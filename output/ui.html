<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<style>


body
{
    margin:           0;
    background-color: #e5e5e5;
}

#container
{
    display: table-column;
}

div
{
    margin:  0;
    padding: 0;
}


.slider
{
    padding:          0;
    width:            74px;
    height:           24px;
    border:           1px solid transparent;
    border-bottom:    1px solid rgba(0, 0, 0, 0.1);
    border-radius:    2px;
    overflow:         hidden;
    background-color: white;
}    

.sliderBar
{
    position:       absolute;
    pointer-events: none;
}

.slider .sliderText
{
    position:       absolute;
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
}

.slider:hover
{
    border: 1px solid rgba(0, 0, 0, 0.1);
}    

.slider:focus
{
    outline: none;
    box-shadow: 0 0 0 2px #18A0FB;
}    


</style>

<div id='container'>


</div>





<script id='generateWorker' type='javascript/worker'>



const Tau = Math.PI * 2;


function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };


function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}

function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}


function vector(angle, dist)
{
    return { 
        x: dist * Math.cos(angle), 
        y: dist * Math.sin(angle) };
}


function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}

function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}

function unitv(v)
{
    return { x: v.x == 0 ? 0 : v.x / lengthv(v),
             y: v.y == 0 ? 0 : v.y / lengthv(v) };
}

function addv(v1, v2)
{
    return { x: v1.x + v2.x,
             y: v1.y + v2.y };
}	


function subv(v1, v2)
{
    return { x: v1.x - v2.x,
             y: v1.y - v2.y };
}	


function mulv(v1, v2)
{
    return { x: v1.x * v2.x,
             y: v1.y * v2.y };
}	

function mulvs(v, s)
{
    return { x: v.x * s,
             y: v.y * s };
}	


function divvs(v, s)
{
    return { x: v.x / s,
             y: v.y / s };
}	


function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return { x:  v.y, 
             y: -v.x };
}


function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	


function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}


function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}


function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        {x:x1, y:y1}, 
        {x:x2, y:y2} ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return {x:NaN, y:NaN}; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return {x:NaN, y:NaN}; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return {x:NaN, y:NaN};
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}


function mulv2m3(v, m)
{
    var r = [0, 0, 0];

    for (var i = 0; i < 3; i++)
    {
        // calculate the dot product of the ith row of m and v
        for (var j = 0; j < 3; j++)
            r[i] += m[i][j] * v[j];
    }

    return {x: r[0], y: r[1]};
}


function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}


function transform(p, xform)
{
    return mulv2m3(p, xform);
}


function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}


function xrotate(angle)
{
    return [[Math.cos(angle), -math.sin(angle), 0],
            [Math.sin(angle),  math.cos(angle), 0],
            [0,                0,               1]];
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }
}


onmessage = function(e)
{
    if (e.data.msg === 'generate')
    {
        var objects = generate(e.data.graph);

        postMessage({ 
            cmd:    'updateCanvas',
            objects: objects
        });
    }
};


function generate(node)
{
    switch (node.type)
    {
        case 'rect'  : return generateRect  (node);
        case 'spread': return generateSpread(node);
    }    
}


function generateRect(node)
{   
    return [{
        id:     node.id,
        type:   node.type,
        x:      0,
        y:      0,
        width:  node.width,
        height: node.height
    }];
}


function generateSpread(node)
{
    var input = generate(node.inputs[0]);


    var rnd = new Random(node.seed);

    result = [];

    for (var i = 0; i < node.count; i++)
    {
        var a = rnd.next() * Tau;
        var d = rnd.next() * node.radius;
        
        var v = vector(a, d);
        
        for (var j = 0; j < input.length; j++)
        {
            var item = Object.assign({}, input[j]);
            
            item.x += v.x;
            item.y += v.y;
            
            result.push(item);
        }
    }

    return result;
}


</script>


<script>

////////////////////////////////////////////////////





const resizeEdgeWidth = 8;

document.canResizeX = false;
document.canResizeY = false;

document.resizingX  = false;
document.resizingY  = false;

document.startX     = 0;
document.startY     = 0;

document.startH     = 0;
document.startW     = 0;


document.addEventListener('pointerdown', function(e)
{
    if (   document.canResizeX
        || document.canResizeY)
    {
        if (document.canResizeX) document.resizingX = true;
        if (document.canResizeY) document.resizingY = true;

        document.startX   = e.clientX;
        document.startY   = e.clientY;

        document.startW   = window.innerWidth;
        document.startH   = window.innerHeight;

        document.body.setPointerCapture(e.pointerId);
    }
});


document.addEventListener('pointermove', function(e)
{
    if (   document.resizingX
        && document.resizingY)
    {
        resizeWindow(
            document.startW + e.clientX - document.startX,
            document.startH + e.clientY - document.startY);
    }
    else if (document.resizingX)
    {
        resizeWindow(
            document.startW + e.clientX - document.startX,
            document.body.clientHeight);
    }
    else if (document.resizingY)
    {
        resizeWindow(
            document.body.clientWidth,
            document.startH + e.clientY - document.startY);
    }
    else
        checkResize(e.clientX, e.clientY);
});


document.addEventListener('pointerup', function(e)
{
    if (   document.resizingX
        || document.resizingY)
    {
        document.resizingX = false;
        document.resizingY = false;
        
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }
});


function resizeWindow(width, height)
{
    parent.postMessage({ pluginMessage: 
    { 
        cmd:    'resizeWindow', 
        width:  width,
        height: height
    }}, '*');

}


function checkResize(x, y)
{
    document.canResizeX = document.body.clientWidth  - x <= resizeEdgeWidth;
    document.canResizeY = document.body.clientHeight - y <= resizeEdgeWidth;

         if (document.canResizeX
          && document.canResizeY) document.body.style.cursor = 'nwse-resize';
    else if (document.canResizeX) document.body.style.cursor = 'ew-resize';
    else if (document.canResizeY) document.body.style.cursor = 'ns-resize';
    else                          document.body.style.cursor = 'auto';
}


class Graph
{
    nodes = new Array();

    #activeNode = null;

    mutex = false;
    defer = false;

    random = new Random();
    randomSeed = this.random.seed; // TODO reset the seed when loading a graph


    get activeNode() { return this.#activeNode; }
    set activeNode(node)
    {
        this.#activeNode = node;
        updateCanvas();
    }


    addNode(node)
    {
        this.nodes.push(node);
        
        node.setGraph(this);
        node.setId(this.getNewId(node)); // TODO: not checking return value here

        document.body.appendChild(node.div);

        this.activeNode = node;
    }


    getNewId(_node)
    {
        var type = _node.type;

        var maxNum = 0;
        
        for (const node of this.nodes)
        {
            if (node == _node)
                continue;
                
            if (   node.id.length < type.length
                || node.id.substring(0, type.length) !== type)
                continue;
                
            var num = parseInt(node.id.substring(type.length));
            
            if (isNaN(num) || num == 0) 
                num = 1;
            
            maxNum = Math.max(num, maxNum);
        }

        if (maxNum == 0)
            return type;

        maxNum++;

        return type + maxNum;
    }
}


const R = 0, G = 1, B = 2, A = 3;
const Eps = 0.0000001;

function nozero(x)
{
    return x != 0 ? x : Eps;
}


function getDigitCount(i)
{
    var l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}


function isDigit(key)
{
    var is = 
           key >= '0' 
        && key <= '9';

    return is;
}

function isHexLetter(key)
{
    var is =
           key.length == 1
        && (   key >= 'A' && key <= 'F'
            || key >= 'a' && key <= 'f');

    return is;
}


function getNumberString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (i < str.length && str[i] !== '.' && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
    str = str.substring(0, i--);
    
    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales    
    str = str.substring(0, i--);
    
    return str;
}    


function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (var property in properties)
        elem.style[property] = properties[property];
}


function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}

function containsChild(parent, child)
{
    return child.parentNode == parent;
}


function forwardEvent(element, event)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}


// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });

//     element.dispatchEvent(e);
// }


function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}


function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}


function colorStyle(rgb)
{
    return colorStyle_(rgb[R], rgb[G], rgb[B], 1);
}


function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}


function isEmptyObject(obj)
{
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}


const Tau = Math.PI * 2;


function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };


function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}

function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}


function vector(angle, dist)
{
    return { 
        x: dist * Math.cos(angle), 
        y: dist * Math.sin(angle) };
}


function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}

function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}

function unitv(v)
{
    return { x: v.x == 0 ? 0 : v.x / lengthv(v),
             y: v.y == 0 ? 0 : v.y / lengthv(v) };
}

function addv(v1, v2)
{
    return { x: v1.x + v2.x,
             y: v1.y + v2.y };
}	


function subv(v1, v2)
{
    return { x: v1.x - v2.x,
             y: v1.y - v2.y };
}	


function mulv(v1, v2)
{
    return { x: v1.x * v2.x,
             y: v1.y * v2.y };
}	

function mulvs(v, s)
{
    return { x: v.x * s,
             y: v.y * s };
}	


function divvs(v, s)
{
    return { x: v.x / s,
             y: v.y / s };
}	


function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return { x:  v.y, 
             y: -v.x };
}


function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	


function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}


function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}


function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        {x:x1, y:y1}, 
        {x:x2, y:y2} ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return {x:NaN, y:NaN}; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return {x:NaN, y:NaN}; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return {x:NaN, y:NaN};
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}


function mulv2m3(v, m)
{
    var r = [0, 0, 0];

    for (var i = 0; i < 3; i++)
    {
        // calculate the dot product of the ith row of m and v
        for (var j = 0; j < 3; j++)
            r[i] += m[i][j] * v[j];
    }

    return {x: r[0], y: r[1]};
}


function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}


function transform(p, xform)
{
    return mulv2m3(p, xform);
}


function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}


function xrotate(angle)
{
    return [[Math.cos(angle), -math.sin(angle), 0],
            [Math.sin(angle),  math.cos(angle), 0],
            [0,                0,               1]];
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }
}


function loadState(state)
{
    resizeWindow(
        window.innerWidth, 
        state.windowHeight);
}    


function save(key, value)
{
    parent.postMessage({ pluginMessage:
    { 
        cmd:   'save', 
        key:   key,
        value: value
    }}, '*');
}


function saveState()
{
    save('state',
    {
        //windowHeight: window.innerHeight
    });
}


class Parameter
{
    #type;
    get type() { return this.#type; }
    
    _op;
    get op() { return this._op; }

    _control;
    get control() { return this._control; }

    constructor(type)
    {
        this.#type = type;
    }
}


class   ValueParam
extends Parameter
{
    #value;

    get value() { return this._control.value; }
    set value(val) { this._control.setValue(val); }


    constructor(name, min, max, val)
    {
        super('value');

        this._control = document.createElement('div');
        this._control.param = this;

        initSlider(
            this._control,
            100,  // width
            20,   // height
            name, 
            min,
            max,
            val,  // default
            0.01, // drag scale
            1,    // wheel step
            0,    // decimals
            0,    // acceleration
            '');  // suffix


        this._control.addEventListener('onchange', function(e)
        {
            this.param.op.valid = false;
            updateCanvas();
            this.param.op.graph.mutex = true;            
        });
    }
}


class Input
{
    _op;
    
    #dataType;

    connectedOutput;

    constructor(dataType)
    {
        this.#dataType = dataType;
    }
    
    get connected() { return this.connectedOutput != null; }

    get data()
    {
        return (
            this.connected
            ? this.connectedOutput.data
            : null);
    }
}


class Output
{
    _op;

    #dataType;
    _data;
    
    connectedInputs = [];


    constructor(dataType)
    {
        this.#dataType = dataType;
    }


    connect(input)
    {
        if (input.connectedOutput != null)
            input.connectedOutput.disconnect(input);

        this.connectedInputs.push(input);
        input.connectedOutput = this;

        updateCanvas();
    }

    disconnect(input)
    {
        var index = this.connectedInputs.indexOf(input);

        if (index >= 0)
        {
            this.connectedInputs[index].connectedOutput = null;
            this.connectedInputs.slice(index, 1);

            updateCanvas();
        }
    }


    get data() 
    {
        return this._op.generate();
    }
}


class Connection
{
    constructor()
    {
        
    }
}


class Operator
{
    #type;
    get type() { return this.#type; }

    _id;
    get id() { return this._id; }

    _graph = null;
    get graph() { return this._graph; }

    setGraph(graph)
    {
        this._graph = graph;
    }
    

    params = [];
    
    inputs = [];
    output;


    #valid = false; // this is the flag for regeneration

    set valid(val) { this.#valid = val; }
    get valid() 
    {
        var valid = this.#valid;

        for (const input of this.inputs)
            valid &= input.valid;

        return valid;
    }


    div; // container for the op's controls
    label;


    constructor(type)
    {
        this.#type = type;
        this._id   = type; // this is a temp until the op becomes a graph node

        this.createDiv();
    }    
    
    
    createDiv()
    {
        this.div = document.createElement('div');
        this.div.op = this;

        this.div.style.display  = 'inline-block';
        this.div.style.position = 'absolute';
        this.div.style.width    = 100;
        this.div.style.height   = 'auto';
        //this.div.style.border = '1px solid red';
        
        this.div.dragging = false;
        
    
        this.div.addEventListener('pointerdown', function(e) 
        {
            if (e.button == 0)
            {
                this.sx  = e.clientX;
                this.sy  = e.clientY;
                this.slx = this.offsetLeft;
                this.sly = this.offsetTop;
    
                this.dragging = true;
                this.setPointerCapture(e.pointerId);
            }
        });
    
        this.div.addEventListener('pointermove', function(e) 
        {
            if (this.dragging)
            {
                this.op.setDivPosition(
                    this.slx + e.clientX - this.sx,
                    this.sly + e.clientY - this.sy);
            };
        });
    
        this.div.addEventListener('pointerup', function(e) 
        {
            if (   e.button == 0
                && this.dragging)
            {
                this.dragging = false;
                this.releasePointerCapture(e.pointerId);
            }
        });
        
        
        this.createDivLabel();
    }     


    createDivLabel()
    {
        this.label = document.createElement('div');
        
        this.label.innerHTML          = this.id;
           
        this.label.style.fontFamily   = 'Inter';
        this.label.style.fontSize     = '11';
        this.label.style.paddingLeft  = '4px';
        this.label.style.display      = 'inline-block';
        this.label.style.width        = 'calc(100% - 2px)';
        this.label.style.height       = 20;
        this.label.style.background   = '#a3d3fd';
        this.label.style.borderRadius = '4px 4px 0 0';
        this.label.style.color        = 'black';
        this.label.style.textAlign    = 'center';
        
        this.div.appendChild(this.label);
    }
    

    setDivPosition(x, y)
    {
        this.div.style.left = x;
        this.div.style.top  = y;
    }


    addInput(input)
    {
        input._op = this;
        this.inputs.push(input);
    }


    setOutput(output)
    {
        if (this.output != null)
            this.output._op = null;

        output._op = this;
        this.output = output;
    }


    addParam(param)
    {
        this.params.push(param);
        
        param._op = this;
        param.control.style.display = 'inline-block';
        
        this.div.appendChild(param.control);
    }
 
    

    setId(newId)
    {
        if (this._graph.nodes.findIndex(node => node.id == newId) >= 0)
            return false; // graph already contains a node with this id

        this._id = newId;
        this.label.innerHTML = newId;

        return true;
    }


    generate() 
    { 
        this.valid = true; 
        return {}; 
    }
}


class   OpRect
extends Operator
{
    #width;
    #height;


    constructor()
    {
        super('rect');

        this.setOutput(new Output('rect'));

        this.addParam(this.#width  = new ValueParam('width',  0.01, Number.MAX_SAFE_INTEGER, 10));
        this.addParam(this.#height = new ValueParam('height', 0.01, Number.MAX_SAFE_INTEGER, 10));
    }


    generate()
    {
        if (!this.valid)
        {
            this.output._data = 
            {
                id:     this.id,
                type:   this.type,
                width:  this.#width .value,
                height: this.#height.value,

                inputs: []
            };
    
            super.generate();
        }
        
        return this.output._data;
    }
}


class   OpSpread 
extends Operator
{
    #count;
    #radius;

    seed = 0;


    constructor()
    {
        super('spread');

        this.addInput (new Input ('rect'));
        this.setOutput(new Output('rect'));
        
        this.addParam(this.#count  = new ValueParam('count',  1,    Number.MAX_SAFE_INTEGER,   2));
        this.addParam(this.#radius = new ValueParam('radius', 0.01, Number.MAX_SAFE_INTEGER, 100));
    }


    setGraph(graph)
    {
        super.setGraph(graph);
        this.seed = this.graph.random.seed;
        this.graph.random.next();
    }

    
    generate()
    {
        if (!this.valid)
        {
            var input = this.inputs[0];
            if (!input.connected) return {};

            this.output._data = 
            {
                id:     this.id,
                type:   this.type,
                count:  this.#count .value,
                radius: this.#radius.value,
                seed:   this.seed,
                inputs: [input.data]
            };
            
            super.generate();
        }

        return this.output._data;
    }
}


function initSliderChildren(slider)
{
    slider.bar = document.createElement('DIV');
    slider.bar.className = 'sliderBar';

    slider.text = document.createElement('DIV');
    slider.text.className = 'sliderText';

    slider.appendChild(slider.bar);
    slider.appendChild(slider.text);
}


function initSlider(slider, width, height, name, min, max, def, dragScale, wheelStep, dec, acc, suffix = '', log = false, backColor = '#fff', valueColor = '#eee', fontSize = 11)
{
    slider.className         = 'slider';

    slider.width             = width;
    slider.height            = height;
        
    slider.style.width       = width;
    slider.style.height      = height;
        
    slider.min               = min;
    slider.max               = max;
    slider.value             = def;
    slider.dec               = dec;
    slider.editDec           = dec;
    slider.acc               = acc;
               
    slider.name              = name;
    slider.suffix            = suffix;
    slider.log               = log;

    slider.dragScale         = dragScale;
    slider.wheelStep         = wheelStep;
        
    slider.backColor         = backColor;
    slider.valueColor        = valueColor;
           
    slider.fontSize          = fontSize;
        
    slider.style.display     = 'inline';
        
    slider.mouseOver         = false;
    slider.buttonDown0       = false;
        
    slider.clickSize         = 4;
    slider.moved             = false;
    
    slider.tabIndex          = 0;
    slider.inFocus           = false;
    slider.clicked           = false;

    slider.wrapValue         = false;
    
    slider.enableChangeEvent = true;

    initSliderChildren(slider);    
    initSliderTextbox(slider);
    
    //

    slider.onchange = new Event('onchange');

    //

    slider.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();

            slider.buttonDown0  = true;
            slider.buttonDown0_ = true;
            slider.moved        = false;
            slider.clientX      = 0;
            slider.sx           = e.clientX;
            slider.sv           = slider.value;

            slider.style.border = '1px solid #18A0FB';
                        
            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();

            slider.clickTimer = setTimeout(function() 
            {
                onSliderClickTimer(slider); 
            }, 500);
        }
    });

    slider.addEventListener('losecapture', function()
    {
        slider.buttonDown0 = false;
        slider.mouseOver  = false;
        slider.update();
    });

    slider.addEventListener('pointerup', function(e)
    {
        clearTimeout(slider.clickTimer);

        if (   slider.moved
            || document.menuHadFocus)
        {
            slider.unlockPointer(e.pointerId);
            return;            
        }    

        if (slider.buttonDown0_)
        {
            slider.clicked = true;
            slider.showTextbox();
        }
        
        slider.buttonDown0_ = false;
    });    


    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && slider.buttonDown0)
        {
            slider.buttonDown0 = false;
            slider.unlockPointer(e.pointerId);

            slider.style.border = '1px solid rgba(0, 0, 0, 0.1)';
        }
    });

    
    slider.addEventListener('pointerenter', function(e)
    {
        slider.style.cursor = 'ew-resize';
    });

    slider.addEventListener('pointerout', function(e)
    {
        slider.style.border       = '1px solid transparent';
        slider.style.borderBottom = '1px solid rgba(0, 0, 0, 0.1)';
        slider.style.cursor       = 'default';
    });


    slider.addEventListener('pointermove', function(e)
    {
        var rect = slider.getBoundingClientRect();
        
        slider.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top
            && e.clientY <  rect.bottom;

        slider.clientX = e.clientX;

        if (slider.buttonDown0)
        {
            slider.style.border = '1px solid #18A0FB';

            if (slider.isPointerLocked())
            {
                slider.movedX += e.movementX;
                
                var dx       = slider.sx - slider.movedX;
                var adaptive = 10 * Math.pow(Math.abs(dx), slider.acc);
    
                // TODO: if (log) do log scaling
                slider.setValue(slider.sv - dx*slider.dragScale*adaptive);
            }
            else
            {
                if (Math.abs(e.clientX - slider.sx) > slider.clickSize/2)
                {
                    slider.moved = true;
                    slider.lockPointer();
                }
            }
        }
        else
            slider.style.border = '1px solid rgba(0, 0, 0, 0.1)';

        slider.update();
    });

    slider.addEventListener('mousewheel', function(e)
    {
        slider.setValue(slider.value + (e.wheelDeltaY > 0 ? 1 : -1) * slider.wheelStep);
    });


    slider.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            slider.showTextbox();
    });


    slider.addEventListener('focus', function()
    {
        slider.showTextbox();
    });

    //

    slider.setValue = function(value, fireChangeEvent = true)
    {
        if (slider.wrapValue)
        {
            while (value < slider.min) value += slider.max - slider.min;
            while (value > slider.max) value -= slider.max - slider.min;
        }
        else
            value = Math.min(Math.max(slider.min, value), slider.max);
        

        slider.value = value;


        var v = value / (slider.max - slider.min);
        var cx = -slider.min / (slider.max - slider.min) * slider.clientWidth;

        slider.bar.style.background = slider.valueColor;

        if (v >= 0)
        {
            slider.bar.style.left  = 1 + slider.offsetLeft + Math.round(cx);
            slider.bar.style.width = Math.round(v * slider.clientWidth);
        }
        else
        {
            slider.bar.style.left  = slider.offsetLeft + cx + v * slider.clientWidth;
            slider.bar.style.width = -v * slider.clientWidth;
        }

        slider.bar.style.background =
            slider.value >= 0
            ? slider.valueColor
            : 'repeating-linear-gradient(-60deg, #fff, #fff 1px, #e5e5e5 2px, #e5e5e5 3px, #fff 4px)';

        slider.bar.style.height = slider.clientHeight;

        slider.text.innerHTML = slider.name + "&nbsp;&nbsp;" + getNumberString(value, slider.dec) + slider.suffix;

        slider.text.style.left = slider.offsetLeft + Math.floor((slider.clientWidth  - slider.text.offsetWidth ) / 2);
        slider.text.style.top  = slider.offsetTop  + Math.floor((slider.clientHeight - slider.text.offsetHeight) / 2) + 1;

        if (   fireChangeEvent
            && slider.enableChangeEvent)
            slider.dispatchEvent(slider.onchange);
    };


    slider.update = function()
    {
        slider.setValue(slider.value, false);
    }


    slider.lockPointer = function()
    {
        slider.requestPointerLock =    
               slider.requestPointerLock 
            || slider.mozRequestPointerLock;

        slider.requestPointerLock();
        clearTimeout(slider.clickTimer);

        slider.movedX = 0;
        slider.sx     = 0;
    };

    slider.unlockPointer = function()
    {
        document.exitPointerLock =    
               document.exitPointerLock    
            || document.mozExitPointerLock;

        document.exitPointerLock();
    };

    slider.isPointerLocked = function()
    {
        return (document.pointerLockElement    === slider 
             || document.mozPointerLockElement === slider);
    }
    
    //

    slider.update();
}


function onSliderClickTimer(slider)
{
    if (!document.menuHadFocus)
    {
        slider.moved = true;
        slider.lockPointer();//slider.clickId);
        //slider.clickId = null;
    }
}


function initSliderTextbox(slider)
{
    slider.textbox = document.createElement('INPUT');
    slider.textbox.setAttribute('type', 'text'); 
    slider.textbox.className = 'sliderTextbox';
    
    slider.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            slider.textbox.finish(true);

        else if (e.code == 'Escape')
            slider.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.slider, .figmaSelect, #hexValue, button');
            var index = slider.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && slider.min < 0))
                e.preventDefault();

            var t = slider.textbox;

            var curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            var nextVal = parseFloat(curVal + e.key);

            if (   nextVal < slider.min - 0.001
                || nextVal > slider.max)
                e.preventDefault();            
        }
    });


    slider.textbox.addEventListener('input', function()
    {
        slider.setValue(Number(slider.textbox.value));
    });

    slider.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(slider.min, val), slider.max);

        slider.textbox.value = isNaN(val) ? '' : val;
    });

    slider.textbox.addEventListener('focusout', function()
    {
        slider.parentNode.removeChild(slider.textbox);
        slider.clicked = false;
    });
    
    slider.textbox.finish = function(success)
    {
        if (success) slider.setValue(Number(slider.textbox.value     ), false);
        else         slider.setValue(Number(slider.textbox.savedValue), true );

        slider.textbox.blur();

        if (slider.inFocus)
            slider.focus();
    };    
    
    
    slider.showTextbox = function()
    {
        slider.inFocus = 
                slider == document.activeElement
            && !slider.clicked;
    
        slider.textbox.style.position = 'absolute';
    
        slider.textbox.style.left      = slider.offsetLeft   + 1;
        slider.textbox.style.top       = slider.offsetTop    + 1;
        slider.textbox.style.width     = slider.offsetWidth  - 2;
        slider.textbox.style.height    = slider.offsetHeight - 2;
        slider.textbox.style.boxShadow = '0 0 0 2px #18A0FB';
        slider.textbox.style.outline   = 'none';
    
        slider.textbox.style.textAlign = 'center';
    
        slider.textbox.value = numToString(slider.value, slider.editDec);
        slider.textbox.savedValue = slider.textbox.value;
        
        slider.parentNode.appendChild(slider.textbox);
        
        slider.textbox.focus();
        slider.textbox.select();
    }
}


var worker = new Worker(
    window.URL.createObjectURL(
        new Blob([generateWorker.textContent])));
      

function updateCanvas()
{
    if (graph.mutex)
    {
        graph.defer = true;
        return;
    }

    graph.mutex = true;


    var updateData = graph.activeNode.output.data;

    if (!isEmptyObject(updateData))
    {
        worker.postMessage(
        {
            msg:    'generate',
            graph:  updateData
        });
    }
}


worker.onmessage = function(e)
{
    if (e.data.cmd == 'updateCanvas')
    {
        parent.postMessage({ pluginMessage: 
        { 
            cmd:  'updateCanvas',
            data: e.data.objects
        }}, '*');

        graph.mutex = false;

        if (graph.defer)
        {
            graph.defer = false;
            updateCanvas();
        }
    }
};


//save('state', null);
//save('windowWidth', null);
//save('windowHeight', null);


parent.postMessage({ pluginMessage: 
{ 
    cmd:    'loadState',
    onLoad: 'loadState'
}}, '*');


// onmessage = (e) =>
// {
//     var msg = e.data.pluginMessage;
// }



/////////////////////////////////////////////////////////


var graph = new Graph();

var opRect    = new OpRect();
var opSpread1 = new OpSpread();
var opSpread2 = new OpSpread();

graph.addNode(opRect);
graph.addNode(opSpread1);
graph.addNode(opSpread2);

opRect   .output.connect(opSpread1.inputs[0]);
opSpread1.output.connect(opSpread2.inputs[0]);




////////////////////////////////////////////////////

</script>
