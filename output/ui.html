<!-- <link rel="preconnect" href="https://rsms.me/">
<link rel="stylesheet" href="https://rsms.me/inter/inter.css"> -->

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>


/* :root
{
} */


:root 
{
    --data-mode-node:        #fed;
    --data-mode-node-active: #fdb;

    --data-mode-conn:        #cfc;
    --data-mode-conn-active: #aea;
}


#dataModeView
{
    position:   absolute;
    left:       0;
    top:        0;
    width:      100%;
    height:     100%;
    display:    none;
    background: var(--figma-color-bg);
    z-index:    4;
}



#dataModeTitleBar
{
    padding: 13px 12px 14px 17px;
}


#dataModeContent
{
    overflow-y: scroll;
    height:     calc(100% - 43px);
}


#dataModeContent::-webkit-scrollbar
{
    background: transparent;
    width:      6px;
}


#dataModeContent::-webkit-scrollbar-track
{
    margin: 6px 6px 6px 0;
}


#dataModeContent::-webkit-scrollbar-thumb
{
    border-radius: 4px;
}


.figma-dark #dataModeContent::-webkit-scrollbar-thumb
{ 
    background:    #fff4;
    /* background-color: #0006;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}

.figma-light #dataModeContent::-webkit-scrollbar-thumb
{ 
    background-color: #0004;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}    


.dataModeRowWrapper
{
    padding:         13px 12px 20px 13px;
    border-bottom:   1px solid var(--figma-color-bg-tertiary);
}


.dataModeRowTitle
{
    font-family:    Inter;
    font-size:      11px;
    color:          var(--figma-color-text);
    font-weight:    600;
    margin:         4px 0 15px 4px;
}


.dataModePage
{
    font-family:    Inter;
    font-size:      11px;
    text-align:     center;
    display:        inline-block;
    min-width:      50px;
    min-height:     14px;
    background:     var(--data-mode-node); 
    border-radius:  3px;
    margin:         2px 0px 0px 3px;
    padding:        4px 4px;
    box-shadow:     0 0 0 1px #dac inset;
    white-space:    pre;
    vertical-align: top;
}


.dataModeNode
{
    font-family:    Inter;
    font-size:      11px;
    text-align:     center;
    display:        inline-block;
    min-width:      50px;
    background:     var(--data-mode-node); 
    border-radius:  3px;
    margin:         2px 0px 0px 3px;
    padding:        4px 4px;
    box-shadow:     0 0 0 1px #dca inset;
    white-space:    pre;
    vertical-align: top;
}


.dataModeConn
{
    font-family:    Inter;
    font-size:      11px;
    text-align:     center;
    display:        inline-block;
    min-width:      70px;
    background:     var(--data-mode-conn); 
    border-radius:  3px;
    margin:         2px 0px 0px 3px;
    padding:        4px 0px;
    box-shadow:     0 0 0 1px #ad8 inset;
    white-space:    pre;
    vertical-align: top;
}


.pageDataHeader
{
    border-bottom: 1px solid #b8a; 
    padding:       0px 11px 4px 9px;
}


.pageDataBody
{
    padding:       4px 11px 0px 0px;
}


.nodeDataHeader
{
    border-bottom: 1px solid #ba8; 
    padding:       0px 11px 4px 9px;
}


.nodeDataBody
{
    padding:       4px 11px 0px 0px;
}


.connDataHeader
{
    border-bottom: 1px solid #8b6; 
    padding:       0px 11px 4px 9px;
}


.connDataBody
{
    padding:       4px 11px 0px 0px;
}


.dataUndefined
{
    background: red;
    color:      white;
    padding:    0 3px;
}


.dialogButtonClose
{
    width:      32px;
    height:     32px;
    position:   absolute;
    left:       calc(100% - 36px);
    top:        4px;
    /* display:    none; */
}


.dialogButtonClose:active
{
    box-shadow: none;
}



#debugInfo
{
    color:            var(--figma-color-text);
    position:         absolute;
    left:             0;
    top:              40px;
    width:            100%; 
    height:           calc(100% - 40px);
    z-index:          100000;
    /* background-color: blue; */
    pointer-events:   none;
}



#commonProgressBar
{
    display:          none;
    background-color: var(--figma-color-bg-brand);
    height:           5px;
    position:         absolute;
    left:             0;
    top:              40px;
    z-index:          20;
}


#loadingOverlay
{
    position: absolute;
    left:     0;
    top:      0;
    width:    100%;
    height:   100%;
    display:  block;
    z-index:  10;
}


.figma-light #loadingOverlay { background: #f0f0f0; } /* my tuning of bg-tertiary */
.figma-dark  #loadingOverlay { background: #1e1e1e; }


#loadingGraphic
{
    display:     none;
    font-family: Inter;
    font-size:   26;
    font-weight: 800;
    color:       var(--figma-color-text);/*#333;*/
    position:    absolute;
    left:        50%;
    top:         50%;
    width:       184px;
    height:       64px;
    transform:   translateX(-50%)
                 translateY(-50%);
    /* box-shadow:  0 0 0 1px red inset; */
}


.figma-light #loadingGraphic { font-weight: 800; }
.figma-dark  #loadingGraphic { font-weight: 600; }


#loadingG 
{
    position:  absolute;
    left:      50%;
    top:       40%;
    transform: translateX(-50%)
               translateY(-50%);
}

#loadingEmpty, #loadingFull
{
    position:  absolute;
    left:      calc(50% - 4px);
    top:       calc(40% - 4px);
}

#loadingG     > path { fill: var(--figma-color-text);            }

#loadingEmpty        { animation: emptyOrbit 5s linear infinite; }
#loadingEmpty > path { fill:var(--figma-color-text);             }

#loadingFull         { animation: fullOrbit 5s linear infinite;  }
#loadingFull  > path { fill: var(--figma-color-text);            }


@keyframes emptyOrbit
{
      0%   { transform: rotate(   0deg) translate(-20px) scale(100%);  opacity: 100%; }
     10%   { transform: rotate(-170deg) translate(-20px) scale(100%);  opacity: 100%; }
     11.3% { transform: rotate(-180deg) translate(-20px) scale(130%);  opacity: 100%; }
     15.3% { transform: rotate(-180deg) translate(-20px) scale(130%);  opacity: 100%; }
     20%   { transform: rotate(-180deg) translate(-20px) scale( 50%);  opacity:   0%; }
     23.4% { transform: rotate(-360deg) translate(-20px) scale(150%);  opacity:   0%; }
     26.7% { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     50%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     62%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     63.3% { transform: rotate(-360deg) translate(-20px) scale(130%);  opacity: 100%; }
     65.3% { transform: rotate(-360deg) translate(-20px) scale(130%);  opacity: 100%; }
     68%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     73.3% { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     80%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
    100%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
}


@keyframes fullOrbit
{
      0%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     12%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     12.7% { transform: rotate(   0deg) translate(20px) scale( 75%);  opacity: 100%; }
     13.3% { transform: rotate(   0deg) translate(20px) scale( 75%);  opacity: 100%; }
     22%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     23.4% { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     30%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     50%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     62%   { transform: rotate(-170deg) translate(20px) scale(100%);  opacity: 100%; }
     63.3% { transform: rotate(-180deg) translate(20px) scale( 50%);  opacity: 100%; }
     65.3% { transform: rotate(-180deg) translate(20px) scale( 50%);  opacity: 100%; }
     68%   { transform: rotate(-180deg) translate(20px) scale(  0%);  opacity:   0%; }
     73.4% { transform: rotate(   0deg) translate(20px) scale( 80%);  opacity:   0%; }
     76.7% { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
    100%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
}


#loadingBar
{
    position:      absolute;
    left:          50%;
    bottom:          0;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         180px;
    height:        5px;
    border-radius: 2.5px;
    overflow:      hidden;
    /* box-shadow:    0 0 0 1px yellow inset; */
}


.figma-light #loadingBar { background: white; }
.figma-dark  #loadingBar { background: var(--figma-color-bg-tertiary); }


#loadingProgress
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         0;
    height:        5px;
    background:    var(--figma-color-text);
}


#btnLoadingRestart
{
    position:      absolute;
    left:          50%;
    top:           calc(75%);
    transform:     translateX(-50%)
                   translateY(-50%);
}


.btnRestart
{
    position:      static;
    font-family:   Inter;
    font-weight:   500;
    font-size:     11px;
    color:         var(--figma-color-text);
    padding:       10px 13px 10px 13px;
    border-radius: 6px;
    box-shadow:    0 0 0 1px inset var(--figma-color-text);
    width:         fit-content;
    /* display:       none; */
}


.btnRestart:active
{
    box-shadow:    0 0 0 2px inset var(--figma-color-bg-brand);
    background:    var(--figma-color-bg-pressed);
}


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    padding-top:   1px; 
    height:        20px;
    line-height:   14px;
    border:        none;
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:focus
{
    box-shadow: 0 0 0 1px var(--activeObjectColor) inset;
    outline:    none;
}


input[type=text]::selection
{
    background-color: var(--figma-color-bg-brand);
    color:            white;
}


@import url('https://rsms.me/inter/inter.css');
html { font-family: 'Inter', sans-serif; }

@supports (font-variation-settings: normal) 
{
  html { font-family: 'Inter var', sans-serif; } 
}


body
{
    margin:                0;
    user-select:           none;
    font-family:           Inter;

    -webkit-touch-callout: none; 
      -webkit-user-select: none; 
       -khtml-user-select: none; 
         -moz-user-select: none; 
          -ms-user-select: none; 
              user-select: none; 

    overflow:              hidden;
}


/* body:active
{
    box-shadow: 0 0 0 1px red inset;
} */


.figma-light body { background: #f4f4f4; }
.figma-dark  body { background: #252524; }


div
{
    margin:  0;
    padding: 0;
}


.windowSizerEdge
{
    position:   absolute;
    background: var(--edgeBack);
    z-index:    10001;
    /* box-shadow: 0 0 0 1px blue inset; */
}


.windowSizerH
{
    top:    var(--defHeaderHeight);
    /* top:    var(--sizeBorderWidth); */
    /* height: calc(100% - calc(2 * var(--sizeBorderWidth))); */
    width:  var(--windowBorderWidth);
    height: calc(100% - calc(25px + var(--windowBorderWidth)));
    cursor: ew-resize;
}


/* #windowSizerL { left:  0; } */
#windowSizerR { right: 0; }


.windowSizerV
{
    left:   var(--windowBorderWidth);
    width:  calc(100% - calc(2 * var(--windowBorderWidth)));
    height: var(--windowBorderWidth);
    cursor: ns-resize;
}


#windowSizerB { bottom: 0; }


.windowSizerCorner
{
    position:   absolute;
    width:      var(--windowBorderWidth);
    height:     var(--windowBorderWidth);
    background: var(--cornerBack);
    z-index:    10001;
    /* box-shadow: 0 0 0 1px yellow inset; */
}


/* #windowSizerBL
{
    left:   0;
    bottom: 0;
    cursor: nesw-resize;
} */


#windowSizerBR
{
    right:  0;
    bottom: 0;
    cursor: nwse-resize;
}


#keyboardPanel
{
    display:       none;
    background:    #1E1E1E;
    width:         calc(100% - 2px);
    height:        240px;
    position:      absolute;
    bottom:        0;
    border-top:    1px solid #ffffff25;
    border-bottom: 1px solid #ffffff0d;
    border-left:   1px solid #ffffff08;
    border-right:  1px solid #ffffff08;
    z-index:       100;
}


#keyboardPanelTabsHolder
{
    height:        36px;
    overflow:      hidden;
    position:      relative;
    /* box-shadow:    0 0 0 1px inset red; */
    z-index:       1;
}


#keyboardPanelTabs
{
    display:    flex;
    width:      fit-content;
    height:     36px;
    position:   absolute;
    left:       50%;
    transform:  translateX(-50%);
    /* box-shadow: 0 0 0 1px inset blue;    */
}


#keyboardPanelTab
{
    background:    #1E1E1E;
    color:         #b6b6b6;
    font-size:     12px;
    font-weight:   500;
    display:       inline;
    padding-left:  16px;
    padding-right: 16px;
    padding-top:   10px;
    margin:        0;
    height:        26px;
    /* box-shadow:    0 0 0 1px inset green;    */
}


#keyboardPanelTab:hover
{
    color:         #f6f6f6;
}


#keyboardPanelClose
{
    position:            absolute;
    top:                 0;
    right:               0;
    width:               35px;
    height:              35px;
    background:          url('data:image/svg+xml;utf8,<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><path id="keyboardCloseX" fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="%23777"/></svg>');
    background-position: 50% calc(50% - 1px);
    background-repeat:   no-repeat;
}


#keyboardPanelClose:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><path id="keyboardCloseX" fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="%23f6f6f6"/></svg>');
    background-position: 50% calc(50% - 1px);
    background-repeat:   no-repeat;
}


#keyboardPanelContent
{
    position:   absolute;
    top:        35px;
    background: #1E1E1E;
    border-top: 1px solid #ffffff1b;   
    width:      100%;
    height:     206px;
    /* box-shadow: 0 0 0 1px inset orange; */
    z-index:    0;
}


.keyboardPage
{
    display:        flex;
    position:       absolute;
    left:           50%;
    top:            0;
    transform:      translateX(-50%);
    padding-top:    6px;
    width:          max-content;
    height:         calc(100% - 7px);
    /* box-shadow:     0 0 0 1px inset red; */
}


.keyboardGroup
{
    display:        inline-block;
    width:          300px;
    height:         auto;
    vertical-align: top;
    /* box-shadow:     0 0 0 1px inset yellow; */
}


.nextGroup
{
    margin-left: 46px;
}


.keyboardLabel
{
    display:     inline-block;
    font-size:   12px;
    font-weight: 600;
    color:       #757575;
    width:       300px;
    height:      26px;
    padding-top: 11px;
    /* box-shadow:  0 0 0 1px inset green; */
}


.keyboardInfo
{
    display:     inline-block;
    font-size:   12px;
    color:       #b6b6b6;
    font-weight: 500;
    width:       300px;
    height:      26px;
    padding-top: 11px;
    /* box-shadow:  0 0 0 1px inset green; */
}


.keyboardShortcut
{
    display:    inline-block;
    position:   relative;
    width:      300px;
    height:     37px;
    /* box-shadow: 0 0 0 1px inset green; */
}


.shortcutAction
{
    position:    absolute;
    left:        0;
    top:         50%;
    transform:   translateY(calc(-50% - 1px));
    display:     inline-block;
    font-size:   12px;
    font-weight: 500;
    color:       #bcbcbc;
    width:       fit-content;
    /* box-shadow:  0 0 0 1px inset blue; */
}


.shortcutKeys
{
    position:    absolute;
    right:       0;
    top:         50%;
    transform:   translateY(-50%);
    display:     flex;
    width:       fit-content;
    white-space: nowrap;
    /* box-shadow:  0 0 0 1px inset magenta; */
}


.shortcutKey
{
    font-family:             Inter;
    display:                 inline-block;
    font-size:               11px;
    color:                   #bcbcbc;
    margin-left:             3px;
    margin-right:            0px;
    padding-left:            5px;
    padding-right:           5px;
    padding-top:             5px;
    width:                   max(20px, fit-content);
    height:                  19px;
    border-radius:           2px;
    box-shadow:              0 0 0 1px inset #bcbcbc;
    font-variant-alternates: stylistic(), styleset();
    font-feature-settings:   'salt' on, 'ss02' on;
}


.shortcutEvent
{
    font-family:             Inter;
    display:                 inline-block;
    font-size:               11px;
    color:                   #bcbcbc;
    margin-left:             3px;
    margin-right:            0px;
    padding-left:            5px;
    padding-right:           5px;
    padding-top:             5px;
    width:                   max(20px, fit-content);
    height:                  19px;
    border-radius:           2px;
    font-variant-alternates: stylistic(), styleset();
    font-feature-settings:   'salt' on, 'ss02' on;
}


.shortcutChar
{
    padding-left:  9px;
    padding-right: 9px;
}

.shortcutCharWide
{
    padding-left:  5px;
    padding-right: 5px;
}

.shortcutCharNarrow
{
    padding-left:  9px;
    padding-right: 9px;
}



#pagesBar
{
    display:          flex;
    flex-wrap:        nowrap;
    flex-grow:        1 1;
    width:            100%;
    height:           36px;
    background-color: #1e1e1e;
    padding:          0;
    cursor:           default;
    position:         relative;
    z-index:          0;
    white-space:      nowrap;
    /* box-shadow:       0 0 0 1px red inset; */
}


.page
{
    /* flex:          0 1 auto; */
    flex-shrink:   1;
    font-family:   Inter;
    font-size:     11px;
    display:       inline-block;
    /* width:         auto; */
    /* min-width:     100px; */
    max-width:     272px;
    height:        calc(100% - 11px);
    outline:       1px solid var(--figma-color-bg-tertiary);
    padding-top:   11px;
    padding-right: 10px
}


.pageIcon
{
    display:      inline-block;
    width:        14px;
    height:       14px;
    margin-left:  13px;
    /* box-shadow:   0 0 0 1px red inset; */
}


.pageName
{
    display:     inline-block;
    flex-shrink: 1;
    /* height:  fit-content; */
    /* box-shadow: 0 0 0 1px orange inset; */
    margin-left: 9px;
    position:    relative;
    top:        -3px;
}


.pageClose
{
    display:     inline-block;
    position:    relative;
    top:         -2px;
    width:       8px;
    height:      8px;
    /* box-shadow:  0 0 0 1px green inset; */
    margin-top:  2px;
    margin-left: 13px;
}


#btnAddPage
{
    /* flex-shrink: 0 0 34px; */
    display:       inline-block;
    position:      relative;
    left:          1px;
    outline:       none;
    /* width:         34px; */
    height:        calc(100% - 13px);
    padding-top:   13px;
    padding-left:  11px;
    padding-right: 12px;
    /* box-shadow:    0 0 0 1px orange inset; */
}


#search
{
    width:            400px;
    height:           48px;
    position:         absolute;
    left:             50%;
    top:              116px;
    transform:        translateX(-50%);
    border-radius:    6px;
    overflow:         hidden;
    z-index:          100000000;
    display:          none;
}


.figma-light #search
{
    background-color: white;
    box-shadow:       0 0      0   1px #00000005,
                      0 3px    5px 0   #0101001c,
                      0 10px  20px 0   #01010026;
}


.figma-dark #search
{
    background-color: #2c2c2c;
    box-shadow:       0 0      1px 0 #fff5 inset,
                      0 1px    1px 0 #ffffff18 inset,
                      0 5px   10px 0 #0005,
                      0 10px  25px 0 #0005;
}


#searchIcon
{
    width:        19px;
    height:       19px;
    /* box-shadow:   0 0 0 1px red inset; */
    display:      block;
    position:     absolute;
    left:         14px;
    top:          14px;
    padding-left: 3px;
    padding-top:  3px;
}


.figma-dark  #searchIconPath { fill: white; }
.figma-light #searchIconPath { fill: black; }


#searchText
{
    display:          block;
    background-color: transparent;
    pointer-events:   all;
    font-family:      Inter;
    font-size:        13px;
    width:            100%;
    height:           48px;
    padding-left:     48px;
    padding-right:    15px;
    /* box-shadow:       0 0 0 1px red inset; */
    border:           none;
    outline:          none;
}


#searchText:hover
{
    border:     none;
    outline:    none;
    box-shadow: none;
}

#searchText:focus
{
    border:     none;
    outline:    none;
    box-shadow: none;
}


.figma-dark #searchText::placeholder
{
    color:      #797979;
    font-weight: 600;
}


.figma-light #searchText::placeholder
{
    color:      #c4c4c4;
    font-weight: 300;
}



#searchResults
{
    width:      100%;
    height:     auto;
    max-height: 304px;
    /* box-shadow: 0 0 0 1px red inset; */
    overflow-y: scroll;
    margin:     0;
}



#noSearchResults
{
    width:       100%;
    height:      auto;
    display:     none;
    /* box-shadow:  0 0 0 1px red inset; */
    font-family: Inter;
    font-size:   13px;
    position:    absolute;
    top:         56px;
    left:        48px
}


.figma-dark  #noSearchResults 
{
    font-weight: 500;
    color:     #7d7d7d;
}

.figma-light #noSearchResults 
{
    color: #444;    
}



#searchResults::-webkit-scrollbar
{
    background: transparent;
    width:      0;
    height:     0;
}


#searchResults::-webkit-scrollbar-track
{
    margin: 0;
}


#searchResults::-webkit-scrollbar-thumb
{
    background: transparent;
}


#searchItems
{
    width:      100%;
    /* box-shadow: 0 0 0 1px yellow inset; */
    margin: 0;
}



.resultItem
{
    font-family:  Inter;
    font-size:    13px;
    display:      inline-block;
    /* box-shadow:   0 0 0 1px green inset; */
    width:        100%;
    height:       24px;
    padding-left: 48px;
    padding-top:   8px;
    position:     relative;
} 


.figma-dark .resultItem
{
    color:       white;
    font-weight: 600;
}

.figma-light .resultItem
{
    color:       #444;
    font-weight: 400;
}


.resultIcon
{
    width:          19px;
    height:         auto;
    line-height:    19px;
    /* box-shadow:     0 0 0 1px red inset; */
    display:        block;
    position:       absolute;
    left:           15px;
    top:            50%;
    transform:      translateY(-50%);
    text-align:     center;
}


.resultLegend
{
    width:          3px;
    height:         18px;
    display:        block;
    position:       absolute;
    left:           0px;
    top:            50%;
    transform:      translateY(-50%);
    background:     transparent;
}



.tooltipPre /* to avoid FOUC (flash of unstyled content) */
{
    font-family: Inter;
    font-size:   12px;
}


.tooltip
{
    display:          none;
    font-family:      Inter;
    font-size:        11px;
    opacity:          0;
    width:            auto;
    height:           15px;
    background-color: #1e1e1e;
    color:            #eee;
    border-radius:    2px;
    padding:          5px 10px 5px 10px;
    position:         absolute;
    z-index:          10000;
    bottom:           125%;
    left:             13px;
    top:              44px;
    overflow:         hidden;
}


.tooltip p
{
    margin: 0;
}


.figma-light .tooltip
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.15),
                      0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark .tooltip
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.35),
                      0px 5px 22px rgba(0, 0, 0, 0.35),
                      0 0px 2px 0px #fff1 inset,
                      0 0.5px 1px 0px #fff2 inset;
}


#tooltipArrow
{
    content:        '';
    position:       absolute;
    margin-left:   -7px;
    border-width:   7px;
    border-style:   solid;
    border-color:   transparent transparent #1e1e1e transparent;
    display:        none;
    opacity:        0%;
    z-index:        20000;
    pointer-events: none;
}


.tooltipBottom
{
    display:    block;
    width:      100%;
    height:     25px;    
    position:   absolute;
    left:       0;
    bottom:     0;
    box-shadow: 0 1px 0 0px inset #ffffff1b;
}


.ignoreButton
{
    border-left: 1px solid #ffffff1b;
    position:    absolute;
    right:       0px;
    text-align:  center;
    width:       74px;
    height:      20px;
    padding-top: 6px;
}


.ignoreButton:hover
{
    background: #ffffff1b;
}


#ttColorblind
{
    width:        208px; 
    height:       322px;
    padding-left: 20px;
}


#ttMinValueZoom
{
    width: max(188px, auto);
}


#ttInterpolationSpace
{
    width:  193px;
    height: 228px;
}    


#ttWcag2
{
    width:  240px;
    height: 140px;
}    

.wcag2description
{
    text-align:       left;
    position:         absolute;
    top:              56px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag2value
{
    position:  absolute;
    top:       102px;
    transform: translateX(-50%);
}


#wcag2info
{
    position:  absolute;
    left:      50%;
    top:       120px;
    transform: translateX(-50%);
}


#wcag2info a
{
    color: #6eb8e9
}


#ttWcag3
{
    width:  240px;
    height: 130px;
}


.wcag3description
{
    text-align:       left;
    position:         absolute;
    top:              46px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag3value
{
    position:  absolute;
    top:       90px;
    transform: translateX(-50%);
}


#wcag3info
{
    position:  absolute;
    left:      50%;
    top:       100px;
    transform: translateX(-50%);
}


#wcag3info a
{
    color: #6eb8e9
}


#ttText
{
    padding:     0;
    height:      fit-content;
    /* box-shadow: 0 0 0 1px orange inset; */
}


#ttTextString
{
    display:     inline-block;
    padding:     10px;
    width:       auto;
    height:      auto;
    max-width:   400px;
    white-space: pre-wrap;
    /* box-shadow: 0 0 0 1px red inset; */
}


#tooltipTextBottom
{
    position: static;
}


#selectBox
{
    outline:          1pt solid var(--figma-color-bg-brand);
    background-color: #18A0FB20;
    pointer-events:   none;
    margin:           0;
    padding:          0;
    position:         absolute;
    visibility:       hidden;
}


#scrollbarX
{
    height: 6px;
}


#scrollbarY
{
    width: 6px;
}


.scrollbar
{
    border-radius:    4px;
    position:         absolute;
    display:          none;
}


.figma-light .scrollbar 
{ 
    background-color: #0004;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}


.figma-dark .scrollbar 
{ 
    background-color: #0006;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}


.dialogScrollbar
{
    border-radius:    4px;
    position:         absolute;
    display:          none;
}


.figma-light .dialogScrollbar 
{ 
    background-color: var(--figma-color-text-tertiary);
    /* box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}

.figma-dark .dialogScrollbar 
{ 
    background-color: var(--figma-color-text-tertiary);
    /* box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}


input[type=text]
{
    color:      var(--figma-color-text);
    background: var(--figma-color-bg);
}


input[type=text]:hover
{
    box-shadow: 0 0 0 1px var(--figma-color-bg-tertiary);
}


input[type=text]:focus
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
    outline:    none;
}


input[type=text]::selection
{
    color:            var(--figma-color-bg-inverse);
    background-color: var(--figma-color-border-brand);
}


a
{
    color: var(--figma-color-text-brand);
}


#whatsNewBack
{
    display:          none;

    z-index:          1000;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    pointer-events:   all;

    background-color: #0005;
}



#whatsNewDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       1002;
    position:      absolute;
    top:           58px;
    left:          calc(50%);
    transform:     translateX(-50%);
    width:         600px;
    height:        calc(100% - 80px);

    overflow:      hidden;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;
}


#whatsNewDialogContainer
{
    height:   calc(100% - 42px);
    overflow: hidden;
    padding:  0;
    z-index:  1;
    /* box-shadow: 0 0 0 1px red inset; */
}


#whatsNewDialogContent
{
    font-size:      12px;
    margin:         0;
    padding:        1px 0 5px 0;
    position:       absolute;
    pointer-events: all;
    user-select:    text;
    /* box-shadow:  0 0 0 1px blue inset; */
}


.figma-light #whatsNewDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #whatsNewDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#whatsNewWatermark
{
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-41%)
                    translateY(-34%);
    font-size:      800px;
    font-weight:    600;
    white-space:    nowrap;
    color:          var(--figma-color-bg-secondary);
    z-index:        -1;
    user-select:    none;
    pointer-events: none;
}



#whatsNewTitle
{
    position:       relative;
    height:         40px;
    border-bottom:  1px solid rgb(0, 0, 0, 0.15);
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
    background:     var(--figma-color-bg);
    z-index:        10;
}


#whatsNewTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);

    pointer-events: none;
    user-select:    none;
}


#whatsNewBody
{
    margin:  0 30px 0 30px;
}



#chkHideWhatsNew
{
    display:  inline-block;
}



#whatsNewScrollbarY
{
    width:   6px;
    z-index: 1;
    margin:  6px 0 18px 0;
    display: none;
}






#aboutBack
{
    display:          none;

    z-index:          10;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    pointer-events:   all;

    background-color: #0005;
}



#aboutDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       20;
    position:      absolute;
    top:           50%;
    left:          50%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         280px;
    height:        168px;

    overflow:      hidden;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;
}


#aboutDialogContainer
{
    height:   calc(100% - 22px);
    overflow: hidden;
    padding:  0;
    z-index:  1;
    /* box-shadow: 0 0 0 1px red inset; */
}


#aboutDialogContent
{
    font-size: 12px;
    margin:    0;
    padding:   1px 0 5px 0;
    position:  absolute;
    pointer-events: all;
    user-select: text;
    /* box-shadow: 0 0 0 1px blue inset; */
}


.figma-light #aboutDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #aboutDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#aboutTitle
{
    position:       relative;
    height:         40px;
    border-bottom:  1px solid rgb(0, 0, 0, 0.15);
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
    background:     var(--figma-color-bg);
    z-index:        10;
}


#aboutTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);

    pointer-events: none;
    user-select:    none;
}


#aboutDialogBody
{
    padding-left: 30px;
    width:        250px;
    /* box-shadow:   0 0 0 1px inset yellow; */
}


#chkAboutHideWhatsNew
{
    display:  inline-block;
}


#aboutBrainshiftLogo
{
    display:   none;
    position:  absolute;
    left:      97px;
    top:       82px;
}


#aboutGeneratorLogo
{
    position: absolute;
    left:     30px;
    top:      48px;
}


#aboutLine
{
    position: absolute;
    left:     18px;
    top:      132px;
}


#aboutVersion
{
    font-weight: 300;
    font-size:   11px;
    display:     inline;
    position:    absolute;
    left:        100px;
    top:         44px;
}


#aboutCopyright
{
    font-weight: 300;
    font-size:   11px;
    display:     inline-block;
    width:       max-content;
    position:    absolute;
    left:        99px;
    top:         62px;
}


.figma-dark  #aboutVersion   { font-weight: 200; }
.figma-dark  #aboutCopyright { font-weight: 200; }

.figma-light #aboutVersion   { font-weight: 400; }
.figma-light #aboutCopyright { font-weight: 400; }


#aboutUserId
{
    font-size:      11px;
    text-align:     center;

    margin-top:     0px;
    margin-bottom:  12px;

    position:       absolute;
    
    left:           50%;
    transform:      translateX(-50%);

    top:            94px;

    width:          300px;

    user-select:    text;
    line-height:    1.4em;

    overflow:       visible;

    /* box-shadow:  0 0 0 1px green inset; */
}


#licenseInfo
{
    font-family:   'Inter';
    font-size:      11px;
    font-weight:    300;

    width:          350px;
    height:         auto;
    padding-top:    4px;
    padding-bottom: 0;

    margin-bottom:  -3px;

    background:     transparent;

    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);
    top:            60px;


    pointer-events: none;

    text-align:     center;

    /* box-shadow:     0 0 0 1px red inset; */
}

.figma-dark  #licenseInfo { font-weight: 200; }
.figma-light #licenseInfo { font-weight: 400; }





#crashBack
{
    display:          none;

    z-index:          10000;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    pointer-events:   all;

    background-color: #0005;
}



#crashDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       10001;
    position:      absolute;
    top:           50%;
    left:          50%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         440px;
    height:        300px;

    overflow:      hidden;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;

    /* -webkit-font-smoothing: subpixel-antialiased;
    -moz-osx-font-smoothing: auto; */
}


#crashDialogContainer
{
    height:   calc(100% - 42px);
    overflow: hidden;
    padding:  0;
    z-index:  1;
    /* box-shadow: 0 0 0 1px red inset; */
}


#crashDialogContent
{
    font-size:      12px;
    margin:         0;
    padding:        1px 0 5px 0;
    position:       absolute;
    pointer-events: all;
    user-select:    text;
    width:          100%;
    /* box-shadow:     0 0 0 1px blue inset; */
}


.figma-light #crashDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #crashDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#crashTitle
{
    font-size:     14px;
    font-weight:   500;
    margin-top:    20px;
    margin-bottom: 27px;
}


#crashDetails
{
    /* font-weight: bold; */
    height:        165px;
    margin-bottom: 30px;
    position:      relative;
    left:          1px;
    overflow-y:    scroll;
    /* box-shadow:    0 0 0 1px red inset; */
}


#crashDetails::-webkit-scrollbar
{
    background: transparent;
    width:      6px;
}


#crashDetails::-webkit-scrollbar-track
{
    margin: 6px 6px 6px 0;
}


#crashDetails::-webkit-scrollbar-thumb
{
    border-radius: 4px;
}


.figma-dark #crashDetails::-webkit-scrollbar-thumb
{ 
    background:    #fff4;
    /* background-color: #0006;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}


.figma-light #crashDetails::-webkit-scrollbar-thumb
{ 
    background-color: #0004;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}    


#crashDialogBody
{
    margin: 0 25px 0 25px;
}


#btnCrashRestart
{
    position: absolute;
    right:    24px;
    bottom:   21px;
}





#deleteConnectionsDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    width:         400px;
    height:        92px;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border-radius: 4px;
}


.figma-light #deleteConnectionsDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #deleteConnectionsDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#deleteConnectionsTitle
{
    height:         40px;
    font-weight:    900;
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
}


#deleteConnectionsTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);
}


#deleteConnectionsLabel
{
    font-size:      11px;

    margin-top:     16px;
    margin-bottom:  12px;

    position:       relative;
    left:           17px;

    user-select:    text;
}


#deleteConnectionsInputBack
{
    font-size:       11px;
    color:           var(--figma-color-bg-disabled);
      
    width:           266px;
    height:          20px;
 
    padding-top:     6px;
    padding-bottom: -6px;

    margin-top:      12px;
    margin-bottom:  -3px;

    position:        absolute;
    left:            18px;
}


#deleteConnectionsInput
{
    background:     transparent;
    font-size:      11px;
      
    width:          278px;
    height:         26px;
 
    padding-left:   6px;
    padding-right:  6px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-top:     12px;
    margin-bottom: -3px;

    position:       absolute;
    left:           12px;
}


#deleteConnectionsButton
{
    width:          60px;

    position:       absolute;
    right:          12px;
    transform:      translateY(-2px);

    margin-top:     12px;
}





#eulaBack
{
    display:          none;

    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    z-index:          100;
    pointer-events:   all;

    /* background-color: #0005; */
}



#eulaDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       200;
    position:      absolute;
    top:           58px;
    left:          calc(50%);
    transform:     translateX(-50%);
    width:         540px;
    height:        calc(100% - 80px);

    overflow:      hidden;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;
}


#eulaDialogContainer
{
    height:   calc(100% - 42px);
    overflow: hidden;
    padding:  0;
    z-index:  1;
    /* box-shadow: 0 0 0 1px red inset; */
}


#eulaDialogContent
{
    font-size:      12px;
    margin:         0;
    padding:        1px 0 5px 0;
    position:       absolute;
    pointer-events: all;
    user-select:    text;
    /* box-shadow:  0 0 0 1px blue inset; */
}


.figma-light #eulaDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #eulaDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#eulaWatermark
{
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-41%)
                    translateY(-34%);
    font-size:      800px;
    font-weight:    600;
    white-space:    nowrap;
    color:          var(--figma-color-bg-secondary);
    z-index:        -1;
    user-select:    none;
    pointer-events: none;
}



#eulaTitle
{
    position:       relative;
    height:         40px;
    border-bottom:  1px solid rgb(0, 0, 0, 0.15);
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
    background:     var(--figma-color-bg);
    z-index:        10;
}


#eulaTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);

    pointer-events: none;
    user-select:    none;
}


#eulaBody
{
    margin:      25px 60px 0 60px;
    font-weight: 200;
}


.figma-dark  #eulaBody { font-weight: 200; }
.figma-light #eulaBody { font-weight: 400; }


#eulaBody ol
{
    margin-left:   16px;
    margin-top:    30px;
    margin-bottom: 30px;
    padding-left:  0;
}

#eulaBody li
{
    margin-bottom: 10px;
}

#eulaBody li::marker
{
    content: counter(list-item) ".  ";
}

.figma-light #eulaBody .bold { font-weight: 700; }
.figma-dark  #eulaBody .bold { font-weight: 500; }



#eulaScrollbarY
{
    width:   6px;
    z-index: 300;
    margin:  6px 0 18px 0;
    display: none;
}

.figma-light #eulaScrollbarY { background: #0002; }
.figma-dark  #eulaScrollbarY { background: #fff2; }



#btnStartTrial
{
    width:       120px;
    height:      14px;
    user-select: none;
    margin:      45px auto 42px auto;
    position:    relative;
    left:        -5px;
    background:  transparent;
}


.figma-light #btnStartTrial { font-weight: 600; }
.figma-dark  #btnStartTrial { font-weight: 300; }


#minZoomDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    width:         200px;
    height:        92px;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border-radius: 4px;
}


.figma-light #minZoomDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #minZoomDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#minZoomTitle
{
    height:         40px;
    font-weight:    900;
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
}


#minZoomTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);
}


#minZoomInput
{
    background:     transparent;
    font-size:      11px;
      
    width:          176px;
    height:         26px;
 
    padding-left:   6px;
    padding-right:  6px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-top:     12px;
    margin-bottom: -3px;

    position:       absolute;
    left:           12px;
}





#saveAsTemplateBack
{
    display:          none;

    z-index:          10;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    pointer-events:   all;

    background-color: #0005;
}



#saveAsTemplateDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       20;
    position:      absolute;
    width:         400px;
    height:        92px;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border-radius: 4px;
}


.figma-light #saveAsTemplateDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #saveAsTemplateDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#saveAsTemplateTitle
{
    height:         40px;
    font-weight:    900;
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
}


#saveAsTemplateTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);
}


#saveAsTemplateLabel
{
    font-size:      11px;

    margin-top:     16px;
    margin-bottom:  12px;

    position:       relative;
    left:           17px;

    user-select:    text;
}


#saveAsTemplateInputBack
{
    font-size:       11px;
    color:           var(--figma-color-bg-disabled);
      
    width:           266px;
    height:          20px;
 
    padding-top:     6px;
    padding-bottom: -6px;

    margin-top:      12px;
    margin-bottom:  -3px;

    position:        absolute;
    left:            18px;
}


#saveAsTemplateInput
{
    background:     transparent;
    font-size:      11px;
      
    width:          278px;
    height:         26px;
 
    padding-left:   6px;
    padding-right:  6px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-top:     12px;
    margin-bottom: -3px;

    position:       absolute;
    left:           12px;
}


#saveAsTemplateButton
{
    width:          60px;

    position:       absolute;
    right:          12px;
    transform:      translateY(-2px);

    margin-top:     12px;
}





#subscriptionBack
{
    display:          none;

    z-index:          1000;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
}


#subscriptionDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2000;
    position:      absolute;
    top:           50%;
    left:          50%;
    transform:     translateX(-50%)
                   translateY(-50%);

    width:         400px;
    height:        226px;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;

    overflow:      hidden;
}


.figma-light #subscriptionDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #subscriptionDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#subscriptionTitle
{
    height:         40px;
    border-bottom:  1px solid rgb(0, 0, 0, 0.15);
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
}


#subscriptionTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);

    pointer-events: none;
    user-select:    none;
}


#subscriptionUserName
{
    font-size:      11px;
    font-weight:    bold;

    margin-top:     16px;
    margin-bottom:  3px;

    padding-bottom: 5px;

    position:       absolute;
    left:           50%;
    top:            70px;
    transform:      translateX(-50%);
    border-bottom:  1px solid var(--figma-color-bg-disabled);
    width:          240;

    overflow:       hidden;

    user-select:    text;

    /* box-shadow:  0 0 0 1px red inset; */
}


#btnSubscribe
{
    display:        none;

    width:          138px;

    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);

    top:            158px;
}


#subscriptionTextBack
{
    display:        none;
    
    position:       absolute;
    left:           50%;
    top:            113px;
    width:          138px;
    height:         25px;

    transform:      translateX(-50%);

    z-index:        0;

    pointer-events: none;

    border-bottom:  1px solid var(--figma-color-bg-tertiary);

    /* box-shadow:  0 0 0 1px red inset; */
}



/* #subscriptionInputBack
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    color:          var(--figma-color-bg-disabled);
    letter-spacing: 1px;
    
    width:          10em;
    padding-left:   3px;
    padding-top:    -2px;
    padding-bottom:  2px;

    position:       absolute;
    left:           calc(calc(50% - 4.5em) + 1px);
    top:            115px;

    z-index:        1;

    pointer-events: none;

    box-shadow:  0 0 0 1px red inset; 
} */



/* #subscriptionInput
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    letter-spacing:  1px;
     
    width:          calc(10em + 2px);
    height:         24px;
    padding-left:   13px;
    padding-top:    -2px;
    padding-bottom:  2px;

    margin-bottom:  -3px;

    background:     transparent;

    position:       absolute;
    left:           calc(50%);
    top:            114px;

    transform:      translateX(-50%);
} */


#subscriptionInput:disabled
{
    color: var(--figma-color-bg-disabled);
}


#subscribeWebsite
{
    font-size:      11px;
    text-align:     center;

    margin-top:     16px;
    margin-bottom:   8px;

    position:       absolute;
    left:           50%;
    top:            200px;
    transform:      translateX(-50%);

    color:          var(--figma-color-bg-disabled);
}





:root
{
    --colorBackSize:      45px;
}


#_graphView
{
    display:    block;
    overflow:   hidden;
    height:     calc(100% - 40px);
    position:   relative;
    z-index:    2;
    box-shadow: 0 1px 0 0 inset #383838;
    /* box-shadow: 0 0 0 1px red inset; */
}


.wireContainer
{
    position:       absolute;
    width:          100%;
    height:         calc(100% - 1px);
    z-index:        1;
    pointer-events: none;
    overflow:       hidden;
}


.menuButton
{
    display:       inline-block;
    font-family:   Inter;
    font-size:     11px;
    width:         50px;
    height:        40px;
    background:    #2c2c2c;
    border-radius: 0;
    min-width:     0;
    min-height:    0;
    border:        none;
    position:      relative;
    padding:       0;
    color:         #fff;
    overflow:      hidden;
    cursor:        default;
    /* box-shadow:    0 0 0 1px red inset; */
}


.menuButton:hover
{
    /* background: black; */
    color:      white;
}


.menuButtonIcon
{
    display:             inline-block;
    width:               30px;
    height:              40px;
    /* box-shadow: 0 0 0 1px yellow inset; */
}


.menuButtonArrow
{
    display:             inline-block;
    width:               20px;
    height:              40px;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="5" viewBox="0 0 8 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.507593 1.22627L1.2469 0.498783L4.01388 3.22151L6.78084 0.498783L7.52015 1.22627L4.01388 4.67648L0.507593 1.22627Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    transition:          0.25s;
    /* box-shadow: 0 0 0 1px magenta inset; */
}


.menu
{
    display:          none;
    position:         absolute;
    width:            auto;
    height:           auto;
    padding:          8px 0 8px 0;
    border-radius:    2px;
    font-family:      Inter;
    font-size:        11px;
    overflow:         hidden;
    overflow-y:       hidden;
    color:            #eee;
    background-color: #1e1e1e;
    z-index:          100000;
}


.menu::-webkit-scrollbar
{
    background: transparent;
    width:      6px;
}


.menu::-webkit-scrollbar-track
{
    margin: 4px 4px 4px 0;
}


.menu::-webkit-scrollbar-thumb
{
    background:    #fff4;
    border-radius: 3px;
}


.menuItems
{
    display:          inline-block;
    height:           fit-content;
    /* box-shadow:       0 0 0 1px red inset; */
}


.figma-light .menu
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark .menu
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


.menuArrow
{
    content:      '';
    position:     absolute;
    margin-left:  -7px;
    border-width: 7px;
    border-style: solid;
    border-color: transparent transparent #1e1e1e transparent;
    display:      none;
    opacity:      0%;
    box-shadow:   0 0px 2px 0px #fff3 inset;
    z-index:      20000;
}


.menuItem
{
    display:     inline-block;
    width:       100%;
    height:      auto;
    font-family: Inter;
    font-size:   12px;
    position:    relative;
    /* box-shadow:  0 0 0 1px red inset; */
}


.menuItemHighlight
{
    display:        block;
    position:       absolute;
    height:         25px;
    pointer-events: none;
}


.menuItemLegend
{
    display:             block;
    position:            absolute;
    width:               3px;
    height:              12px;
    left:                0px;
    top:                 50%;
    transform:           translateY(-50%);
    background:          transparent;
}


.menuItemColor
{
    display:             inline-block;
    width:               16px;
    height:              16px;
    border-radius:       1px;
    margin-left:         4px;
    margin-right:        4px;
    position:            relative;
    top:                 13px;
    pointer-events:      none;
}


.menuItemCheck
{
    display:             inline-block;
    width:               32px;
    height:              22px;
    background:          url('data:image/svg+xml;utf8,<svg width="9" height="9" viewBox="0 -2 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.31749 2.4477L3.42546 4.55569L7.64142 0.339716L8.9589 1.65721L3.42546 7.19067L0 3.76519L1.31749 2.4477Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    visibility:          hidden;
    /* box-shadow:          0 0 0 1px blue inset; */
}



.menuItemIcon
{
    display:             inline-block;
    width:               32px;
    height:              22px;
    /* box-shadow:          0 0 0 1px orange inset; */
    transform:           translateY(1px);
}


.menuItemName
{
    display:     inline-block;
    position:    relative;
    font-weight: 500;
    top:        -5px;
    filter:      grayscale(); /* disables cleartype to match Figma */
}


.menuItemExpand
{
    display:             inline-block;
    width:               48px;
    height:              22px;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="9" viewBox="0 -1 6 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 4L0 0V8L6 4Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    visibility:          hidden;
    position:            absolute;
    right:               0;
}


.menuItemShortcut
{
    display:                  inline-block;
    position:                 absolute;
    right:                    16px;
    transform:                translateY(5px);
    font-variant-alternates:  stylistic(), styleset();
    font-feature-settings:   'salt' on, 'ss02' on;
    filter:                   grayscale(); /* disables cleartype to match Figma */
}


.menuItemSubscribe
{
    display:     inline-block;
    position:    absolute;
    right:       16px;
    font-size:   11px;
    font-weight: 700;
    color:       #e88b;
    transform:   translateY(6px);
    background:  #1e1e1e;
    box-shadow:  0 0 5px 5px #1e1e1e;
}


.disambiguate
{
    font-variant-alternates: stylistic(), styleset();
    font-feature-settings:   'salt' on, 'ss02' on;
}


.menuSeparator
{
    display:    inline-block;
    width:      100%;
    height:     1px;
    background: #383838;
    margin:     8px 0 8px 0;
}


#menuBar
{
    display:          flex;
    height:           40px;
    background-color: #2c2c2c;
    /* border-bottom:    1px solid var(--figma-color-bg-tertiary); */
    padding:          0;
    cursor:           default;
    position:         relative;
    z-index:          4;
    /* vertical-align:   middle; */
}



#pageName
{
    font-family:  Inter;
    font-size:    14px;
    color:        #fff;
    padding-top:  11px;
    margin-left:  auto;
    position:     relative;
    left:        -26px;
    /* margin-right: auto; */
    white-space:  nowrap;
    /* box-shadow:   0 0 0 1px yellow inset; */
}


#btnZoom
{
    position:      absolute;
    padding-left:  14px;
    padding-right: 45px;
}


#btnToggleWires
{
    position:            absolute;
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="%23d5d5d5" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="%23d5d5d5"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnToggleWires:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="white" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="white"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}



#btnCreateInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.3"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="%23d5d5d5"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="white"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="white"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.5"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="white"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateCorrectColor
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="%23d5d5d5"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateCorrectColor:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorContrast
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="%23d5d5d5" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorContrast:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="white" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorBlind
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_603_2)"><path d="M9.33666 18.2036C14.1602 18.2036 18.0705 14.2933 18.0705 9.46972C18.0705 4.64614 14.1602 0.735851 9.33666 0.735851C4.51308 0.735851 0.60279 4.64614 0.60279 9.46972C0.60279 14.2933 4.51308 18.2036 9.33666 18.2036Z" stroke="black" stroke-width="0.919355" stroke-dasharray="1.84 1.84"/><path d="M9.33666 14.1487C11.9208 14.1487 14.0156 12.0538 14.0156 9.46972C14.0156 6.88562 11.9208 4.79079 9.33666 4.79079C6.75256 4.79079 4.65773 6.88562 4.65773 9.46972C4.65773 12.0538 6.75256 14.1487 9.33666 14.1487Z" stroke="black" stroke-width="0.919355"/><path d="M9.33666 10.5448C9.93043 10.5448 10.4118 10.0635 10.4118 9.46972C10.4118 8.87595 9.93043 8.39461 9.33666 8.39461C8.74289 8.39461 8.26155 8.87595 8.26155 9.46972C8.26155 10.0635 8.74289 10.5448 9.33666 10.5448Z" fill="black"/></g><defs><clipPath id="clip0_603_2"><rect width="19" height="19" fill="white"/></clipPath></defs></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorBlind:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15.2335" cy="15.4506" r="14.25" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="7.63405" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="1.75413" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateComment
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="18" height="16" viewBox="0 0 18 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5266L3.6897 11.0341C3.24801 10.1174 3 9.08908 3 8C3 4.13401 6.13401 1 10 1C13.866 1 17 4.13401 17 8C17 11.866 13.866 15 10 15C8.89526 15 7.85296 14.7448 6.92628 14.2911L6.65842 14.1599L6.36249 14.1969L1.94388 14.7492L3.64047 11.9923L3.92701 11.5266ZM0.671856 14.9082L0 16L1.27203 15.841L6.48652 15.1892C7.5471 15.7085 8.73951 16 10 16C14.4183 16 18 12.4183 18 8C18 3.58172 14.4183 0 10 0C5.58172 0 2 3.58172 2 8C2 9.24258 2.28329 10.419 2.78881 11.4682L0.671856 14.9082Z" fill="white" fill-opacity="1"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateComment:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="18" height="16" viewBox="0 0 18 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5266L3.6897 11.0341C3.24801 10.1174 3 9.08908 3 8C3 4.13401 6.13401 1 10 1C13.866 1 17 4.13401 17 8C17 11.866 13.866 15 10 15C8.89526 15 7.85296 14.7448 6.92628 14.2911L6.65842 14.1599L6.36249 14.1969L1.94388 14.7492L3.64047 11.9923L3.92701 11.5266ZM0.671856 14.9082L0 16L1.27203 15.841L6.48652 15.1892C7.5471 15.7085 8.73951 16 10 16C14.4183 16 18 12.4183 18 8C18 3.58172 14.4183 0 10 0C5.58172 0 2 3.58172 2 8C2 9.24258 2.28329 10.419 2.78881 11.4682L0.671856 14.9082Z" fill="white" fill-opacity="1"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#zoomIconOverlay
{
    display:             block;
    position:            absolute;
    height:              20;
}


#groupName
{
    box-shadow: 0 0 0 1px red inset;
}


.figma-light .toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="black"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="black"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.figma-light .toggleButton:hover
{
    box-shadow: 0 0 0 1px #e6e6e6
}


.figma-light .toggleButton:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
}


.figma-dark .toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="white"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    color:               #ddd;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.figma-dark .toggleButton:hover
{
    box-shadow: 0 0 0 1px #777;
}


.figma-dark .toggleButton:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
}


.control
{
    /* box-shadow:       0 0 0 4px purple inset; */
    overflow:    hidden;
    /* width:            10; */
    position:   relative;
    /* height:     auto; */
}


/* .figma-dark .control
{
    background-color: rgba(56, 56, 56, 0.95);
}


.figma-light .control
{
    background-color: rgba(255, 255, 255, 0.95);
} */


.numberControl
{
    padding:          0;
    overflow:         hidden;
    text-align:       center;
    touch-action:     none;
}    


.numberControlBar
{
    position:       absolute;
    pointer-events: none;
}


.numberControlPrecision
{
    display:        hidden;
    position:       absolute;
    pointer-events: none;
    /* background:     red; */
}


.numberControlValue
{
    font-family:          Inter;
    font-size:            11px;
    font-variant-numeric: tabular-nums;
    letter-spacing:       -0.35px;
    pointer-events:       none;
    position:             absolute;
    /* left:                 50%; */
    top:                  50%;
    /* transform:            translateY(-50%); */
    white-space:          nowrap;
    /* margin-left:          3px; */
    /* box-shadow:           0 0 0 1px inset orange; */
}


.numberControlValue .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
    /* box-shadow:           0 0 0 1px inset orange; */
}


.numberControlTextbox
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    position:             absolute;
    /* left:                 50%;
    transform:            translateX(-50%); */
    /* width:                100%; */
    white-space:          nowrap;
    background-color:     transparent;
    z-index:              10;
    border-radius:        0.5px;
}


.textControlTextarea:focus
{
    outline: 2px solid var(--figma-color-bg-brand);
}


.numberControlExt
{
    display:             block;
    position:            absolute;
    top:                 50%;
    transform:           translateY(-50%);
    width:               1px;
    height:              10px;
    /* box-shadow:          0 0 0 1px red inset; */
    z-index:             1200;
}

.numberControlExtLeft  { left:  0px; }
.numberControlExtRight { right: 0px; }


/* .figma-light .numberControlExt
{
    background:          url('data:image/svg+xml;utf8,<svg width="1" height="15" viewBox="0 0 1 15" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="12" width="1" height="3" fill="#000"/><rect y="6" width="1" height="3" fill="#000"/><rect width="1" height="3" fill="#000"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}

.figma-dark .numberControlExt
{
    background:          url('data:image/svg+xml;utf8,');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
} */


.numberControlFocus
{
    position:       absolute;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px var(--activeObjectColor) inset; */
    visibility:     hidden;
    opacity:        0;
    z-index:        5100;
}


.numberControlRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}


.textControl
{
    /* padding:       0; */
    overflow:      visible;
    /* text-align:    center; */
    touch-action:  none;
    /* position:      relative; */
}    


.textControlTextarea
{
    display:              inline-block;
    color:                var(--figma-color-text);

    font-family:          Inter;
    font-size:            11;
    position:             absolute;
    left:                 0px;
    top:                  0px;
    width:                100%;
    background-color:     transparent;
    z-index:              5000;

    border:               none;
    overflow:             auto;
    outline:              none;

    -webkit-box-shadow:   none;
    -moz-box-shadow:      none;
    box-shadow:           none;

    resize:               none;
    cursor:               default;

    padding-top:          0.4em;
    padding-left:         0.4em;
    padding-right:        0.4em;

    border-radius:        0.5px;
    
    /* box-shadow:           0 0 0 1px inset red; */
}


.textControlTextarea:focus
{
    outline: 2px solid var(--figma-color-bg-brand);
}


.textControlTextarea:focus::placeholder 
{
    color: transparent;
}


.textControlTextarea::-webkit-scrollbar
{
    background:   transparent;
    width:        6px;
    /* box-shadow:   0 0 0 1px red inset; */
}


.textControlTextarea::-webkit-scrollbar-track
{
    border: 4px solid transparent;
    margin: 2px 0px 2px 0;
}


.textControlTextarea::-webkit-scrollbar-thumb
{
    background:     #fff4;
    border:         4px solid transparent;
    border-radius:  3px;
    cursor:         default;
    pointer-events: none;
}



.colorControl
{
    padding:          0;
    width:            74px;
    height:           26px;
    overflow:         hidden;
    /* background-color: var(--figma-color-bg); */
    text-align:       center;
    touch-action:     none;
    /* box-shadow:       0 0 0 4px purple inset; */
}    


.figma-light .colorControlName
{
    color: #0006;
}


.figma-dark .colorControlName
{
    color: #fff6;
}


.colorControlBar
{
    position:       absolute;
    pointer-events: none;
}


.colorControlText
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    pointer-events:       none;
    letter-spacing:       -0.35px;
    /* text-align:           center; */
    position:             absolute;
    /* left:                 50%; */
    /* transform:            translateX(-50%); */
    top:                  4px;
    white-space:          nowrap;
    /* box-shadow:           0 0 0 1px inset orange; */
}


.colorControlText .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
}


.colorControlTextbox
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    position:             absolute;
    /* left:                 50%;
    transform:            translateX(-50%); */
    /* width:                100%; */
    white-space:          nowrap;
    letter-spacing:       -0.35px;
    border-radius:        0.5px;
    z-index:              10;
}


.colorControlTextbox:focus
{
    outline: 2px solid var(--figma-color-bg-brand);
}


.colorControlFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px var(--figma-color-bg-brand) inset;
    visibility:     hidden;
    opacity:        0;
}


.colorControlRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}




.menuSelect
{
    font-family:         Inter;
    font-size:           14;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         1;
    margin-right:        6;
    margin-top:          0;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
    color:               white;
}


.menuSelect:hover
{
    /* box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1); */
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) calc(50% + 3px);
    background-repeat:   no-repeat;
    padding-right:       30;
    transition:          all 0.2s ease;
}


.menuSelect:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.menuSelectText
{
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
    position:       relative;
    top:            3px;
}


.menuSelectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px  7px rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2 );
    /* overflow:      hidden; */
}


.menuSelectMenu::after 
{
    content:       '';
    position:      absolute;
    top:           -10px;
    left:          65px;
    border-width:  5px;
    border-style:  solid;
    border-color:  transparent transparent #222 transparent;
}




.select
{
    font-family:         Inter;
    font-size:           11;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         2;
    margin-right:        6;
    margin-top:          1;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.4"/> </svg>');
    background-position: calc(100% - 17px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
}


.select:hover
{
    box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1);
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 7px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
}


.select:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 6px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.selectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px 7px  rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2);
    overflow:      hidden;
}


.button
{
    color:          var(--figma-color-text);
    background:     var(--figma-color-bg);

    font-size:      11px;
    text-align:     center;

    padding:        8px 14px;

    border-radius:  6px;
    box-shadow:     0 0 0 1px var(--figma-color-text) inset;
}


.button:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand) inset;
}


.panelButton
{
    font-family:   Inter;
    font-size:     11px;
    width:         30;
    height:        30;
    background:    white;
    min-width:     0;
    min-height:    0;
    border:        none;
    border-radius: 2px;
    position:      relative;
    padding:       0;
    background:    var(--figma-color-bg);
}


.panelButton:hover
{
    background: var(--figma-color-bg-hover);
}


.panelButton:active
{
    box-shadow: 0 0 0 2px var(--activeObjectColor) inset;
    outline:    none;
}


.checkbox
{
    font-family: Inter;
    font-size:   11px;
    display:     inline-block;
    width:       auto;
    height:      24px;
}


.checkboxCheck
{
    display:       inline-block;
    width:         12px;
    height:        12px;
    border-radius: 2px;
    transform:     translateY(2px);
}


.checkboxText
{
    color:       var(--figma-color-text);
    display:     inline;
    width:       auto;
    height:      auto;
    margin-left: 10px;
}


.inputControls
{
    width:          12px;
    height:         auto;
    float:          left;
    margin-right:   auto;
    padding-top:    13px;
    /* box-shadow:     0 0 0 1px red inset; */
    pointer-events: none;
}


.input
{
    /* display:        inline; */
    width:          6px;
    height:         6px;
    background:     transparent;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    left:           3px;
    pointer-events: none;
    box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12);
    z-index:        10;
    transition:     opacity 0.2s linear 0s;
    /* box-shadow:     0 0 0 1px yellow inset; */
}


.inputBall
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    top:            50%;
    left:           50%;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
    /* box-shadow:     0 0 0 1px orange inset; */
}


.inputHitbox
{
    position:       relative;
    left:          -3px;
    top:           -3px;
    width:          12px;
    height:         12px;
    pointer-events: auto;
    /* box-shadow:     0 0 0 1px red inset; */
}


:root 
{
    --windowBorderWidth: 8px;
    --sizeBorderWidth:   4px;
    --defHeaderHeight:   25px;
    /* --cornerBack:     #0f08;
    --edgeBack:          #08f8; */
    --cornerBack:        none;
    --edgeBack:          none;
}


.node
{
    display:       none;
    position:      absolute;
    height:        auto;
    border-radius: 4px 4px 0 0;
    padding:       0;
    overflow:      visible;
 /* box-shadow:    0 0 0 1px yellow inset; */
}


.nodeInner
{
    display:       block;
    position:      relative;
    width:         100%;
    height:        auto;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    padding:       0;
    /* box-shadow:    0 0 0 1px var(--figma-color-bg-tertiary); */
    overflow:      hidden;
    /* box-shadow:    0 0 0 1px orange inset; */
}    


.nodeHeader
{
    /* background:   'magenta'; */
    display:       flex;
    width:         100%;
    position:      relative;
    border-radius: 4px 4px 0 0;
    z-index:       10000;
 /* overflow:      visible; */
 /* box-shadow:    0 0 0 1px red inset; */
}


.nodeHeaderCheckersHolder
{
    display:       inline-block;
    width:         100%;
    height:        100%;
    position:      absolute;
    left:          0;
    top:           0; 
    z-index:       1;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    pointer-events: none;
    /* box-shadow:    0 0 0 1px red inset; */
}


.nodeHeaderCheckers
{
    display:       inline-block;
    width:         100%;
    height: 100%;
    position:      absolute;
    left:          0;
    top:           0; 
    border-radius: 4px 4px 0 0;
    pointer-events: none;
    /* box-shadow:    0 0 0 1px blue inset; */
}


.nodeParamBack
{
    display:        flex;
    flex-direction: column;
    position:       relative;
    z-index:        2000;
    /* box-shadow:  0 0 0 1px magenta inset; */
}


.nodeHiddenParamBack
{
    display:     block;
    position:    absolute;
    width:       100%;
    background:  #fffe;
    z-index:    -1;
 /* box-shadow:  0 0 0 1px green inset; */
}


/* .paramSeparator
{
    display:    inline-block;
    width:      100%;
    height:     10;
    background: #fffe;
 /* box-shadow: 0 0 0 1px green inset;
} */


.nodeLabelWrapper
{
    position:   absolute;
    width:      100%;
    height:     100%;   
    overflow:   hidden;
    /* box-shadow: 0 0 0 1px blue inset; */
}


.nodeLabel
{
    padding:        0;
    margin:         0;
    display:        block;
    width:          auto;
    height:         auto;
    position:       absolute;
    /* pointer-events: none; */
    z-index:        1000;
    white-space:    nowrap;
    font-weight:    600;
    /* box-shadow:     0 0 0 1px magenta inset; */
}


.nodeIcon
{
    display:       inline;
    width:         19px;
    height:        19px;
    margin-right:  7px;
    position:      relative;
    pointer-events: none;
    /* box-shadow:   0 0 0 1px red inset; */
}


.headerIcon
{
    width:          14px;
    height:         14px;
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-50%)
                    translateY(-50%);
    pointer-events: none;
}    


.nodeLabelText
{
    font-family:    Inter;
    font-size:      11px;
    padding:        0;
    margin:         0;
    display:        inline;
    width:          auto;
    height:         15px;
    text-align:     center;
    white-space:    nowrap;
    vertical-align: top;
    left:           50%;
    text-rendering: geometricPrecision;
    /* box-shadow:     0 0 0 1px orange inset; */
}


.nodeLabelTextbox
{
    font-family: Inter;
    font-size:   11;
 /* box-shadow:  0 0 0 1px #a0a inset; */
    overflow:    visible;
}


.nodeLabelTextbox::selection
{
    background-color: white;
}


.subscribeCover
{
    background: transparent;
    position:   absolute;
    left:       0;
    width:      100%;
    z-index:    100000;
    display:    none;
}



.subscribeLabel
{
    font-family:    Inter;
    font-size:      16px;
    font-weight:    700;
    color:          #e88b;
    position:       absolute;
    left:           50%;
    top:            50%;
    pointer-events: none;
    z-index:        100000;
    transform:      translateX(-50%)
                    translateY(-50%)
                    rotate(-45deg);
    display:        none;
}


.colorWarningOverlay
{
    width:            100%;
    z-index:          100;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.colorValueWarningOverlay
{
    width:            100%;
    z-index:          50;
    position:         absolute;
    top:              0;
    height:           var(--colorBackSize);
    pointer-events:   none;
}


.colorBack
{
    width:            100%;
    /* height:           var(--colorBackSize); */
    z-index:          0;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.txtOrder
{
    text-align:  center;
    width:       100%;
    background:  transparent;
    cursor:      default;
}


.txtOrder:hover
{
    box-shadow: 0  1px 0 0 rgba(0, 0, 0, 0.1) inset,
                0 -1px 0 0 rgba(0, 0, 0, 0.1) inset;
}


.findCorrectColorion
{
    display:             block;
    width:               10px;
    height:              10px;
    position:            absolute;
    left:                50%;
    top:                 50%;
    transform:           translateX(-50%)
                         translateY(-50%);
 /* box-shadow:          0 0 0 1 red inset; */
    background:          url('data:image/svg+xml;utf8,<svg width="10" height="10" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.10345 5.05172C8.10345 7.01329 6.51329 8.60345 4.55172 8.60345C2.59016 8.60345 1 7.01329 1 5.05172C1 3.09016 2.59016 1.5 4.55172 1.5C6.51329 1.5 8.10345 3.09016 8.10345 5.05172ZM7.39723 8.60458C6.61787 9.22958 5.62846 9.60345 4.55172 9.60345C2.03788 9.60345 0 7.56557 0 5.05172C0 2.53788 2.03788 0.5 4.55172 0.5C7.06557 0.5 9.10345 2.53788 9.10345 5.05172C9.10345 6.12858 8.72949 7.1181 8.10436 7.8975L11.3535 11.1467L10.6464 11.8538L7.39723 8.60458Z" fill="black" fill-opacity="0.8"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


.progressWrapper
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         100%;
    height:        6px;   
    background:    transparent;
 /* border-radius: 2.5px; */
    border-radius: 4px 4px 0 0;
    overflow:      hidden;
    display:       none;
}


.progressBar
{
    position:   absolute;
    left:       0;
    top:        0;
    width:      0;
    height:     5px;   
    background: var(--figma-color-bg-brand);
}


.asterisk
{
    font-size: 8px;
    position:  relative;
    top:       -2px;
}


.btnAnimatePlay
{
    width:          15px;
    height:         15px;
    margin-right:   6px;
    pointer-events: all;
}


.btnRenderFinal
{
    width:          20px;
    height:         17px;
    margin-right:   6px;
    pointer-events: all;
}


.styleCircleWrapper
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    border-radius:   8px;
    margin-right:    7px;
    position:       relative;
    top:           -1px;
    pointer-events: all;
    overflow:       hidden;
}


.styleCircleBack
{
    width:          16px;
    height:         16px;
    pointer-events: none;
    position:       absolute;
    left:           0;
    top:            0;
}


.styleCircleCheckers
{
    width:          16px;
    height:         8px;
    pointer-events: none;
    position:       absolute;
    left:           0;
    top:            0;
    transform:      rotate(45deg);
    transform-origin: 50% 100%;
}


.styleCircle
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    position:       absolute;
    left:           0;
    top:            0;
}


.styleLink
{
    width:          16px;
    height:         16px;
    pointer-events: none;
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-50%)
                    translateY(-50%);
}    


.headerCircleWrapper
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    /* border-radius:   8px; */
    margin-right:    3px;
    position:       relative;
    top:           -1px;
    pointer-events: all;
    overflow:       hidden;
}


.headerCircleBack
{
    width:          16px;
    height:         16px;
    pointer-events: none;
    position:       absolute;
    left:           0;
    top:            0;
}


.headerCircle
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    position:       absolute;
    left:           0;
    top:            0;
}


.reorderArrows
{
    width:    5px;
    height:   8px;
    position: absolute;
    left:     0;
    top:      0;
}


.colorblindSymbol
{
    position:  absolute;
    width:     26px;
    height:    26px;
    left:      50%;
    top:       33%;
    transform: translateX(-50%)
               translateY(-50%);
}


.colorblindRing
{
    position:  absolute;
    left:      50%;
    top:       50%;
    transform: translateX(-50%)
               translateY(-50%);
}


.sizerEdge
{
    position:   absolute;
    background: var(--edgeBack);
    z-index:    10000;
    /* box-shadow: 0 0 0 1px green inset; */
}


.sizerH
{
    top:    var(--defHeaderHeight);
    /* top:    var(--sizeBorderWidth); */
    /* height: calc(100% - calc(2 * var(--sizeBorderWidth))); */
    width:  var(--sizeBorderWidth);
    height: calc(100% - calc(25px + var(--sizeBorderWidth)));
    cursor: ew-resize;
}


.sizerL { left:  0; }
.sizerR { right: 0; }


.sizerV
{
    left:   var(--sizeBorderWidth);
    width:  calc(100% - calc(2 * var(--sizeBorderWidth)));
    height: var(--sizeBorderWidth);
    cursor: ns-resize;
}


.sizerT { top:    0; }
.sizerB { bottom: 0; }


.sizerCorner
{
    position:   absolute;
    width:      var(--sizeBorderWidth);
    height:     var(--sizeBorderWidth);
    background: var(--cornerBack);
    z-index:    10000;
    /* box-shadow: 0 0 0 1px yellow inset; */
}


.sizerTL
{
    left:   0;
    top:    0;
    cursor: nwse-resize;
}


.sizerTR
{
    right:  0;
    top:    0;
    cursor: nesw-resize;
}


.sizerBL
{
    left:   0;
    bottom: 0;
    cursor: nesw-resize;
}


.sizerBR
{
    right:  0;
    bottom: 0;
    cursor: nwse-resize;
}


.itemsScroll
{
    display:       block;
    position:      absolute;
    width:         6px;
    height:        100px;
    border-radius: 3px;
    z-index:       10000;
}


.figma-light .itemsScroll       { background: #0002; }
.figma-dark  .itemsScroll       { background: #fff2; }
 
.figma-light .itemsScroll:hover { background: #0004; }
.figma-dark  .itemsScroll:hover { background: #fff4; }


.outputControls
{
    width:          12px;
    /* height:         auto; */
    float:          right;
    margin-left:    auto;
    padding-top:    10px;
    /* box-shadow:     0 0 0 1px green inset; */
    pointer-events: none;
}


.output
{
    /* display:        inline; */
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    right:          3px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
    z-index:        10;
    transition:     opacity 0.2s linear 0s;
}


.outputBall
{
    width:          6px;
    height:         6px;
    border-radius:  6px;
    margin:         0;
    position:       absolute;
    top:            50%;
    transform:      translateY(-50%);
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.outputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: all;
}


.paramDiv
{
    /* background-color: var(--figma-color-bg); */
    /* box-shadow: 0 0 0 1px inset cyan; */
    position:   relative;
}


.paramName
{
    font-family:           Inter;
    font-size:             11px;
    text-align:            right;
    font-style:            normal;
    font-weight:           normal;
    font-variant-numeric:  tabular-nums;
    letter-spacing:       -0.35px;
    pointer-events:        none;
    overflow:              hidden;
    width:                 100px;
    height:                auto;
    position:              absolute;
    top:                   4px;
    white-space:           nowrap;
    /* margin-right:          3px; */
    /* box-shadow:            0 0 0 1px inset yellow; */
}


.figma-light .paramName { color: #0005; }
.figma-dark  .paramName { color: #fff4; }


.paramControls
{
    overflow:     hidden;
    width:        100%;
    height:       100%;
    margin-right: 3px;
    position:     absolute;
    white-space:  nowrap;
    /* box-shadow:   0 0 0 3px inset green; */
}



</style>


<div id='menuBar'>
    <div id='pageName'>Page name</div>
</div>
<div id='pagesBar'>
    <div id='btnAddPage' class='page'>
        <svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path id='btnAddPlus' fill-rule="evenodd" clip-rule="evenodd" d="M6 0.5H4V4L0.5 4V6H4V9.5H6V6H9.5V4L6 4V0.5Z" fill="white"/>
        </svg>
    </div>
</div>


<div id='_graphView'></div>

<div id='selectBox'></div>


<div id='loadingOverlay'>
    <div id='loadingGraphic'>
        <svg id="loadingEmpty" width="8"  height="8"  viewBox="0 0 8 8"   fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 7C5.65685 7 7 5.65685 7 4C7 2.34315 5.65685 1 4 1C2.34315 1 1 2.34315 1 4C1 5.65685 2.34315 7 4 7ZM8 4C8 6.20914 6.20914 8 4 8C1.79086 8 0 6.20914 0 4C0 1.79086 1.79086 0 4 0C6.20914 0 8 1.79086 8 4Z" fill="white"/></svg>
        <svg id="loadingG"     width="21" height="24" viewBox="0 0 21 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.4398 7.77947C16.2474 7.1635 15.9819 6.61217 15.6432 6.12548C15.3123 5.63118 14.912 5.20913 14.4426 4.85932C13.9808 4.50951 13.4497 4.24715 12.8494 4.07224C12.249 3.88973 11.5948 3.79848 10.8868 3.79848C9.61682 3.79848 8.48543 4.11407 7.49258 4.74525C6.49973 5.37643 5.71853 6.30418 5.14898 7.52852C4.58714 8.74525 4.30621 10.2281 4.30621 11.9772C4.30621 13.7414 4.58714 15.2357 5.14898 16.4601C5.71083 17.6844 6.49203 18.616 7.49258 19.2548C8.49313 19.8859 9.65531 20.2015 10.9791 20.2015C12.1798 20.2015 13.2188 19.9734 14.0962 19.5171C14.9813 19.0608 15.6625 18.4144 16.1396 17.5779C16.6168 16.7338 16.8554 15.7452 16.8554 14.6122L17.8252 14.7605H11.4063V11.4525H21V14.2586C21 16.2586 20.569 17.9886 19.707 19.4487C18.845 20.9087 17.6597 22.0342 16.1512 22.8251C14.6427 23.6084 12.9109 24 10.956 24C8.7779 24 6.86531 23.5171 5.21825 22.5513C3.57889 21.5779 2.29742 20.1977 1.37383 18.4106C0.457944 16.616 0 14.4867 0 12.0228C0 10.1369 0.269379 8.45247 0.808136 6.96958C1.35459 5.48669 2.11655 4.22814 3.09401 3.19392C4.07147 2.15209 5.21825 1.36122 6.53436 0.821293C7.85047 0.273764 9.28202 0 10.829 0C12.1374 0 13.3573 0.190114 14.4887 0.570342C15.6201 0.942966 16.6245 1.47529 17.5019 2.1673C18.387 2.85932 19.1143 3.68061 19.6839 4.63118C20.2534 5.58175 20.6267 6.63118 20.8037 7.77947H16.4398Z" fill="white"/></svg>
        <svg id="loadingFull"  width="8"  height="8"  viewBox="0 0 8 8"   fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 4C8 6.20914 6.20914 8 4 8C1.79086 8 0 6.20914 0 4C0 1.79086 1.79086 0 4 0C6.20914 0 8 1.79086 8 4Z" fill="white"/></svg>

        <div id='loadingBar'>
            <div id='loadingProgress'></div>
        </div>
    </div>
    <div class='btnRestart' id='btnLoadingRestart'>Restart in debug mode</div>
</div>


<div id='dataModeView'>

    <div class='dataModeRowWrapper' id='dataModeTitleBar'>
        <div class='btnRestart' id='btnDataModeRestart'>Restart in normal mode</div>
    </div>

    <div id='dataModeContent'>
        
        <div class='dataModeRowWrapper' id='dataModePagesWrapper'>
            <div id='dataModePagesTitle' class='dataModeRowTitle'>Pages</div>
            <div id='dataModePages'></div>
        </div>
        
        <div class='dataModeRowWrapper' id='dataModeNodesWrapper'>
            <div id='dataModeNodesTitle' class='dataModeRowTitle'>Nodes</div>
            <div id='dataModeNodes'></div>
        </div>
        
        <div class='dataModeRowWrapper' id='dataModeConnsWrapper'>
            <div id='dataModeConnsTitle' class='dataModeRowTitle'>Connections</div>
            <div id='dataModeConns'></div>
        </div>

    </div>        
</div>


<div id='commonProgressBar'></div>


<div id='debugInfo'></div>


<!-- <div class='windowSizerEdge windowSizerH' id='windowSizerL'></div> -->
<div class='windowSizerEdge windowSizerH' id='windowSizerR'></div>
<div class='windowSizerEdge windowSizerV' id='windowSizerB'></div>

<!-- <div class='windowSizerCorner' id='windowSizerBL'></div> -->
<div class='windowSizerCorner' id='windowSizerBR'></div>


<div id='crashBack'></div>

<div id='crashDialog'>
    
    <div id='crashDialogContainer'>
        <div id='crashDialogContent'>
            <div id='crashDialogBody'>
                <p id='crashTitle'>Generator has experienced an error</p>
                <p id='crashDetails'></p>
            </div>
        </div>
        <div class='btnRestart' id='btnCrashRestart'>Restart in debug mode</div>
    </div>

</div>


<div id='aboutBack'></div>

<div id='aboutDialog'>
    
    <div id='aboutTitle'>
        <div id='aboutTitleText'>About</div>
        <div class='panelButton dialogButtonClose' id='aboutClose' onclick='aboutClose.blur(); hideAboutDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='aboutDialogContainer'>
        <div id='aboutDialogContent'>
            <div id='aboutDialogBody'>
                <div id='aboutGeneratorLogo'>
                    <svg width="50" height="25" viewBox="0 0 50 25" fill="none" xmlns="http://www.w3.org/2000/svg" id="svgGeneratorLogo">
                        <path d="M31.7883 8.10361C31.5684 7.46198 31.265 6.88767 30.878 6.3807C30.4997 5.86581 30.0423 5.42617 29.5058 5.06179C28.978 4.6974 28.3711 4.42411 27.685 4.24192C26.9989 4.05181 26.2512 3.95675 25.442 3.95675C23.9907 3.95675 22.6976 4.28549 21.5629 4.94297C20.4283 5.60044 19.5355 6.56686 18.8846 7.8422C18.2424 9.10963 17.9214 10.6543 17.9214 12.4762C17.9214 14.314 18.2424 15.8706 18.8846 17.1459C19.5267 18.4213 20.4195 19.3916 21.5629 20.057C22.7064 20.7145 24.0346 21.0433 25.5476 21.0433C26.9197 21.0433 28.1072 20.8056 29.11 20.3303C30.1215 19.855 30.8999 19.1817 31.4453 18.3104C31.9907 17.4311 32.2633 16.4013 32.2633 15.221L33.3716 15.3755H26.0357V11.9297H37V14.8527C37 16.936 36.5074 18.7381 35.5223 20.259C34.5371 21.7799 33.1825 22.9523 31.4585 23.7761C29.7345 24.592 27.7554 25 25.5212 25C23.0319 25 20.8461 24.497 18.9637 23.491C17.0902 22.477 15.6256 21.0393 14.5701 19.1778C13.5234 17.3083 13 15.0903 13 12.5238C13 10.5593 13.3079 8.80466 13.9236 7.25998C14.5481 5.71531 15.4189 4.40431 16.536 3.327C17.6531 2.24176 18.9637 1.41793 20.4678 0.855513C21.972 0.285171 23.608 0 25.376 0C26.8714 0 28.2655 0.198035 29.5586 0.594106C30.8516 0.982256 31.9995 1.53676 33.0022 2.25761C34.0137 2.97845 34.845 3.83397 35.4959 4.82414C36.1468 5.81432 36.5734 6.90748 36.7757 8.10361H31.7883Z" fill="var(--figma-color-text)"/>
                        <path d="M50 12.5C50 14.9853 47.9853 17 45.5 17C43.0147 17 41 14.9853 41 12.5C41 10.0147 43.0147 8 45.5 8C47.9853 8 50 10.0147 50 12.5Z" fill="var(--figma-color-text)"/>
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 16C6.433 16 8 14.433 8 12.5C8 10.567 6.433 9 4.5 9C2.567 9 1 10.567 1 12.5C1 14.433 2.567 16 4.5 16ZM4.5 17C6.98528 17 9 14.9853 9 12.5C9 10.0147 6.98528 8 4.5 8C2.01472 8 0 10.0147 0 12.5C0 14.9853 2.01472 17 4.5 17Z" fill="var(--figma-color-text)"/>
                    </svg>
                </div>

                <div id='aboutVersion'>version  _</div>

                <p id='aboutLine'><div id='aboutCopyright'>Copyright © 2023&nbsp;&hairsp;Brainshift</div></p>
                <!-- <div id='aboutUserId' ondblclick='copyUserId()'></div> -->
            </div>
        </div>
    </div>

</div>


<div id='deleteConnectionsDialog'>

    <div id='deleteConnectionsTitle'>
        <div id='deleteConnectionsTitleText'>Delete connections to</div>
        <div class='panelButton dialogButtonClose' id='deleteConnectionsClose' onclick='deleteConnectionsClose.blur(); hideDeleteConnectionsDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='deleteConnectionsBody'>
        <div id='deleteConnectionsInputBack'></div>
        <input type='text' spellcheck='false' id='deleteConnectionsInput' />
        <div class='button' id='deleteConnectionsButton' onclick='deleteConnectionsToNodes(deleteConnectionsInput.value);'>Delete</div>
    </div>

</div>


<div id='saveAsTemplateBack'></div>

<div id='saveAsTemplateDialog'>

    <div id='saveAsTemplateTitle'>
        <div id='saveAsTemplateTitleText'>Save as template</div>
        <div class='panelButton dialogButtonClose' id='saveAsTemplateClose' onclick='saveAsTemplateClose.blur(); hideSaveAsTemplateDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='saveAsTemplateBody'>
        <div id='saveAsTemplateInputBack'></div>
        <input type='text' spellcheck='false' id='saveAsTemplateInput' />
        <div class='button' id='saveAsTemplateButton' onclick='saveSelectedAsTemplate(saveAsTemplateInput.value); hideSaveAsTemplateDialog();'>Save</div>
    </div>

</div>





<div id='subscriptionBack'></div>

<div id='subscriptionDialog'>

    <div id='subscriptionTitle'>
        <div id='subscriptionTitleText'>Subscription</div>
        <div class='panelButton dialogButtonClose' id='subscriptionClose' onclick='hideAllMenus(); subscriptionClose.blur(); hideSubscriptionDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='subscriptionBody'>
        <div id='licenseInfo'></div>
        <div class='button' id='btnSubscribe' onclick='onSubscribeClick();'>Subscribe</div>
    </div>

</div>


<div id='eulaBack'></div>

<div id='eulaDialog'>
    
    <div id='eulaTitle'>
        <div id='eulaTitleText'>End-User License Agreement</div>
        <!-- <div class='panelButton dialogButtonClose' id='eulaClose' onclick='hideAllMenus(); eulaClose.blur(); hideEulaDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div> -->
    </div>
    
    <div id='eulaDialogContainer'>
        <div id='eulaDialogContent'>
            <div id='eulaWatermark'>◦<span style="font-weight: 700; position: relative; top: 0.06em;">G</span>•</div>

            <div id='eulaBody'>
                <p style='margin-top: 40px; margin-bottom: 35px;'><span class='bold'>By using Generator you agree to the following terms:</span></p>

                <ol>
                    <li><span class='bold'>Grant of License:</span> You are granted a limited, non-transferable license to use Generator for personal or commercial purposes.</li>
                    <li><span class='bold'>Free Use and Subscription:</span> The core features of Generator are available for free. Pro features are available exclusively to subscribers. By subscribing, you agree to the subscription fees and terms.</li>
                    <li><span class="bold">License Validity and Subscription Dates:</span> All license and subscription dates will be converted to Coordinated Universal Time (UTC) for consistency across different time zones.</li>
                    <li><span class='bold'>Intellectual Property:</span> Generator and its associated intellectual property rights are owned by Brainshift.</li>
                    <li><span class='bold'>Updates and Support:</span> Brainshift may provide updates or support for Generator at its discretion.</li>
                    <li><span class='bold'>Restrictions:</span> You may not modify, reverse engineer, distribute, or infringe upon any intellectual property rights of Generator or Brainshift, except as permitted by articles 5 and 6 of EU directive 2009/24/EC.</li>
                    <li><span class='bold'>Disclaimer of Warranty:</span> Generator is provided "as is" without any warranties.</li>
                    <li><span class='bold'>Disclaimer Regarding Software Stability:</span> Generator is considered early software and may contain bugs or experience breaking changes during its development. These issues could potentially render your work or the software itself temporarily or permanently unusable. By installing and using Generator, you acknowledge and accept this risk.</li>
                    <li><span class='bold'>Limitation of Liability:</span> Brainshift is not liable for any damages arising from the use of Generator.</li>
                    <li><span class='bold'>Termination:</span> This agreement may be terminated if you fail to comply with its terms.</li>
                    <li><span class='bold'>Governing Law:</span> This agreement is governed by the laws of the European Union.</li>
                    <li><span class='bold'>Entire Agreement:</span> This EULA constitutes the entire agreement between you and Brainshift.</li>
                </ol>
               
                <p><div class='button' id='btnStartTrial' onclick='hideAllMenus(); btnStartTrial.blur(); hideEulaDialog(); startFreeTrial();'>I agree</div></p>
            </div>
        </div>
        <div class='dialogScrollbar' id='eulaScrollbarY'></div>
    </div>

</div>


<div id='minZoomDialog'>

    <div id='minZoomTitle'>
        <div id='minZoomTitleText'>Zoom level for values</div>
        <div class='panelButton dialogButtonClose' id='minZoomClose' onclick='hideAllMenus(); minZoomClose.blur(); hideMinZoomDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='minZoomBody'>
        <input type='text' spellcheck='false' id='minZoomInput' />
    </div>

</div>


<div id='whatsNewBack'></div>

<div id='whatsNewDialog'>
    
    <div id='whatsNewTitle'>
        <div id='whatsNewTitleText'>Version _</div>
        <div class='panelButton dialogButtonClose' id='whatsNewClose' onclick='hideAllMenus(); whatsNewClose.blur(); hideWhatsNewDialog();'>
            <svg width="30" height="31" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: relative; top: -1px; left: -1px;">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='whatsNewDialogContainer'>
        <div id='whatsNewDialogContent'>
            <div id='whatsNewWatermark'>◦<span style="font-weight: 700; position: relative; top: 0.06em;">G</span>•</div>

            <div id='whatsNewBody'>
                <h1 style='margin-top: 20px;'>What's new</h1>

                <p>•  switched to freemium model with some pro features only for subscribers</p>
                <p>•  improved performance</p>
                <p>•  long repeat calculations can now be aborted</p>
                <p>•  Ctrl/Cmd+Enter now reactivates currently active nodes</p>
                <p>•  simplified sets, now they generate only one value per loop iteration</p>
                <p>•  panels are no longer highlighted in Focus mode</p>
                <p>•  added sRGB ⟷ P3 conversion</p>
                <p>•  added Value Name node to set value names in lists</p>
                <p>•  fixed various node bugs</p>
                <p>•  small UI improvements</p>
                
                <p><br/><br/><div id='chkHideWhatsNew'></div></p>
            </div>
        </div>
        <div class='dialogScrollbar' id='whatsNewScrollbarY'></div>
    </div>

</div>


<div id='search'>
    <div id='searchIcon'></div>

    <input id='searchText' 
           type='text' 
           placeholder="Search menus,&nbsp;&nbsp;/&nbsp;&thinsp;to search nodes" 
           spellcheck='false'
           autocomplete='off' />

    <div id='searchResults'>
        <div id='searchItems'></div>
    </div>

    <div id='noSearchResults'>No matches</div>
</div>


<div id='keyboardPanel'>

    <div id='keyboardPanelTabsHolder'>
        <div id='keyboardPanelTabs'>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(0);">Menu</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(1);">View</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(2);">Zoom</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(3);">Selection</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(4);">Nodes</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(5);">Connections</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(6);">Cursor</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(7);">Edit</div>
        </div>
        <div id='keyboardPanelClose' onclick="hideKeyboardPanel();"></div>
    </div>
    
    <div id='keyboardPanelContent'>


        <div class='keyboardPage' id='keyboardPageMenu'>
            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Keep menu open</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutEvent'>click</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Search menus and nodes</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>/</div></div></div></div>
                <div class='keyboardShortcut'></div>
                <div class='keyboardInfo'>Click a node menu to create a node under<br/>the menu button. Drag the menu to directly<br/>move the new node.</div>
            </div>
        </div>


        <div class='keyboardPage' id='keyboardPageView'>

            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Focus on node</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Alt</div><div class='shortcutKey shortcutChar'>S</div></div></div></div>
            </div>

        </div>


        <div class='keyboardPage' id='keyboardPageZoom'>

            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Pan</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Space</div><div class='shortcutEvent'>drag</div></div></div></div>
                <div class='keyboardLabel'>While not using the hand tool...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutEvent'>wheel</div></div></div></div>
                <div class='keyboardLabel'>While using the hand tool...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutEvent'>Wheel</div></div></div></div>
            </div>

            <div class='keyboardGroup nextGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom in</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>+</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom out</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>−</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to 100%</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>0</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to fit</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey shortcutCharNarrow'>1</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to selection</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey shortcutChar'>2</div></div></div></div>
            </div>

        </div>


        <div class='keyboardPage' id='keyboardPageSelection'>

            <!-- <div class='keyboardGroup'>
                <div class='keyboardLabel'>While selecting...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to selection</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom out from selection</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey'>Alt</div></div></div></div>
            </div> -->

            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select all</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>A</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select inverse</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>A</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select none</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Esc</div></div></div></div>
            </div>

            <div class='keyboardGroup nextGroup'>
                <!-- <div class='keyboardShortcut'><div class='shortcutAction'>Toggle selected</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey'>click</div></div></div></div> -->
                <div class='keyboardShortcut'><div class='shortcutAction'>Select tree left</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift treeLeftCtrl'>Shift</div><div class='shortcutEvent'>click</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select tree right</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey treeRightCtrl1'>Alt</div><div class='shortcutKey treeRightCtrl2'>Shift</div><div class='shortcutEvent'>click</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select tree across</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey treeAcross1'>Ctrl</div><div class='shortcutKey treeAcross2'>Alt</div><div class='shortcutEvent'>click</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select entire tree</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey'>Alt</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutEvent'>click</div></div></div></div>
            </div>

        </div>


        <div class='keyboardPage' id='keyboardPageNodes'>
            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Create node</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Menu</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Insert node into branch</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey'>menu</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Connect node in new branch</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey newBranch1'>Ctrl</div><div class='shortcutKey newBranch2'>Alt</div><div class='shortcutKey'>menu</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Create random color</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Alt</div><div class='shortcutKey'>Color menu</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Reactivate active nodes</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey'>Enter</div></div></div></div>
            </div>
            <div class='keyboardGroup nextGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Rename</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey shortcutChar'>R</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Enable/disable</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>E</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Show/hide node icons</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutCharNarrow'>I</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Show/hide operation results</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>R</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Layout selected nodes</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>L</div></div></div></div>
            </div>
        </div>
 

        <div class='keyboardPage' id='keyboardPageConnections'>
            <div class='keyboardGroup'>
                <div class='keyboardLabel'>While connecting from an output...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Copy input value back to output</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div></div></div></div>
            </div>
        </div>

        
        <div class='keyboardPage' id='keyboardPageCursor'>
            <div class='keyboardGroup'>
                <div class='keyboardLabel'>While adjusting (some) values...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Allow values outside the visible limits</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div></div></div></div>
            </div>
            <div class='keyboardGroup nextGroup'>
                <div class='keyboardLabel'>While hovering over a node...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Isolate the node and its connections</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Alt</div></div></div></div>
            </div>
        </div>

        
        <div class='keyboardPage' id='keyboardPageEdit'>
            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Copy</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>C</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Cut</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>X</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Paste</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>V</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Paste with input connections</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>V</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Remove from branch</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutCharWide'>⌫</div></div></div></div>
            </div>
            <div class='keyboardGroup nextGroup'>
                <!-- <div id='shortcutCopyAsJavascript' class='keyboardShortcut'><div class='shortcutAction'>Copy as Javascript</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>C</div></div></div></div> -->
                <div class='keyboardShortcut'><div class='shortcutAction'>Duplicate</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>D</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Duplicate with input connections</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>D</div></div></div></div>
            </div>
        </div>
    
    
    </div>

</div>


<span id='tooltipArrow'></span>



<div id='ttColorblind' class='tooltip'>

    <div style='margin-top: 10px; margin-bottom: 10px;'>
        Three receptor types in our eyes see<br/>
        <i>three calibers of light</i>&ThinSpace;:<br/><br/>
        <p style='margin-top: 4px; margin-bottom: 20px;'><b>S</b>mall, <b>M</b>edium and <b>L</b>arge.</p>
    </div>

    <svg width="187" height="97" viewBox="0 0 187 97" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M64.3525 17.3547C63.1278 17.3547 62.0721 1.13879 60.8053 1.13879C59.5384 1.13879 58.4827 17.3547 57.258 17.3547" stroke="white"/>
        <path d="M84.3644 10.4618C83.8577 8.49826 82.9076 1.13879 82.0886 1.13879C80.8217 1.13879 79.766 17.3547 78.5414 17.3547" stroke="white"/>
        <path d="M78.5414 17.3547C77.3167 17.3547 76.261 1.13879 74.9942 1.13879C73.7273 1.13879 72.6716 17.3547 71.4469 17.3547" stroke="white"/>
        <path d="M71.4469 17.3547C70.2223 17.3547 69.1666 1.13879 67.8997 1.13879C66.6328 1.13879 65.5771 17.3547 64.3525 17.3547" stroke="white"/>
        <path d="M35.9747 17.3547C34.75 17.3547 33.6943 1.13879 32.4274 1.13879C31.1606 1.13879 30.1049 17.3547 28.8802 17.3547" stroke="white"/>
        <path d="M57.258 17.3547C56.0334 17.3547 54.9776 1.13879 53.7108 1.13879C52.4439 1.13879 51.3882 17.3547 50.1635 17.3547" stroke="white"/>
        <path d="M50.1636 17.3547C48.9389 17.3547 47.8832 1.13879 46.6163 1.13879C45.3495 1.13879 44.2938 17.3547 43.0691 17.3547" stroke="white"/>
        <path d="M43.0691 17.3547C41.8445 17.3547 40.7887 1.13879 39.5219 1.13879C38.255 1.13879 37.1993 17.3547 35.9746 17.3547" stroke="white"/>
        <path d="M7.59684 17.3547C6.3722 17.3547 5.31647 1.13879 4.04961 1.13879C2.78274 1.13879 1.72702 17.3547 0.50238 17.3547" stroke="white"/>
        <path d="M28.8802 17.3547C27.6556 17.3547 26.5998 1.13879 25.333 1.13879C24.0661 1.13879 23.0104 17.3547 21.7857 17.3547" stroke="white"/>
        <path d="M21.7857 17.3547C20.5611 17.3547 19.5054 1.13879 18.2385 1.13879C16.9716 1.13879 15.9159 17.3547 14.6913 17.3547" stroke="white"/>
        <path d="M14.6913 17.3547C13.4666 17.3547 12.4109 1.13879 11.144 1.13879C9.87716 1.13879 8.82144 17.3547 7.5968 17.3547" stroke="white"/>
        <path d="M26.1023 49.8573C21.6833 49.8573 17.8738 28.2361 13.3023 28.2361C8.73093 28.2361 4.92142 49.8573 0.50238 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M97.2868 40.4082C95.3801 36.1644 93.2103 28.2361 90.1022 28.2361C85.5307 28.2361 81.7212 49.8573 77.3022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M77.3021 49.8573C72.8831 49.8573 69.0736 28.2361 64.5022 28.2361C59.9308 28.2361 56.1212 49.8573 51.7022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M51.7022 49.8573C47.2832 49.8573 43.4737 28.2361 38.9023 28.2361C34.3308 28.2361 30.5213 49.8573 26.1023 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M130.23 95.5318C119.033 95.5318 109.381 65.8027 97.7978 65.8027C86.215 65.8027 76.5627 95.5318 65.366 95.5318" stroke="white" stroke-width="2"/>
        <path d="M65.366 95.5318C54.1693 95.5318 44.517 65.8027 32.9342 65.8027C21.3514 65.8027 11.6991 95.5318 0.50238 95.5318" stroke="white" stroke-width="2"/>
        <path d="M133.608 95.8832C142.385 95.8832 149.5 88.7683 149.5 79.9916C149.5 71.2149 142.385 64.1 133.608 64.1C124.831 64.1 117.716 71.2149 117.716 79.9916C117.716 88.7683 124.831 95.8832 133.608 95.8832Z" stroke="white" stroke-width="1.5"/>
        <path d="M133.608 95.8832C142.385 95.8832 149.5 88.7683 149.5 79.9916C149.5 71.2149 142.385 64.1 133.608 64.1C124.831 64.1 117.716 71.2149 117.716 79.9916C117.716 88.7683 124.831 95.8832 133.608 95.8832Z" stroke="white" stroke-width="1.5"/>
        <path d="M133.608 95.8832C142.385 95.8832 149.5 88.7683 149.5 79.9916C149.5 71.2149 142.385 64.1 133.608 64.1C124.831 64.1 117.716 71.2149 117.716 79.9916C117.716 88.7683 124.831 95.8832 133.608 95.8832Z" stroke="white" stroke-width="1.5"/>
        <path d="M173 52C180.18 52 186 46.1797 186 39C186 31.8203 180.18 26 173 26C165.82 26 160 31.8203 160 39C160 46.1797 165.82 52 173 52Z" stroke="white" stroke-width="1.5"/>
        <path d="M105.364 46.8303C109.663 46.8303 113.148 43.3454 113.148 39.0467C113.148 34.7479 109.663 31.2631 105.364 31.2631C101.065 31.2631 97.5804 34.7479 97.5804 39.0467C97.5804 43.3454 101.065 46.8303 105.364 46.8303Z" stroke="white" stroke-width="1.5"/>
        <path d="M105.364 46.8303C109.663 46.8303 113.148 43.3454 113.148 39.0467C113.148 34.7479 109.663 31.2631 105.364 31.2631C101.065 31.2631 97.5804 34.7479 97.5804 39.0467C97.5804 43.3454 101.065 46.8303 105.364 46.8303Z" stroke="white" stroke-width="1.5"/>
        <path d="M105.364 46.8303C109.663 46.8303 113.148 43.3454 113.148 39.0467C113.148 34.7479 109.663 31.2631 105.364 31.2631C101.065 31.2631 97.5804 34.7479 97.5804 39.0467C97.5804 43.3454 101.065 46.8303 105.364 46.8303Z" stroke="white" stroke-width="1.5"/>
        <path d="M173 46C176.866 46 180 42.866 180 39C180 35.134 176.866 32 173 32C169.134 32 166 35.134 166 39C166 42.866 169.134 46 173 46Z" stroke="white" stroke-width="1.5"/>
        <path d="M86.3783 12.7566C87.6918 12.7566 88.7566 11.6918 88.7566 10.3783C88.7566 9.06481 87.6918 8 86.3783 8C85.0648 8 84 9.06481 84 10.3783C84 11.6918 85.0648 12.7566 86.3783 12.7566Z" fill="white"/>
        <path d="M173 41C174.105 41 175 40.1046 175 39C175 37.8954 174.105 37 173 37C171.895 37 171 37.8954 171 39C171 40.1046 171.895 41 173 41Z" fill="white"/>
    </svg>
                                                                                      
    <div style='margin-top: 20px; margin-bottom: -5px;'>
        If one or more are defective or absent,<br/>
        we call that <i>color blindness</i>.
    </div>
       
    <div style='margin-top: 16;'>
        Set the condition of each cone type<br/>
        to simulate types of color vision deficiency.
    </div>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorBlindness' onclick="updateSettingAndMenu('showTooltipColorBlindness', true, false); hideTooltip(ttColorblind);">Don't show</div></div>
</div>


<div id='ttToggleWires' class='tooltip'>Show&thinsp;/&thinsp;hide wires</div>


<div id='ttInterpolationSpace' class='tooltip'>

    <div style="margin-left: 7px;" id="ttInterpolationSpaces">
    </div>
    <div style="margin-left: 7px; margin-top: 7px;">
        Determines the interpolation path.
    </div>
    <div style="margin-left: 7px; margin-top: 7px;">
        In RGB and linear spaces<br/>it's a straight line,<br/><br/>
        in spaces with a Hue it's an arc around the center.
    </div>

    <div style="position: absolute; left:  44px; top: 126px;">Luv</div>
    <div style="position: absolute; left:  44px; top: 146px;">Lab</div>
    <div style="position: absolute; left:  42px; top: 176px;">RGB</div>

    <div style="position: absolute; left: 147px; top: 133px;">HSV</div>
    <div style="position: absolute; left: 147px; top: 153px;">HCL</div>

    <svg width="192" height="88" viewBox="0 0 192 88" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-top: 11px;">
        <circle cx="43.945" cy="43.6699" r="42.9129" transform="rotate(164.053 43.945 43.6699)" stroke="white"/>
        <circle cx="148.459" cy="43.6699" r="42.9129" transform="rotate(164.053 148.459 43.6699)" stroke="white"/>
        <path d="M177.161 53.8683C175.042 59.8328 171.117 64.9889 165.932 68.6199C160.747 72.2509 154.56 74.1764 148.23 74.1287C141.9 74.081 135.743 72.0626 130.613 68.3539C125.484 64.6453 121.637 59.4307 119.607 53.4349" stroke="white" stroke-width="0.8" stroke-dasharray="2 2"/>
        <circle cx="16.6584" cy="54.5167" r="2.79505" transform="rotate(164.053 16.1584 54.5167)" fill="white"/>
        <circle cx="71.0077" cy="54.5167" r="2.79505" transform="rotate(164.053 71.5077 54.4231)" fill="white"/>
        <circle cx="121.173" cy="54.5167" r="2.79505" transform="rotate(164.053 120.673 54.5167)" fill="white"/>
        <circle cx="175.522" cy="54.5167" r="2.79505" transform="rotate(164.053 176.022 54.4231)" fill="white"/>
        <line x1="72.3693" y1="54.0053" x2="15.8716" y2="54.0053" stroke="white" stroke-dasharray="2 2"/>
    </svg>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorInterpolationlindness' onclick="updateSettingAndMenu('showTooltipColorInterpolation', true, false); hideTooltip(ttInterpolationSpace);">Don't show</div></div>
</div>


<div id='ttMinValueZoom' class='tooltip'></div>


<!-- <div id='ttInterpolationGamma' class='tooltip'>
    <div style="text-align: center;">Gamma correction</div>              
    <div style="margin-top: 14px;">How linearly the lightness is interpolated.</div>
</div> -->


<div id='ttWcag2' class='tooltip'>

    <!-- <div style='text-align: center;'>Contrast ratio</div> -->
    
    <div class='wcag2description' style='left: 50px;'>min. normal  </div>
    <div class='wcag2description' style='left: 71px;'>min. reduced </div>
    <div class='wcag2description' style='left: 93px;'>min. assisted</div>
    <div class='wcag2description' style='left: 115px;'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vision</div>

    <svg width="221" height="21" viewBox="0 0 221 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 20px; top: 77px">
        <path d="M220.452 20.2466H70.0214V10.7924H220.452V20.2466Z" fill="white" fill-opacity="0.4"/>
        <path d="M30.0214 0V20.2466" stroke="white"/>
        <path d="M45.0214 0V20.2466" stroke="white"/>
        <path d="M70.0214 0V20.2466" stroke="white"/>
        <path d="M30.0214 10.7924H0.0213623V20.2465H30.0214V10.7924Z" fill="#FF3232" fill-opacity="0.5"/>
        <path d="M45.0214 10.7924H30.0214V20.2465H45.0214V10.7924Z" fill="#FFFF36" fill-opacity="0.55"/>
        <path d="M70.0214 10.7924H45.0214V20.2465H70.0214V10.7924Z" fill="#4FFE15" fill-opacity="0.5"/>
    </svg>
                
    <div class='wcag2value' style='left:  18px;'> 0  </div>
    <div class='wcag2value' style='left:  48px;'> 3  </div>
    <div class='wcag2value' style='left:  68px;'> 4.5</div>
    <div class='wcag2value' style='left:  90px;'> 7  </div>
    <div class='wcag2value' style='left: 239px;'>21  </div>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorContrast2' onclick="updateSettingAndMenu('showTooltipColorContrast', true, false); hideTooltip(ttWcag2);">Don't show</div></div>
    <!-- <div id='wcag2info'><a href='https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html#visual-audio-contrast7-87-head' target='_blank'>More details</a></div> -->
</div>


<div id='ttWcag3' class='tooltip'>

    <!-- <div style='text-align: center;'>APCA visual contrast</div> -->
    
    <div class='wcag3description' style='left:  52px;'>discernible</div>
    <div class='wcag3description' style='left:  84px;'>minimum</div>
    <div class='wcag3description' style='left: 117px;'>large text</div>
    <div class='wcag3description' style='left: 148px;'>other text</div>
    <div class='wcag3description' style='left: 179px;'>body text</div>
    <div class='wcag3description' style='left: 211px;'>all text</div>

    <svg width="222" height="21" viewBox="0 0 222 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 19px; top: 65px">
        <rect x="0.854492" y="10.7924" width="31.5139" height="9.45416" fill="#FF0040" fill-opacity="0.5"/>
        <rect x="32.3684" y="10.7924" width="31.5139" height="9.45416" fill="#FF7048" fill-opacity="0.5"/>
        <rect x="63.8822" y="10.7924" width="31.5139" height="9.45416" fill="#FFB92F" fill-opacity="0.5"/>
        <rect x="95.3961" y="10.7924" width="31.5139" height="9.45416" fill="#FFFF36" fill-opacity="0.5"/>
        <rect x="126.91" y="10.7924" width="31.5139" height="9.45416" fill="#4FFE15" fill-opacity="0.5"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 158.424 20.2466)" fill="#7070FF" fill-opacity="0.7"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 189.938 20.2466)" fill="white" fill-opacity="0.4"/>
        <line x1="32.8684" x2="32.8684" y2="20.2466" stroke="white"/>
        <line x1="64.3822" x2="64.3822" y2="20.2466" stroke="white"/>
        <line x1="95.8961" x2="95.8961" y2="20.2466" stroke="white"/>
        <line x1="127.41" x2="127.41" y2="20.2466" stroke="white"/>
        <line x1="158.924" x2="158.924" y2="20.2466" stroke="white"/>
        <line x1="190.438" x2="190.438" y2="20.2466" stroke="white"/>
    </svg>

    <div class='wcag3value' style='left:  20px;'>  0</div>
    <div class='wcag3value' style='left:  52px;'> 15</div>
    <div class='wcag3value' style='left:  84px;'> 30</div>
    <div class='wcag3value' style='left: 114px;'> 45</div>
    <div class='wcag3value' style='left: 147px;'> 60</div>
    <div class='wcag3value' style='left: 179px;'> 75</div>
    <div class='wcag3value' style='left: 210px;'> 90</div>
    <div class='wcag3value' style='left: 239px;'>105</div>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorContrast3' onclick="updateSettingAndMenu('showTooltipColorContrast', true, false); hideTooltip(ttWcag3);">Don't show</div></div>
    <!-- <div id='wcag3info'><a href='https://www.myndex.com/APCA/#font-size-and-weight' target='_blank'>More details</a></div> -->
</div>



<div id='ttText' class='tooltip'>
    <div id='ttTextString'></div>
    <!-- <div class='tooltipBottom' id='tooltipTextBottom'><div class='ignoreButton' id='ignoreText' onclick="updateSettingAndMenu('showTooltipLongText', true, false); hideTooltip(ttText);">Don't show</div></div> -->
</div>


<script id='generatorScript' type='javascript/worker'>
'use strict';




const generatorVersion = 193;


const MAX_INT32        = 2147483647;
  
const NULL             = '';
  
const HTAB             = '  '; // half-tab
const TAB              = '    ';
const NL               = '\n';
  
const GENERATOR_LOGO   = '◦ G •';
const OBJECT_PREFIX    = GENERATOR_LOGO + ' ';

const nodeTag          = 'G_NODE';
const connTag          = 'G_CONN';
const pageTag          = 'G_PAGE';
const tempTag          = 'G_TEMP';


const identity = Object.freeze(
    [[1, 0, 0],
     [0, 1, 0],
     [0, 0, 1]]);



const Epsilon = 0.0000001;
const Tau     = Math.PI * 2;



var enableAsserts = false;



function almostZero(x, eps = 0.0000001) 
{ 
    return Math.abs(x) < eps ? 0 : x;
}



function nozero(x, eps = Epsilon) 
{ 
    return x != 0 
         ? x 
         : (x < 0 ? -eps : eps);
}



function nozerov(v) 
{ 
    return point(
        nozero(v.x), 
        nozero(v.y)); 
}



function equal(a, b, eps = Epsilon)
{
    return Math.abs(b - a) < eps;
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };
 

function toInt(f) { return Math.floor(f) | 0; }



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >>  1;
    x |= x >>  2;
    x |= x >>  4;
    x |= x >>  8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function gcd(a, b)
{
    let temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



function distance(p1, p2)
{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function dot(v1, v2)
{
    return v1.x * v2.x + v1.y * v2.y;
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(...mm)
{
    consoleAssert(mm.length > 0, 'mulm3m3() must take at least one argument');

    let result = clone(mm[0]);

    for (let a = 1; a < mm.length; a++)
    {
        const m1 = result;
        const m2 = mm[a];

        const m = [[0, 0, 0],
                   [0, 0, 0],
                   [0, 0, 0]];

        for (let i = 0; i < 3; i++)
        {
            for (let j = 0; j < 3; j++)
            {
                /*	calculate the dot product of ith row 
                    of this and jth column of m  */
                for (let k = 0; k < 3; k++)
                    m[i][j] += m1[i][k] * m2[k][j];
            }
        }

        result = m;
    }

    return result;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inversem3(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function createRotateTransform(angle)
{
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    return [[ cosA, sinA, 0],
            [-sinA, cosA, 0],
            [ 0,    0,    1]];
}



function createTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0)
{
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],
            [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],
            [0,                         0,                         1]];
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return v1.x * v2.y - v1.y * v2.x;
}	



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divv(v1, v2)
{
    return point(
        v1.x / v2.x,
        v1.y / v2.y);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function charCodeArrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function stringToCharCodeArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    const newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    const size = Math.min(srcSize, dstSize);

    for (let i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function arraysAreEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (let i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function arraysIntersect(array1, array2)
{
    return array1.findIndex(i => array2.includes(i)) > -1;
}



function  leftArrowChar(list) { return list ? '⟸' : '⟵'; }
function rightArrowChar(list) { return list ? '⟹' : '⟶'; }

function nodeNameForStorage(nodeId) { return nodeTag + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag + ' ' + name;   }
function pageNameForStorage(name)   { return pageTag + ' ' + name;   }



function parseBool(str) 
{ 
    return str.toLowerCase() == 'true'
        || str == '1';
}



function connToString(_conn, logSpace = false)
{
    return getConnectionString(
        _conn.outputNodeId,
        _conn.outputId,
        _conn.outputOrder,
        _conn.inputNodeId,
        _conn.inputId,
        _conn.list,
        logSpace);
}



function getConnectionKey(outputNodeId, outputId, outputOrder, inputNodeId, inputId)
{
    return connNameForStorage(
          outputNodeId + ' '
        + outputId     + ' '
        + outputOrder  + ' '
        + inputNodeId  + ' '
        + inputId);
}



function getStorageConnKey(conn)
{
    return getConnectionKey(
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId);
}



function getConnKey(conn)
{
    return getConnectionKey(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id);
}



function getConnString(conn, logSpace = false)
{
    return getConnectionString(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id,
        conn.list,
        logSpace);
}



function getConnectionString(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, logSpace = false)
{
    const  sp   = logSpace ? ' ' : '  '; 
    const jsp   = logSpace ? ''  : ' '; 

    const arrow = 
          sp 
        + subscriptNumber(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder) 
        + rightArrowChar(typeof list == 'string' ? parseBool(list) : list) 
        + sp;

    const join  = jsp + '.' + jsp;

    return '( '
         + outputNodeId + join + outputId
         + arrow
         + inputNodeId  + join + inputId
         + ' )';
}



function getPageKey(pageId)
{
    return pageNameForStorage(pageId);
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '⁰';
        case '1': return '¹';
        case '2': return '²';
        case '3': return '³';
        case '4': return '⁴';
        case '5': return '⁵';
        case '6': return '⁶';
        case '7': return '⁷';
        case '8': return '⁸';
        case '9': return '⁹';
        case '.': return '·';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '₀';
        case '1': return '₁';
        case '2': return '₂';
        case '3': return '₃';
        case '4': return '₄';
        case '5': return '₅';
        case '6': return '₆';
        case '7': return '₇';
        case '8': return '₈';
        case '9': return '₉';
        case '.': return ' ';
    }
}



function boolToString(bool)
{
    return bool ? 'true' : 'false';
}



function isValid(val)
{
    return val != undefined
        && val != null;
}



function isEmpty(array)
{
    return array.length == 0;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (isEmpty(array))
        return null;

    let last = array.at(-1);
    array.splice(array.length-1, 1)

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}



function removeFromArray(array, item)
{
    const index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeArrayFromArray(fromArray, array)
{
    for (const item of array)
    {
        const index = fromArray.indexOf(item);
        
        if (index > -1)
            fromArray.splice(index, 1);
    }
}



function removeFromArrayWhere(array, where)
{
    const index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function cleanStyleId(styleId)
{
    return styleId.split(',')[0] + ',';
}



function getLinearPathData(points)
{
    let pathData = '';


    if (points.length < 2)
        return pathData;


    pathData += 'M';
    pathData += ' ' + almostZero(points[0].x);
    pathData += ' ' + almostZero(points[0].y);

    for (let i = 1; i < points.length; i++)
    {
        pathData += 
              ' L'
            + ' ' + almostZero(points[i].x)
            + ' ' + almostZero(points[i].y);
    }


    return pathData;
}



function point(x, y) { return {x: x, y: y}; }



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueBy(array, item, equal)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueBy(array, i, equal));
    else if (!array.find(equal))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function consoleAssert(...args)
{
    // if (  !settings 
    //     || settings.enableAsserts)
    if (enableAsserts)
        console.assert(...args);
}



function consoleError(...args)
{
    // if (  !settings
    //     || settings.enableAsserts)
    if (enableAsserts)
        console.error(...args);
}



function trimCharFromStart(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(0, trim.length) == trim) 
        str = str.substring(trim.length);

    return str;
}



function trimCharFromEnd(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(str.length - trim.length) == trim) 
        str = str.substring(0, str.length - trim.length);

    return str;
}



function getObjectFills(genObjFills)
{
    const fills = [];


    for (const fill of genObjFills)
    {
        switch (fill[0])
        {
            case 'SOLID':
            {
                const color = {
                    r: Math.min(Math.max(0, fill[1] / 0xff), 1), 
                    g: Math.min(Math.max(0, fill[2] / 0xff), 1), 
                    b: Math.min(Math.max(0, fill[3] / 0xff), 1) };

                const opacity = Math.min(Math.max(0, fill[4] / 100), 1);


                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(opacity))
                    fills.push(
                    {
                        type:      fill[0], 
                        color:     color,
                        opacity:   opacity,
                        blendMode: fill[5]
                    });


                break;
            }

            case 'GRADIENT_LINEAR':
            case 'GRADIENT_RADIAL':
            case 'GRADIENT_ANGULAR':
            case 'GRADIENT_DIAMOND':
            {
                const xform = fill[1];


                const stops = [];

                for (const stop of fill[2])
                {
                    stops.push({
                        color: 
                        {
                            r: Math.min(Math.max(0, stop[0]), 1),
                            g: Math.min(Math.max(0, stop[1]), 1),
                            b: Math.min(Math.max(0, stop[2]), 1),
                            a: Math.min(Math.max(0, stop[3]), 1)
                        },
                        position: stop[4]
                    })    
                }


                fills.push(
                {
                    type:              fill[0],
                    gradientTransform: xform,
                    gradientStops:     stops,
                    blendMode:         fill[3]
                });


                break;
            }
        }
    }


    return fills;
}


function rgbFromType(type, active)
{
    return rgbFromTypeMode(type, active, darkMode);
}



function rgbFromTypeMode(type, active, mode)
{
    if (NUMBER_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveNumberDark : rgbActiveNumberLight)
            : (mode ? rgbNumberDark       : rgbNumberLight      );

    else if (TEXT_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveTextDark   : rgbActiveTextLight)
            : (mode ? rgbTextDark         : rgbTextLight      );

    else if (SHAPE_TYPES.includes(type)
         || EFFECT_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveShapeDark  : rgbActiveShapeLight)
            : (mode ? rgbShapeDark        : rgbShapeLight      );

    else if (GROUP_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveGroupDark  : rgbActiveGroupLight)
            : (mode ? rgbGroupDark        : rgbGroupLight      );

    else if (FLOW_TYPES.includes(type)
          || type == ANY_VALUE)
        return active 
            ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (mode ? rgbFlowDark         : rgbFlowLight      );

    else if (type == COLOR_STYLE)
        return active 
            ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (mode ? rgbFlowDark         : rgbFlowLight      );


    switch (type)
    {
        case COLOR_VALUE:      
        case FILL_VALUE:
        case STROKE_VALUE:
        case COLOR_STOP_VALUE:
        case GRADIENT_VALUE:

        case COLOR:           
        case COLOR_INTERPOLATE:
        case CORRECT_COLOR:
        case COLOR_CONTRAST:
        case COLORBLIND:
        case COLOR_BLEND:

        case COLOR_STOP:
        case GRADIENT:

            return active 
                ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
                : (mode ? rgbFlowDark         : rgbFlowLight      );
    }

    
    return [0xff, 0, 0xff];
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function isSimpleLatinLetter(c)
{
    return c >= 'a' && c <= 'z'
        || c >= 'A' && c <= 'Z';
}


function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function getDecimalFactor(dec)
{
    return Math.pow(10, -dec);
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function decDigits(num) 
{
    if (typeof num !== 'number')
        consoleError('Input must be a number');
    
    const strNum = num.toFixed(10);
    const iDec   = strNum.indexOf('.');
    
    if (iDec === -1)
        return 0;
    
    let count = 0;
    for (let i = iDec + 1; i < strNum.length; i++)
        if (strNum[i] !== '0')
            count++;
    
    return count;
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     lst str = Number(num).toFixed(dec).toString();

//     let i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function getQueryVariable(strVar)
{
    const query = window.location.search.substring(1);
    const vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function ceilTo(x, dec)
{
    const div = Math.ceil(Math.pow(10, dec));
    return Math.ceil((x + Number.EPSILON) * div) / div;    
}



function distance_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function angle_(x, y)
{
    let angle = Math.atan2(y, x);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



// function ipow(n, e)
// {
//     let res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    let carry = 0n;
    
    // multiply individual digits of res[] by n
    for (let i = 0; i < resSize; i++) 
    {
        const prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    const num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    let d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (let i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    let val = 0;
    let mul = 1;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function lerp2(f0, f1, f2, t)
{
    const c0 = lerp(f0, f1, t);
    const c1 = lerp(f1, f2, t);

    return lerp(c0, c1, t);
}



function lerp3(f0, f1, f2, f3, t)
{
    const c0  = lerp(f0, f1, t);
    const c1  = lerp(f1, f2, t);
    const c2  = lerp(f2, f3, t);

    const c01 = lerp(c0, c1, t);
    const c12 = lerp(c1, c2, t);

    return lerp(c01, c12, t);
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function dot3(m, v) 
{
    const result = [];

    for (let i = 0; i < m.length; i++) 
    {
        let sum = 0;

        for (let j = 0; j < v.length; j++) 
            sum += m[i][j] * v[j];

        result.push(sum);
    }
   
    return result;
}


const point_NaN = point(Number.NaN, Number.NaN);



function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function unit(v)
{
    return v.X != 0 
        || v.Y != 0
        ? mulvs(v, 1 / lengthv(v))
        : point(0, 0);
}



function lerpv(p0, p1, t)
{
    return point(
        lerp(p0.x, p1.x, t),
        lerp(p0.y, p1.y, t));
}



function lerpv2(p0, p1, p2, t)
{
    return point(
        lerp2(p0.x, p1.x, p2.x, t),
        lerp2(p0.y, p1.y, p2.y, t));
}



function lerpv3(p0, p1, p2, p3, t)
{
    return point(
        lerp3(p0.x, p1.x, p2.x, p3.x, t),
        lerp3(p0.y, p1.y, p2.y, p3.y, t));
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        const r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        const r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    const t0 = 0;
    const t1 = 1;

    const dx = x2 - x1;
    const dy = y2 - y1;

    const cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    const cr = clipEdge( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    const ct = clipEdge(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    const cb = clipEdge( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    const v1 = subv(p2, p1);
    const v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    const t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    const t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    const d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    const xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectInside(rect1, rect2)
{
    return rect1.l >= rect2.l
        && rect1.r <= rect2.r
        && rect1.t >= rect2.t
        && rect1.b <= rect2.b; 
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}



function circleCenter(p1, p2, p3)
{
    const v1 = subv(p2, p1);
    const v2 = subv(p3, p2);

    const m1 = divvs(addv(p1, p2), 2);
    const m2 = divvs(addv(p2, p3), 2);

    return intersectLines(
        m1, addv(m1, v2), 
        m2, subv(m2, v1), 
        false);
}



function halfArcAngle(p1, p2, p3)
{
    // returns the angle of the first half of the arc p1-p2

    const pc = circleCenter(p1, p2, p3);

    let a = angleDiff(
        angle(subv(p1, pc)),
        angle(subv(p2, pc)));

    // console.log('angle(subv(p1, pc) =', angle(subv(p1, pc)));    
    // console.log('angle(subv(p2, pc) =', angle(subv(p2, pc)));        
    // while (a < 0)
    //     a += Tau;

    return a;
}


function bezierTangent(x0, y0, x1, y1, x2, y2, x3, y3, t)
{
    const p0 = point(x0, y0);
    const p1 = point(x1, y1);
    const p2 = point(x2, y2);
    const p3 = point(x3, y3);

    return unit(addv(addv(
        mulvs(subv(p1, p0), 3*sqr(1-t)),
        mulvs(subv(p2, p1), 6*(1-t)*t)),
        mulvs(subv(p3, p2), 3*sqr(t))));
}



function positionOnSegment(p0, p1, p2, p3, arcLen, error = 0.001)
{
    const hullLength = 
          distance(p0, p1) 
        + distance(p1, p2)
        + distance(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = arcLen / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(arcLen - length) > error
        && loopProtect-- > 0)
    {
        t += (arcLen - length) / hullLength;

        halves = splitSeg(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        console.log('endless loop in positionOnSegment()');


    return t;
}



function splitSeg(p0, p1, p2, p3, t)
{
    const c0   = lerpv(p0, p1, t);
    const c1   = lerpv(p1, p2, t);
    const c2   = lerpv(p2, p3, t);
                
    const c01  = lerpv(c0, c1, t);
    const c12  = lerpv(c1, c2, t);

    const c012 = lerpv(c01, c12, t);

    return [
        [p0, c0, c01, c012],
        [c012, c12, c2, p3] ];
}



// function splitSegments(_p0, _p1, _p2, _p3, ts)
// {
//     const segments = [];


//     let p0 = _p0, 
//         p1 = _p1,
//         p2 = _p2,
//         p3 = _p3;

//     for (let i = 0; i < ts.length; i++)
//     {
//         const parts = split(p0, p1, p2, p3, ts[i]);
//         const l     = parts[0];
//         const r     = parts[1];


//         segments.push(l);


//         if (i < ts.length-1)
//         {
//             p0 = r[0];
//             p1 = r[1];
//             p2 = r[2];
//             p3 = r[3];

//             for (let j = i+1; j < ts.length; j++)
//                 ts[j] = 1 - (1 - ts[j]) / (1 - ts[i]);
//         }
//         else segments.push(r);
//     }


//     return segments;
// }



function arcLength(p0, p1, p2, p3, error = 0.0000001)
{
    const arcLen = 
          distance(p0, p1)
        + distance(p1, p2)
        + distance(p2, p3);

    const chord = distance(p0, p3);

    if ((arcLen - chord) > error)
    {
        const halves = splitSeg(p0, p1, p2, p3, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength(l[0], l[1], l[2], l[3], error)
             + arcLength(r[0], r[1], r[2], r[3], error);
    }

    return arcLen;
}



function bounds2(p0, p1, p2)
{
    let rect = Rect.NaN;


    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p2);

    /*	if p1 is between p0 and p2 then 
        p0 and p2 are opposite corners of the bounds  */

    if (   (   p0.x <= p1.x && p1.x <= p2.x
            || p2.x <= p1.x && p1.x <= p0.x)
        && (   p0.y <= p1.y && p1.y <= p2.y
            || p2.y <= p1.y && p1.y <= p0.y))
        return rect;


    const ax = p0.x - 2*p1.x + p2.x;
    const bx = 2 * (p1.x - p0.x);
    
    const ay = p0.y - 2*p1.y + p2.y;
    const by = 2 * (p1.y - p0.y);


    const tx = -bx / nozero(2*ax);
    const ty = -by / nozero(2*ay);


    if (tx >= 0 && tx <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, tx));
    if (ty >= 0 && ty <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, ty));
    

    return rect;
}



function bounds3(p0, p1, p2, p3)
{
    let rect = Rect.NaN;


    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p3);


    const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;
    const bx =  3*p0.x - 6*p1.x + 3*p2.x;
    const cx = -3*p0.x + 3*p1.x;

    const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;
    const by =  3*p0.y - 6*p1.y + 3*p2.y;
    const cy = -3*p0.y + 3*p1.y;


    const roots = []; // there will be ≤4 solutions

    bounds3t(ax, bx, cx, roots);
    bounds3t(ay, by, cy, roots);


    for (const root of roots)
    {
        rect = expandRect_(
            rect, 
            lerpv3(p0, p1, p2, p3, root));
    }


    return rect;
}



function bounds3t(a, b, c, roots)
{
    let a_ = a * 3;
    let b_ = b * 2;


    let D = b_*b_ - 4*a_*c;
    let r;

    if (a_ == 0)
    {
        r = -c/b_;  if (r >= 0 && r <= 1) roots.push(r);
    }
    else
    {
        const _2a = 1/(2*a_);
        b_ *= _2a;
    
        if (D == 0)
        {
            if (b_ >= 0 && b_ <= 1) roots.push(-b_);
        }
        else if (D > 0)
        {
            D = Math.sqrt(D) * _2a;

            r = -b_ + D;  if (r >= 0 && r <= 1) roots.push(r);
            r = -b_ - D;  if (r >= 0 && r <= 1) roots.push(r);
        }
    }
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    const size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (let i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    let rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    let c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    let d = x - 1n;
    let s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (let i = 0; i < k; i++)    
    {
        const a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    let x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (let j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    let val = 0n;
    let mul = 1n;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    const gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    const gcd = bigGcdExtended(m % n, n);

    const x   = gcd[1];
    const y   = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l()            { return this.x;            }
    get c()            { return this.x + this.w/2; }
    get r()            { return this.x + this.w;   }
           
    get t()            { return this.y;            }
    get m()            { return this.y + this.h/2  }
    get b()            { return this.y + this.h;   }
          
    get tl()           { return point(this.l, this.t); }
    get tc()           { return point(this.c, this.t); }
    get tr()           { return point(this.r, this.t); }
    get ml()           { return point(this.l, this.m); }
    get mc()           { return point(this.c, this.m); }
    get cm()           { return point(this.c, this.m); }
    get mr()           { return point(this.r, this.m); }
    get bl()           { return point(this.l, this.b); }
    get bc()           { return point(this.c, this.b); }
    get br()           { return point(this.r, this.b); }
      
      
    get width()        { return this.w; }
    get height()       { return this.h; }
      
    get left()         { return this.l; }
    get center()       { return this.c; }
    get right()        { return this.r; }
          
    get top()          { return this.t; }
    get middle()       { return this.m; }
    get bottom()       { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromRect(rect)
    {
        return new Rect(rect.x, rect.y, rect.width, rect.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



function expandRect_(rect, p)
{
    if (rect.isNaN) return new Rect(p.x, p.y, 0, 0);

    return new AbsRect(
        Math.min(p.x, rect.l),
        Math.min(p.y, rect.t),
        Math.max(p.x, rect.r),
        Math.max(p.y, rect.b));
}



class Random
{
    seed;
    index; // for next()

    cache;



    constructor(seed = 0)
    { 
        this.seed  = seed; 
        this.index = 0;
        
        this.updateCache(256);
    }



    copy()
    {
        return new Random(this.seed, this.last);
    }



    updateCache(size)
    {
        this.cache = new Int32Array(size);

        let seed = this.seed;
        let last = seed;

        for (let i = 0; i < size; i++)
            this.cache[i] = seed = this.generate(seed, last);
    }



    next()
    {
        if (this.index >= this.cache.length)
            this.updateCache(nextPow2(this.index));

        return this.cache[this.index++] / -0x7fffffff;
    }



    get(index)
    {
        if (index >= this.cache.length)
            this.updateCache(nextPow2(index+1));

        return this.cache[index] / -0x7fffffff;
    }



    generate(seed, last)
    {
        last = seed;
        
        seed = (seed + 0x7ed55d16) + (seed << 12);
        seed = (seed ^ 0xc761c23c) ^ (seed >> 19);
        seed = (seed + 0x165667b1) + (seed <<  5);
        seed = (seed + 0xd3a2646c) ^ (seed <<  9);
        seed = (seed + 0xfd7046c5) + (seed <<  3);
        seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);

        return seed;
    }
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



var utilCanvas;
var utilContext;
    


function initUtilContext()
{
    utilCanvas  = document.createElement('canvas');
    utilContext = utilCanvas.getContext('2d');

    utilContext.willReadFrequently = true;
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function pluralString(count, pluralChar = 's')
{
    return count == 1 ? '' : pluralChar;
}



function countString(count, itemName)
{
    const lastChar   = itemName.at(-1);
    const pluralChar = lastChar == lastChar.toUpperCase() ? 'S' : 's';

    return itemName + pluralString(count, pluralChar);
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');
    const commaIndex = strValue.indexOf(',');

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    const svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    let str = '';

    for (let i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function printNum(num)
{
    return !isNaN(num) ? num : NAN_DISPLAY;
}



function parseNum(str)
{
    return str == NAN_DISPLAY
         ? Number.NaN 
         : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function osCtrl     (plus = true) { return isMac ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); }
function osAlt      (plus = true) { return isMac ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); }
function osShift    (plus = true) { return isMac ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); }
function osCtrlShift(plus = true) { return isMac ? osShift(plus) + osCtrl(plus) : osCtrl(plus) + osShift(plus); }



function getCreateNodeAction(type, creatingButton, options)
{
    return  options.insert != undefined
        &&  options.insert
        && (    options.autoConnect == undefined
            || !options.autoConnect)
        ? new CreateInsertNodeAction(type, creatingButton, options)
        : new CreateNodeAction      (type, creatingButton, options, options.autoConnect != undefined && options.autoConnect);
}



function simpleIntHash(x)
{
    return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32);
}



function getNewNumberId(nodes, checkExists, curId, id = curId, join = '')
{
    if (!checkExists(id))
        return id;
    

    let numLength = getNumLength(id);

    if (numLength > 0)
    {
        const len = id.length - numLength;
        let   num = parseInt(id.substring(len));

        let newId = '';
        while (newId == '' || checkExists(newId))
            newId = id.substring(0, len + join.length) + join + (++num);

        return newId;
    }

    else if (numLength == 0)
    {
        let num   = 2;
        let newId = id + join + num;

        while (checkExists(newId))
            newId = id + join + (++num);

        return newId;
    }

    else
        return id;
}



function getNumLength(name)
{
    let numLength = 0;

    for (let i = name.length - 1; i >= 0; i--)
    {
        if (isDigit(name[i])) numLength++;
        else break;
    }

    return numLength;
}



function isValidFloatString(str) 
{
    return /^-?\d*\.?\d*(e-?\d+)?$/.test(str);
}



function setControlFont(control, family, size, align = 'left')
{
    control.style.fontFamily = family;
    control.style.fontSize   = size + 'px';
    control.style.textAlign  = align;
}



function daysInMonth(month, year)
{
    if (month == 2)
    {
        return year % 4 != 0
             ? 28
             : 29;
    }
    else if (month == 4
          || month == 7
          || month == 9
          || month == 11)
        return 30;
    else
        return 31;
}



function getFontStyles(fontName)
{
    let fonts = figFonts.filter(f => f.fontName.family == fontName)


    fonts.sort((a, b) =>
    {
        if (a.fontName.style != b.fontName.style)
            return FONT_WEIGHTS.findIndex(w => w[0] == a.fontName.style.toLowerCase())
                 - FONT_WEIGHTS.findIndex(w => w[0] == b.fontName.style.toLowerCase());

        return 0;
    });

    
    return fonts.map(f => f.fontName.style);
}



function unescapeString(str)
{
    return str.replace(/\\(.)/g, (match, char) => 
    {
        const replacements = 
        {
            'n':  '\n',
            'r':  '\r',
            't':  '\t',
            '\\': '\\',
            '\'': '\'',
            '\"': '\"',
            '\`': '\`'
        };
      
        return replacements[char] || match;
    });
}



function getEditDistance(str1, str2)
{
    // calculate the Levenshtein distance between two strings
    // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html

    // TODO replace with Damerau-Levenshtein

    if (str1.length == 0) return str2.length;
    if (str2.length == 0) return str1.length;

    // make sure str1 is the shorter string

    if (str1.length > str2.length)
    {
        const _str = str1;
        str1 = str2;
        str2 = _str;
    } 

    let len1 = str1.length; // min length of the two strings
    let len2 = str2.length;

    // suffix common to both strings can be ignored

    while (len1 > 0 
        && str1[len1 - 1] == str2[len2 - 1])
    {
        len1--; 
        len2--; 
    }

    let start = 0;

    // if there's a shared prefix or str1 == str2's suffix

    if (str1[0] == str2[0])
    {
        while (start < len1 
            && str1[start] == str2[start]) 
            start++;

        len1 -= start; // length of the part excluding common prefix and suffix
        len2 -= start;

        // if str1 == prefix and/or suffix of str2, 
        // edit distance is just the number of additional characters in str2

        if (len1 == 0) return len2;

        str2 = str2.substring(start, len2); // faster than str2[start + j] in inner loop below
    }

    //

    let v0 = [];
    
    for (let j = 0; j < len2; j++) 
        v0.push(j + 1);

    //

    let current = 0;

    for (let i = 0; i < len1; i++)
    {
        const c = str1[start + i];

        let left = current = i;

        for (let j = 0; j < len2; j++)
        {
            const above = current;
           
            current = left; // cost on diagonal (substitution)
            left = v0[j];

            if (c != str2[j])
            {
                current++; // substitution

                let insDel = above + 1; // deletion

                if (insDel < current) 
                    current = insDel;

                insDel = left + 1; // insertion

                if (insDel < current) 
                    current = insDel;
            }

            v0[j] = current;
        }
    }
    
    return current;
}



function skipRandom(count)
{
    for (let i = 0; i < count; i++) 
        Math.random();
}



function includesSimilar(str, sub, levenshteinDistance)
{
    if (sub.length > str.length)
        return false;
    
    if (str.includes(sub))
        return true;
    
    for (let i = 0; i <= str.length - sub.length; i++) 
    {
        const s = str.substring(i, i + sub.length);
        
        if (getEditDistance(sub, s) <= levenshteinDistance)
            return true;
    }
}



function degamma(rgb, cs = sRGB)
{
    return [ cs.degamma(rgb[0]),
             cs.degamma(rgb[1]),
             cs.degamma(rgb[2]) ];
}



function regamma(rgb, cs = sRGB)
{
    return [ cs.regamma(rgb[0]),
             cs.regamma(rgb[1]),
             cs.regamma(rgb[2]) ];
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    const inLen  = base64.length;

    const outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    const bytes = new Uint8Array(outLen);

    for (let mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    let mod3   = 2, 
        base64 = "";

    const length = bytes.length;

    for (let i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    let   str    = "";

    const length = bytes.length;

    for (let i = 0; i < length; i++) 
    {
        const byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    let strLen = str.length, 
        arrLen = 0;


    // mapping

    for (let i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    const bytes = new Uint8Array(arrLen);


    // transcription

    for (let i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        const chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function appendDivTo(div, to)
{
    if (!to.contains(div))
        to.appendChild(div);
}



function removeDivFrom(div, from)
{
    if (from.contains(div))
        from.removeChild(div);
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function createTextarea(className = '')
{
    const textarea = document.createElement('textarea');

    if (className.trim() != '')
        textarea.className = className;
    
    textarea.spellcheck = false;
    
    return textarea;
}



function enableElementText(elem, enable, bold = true)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 

    if (bold)
        elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    const elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    const e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



function offsetRect(element)
{
    return new Rect(
        element.offsetLeft,
        element.offsetTop,
        element.offsetWidth,
        element.offsetHeight);
}



function clientRect(element)
{
    return new Rect(
        element.clientLeft,
        element.clientTop,
        element.clientWidth,
        element.clientHeight);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function selectElementText(elementId)
{
    if (document.selection) // IE
    {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(elementId));
        range.select();
    }
    else if (window.getSelection) 
    {
        var range = document.createRange();
        range.selectNode(document.getElementById(elementId));
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
}



function isTouchpad(e)
{
    return Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;
}



function showElement(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hideElement(element)              
{ 
    showElement(element, false); 
}



function isVisible(element)
{
    return element.offsetParent !== null;
}



function getSelectedText(element) // only allow input[type=text] & textarea
{ 
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        return element.value.substring(
            element.selectionStart,
            element.selectionEnd);
    }
}



function clearSelectedText(element)
{
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        const str = element.value;

        element.value = 
              str.slice(0, element.selectionStart) 
            + str.slice(element.selectionEnd)
    }
}



function scrollbarVisible(element) 
{
    return element.scrollHeight > element.clientHeight;
}



function clientPos(e)
{
    return point(e.clientX, e.clientY);
}



function elementHasSelectedText(div)
{
    const selection = window.getSelection();

    if (selection.rangeCount > 0) 
    {
        const range = selection.getRangeAt(0);
        
        if (   range.commonAncestorContainer === div
            || div.contains(range.commonAncestorContainer))
        {
            const selectedText = range.toString().trim();

            if (selectedText.length > 0)
                return true;
        }
    }

    return false; 
}



function selectDivText(div)
{
    var range = document.createRange();
    range.selectNode(div);

    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);    
}



function loadFromLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '.gen';
    
    input.onchange = e => 
    { 
        const file = e.target.files[0]; 

        const reader = new FileReader();
        reader.readAsText(file,'UTF-8');

        reader.onload = e => callback(e.target.result);
    }; 

    input.click();
}



function getLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '*.*';
    
    input.onchange = e => 
    { 
        callback(e.target.files[0]); 
    }; 

    input.click();
}



function saveToLocalFile(content, filename, contentType)
{
    const a    = document.createElement('a');
    const file = new Blob([content], {type: contentType});

    a.download = filename;
    a.href     = URL.createObjectURL(file);

    a.click();

    URL.revokeObjectURL(a.href);
}


const webColors = [
    {name: 'AliceBlue',            color: 'f0f8ff'},
    {name: 'AntiqueWhite',         color: 'faebd7'},
    {name: 'Aqua',                 color: '00ffff'},
    {name: 'Aquamarine',           color: '7fffd4'},
    {name: 'Azure',                color: 'f0ffff'},
    {name: 'Beige',                color: 'f5f5dc'},
    {name: 'Bisque',               color: 'ffe4c4'},
    {name: 'Black',                color: '000000'},
    {name: 'BlanchedAlmond',       color: 'ffebcd'},
    {name: 'Blue',                 color: '0000ff'},
    {name: 'BlueViolet',           color: '8a2be2'},
    {name: 'Brown',                color: 'a52a2a'},
    {name: 'BurlyWood',            color: 'deb887'},
    {name: 'CadetBlue',            color: '5f9ea0'},
    {name: 'Chartreuse',           color: '7fff00'},
    {name: 'Chocolate',            color: 'd2691e'},
    {name: 'Coral',                color: 'ff7f50'},
    {name: 'CornflowerBlue',       color: '6495ed'},
    {name: 'Cornsilk',             color: 'fff8dc'},
    {name: 'Crimson',              color: 'dc143c'},
    {name: 'Cyan',                 color: '00ffff'},
    {name: 'DarkBlue',             color: '00008b'},
    {name: 'DarkCyan',             color: '008b8b'},
    {name: 'DarkGoldenRod',        color: 'b8860b'},
    {name: 'DarkGray',             color: 'a9a9a9'},
    {name: 'DarkGrey',             color: 'a9a9a9'},
    {name: 'DarkGreen',            color: '006400'},
    {name: 'DarkKhaki',            color: 'bdb76b'},
    {name: 'DarkMagenta',          color: '8b008b'},
    {name: 'DarkOliveGreen',       color: '556b2f'},
    {name: 'DarkOrange',           color: 'ff8c00'},
    {name: 'DarkOrchid',           color: '9932cc'},
    {name: 'DarkRed',              color: '8b0000'},
    {name: 'DarkSalmon',           color: 'e9967a'},
    {name: 'DarkSeaGreen',         color: '8fbc8f'},
    {name: 'DarkSlateBlue',        color: '483d8b'},
    {name: 'DarkSlateGray',        color: '2f4f4f'},
    {name: 'DarkSlateGrey',        color: '2f4f4f'},
    {name: 'DarkTurquoise',        color: '00ced1'},
    {name: 'DarkViolet',           color: '9400d3'},
    {name: 'DeepPink',             color: 'ff1493'},
    {name: 'DeepSkyBlue',          color: '00bfff'},
    {name: 'DimGray',              color: '696969'},
    {name: 'DimGrey',              color: '696969'},
    {name: 'DodgerBlue',           color: '1e90ff'},
    {name: 'FireBrick',            color: 'b22222'},
    {name: 'FloralWhite',          color: 'fffaf0'},
    {name: 'ForestGreen',          color: '228b22'},
    {name: 'Fuchsia',              color: 'ff00ff'},
    {name: 'Gainsboro',            color: 'dcdcdc'},
    {name: 'GhostWhite',           color: 'f8f8ff'},
    {name: 'Gold',                 color: 'ffd700'},
    {name: 'GoldenRod',            color: 'daa520'},
    {name: 'Gray',                 color: '808080'},
    {name: 'Grey',                 color: '808080'},
    {name: 'Green',                color: '008000'},
    {name: 'GreenYellow',          color: 'adff2f'},
    {name: 'HoneyDew',             color: 'f0fff0'},
    {name: 'HotPink',              color: 'ff69b4'},
    {name: 'IndianRed',            color: 'cd5c5c'},
    {name: 'Indigo',               color: '4b0082'},
    {name: 'Ivory',                color: 'fffff0'},
    {name: 'Khaki',                color: 'f0e68c'},
    {name: 'Lavender',             color: 'e6e6fa'},
    {name: 'LavenderBlush',        color: 'fff0f5'},
    {name: 'LawnGreen',            color: '7cfc00'},
    {name: 'LemonChiffon',         color: 'fffacd'},
    {name: 'LightBlue',            color: 'add8e6'},
    {name: 'LightCoral',           color: 'f08080'},
    {name: 'LightCyan',            color: 'e0ffff'},
    {name: 'LightGoldenRodYellow', color: 'fafad2'},
    {name: 'LightGray',            color: 'd3d3d3'},
    {name: 'LightGrey',            color: 'd3d3d3'},
    {name: 'LightGreen',           color: '90ee90'},
    {name: 'LightPink',            color: 'ffb6c1'},
    {name: 'LightSalmon',          color: 'ffa07a'},
    {name: 'LightSeaGreen',        color: '20b2aa'},
    {name: 'LightSkyBlue',         color: '87cefa'},
    {name: 'LightSlateGray',       color: '778899'},
    {name: 'LightSlateGrey',       color: '778899'},
    {name: 'LightSteelBlue',       color: 'b0c4de'},
    {name: 'LightYellow',          color: 'ffffe0'},
    {name: 'Lime',                 color: '00ff00'},
    {name: 'LimeGreen',            color: '32cd32'},
    {name: 'Linen',                color: 'faf0e6'},
    {name: 'Magenta',              color: 'ff00ff'},
    {name: 'Maroon',               color: '800000'},
    {name: 'MediumAquaMarine',     color: '66cdaa'},
    {name: 'MediumBlue',           color: '0000cd'},
    {name: 'MediumOrchid',         color: 'ba55d3'},
    {name: 'MediumPurple',         color: '9370db'},
    {name: 'MediumSeaGreen',       color: '3cb371'},
    {name: 'MediumSlateBlue',      color: '7b68ee'},
    {name: 'MediumSpringGreen',    color: '00fa9a'},
    {name: 'MediumTurquoise',      color: '48d1cc'},
    {name: 'MediumVioletRed',      color: 'c71585'},
    {name: 'MidnightBlue',         color: '191970'},
    {name: 'MintCream',            color: 'f5fffa'},
    {name: 'MistyRose',            color: 'ffe4e1'},
    {name: 'Moccasin',             color: 'ffe4b5'},
    {name: 'NavajoWhite',          color: 'ffdead'},
    {name: 'Navy',                 color: '000080'},
    {name: 'OldLace',              color: 'fdf5e6'},
    {name: 'Olive',                color: '808000'},
    {name: 'OliveDrab',            color: '6b8e23'},
    {name: 'Orange',               color: 'ffa500'},
    {name: 'OrangeRed',            color: 'ff4500'},
    {name: 'Orchid',               color: 'da70d6'},
    {name: 'PaleGoldenRod',        color: 'eee8aa'},
    {name: 'PaleGreen',            color: '98fb98'},
    {name: 'PaleTurquoise',        color: 'afeeee'},
    {name: 'PaleVioletRed',        color: 'db7093'},
    {name: 'PapayaWhip',           color: 'ffefd5'},
    {name: 'PeachPuff',            color: 'ffdab9'},
    {name: 'Peru',                 color: 'cd853f'},
    {name: 'Pink',                 color: 'ffc0cb'},
    {name: 'Plum',                 color: 'dda0dd'},
    {name: 'PowderBlue',           color: 'b0e0e6'},
    {name: 'Purple',               color: '800080'},
    {name: 'RebeccaPurple',        color: '663399'},
    {name: 'Red',                  color: 'ff0000'},
    {name: 'RosyBrown',            color: 'bc8f8f'},
    {name: 'RoyalBlue',            color: '4169e1'},
    {name: 'SaddleBrown',          color: '8b4513'},
    {name: 'Salmon',               color: 'fa8072'},
    {name: 'SandyBrown',           color: 'f4a460'},
    {name: 'SeaGreen',             color: '2e8b57'},
    {name: 'SeaShell',             color: 'fff5ee'},
    {name: 'Sienna',               color: 'a0522d'},
    {name: 'Silver',               color: 'c0c0c0'},
    {name: 'SkyBlue',              color: '87ceeb'},
    {name: 'SlateBlue',            color: '6a5acd'},
    {name: 'SlateGray',            color: '708090'},
    {name: 'SlateGrey',            color: '708090'},
    {name: 'Snow',                 color: 'fffafa'},
    {name: 'SpringGreen',          color: '00ff7f'},
    {name: 'SteelBlue',            color: '4682b4'},
    {name: 'Tan',                  color: 'd2b48c'},
    {name: 'Teal',                 color: '008080'},
    {name: 'Thistle',              color: 'd8bfd8'},
    {name: 'Tomato',               color: 'ff6347'},
    {name: 'Turquoise',            color: '40e0d0'},
    {name: 'Violet',               color: 'ee82ee'},
    {name: 'Wheat',                color: 'f5deb3'},
    {name: 'White',                color: 'ffffff'},
    {name: 'WhiteSmoke',           color: 'f5f5f5'},
    {name: 'Yellow',               color: 'ffff00'},
    {name: 'YellowGreen',          color: '9acd32'}
];


var _clipboard = '';



function writeTextToClipboard(str) 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.writeText(str);

        else 
        {
            const prevActive = document.activeElement;
            const textArea   = document.createElement('textarea');

            textArea.value = str;

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus();
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('copy') ? res() : rej();
                textArea.remove();

                prevActive.focus();
            });
        }
    }
    else
        _clipboard = str;
}



function readTextFromClipboard() 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.readText();

        else 
        {
            let textArea = document.createElement('textarea');

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus();
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('paste') ? res(textArea.value) : rej();
                textArea.remove();
            });
        }
    }
    else
        return new Promise((res, rej) => res(_clipboard));
}


function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isPageKey(key) { return isTagKey(key, pageTag); }
function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noPageTag(key) { return noTag(key, pageTag); }
function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


const NAN_CHAR               = '\uFFFD';
const NAN_DISPLAY            = '?';
    
const UNKNOWN_CHAR           = '?';
const UNKNOWN_DISPLAY        = UNKNOWN_CHAR;//'🤷‍♂️';

const OBJECT_SEPARATOR       = ' > ';
const   PROP_SEPARATOR       = ' / ';
const  INPUT_SEPARATOR       = ':';

const CENTER_SUFFIX          = ' •';
const  XFORM_SUFFIX          = ' ◇';
    

const  TRUE_DISPLAY_LIGHT    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const FALSE_DISPLAY_LIGHT    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    

const  TRUE_DISPLAY_DARK     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const FALSE_DISPLAY_DARK     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';

const  TRUE_DISPLAY_LIGHT_BW = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const FALSE_DISPLAY_LIGHT_BW = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';

const  TRUE_DISPLAY_DARK_BW  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_DARK_BW  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';

const  TRUE_DISPLAY_MENU     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_MENU     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';



function getTrueDisplay(color = true)
{
    return darkMode
         ? (color ? TRUE_DISPLAY_DARK  : TRUE_DISPLAY_DARK_BW )
         : (color ? TRUE_DISPLAY_LIGHT : TRUE_DISPLAY_LIGHT_BW);
}



function getFalseDisplay(color = true)
{
    return darkMode
         ? (color ? FALSE_DISPLAY_DARK  : FALSE_DISPLAY_DARK_BW )
         : (color ? FALSE_DISPLAY_LIGHT : FALSE_DISPLAY_LIGHT_BW);
}


function nodeIdArrayToString(nodeIds)
{
    let str = '';

    for (let i = 0; i < nodeIds.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodeIds[i];
    }

    return str;
}



function nodeArrayToString(nodes)
{
    let str = '';

    nodes.map(n => n ? n.id : 'undefined').join(', ');

    // for (let i = 0; i < nodes.length; i++)
    // {
    //     if (i > 0) str += ', ';
    //     str += nodes[i] ? nodes[i].id : 'undefined';
    // }

    return str;
}


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;



class NoiseSeed
{
    initial;
    current;

    

    constructor()
    {
        this.reset();
    }
    


    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    


    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    


    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }



    reset()
    {
        this.current = this.initial;
    }
};



class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        let next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


const settings =
{
    dataMode:                      false,
    debugMode:                     false,
        
    enableZoomedOutParams:         false,
    minZoomForParams:              0.35,
    showPages:                     false,
    showAllColorSpaces:            false,
    showNodeIcons:                 true,
    showBoolValues:                true,
    showColorLegendInMenus:        false,
    showOperationResults:          false,
    showClearUndoWarning:          true,
    showDebugMenu:                 false,
        
    showNodeId:                    false, // instead of name
    showTransformPoints:           false,
    enableAsserts:                 false,

    showTooltipLongText:           true,
    showTooltipColorInterpolation: true,
    showTooltipColorBlindness:     true,
    showTooltipColorContrast:      true,

    //enableBetaFeatures:            false,
            
    logThreadMessages:             false,
    logDataMessages:               false,
    logMessages:                   false,

    logActions:                    false, 
            
    logLoading:                    false, 
    logRequests:                   false, 
    logValueUpdates:               false, 
    logObjectUpdates:              false,
    logStyleUpdates:               false,
            
    logRawLoadPages:               false, 
    logRawLoadNodes:               false, 
    logRawLoadConnections:         false, 
        
    logRawSavePages:               false, 
    logRawSaveNodes:               false, 
    logRawSaveConnections:         false, 
        
    logRawRequests:                false, 
    logRawValues:                  false,

    sessionId:                     ''
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'dataMode':                      settings.dataMode                      = value;  break;
        case 'debugMode':                     settings.debugMode                     = value;  break;
                
        case 'enableZoomedOutParams':         settings.enableZoomedOutParams         = value;  break;
        case 'minZoomForParams':              settings.minZoomForParams              = value;  break;
        case 'showPages':                     settings.showPages                     = value;  break;
        case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;
        case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;
        case 'showBoolValues':                settings.showBoolValues                = value;  break;
        case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;
        case 'showOperationResults':          settings.showOperationResults          = value;  break;
        case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;
        case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;
                        
        case 'showNodeId':                    settings.showNodeId                    = value;  break;
        case 'showTransformPoints':           settings.showTransformPoints           = value;  break;
        case 'enableAsserts':                 settings.enableAsserts                 = value;  break;

        case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;
        case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;
        case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;
        case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;

        //case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;
                   
        case 'logThreadMessages':             settings.logThreadMessages             = value;  break;
        case 'logDataMessages':               settings.logDataMessages               = value;  break;
        case 'logMessages':                   settings.logMessages                   = value;  break;

        case 'logActions':                    settings.logActions                    = value;  break;
        case 'logLoading':                    settings.logLoading                    = value;  break;
        case 'logRequests':                   settings.logRequests                   = value;  break;
        case 'logValueUpdates':               settings.logValueUpdates               = value;  break;
        case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;
        case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;
                   
        case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;
        case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;
        case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;
                
        case 'logRawSavePages':               settings.logRawSavePages               = value;  break;
        case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;
        case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;
                
        case 'logRawRequests':                settings.logRawRequests                = value;  break;
        case 'logRawValues':                  settings.logRawValues                  = value;  break;

        case 'sessionId':                     settings.sessionId                     = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'dataMode':                      updateSettingAndMenu_(valid, settingName, value, menuItemDataMode                     ); break;
        case 'debugMode':                     updateSettingAndMenu_(valid, settingName, value                                       ); break;
              
        case 'enableZoomedOutParams':         updateSettingAndMenu_(valid, settingName, value, menuItemEnableZoomedOutParams        ); break;
        case 'showPages':                     updateSettingAndMenu_(valid, settingName, value, menuItemShowPages                    ); break;
        case 'showAllColorSpaces':            updateSettingAndMenu_(valid, settingName, value, menuItemShowAllColorSpaces           ); break;
        case 'showNodeIcons':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeIcons                ); break;
        case 'showBoolValues':                updateSettingAndMenu_(valid, settingName, value, menuItemShowBoolValues               ); break;
        case 'showColorLegendInMenus':        updateSettingAndMenu_(valid, settingName, value, menuItemShowColorLegendInMenus       ); break;
        case 'showOperationResults':          updateSettingAndMenu_(valid, settingName, value, menuItemShowOperationResults         ); break;
        case 'showClearUndoWarning':          updateSettingAndMenu_(valid, settingName, value, menuItemShowClearUndoWarning         ); break;
        case 'showDebugMenu':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowDebugMenu                ); break;
                      
        case 'showNodeId':                    updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId                   ); break;
        case 'showTransformPoints':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTransformPoints          ); break;
        case 'enableAsserts':                 updateSettingAndMenu_(valid, settingName, value, menuItemEnableAsserts                ); enableAsserts = value; break;
        
        case 'showTooltipLongText':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipLongText          ); break;
        case 'showTooltipColorContrast':      updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorContrast     ); break;
        case 'showTooltipColorInterpolation': updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorInterpolation); break;
        case 'showTooltipColorBlindness':     updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorBlindness    ); break;

        //case 'enableBetaFeatures':            //updateSettingAndMenu_(valid, settingName, value, menuItemEnableBetaFeatures           ); break;
                      
        case 'logThreadMessages':             updateSettingAndMenu_(valid, settingName, value, menuItemLogThreadMessages            ); break;
        case 'logDataMessages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogDataMessages              ); break;
        case 'logMessages':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages                  ); break;

        case 'logActions':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogActions                   ); break;
        case 'logLoading':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading                   ); break;
        case 'logRequests':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests                  ); break;
        case 'logValueUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates              ); break;
        case 'logObjectUpdates':              updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates             ); break;
        case 'logStyleUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogStyleUpdates              ); break;
                      
        case 'logRawLoadPages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadPages              ); break;
        case 'logRawLoadNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadNodes              ); break;
        case 'logRawLoadConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadConnections        ); break;
                      
        case 'logRawSavePages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSavePages              ); break;
        case 'logRawSaveNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveNodes              ); break;
        case 'logRawSaveConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveConnections        ); break;
                      
        case 'logRawRequests':                updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests               ); break;
        case 'logRawValues':                  updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues                 ); break;
    } 


    if (   save
        && settingName != 'showAllColorSpaces')
        uiSetLocalData(settingName, boolToString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  


    if (setting == 'showNodeId')
    {
        uiPostMessageToFigma(
        {
            cmd:    'figUpdateShowIds',
            showIds: settings.showNodeId
        });
    }


    if (menu)
        menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemDataMode                     .setVisible(settings.dataMode                     );
    menuItemDebug                        .setVisible(settings.debugMode                    );
                
    menuItemEnableZoomedOutParams        .setChecked(settings.enableZoomedOutParams        );
    menuItemShowPages                    .setChecked(settings.showPages                    );
    menuItemShowAllColorSpaces           .setChecked(settings.showAllColorSpaces           );
    menuItemShowNodeIcons                .setChecked(settings.showNodeIcons                );
    menuItemShowBoolValues               .setChecked(settings.showBoolValues               );
    menuItemShowColorLegendInMenus       .setChecked(settings.showColorLegendInMenus       );
    menuItemShowOperationResults         .setChecked(settings.showOperationResults         );
    menuItemShowClearUndoWarning         .setChecked(settings.showClearUndoWarning         );
    menuItemShowDebugMenu                .setChecked(settings.showDebugMenu                );
                
    menuItemShowNodeId                   .setChecked(settings.showNodeId                   );
    menuItemShowTransformPoints          .setChecked(settings.showTransformPoints          );
    menuItemEnableAsserts                .setChecked(settings.enableAsserts                );

    menuItemShowTooltipLongText          .setChecked(settings.showTooltipLongText          );
    menuItemShowTooltipColorInterpolation.setChecked(settings.showTooltipColorInterpolation);
    menuItemShowTooltipColorBlindness    .setChecked(settings.showTooltipColorBlindness    );
    menuItemShowTooltipColorContrast     .setChecked(settings.showTooltipColorContrast     );

  //menuItemEnableBetaFeatures           .setChecked(settings.enableBetaFeatures           );
                  
    menuItemLogThreadMessages            .setChecked(settings.logThreadMessages            );
    menuItemLogDataMessages              .setChecked(settings.logDataMessages              );
    menuItemLogMessages                  .setChecked(settings.logMessages                  );

    menuItemLogActions                   .setChecked(settings.logActions                   );
                  
    menuItemLogLoading                   .setChecked(settings.logLoading                   );
    menuItemLogRequests                  .setChecked(settings.logRequests                  );
    menuItemLogValueUpdates              .setChecked(settings.logValueUpdates              );
    menuItemLogObjectUpdates             .setChecked(settings.logObjectUpdates             );
    menuItemLogStyleUpdates              .setChecked(settings.logStyleUpdates              );
                  
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadPages              );
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadNodes              );
    menuItemLogRawLoadConnections        .setChecked(settings.logRawLoadConnections        );
                    
    menuItemLogRawSavePages              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveNodes              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveConnections        .setChecked(settings.logRawSaveConnections        );
                
    menuItemLogRawRequests               .setChecked(settings.logRawRequests               );
    menuItemLogRawValues                 .setChecked(settings.logRawValues                 );
}



function updateMenuItemShowPages()
{
    uiSetPageData('showPages', boolToString(settings.showPages));
    graph.updatePages();
    graphView.update();
}



function updateMenuItemShowAllColorSpaces()
{
    uiSetPageData('showAllColorSpaces', boolToString(settings.showAllColorSpaces));

    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowNodeIcons()
{
    graph.nodes.forEach(n => n.updateNode());
}



function updateMenuItemShowBoolValues()
{
    graph.nodes
        .filter(n => 
               NUMBER_BOOLEAN_TYPES.includes(n.type)
            ||      CONDITION_TYPES.includes(n.type)
            ||         AFFINE_TYPES.includes(n.type)
            || n.type == IF_ELSE)
        .forEach(n => n.updateNode());
}



function updateMenuItemShowColorLegendInMenus()
{
    for (const menu of menuBarMenus)
        menu.items.forEach(i => i.updateLegend());
}



function updateMenuItemShowOperationResults()
{
    const nodes = graph.nodes
        .filter(n => n.params.find(p => p.isResult));

    nodes.forEach(n => 
    {
        const rectd = n.measureData.divOffset;
        const recth = n.measureData.headerOffset;

        n.setRect(rectd.x, rectd.y, recth.w, recth.h, false);
        n.updateNode();
    });

    graphView.updateNodeTransforms(nodes);
}



function enableFeatures(sub, beta = false)
{
    enableSubscribedMenuItem(menuItemSaveToFile,   sub);
    enableSubscribedMenuItem(menuItemTimer,        sub);
    enableSubscribedMenuItem(menuItemAnimate,      sub);
    enableSubscribedMenuItem(menuItemFetch,        sub);
    enableSubscribedMenuItem(menuItemTextFile,     sub);
    enableSubscribedMenuItem(menuItemDateTime,     sub);
    enableSubscribedMenuItem(menuItemSolve,        sub);
    enableSubscribedMenuItem(menuItemTextJson,     sub);
    enableSubscribedMenuItem(menuItemCorrectColor, sub);
    enableSubscribedMenuItem(menuItemConvertToP3,  sub);
    enableSubscribedMenuItem(menuItemShapeRender,  sub);

    graph.nodes.forEach(n => n.updateSubscribeStatus(sub));
}



function enableSubscribedMenuItem(menuItem, sub)
{
    menuItem.enabled   =  sub;  
    menuItem.subscribe = !sub;    
    menuItem.update();
}



function updateMenuItemShowDebugMenu()
{
    updateElementDisplay(menuItemDebug.div, settings.showDebugMenu);

    menuMain.update(
        boundingRect(menuMain.div).x + 6,
        boundingRect(menuMain.div).y - 4,
        true);
}

 

function updateElementDisplay(menuItem, enable)
{
    menuItem.style.display = enable ? 'block' : 'none';
}



function loadLocalSettings()
{
    uiGetLocalData('dataMode'                     );
    uiGetLocalData('debugMode'                    );
        
    uiGetLocalData('enableZoomedOutParams'        );
    uiGetLocalData('minZoomForParams'             );
    uiGetLocalData('showNodeIcons'                );
    uiGetLocalData('showBoolValues'               );
    uiGetLocalData('showColorLegendInMenus'       );
    uiGetLocalData('showPages'                    );
    uiGetLocalData('showOperationResults'         );
    uiGetLocalData('showClearUndoWarning'         );
    uiGetLocalData('showDebugMenu'                );
        
    uiGetLocalData('showNodeId'                   );
    uiGetLocalData('showTransformPoints'          );
    uiGetLocalData('enableAsserts'                );

    uiGetLocalData('showTooltipLongText'          );
    uiGetLocalData('showTooltipColorInterpolation');
    uiGetLocalData('showTooltipColorBlindness'    );
    uiGetLocalData('showTooltipColorContrast'     );

  //uiGetLocalData('enableBetaFeatures'           );
            
    uiGetLocalData('logThreadMessages'            );
    uiGetLocalData('logDataMessages'              );
    uiGetLocalData('logMessages'                  );

    uiGetLocalData('logActions'                   );
            
    uiGetLocalData('logLoading'                   );
    uiGetLocalData('logRequests'                  );
    uiGetLocalData('logValueUpdates'              );
    uiGetLocalData('logObjectUpdates'             );
    uiGetLocalData('logStyleUpdates'              );
            
    uiGetLocalData('logRawLoadPages'              );
    uiGetLocalData('logRawLoadNodes'              );
    uiGetLocalData('logRawLoadConnections'        );
        
    uiGetLocalData('logRawSavePages'              );
    uiGetLocalData('logRawSaveNodes'              );
    uiGetLocalData('logRawSaveConnections'        );
        
    uiGetLocalData('logRawRequests'               );
    uiGetLocalData('logRawValues'                 );

    uiGetLocalData('sessionId'                    );
}


const LIST_VALUE              = 'LIST#';

const NUMBER_LIST_VALUE       = 'NLIST#';
const   TEXT_LIST_VALUE       = 'TLIST#';
const  SHAPE_LIST_VALUE       = 'SLIST#';


const NULL_NODE               = 'NULL';
const START                   = 'START';
const REPEAT                  = 'REPT';
const CACHE                   = 'CACHE';
const FREEZE                  = 'FRZ';
const TIMER                   = 'TIMER';
const VALUE_NAME              = 'VNAME';

const LIST                    = 'LIST';
const CONDENSE                = 'CDENSE';
const SUBLIST                 = 'SUBLST';
const UNIQUE                  = 'UNIQ';
const REVERSE_LIST            = 'REVLST';
const SORT                    = 'SORT';
const COLUMN                  = 'CLMN';
const CELL                    = 'CELL';
const ITEMS                   = 'ITEMS';
const LIST_COUNT              = 'COUNT';
const CONTAINS                = 'LCONT';
const SELECT                  = 'SEL';
const IF_ELSE                 = 'IF';
const FILTER                  = 'LSTFLT';
const DEFINE                  = 'DEFINE';  


const ANY_VALUE               = 'ANY#';


const LIST_TYPES =
[
    LIST_VALUE,
    NUMBER_LIST_VALUE,
    TEXT_LIST_VALUE,
    SHAPE_LIST_VALUE,
    LIST,
    SUBLIST,
    //ITEMS,
    LIST_COUNT,
    CONTAINS,
    REPEAT
];


const LIST_VALUES =
[
           LIST_VALUE,
    NUMBER_LIST_VALUE,
      TEXT_LIST_VALUE,
     SHAPE_LIST_VALUE
];


//const FOREACH = 'FOR';


const FLOW_TYPES =
[
    NULL_NODE,
    ...LIST_TYPES,
    CONDENSE,
    SUBLIST,
    UNIQUE,
    REVERSE_LIST,
    COLUMN,
    SORT,
    CELL,
    ITEMS,
    SELECT,
    IF_ELSE,
    FILTER,
    START,
    REPEAT,
    //FOREACH,
    DEFINE,
    CACHE,
    FREEZE,
    TIMER,
    VALUE_NAME
];


const NUMBER_VALUE            = 'NUM#';  
const NUMBER                  = 'NUM';   
const NUMBER_SIGN             = 'NSIGN';   
const NUMBER_ABSOLUTE         = 'ABS';   
const NUMBER_ROUND            = 'ROUND';   
const NUMBER_MINMAX           = 'MINMAX';   
const NUMBER_LIMITS           = 'LIM';   
const NUMBER_CONSTANT         = 'CONST';  
const NUMBER_DATETIME         = 'DATE';  
const NUMBER_RANGE            = 'RANGE';  
const NUMBER_SEQUENCE         = 'SEQ';  
const NUMBER_RANDOM           = 'RAND';  
const NUMBER_NOISE            = 'NOISE';  
const NUMBER_PROBABILITY      = 'PROB';  
const NUMBER_ACCUMULATE       = 'ACCUM';  
const NUMBER_INTERPOLATE      = 'LERP'; 
const NUMBER_SOLVE            = 'SOLVE';
const NUMBER_ANIMATE          = 'NANIM';

const NUMBER_MATH             = 'MATH';  
const NUMBER_SIMPLE_MATH      = 'SMATH';  
const NUMBER_ADD              = 'ADD';   
const NUMBER_SUBTRACT         = 'SUB';   
const NUMBER_MULTIPLY         = 'MUL';   
const NUMBER_DIVIDE           = 'DIV';   
const NUMBER_MODULO           = 'MOD';   
const NUMBER_EXPONENT         = 'EXP';

const NUMBER_BOOLEAN          = 'NBOOL';  
const NUMBER_NOT              = 'NOT';
const NUMBER_AND              = 'AND';
const NUMBER_OR               = 'OR';
const NUMBER_XOR              = 'XOR';

const NUMBER_CONDITION        = 'COND';
const NUMBER_EQUAL            = 'EQ';
const NUMBER_NOT_EQUAL        = 'NE';
const NUMBER_LESS             = 'LT';
const NUMBER_LESS_OR_EQUAL    = 'LE';
const NUMBER_GREATER          = 'GT';
const NUMBER_GREATER_OR_EQUAL = 'GE';

const NUMBER_TRIG             = 'TRIG';  
const NUMBER_SIN              = 'SIN';   
const NUMBER_COS              = 'COS';   
const NUMBER_TAN              = 'TAN';   


const MATH_TYPES =
[
    NUMBER_MATH,
    NUMBER_SIMPLE_MATH,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT
];


const NUMBER_BOOLEAN_TYPES =
[
    NUMBER_BOOLEAN,
    NUMBER_NOT,
    NUMBER_AND,
    NUMBER_OR,
    NUMBER_XOR
];


const CONDITION_TYPES =
[
    NUMBER_CONDITION,
    NUMBER_EQUAL,
    NUMBER_NOT_EQUAL,
    NUMBER_LESS,
    NUMBER_LESS_OR_EQUAL,
    NUMBER_GREATER,
    NUMBER_GREATER_OR_EQUAL
];


const TRIG_TYPES =
[
    NUMBER_TRIG,
    NUMBER_SIN,
    NUMBER_COS,
    NUMBER_TAN
];


const TEXT_VALUE     = 'TEXT#';
const TEXT           = 'TEXT';
const TEXT_LENGTH    = 'TLEN';
const TEXT_TRIM      = 'TTRIM';
const TEXT_SUBSTRING = 'TSUB';
const TEXT_CONTAINS  = 'TCONT';
const TEXT_CASE      = 'TCASE';
const TEXT_REPLACE   = 'TREPL';
const TEXT_JOIN      = 'TJOIN';
const TEXT_PAD       = 'TPAD';
const TEXT_COMPARE   = 'TCMP';
const TEXT_CHAR      = 'TCHAR';
const NUMBER_TO_TEXT = 'N2T';
const TEXT_TO_NUMBER = 'T2N';
const TEXT_TO_COLOR  = 'T2C';
const TEXT_SPLIT     = 'TSPLT';
const TEXT_JSON      = 'TJSON';
const TEXT_CSV       = 'TCSV';
const TEXT_FETCH     = 'FETCH';
const TEXT_FILE      = 'TFILE';


const NUMBER_TYPES =
[
    NUMBER_VALUE,
    NUMBER_LIST_VALUE,
    NUMBER,
    NUMBER_SIGN,
    NUMBER_ABSOLUTE,
    NUMBER_ROUND,
    NUMBER_MINMAX,
    NUMBER_LIMITS,
    NUMBER_CONSTANT,
    NUMBER_DATETIME,
    NUMBER_RANGE,
    NUMBER_SEQUENCE,
    NUMBER_RANDOM,
    NUMBER_NOISE,
    NUMBER_PROBABILITY,
    NUMBER_ACCUMULATE,
    NUMBER_INTERPOLATE,
    NUMBER_SOLVE,
    NUMBER_ANIMATE,
    NUMBER_TO_TEXT,

    ...MATH_TYPES,
    ...NUMBER_BOOLEAN_TYPES,
    ...CONDITION_TYPES,
    ...TRIG_TYPES
];


const TEXT_TYPES =
[
    TEXT_VALUE,
    TEXT_LIST_VALUE,
    TEXT,
    TEXT_LENGTH,
    TEXT_TRIM,
    TEXT_SUBSTRING,
    TEXT_CONTAINS,
    TEXT_CASE,
    TEXT_JOIN,
    TEXT_PAD,
    TEXT_REPLACE,
    TEXT_COMPARE,
    TEXT_CHAR,
    TEXT_TO_NUMBER,
    TEXT_TO_COLOR,
    TEXT_SPLIT,
    TEXT_JSON,
    TEXT_CSV,
    TEXT_FETCH,
    TEXT_FILE
];


const COLOR_VALUE        = 'COL#';  
const COLOR              = 'COL';   
const VALID_COLOR        = 'CVAL';  
const CORRECT_COLOR      = 'CCOR';  
const COLOR_CONVERT_P3   = 'COLP3';
const COLOR_CONTRAST     = 'CCNT';  
const COLORBLIND         = 'BLND';  
const COLOR_INTERPOLATE  = 'CLERP'; 
const COLOR_BLEND        = 'CBLND';


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    CORRECT_COLOR,
    COLOR_CONVERT_P3,
    COLORBLIND,
    COLOR_INTERPOLATE,
    COLOR_BLEND
];


const FILL_VALUE         = 'FILL#';
const FILL               = 'FILL';
const FILL_TYPES         = [FILL_VALUE, FILL];
  
const STROKE_VALUE       = 'STRK#';
const STROKE             = 'STRK';
const STROKE_TYPES       = [STROKE_VALUE, STROKE];
  
const COLOR_STOP_VALUE   = 'CSTOP#';
const COLOR_STOP         = 'CSTOP';
const COLOR_STOP_TYPES   = [COLOR_STOP_VALUE, COLOR_STOP];
  
const GRADIENT_VALUE     = 'GRAD#';
const GRADIENT           = 'GRAD';
const GRADIENT_TYPES     = [GRADIENT_VALUE, GRADIENT];
 

const DROP_SHADOW_VALUE  = 'DRSH#';
const DROP_SHADOW        = 'DRSH';
const DROP_SHADOW_TYPES  = [DROP_SHADOW_VALUE, DROP_SHADOW];

const INNER_SHADOW_VALUE = 'INSH#';
const INNER_SHADOW       = 'INSH';
const INNER_SHADOW_TYPES = [INNER_SHADOW_VALUE, INNER_SHADOW];

const LAYER_BLUR_VALUE   = 'LBLR#';
const LAYER_BLUR         = 'LBLR';
const LAYER_BLUR_TYPES   = [LAYER_BLUR_VALUE, LAYER_BLUR];

const BACK_BLUR_VALUE    = 'BBLR#';
const BACK_BLUR          = 'BBLR';
const BACK_BLUR_TYPES    = [BACK_BLUR_VALUE, BACK_BLUR];

const LAYER_MASK_VALUE   = 'MASK#';
const LAYER_MASK         = 'MASK';
const LAYER_MASK_TYPES   = [LAYER_MASK_VALUE, LAYER_MASK];

const VAR_COLOR          = 'CVAR';
const VAR_NUMBER         = 'NVAR';
const VAR_TEXT           = 'TVAR';
const VAR_BOOLEAN        = 'BVAR';


const EFFECT_TYPES =
[
    ...DROP_SHADOW_TYPES,
    ...INNER_SHADOW_TYPES,
    ...LAYER_BLUR_TYPES,
    ...BACK_BLUR_TYPES,
    ...LAYER_MASK_TYPES
];


const VARIABLE_TYPES =
[
    VAR_COLOR,
    VAR_NUMBER,
    VAR_TEXT,
    VAR_BOOLEAN
];


const STYLE_VALUES =
[
    COLOR_VALUE, 
    FILL_VALUE, 
    GRADIENT_VALUE, 
    STROKE_VALUE,
    DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
    LAYER_BLUR_VALUE,
    BACK_BLUR_VALUE,
    LAYER_MASK_VALUE
];


const COLOR_STYLE          = 'CSTL';
 
 
const SHAPE_VALUE          = 'SHP#'; // abstract placeholder
 
const RECTANGLE_VALUE      = 'RECT#';
const RECTANGLE            = 'RECT'; 
const RECTANGLE_TYPES      = [RECTANGLE_VALUE, RECTANGLE];
 
const LINE_VALUE           = 'LINE#';
const LINE                 = 'LINE'; 
const LINE_TYPES           = [LINE_VALUE, LINE];
   
const ELLIPSE_VALUE        = 'ELPS#';
const ELLIPSE              = 'ELPS'; 
const ELLIPSE_TYPES        = [ELLIPSE_VALUE, ELLIPSE];
 
const TRAPEZE_VALUE        = 'TRPZ#';
const TRAPEZE              = 'TRPZ';
const TRAPEZE_TYPES        = [TRAPEZE_VALUE, TRAPEZE];
 
const POLYGON_VALUE        = 'POLY#';
const POLYGON              = 'POLY'; 
const POLYGON_TYPES        = [POLYGON_VALUE, POLYGON];
   
const STAR_VALUE           = 'STAR#';
const STAR                 = 'STAR'; 
const STAR_TYPES           = [STAR_VALUE, STAR];
   
const TEXT_SHAPE_VALUE     = 'TXTS#';
const TEXT_SHAPE           = 'TXTS'; 
const TEXT_SHAPE_TYPES     = [TEXT_SHAPE_VALUE, TEXT_SHAPE];
  
const POINT                = 'PT';
const POINT_VALUE          = 'PT#';
const POINT_TYPES          = [POINT_VALUE, POINT];

const VECTOR_PATH_VALUE    = 'VPATH#';
const VECTOR_PATH          = 'VPATH'; 
const VECTOR_PATH_TYPES    = [VECTOR_PATH_VALUE, VECTOR_PATH];
 
const VECTOR_VERTEX_VALUE  = 'VPT#';
const VECTOR_VERTEX        = 'VPT'; 
const VECTOR_VERTEX_TYPES  = [VECTOR_VERTEX_VALUE, VECTOR_VERTEX];
 
const VECTOR_EDGE_VALUE    = 'VEDGE#';
const VECTOR_EDGE          = 'VEDGE'; 
const VECTOR_EDGE_TYPES    = [VECTOR_EDGE_VALUE, VECTOR_EDGE];
 
const VECTOR_REGION_VALUE  = 'VREG#';
const VECTOR_REGION        = 'VREG'; 
const VECTOR_REGION_TYPES  = [VECTOR_REGION_VALUE, VECTOR_REGION];
 
const VECTOR_NETWORK_VALUE = 'VNET#';
const VECTOR_NETWORK       = 'VNET'; 
const VECTOR_NETWORK_TYPES = [VECTOR_NETWORK_VALUE, VECTOR_NETWORK];
 
const SHAPE_GROUP_VALUE    = 'SGRP#';
const SHAPE_GROUP          = 'SGRP';
const SHAPE_GROUP_TYPES    = [SHAPE_GROUP_VALUE, SHAPE_GROUP];
 
const FRAME_VALUE          = 'FRM#';
const FRAME                = 'FRM';
const FRAME_TYPES          = [FRAME_VALUE, FRAME];
 

const MOVE                 = 'MOVE';
const ROTATE               = 'ROT';
const SCALE                = 'SCALE';
const SKEW                 = 'SKEW';

const CENTER               = 'CENTR';
const RESET_XFORM          = 'RSTX';

const PLACE                = 'PLACE';
const SHAPE_APPLY          = 'APPLY';
  
const MEASURE_POINTS       = 'MESPT';
const INTERPOLATE_POINT    = 'PTLERP';
const POINT_ON_PATH        = 'PONPT';


const BOOLEAN              = 'BOOL';
const BOOLEAN_VALUE        = 'BOOL#';

const BOOL_UNION           = 'BOOLU';
const BOOL_SUBTRACT        = 'BOOLS';
const BOOL_INTERSECT       = 'BOOLI';
const BOOL_EXCLUDE         = 'BOOLE';


const BOOLEAN_TYPES =
[
    BOOLEAN,
    BOOLEAN_VALUE,
    BOOL_UNION,
    BOOL_SUBTRACT,
    BOOL_INTERSECT,
    BOOL_EXCLUDE
]


const RENDER             = 'RENDER';


const SHAPE_VALUES =
[
    SHAPE_VALUE,
    SHAPE_LIST_VALUE,
    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    TRAPEZE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE,
    TEXT_SHAPE_VALUE,
    POINT_VALUE,
    VECTOR_PATH_VALUE,
    VECTOR_VERTEX_VALUE,
    VECTOR_EDGE_VALUE,
    VECTOR_REGION_VALUE,
    VECTOR_NETWORK_VALUE,
    SHAPE_GROUP_VALUE,
    FRAME_VALUE,
    BOOLEAN_VALUE,
    DROP_SHADOW_VALUE
];


const AFFINE_TYPES =
[
    ROTATE,
    SCALE,
    SKEW
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    ...RECTANGLE_TYPES,
    ...LINE_TYPES,
    ...ELLIPSE_TYPES,
    ...TRAPEZE_TYPES,
    ...POLYGON_TYPES,
    ...STAR_TYPES,
    ...TEXT_SHAPE_TYPES,
    ...POINT_TYPES,
    ...VECTOR_PATH_TYPES,
    ...VECTOR_VERTEX_TYPES,
    ...VECTOR_EDGE_TYPES,
    ...VECTOR_REGION_TYPES,
    ...VECTOR_NETWORK_TYPES,
    ...SHAPE_GROUP_TYPES,
    ...FRAME_TYPES,
    ...BOOLEAN_TYPES,

    MOVE,
    ...AFFINE_TYPES,
    CENTER,
    RESET_XFORM,

    PLACE,
    SHAPE_APPLY,

    MEASURE_POINTS,
    INTERPOLATE_POINT,
    POINT_ON_PATH,

    RENDER
];


const ALL_VALUES =
[
            LIST_VALUE,
     NUMBER_LIST_VALUE,
       TEXT_LIST_VALUE,
      SHAPE_LIST_VALUE,
     
          NUMBER_VALUE,
            TEXT_VALUE,
           COLOR_VALUE,
 
            FILL_VALUE,
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
          STROKE_VALUE,
 
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
 
           SHAPE_VALUE,
       RECTANGLE_VALUE,
            LINE_VALUE,
         ELLIPSE_VALUE,
         TRAPEZE_VALUE,
         POLYGON_VALUE,
            STAR_VALUE,
      TEXT_SHAPE_VALUE,
           POINT_VALUE,
     VECTOR_PATH_VALUE,
   VECTOR_VERTEX_VALUE,
     VECTOR_EDGE_VALUE,
   VECTOR_REGION_VALUE,
  VECTOR_NETWORK_VALUE,
     SHAPE_GROUP_VALUE,
           FRAME_VALUE,

     DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
      LAYER_BLUR_VALUE,
       BACK_BLUR_VALUE
];


const GROUP_NODE    = 'GROUP';
const GROUP_PARAM   = 'GPARAM';


const GROUP_TYPES =
[
    GROUP_NODE,
    GROUP_PARAM
];


const COMMENT       = 'CMNT';
const PANEL         = 'PANEL';


const ACTIVE        = 'ACT';
const BEFORE_ACTIVE = 'BEF';
const DISABLED      = 'DIS';
const NOCACHE       = 'NOC';
 
const PARAM         = 'PARAM'; // nodeId paramId
 

const LOG           = 'LOG';


const GRAPH         = 'GRAPH';


const MATH_OPS = 
[   // the order is important for logical keyboard value changes
    [NUMBER_SUBTRACT, '−' ],
    [NUMBER_ADD,      '+' ],
    [NUMBER_MODULO,   '%' ],
    [NUMBER_DIVIDE,   '/' ], //'÷' ],
    [NUMBER_MULTIPLY, '×' ],
    [NUMBER_EXPONENT, 'e<sup>x'] 
];



const BOOLEAN_NOT = 0;
const BOOLEAN_XOR = 1;
const BOOLEAN_OR  = 2;
const BOOLEAN_AND = 3;


const BOOLEAN_OPS = 
[   
    [BOOLEAN_NOT, 'not'],
    [BOOLEAN_XOR, 'xor'], 
    [BOOLEAN_OR,  'or' ],
    [BOOLEAN_AND, 'and']
];



const CONDITION_LESS             = 0;
const CONDITION_LESS_OR_EQUAL    = 1;
const CONDITION_NOT_EQUAL        = 2;
const CONDITION_EQUAL            = 3;
const CONDITION_GREATER_OR_EQUAL = 4;
const CONDITION_GREATER          = 5;


const CONDITION_OPS = 
[   
    [CONDITION_LESS,             '<'],
    [CONDITION_LESS_OR_EQUAL,    '≤'],
    [CONDITION_NOT_EQUAL,        '≠'],
    [CONDITION_EQUAL,            '='],
    [CONDITION_GREATER_OR_EQUAL, '≥'],
    [CONDITION_GREATER,          '>']
];



const TRIG_SIN = 0;
const TRIG_COS = 1;
const TRIG_TAN = 2;


const TRIG_OPS = 
[   
    [TRIG_SIN, 'sin'],
    [TRIG_COS, 'cos'],
    [TRIG_TAN, 'tan']
];



const EMPTY_ACTION               = 'EMPTY';
const CONNECT_ACTION             = 'CONNECT';
const CREATE_ACTION              = 'CREATE';
const CREATE_INSERT_ACTION       = 'CREATE_INSERT';
const DELETE_ACTION              = 'DELETE';
const DISCONNECT_ACTION          = 'DISCONNECT';
const LINK_STYLE_ACTION          = 'LINK_STYLE';
const MAKE_ACTIVE_ACTION         = 'MAKE_ACTIVE';
const MAKE_PASSIVE_ACTION        = 'MAKE_PASSIVE';
const PASTE_ACTION               = 'PASTE';
const RECONNECT_ACTION           = 'RECONNECT';
const REMOVE_ACTION              = 'REMOVE';
const RENAME_ACTION              = 'RENAME';
const REORDER_INPUTS_ACTION      = 'REORDER_INPUTS';
const REORDER_CONNECTIONS_ACTION = 'REORDER_CONNECTIONS';
const SELECT_ACTION              = 'SELECT';
const SELECT_MOVE_ACTION         = 'SELECT_MOVE';
const MOVE_NODES_ACTION          = 'MOVE_NODES';
const SET_PARAM_VALUE_ACTION     = 'SET_PARAM_VALUE';
const SET_PARAM_SETTING_ACTION   = 'SET_PARAM_SETTING';
const SET_NODE_RECT_ACTION       = 'SET_NODE_RECT';
const TOGGLE_DISABLE_ACTION      = 'TOGGLE_DISABLE';
const TOGGLE_PARAM_HEADER_ACTION = 'TOGGLE_PARAM_HEADER';
const SET_CURRENT_GRAPH_ACTION   = 'SET_CURRENT_GRAPH';
const CREATE_PAGE_ACTION         = 'CREATE_PAGE';
const DELETE_PAGE_ACTION         = 'DELETE_PAGE';
const GROUP_NODES_ACTION         = 'GROUP_NODES';
const UNGROUP_NODES_ACTION       = 'UNGROUP_NODES';
const HIGHLIGHT_NODES_ACTION     = 'HIGHLIGHT_NODES';


const BLEND_NORMAL               = 'BNORM';
const BLEND_DARKEN               = 'BDARK';
const BLEND_MULTIPLY             = 'BMULT';
const BLEND_COLOR_BURN           = 'BBURN';
const BLEND_LIGNTEN              = 'BLITE';
const BLEND_SCREEN               = 'BSCRN';
const BLEND_COLOR_DODGE          = 'BDODG';
const BLEND_OVERLAY              = 'BOVER';
const BLEND_SOFT_LIGHT           = 'BSOFT';
const BLEND_HARD_LIGHT           = 'BHARD';
const BLEND_DIFFERENCE           = 'BDIFF';
const BLEND_EXCLUSION            = 'BEXCL';
const BLEND_HUE                  = 'BHUE';
const BLEND_SATURATION           = 'BSAT';
const BLEND_COLOR                = 'BCOL';
const BLEND_LUMINOSITY           = 'BLUM';


const BlendModes =
[
    [BLEND_NORMAL,      'normal',      'NORMAL'     ],
    [BLEND_DARKEN,      'darken',      'DARKEN'     ],
    [BLEND_MULTIPLY,    'multiply',    'MULTIPLY'   ],
    [BLEND_COLOR_BURN,  'color burn',  'COLOR_BURN' ],
    [BLEND_LIGNTEN,     'lighten',     'LIGHTEN'    ],
    [BLEND_SCREEN,      'screen',      'SCREEN'     ],
    [BLEND_COLOR_DODGE, 'color dodge', 'COLOR_DODGE'],
    [BLEND_OVERLAY,     'overlay',     'OVERLAY'    ],
    [BLEND_SOFT_LIGHT,  'soft light',  'SOFT_LIGHT' ],
    [BLEND_HARD_LIGHT,  'hard light',  'HARD_LIGHT' ],
    [BLEND_DIFFERENCE,  'difference',  'DIFFERENCE' ],
    [BLEND_EXCLUSION,   'exclusion',   'EXCLUSION'  ],
    [BLEND_HUE,         'hue',         'HUE'        ],
    [BLEND_SATURATION,  'saturation',  'SATURATION' ],
    [BLEND_COLOR,       'color',       'COLOR'      ],
    [BLEND_LUMINOSITY,  'luminosity',  'LUMINOSITY' ]
];



const FONT_WEIGHTS =
[
    ['thin',        100],
    ['extra light', 200],
    ['light',       300],
    ['regular',     400],
    ['medium',      500],
    ['semi bold',   600],
    ['bold',        700],
    ['extra bold',  800],
    ['black',       900]
];



const FO_TYPE           =  0;
const FO_NODE_ID        =  1;

const FO_OBJECT_ID      =  2;   const FO_STYLE_ID     = 2;
const FO_OBJECT_NAME    =  3;   const FO_STYLE_NAME   = 3;

const FO_FEEDBACK       =  4;   const FO_STYLE_PAINTS = 4;
const FO_RETAIN         =  5;


const FO_XP0            =  6;
const FO_XP1            =  7;
const FO_XP2            =  8;

const FO_SCALE          =  9;

const FO_FILLS          = 10;
const FO_STROKES        = 11;


const FO_STROKE_WEIGHT  = 12;
const FO_STROKE_ALIGN   = 13;
const FO_STROKE_JOIN    = 14;                                    
const FO_STROKE_MITER   = 15;
const FO_STROKE_CAP     = 16;
const FO_STROKE_DASHES  = 17;

const FO_EFFECTS        = 18;

const FO_DECO           = 19;

const FO_MASK           = 20;

const FO_X              = 21;                                                                                                                                                                                                         const FO_GROUP_CHILDREN = 21;
const FO_Y              = 22;                                    
const FO_WIDTH          = 23;   const FO_POINT_IS_CENTER = 23;   
const FO_HEIGHT         = 24;                                    

const FO_RECT_ROUND     = 25;   const FO_ELLIPSE_FROM    = 25;   const FO_VECTOR_NETWORK_DATA = 25;   const FO_VECTOR_PATH_DATA    = 25;   const FO_POLY_ROUND   = 25;   const FO_STAR_ROUND  = 25;   const FO_FIG_WIDTH      = 25;   const FO_FRAME_ROUND    = 25;
                                const FO_ELLIPSE_TO      = 26;                                        const FO_VECTOR_PATH_WINDING = 26;   const FO_POLY_CORNERS = 26;   const FO_STAR_POINTS = 26;   const FO_FIG_HEIGHT     = 26;   const FO_FRAME_CHILDREN = 26;
                                const FO_ELLIPSE_INNER   = 27;                                        const FO_VECTOR_PATH_ROUND   = 27;                                 const FO_STAR_CONVEX = 27;   const FO_TEXT           = 27; 
                                                                                                                                 
                                                                                                                                                                                                      const FO_FONT           = 28;
                                                                                                                                                                                                      const FO_FONT_SIZE      = 29;
                                                                                                                                                                                                      const FO_FONT_STYLE     = 30;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_ALIGN_H        = 31;
                                                                                                                                                                                                      const FO_ALIGN_V        = 32;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_LINE_HEIGHT    = 33;
                                                                                                                                                                                                      const FO_LETTER_SPACING = 34;                                


class FigmaObject
{
    type;
    

    nodeId     = '';


    objectId   = NULL;
    objectName = NULL;

    inputIndex = -1; // for unique object IDs

    retain     = 0;
    feedback   = false;


    xform;

    xp0 = null; //  xp0 ------- xp1 
    xp1 = null; //   |     
    xp2 = null; //  xp2

    sp0 = null; //  sp0 ------- sp1 
    sp1 = null; //   |
    sp2 = null; //  sp2


    scaleCorners;
    scaleStyle;



    constructor(type, nodeId, objectId, objectName)
    {
        this.type         = type;
        this.nodeId       = nodeId;
        this.objectId     = objectId;
        this.objectName   = objectName;

        this.xform        = clone(identity);

        this.scaleCorners = 1;
        this.scaleStyle   = 1;
    }



    copyBase(base)
    {
        this.inputIndex   = base.inputIndex;
        
        this.feedback     = base.feedback;
        this.retain       = base.retain;
        
        this.xform        = clone(base.xform);

        this.xp0          = clone(base.xp0); //base.xp0 ? base.xp0.copy() : null;
        this.xp1          = clone(base.xp1); //base.xp1 ? base.xp1.copy() : null;
        this.xp2          = clone(base.xp2); //base.xp2 ? base.xp2.copy() : null;

        this.sp0          = clone(base.sp0);
        this.sp1          = clone(base.sp1);
        this.sp2          = clone(base.sp2);

        this.scaleCorners = base.scaleCorners;
        this.scaleStyle   = base.scaleStyle;
    }



    copy()
    {
        consoleError('invalid use of abstract method FigmaObject.copy()');
        return null;
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5)
    {
        if (singlePoint)
        {
            cx *= 100;
            cy *= 100;
        }


        const _cx = singlePoint ? this.x + cx : bounds.x + cx * bounds.width;
        const _cy = singlePoint ? this.y + cy : bounds.y + cy * bounds.height;            


        const ds1 = subv(this.sp1, this.sp0);
        const ds2 = subv(this.sp2, this.sp0);

        this.sp0  = point(_cx, _cy);

        this.sp1  = addv(this.sp0, ds1);
        this.sp2  = addv(this.sp0, ds2);
    }



    createDefaultTransform(x, y, a = 0)
    {
        this.xform =
            [[Math.cos(a), -Math.sin(a), x],
             [Math.sin(a),  Math.cos(a), y],
             [0,            0,           1]];
    }



    createDefaultTransformPoints(x, y, w, h)
    {
        this.xp0 = point(x,     y    );
        this.xp1 = point(x + w, y    );
        this.xp2 = point(x,     y + h);

        // this.xp0 = new FigmaPoint(this.nodeId, this.objectId+'.0', this.objectName+' ^ 0', x,     y,     true, false, true);
        // this.xp1 = new FigmaPoint(this.nodeId, this.objectId+'.1', this.objectName+' ^ 1', x + w, y,     true, false, true);
        // this.xp2 = new FigmaPoint(this.nodeId, this.objectId+'.2', this.objectName+' ^ 2', x,     y + h, true, false, true);

        // w = Math.sign(w) * Math.max(0.000001, Math.abs(w));
        // h = Math.sign(h) * Math.max(0.000001, Math.abs(h));

        // this.xp0.createDefaultTransform(x,     y    );
        // this.xp1.createDefaultTransform(x + w, y    );
        // this.xp2.createDefaultTransform(x,     y + h);
    }



    updateTransformPoints()
    {
        // if (this.xp0) this.xp0.nodeId     = this.nodeId;
        // if (this.xp1) this.xp1.nodeId     = this.nodeId;
        // if (this.xp2) this.xp2.nodeId     = this.nodeId;

        // if (this.xp0) this.xp0.objectId   = this.objectId+'.0';
        // if (this.xp1) this.xp1.objectId   = this.objectId+'.1';
        // if (this.xp2) this.xp2.objectId   = this.objectId+'.2';

        // if (this.xp0) this.xp0.objectName = this.objectName+' ^ 0';
        // if (this.xp1) this.xp1.objectName = this.objectName+' ^ 1';
        // if (this.xp2) this.xp2.objectName = this.objectName+' ^ 2';
    }



    createSpaceTransform()
    {
        let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);
        let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);
    
    
        let sx = nozero(vr.x);
        let sy = nozero(vb.y);
    
        let kx = vr.y;
        let ky = vb.x;
        
        let dx = this.sp0.x;
        let dy = this.sp0.y;
    
    
        let xform = mulm3m3(
            createTransform(dx, dy),
            [[sx, ky, 0],
             [kx, sy, 0],
             [0,  0,  1]]);
    

        return xform;
    }
    
    

    getBounds()
    {
        let bounds = Rect.NaN;

        const dp = subv(this.xp1, this.xp0);

        bounds = expandRect_(bounds, this.xp0);
        bounds = expandRect_(bounds, this.xp1);
        bounds = expandRect_(bounds, this.xp2);
        bounds = expandRect_(bounds, addv(this.xp2, dp));

        return bounds;
    }



    applyTransform(xform, affectSpace)
    {
        const space = this.createSpaceTransform();


        if (this.type == POINT)
        {
            const p = transformPoint(point(this.x, this.y), xform, space);

            this.x = p.x;
            this.y = p.y;

            if (affectSpace)
                this.applySpaceTransform(xform, space);
        }
        // else if (this.type == VECTOR_PATH)
        // {
        //     this.updatePoints(xform, space);

        //     if (affectSpace)
        //         this.applySpaceTransform(xform, space);
        // }
        else if (this.type == SHAPE_GROUP)
        {
            for (const obj of this.children)
            {
                obj.applyObjectTransform(xform, space);

                if (affectSpace)
                    obj.applySpaceTransform(xform, space);
            }                
        }
        else
        {
            this.applyObjectTransform(xform, space);

            if (affectSpace)
                this.applySpaceTransform(xform, space);
        }
    }



    applyObjectTransform(xform, space)
    {
        this.updateTransformPoints();

        this.xp0 = transformPoint(this.xp0, xform, space);
        this.xp1 = transformPoint(this.xp1, xform, space);
        this.xp2 = transformPoint(this.xp2, xform, space);

        // const xp0 = transformPoint(this.xp0.toPoint(), xform, space);
        // const xp1 = transformPoint(this.xp1.toPoint(), xform, space);
        // const xp2 = transformPoint(this.xp2.toPoint(), xform, space);

        // this.xp0.x = xp0.x;
        // this.xp0.y = xp0.y;

        // this.xp1.x = xp1.x;
        // this.xp1.y = xp1.y;

        // this.xp2.x = xp2.x;
        // this.xp2.y = xp2.y;
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    toJsonObject()
    {
        return {
            type:       this.type,
            nodeId:     this.nodeId,

            objectId:   this.objectId,
            objectName: this.objectName,
            
            feedback:   this.feedback,

            xp0:        this.xp0 ? this.xp0/*.toPoint()*/ : null,
            xp1:        this.xp1 ? this.xp1/*.toPoint()*/ : null,
            xp2:        this.xp2 ? this.xp2/*.toPoint()*/ : null
        };
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.objectId,
        /* 3 */ this.objectName,
            
        /* 4 */ this.feedback,
        /* 5 */ this.retain,
        
        /* 6 */ this.xp0 ? this.xp0/*.toPoint()*/ : null,
        /* 7 */ this.xp1 ? this.xp1/*.toPoint()*/ : null,
        /* 8 */ this.xp2 ? this.xp2/*.toPoint()*/ : null,

        /* 9 */ 0 // for future use
        ];
    }



    // isValid()
    // {
    //     return true;
    // }
}



function transformPoint(p, xform, space)
{
    p = mulv2m3(p, inversem3(space));
    p = mulv2m3(p, xform);
    p = mulv2m3(p, space);

    return p;
}



function copyFigmaObject(obj)
{
    switch (obj.type)
    {
        case RECTANGLE:   return FigmaRectangle .prototype.copy.call(obj);
        case LINE:        return FigmaLine      .prototype.copy.call(obj);
        case ELLIPSE:     return FigmaEllipse   .prototype.copy.call(obj);
        case TRAPEZE:     return FigmaTrapeze   .prototype.copy.call(obj);
        case POLYGON:     return FigmaPolygon   .prototype.copy.call(obj);
        case STAR:        return FigmaStar      .prototype.copy.call(obj);
        case TEXT_SHAPE:  return FigmaText      .prototype.copy.call(obj);
        case POINT:       return FigmaPoint     .prototype.copy.call(obj);
        case VECTOR_PATH: return FigmaVectorPath.prototype.copy.call(obj);
        case BOOLEAN:     return FigmaBoolean   .prototype.copy.call(obj);
        case SHAPE_GROUP: return FigmaShapeGroup.prototype.copy.call(obj);
        case FRAME:       return FigmaFrame     .prototype.copy.call(obj);
    }

    consoleError('invalid Figma object type \'' + obj.type + '\'');
    return null;
}



function getPointBounds(points)
{
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;

    for (const p of points)
    {
        minX = Math.min(minX, p.x.value);
        minY = Math.min(minY, p.y.value);
        maxX = Math.max(maxX, p.x.value);
        maxY = Math.max(maxY, p.y.value);
    }

    return new AbsRect(minX, minY, maxX, maxY);
}



function getObjBounds(objects)
{
    let bounds = Rect.NaN;

    for (const obj of objects)
        bounds = expandRect(bounds, obj.getBounds());

    return bounds;
}



function addObjectCenter(node, obj, zoom)
{
    const length = 10;
    
    const sp0 = point(
        obj.sp0.x /*+ 0.5*/, 
        obj.sp0.y /*+ 0.5*/);

    const sp1 = addv(sp0, mulvs(      subv(obj.sp1, obj.sp0),      length));
    const sp2 = addv(sp0, mulvs(mulvs(subv(obj.sp2, obj.sp0), -1), length));    

    node.value.objects.push(
        createDecoPoly(
            node, 
            sp0, 
            [sp2, sp0, sp1],
            false,
            '',
            [242, 72, 34], 
            CENTER_SUFFIX));
}



function createDecoPoly(node, center, points, closed, dashes, color, suffix)
{
    const line = new FigmaVectorPath(
        node.nodeId,
        node.nodeId   + suffix,
        node.nodeName + suffix,
        points.map(p => PointValue.fromPoint(node.nodeId, p)),
        closed ? 1 : 0, 
        0, 
        0, 
        0);


    line.strokes.push([
        'SOLID', 
        color[0], 
        color[1], 
        color[2], 
        100, 
        'NORMAL']);

    line.strokeWeight = 1;
    line.strokeAlign  = 'CENTER';
    line.strokeJoin   = 'MITER';
    line.strokeCap    = 'NONE';
    line.strokeDashes = dashes;
    line.isDeco       = true;


    line.createDefaultTransform(center.x, center.y);


    return line;
}



function getValidObjects(value)
{
    return value
        && value.objects
        ? value.objects
              .filter(o => 
                     o.isDeco  === false
                  || o.isXform === true)
              .map(o => o.copy()) 
        : [];
}



// function getValidInputObjects(input)
// {
//     const objects = [];
    

//     if (!input)
//         return objects;

//     // if (LIST_VALUES.includes(input.type))
//     //     for (const item of input.items)
//     //         objects.push(...getValidInputObjects(item));

//     if (   input.value
//         && input.value.objects)
//         objects.push(...input.value.objects
//               .filter(o => 
//                      o.isDeco  === false
//                   || o.isXform === true)
//               .map(o => o.copy()));


//     return objects;
// }


function addColorProp(obj, prop)
{
    const rgb = scaleRgb(prop.toRgb());

    obj.fills.push([
        'SOLID', 
        rgb[0], 
        rgb[1], 
        rgb[2], 
        255   ]);
}



function addFillProp(obj, prop, target = obj.fills)
{
    const rgb = scaleRgb(prop.color.toRgb());

    target.push([
        'SOLID', 
        rgb[0], 
        rgb[1], 
        rgb[2], 
        prop.opacity.toValue().toNumber(),
        BlendModes[prop.blend.value][2]]);
}



function addGradientProp(obj, prop, target = obj.fills)                
{
    const gradient = 
    [
        '', // type
        [], // transform
        []  // stops
    ];


    switch(prop.gradType.value)
    {
        case 0: gradient[0] = 'GRADIENT_LINEAR';  break;
        case 1: gradient[0] = 'GRADIENT_RADIAL';  break;
        case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;
        case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;
    }


    const isLinear = prop.gradType.value == 0;


    let   x   =        prop.x     .toNumber() / 100;
    let   y   =        prop.y     .toNumber() / 100;
    const a   =        prop.angle .toNumber()/360*Tau;
    let   s   = nozero(prop.size  .toNumber() / 100);
    let   asp = nozero(prop.aspect.toNumber() / 100);
    let   sk  =        prop.skew  .toNumber() / 100;


    if (!isLinear)
    {
        x   -= s * Math.cos(a);
        y   -= s * Math.sin(a);

        s   *= 2;

        asp /= 2;
    }

    
    const p0 = point(x, y);
    const p1 = addv(p0, vector(a, s));
    
    const p2 = addv(
        addv(p0, vector(a + Tau/4, s * asp)),
        mulvs(unitv(subv(p1, p0)), distance(p0, p1) * sk));


    const identityHandles = 
        [[0,   1,   0],
         [0.5, 0.5, 1],
         [1,   1,   1]];


    let xform = [
        [p0.x, p1.x, p2.x],
        [p0.y, p1.y, p2.y],
        [1,    1,    1   ]];


    xform = mulm3m3(identityHandles, inversem3(xform));


    gradient[1] = [
        xform[0],
        xform[1] ];
        

    const stops = validateColorStops(prop.stops.items);
    
    setColorStopPositions(stops);


    for (let j = 0; j < stops.length; j++)
    {
        const stop = stops[j];
        const rgba = stop.fill.toRgba();

        gradient[2].push([
            rgba[0], 
            rgba[1], 
            rgba[2], 
            rgba[3],
            stop.position.toNumber() / 100]);
    }


    gradient[3] = BlendModes[prop.blend.value][2];    


    target.push(gradient);
}



function validateColorStops(_stops)
{
    const stops = [];


    for (let i = 0; i < _stops.length; i++)
    {
        const stop = _stops[i];

        if (stop.type == COLOR_VALUE)
        {
            // if (isNaN(stop.toRgb()[0]))
            //     console.log('stop =', stop);
            stops.push(new ColorStopValue(
                FillValue.fromRgb(scaleRgb(stop.toRgb()), 100),
                NumberValue.NaN));
        }

        else if (stop.type == FILL_VALUE)
            stops.push(new ColorStopValue(
                stop,
                NumberValue.NaN));

        else if (stop.type == LIST_VALUE)
            stops.push(...validateColorStops(stop.items));

        else
            stops.push(stop);
    }


    return stops;
}



function setColorStopPositions(stops)
{
    if (    stops.length > 0
        && !stops[0].position.isValid()) 
        stops[0].position = new NumberValue(0);

    if (    stops.length > 1
        && !stops.at(-1).position.isValid()) 
        stops.at(-1).position = new NumberValue(100);
    

    if (stops.length > 2)
    {
        for (let i = 1; i < stops.length-1; i++)
        {
            const stop = stops[i];

            if (!stop.position.isValid())
            {
                let prevValid = i-1;
                let nextValid = i+1;

                while ( prevValid > 0
                    && !stops[prevValid].position.isValid()) 
                    prevValid--;

                while ( nextValid < stops.length-1
                    && !stops[nextValid].position.isValid()) 
                    nextValid++;
                        
                const pv = stops[prevValid].position.toNumber();
                const nv = stops[nextValid].position.toNumber();

               stop.position = new NumberValue((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid)))); 
            }
        }
    }
}



function addStrokeProp(obj, prop)
{
    for (const fill of prop.fills.items)
    {
        if (fill.type ==     FILL_VALUE) addFillProp    (obj, fill, obj.strokes);
        if (fill.type == GRADIENT_VALUE) addGradientProp(obj, fill, obj.strokes);
    }


    obj.strokeWeight = prop.weight.toValue().toNumber();

    switch (prop.fit.toValue().value)
    {
        case 0: obj.strokeAlign = 'INSIDE';  break;
        case 1: obj.strokeAlign = 'CENTER';  break;
        case 2: obj.strokeAlign = 'OUTSIDE'; break;
    }

    switch (prop.join.toValue().value)
    {
        case 0: obj.strokeJoin = 'MITER'; break;
        case 1: obj.strokeJoin = 'BEVEL'; break;
        case 2: obj.strokeJoin = 'ROUND'; break;
    }

    switch (prop.cap.toValue().value)
    {
        case 0: obj.strokeCap = 'NONE';   break;
        case 1: obj.strokeCap = 'SQUARE'; break;
        case 2: obj.strokeCap = 'ROUND';  break;
    }

    obj.strokeDashes     = prop.dashes.toValue().value;
    
    obj.strokeMiterLimit = prop.miter.toValue().value;
}



function addDropShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'DROP_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .toNumber(),
        prop.y     .toNumber(),
        prop.blur  .toNumber(),
        prop.spread.toNumber(),
        BlendModes[prop.blend.value][2],
        prop.behind.value > 0,
        prop.visible ]);
}



function addInnerShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'INNER_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .toNumber(),
        prop.y     .toNumber(),
        prop.blur  .toNumber(),
        prop.spread.toNumber(),
        BlendModes[prop.blend.value][2],
        prop.visible ]);
}



function addLayerBlurProp(obj, prop)
{
    obj.effects.push([
        'LAYER_BLUR', 
        prop.radius.toNumber(),
        prop.visible ]);
}



function addBackBlurProp(obj, prop)
{
    obj.effects.push([
        'BACKGROUND_BLUR', 
        prop.radius.toNumber(),
        prop.visible ]);
}



function addMaskProp(obj)
{
    obj.isMask = true;
}



class FigmaShape
extends FigmaObject
{
    skewX;
    skewY;

    fills   = [];
    strokes = [];

    strokeWeight;
    strokeAlign;
    strokeJoin;
    strokeMiterLimit;
    strokeCap;
    strokeDashes;

    effects = [];

    isDeco;
    isXform;

    isMask  = false;



    constructor(type, nodeId, objectId, objectName, isDeco = false, isXform = false)
    {
        super(type, nodeId, objectId, objectName);

        this.skewX   = 0;
        this.skewY   = 0;

        this.isDeco  = isDeco;
        this.isXform = isXform;
    }



    copyBase(base)
    {
        super.copyBase(base);

        this.skewX            = base.skewX;
        this.skewY            = base.skewY;

        this.fills            = clone(base.fills);
        this.strokes          = clone(base.strokes);

        this.strokeWeight     = base.strokeWeight;
        this.strokeAlign      = base.strokeAlign;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
        this.strokeCap        = base.strokeCap;
        this.strokeDashes     = base.strokeDashes;

        this.effects          = clone(base.effects);

        this.isDeco           = base.isDeco;
        this.isXform          = base.isXform;

        this.isMask           = base.isMask;
    }



    toData()
    {
        const weight = this.strokeWeight * Math.abs(this.scaleStyle);

        const dashes = 
            this.strokeDashes
            ? this.strokeDashes
                .split(',')
                .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))
                .join(',')
            : '';

        
        return [
            ...super.toData(),
   
            /* 10 */ this.fills,
            /* 11 */ this.strokes,

            /* 12 */ weight,
            /* 13 */ this.strokeAlign,
            /* 14 */ this.strokeJoin,
            /* 15 */ this.strokeMiterLimit,
            /* 16 */ this.strokeCap,
            /* 17 */ dashes,

            /* 18 */ this.effects,

            /* 19 */ this.isDeco,

            /* 20 */ this.isMask
        ];
    }
}



class FigmaRectangle
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, round)
    {
        super(RECTANGLE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;

        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaRectangle(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round);


        copy.copyBase(this);

        
        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round * Math.abs(this.scaleCorners)
        ];
    }
}



class FigmaLine
extends FigmaShape
{
    x;
    y;
    width;



    constructor(nodeId, objectId, objectName, x, y, width)
    {
        super(LINE, nodeId, objectId, objectName);
        
        this.x     = x;
        this.y     = y;
        this.width = width;

        
        this.createDefaultSpace(
            x + width/2, 
            y);
    }



    copy()
    {
        const copy = new FigmaLine(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width
        ];
    }
}


class FigmaEllipse
extends FigmaShape
{
    x;
    y;
    width;
    height;

    from;
    to;
    inner;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, from, to, inner)
    {
        super(ELLIPSE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.from   = from;
        this.to     = to;
        this.inner  = inner;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaEllipse(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.from,
            this.to,
            this.inner);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.from,
            /* 26 */ this.to,
            /* 27 */ this.inner
        ];
    }
}


class FigmaVectorPath
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;
    closed;
    degree;

    pathPoints;

    pathData;
    winding;
    round;



    constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)
    {
        super(VECTOR_PATH, nodeId, objectId, objectName);
        
        this.points  = points.map(p => p.copy());

        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;

        this.round   = round;
        

        this.updatePathPoints();


        let bounds = this.getBounds();

        this.createDefaultSpace(
            bounds.x + bounds.width /2,            
            bounds.y + bounds.height/2            
        );
    }



    copy()
    {
        const copy = new FigmaVectorPath(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points, 

            this.closed, 
            this.degree,
            this.winding,

            this.round);


        copy.x      = this.x;
        copy.y      = this.y;
        copy.width  = this.width;
        copy.height = this.height;


        copy.copyBase(this);


        return copy;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.points) this.points = base.points.map(p => p.copy());
    }



    getBounds()
    {
        let bounds = Rect.NaN;

        
        switch (this.degree)
        {
            case 0:
                for (const p of this.pathPoints)
                    bounds = expandRect_(bounds, p);

                break;

            case 1:
                for (let i = 0; i < this.pathPoints.length-2; i += 2)
                {
                    bounds = expandRect(
                        bounds, 
                        bounds2(
                            this.pathPoints[i  ], 
                            this.pathPoints[i+1],
                            this.pathPoints[i+2]));
                }
                break;

            case 2:
            case 3:
            case 4:
            case 5:
                for (let i = 0; i < this.pathPoints.length-3; i += 3)
                {
                    bounds = expandRect(
                        bounds, 
                        bounds3(
                            this.pathPoints[i  ], 
                            this.pathPoints[i+1],
                            this.pathPoints[i+2],
                            this.pathPoints[i+3]));
                }
                break;

            default:
                console.error('invalid curve degree');
        }


        return bounds;
    }



    applyObjectTransform(xform, space)
    {
        super.applyObjectTransform(xform, space);
        this.updatePoints(xform, space);
    }



    updatePoints(xform, space)
    {
        for (let i = 0; i < this.points.length; i++)
        {
            let p = this.points[i].toPoint();
            p = transformPoint(p, xform, space);
            this.points[i] = PointValue.fromPoint(this.nodeId, p);
        }
    }



    updatePathPoints()
    {
        switch (this.degree)
        {
        case 0: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 1: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 2: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 3: this.pathPoints = getSmoothPoints(this.points, this.closed, getSmoothSegment); break;
        case 4: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineXSegment ); break;
        case 5: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineYSegment ); break;
        }
    }



    updatePathData()
    {
        const bounds = this.getBounds();

        this.x      = bounds.x;
        this.y      = bounds.y;
        this.width  = bounds.width;
        this.height = bounds.height;

        this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);

        this.pathData = getPathDataFromPoints(this.pathPoints, this.closed, this.degree);
    }



    toData()
    {
        this.updatePathPoints();
        this.updatePathData();


        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.pathData,
            /* 26 */ this.winding,
            /* 27 */ this.round * Math.abs(this.scaleCorners)
        ];
    }
}



function getPathDataFromPoints(points, closed, degree)
{
    for (const p of points)
        if (   isNaN(p.x)
            || isNaN(p.y))
            return '';

            
    let pathData = '';


    switch (degree)
    {
    case 0: pathData = getLinearPathData   (points);         break;
    case 1: pathData = getQuadraticPathData(points, closed); break;
    case 2: 
    case 3: 
    case 4: 
    case 5: pathData = getCubicPathData    (points, closed); break;
    }


    const pointsAreValid =
           degree == 0 && points.length > 2
        || degree == 1 && points.length > 2
        || degree == 2 && points.length > 3
        || degree == 3 && points.length > 2
        || degree == 4 && points.length > 2
        || degree == 5 && points.length > 2;


    if (   pointsAreValid
        && (   closed
            || equalv(points[0], points.at(-1))))
        pathData += ' Z';


    return pathData;
}



function getQuadraticPathData(points, closed)
{
    let pathData = '';


    if (points.length < 3)
        return pathData;


    pathData += 'M';
    pathData += ' ' + almostZero(points[0].x);
    pathData += ' ' + almostZero(points[0].y);

    let i;
    for (i = 1; i < points.length-1; i += 2)
    {
        pathData += 
              ' Q'
            + ' ' + almostZero(points[i  ].x)
            + ' ' + almostZero(points[i  ].y)
            + ' ' + almostZero(points[i+1].x)
            + ' ' + almostZero(points[i+1].y);
    }


    if (   points.length - i == 1
        && closed)
    {
        pathData += 
              ' Q'
            + ' ' + almostZero(points.at(-1).x)
            + ' ' + almostZero(points.at(-1).y)
            + ' ' + almostZero(points.at( 0).x)
            + ' ' + almostZero(points.at( 0).y);
    }


    return pathData;
}



function getCubicPathData(points, closed)
{
    let pathData = '';


    if (points.length < 4)
        return pathData;


    pathData += 'M';
    pathData += ' ' + almostZero(points[0].x);
    pathData += ' ' + almostZero(points[0].y);

    let i;
    for (i = 1; i < points.length-2; i += 3)
    {
        pathData += 
              ' C'
            + ' ' + almostZero(points[i  ].x)
            + ' ' + almostZero(points[i  ].y)
            + ' ' + almostZero(points[i+1].x)
            + ' ' + almostZero(points[i+1].y)
            + ' ' + almostZero(points[i+2].x)
            + ' ' + almostZero(points[i+2].y);
    }


    if (points.length - i == 2)
    {
        pathData += 
              ' C'
            + ' ' + almostZero(points.at(-2).x)
            + ' ' + almostZero(points.at(-2).y)
            + ' ' + almostZero(points.at(-1).x)
            + ' ' + almostZero(points.at(-1).y)
            + ' ' + almostZero(points.at( 0).x)
            + ' ' + almostZero(points.at( 0).y);
    }


    return pathData;
}



function getSmoothPoints(points, closed, getSegment)
{
    if (points.length < 2)
        return '';


    const bp = [];


    // first point
    let [pp, p, pn] = getSegment(
        closed ? points.at(-1) : points[0], 
        points[0],
        points[1]);

    bp.push(p);


    let _pp = pn;


    // middle segments
    for (let i = 1; i < points.length; i++)
    {
        [pp, p, pn] = getSegment(
            points[i-1], 
            points[i],
            i == points.length-1 
            ? (closed ? points[0] : points[i])
            : points[i+1]);

        bp.push(_pp, pp, p);

        _pp = pn;
    }


    if (bp.length > 3)
    {
        if (closed)
        {
            if (   equal(bp[0].x, bp.at(-1).x, 0.01)
                && equal(bp[0].y, bp.at(-1).y, 0.01))
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-2), 
                    points.at( 0),
                    points.at( 1));

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
            else
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-1), 
                    points.at( 0),
                    points.at( 1));

                bp.push(_pp, pp, p);

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
        }
        else // open
        {
            bp[1]           = addv(bp[0],     mulvs(unitv(subv(bp[2],     bp[0]    )), distance(bp[3],     bp[0]    )/3));
            bp[bp.length-2] = addv(bp.at(-1), mulvs(unitv(subv(bp.at(-3), bp.at(-1))), distance(bp.at(-4), bp.at(-1))/3));
        }
    }


    return bp;
}



function getSmoothSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);


    const v = subv(_pn, _pp);
    
    
    let a = angleDiff(
        angle(subv(_p, _pp)), 
        angle(subv(_pn, _p)));

    a = Math.abs(a);
    while (a >= Tau/2) a -= Tau;


    const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248; // slight improvement (see Bézier Curves p. 13, Gernot Hoffmann);

    let f =
        a > Tau/4
        ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)
        : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));
    

    const pp = addv(_p, mulvs(unitv(v), -lengthv(v)/2 * f));
    const pn = addv(_p, mulvs(unitv(v),  lengthv(v)/2 * f));
    //console.log('pp =', pp);
    //console.log('pn =', pn);


    return [pp, _p, pn];
}



function getSineXSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);
    const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);

    return [pp, _p, pn];
}



function getSineYSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);
    const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);

    return [pp, _p, pn];
}


class FigmaVectorNetwork
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;
    edges;
    regions;

    networkData;



    constructor(nodeId, objectId, objectName, points, edges, regions)
    {
        super(VECTOR_NETWORK, nodeId, objectId, objectName);
        
        this.points  = points .map(p => p.copy());
        this.edges   = edges  .map(e => e.copy());
        this.regions = regions.map(r => r.copy());


        this.updateNetworkData();


        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            bounds = expandRect(
                bounds, 
                bounds3(
                    this.edges[i].start.toPoint(), 
                    this.edges[i].start.toPoint(),
                    this.edges[i].end  .toPoint(),
                    this.edges[i].end  .toPoint()));
        }

        this.createDefaultSpace(
            bounds.x + bounds.width /2,            
            bounds.y + bounds.height/2            
        );
    }



    copy()
    {
        const copy = new FigmaVectorNetwork(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points, 
            this.edges, 
            this.regions);


        copy.x      = this.x;
        copy.y      = this.y;
        copy.width  = this.width;
        copy.height = this.height;


        copy.copyBase(this);


        return copy;
    }



    updateNetworkData()
    {
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;

        for (const p of this.points)
        {
            minX = Math.min(minX, p.x.value);
            minY = Math.min(minY, p.y.value);
            maxX = Math.max(maxX, p.x.value);
            maxY = Math.max(maxY, p.y.value);
        }


        this.x      = minX;
        this.y      = minY;
        this.width  = maxX - minX;
        this.height = maxY - minY;

        this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);


        this.networkData = getNetworkData(this.points, this.edges, this.regions);
    }



    getBounds()
    {
        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            bounds = expandRect(
                bounds, 
                bounds3(
                    this.edges[i].start.toPoint(), 
                    this.edges[i].start.toPoint(),
                    this.edges[i].end  .toPoint(),
                    this.edges[i].end  .toPoint()));
        }

        return bounds;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.networkData
        ];
    }
}



function getNetworkData(points, edges, _regions)
{
    const vertices = [];
    const segments = [];
    const regions  = [];


    for (const point of points)
    {
        let join;
        let cap;

        switch (point.join.value)
        {
            case 0: join = 'MITER'; break;
            case 1: join = 'BEVEL'; break;
            case 2: join = 'ROUND'; break;
        }
    
        switch (point.cap.value)
        {
            case 0: cap = 'NONE';   break;
            case 1: cap = 'SQUARE'; break;
            case 2: cap = 'ROUND';  break;
        }
    
        vertices.push(
        {
            x:            point.x.value,
            y:            point.y.value,
            strokeJoin:   join,
            strokeCap:    cap,
            cornerRadius: point.round.value
        });
    }


    for (const edge of edges)
    {
        segments.push(
        {
            start: points.findIndex(p => p.uniqueId == edge.start.uniqueId),
            end:   points.findIndex(p => p.uniqueId == edge.end  .uniqueId)
        });
    }


    for (const region of _regions)
    {
        const loops = [];

        for (const _loop of region.loops.items)
        {
            const loop = [];

            for (const _edge of _loop.items)
                loop.push(edges.findIndex(e => e.uniqueId == _edge.uniqueId));

            loops.push(loop);
        }


        regions.push(
        {
            windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',
            loops:       loops,
            fills:       getObjectFills(region.fills)
        });
    }


    let networkData = 
    {
        vertices: vertices,
        segments: segments,
        regions:  regions
    };


    return networkData;
}


class FigmaTrapeze
extends FigmaVectorPath
{
    width;
    height;

    round;

    bias;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)
    {
        const tw = width * (1 + Math.min(0,  bias/100));
        const bw = width * (1 + Math.min(0, -bias/100));
        
        const tx = x + (width - tw) / 2;
        const bx = x + (width - bw) / 2;

        const points =
        [
            PointValue.create(nodeId, tx,      y         ),
            PointValue.create(nodeId, bx,      y + height),
            PointValue.create(nodeId, bx + bw, y + height),
            PointValue.create(nodeId, tx + tw, y         )
        ];

    
        super(
            nodeId, 
            objectId,
            objectName, 
            points,
            1, // closed
            0, // linear
            0, // even-odd winding
            round);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.bias   = bias;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaTrapeze(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.bias);


        copy.x = this.x;
        copy.y = this.y;


        copy.copyBase(this);

        
        return copy;
    }
}



class FigmaPolygon
extends FigmaShape
{
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)
    {
        super(POLYGON, nodeId, objectId, objectName);
        
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;

        this.round   = round;
        this.corners = corners;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaPolygon(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.corners);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round * Math.abs(this.scaleCorners),
            /* 26 */ this.corners
        ];
    }
}



class FigmaStar
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    points;
    convex;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)
    {
        super(STAR, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.points = points;
        this.convex = convex;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaStar(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,

            this.round,
            this.points,
            this.convex);

        copy.copyBase(this);

        return copy;
    }


    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round * Math.abs(this.scaleCorners),
            /* 26 */ this.points,
            /* 27 */ this.convex
        ];
    }
}



class FigmaText
extends FigmaShape
{
    text;
    
    x;
    y;
    width;
    height;
    
    figWidth;
    figHeight;
    
    font;
    size;
    style;
    
    alignH;
    alignV;
    
    lineHeight;
    letterSpacing;



    constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignH, alignV, lineHeight, letterSpacing)
    {
        super(TEXT_SHAPE, nodeId, objectId, objectName);
        
        this.text          = text;
    
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
    
        this.figWidth      = width;
        this.figHeight     = height;
    
        this.font          = font;
        this.size          = size;
        this.style         = style;
    
        this.alignH        = alignH;
        this.alignV        = alignV;
    
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaText(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.text,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.font,
            this.size,
            this.style,
    
            this.alignH,
            this.alignV,
    
            this.lineHeight,
            this.letterSpacing);


        copy.figWidth  = this.figWidth;
        copy.figHeight = this.figHeight;


        copy.copyBase(this);


        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:             this.x,
            y:             this.y,
            width:         this.width,
            height:        this.height,

            figWidth:      this.figWidth,
            figHeight:     this.figHeight,

            text:          this.text,

            font:          this.font,
            size:          this.size,
            style:         this.style,

            alignH:        this.alignH,
            alignV:        this.alignV,
            
            lineHeight:    this.lineHeight,
            letterSpacing: this.letterSpacing
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,
            
            /* 25 */ this.figWidth,
            /* 26 */ this.figHeight,
            
            /* 27 */ this.text,

            /* 28 */ this.font,
            /* 29 */ this.size,
            /* 30 */ this.style,
            
            /* 31 */ this.alignH,
            /* 32 */ this.alignV,
            
            /* 33 */ this.lineHeight,
            /* 34 */ this.letterSpacing
        ];
    }



    // isValid()
    // {
    //     return super.isValid()

    //         && this.x
    //         && this.y
    //         && this.width
    //         && this.height

    //         && this.figWidth
    //         && this.figHeight

    //         && this.text

    //         && this.font
    //         && this.size
    //         && this.style

    //         && this.alignH
    //         && this.alignV
        
    //         && this.lineHeight
    //         && this.letterSpacing;
    // }
}



class FigmaPoint
extends FigmaShape
{
    x;
    y;
    isCenter;



    constructor(nodeId, objectId, objectName, x, y, isDeco = false, isCenter = false, isXform = false)
    {
        super(POINT, nodeId, objectId, objectName, isDeco, isXform);
        
        this.x        = x;
        this.y        = y;
        this.isCenter = isCenter;

        
        this.createDefaultSpace(x, y);

        this.createDefaultTransform(x, y);
    }



    copy()
    {
        const copy = new FigmaPoint(
            this.nodeId,
            this.objectId,
            this.objectName, 
            this.x,
            this.y,
            this.isDeco,
            this.isCenter);

        copy.copyBase(this);

        return copy;
    }



    getBounds()
    {
        return new Rect(this.x-0.005, this.y-0.005, 0.01, 0.01);
    }



    toPoint()
    {
        return point(this.x, this.y);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.isCenter
        ];
    }
}



class FigmaBoolean
extends FigmaShape
{
    operation;
    children;



    constructor(nodeId, objectId, objectName, operation, children = [])
    {
        super(BOOLEAN, nodeId, objectId, objectName);
        
        this.operation = operation;
        this.children  = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaBoolean(
            this.nodeId,
            this.objectId,
            this.objectName,
            this.operation,
            this.children);

        copy.copyBase(this);

        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            operation: this.operation,
            children:  this.children
        };
    }
}


class FigmaShapeGroup
extends FigmaShape
{
    children;



    constructor(nodeId, objectId, objectName, children = [])
    {
        super(SHAPE_GROUP, nodeId, objectId, objectName);
        
        this.children = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaShapeGroup(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.children);

        copy.copyBase(this);

        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.children.map(o => o.toData())
        ];
    }
}


class FigmaFrame
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    
    children;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, children = [])
    {
        super(FRAME, nodeId, objectId, objectName);
        
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
    
        this.round    = round;
    
        this.children = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaFrame(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.round,
    
            this.children);


        copy.copyBase(this);


        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:        this.x,
            y:        this.y,
            width:    this.width,
            height:   this.height,
        
            round:    this.round,
        
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round,

            /* 26 */ this.children.map(o => o.toData())
        ];
    }
}






class FigmaColorStyle
{
    type;
    
    nodeId = '';

    styleId;
    styleName;

    paints = [];

//    existing;



    constructor(nodeId, styleId, styleName)
    {
        this.type      = COLOR_STYLE;
        this.nodeId    = nodeId;

        this.styleId   = styleId;
        this.styleName = styleName;
    }



    copy()
    {
        const copy = new FigmaColorStyle(this.nodeId, this.styleId, this.styleName);

//        copy.existing = this.existing;

        return copy;
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.styleId,
        /* 3 */ this.styleName,
        
        /* 4 */ this.paints
        ];
    }
}


class GNode
{
    static nextUniqueId = 0;

    type;


    valid; // has been evaluated

    listId        = -1;
    uniqueId;

    cached        = true;
    unknown       = false;

    loopId        = NULL;

    iteration     = 0;
    iterated      = false;


    updateValues  = null;



    constructor(type, options) 
    {
        this.type    = type;

        if (options && options.cached ) this.cached  = options.cached;
        if (options && options.unknown) this.unknown = options.unknown;
     
        this.uniqueId = GNode.nextUniqueId++;
    }



    copy()
    {
        consoleError('abstract type GNode cannot be copied');
        return null;
    }



    copyBase(base)
    {
        this.data     = clone(base.data   );

        this.uniqueId = base.uniqueId;
    }



    toValue()
    {
        return null;
    }



    toString() 
    { 
        return this.type; 
    }



    toJson()
    {
        return this.toString();
    }



    isValid() // is a valid value
    {
        return false;
    }


    
    validate()
    {
        this.valid = true;
    }



    pushValueUpdates(parse)
    {

    }



    invalidateInputs(parse, from)
    {
        if (this.unknown)
            this.valid = false;

        return true;
    }



    initLoop(parse, nodeId)
    {

    }



    invalidateLoop(parse, nodeId)
    {

    }



    iterateLoop(parse)
    {

    }



    resetLoop(parse, nodeId)
    {

    }    
}



class GValue
extends GNode
{
    valueId;

    objects = null;



    constructor(type, options) 
    {
        super(type, options);

        this.valueId = '';
    }



    copy()
    {
        consoleError('abstract class GValue cannot be copied');
        return null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.valueId = base.valueId;

        if (base.objects)
            this.copyObjects(base.objects);
    }



    copyObjects(objects)
    {
        this.objects = objects.map(o => o.copy());
    }



    // eval()
    // {
    //     return this;
    // }



    hasInitValue()
    {
        return false;
    }



    toValue()
    {
        return this.copy();
    }



    toJson() 
    { 
        return this.toString(); 
    }



    toString() 
    { 
        return this.type; 
    }



    toDisplayString()
    {
        return this.toString();
    }



    toJsCode(gen)
    {
        consoleError('invalid abstract method');
        return '';
    }



    getNaN()
    {
        consoleError('invalid abstract method');
        return null;
    }



    isCached()
    {
        return true;
    }
}



function parseValueFromType(type, value)
{
    switch (type)
    {
        case           LIST_VALUE: 
        case    NUMBER_LIST_VALUE: 
        case      TEXT_LIST_VALUE: 
        case     SHAPE_LIST_VALUE: return parseListValue         (value)[0];

        case         NUMBER_VALUE: return parseNumberValue       (value)[0];
        case           TEXT_VALUE: return parseTextValue         (value)[0];
        case          COLOR_VALUE: return parseColorValue        (value)[0];

        case           FILL_VALUE: return parseFillValue         (value)[0];
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0];
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0];
        case         STROKE_VALUE: return parseStrokeValue       (value)[0];
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0];
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0];
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0];
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0];
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0];

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0];
        case           LINE_VALUE: return parseLineValue         (value)[0];
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0];
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0];
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0];
        case           STAR_VALUE: return parseStarValue         (value)[0];
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0];
        case          POINT_VALUE: return parsePointValue        (value)[0];
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0];
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0];
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0];
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0];
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0];
        case        BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0];
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0];
        case          FRAME_VALUE: return parseFrameValue        (value)[0];
        
        default: 
            console.error('unknown type \'' + type + '\'');
            return null;
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case           LIST_VALUE: return parseListValue         (value)[0].toDisplayString();

        case         NUMBER_VALUE: return parseNumberValue       (value)[0].toDisplayString();
        case           TEXT_VALUE: const val = parseTextValue    (value)[0]; return val == '' ? '\'\'' : val.toDisplayString();
        case          COLOR_VALUE: return parseColorValue        (value)[0].toDisplayString();
        case           FILL_VALUE: return parseFillValue         (value)[0].toDisplayString();
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0].toDisplayString();
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0].toDisplayString();
        case         STROKE_VALUE: return parseStrokeValue       (value)[0].toDisplayString();
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0].toDisplayString();
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0].toDisplayString();
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0].toDisplayString();
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0].toDisplayString();
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0].toDisplayString();

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0].toDisplayString();
        case           LINE_VALUE: return parseLineValue         (value)[0].toDisplayString();
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0].toDisplayString();
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0].toDisplayString();
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0].toDisplayString();
        case           STAR_VALUE: return parseStarValue         (value)[0].toDisplayString();
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0].toDisplayString();
        case          POINT_VALUE: return parsePointValue        (value)[0].toDisplayString();
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0].toDisplayString();
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0].toDisplayString();
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0].toDisplayString();
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0].toDisplayString();
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0].toDisplayString();
        case        BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0].toDisplayString();
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0].toDisplayString();
        case          FRAME_VALUE: return parseFrameValue        (value)[0].toDisplayString();
    }


    consoleError('cannot display value of type \'' + type + '\'');
}



function nanFromType(type)
{
    switch (type)
    {
        case            LIST_VALUE: return          ListValue.NaN;

        case          NUMBER_VALUE: return        NumberValue.NaN;
        case            TEXT_VALUE: return        new TextValue();
        case           COLOR_VALUE: return         ColorValue.NaN;
        case            FILL_VALUE: return          FillValue.NaN;
        case      COLOR_STOP_VALUE: return     ColorStopValue.NaN;
        case        GRADIENT_VALUE: return      GradientValue.NaN;
        case          STROKE_VALUE: return        StrokeValue.NaN;
        case     DROP_SHADOW_VALUE: return    DropShadowValue.NaN;
        case    INNER_SHADOW_VALUE: return   InnerShadowValue.NaN;
        case      LAYER_BLUR_VALUE: return     LayerBlurValue.NaN;
        case       BACK_BLUR_VALUE: return      BackBlurValue.NaN;
        case      LAYER_MASK_VALUE: return     LayerMaskValue.NaN;

        case       RECTANGLE_VALUE: return     RectangleValue.NaN;
        case            LINE_VALUE: return          LineValue.NaN;
        case         ELLIPSE_VALUE: return       EllipseValue.NaN;
        case         POLYGON_VALUE: return       PolygonValue.NaN;
        case            STAR_VALUE: return          StarValue.NaN;
        case      TEXT_SHAPE_VALUE: return     TextShapeValue.NaN;
        case           POINT_VALUE: return         PointValue.NaN;
        case     VECTOR_PATH_VALUE: return    VectorPathValue.NaN;
        case   VECTOR_VERTEX_VALUE: return  VectorVertexValue.NaN;
        case     VECTOR_EDGE_VALUE: return    VectorEdgeValue.NaN;
        case   VECTOR_REGION_VALUE: return  VectorRegionValue.NaN;
        case  VECTOR_NETWORK_VALUE: return VectorNetworkValue.NaN;
        case         BOOLEAN_VALUE: return  ShapeBooleanValue.NaN;
        case     SHAPE_GROUP_VALUE: return    ShapeGroupValue.NaN;
        case           FRAME_VALUE: return         FrameValue.NaN;
    }

    consoleError('cannot determine null value from type \'' + type + '\'');
}


class GOperator
extends GNode
{
    nodeId;
    nodeName;

    topLevel;

    value;

    options      = {};

    updateValues = [];

   
    
    constructor(type, nodeId, options)
    {
        super(type, options);

        this.nodeId   = nodeId;
        this.nodeName = options.nodeName;

        this.options  = clone(options);

        this.valid    = false;
        this.topLevel = false;

        this.value    = null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId   = base.nodeId;
        this.nodeName = base.nodeName;

        this.options  = clone(base.options);

        this.valid    = base.valid;
        this.topLevel = base.topLevel;

        if (base.value) 
            this.value = base.value.copy();
    }



    paramFromId(paramId)
    {
        return paramId == 'value'
            ?  this.value
            :  this[paramId];
    }



    isCached()
    {
        return this.options.cached
            && this.valid;
    }



    async eval(parse)
    {
        // calculate and add value update here

        return this;
    }



    async evalObjects(parse)
    {

    }



    copyObjects(value, listId = -1)
    {
        const objects = getValidObjects(value);
        const copies  = [];
                        
        for (let i = 0; i < objects.length; i++)//, o++)
        {
            const obj = copyFigmaObject(objects[i]);
    
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            obj.listId   = listId;
    
            copies.push(obj);
        }

        return copies;
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        //if (this.unknown)
            this.valid = false;

        this.iterated = false;
    }



    initLoop(parse, nodeId)
    {
        this.loopId    = nodeId;
        this.iteration = 0;
    }



    invalidateLoop(parse, nodeId)
    {
        this.valid = false;
    }



    iterateLoop(parse)
    {
        const repeatIndex = parse.repeats.findIndex(r => r.repeatId == this.loopId);
        
        if (   (   repeatIndex < 0
                || repeatIndex == parse.repeats.length-1)
            && !this.iterated)
        {
            this.iteration++;
            this.iterated = true;
        }
    }



    resetLoop(parse, nodeId)
    {
        this.valid     = false;
        this.iteration = 0;
    }    



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    setUpdateValues(parse, values, add = false)
    {
        // if (this.nodeId == 'num')
        // {
        //     console.log('parse.repeats.length =', parse.repeats.length);
        //     console.log('this.unknown =', this.unknown);

        //     if (parse.repeats.length > 0)
        //         console.log('parse.repeats[0].total == 0 =', parse.repeats[0].total == 0);

        //     console.log('parse.repeats.length =', parse.repeats.length);
            
        //     if (parse.repeats.length > 0)
        //         console.log('parse.repeats.at(-1) =', parse.repeats.at(-1));
        // }

        if (    parse.repeats.length == 0
            ||  this.unknown && parse.repeats[0].total == 0
            || !this.unknown
            ||  parse.repeats.at(-1).iteration == parse.repeats.at(-1).total-1)
        {
            // if (this.nodeId == 'num') console.log('1');
            // if (this.nodeId == 'num') console.log('values =', [...values]);
            if (add) this.updateValues.push(...values);
            else     this.updateValues = [...values];
        }
        else if (!add)
        {
            // if (this.nodeId == 'num') console.log('2');
            this.updateValues = [];
        }
    }



    pushValueUpdates(parse)
    {
        if (!this.updateValues)
            return;

        for (const value of this.updateValues)
            genPushUpdateValue(parse, this.nodeId, value[0], value[1]);

        if (this.isValid())
            this.updateValues = [];
    }



    updateValueObjects()
    {
        if (   !this.value
            || !this.value.objects)
            return;


        for (let i = 0; i < this.value.objects.length; i++)
        {
            const obj    = this.value.objects[i];

            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            obj.listId   = -1;
        }
    }
}


class GOperator1
extends GOperator
{
    input = null;



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input) this.input = base.input.copy();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GOperator2
extends GOperator
{
    input0 = null;
    input1 = null;



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input0) this.input0.invalidateInputs(parse, from);
        if (this.input1) this.input1.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
    }
}


class GParam
extends GOperator
{
    paramId;
    
    node;
    param;
    


    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    copy()
    {
        const copy = new GParam(this.nodeId, this.paramId);

        copy.copyBase(this);

        copy.node = this.node;
    
        return copy;
    }



    async eval(parse)
    {
        this.node = parse.parsedNodes.find(v => v.nodeId == this.nodeId);
        consoleAssert(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');


        await this.node.eval(parse);


        this.param = this.node.paramFromId(this.paramId);

        if (this.node.type == ITEMS)
            this.param = this.node[this.paramId];

        
        if (isValid(this.param))
        {
            const value = (await this.param.eval(parse)).toValue();
            this.value = value;
            
            return this.value;
        }
        else
            return this.value = NullValue.copy();
    }



    isCached()
    {
        return super.isCached();
//            && this.node.isCached();
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.node) this.node.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.node) this.node.invalidateInputs(parse, from);
    }



    initLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.initLoop(parse, nodeId);
    }



    invalidateLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.invalidateLoop(parse, nodeId);
    }



    iterateLoop(parse)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.resetLoop(parse, nodeId);
    }
}


class ListValue
extends GValue
{
    items;

    condensed = false;



    constructor(items = [])
    {
        super(LIST_VALUE);

        if (items)
        {
            this.items = [];

            for (const item of items)
            {
                this.items.push(item.copy());

                if (   this.objects
                    && item.objects)
                    this.objects.push(...item.objects.map(o => o.copy()));
            }
        }
    }



    copy()
    {
        const copy = new ListValue(this.items);

        copy.copyBase(this);

        copy.condensed = this.condensed;

        return copy;
    }



    equals(list)
    {
        if (!list)                                  return false;
        if (!(list instanceof ListValue))           return false;
        if (this.items.length != list.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(list.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        if (!this.items)
            return false;
            
        for (const item of this.items)
            if (!item.hasInitValue())
                return false;

        return true;
    }



    isValid()
    {
        //console.log('invalid =', this.items.find(i => !i.isValid()));
        return  this.items;
        //    && !this.items.find(i => !i.isValid());
    }



    toJson()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toJson();
        }


        return str;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        const nItems = Math.min(this.items.length, 10);


        let str = '';

        for (let i = 0; i < nItems; i++)
        {
            if (i > 0) 
                str += '<br/>';


            const item = this.items[i];

            if (LIST_VALUES.includes(item.type))
                // str += 'list [' + item.items.length + ']';
            {
                for (let j = 0; j < item.items.length; j++)
                {
                    if (j > 0) 
                        str += ', ';
                    
                    str += item.items[j].toPreviewString();
                }
            }
            else
                str += item.toPreviewString();
        }

        if (this.items.length > 10) 
            str += '<br/>. . .';
        
        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    getNaN()
    {
        return ListValue.NaN;
    }



    static NaN = Object.freeze(new ListValue(null));
}



function parseListValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        
    
    const iStart  = i;
    const nInputs = parseInt(str[i++]);
    
    
    const list = new ListValue();


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];

        switch (type)
        {
            case         LIST_VALUE:  
            case  NUMBER_LIST_VALUE:  
            case    TEXT_LIST_VALUE:  
            case   SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }
 
            case       NUMBER_VALUE: { const num     = parseNumberValue      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }
            case         TEXT_VALUE: { const text    = parseTextValue        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }
            case        COLOR_VALUE: { const color   = parseColorValue       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }

            case         FILL_VALUE: { const fill    = parseFillValue        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }
            case   COLOR_STOP_VALUE: { const stop    = parseColorStopValue   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }
            case     GRADIENT_VALUE: { const grad    = parseGradientValue    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }
            case       STROKE_VALUE: { const stroke  = parseStrokeValue      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }
            case  DROP_SHADOW_VALUE: { const shadow  = parseDropShadowValue  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case INNER_SHADOW_VALUE: { const shadow  = parseInnerShadowValue (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case   LAYER_BLUR_VALUE: { const blur    = parseLayerBlurValue   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case    BACK_BLUR_VALUE: { const blur    = parseBackBlurValue    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case   LAYER_MASK_VALUE: { const mask    = parseLayerMaskValue   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }

            case    RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }
            case         LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }
            case      ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }
            case      TRAPEZE_VALUE: { const trapeze = parseTrapezeValue     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }
            case      POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }
            case         STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }
            case   TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }
            case        POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }
            case  VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }
            case      BOOLEAN_VALUE: { const bool    = parseShapeBooleanValue(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }
            case  SHAPE_GROUP_VALUE: { const group   = parseShapeGroupValue  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }
            case        FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        list, 
        i - iStart];
}



function getItemTypes(items, debug)
{
    const types = [];

    for (const item of items)
    {
        if (   item.type ==        LIST_VALUE
            || item.type == NUMBER_LIST_VALUE
            || item.type ==   TEXT_LIST_VALUE
            || item.type ==  SHAPE_LIST_VALUE)
            pushUnique(types, finalListTypeFromItems(item.items, debug));

        else
            pushUnique(types, item.type);
    }

    return types;
}



function finalTypeFromItems(items)
{
    return finalTypeFromTypes(getItemTypes(items));
}



function finalListTypeFromItems(items)
{
    return finalListTypeFromTypes(getItemTypes(items));
}



function finalTypeFromTypes(types)
{
    let _type = NULL;


    for (const type of types)
    {
        if (_type == NULL)
            _type = type;

        else if (_type != type
                 &&  SHAPE_VALUES.includes(_type) 
                 && !SHAPE_VALUES.includes( type))
        { 
            _type = ANY_VALUE;
            break; 
        }
    }


    return _type;
}



function finalListTypeFromTypes(types)
{
    //console.log('types =', types);
    let _type = finalTypeFromTypes(types);
    
         if (  _type == NUMBER_VALUE || _type == NUMBER_LIST_VALUE)  return NUMBER_LIST_VALUE;
    else if (  _type ==   TEXT_VALUE || _type ==   TEXT_LIST_VALUE)  return   TEXT_LIST_VALUE;
    else if (SHAPE_VALUES.includes(_type))                           return  SHAPE_LIST_VALUE;
    else                                                             return        LIST_VALUE;
}


class NumberValue
extends GValue
{
    value;
    initValue;
    decimals;



    constructor(val = Number.NaN, dec = 0)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
            consoleError('NumberValue(value) is ' + typeof val + ', must be a number');


        this.value     = val;
        this.initValue = val;
        this.decimals  = dec;
    }



    static fromString(str)
    {
        return new NumberValue(
            parseFloat(str),
            decCount(str));
    }



    copy()
    {
        const copy = new NumberValue(
            this.value, 
            this.decimals);

        copy.initValue = this.initValue;

        copy.copyBase(this);

        return copy;
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.value == this.initValue;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    toInteger()
    {
        return new NumberValue(Math.round(this.value));
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals);
    }



    toPreviewString()
    {
        return this.isValid()
             ? numToString(this.value, this.decimals)
             : NAN_DISPLAY;
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? subscriptNumber(this.decimals)
                : '');
    }



    toJsCode(gen)
    {
        return this.toPreviewString();
    }



    getNaN()
    {
        return NumberValue.NaN;
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



const NullValue = Object.freeze(NumberValue.NaN);



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
    {
        console.trace();
        consoleError('number value \'' + str + '\' missing \',\'');
    }

    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == NAN_DISPLAY
        ? NumberValue.NaN
        : NumberValue.fromString(str);

    return [num, 1];
}


class TextValue
extends GValue
{
    value;
    initValue;



    constructor(val = '')
    {
        super(TEXT_VALUE);


        if (   val !== null
            && typeof val !== 'string')
        {
            console.trace();
            consoleError('TextValue('+val+') is ' + typeof val + ', must be a string');
        }

        
        this.value        = val;
        this.initValue    = val;

        // this.updateValues = [];
    }



    copy()
    {
        const copy = new TextValue(this.value);

        copy.initValue = this.initValue;
        
        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.value == text.value;
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        this.value == this.initValue;
    }



    isValid()
    {
        return this.value !== null;
    }



    toJson()
    {
        return encodeURIComponent(this.value);
    }



    toString()
    {
        return this.value;
    }



    toPreviewString()
    {
        const lines = this.value.split('\n');

        let str = '';

        for (let i = 0; i < Math.min(lines.length, 10); i++)
        {
            if (i > 0)
                str += '\n';

            str += lines[i];
        }

        if (lines.length > 10)
            str += '\n. . .';
        
        return str;
    }



    toDisplayString()
    {
        return '\'' 
             + this.value.replaceAll('\n', '↵')
             + '\'';
    }



    getNaN()
    {
        return TextValue.NaN;
    }



    static NaN = Object.freeze(new TextValue());
}



function parseTextValue(str)
{
    const text = new TextValue(decodeURIComponent(str));

    return [text, 1];
}


class ColorValue
extends GValue
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        consoleAssert(typeof space == 'number', 'ColorValue.create() space must be a number');
        consoleAssert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        consoleAssert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        consoleAssert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    static fromDataColor(_color, spaceIndex = -1)
    {
        if (spaceIndex < 0)
            spaceIndex = colorSpaceIndex (_color[0]);

        const space  = colorSpace(spaceIndex);
        const factor = colorSpaceFactor(space);

        return ColorValue.create(
            spaceIndex,
            _color[1] * factor[0],
            _color[2] * factor[1],
            _color[3] * factor[2]);
    }



    copy()
    {
        const copy = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.space.hasInitValue()
            && this.c1   .hasInitValue()
            && this.c2   .hasInitValue()
            && this.c3   .hasInitValue();
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    async eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        const space = this.space.copy();

        space.value = Math.round(Math.min(Math.max(0, space.value), ColorSpaces.length-1));

        return makeDataColor(
            space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toPreviewString()
    {
        return      this.space.toPreviewString()
            + ' ' + this.c1   .toPreviewString()
            + ' ' + this.c2   .toPreviewString()
            + ' ' + this.c3   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    toPreviewString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return '#' + rgb2hex(rgb);
    }



    toRgbString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    getNaN()
    {
        return ColorValue.NaN;
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart ];
}


class FillValue
extends GValue
{
    color;
    opacity;
    blend;



    constructor(color   = ColorValue.NaN, 
                opacity = new NumberValue(100),
                blend   = new NumberValue(0))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();
        this.blend   = blend  .copy();

        this.valid   = true;
    }


    
    static create(r, g, b, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    static fromRgb(rgb, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    copy()
    {
        const copy = new FillValue(
            this.color  .copy(),
            this.opacity.copy(),
            this.blend  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(fill)
    {
        return this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity)
            && this.blend  .equals(fill.blend  );
    }



    async eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString()
              + ' ' + this.blend             .toString();
    }



    toPreviewString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toPreviewString()
              + ' ' + new NumberValue(rgb[1]).toPreviewString()
              + ' ' + new NumberValue(rgb[2]).toPreviewString()
              + ' ' + this.opacity           .toPreviewString()
              + ' ' + this.blend             .toPreviewString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString()
              + ' ' + this.blend             .toDisplayString();
    }



    hasInitValue()
    {
        return this.color  .hasInitValue()
            && this.opacity.hasInitValue()
            && this.blend  .hasInitValue();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid()
            && this.blend  .isValid();
    }



    getNaN()
    {
        return FillValue.NaN;
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r  = parseNumberValue(str[i]); i += r [1];
    const g  = parseNumberValue(str[i]); i += g [1];
    const b  = parseNumberValue(str[i]); i += b [1];
    const a  = parseNumberValue(str[i]); i += a [1];
    const bl = parseNumberValue(str[i]); i += bl[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0], bl[0]),
        i - iStart ];
}






// async function evalFillValue(fillValue, parse)
// {
//     await fillValue.eval(parse);

//          if ( FILL_TYPES.includes(fillValue.type)) return fill;
//     else if (COLOR_TYPES.includes(fillValue.type)) return new FillValue(fill, fillValue.data.opacity);

//     else consoleError('fill must have type');
// }


class ColorStopValue
extends GValue
{
    fill;
    position;



    constructor(fill     = FillValue.NaN, 
                position = new NumberValue(1))
    {
        if (fill.type != FILL_VALUE)
            consoleError('fill.type is ' + fill.type + ', must be FILL_VALUE');


        super(COLOR_STOP_VALUE);

        this.fill     = fill    .copy();
        this.position = position.copy();

        this.valid    = true;
    }


    
    copy()
    {
        const copy = new ColorStopValue(
            this.fill    .copy(),
            this.position.copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.fill    .isValid()
            && this.position.isValid();
    }



    equals(stop)
    {
        return stop
            && this.fill    .equals(stop.fill    )
            && this.position.equals(stop.position);
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fill    .toString()
            + ' ' + this.position.toString();
    }



    toPreviewString()
    {
        return      this.fill    .toPreviewString()
            + ' ' + this.position.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fill    .toDisplayString()
            + ' ' + this.position.toDisplayString();
    }



    getNaN()
    {
        return ColorStopValue.NaN;
    }



    static NaN = Object.freeze(new ColorStopValue(
        FillValue  .NaN,
        NumberValue.NaN));
}



function parseColorStopValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ColorStopValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill     = parseFillValue  (str, i); i += fill    [1];
    const position = parseNumberValue(str[i]); i += position[1];


    return [
        new ColorStopValue(fill[0], position[0]),
        i - iStart ];
}


class GradientValue
extends GValue
{
    stops;
    gradType;
    x;
    y;
    size;
    angle;
    aspect;
    skew;
    blend;



    constructor(stops    = new ListValue(),
                gradType = new NumberValue(0),
                x        = new NumberValue(0),
                y        = new NumberValue(0),
                size     = new NumberValue(0),
                angle    = new NumberValue(0),
                aspect   = new NumberValue(0),
                skew     = new NumberValue(0),
                blend    = new NumberValue(0))
    {
        super(GRADIENT_VALUE);

        this.stops    = stops   .copy();
        this.gradType = gradType.copy();
        this.x        = x       .copy();
        this.y        = y       .copy();
        this.size     = size    .copy();
        this.angle    = angle   .copy();
        this.aspect   = aspect  .copy();
        this.skew     = skew    .copy();
        this.blend    = blend   .copy();

        this.valid = true;
    }


    
    copy()
    {
        const copy = new GradientValue(
            this.stops,
            this.gradType,
            this.x,
            this.y,
            this.size,
            this.angle,
            this.aspect,
            this.skew,
            this.blend);

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.stops   .isValid()
            && this.gradType.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.size    .isValid()
            && this.angle   .isValid()
            && this.aspect  .isValid()
            && this.skew    .isValid()
            && this.blend   .isValid();
    }



    equals(grad)
    {
        return grad
            && this.stops   .equals(grad.stops   )
            && this.gradType.equals(grad.gradType)
            && this.x       .equals(grad.x       )
            && this.y       .equals(grad.y       )
            && this.size    .equals(grad.size    )
            && this.angle   .equals(grad.angle   )
            && this.aspect  .equals(grad.aspect  )
            && this.skew    .equals(grad.skew    )
            && this.blend   .equals(grad.blend   );
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.stops   .toString()
            + ' ' + this.gradType.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.size    .toString()
            + ' ' + this.angle   .toString()
            + ' ' + this.aspect  .toString()
            + ' ' + this.skew    .toString()
            + ' ' + this.blend   .toString();
    }



    toPreviewString()
    {
        return      this.stops   .toPreviewString()
            + ' ' + this.gradType.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.size    .toPreviewString()
            + ' ' + this.angle   .toPreviewString()
            + ' ' + this.aspect  .toPreviewString()
            + ' ' + this.skew    .toPreviewString()
            + ' ' + this.blend   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.stops   .toDisplayString()
            + ' ' + this.gradType.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.size    .toDisplayString()
            + ' ' + this.angle   .toDisplayString()
            + ' ' + this.aspect  .toDisplayString()
            + ' ' + this.skew    .toDisplayString()
            + ' ' + this.blend   .toDisplayString();
    }



    getNaN()
    {
        return GradientValue.NaN;
    }



    static NaN = Object.freeze(new GradientValue(
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    // static default = Object.freeze(new StrokeValue(
    //     FillValue.create(0, 0, 0, 100),
    //     new NumberValue(1),
    //     new NumberValue(0),
    //     new NumberValue(0),
    //     new NumberValue(28.96)));
}



function parseGradientValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [GradientValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const stops    = parseListValue  (str, i); i += stops   [1];
    const gradType = parseNumberValue(str[i]); i += gradType[1];
    const x        = parseNumberValue(str[i]); i += x       [1];
    const y        = parseNumberValue(str[i]); i += y       [1];
    const size     = parseNumberValue(str[i]); i += size    [1];
    const angle    = parseNumberValue(str[i]); i += angle   [1];
    const aspect   = parseNumberValue(str[i]); i += aspect  [1];
    const skew     = parseNumberValue(str[i]); i += skew    [1];
    const blend    = parseNumberValue(str[i]); i += blend   [1];


    return [
        new GradientValue(stops[0], gradType[0], x[0], y[0], size[0], angle[0], aspect[0], skew[0], blend[0]),
        i - iStart ];
}


class StrokeValue
extends GValue
{
    fills;
    weight;
    fit;
    join;
    miter;
    cap;
    dashes;



    constructor(fills  = new ListValue(), 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2),
                cap    = new NumberValue(0),
                dashes = new TextValue())
    {
        if (fills.type != LIST_VALUE)
            consoleError('fill.type is ' + fills.type + ', must be LIST_VALUE');


        super(STROKE_VALUE);

        this.fills  = fills .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();
        this.cap    = cap   .copy();
        this.dashes = dashes.copy();

        this.valid  = true;
    }


    
    copy()
    {
        const copy = new StrokeValue(
            this.fills .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy(),
            this.cap   .copy(),
            this.dashes.copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.fills .hasInitValue()
            && this.weight.hasInitValue()
            && this.fit   .hasInitValue()
            && this.join  .hasInitValue()
            && this.miter .hasInitValue()
            && this.cap   .hasInitValue()
            && this.dashes.hasInitValue();
    }



    isValid()
    {
        return this.fills .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid()
            && this.cap   .isValid()
            && this.dashes.isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fills .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter )
            && this.cap   .equals(stroke.cap   )
            && this.dashes.equals(stroke.dashes);
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fills .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString()
            + ' ' + this.cap   .toString()
            + ' ' + this.dashes.toString();
    }



    toPreviewString()
    {
        return      this.fills .toPreviewString()
            + ' ' + this.weight.toPreviewString()
            + ' ' + this.fit   .toPreviewString()
            + ' ' + this.join  .toPreviewString()
            + ' ' + this.miter .toPreviewString()
            + ' ' + this.cap   .toPreviewString()
            + ' ' + this.dashes.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fills .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString()
            + ' ' + this.cap   .toDisplayString()
            + ' ' + this.dashes.toDisplayString();
    }



    getNaN()
    {
        return StrokeValue.NaN;
    }



    static NaN = Object.freeze(new StrokeValue(
        new ListValue(),
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        new TextValue()));



    static default = Object.freeze(new StrokeValue(
        new ListValue(),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96),
        new NumberValue(0),
        new TextValue()));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fills  = parseListValue  (str, i); i += fills [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];
    const cap    = parseNumberValue(str[i]); i += cap   [1];
    const dashes = parseTextValue  (str[i]); i += dashes[1];

    return [

        new StrokeValue(
            fills [0], 
            weight[0], 
            fit   [0], 
            join  [0], 
            miter [0], 
            cap   [0], 
            dashes[0]),
        
        i - iStart ];
}



class DropShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    behind;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                behind  = new NumberValue(0),
                visible = true)
    {
        super(DROP_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.behind  = behind;
        this.visible = visible;
        
        consoleAssert(fill.type == FILL_VALUE, 'fill.type must be FILL_VALUE');
    }


    
    // static create(x, y, blur, spread, fill, blend, behind)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new DropShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.behind.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.behind.equals(shadow.behind)
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString()
            + ' ' + this.behind.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString()
            + ' ' + this.behind.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString()
            + ' ' + this.behind.toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid()
            && this.behind.isValid();
    }



    getNaN()
    {
        return DropShadowValue.NaN;
    }



    static NaN = Object.freeze(new DropShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false));


    // static default = Object.freeze(DropShadowValue.create(217, 217, 217, 100));
}



function parseDropShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [DropShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];
    const behind = parseNumberValue(str[i]); i += behind[1];


    const shadow = new DropShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0],
        behind[0]);


    return [shadow, i - iStart];
}



class InnerShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                visible = true)
    {
        super(INNER_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new InnerShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid();
    }



    getNaN()
    {
        return InnerShadowValue.NaN;
    }



    static NaN = Object.freeze(new InnerShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        false));



    // static default = Object.freeze(InnerShadowValue.create(217, 217, 217, 100));
}



function parseInnerShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [InnerShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];


    const shadow = new InnerShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0]);


    return [shadow, i - iStart];
}



class LayerBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0), 
                visible = true)
    {
        super(LAYER_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new LayerBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return LayerBlurValue.NaN;
    }



    static NaN = Object.freeze(new LayerBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(LayerBlurValue.create(217, 217, 217, 100));
}



function parseLayerBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LayerBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new LayerBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class BackBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0),
                visible = true)
    {
        super(BACK_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new BackBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return BackBlurValue.NaN;
    }



    static NaN = Object.freeze(new BackBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(BackBlurValue.create(217, 217, 217, 100));
}



function parseBackBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [BackBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new BackBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class LayerMaskValue
extends GValue
{
    visible;



    constructor(visible = true)
    {
        super(LAYER_MASK_VALUE);

        this.visible = visible;
    }


    
    copy()
    {
        const copy = new LayerMaskValue(this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(mask)
    {
        return this.visible === mask.visible;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return 'mask';
    }



    toPreviewString()
    {
        return 'mask';
    }



    toDisplayString()
    {
        return 'mask';
    }



    isValid()
    {
        return super.isValid();
    }



    getNaN()
    {
        return LayerMaskValue.NaN;
    }



    static NaN = Object.freeze(new LayerMaskValue(false));
}



function parseLayerMaskValue(str)
{
    const mask = 
        str == NAN_DISPLAY
        ? LayerMaskValue.NaN
        : new LayerMaskValue(true);

    return [mask, 1];
}



/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeValue
extends GValue
{
    nodeId;

    props = null;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 

        this.objects = [];
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId  = base.nodeId;

        this.objects = base.objects.map(o => o.copy());

        if (base.props) this.props = base.props.copy();
    }



    hasInitValue()
    {
        return !this.props
            ||  this.props.hasInitValue();
    }



    isValid()
    {
        return !this.props
            ||  this.props.isValid();
    }
}



function parseShapeBaseValue(str, i, obj)
{
    const props = parseListValue(str, i); i += props[1];

    obj.props = props[0];

    return i;
}


class RectangleValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'rectangle';
            // + ' ' + this.x     .toPreviewString()
            // + ' ' + this.y     .toPreviewString()
            // + ' ' + this.width .toPreviewString()
            // + ' ' + this.height.toPreviewString()
            // + ' ' + this.round .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends ShapeValue
{
    x;
    y;
    width;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0))
    {
        super(LINE_VALUE, nodeId);

        this.x     = x;
        this.y     = y;
        this.width = width;
    }



    copy()
    {
        const copy = new LineValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.width.copy())

        copy.copyBase(this);

        return copy;
    }



    equals(line)
    {
        return line
            && this.x    .equals(line.x    )
            && this.y    .equals(line.y    )
            && this.width.equals(line.width);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.width.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.width.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.width.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.width.toDisplayString();
    }



    static NaN = new LineValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LineValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const width = parseNumberValue(str[i]); i += width[1];


    const line = new LineValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        width[0]);


    i = parseShapeBaseValue(str, i, line);

    
    return [line, i - iStart];
}



class EllipseValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    from;
    to;
    inner;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                from   = new NumberValue(0),
                to     = new NumberValue(0),
                inner  = new NumberValue(0))
    {
        super(ELLIPSE_VALUE, nodeId);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.from    = from;
        this.to      = to;
        this.inner   = inner;
    }



    copy()
    {
        const copy = new EllipseValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.from  .copy(),
            this.to    .copy(),
            this.inner .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(ellipse)
    {
        return ellipse
            && this.x     .equals(ellipse.x     )
            && this.y     .equals(ellipse.y     )
            && this.width .equals(ellipse.width )
            && this.height.equals(ellipse.height)
            && this.from  .equals(ellipse.from  )
            && this.to    .equals(ellipse.to    )
            && this.inner .equals(ellipse.inner );
    }



    async eval(parse)
    {
        return this;
    }
    
    
    
    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.from  .hasInitValue()
            && this.to    .hasInitValue()
            && this.inner .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.from  .isValid()
            && this.to    .isValid()
            && this.inner .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.from  .toString()
            + ' ' + this.to    .toString()
            + ' ' + this.inner .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'ellipse';
            // + ' ' + this.x     .toPreviewString()
            // + ' ' + this.y     .toPreviewString()
            // + ' ' + this.width .toPreviewString()
            // + ' ' + this.height.toPreviewString()
            // + ' ' + this.inner .toPreviewString() + '%'
            // + ' ' + this.from  .toPreviewString() + '°'
            // + ' ' + this.to    .toPreviewString() + '°';
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.from  .toDisplayString()
            + ' ' + this.to    .toDisplayString()
            + ' ' + this.inner .toDisplayString();
    }



    static NaN = new EllipseValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [EllipseValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const from   = parseNumberValue(str[i]); i += from  [1];
    const to     = parseNumberValue(str[i]); i += to    [1];
    const inner  = parseNumberValue(str[i]); i += inner [1];


    const ellipse = new EllipseValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        from  [0],
        to    [0],
        inner [0]);


    i = parseShapeBaseValue(str, i, ellipse);

    
    return [ellipse, i - iStart];
}



class TrapezeValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    bias;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0),
                bias   = new NumberValue(0))
    {
        super(TRAPEZE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
        this.bias   = bias;
    }



    copy()
    {
        const copy = new TrapezeValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy(),
            this.bias  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round )
            && this.bias  .equals(rect.bias  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + this.bias  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.width .toPreviewString()
            + ' ' + this.height.toPreviewString()
            + ' ' + this.round .toPreviewString()
            + ' ' + this.bias  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.bias  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue()
            && this.bias  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid()
            && this.bias  .isValid();
    }


    
    static NaN = new TrapezeValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTrapezeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TrapezeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const bias   = parseNumberValue(str[i]); i += bias  [1];


    const rect = new TrapezeValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        bias  [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class PolygonValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId,
                x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                width   = new NumberValue(0), 
                height  = new NumberValue(0), 
                round   = new NumberValue(0), 
                corners = new NumberValue(0))
    {
        super(POLYGON_VALUE, nodeId);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new PolygonValue(
            this.nodeId,
            this.x      .copy(), 
            this.y      .copy(), 
            this.width  .copy(), 
            this.height .copy(), 
            this.round  .copy(), 
            this.corners.copy());
    
        copy.copyBase(this);

        return copy;
    }



    equals(poly)
    {
        return poly
            && this.x      .equals(poly.x      )
            && this.y      .equals(poly.y      )
            && this.width  .equals(poly.width  )
            && this.height .equals(poly.height )
            && this.round  .equals(poly.round  )
            && this.corners.equals(poly.corners);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x      .hasInitValue()
            && this.y      .hasInitValue()
            && this.width  .hasInitValue()
            && this.height .hasInitValue()
            && this.round  .hasInitValue()
            && this.corners.hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x      .isValid()
            && this.y      .isValid()
            && this.width  .isValid()
            && this.height .isValid()
            && this.round  .isValid()
            && this.corners.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x      .toString()
            + ' ' + this.y      .toString()
            + ' ' + this.width  .toString()
            + ' ' + this.height .toString()
            + ' ' + this.round  .toString()
            + ' ' + this.corners.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x      .toPreviewString()
            + ' ' + this.y      .toPreviewString()
            + ' ' + this.width  .toPreviewString()
            + ' ' + this.height .toPreviewString()
            + ' ' + this.round  .toPreviewString()
            + ' ' + this.corners.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x      .toDisplayString()
            + ' ' + this.y      .toDisplayString()
            + ' ' + this.width  .toDisplayString()
            + ' ' + this.height .toDisplayString()
            + ' ' + this.round  .toDisplayString()
            + ' ' + this.corners.toDisplayString();
    }



    static NaN = new PolygonValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PolygonValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x       = parseNumberValue(str[i]); i += x      [1];
    const y       = parseNumberValue(str[i]); i += y      [1];
    const width   = parseNumberValue(str[i]); i += width  [1];
    const height  = parseNumberValue(str[i]); i += height [1];
    const round   = parseNumberValue(str[i]); i += round  [1];
    const corners = parseNumberValue(str[i]); i += corners[1];


    const poly = new PolygonValue(
        '', // set node ID elsewhere
        x      [0],
        y      [0],
        width  [0],
        height [0],
        round  [0],
        corners[0]);


    i = parseShapeBaseValue(str, i, poly);

    
    return [poly, i - iStart];
}



class StarValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    points;
    convex;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0), 
                points = new NumberValue(0),
                convex = new NumberValue(0))
    {
        super(STAR_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new StarValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy(), 
            this.points.copy(),
            this.convex.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(star)
    {
        return star
            && this.x     .equals(star.x     )
            && this.y     .equals(star.y     )
            && this.width .equals(star.width )
            && this.height.equals(star.height)
            && this.round .equals(star.round )
            && this.points.equals(star.points)
            && this.convex.equals(star.convex);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue()
            && this.points.hasInitValue()
            && this.convex.hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid()
            && this.points.isValid()
            && this.convex.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + this.points.toString()
            + ' ' + this.convex.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.width .toPreviewString()
            + ' ' + this.height.toPreviewString()
            + ' ' + this.round .toPreviewString()
            + ' ' + this.points.toPreviewString()
            + ' ' + this.convex.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.points.toDisplayString()
            + ' ' + this.convex.toDisplayString();
    }



    static NaN = new StarValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StarValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const points = parseNumberValue(str[i]); i += points[1];
    const convex = parseNumberValue(str[i]); i += convex[1];


    const star = new StarValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        points[0],
        convex[0]);


    i = parseShapeBaseValue(str, i, star);

    
    return [star, i - iStart];
}



class TextShapeValue
extends ShapeValue
{
    text;
    x;
    y;
    width;
    height;
    font;
    style;
    size;
    alignH;
    alignV;
    lineHeight;
    letterSpacing;

    

    constructor(nodeId,
                text          = new TextValue(),
                x             = new NumberValue(0), 
                y             = new NumberValue(0), 
                width         = new NumberValue(0), 
                height        = new NumberValue(0), 
                font          = new NumberValue(0),
                style         = new NumberValue(0),
                size          = new NumberValue(0),
                alignH        = new NumberValue(0),
                alignV        = new NumberValue(0),
                lineHeight    = new NumberValue(0),
                letterSpacing = new NumberValue(0))
    {
        super(TEXT_SHAPE_VALUE, nodeId);

        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignH        = alignH;
        this.alignV        = alignV;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        this.objects       = [];
    }



    copy()
    {
        const copy = new TextShapeValue(
            this.nodeId,
            this.text         .copy(),
            this.x            .copy(), 
            this.y            .copy(), 
            this.width        .copy(), 
            this.height       .copy(), 
            this.font         .copy(),
            this.style        .copy(),
            this.size         .copy(),
            this.alignH       .copy(),
            this.alignV       .copy(),
            this.lineHeight   .copy(),
            this.letterSpacing.copy()); 

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.text         .equals(text.text         )
            && this.x            .equals(text.x            )
            && this.y            .equals(text.y            )
            && this.width        .equals(text.width        )
            && this.height       .equals(text.height       )
            && this.font         .equals(text.font         )
            && this.style        .equals(text.style        )
            && this.size         .equals(text.size         )
            && this.alignH       .equals(text.alignH       )
            && this.alignV       .equals(text.alignV       )
            && this.lineHeight   .equals(text.lineHeight   )
            && this.letterSpacing.equals(text.letterSpacing);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.text         .hasInitValue()
            && this.x            .hasInitValue()
            && this.y            .hasInitValue()
            && this.width        .hasInitValue()
            && this.height       .hasInitValue()
            && this.font         .hasInitValue()
            && this.style        .hasInitValue()
            && this.size         .hasInitValue()
            && this.alignH       .hasInitValue()
            && this.alignV       .hasInitValue()
            && this.lineHeight   .hasInitValue()
            && this.letterSpacing.hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignH       .isValid()
            && this.alignV       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.text         .toJson() // otherwise the string can't contain another string
            + ' ' + this.x            .toString()
            + ' ' + this.y            .toString()
            + ' ' + this.width        .toString()
            + ' ' + this.height       .toString()
            + ' ' + this.font         .toString()
            + ' ' + this.style        .toString()
            + ' ' + this.size         .toString()
            + ' ' + this.alignH       .toString()
            + ' ' + this.alignV       .toString()
            + ' ' + this.lineHeight   .toString()
            + ' ' + this.letterSpacing.toString()
            + ' ' + super.toString();
        }



    toPreviewString()
    {
        return      this.text         .toJson() // otherwise the string can't contain another string
            + ' ' + this.x            .toPreviewString()
            + ' ' + this.y            .toPreviewString()
            + ' ' + this.width        .toPreviewString()
            + ' ' + this.height       .toPreviewString()
            + ' ' + this.font         .toPreviewString()
            + ' ' + this.style        .toPreviewString()
            + ' ' + this.size         .toPreviewString()
            + ' ' + this.alignH       .toPreviewString()
            + ' ' + this.alignV       .toPreviewString()
            + ' ' + this.lineHeight   .toPreviewString()
            + ' ' + this.letterSpacing.toPreviewString();
    }



    toDisplayString()
    {
        return      this.text         .toDisplayString()
            + ' ' + this.x            .toDisplayString()
            + ' ' + this.y            .toDisplayString()
            + ' ' + this.width        .toDisplayString()
            + ' ' + this.height       .toDisplayString()
            + ' ' + this.font         .toDisplayString()
            + ' ' + this.style        .toDisplayString()
            + ' ' + this.size         .toDisplayString()
            + ' ' + this.alignH       .toDisplayString()
            + ' ' + this.alignV       .toDisplayString()
            + ' ' + this.lineHeight   .toDisplayString()
            + ' ' + this.letterSpacing.toDisplayString();
    }



    toJson()
    {
        return      this.text         .toJson()
            + ' ' + this.x            .toJson()
            + ' ' + this.y            .toJson()
            + ' ' + this.width        .toJson()
            + ' ' + this.height       .toJson()
            + ' ' + this.font         .toJson()
            + ' ' + this.style        .toJson()
            + ' ' + this.size         .toJson()
            + ' ' + this.alignH       .toJson()
            + ' ' + this.alignV       .toJson()
            + ' ' + this.lineHeight   .toJson()
            + ' ' + this.letterSpacing.toJson();
    }



    static NaN = new TextShapeValue(
        '',
        TextValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTextShapeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TextShapeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const text          = parseTextValue  (str[i]); i += text         [1];
    const x             = parseNumberValue(str[i]); i += x            [1];
    const y             = parseNumberValue(str[i]); i += y            [1];
    const width         = parseNumberValue(str[i]); i += width        [1];
    const height        = parseNumberValue(str[i]); i += height       [1];
    const font          = parseNumberValue(str[i]); i += font         [1];
    const style         = parseNumberValue(str[i]); i += style        [1];
    const size          = parseNumberValue(str[i]); i += size         [1];
    const alignH        = parseNumberValue(str[i]); i += alignH       [1];
    const alignV        = parseNumberValue(str[i]); i += alignV       [1];
    const lineHeight    = parseNumberValue(str[i]); i += lineHeight   [1];
    const letterSpacing = parseNumberValue(str[i]); i += letterSpacing[1];


    const txts = new TextShapeValue(
        '', // set node ID elsewhere
        text         [0],
        x            [0],
        y            [0],
        width        [0],
        height       [0],
        font         [0],
        style        [0],
        size         [0],
        alignH       [0],
        alignV       [0],
        lineHeight   [0],
        letterSpacing[0]);


    i = parseShapeBaseValue(str, i, txts);

    
    return [txts, i - iStart];
}



class PointValue
extends GValue
{
    nodeId;

    x;
    y;

    sp0 = null; //  sp0 ------- sp1 
    sp1 = null; //   |
    sp2 = null; //  sp2



    constructor(nodeId,
                x = new NumberValue(0), 
                y = new NumberValue(0))
    {
        super(POINT_VALUE);

        this.nodeId  = nodeId;

        this.x       = x;
        this.y       = y;

        this.createDefaultSpace();
    }



    copy()
    {
        const copy = new PointValue(
            this.nodeId,
            this.x.copy(), 
            this.y.copy());

        copy.copyBase(this);

        copy.sp0 = clone(this.sp0);
        copy.sp1 = clone(this.sp1);
        copy.sp2 = clone(this.sp2);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x.equals(p.x)
            && this.y.equals(p.y);
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    static create(nodeId, x, y)
    {
        return new PointValue(
            nodeId,
            new NumberValue(x),
            new NumberValue(y));
    }



    static fromPoint(nodeId, p)
    {
        return new PointValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.x.hasInitValue()
            && this.y.hasInitValue();
    }



    isValid()
    {
        return this.x.isValid()
            && this.y.isValid();
    }



    toString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toString()
              + ' ' + this.y.toString()
            : NAN_DISPLAY;
    }



    toPreviewString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?   '(' + this.x.toPreviewString()
              + ', ' + this.y.toPreviewString()
              + ')'
            : NAN_DISPLAY;
    }



    toDisplayString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toDisplayString()
              + ' ' + this.y.toDisplayString()
            : NAN_DISPLAY;
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return PointValue.NaN;
    }



    static NaN = Object.freeze(new PointValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parsePointValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PointValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x = parseNumberValue(str[i]); i += x[1];
    const y = parseNumberValue(str[i]); i += y[1];


    const rect = new PointValue(
        '', // set node ID elsewhere
        x[0],
        y[0]);


    return [rect, i - iStart];
}



class VectorPathValue
extends ShapeValue
{
    points;
    closed;
    degree;
    winding;
    round;



    constructor(nodeId,
                points  = new ListValue(), 
                closed  = new NumberValue(0), 
                degree  = new NumberValue(0), 
                winding = new NumberValue(0), 
                round   = new NumberValue(0))
    {
        super(VECTOR_PATH_VALUE, nodeId);

        this.points  = points ?? new ListValue();
        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;
        this.round   = round;
    }



    copy()
    {
        const copy = new VectorPathValue(
            this.nodeId,
            this.points .copy(), 
            this.closed .copy(), 
            this.degree .copy(), 
            this.winding.copy(), 
            this.round  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.points .equals(rect.points )
            && this.closed .equals(rect.closed )
            && this.degree .equals(rect.degree )
            && this.winding.equals(rect.winding)
            && this.round  .equals(rect.round  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.points .toString()
            + ' ' + this.closed .toString()
            + ' ' + this.degree .toString()
            + ' ' + this.winding.toString()
            + ' ' + this.round  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.points .toPreviewString()
            + ' ' + this.closed .toPreviewString()
            + ' ' + this.degree .toPreviewString()
            + ' ' + this.winding.toPreviewString()
            + ' ' + this.round  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.points .toDisplayString()
            + ' ' + this.closed .toDisplayString()
            + ' ' + this.degree .toDisplayString()
            + ' ' + this.winding.toDisplayString()
            + ' ' + this.round  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.points .hasInitValue()
            && this.closed .hasInitValue()
            && this.degree .hasInitValue()
            && this.winding.hasInitValue()
            && this.round  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.points .isValid()
            && this.closed .isValid()
            && this.degree .isValid()
            && this.winding.isValid()
            && this.round  .isValid();
    }


    
    static NaN = new VectorPathValue(
        '',
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseVectorPathValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorPathValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const points  = parseListValue  (str, i); i += points [1];
    const closed  = parseNumberValue(str[i]); i += closed [1];
    const degree  = parseNumberValue(str[i]); i += degree [1];
    const winding = parseNumberValue(str[i]); i += winding[1];
    const round   = parseNumberValue(str[i]); i += round  [1];

    const path = new VectorPathValue(
        '', // set node ID elsewhere
        points [0],
        closed [0],
        degree [0],
        winding[0],
        round  [0]);


    i = parseShapeBaseValue(str, i, path);

    
    return [path, i - iStart];
}



class VectorVertexValue
extends GValue
{
    nodeId;

    x;
    y;
    join;
    cap;
    round;



    constructor(nodeId,
                x     = new NumberValue(0), 
                y     = new NumberValue(0),
                join  = new NumberValue(0),
                cap   = new NumberValue(0),
                round = new NumberValue(0))
    {
        super(VECTOR_VERTEX_VALUE);

        this.nodeId = nodeId;

        this.x      = x    .copy();
        this.y      = y    .copy();
        this.join   = join .copy();
        this.cap    = cap  .copy();
        this.round  = round.copy();
    }



    copy()
    {
        const copy = new VectorVertexValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.join .copy(), 
            this.cap  .copy(), 
            this.round.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x    .equals(p.x    )
            && this.y    .equals(p.y    )
            && this.join .equals(p.join )
            && this.cap  .equals(p.cap  )
            && this.round.equals(p.round);
    }



    static create(nodeId, x, y)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(x    ),
            new NumberValue(y    ),
            new NumberValue(join ),
            new NumberValue(cap  ),
            new NumberValue(round));
    }



    static fromPoint(nodeId, p)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y),
            new NumberValue(0),
            new NumberValue(0),
            new NumberValue(0));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.x    .hasInitValue()
            && this.y    .hasInitValue()
            && this.join .hasInitValue()
            && this.cap  .hasInitValue()
            && this.round.hasInitValue();
    }



    isValid()
    {
        return this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.join .toString()
            + ' ' + this.cap  .toString()
            + ' ' + this.round.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.join .toPreviewString()
            + ' ' + this.cap  .toPreviewString()
            + ' ' + this.round.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.join .toDisplayString()
            + ' ' + this.cap  .toDisplayString()
            + ' ' + this.round.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorVertexValue.NaN;
    }



    static NaN = Object.freeze(new VectorVertexValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parseVectorVertexValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorVertexValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const join  = parseNumberValue(str[i]); i += join [1];
    const cap   = parseNumberValue(str[i]); i += cap  [1];
    const round = parseNumberValue(str[i]); i += round[1];


    const point = new VectorVertexValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        join [0],
        cap  [0],
        round[0]);


    return [point, i - iStart];
}



class VectorEdgeValue
extends GValue
{
    nodeId;

    start;
    end;
    startTangent;
    endTangent;



    constructor(nodeId,
                start, 
                end,
                startTangent = PointValue.create(nodeId, 0, 0),
                endTangent   = PointValue.create(nodeId, 0, 0))
    {
        super(VECTOR_EDGE_VALUE);

        this.nodeId = nodeId;

        this.start        = start       .copy();       
        this.end          = end         .copy();         
        this.startTangent = startTangent.copy();
        this.endTangent   = endTangent  .copy();  
    }



    copy()
    {
        const copy = new VectorEdgeValue(
            this.nodeId,
            this.start       .copy(), 
            this.end         .copy(), 
            this.startTangent.copy(), 
            this.endTangent  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(edge)
    {
        return edge
            && this.start       .equals(edge.start       )
            && this.end         .equals(edge.end         )
            && this.startTangent.equals(edge.startTangent)
            && this.  endTangent.equals(edge.  endTangent);
    }



    static create(nodeId, start, end, startTangent, endTangent)
    {
        return new VectorEdgeValue(
            nodeId,
            start,
            end,
            PointValue.create(nodeId, startTangent.x, startTangent.y),
            PointValue.create(nodeId,   endTangent.x,   endTangent.y));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.start       .hasInitValue()
            && this.end         .hasInitValue()
            && this.startTangent.hasInitValue()
            && this.endTangent  .hasInitValue();
    }



    isValid()
    {
        return this.start       .isValid()
            && this.end         .isValid();
            // && this.startTangent.isValid()
            // && this.endTangent  .isValid();
    }



    toString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toPreviewString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toDisplayString()
    {
        return      this.start       .toDisplayString()
            + ' ' + this.end         .toDisplayString()
            + ' ' + this.startTangent.toDisplayString()
            + ' ' + this.endTangent  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN;
    }



    static NaN = Object.freeze(new VectorEdgeValue(
        '',
        VectorVertexValue.NaN, 
        VectorVertexValue.NaN, 
        PointValue.NaN, 
        PointValue.NaN));
}



function parseVectorEdgeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorEdgeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const start        = parseVectorVertexValue(str, i); i += start       [1];
    const end          = parseVectorVertexValue(str, i); i += end         [1];
    const startTangent = parsePointValue       (str, i); i += startTangent[1];
    const endTangent   = parsePointValue       (str, i); i +=   endTangent[1];


    const edge = new VectorEdgeValue(
        '', // set node ID elsewhere
        start       [0],
        end         [0],
        startTangent[0],
          endTangent[0]);


    return [edge, i - iStart];
}



class VectorRegionValue
extends ShapeValue
{
    loops;  
    winding;

    fills = [];



    constructor(nodeId,
                loops   = new ListValue(), 
                winding = new NumberValue(0))
    {
        super(VECTOR_REGION_VALUE, nodeId);

        this.loops   = loops;  
        this.winding = winding;
    }



    copy()
    {
        const copy = new VectorRegionValue(
            this.nodeId,
            this.loops  .copy(), 
            this.winding.copy());

        copy.fills = clone(this.fills);
        
        copy.copyBase(this);

        return copy;
    }



    equals(region)
    {
        return region
            && this.loops  .equals(region.loops  )
            && this.winding.equals(region.winding);
    }



    // static create(nodeId, loops, winding, props)
    // {
    //     return new VectorRegionValue(
    //         nodeId,
    //         loops,
    //         new NumberValue(winding));
    // }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.loops  .hasInitValue()
            && this.winding.hasInitValue();
    }



    isValid()
    {
        return this.loops  .isValid()
            && this.winding.isValid();
    }



    toString()
    {
        return      this.loops  .toString()
            + ' ' + this.winding.toString();
    }



    toPreviewString()
    {
        return      this.loops  .toPreviewString()
            + ' ' + this.winding.toPreviewString();
    }



    toDisplayString()
    {
        return      this.loops  .toDisplayString()
            + ' ' + this.winding.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN;
    }



    static NaN = Object.freeze(new VectorRegionValue(
        '',
        ListValue  .NaN, 
        NumberValue.NaN));
}



function parseVectorRegionValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorRegionValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const loops   = parseListValue  (str, i); i += loops  [1];
    const winding = parseNumberValue(str[i]); i += winding[1];


    const region = new VectorRegionValue(
        '', // set node ID elsewhere
        loops  [0],
        winding[0]);


    i = parseShapeBaseValue(str, i, region);


    return [region, i - iStart];
}



class VectorNetworkValue
extends GValue
{
    nodeId;

    regions;



    constructor(nodeId,
                regions = new ListValue())
    {
        super(VECTOR_NETWORK_VALUE);

        this.nodeId  = nodeId;

        this.regions = regions; 
    }



    copy()
    {
        const copy = new VectorNetworkValue(
            this.nodeId,
            this.regions.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(region)
    {
        return region
            && this.regions.equals(region.regions);
    }



    static create(nodeId, regions)
    {
        return new VectorNetworkValue(
            nodeId,
            regions);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.regions.hasInitValue();
    }



    isValid()
    {
        return this.regions.isValid();
    }



    toString()
    {
        return this.regions.toString();
    }



    toPreviewString()
    {
        return this.regions.toPreviewString();
    }



    toDisplayString()
    {
        return this.regions.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorNetworkValue.NaN;
    }



    static NaN = Object.freeze(new VectorNetworkValue(
        '',
        ListValue.NaN));
}



function parseVectorNetworkValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorNetworkValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const regions = parseListValue(str, i); i += regions[1];


    const net = new VectorNetworkValue(
        '', // set node ID elsewhere
        regions[0]);


    return [net, i - iStart];
}



class ShapeBooleanValue
extends ShapeValue
{
    operation;
    children;



    constructor(nodeId, operation, children)
    {
        super(BOOLEAN_VALUE, nodeId);

        this.operation = operation;
        this.children  = children;

        this.objects = 
            children.objects
            ? children.objects.map(o => o.copy())
            : null;
    }



    copy()
    {
        const copy = new ShapeGroupValue(
            this.nodeId,
            this.operation.copy(),
            this.children .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(bool)
    {
        return bool
            && this.operation.equals(bool.operation)
            && this.children .equals(bool.children );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.operation.toString()
            + ' ' + this.children .toString();
    }



    toPreviewString()
    {
        return      this.operation.toPreviewString()
            + ' ' + this.children .toPreviewString();
    }



    toDisplayString()
    {
        return      this.operation.toDisplayString()
            + ' ' + this.children .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.operation.isValid()
            && this.children .isValid();
    }


    
    static NaN = new ShapeBooleanValue(
        '',
        NumberValue.NaN,
        ListValue  .NaN);
}



function parseShapeBooleanValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ShapeBooleanValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const operation = parseNumberValue(str[i]); i += operation[1];
    const children  = parseListValue  (str, i); i += children [1];

    const bool = new ShapeBooleanValue(
        '', // set node ID elsewhere
        operation[0],
        children [0]);


    i = parseShapeBaseValue(str, i, bool);

    
    return [bool, i - iStart];
}



class ShapeGroupValue
extends GValue
{
    items = [];



    constructor(nodeId, items = [])
    {
        super(SHAPE_GROUP_VALUE, nodeId);

        this.items = items;

        //this.objects = children.objects.map(o => o.copy());
    }



    copy()
    {
        const copy = new ShapeGroupValue(
            this.nodeId,
            this.items.map(i => i.copy()));

        copy.copyBase(this);

        return copy;
    }



    equals(group)
    {
        if (!group)                                  return false;
        if (!(group instanceof ShapeGroupValue))     return false;
        if (this.items.length != group.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(group.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toPreviewString();
        }


        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return  this.items
            && !this.items.find(i => !i.isValid());
    }


    
    static NaN = new ShapeGroupValue(
        '',
        ListValue.NaN);
}



function parseShapeGroupValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const group = new ShapeGroupValue();
    

    const nInputs = parseInt(str[i++]);


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];
        
        switch (type)
        {
            case         LIST_VALUE:  
            // case  NUMBER_LIST_VALUE:  
            // case    TEXT_LIST_VALUE:  
            case   SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }
 
            // case       NUMBER_VALUE: { const num     = parseNumberValue      (str[i]);  i += num    [1];  group.items.push(num    [0]);  break; }
            // case         TEXT_VALUE: { const text    = parseTextValue        (str[i]);  i += text   [1];  group.items.push(text   [0]);  break; }
            // case        COLOR_VALUE: { const color   = parseColorValue       (str, i);  i += color  [1];  group.items.push(color  [0]);  break; }

            // case         FILL_VALUE: { const fill    = parseFillValue        (str, i);  i += fill   [1];  group.items.push(fill   [0]);  break; }
            // case       STROKE_VALUE: { const stroke  = parseStrokeValue      (str, i);  i += stroke [1];  group.items.push(stroke [0]);  break; }
            // case  DROP_SHADOW_VALUE: { const shadow  = parseDropShadowValue  (str, i);  i += shadow [1];  group.items.push(shadow [0]);  break; }
            // case INNER_SHADOW_VALUE: { const shadow  = parseInnerShadowValue (str, i);  i += shadow [1];  group.items.push(shadow [0]);  break; }
            // case   LAYER_BLUR_VALUE: { const blur    = parseLayerBlurValue   (str, i);  i += blur   [1];  group.items.push(blur   [0]);  break; }
            // case    BACK_BLUR_VALUE: { const blur    = parseBackBlurValue    (str, i);  i += blur   [1];  group.items.push(blur   [0]);  break; }
            // case   LAYER_MASK_VALUE: { const mask    = parseLayerMaskValue   (str[i]);  i += mask   [1];  group.items.push(mask   [0]);  break; }

            case    RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }
            case         LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }
            case      ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case      TRAPEZE_VALUE: { const ellipse = parseTrapezeValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case      POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }
            case         STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }
            case   TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }
            case        POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }
            case  VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case      BOOLEAN_VALUE: { const path    = parseShapeBooleanValue(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case  SHAPE_GROUP_VALUE: { const _group  = parseShapeGroupValue  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }
            case        FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        group, 
        i - iStart];
}



class FrameValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    children;



    constructor(nodeId, x, y, width, height, round, children)
    {
        super(FRAME_VALUE, nodeId);

        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.children = children;

        this.objects = 
               children
            && children.objects 
            ? children.objects.map(o => o.copy()) 
            : [];
    }



    copy()
    {
        const copy = new FrameValue(
            this.nodeId,
            this.x       .copy(),
            this.y       .copy(),
            this.width   .copy(),
            this.height  .copy(),
            this.round   .copy(),
            this.children.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(frame)
    {
        return frame
            && this.x       .equals(frame.x       )
            && this.y       .equals(frame.y       )
            && this.width   .equals(frame.width   )
            && this.height  .equals(frame.height  )
            && this.round   .equals(frame.round   )
            && this.children.equals(frame.children);
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.children.toString();
    }



    toPreviewString()
    {
        return      this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.width   .toPreviewString()
            + ' ' + this.height  .toPreviewString()
            + ' ' + this.round   .toPreviewString()
            + ' ' + this.children.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.children.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.children.isValid()
            && super.isValid();
    }


    
    static NaN = new FrameValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        ListValue  .NaN);
}



function parseFrameValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [FrameValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x        = parseNumberValue(str[i]); i += x      [1];
    const y        = parseNumberValue(str[i]); i += y      [1];
    const width    = parseNumberValue(str[i]); i += width  [1];
    const height   = parseNumberValue(str[i]); i += height [1];
    const round    = parseNumberValue(str[i]); i += round  [1];
    const children = parseListValue  (str, i); i += children[1];

    const frame = new FrameValue(
        '', // set node ID elsewhere
        x       [0],
        y       [0],
        width   [0],
        height  [0],
        round   [0],
        children[0]);


    i = parseShapeBaseValue(str, i, frame);

    
    return [frame, i - iStart];
}



class GStart
extends GOperator
{
    input    = null;

    feedback = null;
    from     = null;

    loopId   = NULL;

    

    constructor(nodeId, options)
    {
        super(START, nodeId, options);
    }


    
    copy()
    {
        const copy = new GStart(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value   ) copy.value    = this.value   .copy();
        if (this.input   ) copy.input    = this.input   .copy();
        if (this.feedback) copy.feedback = this.feedback.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const feedback = this.feedback ? (await this.feedback.eval(parse)).toValue() : null;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;


        this.setUpdateValues(parse, 
        [
            ['feedback', feedback]
        ]);


        await this.evalObjects(parse, {feedback: feedback.value > 0});

        
        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);


        this.updateObjects(
               this.from
            && repeat
            && repeat.iteration > 0
            && options.feedback
            ? this.from.iterationObjects 
            : (   this.input 
               && this.input.value.objects 
               ? this.input.value.objects 
               : []),
            repeat 
            ? repeat.iteration.toString()
            : '');

        this.from = null;

        
        await super.evalObjects(parse);
    }



    updateObjects(objects, iteration)
    {
        if (!this.value.isValid())
            return;
            
        this.value.objects = objects.map(o => o.copy());

        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        }
    }
    

    
    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input    && this.input   .isValid()
            && this.feedback && this.feedback.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input   ) this.input   .pushValueUpdates(parse);
        if (this.feedback) this.feedback.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.from = from;

        if (this.input   ) this.input   .invalidateInputs(parse, from);
        if (this.feedback) this.feedback.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input   ) this.input   .iterateLoop(parse);
        if (this.feedback) this.feedback.iterateLoop(parse);
    }
}



class GRepeat
extends GOperator1
{
    count = null;
   _while = null;
    loop  = null;

    iterationObjects = [];



    constructor(nodeId, options)
    {
        super(REPEAT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRepeat(this.nodeId, this.options);

        copy.copyBase(this);

        copy. value = this. value.copy();
        copy. count = this. count.copy();
        copy._while = this._while.copy();
        copy. loop  = this. loop .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        let   count = (await this.count.eval(parse)).toValue();
        let  _while = new NumberValue(1);
        const loop  = (await this.loop.eval(parse)).toValue();


        count = 
            count
            ? new NumberValue(Math.round(count.value))
            : new NumberValue(0);


        if (this.loop.type != NUMBER_VALUE) assertVolatile(this.loop, this);


        this.value = new ListValue();
        this.value.objects = [];


        if (count.value > 0)
        {
            if (this.input)
                //&& this.input.isValid())
            {
                const startTime    = Date.now();
                let   showProgress = false;


                const nRepeats = 
                       this.options.enabled 
                    && (   this.options.active
                        || this.options.beforeActive)
                    ? count.value 
                    : 0;
                

                let repeat =
                {
                    repeatId:  this.nodeId,
                    iteration: 0,
                    total:     nRepeats
                };

                    
                parse.repeats.push(repeat);

                if (parse.repeats.length == 1)
                    parse.totalProgress += nRepeats;


                if (this.loop.type != NUMBER_VALUE) 
                    this.loop.initLoop(parse, this.nodeId);


                for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)
                {
                    //console.log('repeat');
                    _while = (await this._while.eval(parse)).toValue();

                    if (_while.value == 0)
                        break;


                    if (  !showProgress
                        && Date.now() - startTime > 50)
                    {
                        genInitNodeProgress(this.nodeId);
                        showProgress = true;
                    }


                    repeat.iteration = i;

                    this.input.invalidateInputs(parse, this);
                    

                    const input = (await this.input.eval(parse)).toValue();


                    if (   input
                        && nRepeats > 0)
                    {
                        this.value.items.push(input.copy());


                        this.iterationObjects = [];
                    
                        if (this.input.value.objects)
                        {
                            for (let j = 0; j < this.input.value.objects.length; j++, o++)
                            {
                                const obj = copyFigmaObject(this.input.value.objects[j]);

                                this.iterationObjects.push(obj.copy());

                                obj.nodeId      = this.nodeId;
                                obj.listId      = i;

                                obj.objectId    = obj.objectId + OBJECT_SEPARATOR + this.nodeId + ':' + (o+1).toString();
                                obj.objectName += ' ' + (o+1).toString();

                                if (this.value.objects)
                                    this.value.objects.push(obj);
                            }
                        }
                    }


                    this.input.iterateLoop(parse);


                    if (parse.repeats.length == 1)
                    {
                        parse.currentProgress++;
                        
                        const stopRequestId = await genGetValueFromUi('stopRequestId');

                        if (   parse.requestId == stopRequestId.value
                            || curRequestIds.includes(parse.requestId)) 
                        { 
                            parse.stopGenerate = true;
                            break; 
                        }
                    }


                    if (showProgress)
                        genUpdateNodeProgress(parse, this.nodeId, i / nRepeats);
                }


                if (this.loop.type != NUMBER_VALUE)
                    this.loop.resetLoop(parse, this.nodeId);


                if (this.startTimer > -1)
                {
                    clearTimeout(this.startTimer);
                    this.startTimer = -1;
                }


                genEndNodeProgress(this.nodeId);


                consoleAssert(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');
                parse.repeats.pop();
            }
            else if (this.input)
                await this.input.eval(parse);
        }
        else
        {
            if (this.input)
                await this.input.eval(parse);
        }


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type',  type ],
            ['count', count]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this. count && this. count.isValid()
            && this._while && this._while.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this. count) this. count.pushValueUpdates(parse);
        if (this._while) this._while.pushValueUpdates(parse);
        if (this. loop ) this. loop .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this. count) this. count.invalidateInputs(parse, from);
        if (this._while) this._while.invalidateInputs(parse, from);
        if (this. loop ) this. loop .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this. count) this. count.iterateLoop(parse);
        if (this._while) this._while.iterateLoop(parse);
        if (this. loop ) this. loop .iterateLoop(parse);
    }
}



function assertVolatile(loop, node)
{
    consoleAssert(
           loop.type == DEFINE
        || loop.type == FREEZE
        || loop.type == NUMBER_RANGE
        || loop.type == NUMBER_SEQUENCE
        || loop.type == NUMBER_RANDOM
        || loop.type == NUMBER_NOISE
        || loop.type == NUMBER_PROBABILITY
        || loop.type == LIST
        || loop.type == PARAM, // for OpStart
        'only volatile types can be repeated');
}


class GNull
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(NULL_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNull(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.input) copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}



class GCache
extends GOperator1
{
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(CACHE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCache(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.cachedValue)
            this.value = this.cachedValue.copy();

        else
        {
            this.value = 
                this.input 
                ? (await this.input.eval(parse)).toValue() 
                : NullValue;

            this.cachedValue = this.value.copy();
        }


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.cachedValue = null;
    }



    // iterateLoop(parse)
    // {
    //     super.iterateLoop(parse);

    //     this.cachedValue = null;
    // }
}



class GFreeze
extends GOperator1
{
    frozen = false;

    loopId  = NULL;



    constructor(nodeId, options)
    {
        super(FREEZE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GFreeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);

        if (      repeat
               && repeat.iteration == 0
            || !this.options.enabled)
            this.frozen = false;


        if (!this.frozen)
        {
            this.value = 
                this.input 
                ? (await this.input.eval(parse)).toValue()
                : NullValue;

            this.frozen = true;

            this.updateValueObjects();
        }


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type],
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}



class GTimer
extends GOperator
{
    input = null;

    delay = null;



    constructor(nodeId, options)
    {
        super(TIMER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTimer(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.delay) copy.delay = this.delay.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const delay = (await this.delay.eval(parse)).toValue();
            

        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            this.value = input ? input : NullValue;
        }
        else
            this.value = NullValue.copy();
            

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['delay', delay     ]
        ]);

        
        this.updateValueObjects();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.delay && this.delay.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.delay) this.delay.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.delay) this.delay.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.delay) this.delay.iterateLoop(parse);
    }
}



class GValueName
extends GOperator
{
    input = null;

    name  = null;



    constructor(nodeId, options)
    {
        super(VALUE_NAME, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNull(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.input) copy.input = this.input.copy();
        if (this.name ) copy.name  = this.name .copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;

        
        const name = (await this.name.eval(parse)).toValue();

        if (this.value.isValid())
            this.value.valueId = name.value;


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type],
            ['name', name]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.name  && this.name .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.name ) this.name .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.name ) this.name .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.name ) this.name .iterateLoop(parse);
    }
}



class GList
extends GOperator
{
    inputs = [];

    value;



    constructor(nodeId, options)
    {
        super(LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GList(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());
        copy.value  = this.value.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        this.value.objects = [];


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);
            
            
            // first copy the input objects
            // to display when list is the active node

            // if (   this.options.enabled
            //     && this.inputs[i].value)
            // {
            //     const objects = getValidObjects(this.inputs[i].value);
                
            //     for (let j = 0; j < objects.length; j++, o++)
            //     {
            //         const obj = objects[j];//copyFigmaObject(objects[j]);

            //         obj.nodeId   = this.nodeId;
            //         obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            //         obj.listId   = i;

            //         //this.value.objects.push(obj);
            //     }
            // }


            // now create the output value

            const input = this.inputs[i].toValue();


            if (   input
                && this.options.enabled)
            {
                if (LIST_VALUES.includes(input.type))
                {
                    if (input.condensed === true)
                        this.value.items.push(input.copy());
                    else
                    {
                        for (const item of input.items)
                            this.value.items.push(item.copy());   
                    }
                }
                else
                    this.value.items.push(input.copy());
            }


            this.value.objects.push(...this.copyObjects(input, i));
        }


        // reset object space

        const bounds = getObjBounds(this.value.objects);

        const singlePoint =
               this.value.objects.length  == 1 
            && this.value.objects[0].type == POINT;


        for (const obj of this.value.objects)
        {
            obj.createDefaultSpace(obj.sp0.x, obj.sp0.y);
            obj.resetSpace(bounds, singlePoint);
        }


        const preview = new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)));
        const length  = new NumberValue(this.value.items.length);
        const type    = new TextValue(finalListTypeFromItems(this.value.items));

        
        this.setUpdateValues(parse,
        [
            ['preview', preview],
            ['length',  length ],
            ['type',    type   ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    initLoop(parse, loopId)
    {
        this.inputs.forEach(i => i.initLoop(parse, loopId));
    }



    invalidateLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.invalidateLoop(parse, nodeId));
    }



    iterateLoop(parse)
    {
        this.inputs.forEach(i => i.iterateLoop(parse));
    }



    resetLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.resetLoop(parse, nodeId));
    }
}


class GCondense
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(CONDENSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondense(this.nodeId, this.options);

        copy.copyBase(this);

        //copy.value  = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();
        this.value.condensed = true;

        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            length = input.items.length;
               
                
            if (input)
            {
                if (   LIST_VALUES.includes(input.type)
                    && this.options.enabled)
                {
                    for (const item of input.items)
                    {
                        const copy = item.copy();

                        this.value.items.push(copy);
                        //this.value.objects.push(...copy.objects);
                    }
                }
                else
                {
                    const copy = input.copy();

                    this.value.items.push(copy);
                    this.value.objects.push(...copy.objects);
                }
            }
        }


        this.updateValueObjects();
    

        this.setUpdateValues(parse,
        [
            ['length', new NumberValue(length)                              ],
            ['type', new TextValue(finalListTypeFromItems(this.value.items))]
        ]);
        

        this.validate();

        return this;
    }
}



class GSublist
extends GOperator1
{
    start;
    end;


    
    constructor(nodeId, options)
    {
        super(SUBLIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSublist(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start) copy.start = this.start.copy();
        if (this.end  ) copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = this.start ? (await this.start.eval(parse)).toValue() : null;
        const end   = this.end   ? (await this.end  .eval(parse)).toValue() : null;


        this.value = new ListValue();

        let length = 0;
        

        if (   this.input
            && start
            && end)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (   input
                && input.items)
            {
                length = input.items.length;


                const _end =
                    end.isValid()
                    ? end
                    : new NumberValue(input.items.length);


                if (start.value < _end.value)
                {
                    if (this.options.enabled)
                    {
                        for (let i = start.value; i < _end.value; i++)
                        {
                            const item = input.items[i];
                            
                            this.value.items.push(item ? item.copy() : NullValue);
                            
                            if (   item
                                && this.value.objects) 
                                this.value.objects.push(...input.items[i].objects);
                        }
                    }
                    else
                        this.value = input.copy();
                }
            }
            else
                this.value = ListValue.NaN.copy();
        }


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview',    new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['type',       type                                                                           ],
            ['length',     new NumberValue(this.value.items.length)                                                        ], // used to set start and end maxima
            ['fullLength', new NumberValue(length)                                                        ], // used to set start and end maxima
            ['start',      start                                                                          ],
            ['end',        end                                                                            ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.end  ) this.end  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GUnique
extends GOperator1
{
    counts = null;


    
    constructor(nodeId, options)
    {
        super(UNIQUE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GUnique(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = this.input ? (await this.input.eval(parse)).toValue() : null;


        this.counts = new ListValue();


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item       = input.items[i];
                    const foundIndex = this.value.items.findIndex(i => i.equals(item));

                    if (foundIndex < 0)
                    {
                        this.value.items.push(item.copy());
                        this.value.objects.push(...item.objects);

                        this.counts.items.push(new NumberValue(1));
                    }
                    else
                        this.counts.items[foundIndex].value++;
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new ListValue();//TextValue.NaN;


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)))],
            ['type',    type                                                                           ],
            ['length',  new NumberValue(this.value.items.length)                                       ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.counts && this.counts.isValid();
    }
}



class GReverseList
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(REVERSE_LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GReverseList(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = this.input ? (await this.input.eval(parse)).toValue() : null;


        this.counts = new ListValue();


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();

                for (let i = input.items.length-1; i >= 0; i--)
                {
                    this.value.items.push(input.items[i].copy());
                    this.value.objects.push(...input.items[i].objects);
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = ListValue.NaN.copy();


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;

        this.setUpdateValues(parse, 
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)))],
            ['type',    type                                                                           ],
            ['length', new NumberValue(this.value.items.length)                                        ]
        ]); 
               

        this.validate();

        return this;
    }
}



class GSort
extends GOperator1
{
    column  = null;
    reverse = null;


    
    constructor(nodeId, options)
    {
        super(SORT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSort(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.column ) copy.column  = this.column .copy();
        if (this.reverse) copy.reverse = this.reverse.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const column  = this.column  ? (await this.column .eval(parse)).toValue() : null;
        const reverse = this.reverse ? (await this.reverse.eval(parse)).toValue() : null;

        
        this.value = new ListValue();

        let maxColumns = 0;

        
        if (   this.input
            && column
            && reverse)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            const sortMultiplier = reverse.value > 0 ? -1 : 1;

            input.items.sort((a, b) => 
            {
                const ca = a ? (LIST_VALUES.includes(a.type) ? a.items[column.value].value : a.value) : 0;
                const cb = b ? (LIST_VALUES.includes(b.type) ? b.items[column.value].value : b.value) : 0;

                if (ca < cb) return -1 * sortMultiplier;
                if (ca > cb) return  1 * sortMultiplier;

                return 0;
            });


            input.items.forEach(i => maxColumns = Math.max(maxColumns, LIST_VALUES.includes(i.type) ? i.items.length : 1));

            for (let i = 0; i < input.items.length; i++)
            {
                const row = input.items[i];
                this.value.items.push(row.copy());

                if (   row.objects
                    && this.value.objects)
                    this.value.objects.push(...row.objects);
            }
        }


        const preview = new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)));

        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', preview                                 ],
            ['type',    type                                    ],
            ['length',  new NumberValue(this.value.items.length)],
            ['columns', new NumberValue(maxColumns)             ],
            ['column',  column                                  ],
            ['reverse', reverse                                 ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.column  && this.column .isValid()
            && this.reverse && this.reverse.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.column ) this.column .pushValueUpdates(parse);
        if (this.reverse) this.reverse.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.column ) this.column .invalidateInputs(parse, from);
        if (this.reverse) this.reverse.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.column ) this.column .iterateLoop(parse);
        if (this.reverse) this.reverse.iterateLoop(parse);
    }
}


class GColumn
extends GOperator1
{
    index;


    
    constructor(nodeId, options)
    {
        super(COLUMN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColumn(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.index) copy.index = this.index.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const index = (await this.index.eval(parse)).toValue();

        
        this.value = new ListValue();

        let maxColumns = 0;


        if (   this.input
            && index)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (isTable(input))
            {
                input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));

                if (index.value < maxColumns)
                {
                    for (let i = 0; i < input.items.length; i++)
                    {
                        const row = input.items[i];

                        if (index.value < row.items.length)
                        {
                            this.value.items.push(row.items[index.value].copy());

                            if (   this.value.objects 
                                && row.items[index.value].objects)
                                this.value.objects.push(...row.items[index.value].objects);
                        }
                    }
                }
            }
            else if (LIST_VALUES.includes(input.type))
                this.value = input.copy();
        }


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['type',    type                                                                           ],
            ['length',  new NumberValue(this.value.items.length)                                       ],
            ['columns', new NumberValue(maxColumns)                                                    ],
            ['index',   index                                                                          ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.index) this.index.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
    }
}



function isTable(value)
{
    if (!LIST_VALUES.includes(value.type))
        return false;

    for (const item of value.items)
    {
        if (!LIST_VALUES.includes(item.type))
            return false;
    }

    return true;
}


class GCell
extends GOperator
{
    column;
    row;


    
    constructor(nodeId, options)
    {
        super(CELL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCell(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.column) copy.column = this.column.copy();
        if (this.row   ) copy.row    = this.row   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const column = this.column ? (await this.column.eval(parse)).toValue() : null;
        const row    = this.row    ? (await this.row   .eval(parse)).toValue() : null;


        let columns = 0;
        let rows    = 0;

        if (   this.input
            && column
            && row)
        {
            const input = this.input ? (await this.input.eval(parse)).toValue() : null;

            
            if (   input
                && isTable(input))
            {
                rows = input.items.length;

                input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));

                if (row.value < rows)
                {
                    const _row = input.items[row.value];

                    if (column.value < columns)
                        this.value = _row.items[column.value].copy()
                    else
                        this.value = NullValue.copy();
                }
                else
                    this.value = NullValue.copy();
            }
            else
                this.value = NullValue.copy();
        }
        else
            this.value = NullValue.copy();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', this.value              ],
            ['type',    type                    ],
            ['columns', new NumberValue(columns)],
            ['rows',    new NumberValue(rows   )]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.column && this.column.isValid()
            && this.row    && this.row   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.column) this.column.pushValueUpdates(parse);
        if (this.row   ) this.row   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.column) this.column.invalidateInputs(parse, from);
        if (this.row   ) this.row   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.column) this.column.iterateLoop(parse);
        if (this.row   ) this.row   .iterateLoop(parse);
    }
}


class GItems
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(ITEMS, nodeId, options);
    }



    copy()
    {
        const copy = new GItems(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (this[key] instanceof GValue)
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = this.input ? (await this.input.eval(parse)).toValue() : ListValue.NaN;


        this.updateValues = [];

        
        if (    this.value.isValid()
            && !isEmpty(this.value.items))
        {
            for (let i = 0; i < this.value.items.length; i++)
            {
                const item = this.value.items[i];

                const valueId = 
                    item.valueId != ''
                    ? item.valueId
                    : i;//'item' + i;

                Object.assign(this, {[valueId]: item});
                this.setUpdateValues(parse, [[valueId, item]], true);

                item.sortId = i;
            }

            this.updateValues.sort((a, b) => a.sortId - b.sortId);
        }
        else
            this.setUpdateValues(parse, [['', NullValue]], true);


        //this.updateValues.push(['value', this.value]); // first so it can be separated out in OpItems


        if (this.value.objects)
            for (let j = 0; j < this.value.objects.length; j++)
                this.value.objects[j].nodeId = this.nodeId;


        this.validate();

        return this;
    }
    
    

    paramFromId(paramId)
    {
        return paramId != 'value'
              ? this.value.items.find(i => i.valueId == paramId) //this[paramId]
              : null;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GSelect
extends GOperator
{
    input = null;
    
    index;



    constructor(nodeId, options)
    {
        super(SELECT, nodeId, options);
    }



    copy()
    {
        const copy = new GSelect(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.index) copy.index = this.index.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let index = this.index ? (await this.index.eval(parse)).toValue() : null;


        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            

            if (   index
                && input
                && input.items
                && input.items.length > 0)
            {
                length = input.items.length;


                index = 
                       index.isValid()
                    && index.value >= 0
                    && index.value <  input.items.length
                    ? new NumberValue(Math.round(index.value))
                    : new NumberValue(0);


                if (   index.isValid()
                    && index.value >= 0
                    && index.value < input.items.length)
                {
                    this.value = input.items[index.value].copy();
                
                    if (this.value.objects)
                    {
                        for (const obj of this.value.objects)
                        {
                            obj.nodeId = this.nodeId;
                            obj.listId = -1;

                            if (obj.objectId != NULL) 
                                obj.objectId += '/';

                            obj.objectId += index.value.toString();
                        }
                    }
                }
                else
                {
                    this.value = NullValue.copy();
                    index      = NumberValue.NaN;
                }                    
            }
            else
            {
                this.value = NullValue.copy();
                index      = NumberValue.NaN;
            }
        }
        else
        {
            this.value = NullValue.copy();
            index      = NumberValue.NaN;
        }


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', this.value              ],
            ['type',    type                    ],
            ['length',  new NumberValue(length) ],
            ['index',   index                   ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.index) this.index.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.index) this.index.iterateLoop(parse);
    }
}


class GListCount
extends GOperator
{
    input = null;
    start = null;

    value = null;



    constructor(nodeId, options)
    {
        super(LIST_COUNT, nodeId, options);
    }



    copy()
    {
        const copy = new GListCount(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.start)  copy.start  = this.start .copy();
        
        if (this.count) copy.count = this.count.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            this.value = new NumberValue(input.items.length - (start.value == 0 ? 1 : 0));
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['start', start     ]
        ]);


        this.validate();

        return this;
    }



    // toValue()
    // {
    //     return this.value.copy();
    // }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.start && this.start.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.start) this.start.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.start) this.start.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.start) this.start.iterateLoop(parse);
    }    
}


class GContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(CONTAINS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GContains(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
        const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];

            
            if (   input1
                && input1.isValid())
            {
                for (let i = 0; i < input0.items.length; i++)
                {
                    if (input0.items[i].equals(input1))
                        indices.push(i);
                }  


                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN;
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN;

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN;
                this.last  = NumberValue.NaN;
                this.all   =   ListValue.NaN;
            }
        }
        else                  
        {
            this.value = NumberValue.NaN;
            this.first = NumberValue.NaN;
            this.last  = NumberValue.NaN;
            this.all   =   ListValue.NaN;
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}


class GIfElse
extends GOperator
{
    input0 = null;
    input1 = null;

    condition;



    constructor(nodeId, options)
    {
        super(IF_ELSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GIfElse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0   ) copy.input0    = this.input0   .copy();
        if (this.input1   ) copy.input1    = this.input1   .copy();

        if (this.condition) copy.condition = this.condition.copy();

        if (this.value    ) copy.value     = this.value    .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const cond = (await this.condition.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = cond.value != 0 ? input0 : input1;
        }
        else if (this.input0)
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.value = 
                cond.value != 0
                ? input0
                : null;
        }
        else if (this.input1)
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = 
                cond.value == 0
                ? input1
                : null;
        }
        else                  
            this.value = null;


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',      new TextValue(this.value ? this.value.type : ANY_VALUE)],
            ['condition', cond                                                   ]
        ]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    isValid()
    {
        return this.input0    && this.input0   .isValid()
            && this.input1    && this.input1   .isValid()
            && this.condition && this.condition.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0   ) this.input0   .pushValueUpdates(parse);
        if (this.input1   ) this.input1   .pushValueUpdates(parse);
        if (this.condition) this.condition.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input0   ) this.input0   .invalidateInputs(parse, from);
        if (this.input1   ) this.input1   .invalidateInputs(parse, from);
        if (this.condition) this.condition.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0   ) this.input0   .iterateLoop(parse);
        if (this.input1   ) this.input1   .iterateLoop(parse);
        if (this.condition) this.condition.iterateLoop(parse);
    }    
}



class GArithmetic
extends GOperator
{
    inputs = [];



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    isValid()
    {
        return  this.inputs.length > 0
            && !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GNumber
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.input || this.input.isValid();
    }
}


class GSign
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIGN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSign(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.sign(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }
}


class GAbsolute
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_ABSOLUTE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAbsolute(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.abs(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GRound
extends GOperator1
{
    type;
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_ROUND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        copy.type     = this.type    .copy();
        copy.decimals = this.decimals.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const type = (await this.type    .eval(parse)).toValue();
        const dec  = (await this.decimals.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                switch (type.value)
                {
                    case 0: this.value.value = floorTo(this.value.value, dec.value); break;
                    case 1: this.value.value = roundTo(this.value.value, dec.value); break;
                    case 2: this.value.value =  ceilTo(this.value.value, dec.value); break;
                }

                this.value.decimals = dec.value;
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['type',     type      ],
            ['decimals', dec       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.type     && this.type    .isValid()
            && this.decimals && this.decimals.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.type    ) this.type    .pushValueUpdates(parse);
        if (this.decimals) this.decimals.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.type    ) this.type    .invalidateInputs(parse, from);
        if (this.decimals) this.decimals.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.type    ) this.type    .iterateLoop(parse);
        if (this.decimals) this.decimals.iterateLoop(parse);
    }
}



class GMinMax
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MINMAX, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMinMax(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

        
        this.value = await evalMinMaxInputs(this.inputs, op.value, parse);

        
        this.setUpdateValues(parse,
        [
            ['operation', op        ],
            ['value',     this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalMinMaxInputs(inputs, op, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    let value = new NumberValue(0);


    const val0 = (await inputs[0].eval(parse)).toValue();

    if (   inputs.length == 1
        && val0.type == NUMBER_VALUE)
    {
        value = new NumberValue(-val0.value, val0.decimals);
    }
    else if (LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
    {
        const item0 = val0.items[0];

        value.value    = item0.value;
        value.decimals = item0.decimals;

        for (let i = 1; i < val0.items.length; i++)
        {
            const item = val0.items[i];

            if (item.type == NUMBER_VALUE)
            {
                value.value = 
                    op == 0
                    ? Math.min(value.value, item.value)
                    : Math.max(value.value, item.value);

                value.decimals = Math.max(value.decimals, item.decimals);
            }                    
        }
    }
    else
    {
        if (val0.type != NUMBER_VALUE)
            return NumberValue.NaN;

        value.value    = val0.value;
        value.decimals = val0.decimals;
    }


    for (let i = 1; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        if (LIST_VALUES.includes(val.type))
        {
            for (const item of val.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value.value = 
                        op == 0
                        ? Math.min(value.value, item.value)
                        : Math.max(value.value, item.value);

                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            consoleAssert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = 
                op == 0
                ? Math.min(value.value, val.value)
                : Math.max(value.value, val.value);

            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GLimits
extends GOperator1
{
    min;
    max;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        copy.min = this.min.copy();
        copy.max = this.max.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.min || this.min.isCached())
            && (!this.max || this.max.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const min = (await this.min.eval(parse)).toValue();
        const max = (await this.max.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                this.value.value = Math.min(Math.max(
                    min.value,
                    this.value.value),
                    max.value);
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['min',   min       ],
            ['max',   max       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.min && this.min.isValid()
            && this.max && this.max.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.min  ) this.min  .pushValueUpdates(parse);
        if (this.max  ) this.max  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.min  ) this.min  .invalidateInputs(parse, from);
        if (this.max  ) this.max  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.min  ) this.min  .iterateLoop(parse);
        if (this.max  ) this.max  .iterateLoop(parse);
    }
}



class GConstant
extends GOperator
{
    constant;



    constructor(nodeId, options)
    {
        super(NUMBER_CONSTANT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GConstant(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.constant) copy.constant = this.constant.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const constant = (await this.constant.eval(parse)).toValue();
    
        let value;

        switch (Math.min(Math.max(0, constant.toNumber()), 5))
        {
            case 0: value = 1.4142135623; break; // √̅2
            case 1: value = 2.7182818284; break; // e
            case 2: value = 0.6180339887; break; // phi
            case 3: value = 1.6180339887; break; // PHI
            case 4: value = 3.1415926536; break; // pi
            case 5: value = 6.2831853072; break; // tau
        }


        this.value = new NumberValue(value, 10);

        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['constant', constant ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.constant && this.constant.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.constant) this.constant.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.constant) this.constant.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.constant) this.constant.iterateLoop(parse);
    }
}



class GDateTime
extends GOperator
{
    seconds   = null;
    minutes   = null;
    hours     = null;
    dayOfWeek = null;
    date      = null;
    month     = null;
    year      = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);
        
        copy.copyBase(this);
        
        copy.seconds   = this.seconds  .copy();
        copy.minutes   = this.minutes  .copy();
        copy.hours     = this.hours    .copy();
        copy.dayOfWeek = this.dayOfWeek.copy();
        copy.date      = this.date     .copy();
        copy.month     = this.month    .copy();
        copy.year      = this.year     .copy();

        return copy;
    }    
    
    
    
    isCached()
    {
        return super.isCached()
            && (!this.year      || this.year     .isCached())
            && (!this.month     || this.month    .isCached())
            && (!this.date      || this.date     .isCached())
            && (!this.dayOfWeek || this.dayOfWeek.isCached())
            && (!this.hours     || this.hours    .isCached())
            && (!this.minutes   || this.minutes  .isCached())
            && (!this.seconds   || this.seconds  .isCached())
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];

        
        if (this.options.enabled)
        {
            const dateTime = new Date();

            const seconds   = new NumberValue(dateTime.getSeconds() );
            const minutes   = new NumberValue(dateTime.getMinutes() );
            const hours     = new NumberValue(dateTime.getHours()   );
            const dayOfWeek = new NumberValue(dateTime.getDay()     );
            const date      = new NumberValue(dateTime.getDate()    );
            const month     = new NumberValue(dateTime.getMonth()   );
            const year      = new NumberValue(dateTime.getFullYear());


            this.setUpdateValues(parse,
            [
                ['seconds',   seconds  ],
                ['minutes',   minutes  ],
                ['hours',     hours    ],
                ['dayOfWeek', dayOfWeek],
                ['date',      date     ],
                ['month',     month    ],
                ['year',      year     ]
            ]);    
        }    

        
        this.validate();

        return this;
    }    



    isValid()
    {
        return this.year      && this.year     .isValid()
            && this.month     && this.month    .isValid()
            && this.date      && this.date     .isValid()
            && this.dayOfWeek && this.dayOfWeek.isValid()
            && this.hours     && this.hours    .isValid()
            && this.minutes   && this.minutes  .isValid()
            && this.seconds   && this.seconds  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.year     ) this.year     .pushValueUpdates(parse);
        if (this.month    ) this.month    .pushValueUpdates(parse);
        if (this.date     ) this.date     .pushValueUpdates(parse);
        if (this.dayOfWeek) this.dayOfWeek.pushValueUpdates(parse);
        if (this.hours    ) this.hours    .pushValueUpdates(parse);
        if (this.minutes  ) this.minutes  .pushValueUpdates(parse);
        if (this.seconds  ) this.seconds  .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.year     ) this.year     .invalidateInputs(parse, from);
        if (this.month    ) this.month    .invalidateInputs(parse, from);
        if (this.date     ) this.date     .invalidateInputs(parse, from);
        if (this.dayOfWeek) this.dayOfWeek.invalidateInputs(parse, from);
        if (this.hours    ) this.hours    .invalidateInputs(parse, from);
        if (this.minutes  ) this.minutes  .invalidateInputs(parse, from);
        if (this.seconds  ) this.seconds  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.year     ) this.year     .iterateLoop(parse);
        if (this.month    ) this.month    .iterateLoop(parse);
        if (this.date     ) this.date     .iterateLoop(parse);
        if (this.dayOfWeek) this.dayOfWeek.iterateLoop(parse);
        if (this.hours    ) this.hours    .iterateLoop(parse);
        if (this.minutes  ) this.minutes  .iterateLoop(parse);
        if (this.seconds  ) this.seconds  .iterateLoop(parse);
    }    
}



class GDefine
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(DEFINE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDefine(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _values = [];

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            if (   input
                && this.options.enabled)            
            {
                if (LIST_VALUES.includes(input.type))
                {
                    for (const item of input.items)
                        _values.push(item.copy());   
                }
                else
                    _values.push(input.copy());
            }
        }
            

        this.value = _values[this.iteration % _values.length];


        this.setUpdateValues(parse,
        [
            ['type', new TextValue(finalTypeFromItems(_values))]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GRange
extends GOperator
{
    from;
    start;
    end;
    spread;
    bias;



    constructor(nodeId, options)
    {
        super(NUMBER_RANGE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRange(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from   ) copy.from    = this.from   .copy();
        if (this.start  ) copy.start   = this.start  .copy();
        if (this.end    ) copy.end     = this.end    .copy();
        if (this.spread ) copy.spread  = this.spread .copy();
        if (this.bias   ) copy.bias    = this.bias   .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const from   = (await this.from  .eval(parse)).toValue();
        const start  = (await this.start .eval(parse)).toValue();
        const end    = (await this.end   .eval(parse)).toValue();
        const spread = (await this.spread.eval(parse)).toValue();
        const bias   = (await this.bias  .eval(parse)).toValue();
    

        const repeat    = parse.repeats.find(r => r.repeatId == this.loopId);
        const iteration = repeat ? repeat.iteration : 0;


        let delta = end.toNumber() - start.toNumber();

        let step = 
               repeat
            && this.options.enabled
            ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))
            : 0;

            
        let startOffset;

             if (from  .value == 2) startOffset = step;
        else if (from  .value == 1
              && repeat
              && repeat.total == 1) startOffset = delta/2;
        else                        startOffset = 0;


        let f;
        
        if (repeat)
        {
            const sd = delta ? start.value/delta : 0;

                 if (from.value == 2) f = sd + iteration/repeat.total;
            else if (from.value == 1) f = sd + (repeat.total > 1 ? iteration/(repeat.total-1) : 0);
            else if (from.value == 0) f = sd + iteration/repeat.total;
        }
        else
            f = 0;


        switch(spread.value)
        {
            case 0:
                break;

            case 1:
            {
                const b = bias.toNumber() / 50;

                f = 
                    b >= 0
                    ? 1 - Math.pow(1-f, 1+b)
                    :     Math.pow(  f, 1-b);

                break;
            }
            case 2:
            {
                const b = bias.toNumber() / 50;

                     if (b >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+b) / 2;
                else if (b >= 0 && f <  0.5) f = Math.pow(f*2, 1+b) / 2;
                else if (b < 0)              f = lerp3(0, (1-b)/3, (2+b)/3, 1, f);

                break;
            }
        }


        this.value = new NumberValue(
            start.toNumber() + startOffset + delta * f,
            Math.max(start.decimals, end.decimals));

        this.setUpdateValues(parse,
        [
            ['from',   from  ],
            ['start',  start ],
            ['end',    end   ],
            ['spread', spread],
            ['bias',   bias  ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.from   && this.from  .isValid()
            && this.start  && this.start .isValid()
            && this.end    && this.end   .isValid()
            && this.spread && this.spread.isValid()
            && this.bias   && this.bias  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from  ) this.from  .pushValueUpdates(parse);
        if (this.start ) this.start .pushValueUpdates(parse);
        if (this.end   ) this.end   .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.bias  ) this.bias  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from  ) this.from  .invalidateInputs(parse, from);
        if (this.start ) this.start .invalidateInputs(parse, from);
        if (this.end   ) this.end   .invalidateInputs(parse, from);
        if (this.spread) this.spread.invalidateInputs(parse, from);
        if (this.bias  ) this.bias  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from  ) this.from  .iterateLoop(parse);
        if (this.start ) this.start .iterateLoop(parse);
        if (this.end   ) this.end   .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.bias  ) this.bias  .iterateLoop(parse);
    }
}



class GSequence
extends GOperator
{
    start;
    step;
    end;

    current;



    constructor(nodeId, options)
    {
        super(NUMBER_SEQUENCE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSequence(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start  ) copy.start   = this.start  .copy();
        if (this.step   ) copy.step    = this.step   .copy();
        if (this.end    ) copy.end     = this.end    .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const start = (await this.start.eval(parse)).toValue();
        const step  = (await this.step .eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();
    

        if (   start
            && end
            && step)
        {
            const value = start.toNumber() + (this.options.enabled ? step.toNumber() * this.iteration : 0);

            // console.log('sequence');

            if (!end.isValid())
                this.value = new NumberValue(value, Math.max(start.decimals, step.decimals));

            else if (end.isValid()   
                     && (   step.toNumber() == 0
                         || step.toNumber() >  0 && start.toNumber() < end.toNumber()
                                                 && value < end.toNumber()
                         || step.toNumber() <  0 && start.toNumber() > end.toNumber()
                                                 && value > end.toNumber()))
            {
                this.value = new NumberValue(
                    start.toNumber() + (this.options.enabled ? step.toNumber() * this.iteration : 0),
                    Math.max(start.decimals, step.decimals));
            }

            else
                this.value = NumberValue.NaN.copy();
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['start', start],
            ['step',  step ],
            ['end',   end  ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.start && this.start.isValid()
            && this.step  && this.step .isValid()
            && (!this.end || this.end.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.step ) this.step .pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.end  ) this.end  .invalidateInputs(parse, from);
        if (this.step ) this.step .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.step ) this.step .iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GRandom
extends GOperator
{
    seed;
    min;
    max;
    unique;

    random       = null;
    randomUnique = null;

    lastValue1   = -1;
    lastValue2   = -1;
    uniqueOffset =  0;



    constructor(nodeId, options)
    {
        super(NUMBER_RANDOM, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.min   ) copy.min    = this.min   .copy();
        if (this.max   ) copy.max    = this.max   .copy();
        if (this.unique) copy.unique = this.unique.copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const seed   = (await this.seed  .eval(parse)).toValue();
        const min    = (await this.min   .eval(parse)).toValue();
        const max    = (await this.max   .eval(parse)).toValue();
        const unique = (await this.unique.eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
        {
            this.random       = new Random(seed.value);
            this.randomUnique = new Random(seed.value+1);
        }



        this.value = new NumberValue(
            min.value + this.random.get(this.iteration + this.uniqueOffset) * (max.value - min.value), 
            Math.max(min.decimals, max.decimals));

            
        const _unique = unique.value/100;
        

        if (max.value - min.value >= 1)
        {
            while (this.value.toNumber() == this.lastValue1
                && this.randomUnique.get(this.iteration) < _unique)
                this.value = new NumberValue(
                    min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),
                    Math.max(min.decimals, max.decimals));
        }

        if (max.value - min.value >= 2)
        {
            while ((   this.value.toNumber() == this.lastValue1
                    || this.value.toNumber() == this.lastValue2)
                && this.randomUnique.get(this.iteration) < Math.max(_unique - 1))
                this.value = new NumberValue(
                    min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),
                    Math.max(min.decimals, max.decimals));
        }        


        this.lastValue2 = this.lastValue1;
        this.lastValue1 = this.value.toNumber();


        this.setUpdateValues(parse,
        [
            ['seed',   seed  ],
            ['min',    min   ],
            ['max',    max   ],
            ['unique', unique]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed   && this.seed  .isValid()
            && this.min    && this.min   .isValid()
            && this.max    && this.max   .isValid()
            && this.unique && this.unique.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed  ) this.seed  .pushValueUpdates(parse);
        if (this.min   ) this.min   .pushValueUpdates(parse);
        if (this.max   ) this.max   .pushValueUpdates(parse);
        if (this.unique) this.unique.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.seed  ) this.seed  .invalidateInputs(parse, from);
        if (this.min   ) this.min   .invalidateInputs(parse, from);
        if (this.max   ) this.max   .invalidateInputs(parse, from);
        if (this.unique) this.unique.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed  ) this.seed  .iterateLoop(parse);
        if (this.min   ) this.min   .iterateLoop(parse);
        if (this.max   ) this.max   .iterateLoop(parse);
        if (this.unique) this.unique.iterateLoop(parse);
    }



    initLoop(parse, nodeId)
    {
        super.initLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }
}



class GNoise
extends GOperator
{
    seed;
    min;
    max;
    scale;
    interpolate;
    offset;
    detail;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_NOISE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNoise(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed       ) copy.seed        = this.seed       .copy();
        if (this.min        ) copy.min         = this.min        .copy();
        if (this.max        ) copy.max         = this.max        .copy();
        if (this.scale      ) copy.scale       = this.scale      .copy();
        if (this.offset     ) copy.offset      = this.offset     .copy();
        if (this.interpolate) copy.interpolate = this.interpolate.copy();
        if (this.detail     ) copy.detail      = this.detail     .copy();

        if (this.random     ) copy.random      = this.random     .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const seed        = (await this.seed       .eval(parse)).toValue();
        const min         = (await this.min        .eval(parse)).toValue();
        const max         = (await this.max        .eval(parse)).toValue();
        const scale       = (await this.scale      .eval(parse)).toValue();
        const offset      = (await this.offset     .eval(parse)).toValue();
        const interpolate = (await this.interpolate.eval(parse)).toValue();
        const detail      = (await this.detail     .eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
            this.random = new Random(seed.value);

        
        let size  = 1;
        let power = 1;
        
        const avg = (min.value + max.value) / 2;
        let   r;

        
        if (   this.options.enabled
            && scale
            && offset)
        {
            r = avg;
            
            for (let c = 0; c < detail.value; c++)
            {
                const i = this.iteration / (scale.value * size) + offset.value;
                
                const i0 = Math.floor(i);
                const i1 = Math.ceil (i);

                const r0 = this.random.get(i0);
                const r1 = this.random.get(i1);


                let _r;
                
                switch (interpolate.value)
                {
                    case 0: _r = power * r0;                                                 break;
                    case 1: _r = power * lerp(r0, r1, i-i0);                                 break;
                    case 2: _r = power * (r0 + (r1 - r0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;
                }

                r += 
                    - power * (avg       - min.value)
                    + _r    * (max.value - min.value);


                size  /= 2;
                power /= 2;
            }
        }
        else
        {
            r = min.value;
        }


        this.value = new NumberValue(r, Math.max(min.decimals, max.decimals));


        this.setUpdateValues(parse,
        [
            ['seed',        seed       ],
            ['min',         min        ],
            ['max',         max        ],
            ['scale',       scale      ],
            ['offset',      offset     ],
            ['interpolate', interpolate],
            ['detail',      detail     ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed        && this.seed       .isValid()
            && this.min         && this.min        .isValid()
            && this.max         && this.max        .isValid()
            && this.scale       && this.scale      .isValid()
            && this.offset      && this.offset     .isValid()
            && this.interpolate && this.interpolate.isValid()
            && this.detail      && this.detail     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed       ) this.seed       .pushValueUpdates(parse);
        if (this.min        ) this.min        .pushValueUpdates(parse);
        if (this.max        ) this.max        .pushValueUpdates(parse);
        if (this.scale      ) this.scale      .pushValueUpdates(parse);
        if (this.offset     ) this.offset     .pushValueUpdates(parse);
        if (this.interpolate) this.interpolate.pushValueUpdates(parse);
        if (this.detail     ) this.detail     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.seed       ) this.seed       .invalidateInputs(parse, from);
        if (this.min        ) this.min        .invalidateInputs(parse, from);
        if (this.max        ) this.max        .invalidateInputs(parse, from);
        if (this.scale      ) this.scale      .invalidateInputs(parse, from);
        if (this.offset     ) this.offset     .invalidateInputs(parse, from);
        if (this.interpolate) this.interpolate.invalidateInputs(parse, from);
        if (this.detail     ) this.detail     .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed       ) this.seed       .iterateLoop(parse);
        if (this.min        ) this.min        .iterateLoop(parse);
        if (this.max        ) this.max        .iterateLoop(parse);
        if (this.scale      ) this.scale      .iterateLoop(parse);
        if (this.offset     ) this.offset     .iterateLoop(parse);
        if (this.interpolate) this.interpolate.iterateLoop(parse);
        if (this.detail     ) this.detail     .iterateLoop(parse);
    }
}



class GProbability
extends GOperator
{
    seed;
    chance;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_PROBABILITY, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.chance) copy.chance = this.chance.copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const seed   = (await this.seed  .eval(parse)).toValue();
        const chance = (await this.chance.eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
            this.random = new Random(seed.value);


        const r = 
            this.options.enabled
            ? (this.random.get(this.iteration) > 1 - chance.value/100 ? 1 : 0)
            : 0;


        this.value = new NumberValue(Math.round(r));


        this.setUpdateValues(parse,
        [
            ['seed', seed  ],
            ['min',  chance],
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed   && this.seed  .isValid()
            && this.chance && this.chance.isValid()
            && this.max    && this.max   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed  ) this.seed  .pushValueUpdates(parse);
        if (this.chance) this.chance.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.seed  ) this.seed  .invalidateInputs(parse, from);
        if (this.chance) this.chance.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed  ) this.seed  .iterateLoop(parse);
        if (this.chance) this.chance.iterateLoop(parse);
    }
}



class GAccumulate
extends GOperator
{
    current;
    when;



    constructor(nodeId, options)
    {
        super(NUMBER_ACCUMULATE, nodeId, options);

        this.current = new NumberValue(0);
    }


    
    copy()
    {
        const copy = new GAccumulate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.when   ) copy.when    = this.when   .copy();
        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const when = (await this.when.eval(parse)).toValue();
            

        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (when.value == 0)
                this.value = this.current.copy();

            if (input)
            {
                this.current.value += input.value;
                this.current.decimals = Math.max(this.current.decimals, input.decimals);
            }

            if (when.value > 0)
                this.value = this.current.copy();
        }


        this.setUpdateValues(parse, [['', NullValue]]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.when && this.when.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.step ) this.step .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.step ) this.step .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.step ) this.step .iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.current = new NumberValue(0);
    }
}



class GInterpolate
extends GOperator2
{
    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount = (await this.amount.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = (await this.input0.eval(parse)).toValue();
            const val1 = (await this.input1.eval(parse)).toValue();

            const maxDec = Math.max(val0.decimals, val1.decimals);

            this.value = new NumberValue(
                val0.value + amount.value * (val1.value - val0.value) / 100,
                maxDec);
        }
        else if (this.input0)
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();

        else                  
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['amount', amount    ],
            ['value',  this.value]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.amount && this.amount.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.amount) this.amount.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.amount) this.amount.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.amount) this.amount.iterateLoop(parse);
    }
}



class GSolve
extends GOperator1
{
    current;
    target;

    temp;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSolve(this.nodeId, this.options);

        copy.copyBase(this);

        copy.current = this.current.copy();
        copy.target  = this.target .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && this.current.isCached()
            && this.target .isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let   current = (await this.current.eval(parse)).toValue();
        const target  = (await this.target .eval(parse)).toValue();


        if (   this.input
            //&& current.isValid()
            && target .isValid())
        {
            let input = (await this.input.eval(parse)).toValue();

            consoleAssert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                const diffStart = target.value - current.value;
                let   diff      = diffStart;
                let   prevDiff  = 0;


                let   temp      = 0;
                let   step      = Number.MAX_SAFE_INTEGER/2;


                let   iter      = 0;
                const maxIter   = 1000;
                

                genInitNodeProgress(this.nodeId);


                parse.totalProgress += maxIter;


                while (iter++ < maxIter)
                {
                    temp += step;


                    if (this.input.type == PARAM)
                        this.input.node[this.input.paramId].value = temp;
                        
                    this.current.invalidateInputs(parse, this);
                    current = (await this.current.eval(parse)).toValue();


                    if (!current.isValid())
                        diff = Number.MAX_SAFE_INTEGER;
                    else
                        diff = target.value - current.value;

                    if (Math.abs(diff) < 0.0000001)
                        break;
                        

                    if (   Math.abs (diff) >  Math.abs (prevDiff)
                        || Math.sign(diff) != Math.sign(prevDiff))
                        step /= -2;


                    prevDiff = diff;


                    parse.currentProgress++;


                    genUpdateNodeProgress(parse, this.nodeId, iter / maxIter);
                }


                if (iter < maxIter)
                {
                    parse.currentProgress += maxIter - iter;

                    input = (await this.input.eval(parse)).toValue();
                    this.value = input;
                }
                else
                {
                    this.value = NumberValue.NaN;
                    console.warn('max solve iterations');
                }
            }
            else
                this.value = input;
        }
        else
        {
            if (this.input) 
                await this.input.eval(parse);

            this.value = NumberValue.NaN;
        }

        
        // TODO push good result value to input 

        this.setUpdateValues(parse,
        [
            //['value',   this.value],
            ['current', current   ],
            ['target',  target    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.current && this.current.isValid()
            && this.target  && this.target .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.current) this.current.pushValueUpdates(parse);
        if (this.target ) this.target .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.current) this.current.invalidateInputs(parse, from);
        if (this.target ) this.target .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.current) this.current.iterateLoop(parse);
        if (this.target ) this.target .iterateLoop(parse);
    }
}



class GAnimate
extends GOperator
{
    from;
    to;
    curve;
    repeat;
    length;
    time;



    constructor(nodeId, options)
    {
        super(NUMBER_ANIMATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnimate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from  ) copy.from   = this.from  .copy();
        if (this.to    ) copy.to     = this.to    .copy();
        if (this.curve ) copy.curve  = this.curve .copy();
        if (this.repeat) copy.repeat = this.repeat.copy();
        if (this.length) copy.length = this.length.copy();
        if (this.time  ) copy.time   = this.time  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const from   = (await this.from  .eval(parse)).toValue();
        const to     = (await this.to    .eval(parse)).toValue();
        const curve  = (await this.curve .eval(parse)).toValue();
        const repeat = (await this.repeat.eval(parse)).toValue();
        const length = (await this.length.eval(parse)).toValue();
        const time   = (await this.time  .eval(parse)).toValue();
    

        const maxDec = Math.max(from.decimals, to.decimals);

        switch (curve.value)
        {
            case 0: 
            {
                this.value = new NumberValue(
                    time.value < length.value ? from.value : to.value, 
                    maxDec);
    
                break;
            }
            case 1: 
            {
                this.value = new NumberValue(
                    from.value + (to.value - from.value) * time.value / length.value,
                    maxDec);

                break;
            }
            case 2: 
            {
                let f = time.value / length.value;

                f = 1 - sqr(1 - f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 3: 
            {
                let f = time.value / length.value;

                f = sqr(f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 4: 
            {
                let f = time.value / length.value;

                f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
        }
        

        this.setUpdateValues(parse,
        [
            ['from',   from  ],
            ['to',     to    ],
            ['curve',  curve ],
            ['repeat', repeat],
            ['length', length],
            ['time',   time  ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return this.from   && this.from  .isValid()
            && this.to     && this.to    .isValid()
            && this.curve  && this.curve .isValid()
            && this.repeat && this.repeat.isValid()
            && this.length && this.length.isValid()
            && this.time   && this.time  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from  ) this.from  .pushValueUpdates(parse);
        if (this.to    ) this.to    .pushValueUpdates(parse);
        if (this.curve ) this.curve .pushValueUpdates(parse);
        if (this.repeat) this.repeat.pushValueUpdates(parse);
        if (this.length) this.length.pushValueUpdates(parse);
        if (this.time  ) this.time  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from  ) this.from  .invalidateInputs(parse, from);
        if (this.to    ) this.to    .invalidateInputs(parse, from);
        if (this.curve ) this.curve .invalidateInputs(parse, from);
        if (this.repeat) this.repeat.invalidateInputs(parse, from);
        if (this.length) this.length.invalidateInputs(parse, from);
        if (this.time  ) this.time  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from  ) this.from  .iterateLoop(parse);
        if (this.to    ) this.to    .iterateLoop(parse);
        if (this.curve ) this.curve .iterateLoop(parse);
        if (this.repeat) this.repeat.iterateLoop(parse);
        if (this.length) this.length.iterateLoop(parse);
        if (this.time  ) this.time  .iterateLoop(parse);
    }
}



class GMath
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

        switch (op.value)
        {
            case 0: this.value = await evalSubtractInputs(this.inputs, parse); break;
            case 1: this.value = await evalAddInputs     (this.inputs, parse); break;
            case 2: this.value = await evalModuloInputs  (this.inputs, parse); break;
            case 3: this.value = await evalDivideInputs  (this.inputs, parse); break;
            case 4: this.value = await evalMultiplyInputs(this.inputs, parse); break;
            case 5: this.value = await evalExponentInputs(this.inputs, parse); break;
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



class GSimpleMath
extends GOperator1
{
    operation;
    operand;



    constructor(nodeId, options)
    {
        super(NUMBER_SIMPLE_MATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();
        copy.operand   = this.operand  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const op      = (await this.operation.eval(parse)).toValue();
        const operand = (await this.operand  .eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

                switch (op.value)
                {
                    case 0: 
                        this.value = new NumberValue(
                            this.value.value - operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 1: 
                        this.value = new NumberValue(
                            this.value.value + operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 2: 
                        this.value = new NumberValue(
                            this.value.value % operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 3: 
                        if (operand.value == 0)
                            this.value = NumberValue.NaN;
                        else
                        {
                            const val = this.value.value / operand.value;

                            this.value = new NumberValue(
                                val, 
                                Math.max(Math.max(this.value.decimals, operand.decimals)), decDigits(val));
                        }
                        break;

                    case 4: 
                        this.value = new NumberValue(
                            this.value.value * operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 5: 
                        this.value = new NumberValue(
                            Math.pow(this.value.value, operand.value),
                            Math.max(this.value.decimals, operand.decimals));
                        break;
                }
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ],
            ['operand',   operand   ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
    }
}



class GAdd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAdd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalAddInputs(this.inputs, parse);
        
        this.setUpdateValues(parse, [['value', this.value]]);

        this.validate();

        return this;
    }
}



async function evalAddInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        if (LIST_VALUES.includes(val.type))
        {
            if (   isEmpty(val.items)
                || val.items[0].type != NUMBER_VALUE)
                return NumberValue.NaN;

            for (const item of val.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value.value   += item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
        }
        else
        {
            consoleAssert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            value.value   += val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GSubtract
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSubtract(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalSubtractInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalSubtractInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    let value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (   inputs.length == 1
            && val0.type == NUMBER_VALUE)
        {
            value = new NumberValue(-val0.value, val0.decimals);
        }
        else if (LIST_VALUES.includes(val0.type)
             && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];

                if (item.type == NUMBER_VALUE)
                {
                    value.value   -= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        value.value   -= item.value;
                        value.decimals = Math.max(value.decimals, item.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                value.value   -= val.value;
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GMultiply
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GMultiply(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }

    

    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalMultiplyInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalMultiplyInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        value.value = 1;

        for (let i = 0; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                if (   isEmpty(val.items)
                    || val.items[0].type != NUMBER_VALUE)
                    return NumberValue.NaN;

                for (const item of val.items)
                {
                    value.value   *= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value   *= val.value;
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GDivide
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDivide(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        this.value = await evalDivideInputs(this.inputs, parse);
    
        
        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalDivideInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();


        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                console.log('item =', item);
                
                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.value    = value.value / item.value;
                    value.decimals = Math.max(Math.max(value.decimals, item.decimals), decDigits(value.value));
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }

        
        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value.value    = value.value / item.value;
                        value.decimals = Math.max(Math.max(value.decimals, item.decimals), decDigits(value.value));
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }
    
                value.value    = value.value / val.value;
                value.decimals = Math.max(Math.max(value.decimals, val.decimals), decDigits(value.value));
            }
        }
    }


    return value;
}


class GModulo
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const copy = new GModulo(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalModuloInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalModuloInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.decimals = Math.max(value.decimals, item.decimals);
                    value.value    = value.value % item.value;
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value.decimals = Math.max(value.decimals, item.decimals);
                        value.value    = floorTo(value.value % item.value, value.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }

                value.decimals = Math.max(value.decimals, val.decimals);
                value.value    = floorTo(value.value % val.value, value.decimals);
            }
        }
    }


    return value;
}


class GExponent
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GExponent(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalExponentInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalExponentInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                {
                    value.value    = Math.pow(value.value,    item.value);
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        value.value    = Math.pow(value.value,    item.value);
                        value.decimals = Math.max(value.decimals, item.decimals);
                            }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value    = Math.pow(value.value,    val.value);
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GBoolean
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_BOOLEAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), BOOLEAN_OPS.length-1);

        
        switch (op.value)
        {
            case BOOLEAN_NOT: this.value = await evalNandInputs(this.inputs, parse); break;
            case BOOLEAN_XOR: this.value = await evalXorInputs (this.inputs, parse); break;
            case BOOLEAN_OR:  this.value = await evalOrInputs  (this.inputs, parse); break;
            case BOOLEAN_AND: this.value = await evalAndInputs (this.inputs, parse); break;
        }

        
        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}


class GNot
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNot(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalNandInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalNandInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber() != 0 ? 0 : 1;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() == 0)
                    value.value = 1;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber() != 0 ? 0 : 1;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() == 0)
                        value.value = 1;
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.toNumber() == 0)
                    value.value = 1;
            }
        }
    }


    return value;
}



class GAnd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_AND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalAndInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);

        
        this.validate();

        return this;
    }
}



async function evalAndInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.min(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.min(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value = Math.min(value.value, val.toNumber());
            }
        }

        
        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GOr
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_OR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GOr(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalOrInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalOrInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.max(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.max(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                value.value = Math.max(value.value, val.toNumber());
            }
        }


        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GXor
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_XOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GXor(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalXorInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalXorInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    let flipped;

    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            flipped = item0.toNumber() != 0;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() != 0)
                    flipped++;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            flipped = val0.toNumber() != 0;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() != 0)
                        flipped++;
                    }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                if (val.toNumber() != 0)
                    flipped++;
            }
        }


        value.value = flipped == 1 ? 1 : 0;
    }


    return value;
}


class GCondition
extends GOperator1
{
    operation;
    operand;



    constructor(nodeId, options)
    {
        super(NUMBER_CONDITION, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondition(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();
        copy.operand   = this.operand  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op      = (await this.operation.eval(parse)).toValue();
        const operand = (await this.operand  .eval(parse)).toValue();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        switch (op.value)
        {
            case CONDITION_LESS:              this.value = await evalConditionInputs(this.input, operand, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     this.value = await evalConditionInputs(this.input, operand, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         this.value = await evalConditionInputs(this.input, operand, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             this.value = await evalConditionInputs(this.input, operand, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  this.value = await evalConditionInputs(this.input, operand, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           this.value = await evalConditionInputs(this.input, operand, ((a, b) => a >  b), parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ],
            ['operand',   operand   ]
        ]);


        this.validate();

    return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
    }
}



async function evalConditionInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : NumberValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : NumberValue.NaN;

    if (   val0.isValid() 
        && val1.isValid())
        return new NumberValue(op(val0.toNumber(), val1.toNumber()) ? 1 : 0);
    else                  
        return NumberValue.NaN;
}


class GEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a == b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GNotEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNotEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a != b, 
            parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GLess
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLess(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a < b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GLessOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLessOrEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a <= b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GGreater
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreater(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a > b, 
            parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GGreaterOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreaterOrEqual(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a >= b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GTrig
extends GOperator1
{
    function;



    constructor(nodeId, options)
    {
        super(NUMBER_TRIG, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTrig(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const func = (await this.function.eval(parse)).toValue().toInteger();

        func.value = Math.min(Math.max(0, func.value), TRIG_OPS.length-1);

        
        switch (func.value)
        {
            case TRIG_SIN: this.value = await evalSine   (this.input, parse);  break;
            case TRIG_COS: this.value = await evalCosine (this.input, parse);  break;
            case TRIG_TAN: this.value = await evalTangent(this.input, parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['function', func      ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.function && this.function.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.function) this.function.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.function) this.function.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.function) this.function.iterateLoop(parse);
    }
}


class GSine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalSine(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



async function evalSine(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    value = new NumberValue(Math.sin(value.value, 10));

    return value;
}


class GCosine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_COS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCosine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalCosine(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalCosine(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    value = new NumberValue(Math.cos(value.value, 10));

    return value;
}


class GTangent
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_TAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTangent(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalTangent(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalTangent(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    value = new NumberValue(Math.tan(value.value, 10));

    return value;
}


class GText
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT, nodeId, options);
    }



    copy()
    {
        const copy = new GText(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return   !this.input
               && this.value != NAN_CHAR 
            || this.input.isValid();
    }



    isValid()
    {
        return ;
    }
}


class GTextLength
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_LENGTH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextLength(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.length) copy.length = this.length.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let length;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            consoleAssert(input.type == TEXT_VALUE, 'input must be TEXT_VALUE');

            length = new NumberValue(input.value.length);
        }
        else
            length = NumberValue.NaN;
    

        this.setUpdateValues(parse,
        [
            ['length', length]
        ]);


        this.validate();

        return this;
    }
}



class GTextTrim
extends GOperator1
{
    start;
    end;


    
    constructor(nodeId, options)
    {
        super(TEXT_TRIM, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextTrim(this.nodeId, this.options);

        copy.copyBase(this);

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            if (this.options.enabled)
            {
                if (start.value.length > 0) this.value.value = trimCharFromStart(this.value.value, unescapeString(start.value));
                if (end  .value.length > 0) this.value.value = trimCharFromEnd  (this.value.value, unescapeString(end  .value));
            }
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['start', start     ],
            ['end',   end       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.end  ) this.end  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GTextSubstring
extends GOperator1
{
    start;
    end;


    
    constructor(nodeId, options)
    {
        super(TEXT_SUBSTRING, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextSubstring(this.nodeId, this.options);

        copy.copyBase(this);

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();

        let   length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            length = input.value.length;
            
            this.value = input.copy();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            const _end =
                end.isValid()
                ? end
                : new NumberValue(input.value.length);


            if (start.value <= _end.value)
            {
                if (this.options.enabled)
                    this.value.value = this.value.value.substring(start.value, _end.value);
            }
            else
                this.value = new TextValue();//TextValue.NaN;
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',  this.value             ],
            ['length', new NumberValue(length)], // used to set start and end maxima
            ['start',  start                  ],
            ['end',    end                    ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    iterateLoop(parse, from)
    {
        super.iterateLoop(parse, from);

        if (this.start) this.start.iterateLoop(parse, from);
        if (this.end  ) this.end  .iterateLoop(parse, from);
    }
}



class GTextContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(TEXT_CONTAINS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextContains(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
        const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];
            let   index   = 0;

            if (input1.value != '')
            {
                while (index != -1) 
                {
                    index = input0.value.indexOf(input1.value, index);

                    if (index != -1) 
                    {
                        indices.push(index);
                        index += 1;
                    }
                }

                
                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN;
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN;

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN;
                this.last  = NumberValue.NaN;
                this.all   =   ListValue.NaN;
            }
        }
        else                  
        {
            this.value = NumberValue.NaN;
            this.first = NumberValue.NaN;
            this.last  = NumberValue.NaN;
            this.all   =   ListValue.NaN;
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}


class GTextCase
extends GOperator1
{
    case;


    
    constructor(nodeId, options)
    {
        super(TEXT_CASE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCase(this.nodeId, this.options);

        copy.copyBase(this);

        copy.case = this.case.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _case = (await this.case.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            if (this.options.enabled)
            {
                const val = this.value.value;

                if (_case.value == 0) 
                     this.value.value = val.toLowerCase();

                else if (_case.value == 1)
                {
                    this.value.value = '';

                    if (val.length > 0) this.value.value += val.substring(0, 1).toUpperCase();
                    if (val.length > 1) this.value.value += val.substring(1)   .toLowerCase();
                }

                else if (_case.value == 2)
                {
                    this.value.value = '';

                    let i = 0;
                    while (i < val.length)
                    {
                        while (i < val.length
                            && /\s/.test(val.charAt(i)))
                            this.value.value += val.charAt(i++);

                        if (i < val.length)
                            this.value.value += val.charAt(i++).toUpperCase();

                        while (i < val.length
                            && !/\s/.test(val.charAt(i)))
                            this.value.value += val.charAt(i++).toLowerCase();
                    }
                }

                else if (_case.value == 3) 
                    this.value.value = val.toUpperCase();
            }
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['case',  _case     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.case && this.case.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.case) this.case.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.case) this.case.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.case) this.case.iterateLoop(parse);
    }
}



class GNumberToText
extends GOperator1
{
    number;
    format;


    
    constructor(nodeId, options)
    {
        super(NUMBER_TO_TEXT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNumberToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            let str = NAN_CHAR;

            switch (format.value)
            {
                case 0: // dec
                    str = numToString(input.value, -input.decimals);
                break;

                case 1: // hex
                    str = numToString(Math.round(input.value), input.decimals, true).toUpperCase();
                    break;
            }

            this.value = new TextValue(str);
        }
        else
            this.value = TextValue.NaN;

            
        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['format', format    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.format) this.format.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



class GTextToNumber
extends GOperator1
{
    format;


    
    constructor(nodeId, options)
    {
        super(TEXT_TO_NUMBER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextToNumber(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            let num = Number.NaN;

            switch (format.value)
            {
                case 0: // dec
                    num = parseFloat(input.value);
                    break;

                case 1: // hex
                    num = parseInt(input.value, 16);
                    break;
            }

            this.value = new NumberValue(num, decDigits(num));
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['format', format    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.format) this.format.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



class GTextToColor
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_TO_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextToColor(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            let rgb = 
                input.value.trim() != ''
                ? validHex2rgb(input.value)
                : rgb_NaN;
                
            this.value = ColorValue.fromRgb(scaleRgb(rgb));
        }
        else
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



class GTextCharacter
extends GOperator1
{
    code;


    
    constructor(nodeId, options)
    {
        super(TEXT_CHAR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCharacter(this.nodeId, this.options);

        copy.copyBase(this);

        copy.code = this.code.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const code = (await this.code.eval(parse)).toValue();


        this.value = new TextValue(String.fromCharCode(code.value));


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['code',  code      ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.code && this.code.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.code) this.code.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.code) this.code.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.code) this.code.iterateLoop(parse);
    }
}



class GTextReplace
extends GOperator1
{
    what;
    with;



    constructor(nodeId, options)
    {
        super(TEXT_REPLACE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextReplace(this.nodeId, this.options);

        copy.copyBase(this);

        copy.what  = this.what .copy();
        copy.with  = this.with .copy();

        copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _what = (await this.what.eval(parse)).toValue();
        const _with = (await this.with.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');

            this.value.value = this.value.value.replaceAll(
                unescapeString(_what.value),
                unescapeString(_with.value));
        }
        else
            this.value = new TextValue();//TextValue.NaN;

            
        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['what',  _what     ],
            ['with',  _with     ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.what && this.what.isValid()
            && this.with && this.with.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.what) this.what.pushValueUpdates(parse);
        if (this.with) this.with.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.what) this.what.invalidateInputs(parse, from);
        if (this.with) this.with.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.what) this.what.iterateLoop(parse);
        if (this.with) this.with.iterateLoop(parse);
    }
}



class GTextJoin
extends GOperator
{
    inputs = [];

    with;


    
    constructor(nodeId, options)
    {
        super(TEXT_JOIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextJoin(this.nodeId, this.options);
        copy.copyBase(this);
        
        copy.inputs = this.inputs.map(i => i.copy());
        copy.with   = this.with;

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _with = (await this.with.eval(parse)).toValue();

        this.value = await evalJoinInputs(this.inputs, _with, parse);

        
        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['with',  _with     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.with && this.with.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



async function evalJoinInputs(inputs, _with, parse)
{
    if (isEmpty(inputs))
        return new TextValue();//TextValue.NaN;


    const value = new TextValue();
    const w     = unescapeString(_with.value);

    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();
        if (!val) continue;


        if (i > 0)
            value.value += w;


        if (LIST_VALUES.includes(val.type))
        {
            for (let j = 0; j < val.items.length; j++)
            {
                if (j > 0)
                    value.value += w;


                const item = val.items[j];

                if (item.type == TEXT_VALUE)
                    value.value += item.value;
            }
        }
        else
        {
            consoleAssert(val.type == TEXT_VALUE, 'val.type must be TEXT_VALUE');

            value.value += val.value;
        }
    }


    return value;
}


class GTextPad
extends GOperator1
{
    startPad;
    startCount;
    endPad;
    endCount;


    
    constructor(nodeId, options)
    {
        super(TEXT_PAD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextPad(this.nodeId, this.options);

        copy.copyBase(this);

        copy.startPad   = this.startPad  .copy();
        copy.startCount = this.startCount.copy();
        copy.endPad     = this.endPad    .copy();
        copy.endCount   = this.endCount  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const startPad   = (await this.startPad  .eval(parse)).toValue();
        const startCount = (await this.startCount.eval(parse)).toValue();
        const endPad     = (await this.endPad    .eval(parse)).toValue();
        const endCount   = (await this.endCount  .eval(parse)).toValue();


        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            length = input.value.length;
            
            this.value = input.copy();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            if (this.options.enabled)
                this.value.value = this.value.value
                    .padStart(startCount.value, unescapeString(startPad.value))
                    .padEnd  (  endCount.value, unescapeString(  endPad.value));
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',      this.value             ],
            ['length',     new NumberValue(length)], // used to set start and end maxima
            ['startPad',   startPad               ],
            ['startCount', startCount             ],
            ['endPad',     endPad                 ],
            ['endCount',   endCount               ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.startPad   && this.startPad  .isValid()
            && this.startCount && this.startCount.isValid()
            && this.endPad     && this.endPad    .isValid()
            && this.endCount   && this.endCount  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.startPad  ) this.startPad  .pushValueUpdates(parse);
        if (this.startCount) this.startCount.pushValueUpdates(parse);
        if (this.endPad    ) this.endPad    .pushValueUpdates(parse);
        if (this.endCount  ) this.endCount  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.startPad  ) this.startPad  .invalidateInputs(parse, from);
        if (this.startCount) this.startCount.invalidateInputs(parse, from);
        if (this.endPad    ) this.endPad    .invalidateInputs(parse, from);
        if (this.endCount  ) this.endCount  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.startPad  ) this.startPad  .iterateLoop(parse);
        if (this.startCount) this.startCount.iterateLoop(parse);
        if (this.endPad    ) this.endPad    .iterateLoop(parse);
        if (this.endCount  ) this.endCount  .iterateLoop(parse);
    }
}



class GTextSplit
extends GOperator1
{
    value;
    separator;



    constructor(nodeId, options)
    {
        super(TEXT_SPLIT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextSplit(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value    ) copy.value     = this.value    .copy();
        if (this.separator) copy.separator = this.separator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const separator = this.separator ? (await this.separator.eval(parse)).toValue() : null;


        this.value = new ListValue();


        if (   this.input
            && separator)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            if (   input
                && input.value)
            {
                consoleAssert(input.type == TEXT_VALUE, 'input must be TEXT_VALUE');
                const items = input.value.split(unescapeString(separator.value));

                for (const item of items)
                    this.value.items.push(new TextValue(item));
            }
        }
    

        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['separator', separator ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.separator && this.separator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.separator) this.separator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.separator) this.separator.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.separator) this.separator.iterateLoop(parse);
    }
}



class GTextCompare
extends GOperator2
{
    operation;



    constructor(nodeId, options)
    {
        super(TEXT_COMPARE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCompare(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        let result;

        switch (op.value)
        {
            case CONDITION_LESS:              result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a >  b), parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['result',    result],
            ['operation', op    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalCompareInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : TextValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : TextValue.NaN;

    if (   val0 && val0.isValid() 
        && val1 && val1.isValid())
        return new NumberValue(op(val0.value, val1.value) ? 1 : 0);
    else                  
        return NullValue;//new NumberValue(0);
}


class GTextCSV
extends GOperator1
{
    rowSeparator;
    columnSeparator;



    constructor(nodeId, options)
    {
        super(TEXT_CSV, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCSV(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.rowSeparator   ) copy.rowSeparator    = this.rowSeparator   .copy();
        if (this.columnSeparator) copy.columnSeparator = this.columnSeparator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const rowSeparator    = this.rowSeparator    ? (await this.rowSeparator   .eval(parse)).toValue() : null;
        const columnSeparator = this.columnSeparator ? (await this.columnSeparator.eval(parse)).toValue() : null;


        this.value = new ListValue();


        let maxColumns = 0;

        
        let nRows    = 0;
        let nColumns = 0;


        if (   this.input
            && rowSeparator
            && columnSeparator
            && rowSeparator.value != '')
        {
            const input = this.input ? (await this.input.eval(parse)).toValue() : null;
            

            const rows = 
                   input
                && input.value            
                ? input.value.split(unescapeString(rowSeparator.value))
                : [];


            for (const _row of rows)
            {
                const cells = 
                    _row
                    ? _row.split(unescapeString(columnSeparator.value))
                    : [];


                const row = new ListValue();

                for (const cell of cells)
                    row.items.push(new TextValue(cell));

                maxColumns = Math.max(maxColumns, row.items.length);


                this.value.items.push(row);
            }


            nRows    = this.value.items.length;
            nColumns = maxColumns;
        }
    

        this.setUpdateValues(parse,
        [
            ['preview',         new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['rowSeparator',    rowSeparator             ],
            ['columnSeparator', columnSeparator          ],
            ['rows',            new NumberValue(nRows   )],
            ['columns',         new NumberValue(nColumns)]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.rowSeparator    && this.rowSeparator   .isValid()
            && this.columnSeparator && this.columnSeparator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.rowSeparator   ) this.rowSeparator   .pushValueUpdates(parse);
        if (this.columnSeparator) this.columnSeparator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.rowSeparator   ) this.rowSeparator   .invalidateInputs(parse, from);
        if (this.columnSeparator) this.columnSeparator.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.rowSeparator   ) this.rowSeparator   .iterateLoop(parse);
        if (this.columnSeparator) this.columnSeparator.iterateLoop(parse);
    }
}



class GTextJson
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_JSON, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextJson(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            try
            {
                const json = JSON.parse(input.value);
                this.value = this.evalItems(json);
            }
            catch (e)
            {
                this.value = new ListValue();
            }
        }
    

        // console.log('this.value =', this.value);
        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['length',  new NumberValue(this.value.items.length)]
            //['value',   this.value]
        ]);
        

        this.validate();

        return this;
    }



    evalItems(json)
    {
        let list = new ListValue();


        for (const key in json)
        {
            if (   typeof json[key] === 'object'
                && json[key] !== null)
            {
                const obj = this.evalItems(json[key]);
                obj.valueId = key;
                list.items.push(obj);
            }
            else
            {
                let value;

                if (   typeof json[key] === 'number'
                    || isValidFloatString(json[key]))
                    value = NumberValue.fromString(json[key].toString());
                else if (typeof json[key] === 'boolean')
                    value = new NumberValue(parseBool(json[key].toString()) ? 1 : 0);
                else
                    value = new TextValue(json[key]);

                    
                value.valueId = 
                    key == 'value'
                    ? '(value)' // reserved param name in Generator
                    : key;

                list.items.push(value);
            }
        }

        
        return list;
    }
}



class GTextFetch
extends GOperator
{
    request;
    cachedValue;



    constructor(nodeId, options)
    {
        super(TEXT_FETCH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextFetch(this.nodeId, this.options);

        copy.copyBase(this);

        copy.request     = this.request    .copy();
        copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const request     = (await this.request    .eval(parse)).toValue();
        const cachedValue = (await this.cachedValue.eval(parse)).toValue();

        
        genInitNodeProgress(this.nodeId);


        if (cachedValue.value == '')
        {
            try 
            {
                const response = await fetch(request.value);
                const content  = await response.text();
                
                this.value = new TextValue(content);
            }
            catch (e)
            {
                // const parts = e.message.split(':');
                
                this.value = 
                    request.value.trim() == NULL
                    ? new TextValue()
                    : new TextValue('invalid request');//parts[Math.min(1, parts.length-1)]);
            }
        }
        else
        {
            this.value = this.cachedValue.copy();
        }


        this.setUpdateValues(parse,
        [
            ['preview', this.value],
            ['value',   this.value],
            ['request', request   ]
        ]);
        
        
        this.validate();

        return this;
    }



    isValid()
    {
        return this.request && this.request.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.request) this.request.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.request) this.request.invalidateInputs(parse, from);

        this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.request) this.request.iterateLoop(parse);
    }
}


class GTextFile
extends GOperator
{
    path;
    
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(TEXT_FILE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextFile(this.nodeId, this.options);

        copy.copyBase(this);

        copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const cachedValue = this.cachedValue ? (await this.cachedValue.eval(parse)).toValue() : null;
        const path        = this.path        ? (await this.path       .eval(parse)).toValue() : null;

        
        genInitNodeProgress(this.nodeId);


        this.value = cachedValue ?? new TextValue();


        this.setUpdateValues(parse,
        [
            ['preview', this.value],
            ['path',    path      ]
        ]);
        
        
        this.validate();

        return this;
    }



    isValid()
    {
        return this.path && this.path.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.path) this.path.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.path) this.path.invalidateInputs(parse, from);

        //this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.path) this.path.iterateLoop(parse);
    }
}


class ColorCorrection
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    
    constructor(name = '', max = 0, value = 0)//, locked = false)
    {
        this.name  = name;
        this.max   = max;
        this.value = value;
    }
}



async function findCorrection(parse,
                        nodeId,
                        color,
                        order,       margin1, margin2, margin3,
                        lockedOrder, locked1, locked2, locked3) 
{
    const refOklab = dataColor2array(dataColor2oklab(color));

    
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = order ? order.value : -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);

        
    let d = 1;
        
    parse.totalProgress += 1024;


    dLoop:
    while (d > 1/1024)
    {
        if (parse.stop()) break dLoop;

        let _closestColor = [...closestColor];


        for (let _order = 0; _order < 6; _order++)
        {
            if (parse.stop()) break dLoop;

            closestColor = [..._closestColor];

            const [min1, min2, min3] = getMinCorrections(color[0], _order);
            const [max1, max2, max3] = getMaxCorrections(color[0], _order);

            let start1 = lerp(min1, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(min2, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(min3, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = margin1.toNumber(); start1 = closest1; end1 = closest1+Epsilon; }
            if (locked2) { closest2 = margin2.toNumber(); start2 = closest2; end2 = closest2+Epsilon; }
            if (locked3) { closest3 = margin3.toNumber(); start3 = closest3; end3 = closest3+Epsilon; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = await findCorrectionInOrder(
                parse,
                nodeId,
                refOklab,
                _order, 
                lockedOrder, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }


        if (parse.stopGenerate)
            break;

        
        d /= 2;


        parse.currentProgress++;
    }


    if (   !parse.stop()
        && !parse.stopGenerate)
    {
        // reduce closest to necessary minimums

        const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

        let c1 = closest1;
        let c2 = closest2;
        let c3 = closest3;

        while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
        while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
        while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

        closest1 = Math.max(0, c1);
        closest2 = Math.max(0, c2);
        closest3 = Math.max(0, c3);
    }

    
    return [
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



async function findCorrectionInOrder(parse,
                                     nodeId,
                                     refOklab,
                                     order, 
                                     lockedOrder, 
                                     locked1,  locked2,  locked3,
                                     closest1, closest2, closest3,
                                     start1,   start2,   start3, 
                                     end1,     end2,     end3,
                                     closestColor,
                                     closestOklab,
                                     closestOrder,
                                     progress,
                                     total)
{
    const color = [...closestColor];
    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    cLoop:
    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
       if (parse.stop()) break cLoop;

        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            if (parse.stop()) break cLoop;

            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                if (parse.stop()) break cLoop;

                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsOk(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    
                    if (!lockedOrder)
                        closestOrder = order;

                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;
                }

                progress++;
            }
        }

        
        if (parse.repeats.length == 1)
        {
            const stopRequestId = await genGetValueFromUi('stopRequestId');

            if (   parse.requestId == stopRequestId.value
                || curRequestIds.includes(parse.requestId)) 
            { 
                parse.stopGenerate = true;
                break; 
            }
        }


        genUpdateNodeProgress(parse, nodeId, progress / total, false);
    }

    
    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = correctColor(color, order, m1, m2, m3);
    const oklab  = dataColor2array(dataColor2oklab(_color));
    const rgb    = oklab2rgb(oklab);

    return [_color, oklab, rgb];
}



function correctColor(color, order, margin1, margin2, margin3)
{
    if (order < 0)
        return color;


    const [i1, i2, i3] = getCorrectionsInOrder(order);

                               color = correctChannel(color, i1, margin1);
    if (!dataColorIsOk(color)) color = correctChannel(color, i2, margin2);
    if (!dataColorIsOk(color)) color = correctChannel(color, i3, margin3);


    // clip colors that are reasonably valid but stick over the fence
    
    let rgb = dataColor2rgb(color);

    if (rgbIsOk(rgb))
        rgb = invalid2validRgb(rgb);
    
        
    color = convertDataColorToSpace(
        rgb2dataColor(rgb),
        color[0]);

        
    return color;
}



function correctChannel(color, iChan, margin)
{
    const factor = colorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsOk(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorOk(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorOk( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsOk(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorOk(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsOk(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorOk(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorOk(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsOk(color);
}



function getCorrectionsInOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }

    // should never get here
    consoleError('invalid correction order ' + order);
    return [0, 0, 0];
}



function getMinCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let min;

    switch (space)
    {
        case 'hex':
        case 'rgb':    min = [0, 0, 0]; break

        case 'hsv': 
        case 'hsl':    min = [0, 0, 0]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': min = [0, 0, 0]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    min = [0, -oppFactor[1]/2, -oppFactor[2]/2]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [min[c1], min[c2], min[c3]];
}



function getMaxCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let max;

    switch (space)
    {
        case 'hex':
        case 'rgb':    max = [...rgbFactor]; break;

        case 'hsv': 
        case 'hsl':    max = [hs_Factor[0]/2, hs_Factor[1], hs_Factor[2]]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': max = [hclFactor[0]/2, hclFactor[1], hclFactor[2]]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    max = [...oppFactor]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [max[c1], max[c2], max[c3]];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Epsilon
        && c2.closest <  Epsilon
        && c3.closest >= Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Epsilon
          && c2.closest <  Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getColorCorrections(colorSpace)
{
    switch (colorSpace)
    {
    case 'hex':
    case 'rgb':
        return [
            new ColorCorrection('R', rgbFactor[0]),
            new ColorCorrection('G', rgbFactor[1]),
            new ColorCorrection('B', rgbFactor[2]) ];

    case 'hsv':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('V', hs_Factor[2]) ];

    case 'hsl':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('L', hs_Factor[2]) ];

    case 'hclok':
    case 'hclab':
    case 'hcluv':
        return [
            new ColorCorrection('H', hclFactor[0]/2),
            new ColorCorrection('C', hclFactor[1]),
            new ColorCorrection('L', hclFactor[2]) ];

    case 'oklab': 
    case 'lab':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('a', oppFactor[1]),
            new ColorCorrection('b', oppFactor[2]) ];

    case 'luv':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('u', oppFactor[1]),
            new ColorCorrection('v', oppFactor[2]) ];
    }


    consoleError('invalid color space ' + colorSpace);
    return [
        new ColorCorrection(),
        new ColorCorrection(),
        new ColorCorrection() ];
}


class GColor
extends GOperator1
{
    space   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;

    hasInputs;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColor(this.nodeId, this.options);

        copy.copyBase(this);

        copy.space = this.space.copy();

        if (this.c1) copy.c1 = this.c1.copy();
        if (this.c2) copy.c2 = this.c2.copy();
        if (this.c3) copy.c3 = this.c3.copy();

        if (this.convert) 
            copy.convert = this.convert.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space = this.space ? (await this.space.eval(parse)).toValue().toInteger() : null; 
        let   c1    = this.c1    ? (await this.c1   .eval(parse)).toValue()             : null;
        let   c2    = this.c2    ? (await this.c2   .eval(parse)).toValue()             : null;
        let   c3    = this.c3    ? (await this.c3   .eval(parse)).toValue()             : null;

        //console.log('COLOR c3 =', c3.value);
        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (   input.isValid()
                && this.input.type != START)
            {
                if (this.options.enabled)
                {
                    this.value = input.copy();
                    

                    const fromSpaceIndex = input.space.value;

                    const toSpaceIndex = Math.min(Math.max(
                        0,
                        Math.round(space.value)), // round because a value can come in with decimals (TODO fix this)
                        colorSpaceCount(parse)-1);


                    if (toSpaceIndex != fromSpaceIndex)
                    {
                        this.convertColor(
                            this.value,
                            colorSpace(fromSpaceIndex), 
                            colorSpace(  toSpaceIndex));

                        this.value.space.value = toSpaceIndex;
                    }


                    if (!c1) c1 = this.value.c1;
                    if (!c2) c2 = this.value.c2;
                    if (!c3) c3 = this.value.c3;
                
                    if (c1) this.value.c1 = c1;
                    if (c2) this.value.c2 = c2;
                    if (c3) this.value.c3 = c3;
                }
                else
                    this.value = input;
            }
            else
                this.value = ColorValue.NaN;


            if (!this.convert)
                this.convert = NumberValue.NaN;
        }
        else
        {
            this.value = new ColorValue(space, c1, c2, c3);


            const toSpaceIndex = Math.min(Math.max(
                0,
                Math.round(this.value.space.value)), // round because a value can come in with decimals (TODO fix this)
                colorSpaceCount(parse)-1);

            this.value.space.value = toSpaceIndex;

            if (    this.convert
                &&  this.convert.isValid()
                &&  this.convert.value > -1
                &&  this.value.isValid()
                && !this.hasInputs)
            {
                await this.convert.eval(parse);

                this.convertColor(
                    this.value,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }
        }


        if (!this.value.space.isValid())
            this.value = new ColorValue(
                this.space.toValue(),
                NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN);


        this.setUpdateValues(parse,
        [
            ['convert', this.convert    ],
            ['space',   this.value.space],
            ['c1',      this.value.c1   ],
            ['c2',      this.value.c2   ],
            ['c3',      this.value.c3   ]
        ]);


        if (!this.c1) this.c1 = this.value.c1.copy();
        if (!this.c2) this.c2 = this.value.c2.copy();
        if (!this.c3) this.c3 = this.value.c3.copy();


        this.validate();

        return this;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2) ];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    toValue()
    {
        return this.options.enabled
             ? this.value.copy()
             : ColorValue.NaN;
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.space && this.space.isValid()
            && this.c1    && this.c1   .isValid()
            && this.c2    && this.c2   .isValid()
            && this.c3    && this.c3   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space) this.space.pushValueUpdates(parse);
        if (this.c1   ) this.c1   .pushValueUpdates(parse);
        if (this.c2   ) this.c2   .pushValueUpdates(parse);
        if (this.c3   ) this.c3   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.space) this.space.invalidateInputs(parse, from);
        if (this.c1   ) this.c1   .invalidateInputs(parse, from);
        if (this.c2   ) this.c2   .invalidateInputs(parse, from);
        if (this.c3   ) this.c3   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space) this.space.iterateLoop(parse);
        if (this.c1   ) this.c1   .iterateLoop(parse);
        if (this.c2   ) this.c2   .iterateLoop(parse);
        if (this.c3   ) this.c3   .iterateLoop(parse);
    }
}


class GValidColor
extends GOperator1
{
    quality      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(VALID_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GValidColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value  ) copy.value   = this.value  .copy();
        if (this.quality) copy.quality = this.quality.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const quality = this.quality ? (await this.quality.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                // if (   !isValid(this.value) 
                //     || !this.value.isValid()) 
                // {
                    let rgb = input.toRgb();

                    if (quality.value == 0) // clip sRGB
                    {
                        rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
                        rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
                        rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
                        
                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else if (quality.value == 1) // clip chroma
                    {
                        rgb = clipChroma(rgb);

                        rgb[0] = Math.round(rgb[0] * 0xff);   
                        rgb[1] = Math.round(rgb[1] * 0xff);   
                        rgb[2] = Math.round(rgb[2] * 0xff); 

                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else // find corrections
                    {
                        if (!rgbIsOk(rgb))
                            genInitNodeProgress(this.nodeId);
                        

                        const inputColor = input.toDataColor();


                        const
                      [ closestOrder,
                        closest1,
                        closest2,
                        closest3 ] = await findCorrection(
                            parse,
                            this.nodeId,
                            inputColor, 
                            quality, null,  null,  null, 
                            false,   false, false, false); 

                            
                        if (!parse.stopGenerate)
                        {
                            if (   closestOrder >= 0 
                                && closestOrder <  6)
                            {
                                this._color = correctColor(
                                    inputColor,
                                    closestOrder,
                                    closest1,
                                    closest2,
                                    closest3);

                                this.value = ColorValue.fromDataColor(this._color);
                            }
                            else
                            {
                                this.value = ColorValue.NaN;
                            }
                        }
                    }
                //}
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['quality', quality   ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.quality && this.quality.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.quality) this.quality.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.quality) this.quality.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.quality) this.quality.iterateLoop(parse);
    }
}



class GCorrectColor
extends GOperator1
{
    order        = null;
    margin1      = null;
    margin2      = null;
    margin3      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(CORRECT_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCorrectColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.order  ) copy.order   = this.order  .copy();
        if (this.margin1) copy.margin1 = this.margin1.copy();
        if (this.margin2) copy.margin2 = this.margin2.copy();
        if (this.margin3) copy.margin3 = this.margin3.copy();
        if (this.value  ) copy.value   = this.value  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const order   = this.order   ? (await this.order  .eval(parse)).toValue().toInteger() : null;
        const margin1 = this.margin1 ? (await this.margin1.eval(parse)).toValue()             : null;
        const margin2 = this.margin2 ? (await this.margin2.eval(parse)).toValue()             : null;
        const margin3 = this.margin3 ? (await this.margin3.eval(parse)).toValue()             : null;

    
        if (order)
            order.value = Math.min(Math.max(0, order.value), 5);


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                // if (   isValid(this.order  ) && this.order  .isValid()
                //     && isValid(this.margin1) && this.margin1.isValid()
                //     && isValid(this.margin2) && this.margin2.isValid()
                //     && isValid(this.margin3) && this.margin3.isValid()
                //     && isValid(this.value  ) && this.value  .isValid())
                // {
                //     genPushUpdateValue(parse, this.nodeId, 'order'  , this.order  );
                //     genPushUpdateValue(parse, this.nodeId, 'margin1', this.margin1);
                //     genPushUpdateValue(parse, this.nodeId, 'margin2', this.margin2);
                //     genPushUpdateValue(parse, this.nodeId, 'margin3', this.margin3);
                //     genPushUpdateValue(parse, this.nodeId, 'value'  , this.value  );
                // }
                // else
                // {
                    const rgb = input.toRgb();
                    
                    if (!rgbIsOk(rgb))
                        genInitNodeProgress(this.nodeId);


                    const inputColor = input.toDataColor();


                    const
                  [ closestOrder,
                    closest1,
                    closest2,
                    closest3 ] = await findCorrection(
                        parse,
                        this.nodeId,
                        inputColor, 
                        order, margin1, margin2, margin3, 
                        this.order   != null,
                        this.margin1 != null, 
                        this.margin2 != null, 
                        this.margin3 != null); 

                        
                    if (   !parse.stop()
                        && !parse.stopGenerate)
                    {
                        if (   closestOrder >= 0 
                            && closestOrder <  6)
                        {
                            this._color = correctColor(
                                inputColor,
                                closestOrder,
                                closest1,
                                closest2,
                                closest3);

                                
                            this.order   = new NumberValue(closestOrder);
                            this.margin1 = new NumberValue(closest1);
                            this.margin2 = new NumberValue(closest2);
                            this.margin3 = new NumberValue(closest3);
                            this.value   = ColorValue.fromDataColor(this._color);

                            this.setUpdateValues(parse,
                            [
                                ['order',   new NumberValue(closestOrder)],
                                ['margin1', new NumberValue(closest1    )],
                                ['margin2', new NumberValue(closest2    )],
                                ['margin3', new NumberValue(closest3    )],
                                ['value',   this.value                   ]
                            ]);
                        }
                        // else
                        // {
                        //     this.order   = NumberValue.NaN;
                        //     this.margin1 = NumberValue.NaN;
                        //     this.margin2 = NumberValue.NaN;
                        //     this.margin3 = NumberValue.NaN;
                        //     this.value   = ColorValue .NaN;

                        //     this.setUpdateValues(parse,
                        //     [
                        //         ['order',   NumberValue.NaN],
                        //         ['margin1', NumberValue.NaN],
                        //         ['margin2', NumberValue.NaN],
                        //         ['margin3', NumberValue.NaN],
                        //         ['value',   ColorValue .NaN]
                        //     ]);
                        // }
                    }
                    else
                    {
                        this.order   = NumberValue.NaN;
                        this.margin1 = NumberValue.NaN;
                        this.margin2 = NumberValue.NaN;
                        this.margin3 = NumberValue.NaN;
                        this.value   = input;
        
                        this.setUpdateValues(parse,
                        [
                            ['order'  , this.order  ],
                            ['margin1', this.margin1],
                            ['margin2', this.margin2],
                            ['margin3', this.margin3],
                            ['value',   this.value  ]
                        ]);
                    }
                //}
            }
            else
            {
                this.order   = NumberValue.NaN;
                this.margin1 = NumberValue.NaN;
                this.margin2 = NumberValue.NaN;
                this.margin3 = NumberValue.NaN;
                this.value   = input;

                this.setUpdateValues(parse,
                [
                    ['order'  , this.order  ],
                    ['margin1', this.margin1],
                    ['margin2', this.margin2],
                    ['margin3', this.margin3],
                    ['value',   this.value  ]
                ]);
            }
        }
        else
        {
            this.order   = NumberValue.NaN;
            this.margin1 = NumberValue.NaN;
            this.margin2 = NumberValue.NaN;
            this.margin3 = NumberValue.NaN;
            this.value   = ColorValue .NaN;

            this.setUpdateValues(parse,
            [
                ['order',   NumberValue.NaN],
                ['margin1', NumberValue.NaN],
                ['margin2', NumberValue.NaN],
                ['margin3', NumberValue.NaN],
                ['value',   ColorValue .NaN]
            ]);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.order   && this.order  .isValid()
            && this.margin1 && this.margin1.isValid()
            && this.margin2 && this.margin2.isValid()
            && this.margin3 && this.margin3.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.order  ) this.order  .pushValueUpdates(parse);
        if (this.margin1) this.margin1.pushValueUpdates(parse);
        if (this.margin2) this.margin2.pushValueUpdates(parse);
        if (this.margin3) this.margin3.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.order  ) this.order  .invalidateInputs(parse, from);
        if (this.margin1) this.margin1.invalidateInputs(parse, from);
        if (this.margin2) this.margin2.invalidateInputs(parse, from);
        if (this.margin3) this.margin3.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.order  ) this.order  .iterateLoop(parse);
        if (this.margin1) this.margin1.iterateLoop(parse);
        if (this.margin2) this.margin2.iterateLoop(parse);
        if (this.margin3) this.margin3.iterateLoop(parse);
    }
}



class GColorContrast
extends GOperator2
{
    standard = null;
    contrast = null;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorContrast(this.nodeId, this.options);

        copy.copyBase(this);

        copy.standard = this.standard.copy();
        copy.contrast = this.contrast.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const standard = (await this.standard.eval(parse)).toValue().toInteger();

        
        if (standard.isValid())
            standard.value = Math.min(Math.max(0, standard.value), 1);


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();


            if (   input0.isValid()
                && input1.isValid())
            {
                if (   dataColorIsValid(input0.toDataColor())
                    && dataColorIsValid(input1.toDataColor()))
                {
                    if (standard.value == 0)
                    {
                        const value = getContrastRatio2(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 2);
                    }
                    else
                    {
                        const value = getContrastRatio3(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 1);
                    }
                }
                else
                    this.contrast = NumberValue.NaN;
            }
            else
                this.contrast = NumberValue.NaN;


            this.value = input0 ? input0.copy() : ColorValue.NaN;


            this.setUpdateValues(parse,
            [
                ['text', input0],
                ['back', input1]
            ]);
        }

        else if (this.input0) 
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.setUpdateValues(parse,
            [
                ['text', input0.isValid() ? input0 : ColorValue.NaN],
                ['back', ColorValue.NaN                            ]
            ]);
            
            this.value    = input0.copy();
            this.contrast = NumberValue.NaN;
        }

        else if (this.input1) 
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN                            ],
                ['back', input1.isValid() ? input1 : ColorValue.NaN]
            ]);

            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else
        {
            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;

            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN],
                ['back', ColorValue.NaN]
            ]);
        }
        


        this.setUpdateValues(parse,
        [
            ['standard', standard     ],
            ['contrast', this.contrast]
        ],
        true);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.standard && this.standard.isValid()
            && (!this.contrast || this.contrast.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.standard) this.standard.pushValueUpdates(parse);
        if (this.contrast) this.contrast.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.standard) this.standard.invalidateInputs(parse, from);
        if (this.contrast) this.contrast.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.standard) this.standard.iterateLoop(parse);
        if (this.contrast) this.contrast.iterateLoop(parse);
    }
}



class GConvertP3
extends GOperator1
{
    from = null;



    constructor(nodeId, options)
    {
        super(COLOR_CONVERT_P3, nodeId, options);
    }


    
    copy()
    {
        const copy = new GConvertP3(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.from ) copy.from  = this.from .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const from = this.from ? (await this.from.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (this.options.enabled)
            {
                this.value = ColorValue.fromRgb(
                    from.value == 0 
                    ? scaleRgb(srgb2p3(input.toRgb()))
                    : scaleRgb(p32srgb(input.toRgb())));
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['quality', from      ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.from && this.from.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from) this.from.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from) this.from.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from) this.from.iterateLoop(parse);
    }
}



class GColorBlind
extends GOperator1
{
    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlind(this.nodeId, this.options);

        copy.copyBase(this);

        copy.l = this.l.copy();
        copy.m = this.m.copy();
        copy.s = this.s.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const l = (await this.l.eval(parse)).toValue();        
        const m = (await this.m.eval(parse)).toValue();
        const s = (await this.s.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            const rgb   = input.toRgb();

            if (this.options.enabled)
            {
                const rgbCb = rgb2colorblind(
                    rgb,
                    l.value / 2,
                    m.value / 2,
                    s.value / 2);

                if (   !rgbIsNaN(rgb)
                    && !rgbIsNaN(rgbCb))
                {
                    const validRgbCb = rgbCb;
                
                    const validCol = convertDataColorToSpace(
                        rgb2dataColor(validRgbCb), 
                        colorSpace(input.space.value));

                    this.value = ColorValue.fromDataColor(validCol);
                }
                else
                    this.value = ColorValue.NaN;
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['l',     l         ],
            ['m',     m         ],
            ['s',     s         ],
            ['value', this.value]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.l && this.l.isValid()
            && this.m && this.m.isValid()
            && this.s && this.s.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.l) this.l.pushValueUpdates(parse);
        if (this.m) this.m.pushValueUpdates(parse);
        if (this.s) this.s.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.l) this.l.invalidateInputs(parse, from);
        if (this.m) this.m.invalidateInputs(parse, from);
        if (this.s) this.s.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.l) this.l.iterateLoop(parse);
        if (this.m) this.m.iterateLoop(parse);
        if (this.s) this.s.iterateLoop(parse);
    }
}



class GColorInterpolate
extends GOperator2
{
    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.space  = this.space .copy();
        copy.amount = this.amount.copy();
        copy.gamma  = this.gamma .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space  = (await this.space .eval(parse)).toValue().toInteger();
        const amount = (await this.amount.eval(parse)).toValue();
        const gamma  = (await this.gamma .eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            consoleAssert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const f = amount.value / 100;


            const spaceIndex = Math.min(Math.max(0, space.value), colorSpaceCount()-1);
            const gammaValue = Math.max(0.0001, gamma.value);

            const _space = colorSpace(spaceIndex);

            const _color = this.interpolate(
                spaceIndex,
                convertDataColorToSpace(input0.toDataColor(), _space),
                convertDataColorToSpace(input1.toDataColor(), _space),
                f,
                gammaValue);


            // allow interpolating invalid colors,
            // so no valid color check here

            this.value = ColorValue.fromDataColor(_color, spaceIndex);
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['space',  space     ],
            ['amount', amount    ],
            ['gamma',  gamma     ],
            ['value',  this.value]
        ]);
        

        this.validate();
        
        return this;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (   space <= 1
            || space >  6) // hex, rgb, okLab, lab, luv
        {
            gamma = Math.max(0.01, gamma);

            const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);  
            const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);  
            const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);  

            const r1 = Math.sign(col1[1]) * Math.pow(Math.abs(col1[1]), gamma);
            const g1 = Math.sign(col1[2]) * Math.pow(Math.abs(col1[2]), gamma);
            const b1 = Math.sign(col1[3]) * Math.pow(Math.abs(col1[3]), gamma);

            const r = lerp(r0, r1, f);        
            const g = lerp(g0, g1, f);            
            const b = lerp(b0, b1, f);        

            return [
                colorSpace(space),
                Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),
                Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),
                Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }



    isValid()
    {
        return super.isValid()
            && this.space  && this.space .isValid()
            && this.amount && this.amount.isValid()
            && this.gamma  && this.gamma .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space ) this.space .pushValueUpdates(parse);
        if (this.amount) this.amount.pushValueUpdates(parse);
        if (this.gamma ) this.gamma .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.space ) this.space .invalidateInputs(parse, from);
        if (this.amount) this.amount.invalidateInputs(parse, from);
        if (this.gamma ) this.gamma .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space ) this.space .iterateLoop(parse);
        if (this.amount) this.amount.iterateLoop(parse);
        if (this.gamma ) this.gamma .iterateLoop(parse);
    }
}



class GColorBlend
extends GOperator2
{
    mode;
    opacity;
    

    constructor(nodeId, options)
    {
        super(COLOR_BLEND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlend(this.nodeId, this.options);

        copy.copyBase(this);

        copy.mode    = this.mode   .copy();
        copy.opacity = this.opacity.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const mode    = (await this.mode   .eval(parse)).toValue().toInteger();
        const opacity = (await this.opacity.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            consoleAssert(
                opacity.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const _opacity = opacity.value / 100;

            const modeIndex = Math.min(Math.max(0, mode.value), BlendModes.length-1);


            const col = this.blend(
                modeIndex,
                input0.toRgb(),
                input1.toRgb(),
                _opacity);

            this.value = ColorValue.fromRgb(scaleRgb(col));
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['mode',    mode      ],
            ['opacity', opacity   ]
        ]);


        this.validate();
        
        return this;
    }



    blend(mode, col0, col1, opacity)
    {
        switch (mode)
        {
            case  0: return blendNormal    (col0, col1, opacity);

            case  1: return blendDarken    (col0, col1, opacity);
            case  2: return blendMultiply  (col0, col1, opacity);
            case  3: return blendColorBurn (col0, col1, opacity);

            case  4: return blendLighten   (col0, col1, opacity);
            case  5: return blendScreen    (col0, col1, opacity);
            case  6: return blendColorDodge(col0, col1, opacity);

            case  7: return blendOverlay   (col0, col1, opacity);
            case  8: return blendSoftLight (col0, col1, opacity);
            case  9: return blendHardLight (col0, col1, opacity);

            case 10: return blendDifference(col0, col1, opacity);
            case 11: return blendExclusion (col0, col1, opacity);

            case 12: return blendHue       (col0, col1, opacity);
            case 13: return blendSaturation(col0, col1, opacity);
            case 14: return blendColor     (col0, col1, opacity);
            case 15: return blendLuminosity(col0, col1, opacity);
        }
    }



    isValid()
    {
        return super.isValid()
            && this.mode    && this.mode   .isValid()
            && this.opacity && this.opacity.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.mode   ) this.mode   .pushValueUpdates(parse);
        if (this.opacity) this.opacity.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.mode   ) this.mode   .invalidateInputs(parse, from);
        if (this.opacity) this.opacity.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.mode   ) this.mode   .iterateLoop(parse);
        if (this.opacity) this.opacity.iterateLoop(parse);
    }
}



function blendNormal(col, back, opacity)
{
    return [ col[0] * opacity + back[0] * (1 - opacity),
             col[1] * opacity + back[1] * (1 - opacity),
             col[2] * opacity + back[2] * (1 - opacity) ];
}



function blendDarken(col, back, opacity)
{
    return blendNormal(
        [ Math.min(back[0], col[0]),
          Math.min(back[1], col[1]),
          Math.min(back[2], col[2]) ],
        back,
        opacity);
}



function chanMultiply(c, b)
{
    return c * b;
}



function blendMultiply(col, back, opacity)
{
    return blendNormal(
        [ chanMultiply(col[0], back[0]),
          chanMultiply(col[1], back[1]),
          chanMultiply(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorBurn(c, b)
{
         if (b == 1) return 1;
    else if (c == 0) return 0;
    else             return 1 - Math.min((1 - b) / c, 1);
}



function blendColorBurn(col, back, opacity)
{
    return blendNormal(
         [ chanColorBurn(col[0], back[0]),
           chanColorBurn(col[1], back[1]),
           chanColorBurn(col[2], back[2]) ],
        back,
        opacity);
}



function blendLighten(col, back, opacity)
{
    return blendNormal(
        [ Math.max(back[0], col[0]),
          Math.max(back[1], col[1]),
          Math.max(back[2], col[2]) ],
        back,
        opacity);
}



function chanScreen(c, b)
{
    return b + c - b*c;
}



function blendScreen(col, back, opacity)
{
    return blendNormal(
        [ chanScreen(col[0], back[0]),
          chanScreen(col[1], back[1]),
          chanScreen(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorDodge(c, b)
{
         if (b == 0) return 0;
    else if (c == 1) return 1;
    else             return Math.min(b / (1 - c), 1);
}



function blendColorDodge(col, back, opacity)
{
    return blendNormal(
        [ chanColorDodge(col[0], back[0]),
          chanColorDodge(col[1], back[1]),
          chanColorDodge(col[2], back[2]) ],
        back,
        opacity);
}



function blendOverlay(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(back[0], col[0]),
          chanHardLight(back[1], col[1]),
          chanHardLight(back[2], col[2]) ],
        back,
        opacity);
}



function bSL_D(b)
{
    return b <= 0.25
         ? ((16 * b - 12) * b + 4) * b
         : Math.sqrt(b);
}



function chanSoftLight(c, b)
{
    return c <= 0.5
         ? b - (1 - 2*c) * b * (1 - b)
         : b + (2*c - 1) * (bSL_D(b) - b);
}



function blendSoftLight(col, back, opacity)
{
    return blendNormal(
        [ chanSoftLight(col[0], back[0]),
          chanSoftLight(col[1], back[1]),
          chanSoftLight(col[2], back[2]) ],
        back,
        opacity);
}



function chanHardLight(c, b)
{
    if (c <= 0.5) return chanMultiply(b, 2 * c);
    else          return chanScreen(b, 2 * c - 1);
}



function blendHardLight(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(col[0], back[0]),
          chanHardLight(col[1], back[1]),
          chanHardLight(col[2], back[2]) ],
        back,
        opacity);
}



function blendDifference(col, back, opacity)
{
    return [ Math.abs(back[0] - col[0]),
             Math.abs(back[1] - col[1]),
             Math.abs(back[2] - col[2]) ];
}



function chanExclusion(c, b)
{
    return b + c - 2*b*c;
}



function blendExclusion(col, back, opacity)
{
    return blendNormal(
        [ chanExclusion(col[0], back[0]),
          chanExclusion(col[1], back[1]),
          chanExclusion(col[2], back[2]) ],
        back,
        opacity);
}



function bl_lum(col)
{
    return col[0] * 0.30
         + col[1] * 0.59
         + col[2] * 0.11;
}



function bl_setLum(_col, l)
{
    const col = [..._col];

    const d = l - bl_lum(col);

    col[0] += d;
    col[1] += d;
    col[2] += d;

    return bl_clamp(col);
}



function bl_sat(col)
{
    return Math.max(col[0], col[1], col[2]) 
         - Math.min(col[0], col[1], col[2]);
}



function bl_min(col)
{
         if (col[0] <= col[1] 
          && col[0] <= col[2]) return 0;
    else if (col[1] <= col[1] 
          && col[1] <= col[2]) return 1;
    else                       return 2;
}



function bl_mid(col)
{
         if (   col[0] >= col[1] 
             && col[0] <= col[2]
          ||    col[0] <= col[1] 
             && col[0] >= col[2]) return 0;
    else if (   col[1] >= col[0] 
             && col[1] <= col[2]
          ||    col[1] <= col[0] 
             && col[1] >= col[2]) return 1;
    else                          return 2;
}



function bl_max(col)
{
         if (col[0] >= col[1] 
          && col[0] >= col[2]) return 0;
    else if (col[1] >= col[1] 
          && col[1] >= col[2]) return 1;
    else                       return 2;
}



function bl_ndx(col) // get min/mid/max chan indices
{
    if (   col[0] == col[1] 
        && col[0] == col[2])
        return [0, 1, 2];

    else 
        return [
            bl_min(col), 
            bl_mid(col), 
            bl_max(col)];
}



function bl_setSat(_col, s)
{
    const col       = [..._col];
    const [n, d, x] = bl_ndx(col);

    if (col[x] > col[n])
    {
        col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));
        col[x] = s;
    }
    else
        col[d] = col[x] = 0;

    col[n] = 0;

    return col;
}



function bl_chanClamp(c, l, n, x)
{
         if (n < 0) return l + (((c - l) * l) / (l - n));
    else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));
    else            return c;
}



function bl_clamp(col)
{
    const l   = bl_lum(col);

    const n = Math.min(col[0], col[1], col[2]);
    const x = Math.max(col[0], col[1], col[2]);

    return [ bl_chanClamp(col[0], l, n, x),
             bl_chanClamp(col[1], l, n, x),
             bl_chanClamp(col[2], l, n, x) ];
}



function blendHue(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(col, bl_sat(back)), bl_lum(back)),
        back,
        opacity);
}



function blendSaturation(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(back, bl_sat(col)), bl_lum(back)),
        back,
        opacity);
}



function blendColor(col, back, opacity)
{
    return blendNormal(
        bl_setLum(col, bl_lum(back)),
        back,
        opacity);
}



function blendLuminosity(col, back, opacity)
{
    return blendNormal(
        bl_setLum(back, bl_lum(col)),
        back,
        opacity);
}


class GColorStyle
extends GOperator
{
    id;

    colorStyle;
    genValue;

    //existing;
    linked;



    constructor(nodeId, options, styleId)
    {
        super(COLOR_STYLE, nodeId, options);

        this.id == styleId;
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        copy.id         = this.id;
        copy.colorStyle = this.colorStyle.copy();
        copy.genValue   = this.genValue  .copy();
        
        //copy.existing   = this.existing;
        copy.linked     = this.linked;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        this.value = (await this.genValue.eval(parse)).toValue();


        if (   this.value.isValid()
            && this.linked)
            // (  !this.existing
            //     || this.linked))
        {
            if (this.value.type == COLOR_VALUE)
                this.value = FillValue.fromRgb(scaleRgb(this.value.toRgb()), 0xff);

            const rgba       = this.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            this.evalStyle({rgba: rgbaStripe});
        }
        else
            this.value = FillValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    evalStyle(options = {})
    {
        if (!this.options.enabled)
            return;

            
        const colorStyle = new FigmaColorStyle(this.nodeId, this.id, this.name);

        //colorStyle.existing = this.existing;


        colorStyle.paints = 
        [
            [ 'SOLID', 
                      Math.round(options.rgba[0] * 0xff)
              + ' ' + Math.round(options.rgba[1] * 0xff)
              + ' ' + Math.round(options.rgba[2] * 0xff)
              + ' ' + Math.round(options.rgba[3] * 100 ) ]
        ];


        this.colorStyle = colorStyle;
    }



    isValid()
    {
        return this.genValue && this.genValue.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.genValue) this.genValue.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.genValue) this.genValue.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.genValue) this.genValue.iterateLoop(parse);
    }
}


class GFill
extends GOperator1
{
    color   = null;
    opacity = null;
    blend   = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    copy()
    {
        const copy = new GFill(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.color  ) copy.color   = this.color  .copy();
        if (this.opacity) copy.opacity = this.opacity.copy();
        if (this.blend  ) copy.blend   = this.blend  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let color   = this.color   ? (await this.color  .eval(parse)).toValue() : null;
        let opacity = this.opacity ? (await this.opacity.eval(parse)).toValue() : null;
        let blend   = this.blend   ? (await this.blend  .eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new FillValue(
                color   ?? input.color,
                opacity ?? input.opacity,
                blend   ?? input.blend);
        }
        else
        {
            this.value = new FillValue(
                color, 
                opacity,
                blend);
        }


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['color',   color     ],
            ['opacity', opacity   ],
            ['blend',   blend     ]
        ]);
        

        if (!this.color  ) this.color   = this.value.color  .copy();
        if (!this.opacity) this.opacity = this.value.opacity.copy();
        if (!this.blend  ) this.blend   = this.value.blend  .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.options.enabled
            ? new FillValue(
                this.color   ? this.color  .toValue() : this.input.value.color  .toValue(),
                this.opacity ? this.opacity.toValue() : this.input.value.opacity.toValue(),
                this.blend   ? this.blend  .toValue() : this.input.value.blend  .toValue())
            : FillValue.NaN;
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.color   && this.color  .isValid()
            && this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.color  ) this.color  .pushValueUpdates(parse);
        if (this.opacity) this.opacity.pushValueUpdates(parse);
        if (this.blend  ) this.blend  .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.color  ) this.color  .invalidateInputs(parse, from);
        if (this.opacity) this.opacity.invalidateInputs(parse, from);
        if (this.blend  ) this.blend  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.color  ) this.color  .iterateLoop(parse);
        if (this.opacity) this.opacity.iterateLoop(parse);
        if (this.blend  ) this.blend  .iterateLoop(parse);
    }
}


class GColorStop
extends GOperator1
{
    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }



    copy()
    {
        const copy = new GColorStop(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fill    ) copy.fill     = this.fill    .copy();
        if (this.position) copy.position = this.position.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fill = this.fill ? (await this.fill.eval(parse)).toValue() : null;

        fill = this.validateFill(fill);


        const position = this.position ? (await this.position.eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new ColorStopValue(
                fill     ?? input.fill,
                position ?? input.position);
        }
        else
        {
            this.value = new ColorStopValue(
                fill, 
                position);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);
        

        if (!this.fill    ) this.fill     = this.value.fill    .copy();
        if (!this.position) this.position = this.value.position.copy();


        this.validate();

        return this;
    }



    validateFill(fill)
    {
        if (!fill)
            return null;


        if (fill.type == COLOR_VALUE)
            return FillValue.fromRgb(scaleRgb(fill.toRgb()), 100);
        else
            return fill;
    }



    toValue()
    {
        return new ColorStopValue(
            this.options.enabled
            ? this.validateFill(this.fill ? this.fill.toValue() : this.input.fill.toValue())
            : FillValue.NaN,
            this.position ? this.position.toValue() : this.input.position.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fill     && this.fill    .isValid()
            && this.position && this.position.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.fill    ) this.fill    .pushValueUpdates(parse);
        if (this.position) this.position.pushValueUpdates(parse);
    }    

    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.fill    ) this.fill    .invalidateInputs(parse, from);
        if (this.position) this.position.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.fill    ) this.fill    .iterateLoop(parse);
        if (this.position) this.position.iterateLoop(parse);
    }
}


class GGradient
extends GOperator
{
    inputs = [];

    gradType = null;
    x        = null;
    y        = null;
    size     = null;
    angle    = null;
    aspect   = null;
    skew     = null;
    blend    = null;



    constructor(nodeId, options)
    {
        super(GRADIENT, nodeId, options);
    }



    copy()
    {
        const copy = new GGradient(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.gradType) copy.gradType = this.x     .copy();
        if (this.x       ) copy.x        = this.x     .copy();
        if (this.y       ) copy.y        = this.y     .copy();
        if (this.size    ) copy.size     = this.size  .copy();
        if (this.angle   ) copy.angle    = this.angle .copy();
        if (this.aspect  ) copy.aspect   = this.aspect.copy();
        if (this.skew    ) copy.skew     = this.skew  .copy();
        if (this.blend   ) copy.blend    = this.blend .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        const gradType = this.gradType ? (await this.gradType.eval(parse)).toValue() : null;
        const x        = this.x        ? (await this.x       .eval(parse)).toValue() : null;
        const y        = this.y        ? (await this.y       .eval(parse)).toValue() : null;
        const size     = this.size     ? (await this.size    .eval(parse)).toValue() : null;
        const angle    = this.angle    ? (await this.angle   .eval(parse)).toValue() : null;
        const aspect   = this.aspect   ? (await this.aspect  .eval(parse)).toValue() : null;
        const skew     = this.skew     ? (await this.skew    .eval(parse)).toValue() : null;
        const blend    = this.blend    ? (await this.blend   .eval(parse)).toValue() : null;


        const stops = new ListValue();

        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);
            stops.items.push(this.inputs[i].toValue());
        }


        this.value = new GradientValue(
            stops,
            gradType,
            x, 
            y, 
            size, 
            angle, 
            aspect,
            skew,
            blend);

            
        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);
        

        if (!this.gradType) this.gradType = this.value.gradType.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.size    ) this.size     = this.value.size    .copy();
        if (!this.angle   ) this.angle    = this.value.angle   .copy();
        if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();
        if (!this.skew    ) this.skew     = this.value.skew    .copy();
        if (!this.blend   ) this.blend    = this.value.blend   .copy();


        this.validate();

        return this;
    }

    
    
    toValue()
    {
        const stops = new ListValue();

        for (let i = 0, o = 0; i < this.inputs.length; i++)
            stops.items.push(this.inputs[i].toValue());


        return new GradientValue(
            stops,
            this.gradType ? this.gradType.toValue() : this.input.gradType.toValue(),
            this.x        ? this.x       .toValue() : this.input.x       .toValue(),
            this.y        ? this.y       .toValue() : this.input.y       .toValue(),
            this.size     ? this.size    .toValue() : this.input.size    .toValue(),
            this.angle    ? this.angle   .toValue() : this.input.angle   .toValue(),
            this.aspect   ? this.aspect  .toValue() : this.input.aspect  .toValue(),
            this.skew     ? this.skew    .toValue() : this.input.skew    .toValue(),
            this.blend    ? this.blend   .toValue() : this.input.blend   .toValue());
    }                 



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.gradType && this.gradType.isValid()
            && this.x        && this.x       .isValid()
            && this.y        && this.y       .isValid()
            && this.size     && this.size    .isValid()
            && this.angle    && this.angle   .isValid()
            && this.aspect   && this.aspect  .isValid()
            && this.skew     && this.skew    .isValid()
            && this.blend    && this.blend   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.gradType) this.gradType.pushValueUpdates(parse);
        if (this.x       ) this.x       .pushValueUpdates(parse);
        if (this.y       ) this.y       .pushValueUpdates(parse);
        if (this.size    ) this.size    .pushValueUpdates(parse);
        if (this.angle   ) this.angle   .pushValueUpdates(parse);
        if (this.aspect  ) this.aspect  .pushValueUpdates(parse);
        if (this.skew    ) this.skew    .pushValueUpdates(parse);
        if (this.blend   ) this.blend   .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
        
        if (this.gradType) this.gradType.invalidateInputs(parse, from);
        if (this.x       ) this.x       .invalidateInputs(parse, from);
        if (this.y       ) this.y       .invalidateInputs(parse, from);
        if (this.size    ) this.size    .invalidateInputs(parse, from);
        if (this.angle   ) this.angle   .invalidateInputs(parse, from);
        if (this.aspect  ) this.aspect  .invalidateInputs(parse, from);
        if (this.skew    ) this.skew    .invalidateInputs(parse, from);
        if (this.blend   ) this.blend   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.gradType) this.gradType.iterateLoop(parse);
        if (this.x       ) this.x       .iterateLoop(parse);
        if (this.y       ) this.y       .iterateLoop(parse);
        if (this.size    ) this.size    .iterateLoop(parse);
        if (this.angle   ) this.angle   .iterateLoop(parse);
        if (this.aspect  ) this.aspect  .iterateLoop(parse);
        if (this.skew    ) this.skew    .iterateLoop(parse);
        if (this.blend   ) this.blend   .iterateLoop(parse);
    }    
}


class GStroke
extends GOperator1
{
    fills  = null;
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;
    cap    = null;
    dashes = null;



    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }



    copy()
    {
        const copy = new GStroke(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fills ) copy.fills  = this.fills .copy();
        if (this.weight) copy.weight = this.weight.copy();
        if (this.fit   ) copy.fit    = this.fit   .copy();
        if (this.join  ) copy.join   = this.join  .copy();
        if (this.miter ) copy.miter  = this.miter .copy();
        if (this.cap   ) copy.cap    = this.cap   .copy();
        if (this.dashes) copy.dashes = this.dashes.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fills = this.fills ? (await this.fills.eval(parse)).toValue() : null;

        fills = this.validateFills(fills);


        const weight = this.weight ? (await this.weight.eval(parse)).toValue() : null;
        const fit    = this.fit    ? (await this.fit   .eval(parse)).toValue() : null;
        const join   = this.join   ? (await this.join  .eval(parse)).toValue() : null;
        const miter  = this.miter  ? (await this.miter .eval(parse)).toValue() : null;
        const cap    = this.cap    ? (await this.cap   .eval(parse)).toValue() : null;
        const dashes = this.dashes ? (await this.dashes.eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new StrokeValue(
                fills  ?? input.fills,
                weight ?? input.weight,
                fit    ?? input.fit,
                join   ?? input.join,
                miter  ?? input.miter,
                cap    ?? input.cap,
                dashes ?? input.dashes);
        }
        else
        {
            this.value = new StrokeValue(
                fills, 
                weight, 
                fit, 
                join,
                miter,
                cap,
                dashes);
        }


        if (!this.fills ) this.fills  = this.value.fills .copy();
        if (!this.weight) this.weight = this.value.weight.copy();
        if (!this.fit   ) this.fit    = this.value.fit   .copy();
        if (!this.join  ) this.join   = this.value.join  .copy();
        if (!this.miter ) this.miter  = this.value.miter .copy();
        if (!this.cap   ) this.cap    = this.value.cap   .copy();
        if (!this.dashes) this.dashes = this.value.dashes.copy();


        this.setUpdateValues(parse,
            [
                ['value',  this.value],
                ['fills',  fills     ],
                ['weight', weight    ],
                ['fit',    fit       ],
                ['join',   join      ],
                ['miter',  miter     ],
                ['cap',    cap       ],
                ['dashes', dashes    ]
            ]);


        this.validate();

        return this;
    }



    validateFills(fills)
    {
        if (!fills)
            return null;

            
        if (fills.type == COLOR_VALUE)
            return new ListValue([FillValue.fromRgb(scaleRgb(fills.toRgb()), 255)]);

        else if (fills.type ==     FILL_VALUE
              || fills.type == GRADIENT_VALUE)
            return new ListValue([fills]);
        else
        {
            consoleAssert(fills.type == LIST_VALUE, 'stroke.fills must be a LIST_VALUE');
            return fills;
        }
    }



    toValue()
    {
        return new StrokeValue(
            this.options.enabled
            ? this.validateFills(this.fills ? this.fills.toValue() : this.input.fills.toValue())
            : new ListValue(),
            this.weight ? this.weight.toValue() : this.input.weight.toValue(),
            this.fit    ? this.fit   .toValue() : this.input.fit   .toValue(),
            this.join   ? this.join  .toValue() : this.input.join  .toValue(),
            this.miter  ? this.miter .toValue() : this.input.miter .toValue(),
            this.cap    ? this.cap   .toValue() : this.input.cap   .toValue(),
            this.dashes ? this.dashes.toValue() : this.input.dashes.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fills  && this.fills .isValid()
            && this.weight && this.weight.isValid()
            && this.fit    && this.fit   .isValid()
            && this.join   && this.join  .isValid()
            && this.miter  && this.miter .isValid()
            && this.cap    && this.cap   .isValid()
            && this.dashes && this.dashes.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.fills ) this.fills .pushValueUpdates(parse);
        if (this.weight) this.weight.pushValueUpdates(parse);
        if (this.fit   ) this.fit   .pushValueUpdates(parse);
        if (this.join  ) this.join  .pushValueUpdates(parse);
        if (this.miter ) this.miter .pushValueUpdates(parse);
        if (this.cap   ) this.cap   .pushValueUpdates(parse);
        if (this.dashes) this.dashes.pushValueUpdates(parse);
    }    
    
    

    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.fills ) this.fills .invalidateInputs(parse, from);
        if (this.weight) this.weight.invalidateInputs(parse, from);
        if (this.fit   ) this.fit   .invalidateInputs(parse, from);
        if (this.join  ) this.join  .invalidateInputs(parse, from);
        if (this.miter ) this.miter .invalidateInputs(parse, from);
        if (this.cap   ) this.cap   .invalidateInputs(parse, from);
        if (this.dashes) this.dashes.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.fills ) this.fills .iterateLoop(parse);
        if (this.weight) this.weight.iterateLoop(parse);
        if (this.fit   ) this.fit   .iterateLoop(parse);
        if (this.join  ) this.join  .iterateLoop(parse);
        if (this.miter ) this.miter .iterateLoop(parse);
        if (this.cap   ) this.cap   .iterateLoop(parse);
        if (this.dashes) this.dashes.iterateLoop(parse);
    }    
}


class GDropShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;
    behind = null;



    constructor(nodeId, options)
    {
        super(DROP_SHADOW, nodeId, options);
    }



    copy()
    {
        const copy = new GDropShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();
        if (this.behind) copy.behind = this.behind.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const blur   = this.blur   ? (await this.blur  .eval(parse)).toValue() : null;
        const spread = this.spread ? (await this.spread.eval(parse)).toValue() : null;
        let   fill   = this.fill   ? (await this.fill  .eval(parse)).toValue() : null;
        const blend  = this.blend  ? (await this.blend .eval(parse)).toValue() : null;
        const behind = this.behind ? (await this.behind.eval(parse)).toValue() : null;


        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new DropShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                behind ?? input.behind,
                this.options.enabled);
        }
        else
        {
            this.value = new DropShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend, 
                behind,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
            ['behind', this.value.behind]
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();
        if (!this.behind) this.behind = this.value.behind.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid()
            && this.behind && this.behind.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
        if (this.behind) this.behind.pushValueUpdates(parse);
    }
    
    
    
   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x     ) this.x     .invalidateInputs(parse, from);
        if (this.y     ) this.y     .invalidateInputs(parse, from);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from);
        if (this.spread) this.spread.invalidateInputs(parse, from);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from);
        if (this.blend ) this.blend .invalidateInputs(parse, from);
        if (this.behind) this.behind.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
        if (this.behind) this.behind.iterateLoop(parse);
    }
}


class GInnerShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;



    constructor(nodeId, options)
    {
        super(INNER_SHADOW, nodeId, options);
    }



    copy()
    {
        const copy = new GInnerShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const blur   = this.blur   ? (await this.blur  .eval(parse)).toValue() : null;
        const spread = this.spread ? (await this.spread.eval(parse)).toValue() : null;
        let   fill   = this.fill   ? (await this.fill  .eval(parse)).toValue() : null;
        const blend  = this.blend  ? (await this.blend .eval(parse)).toValue() : null;

        
        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);


         if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new InnerShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                this.options.enabled);
        }
        else
        {
            this.value = new InnerShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x     ) this.x     .invalidateInputs(parse, from);
        if (this.y     ) this.y     .invalidateInputs(parse, from);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from);
        if (this.spread) this.spread.invalidateInputs(parse, from);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from);
        if (this.blend ) this.blend .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
    }
}


class GLayerBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(LAYER_BLUR, nodeId, options);
    }



    copy()
    {
        const copy = new GLayerBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const radius = this.radius ? (await this.radius.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new LayerBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new LayerBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new LayerBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.radius) this.radius.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GBackBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(BACK_BLUR, nodeId, options);
    }



    copy()
    {
        const copy = new GBackBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const radius = this.radius ? (await this.radius.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new BackBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new BackBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new BackBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.radius) this.radius.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GLayerMask
extends GOperator
{
    constructor(nodeId, options)
    {
        super(LAYER_MASK, nodeId, options);
    }



    copy()
    {
        const copy = new GLayerMask(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        this.value = new LayerMaskValue(this.options.enabled);


        this.setUpdateValues(parse, [['', NullValue]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return new LayerMaskValue(this.options.enabled);
    }



    isValid()
    {
        return true;
    }
}


class GShapeBase
extends GOperator
{
    x      = null;
    y      = null;
    width  = null;
    height = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.x     ) this.x      = base.x     .copy();
        if (base.y     ) this.y      = base.y     .copy();
        if (base.width ) this.width  = base.width .copy();
        if (base.height) this.height = base.height.copy();
    }



    async evalBaseParams(parse, evalHeight = true)
    {
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;

        const height = evalHeight
                    && this.height ? (await this.height.eval(parse)).toValue() : null;

        return [x, y, width, height];
    }



    evalStyle(options = {})
    {
        // for (const style of this.styles)
        //     style.nodeId = this.nodeId;
    }



    isValid()
    {
        return this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.width  && this.width .isValid()
            && this.height && this.height.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.width ) this.width .pushValueUpdates(parse);
        if (this.height) this.height.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x     ) this.x     .invalidateInputs(parse, from);
        if (this.y     ) this.y     .invalidateInputs(parse, from);
        if (this.width ) this.width .invalidateInputs(parse, from);
        if (this.height) this.height.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.width ) this.width .iterateLoop(parse);
        if (this.height) this.height.iterateLoop(parse);
    }
}



function validateObjectRect(x, y, w, h, a = 0, _a = 0)
{
    if (w < 0)
    {
        x += w * Math.cos(_a);
        y += w * Math.sin(_a);
    }

    if (h < 0)
    {
        y += h * Math.cos(_a);
        x -= h * Math.sin(_a);
    }
  
    
    w = Math.abs(w);
    h = Math.abs(h);


    return [x, y, w, h, a, _a];
}


class GShape
extends GShapeBase
{
    input = null;

    props = null;
   


    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        if (base.input) this.input = base.input.copy();
        if (base.props) this.props = base.props.copy();
    }



    baseIsValid()
    {
        return this.props.isValid();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async evalShapeBase(parse)
    {
        let props = this.props ? (await this.props.eval(parse)).toValue() : null;

        if (   props
            && STYLE_VALUES.includes(props.type))
            props = new ListValue([props]);

        
        if (this.value)
        {
            if (this.input)
                this.value.props = props ?? this.input.value.props;
            else
                this.value.props = props;

                    
            if (   this.value
                && this.value.isValid()
                && this.value.props != undefined) 
            {
                this.setUpdateValues(parse, 
                [
                    ['props', this.value.props]
                ], 
                true);


                if (!this.props) this.props = this.value.props.copy();
            }
        }
    }



    async evalObjects(parse)
    {
        if (!this.value)
            return;


        for (const obj of this.value.objects)
        {
            consoleAssert(obj.fills,   'obj.fills must not be null'  );
            consoleAssert(obj.strokes, 'obj.strokes must not be null');
            consoleAssert(obj.effects, 'obj.effects must not be null');


            if (  !this.value.props
                || this.value.props.items == undefined) 
                continue;


            for (let i = this.value.props.items.length-1; i >= 0; i--)
            {
                const prop = this.value.props.items[i];
                
                     if (prop.type ==        COLOR_VALUE)  addColorProp      (obj, prop);
                else if (prop.type ==         FILL_VALUE)  addFillProp       (obj, prop);
                else if (prop.type ==     GRADIENT_VALUE)  addGradientProp   (obj, prop);
                else if (prop.type ==       STROKE_VALUE)  addStrokeProp     (obj, prop);
                else if (prop.type ==  DROP_SHADOW_VALUE)  addDropShadowProp (obj, prop);
                else if (prop.type == INNER_SHADOW_VALUE)  addInnerShadowProp(obj, prop);
                else if (prop.type ==   LAYER_BLUR_VALUE)  addLayerBlurProp  (obj, prop);
                else if (prop.type ==    BACK_BLUR_VALUE)  addBackBlurProp   (obj, prop);
                else if (prop.type ==   LAYER_MASK_VALUE)  addLayerMaskProp  (obj);
            }
        }
    }



    evalStyle(options = {})
    {

    }



    isValid()
    {
        return super.isValid()
            && (!this.input || this.input.isValid())
            && this.props && this.props.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.props) this.props.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.props) this.props.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.props) this.props.iterateLoop(parse);
    }
}


class GRectangle
extends GShape
{
    round = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    copy()
    {
        const copy = new GRectangle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round = this.round ? (await this.round.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new RectangleValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round);
        }
        else
        {
            this.value = new RectangleValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round);
        }

       
        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const rect = new FigmaRectangle(
                    this.nodeId, 
                    this.nodeId, 
                    this.nodeName, 
                    x, y, w, h, r);

                rect.createDefaultTransform(x, y);
                rect.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(rect);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const rect = new RectangleValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue());

        rect.props   = this.props.toValue();
        rect.objects = this.value.objects.map(o => o.copy());

        return rect;
    }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round) this.round.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
    }
}


class GLine
extends GShape
{
    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const copy = new GLine(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, ] = await this.evalBaseParams(parse, false);

            
        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new LineValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                width ?? input.width);
        }
        else
        {
            this.value = new LineValue(
                this.nodeId, 
                x, 
                y, 
                width);
        }


        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x    ) this.x     = this.value.x    .copy();
        if (!this.y    ) this.y     = this.value.y    .copy();
        if (!this.width) this.width = this.value.width.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x    .isValid()
            && this.value.y    .isValid()
            && this.value.width.isValid()) 
        {
            let x = this.value.x    .value;
            let y = this.value.y    .value;
            let w = this.value.width.value;


            [x, y, w, , , ] = validateObjectRect(x, y, w, 0);


            if (w != 0)
            {
                const line = new FigmaLine(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w);

                line.createDefaultTransform(x, y);
                line.createDefaultTransformPoints(x, y, w, 0.01);
                
                this.value.objects.push(line);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const line = new LineValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue());

        line.props   = this.props.toValue();
        line.objects = this.value.objects.map(o => o.copy());

        return line;
    }
}


class GEllipse
extends GShape
{
    from  = null;
    to    = null;
    inner = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    copy()
    {
        const copy = new GEllipse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from ) copy.from  = this.from .copy();
        if (this.to   ) copy.to    = this.to   .copy();
        if (this.inner) copy.inner = this.inner.copy();
        
        return copy;
    }


    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, height] = await this.evalBaseParams(parse);

        const from  = this.from  ? (await this.from .eval(parse)).toValue() : null;
        const to    = this.to    ? (await this.to   .eval(parse)).toValue() : null;
        const inner = this.inner ? (await this.inner.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new EllipseValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                from   ?? input.from,
                to     ?? input.to,
                inner  ?? input.inner);
        }
        else
        {
            this.value = new EllipseValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                from,
                to, 
                inner);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.from  ) this.from   = this.value.from  .copy();
        if (!this.to    ) this.to     = this.value.to    .copy();
        if (!this.inner ) this.inner  = this.value.inner .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()) 
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const f = this.value.from  .value;
            const t = this.value.to    .value;
            const i = this.value.inner .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const ellipse = new FigmaEllipse(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, f, t, i);

                ellipse.createDefaultTransform(x, y);
                ellipse.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(ellipse);
            }
        }

       
        await super.evalObjects(parse);
    }
   
    
        
    toValue()
    {
        const ellipse = new EllipseValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.from  .toValue(),
            this.to    .toValue(),
            this.inner .toValue());

        ellipse.props   = this.props.toValue();

        ellipse.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];
        
        return ellipse;
    }
    

    
    isValid()
    {
        return super.isValid()
            && this.from  && this.from .isValid()
            && this.to    && this.to   .isValid()
            && this.inner && this.inner.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
 
        if (this.from ) this.from .pushValueUpdates(parse);
        if (this.to   ) this.to   .pushValueUpdates(parse);
        if (this.inner) this.inner.pushValueUpdates(parse);
    }

   
        
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from ) this.from .invalidateInputs(parse, from);
        if (this.to   ) this.to   .invalidateInputs(parse, from);
        if (this.inner) this.inner.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
 
        if (this.from ) this.from .iterateLoop(parse);
        if (this.to   ) this.to   .iterateLoop(parse);
        if (this.inner) this.inner.iterateLoop(parse);
    }
}


class GTrapeze
extends GShape
{
    round = null;
    bias  = null;



    constructor(nodeId, options)
    {
        super(TRAPEZE, nodeId, options);
    }



    copy()
    {
        const copy = new GTrapeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();
        if (this.bias ) copy.bias  = this.bias .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round = this.round ? (await this.round.eval(parse)).toValue() : null;
        const bias  = this.bias  ? (await this.bias .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TrapezeValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round,
                bias   ?? input.bias);
        }
        else
        {
            this.value = new TrapezeValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round,
                bias);
        }

       
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()    
            && this.value.y     .isValid()    
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid()
            && this.value.bias  .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);
            let   b = this.value.bias  .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const trapeze = new FigmaTrapeze(
                    this.nodeId, 
                    this.nodeId, 
                    this.nodeName, 
                    x, y, w, h, r, b);

                trapeze.createDefaultTransform(x, y);
                trapeze.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(trapeze);
            }
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const trap = new TrapezeValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue(),
            this.bias  .toValue());

        trap.props   = this.props.toValue();
        trap.objects = this.value.objects.map(o => o.copy());

        return trap;
    }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid()
            && this.bias  && this.bias .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
        if (this.bias ) this.bias .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round) this.round.invalidateInputs(parse, from);
        if (this.bias ) this.bias .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
        if (this.bias ) this.bias .iterateLoop(parse);
    }
}


class GPolygon
extends GShape
{
    round   = null;
    corners = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    copy()
    {
        const copy = new GPolygon(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round  ) copy.round   = this.round  .copy();
        if (this.corners) copy.corners = this.corners.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round   = this.round   ? (await this.round  .eval(parse)).toValue() : null;
        const corners = this.corners ? (await this.corners.eval(parse)).toValue() : null;


        let input = null;
             
        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new PolygonValue(
                this.nodeId,
                x       ?? input.x,
                y       ?? input.y,
                width   ?? input.width,
                height  ?? input.height,
                round   ?? input.round,
                corners ?? input.corners);
        }
        else
        {
            this.value = new PolygonValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round, 
                corners);
        }

        
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x      ) this.x       = this.value.x      .copy();
        if (!this.y      ) this.y       = this.value.y      .copy();
        if (!this.width  ) this.width   = this.value.width  .copy();
        if (!this.height ) this.height  = this.value.height .copy();
        if (!this.round  ) this.round   = this.value.round  .copy();
        if (!this.corners) this.corners = this.value.corners.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x      .isValid()
            && this.value.y      .isValid()
            && this.value.width  .isValid()
            && this.value.height .isValid()
            && this.value.round  .isValid()
            && this.value.corners.isValid())
        {
            let   x = this.value.x      .value;
            let   y = this.value.y      .value;
            let   w = this.value.width  .value;
            let   h = this.value.height .value;
            const r = Math.max(0, this.value.round.value);
            const c = this.value.corners.value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const poly = new FigmaPolygon(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, c);

                poly.createDefaultTransform(x, y);
                poly.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(poly);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const poly = new PolygonValue(
            this.nodeId,
            this.x      .toValue(),
            this.y      .toValue(),
            this.width  .toValue(),
            this.height .toValue(),
            this.round  .toValue(),
            this.corners.toValue());

        poly.props   = this.props.toValue();
        poly.objects = this.value.objects.map(o => o.copy());

        return poly;
    }



    isValid()
    {
        return super.isValid()
            && this.round   && this.round  .isValid()
            && this.corners && this.corners.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round  ) this.round  .pushValueUpdates(parse);
        if (this.corners) this.corners.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round  ) this.round  .invalidateInputs(parse, from);
        if (this.corners) this.corners.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round  ) this.round  .iterateLoop(parse);
        if (this.corners) this.corners.iterateLoop(parse);
    }
}



class GStar
extends GShape
{
    round  = null;
    points = null;
    convex = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    copy()
    {
        const copy = new GStar(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round ) copy.round  = this.round .copy();
        if (this.points) copy.points = this.points.copy();
        if (this.convex) copy.convex = this.convex.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round  = this.round  ? (await this.round .eval(parse)).toValue() : null;
        const points = this.points ? (await this.points.eval(parse)).toValue() : null;
        const convex = this.convex ? (await this.convex.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new StarValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round,
                points ?? input.points,
                convex ?? input.convex);
        }
        else
        {
            this.value = new StarValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round, 
                points, 
                convex);
        }

             
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();
        if (!this.points) this.points = this.value.points.copy();
        if (!this.convex) this.convex = this.value.convex.copy();



        this.validate();

        return this;
   }



   async evalObjects(parse, options = {})
   {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid() 
            && this.value.round .isValid()
            && this.value.points.isValid()
            && this.value.convex.isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);
            const p = this.value.points.value;
            const c = this.value.convex.value;


            if (   w != 0
                && h != 0)
            {
                const star = new FigmaStar(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, p, c);

                star.createDefaultTransform(x, y);
                star.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(star);
            }
        }

       
        await super.evalObjects(parse);
    }



    toValue()
    {
        const star = new StarValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue(),
            this.points.toValue(),
            this.convex.toValue());
 
        star.props   = this.props.toValue();
        star.objects = this.value.objects.map(o => o.copy());
 
        return star;
    }



    isValid()
    {
        return super.isValid()
            && this.round  && this.round .isValid()
            && this.points && this.points.isValid()
            && this.convex && this.convex.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round ) this.round .pushValueUpdates(parse);
        if (this.points) this.points.pushValueUpdates(parse);
        if (this.convex) this.convex.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round ) this.round .invalidateInputs(parse, from);
        if (this.points) this.points.invalidateInputs(parse, from);
        if (this.convex) this.convex.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round ) this.round .iterateLoop(parse);
        if (this.points) this.points.iterateLoop(parse);
        if (this.convex) this.convex.iterateLoop(parse);
    }
}


class GTextShape
extends GShape
{
    text          = null;
    x             = null;
    y             = null;
    width         = null;
    height        = null;
    font          = null;
    size          = null;
    style         = null;
    alignH        = null;
    alignV        = null;
    lineHeight    = null;
    letterSpacing = null;



    constructor(nodeId, options)
    {
        super(TEXT_SHAPE, nodeId, options);
    }



    copy()
    {
        const copy = new GTextShape(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.text         ) copy.text          = this.text         .copy();
        if (this.x            ) copy.x             = this.x            .copy();
        if (this.y            ) copy.y             = this.y            .copy();
        if (this.width        ) copy.width         = this.width        .copy();
        if (this.height       ) copy.height        = this.height       .copy();
        if (this.font         ) copy.font          = this.font         .copy();
        if (this.style        ) copy.style         = this.style        .copy();
        if (this.size         ) copy.size          = this.size         .copy();
        if (this.alignH       ) copy.alignH        = this.alignH       .copy();
        if (this.alignV       ) copy.alignV        = this.alignV       .copy();
        if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();
        if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const text          = this.text          ? (await this.text         .eval(parse)).toValue() : null;
        const x             = this.x             ? (await this.x            .eval(parse)).toValue() : null;
        const y             = this.y             ? (await this.y            .eval(parse)).toValue() : null;
        const width         = this.width         ? (await this.width        .eval(parse)).toValue() : null;
        const height        = this.height        ? (await this.height       .eval(parse)).toValue() : null;
        const font          = this.font          ? (await this.font         .eval(parse)).toValue() : null;
        const style         = this.style         ? (await this.style        .eval(parse)).toValue() : null;
        const size          = this.size          ? (await this.size         .eval(parse)).toValue() : null;
        const alignH        = this.alignH        ? (await this.alignH       .eval(parse)).toValue() : null;
        const alignV        = this.alignV        ? (await this.alignV       .eval(parse)).toValue() : null;
        const lineHeight    = this.lineHeight    ? (await this.lineHeight   .eval(parse)).toValue() : null;
        const letterSpacing = this.letterSpacing ? (await this.letterSpacing.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TextShapeValue(
                this.nodeId,
                text          ?? input.text,
                x             ?? input.x,
                y             ?? input.y,
                width         ?? input.width,
                height        ?? input.height,
                font          ?? input.font,
                style         ?? input.style,
                size          ?? input.size,
                alignH        ?? input.size,
                alignV        ?? input.size,
                lineHeight    ?? input.size,
                letterSpacing ?? input.size);
        }
        else
        {
            this.value = new TextShapeValue(
                this.nodeId, 
                text, 
                x, 
                y, 
                this.width .type != NUMBER_VALUE ? width  : new NumberValue(0), 
                this.height.type != NUMBER_VALUE ? height : new NumberValue(0), 
                font, 
                style,
                size,
                alignH,
                alignV,
                lineHeight,
                letterSpacing);
        }

       
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.text         ) this.text          = this.value.text         .copy();
        if (!this.x            ) this.x             = this.value.x            .copy();
        if (!this.y            ) this.y             = this.value.y            .copy();
        if (!this.width        ) this.width         = this.value.width        .copy();
        if (!this.height       ) this.height        = this.value.height       .copy();
        if (!this.font         ) this.font          = this.value.font         .copy();
        if (!this.style        ) this.style         = this.value.style        .copy();
        if (!this.size         ) this.size          = this.value.size         .copy();
        if (!this.alignH       ) this.alignH        = this.value.alignH       .copy();
        if (!this.alignV       ) this.alignV        = this.value.alignV       .copy();
        if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();
        if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;

        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.text         .isValid()
            && this.value.x            .isValid()
            && this.value.y            .isValid()
            && this.value.width        .isValid()
            && this.value.height       .isValid()
            && this.value.font         .isValid()
            && this.value.style        .isValid()
            && this.value.size         .isValid()
            && this.value.alignH       .isValid()
            && this.value.alignV       .isValid()
            && this.value.lineHeight   .isValid()
            && this.value.letterSpacing.isValid())
        {
            let x = this.value.x     .value;
            let y = this.value.y     .value;
            let w = this.value.width .value;
            let h = this.value.height.value;

            const fontName   = figUniqueFontNames[this.value.font.value];
            const fontStyles = getFontStyles(fontName);

            const text = new FigmaText(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                this.value.text.value,
                x, y, w, h,
                fontName,
                this.value.size         .value,
                fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],
                this.value.alignH       .value,
                this.value.alignV       .value,
                this.value.lineHeight   .value,
                this.value.letterSpacing.value);


            text.createDefaultTransform(x, y);
 
            if (   text.width  == 0
                && text.height == 0)
            {
                const {objectId, width, height} = await genGetObjectSizeFromFigma(text.toData());

                text.width  = width;
                text.height = height;

                this.value.width.value  = width;
                this.value.height.value = height;

                text.createDefaultTransformPoints(x, y, width, height);

                this.value.objects.push(text);
            }
            else
            {
                text.createDefaultTransformPoints(x, y, w, h)

                this.value.objects.push(text);
            }
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.text          && this.text         .isValid()
            && this.x             && this.x            .isValid()
            && this.y             && this.y            .isValid()
            && this.width         && this.width        .isValid()
            && this.height        && this.height       .isValid()
            && this.font          && this.font         .isValid()
            && this.style         && this.style        .isValid()
            && this.size          && this.size         .isValid()
            && this.alignH        && this.alignH       .isValid()
            && this.alignV        && this.alignV       .isValid()
            && this.lineHeight    && this.lineHeight   .isValid()
            && this.letterSpacing && this.letterSpacing.isValid();
    }



    toValue()
    {
        const text = new TextShapeValue(
            this.nodeId,
            
            this.text         .toValue(),
            
            this.x            .toValue(),
            this.y            .toValue(),
            
            this.width        .toValue(),
            this.height       .toValue(),
            
            this.font         .toValue(),
            this.style        .toValue(),
            this.size         .toValue(),
            
            this.alignH       .toValue(),
            this.alignV       .toValue(),
            
            this.lineHeight   .toValue(),
            this.letterSpacing.toValue());

            
        text.props = this.props.toValue();

        text.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];

        
        return text;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
        
        if (this.text         ) this.text         .pushValueUpdates(parse);
        if (this.x            ) this.x            .pushValueUpdates(parse);
        if (this.y            ) this.y            .pushValueUpdates(parse);
        if (this.width        ) this.width        .pushValueUpdates(parse);
        if (this.height       ) this.height       .pushValueUpdates(parse);
        if (this.font         ) this.font         .pushValueUpdates(parse);
        if (this.style        ) this.style        .pushValueUpdates(parse);
        if (this.size         ) this.size         .pushValueUpdates(parse);
        if (this.alignH       ) this.alignH       .pushValueUpdates(parse);
        if (this.alignV       ) this.alignV       .pushValueUpdates(parse);
        if (this.lineHeight   ) this.lineHeight   .pushValueUpdates(parse);
        if (this.letterSpacing) this.letterSpacing.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);
        
        if (this.text         ) this.text         .invalidateInputs(parse, from);
        if (this.x            ) this.x            .invalidateInputs(parse, from);
        if (this.y            ) this.y            .invalidateInputs(parse, from);
        if (this.width        ) this.width        .invalidateInputs(parse, from);
        if (this.height       ) this.height       .invalidateInputs(parse, from);
        if (this.font         ) this.font         .invalidateInputs(parse, from);
        if (this.style        ) this.style        .invalidateInputs(parse, from);
        if (this.size         ) this.size         .invalidateInputs(parse, from);
        if (this.alignH       ) this.alignH       .invalidateInputs(parse, from);
        if (this.alignV       ) this.alignV       .invalidateInputs(parse, from);
        if (this.lineHeight   ) this.lineHeight   .invalidateInputs(parse, from);
        if (this.letterSpacing) this.letterSpacing.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
        
        if (this.text         ) this.text         .iterateLoop(parse);
        if (this.x            ) this.x            .iterateLoop(parse);
        if (this.y            ) this.y            .iterateLoop(parse);
        if (this.width        ) this.width        .iterateLoop(parse);
        if (this.height       ) this.height       .iterateLoop(parse);
        if (this.font         ) this.font         .iterateLoop(parse);
        if (this.style        ) this.style        .iterateLoop(parse);
        if (this.size         ) this.size         .iterateLoop(parse);
        if (this.alignH       ) this.alignH       .iterateLoop(parse);
        if (this.alignV       ) this.alignV       .iterateLoop(parse);
        if (this.lineHeight   ) this.lineHeight   .iterateLoop(parse);
        if (this.letterSpacing) this.letterSpacing.iterateLoop(parse);
    }
}


class GPoint
extends GOperator1
{
    x = null;
    y = null;



    constructor(nodeId, options)
    {
        super(POINT, nodeId, options);
    }



    copy()
    {
        const copy = new GPoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const x = this.x ? (await this.x.eval(parse)).toValue() : null;
        const y = this.y ? (await this.y.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new PointValue(
                this.nodeId,
                x ?? input.x,
                y ?? input.y);
        }
        else
        {
            this.value = new PointValue(
                this.nodeId, 
                x, 
                y);
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        if (!this.x) this.x = this.value.x.copy();
        if (!this.y) this.y = this.value.y.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const point = new PointValue(
            this.nodeId,
            this.x.toValue(),
            this.y.toValue());

        point.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];

        return point;
    }



    isValid()
    {
        return super.isValid()
            && this.x && this.x.isValid()
            && this.y && this.y.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x) this.x.pushValueUpdates(parse);
        if (this.y) this.y.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x) this.x.invalidateInputs(parse, from);
        if (this.y) this.y.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x) this.x.iterateLoop(parse);
        if (this.y) this.y.iterateLoop(parse);
    }
}


class GVectorPath
extends GShape
{
    points  = null;
    closed  = null;
    degree  = null;
    winding = null;
    round   = null;



    constructor(nodeId, options)
    {
        super(VECTOR_PATH, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.points ) copy.points  = this.points .copy();
        if (this.closed ) copy.closed  = this.closed .copy();
        if (this.degree ) copy.degree  = this.degree .copy();
        if (this.winding) copy.winding = this.winding.copy();
        if (this.round  ) copy.round   = this.round  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const points  = this.points  ? (await this.points .eval(parse)).toValue() : null;
        const closed  = this.closed  ? (await this.closed .eval(parse)).toValue() : null;
        const degree  = this.degree  ? (await this.degree .eval(parse)).toValue() : null;
        const winding = this.winding ? (await this.winding.eval(parse)).toValue() : null;
        const round   = this.round   ? (await this.round  .eval(parse)).toValue() : null;

        
        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new VectorPathValue(
                this.nodeId,
                points  ?? input.points,
                closed  ?? input.closed,
                degree  ?? input.degree,
                winding ?? input.winding,
                round   ?? input.round);
        }
        else
        {
            this.value = new VectorPathValue(
                this.nodeId, 
                points, 
                closed, 
                degree, 
                winding, 
                round);
        }

        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.points ) this.points  = this.value.points .copy();
        if (!this.closed ) this.closed  = this.value.closed .copy();
        if (!this.degree ) this.degree  = this.value.degree .copy();
        if (!this.winding) this.winding = this.value.winding.copy();
        if (!this.round  ) this.round   = this.value.round  .copy();



        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        const points = [];

        if (this.value.points.objects)
        {
            const objPoints = this.value.points.objects.filter(o => o.type == POINT);

            for (const pt of objPoints)
                points.push(PointValue.create(this.nodeId, pt.x, pt.y));
        }


        this.value.objects = [];


        if (   super.baseIsValid()   
            && points.length >= 2
            && this.value.closed .isValid()
            && this.value.degree .isValid()
            && this.value.winding.isValid()
            && this.value.round  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                this.value.closed .value,
                this.value.degree .value,
                this.value.winding.value,
                this.value.round  .value);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;

            
            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const path = new VectorPathValue(
            this.nodeId,
            this.points .toValue(),
            this.closed .toValue(),
            this.degree .toValue(),
            this.winding.toValue(),
            this.round  .toValue());

        path.props   = this.props.toValue();
        path.objects = this.value.objects.map(o => o.copy());

        return path;
    }



    isValid()
    {
        return super.isValid()
            && this.points  && this.points .isValid()
            && this.closed  && this.closed .isValid()
            && this.degree  && this.degree .isValid()
            && this.winding && this.winding.isValid()
            && this.round   && this.round  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.points ) this.points .pushValueUpdates(parse);
        if (this.closed ) this.closed .pushValueUpdates(parse);
        if (this.degree ) this.degree .pushValueUpdates(parse);
        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.round  ) this.round  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.points ) this.points .invalidateInputs(parse, from);
        if (this.closed ) this.closed .invalidateInputs(parse, from);
        if (this.degree ) this.degree .invalidateInputs(parse, from);
        if (this.winding) this.winding.invalidateInputs(parse, from);
        if (this.round  ) this.round  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.points ) this.points .iterateLoop(parse);
        if (this.closed ) this.closed .iterateLoop(parse);
        if (this.degree ) this.degree .iterateLoop(parse);
        if (this.winding) this.winding.iterateLoop(parse);
        if (this.round  ) this.round  .iterateLoop(parse);
    }
}


class GVectorVertex
extends GOperator1
{
    x     = null;
    y     = null;
    join  = null;
    cap   = null;
    round = null;



    constructor(nodeId, options)
    {
        super(VECTOR_VERTEX, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorVertex(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();
        if (this.join ) copy.join  = this.join .copy();
        if (this.cap  ) copy.cap   = this.cap  .copy();
        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const x     = this.x     ? (await this.x    .eval(parse)).toValue() : null;
        const y     = this.y     ? (await this.y    .eval(parse)).toValue() : null;
        const join  = this.join  ? (await this.join .eval(parse)).toValue() : null;
        const cap   = this.cap   ? (await this.cap  .eval(parse)).toValue() : null;
        const round = this.round ? (await this.round.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new VectorVertexValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                join  ?? input.join,
                cap   ?? input.cap,
                round ?? input.round);
        }
        else
        {
            this.value = new VectorVertexValue(
                this.nodeId, 
                x, 
                y, 
                join, 
                cap, 
                round);
        }

       
        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x    
            && this.value.y    
            && this.value.join 
            && this.value.cap  
            && this.value.round)
        {
            const x     = this.value.x    .value;
            const y     = this.value.y    .value;
            //const join  = this.value.join .value;
            //const cap   = this.value.cap  .value;
            //const round = this.value.round.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const point = new VectorVertexValue(
            this.nodeId,
            this.x    .toValue(),
            this.y    .toValue(),
            this.join .toValue(),
            this.cap  .toValue(),
            this.round.toValue());

        point.objects  = this.value.objects.map(o => o.copy());
        point.uniqueId = this.value.uniqueId;

        return point;
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x    ) this.x    .pushValueUpdates(parse);
        if (this.y    ) this.y    .pushValueUpdates(parse);
        if (this.join ) this.join .pushValueUpdates(parse);
        if (this.cap  ) this.cap  .pushValueUpdates(parse);
        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x    ) this.x    .invalidateInputs(parse, from);
        if (this.y    ) this.y    .invalidateInputs(parse, from);
        if (this.join ) this.join .invalidateInputs(parse, from);
        if (this.cap  ) this.cap  .invalidateInputs(parse, from);
        if (this.round) this.round.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x    ) this.x    .iterateLoop(parse);
        if (this.y    ) this.y    .iterateLoop(parse);
        if (this.join ) this.join .iterateLoop(parse);
        if (this.cap  ) this.cap  .iterateLoop(parse);
        if (this.round) this.round.iterateLoop(parse);
    }
}


class GVectorEdge
extends GOperator1
{
    input0       = null;
    input1       = null;

    startTangent = null;
    endTangent   = null;



    constructor(nodeId, options)
    {
        super(VECTOR_EDGE, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorEdge(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0      ) copy.input0       = this.input0      .copy();
        if (this.input1      ) copy.input1       = this.input1      .copy();
        if (this.startTangent) copy.startTangent = this.startTangent.copy();
        if (this.endTangent  ) copy.endTangent   = this.endTangent  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input0       = this.input0       ? (await this.input0      .eval(parse)).toValue() : VectorVertexValue.NaN;
        const input1       = this.input1       ? (await this.input1      .eval(parse)).toValue() : VectorVertexValue.NaN;
        const startTangent = this.startTangent ? (await this.startTangent.eval(parse)).toValue() : PointValue.NaN;
        const   endTangent = this.  endTangent ? (await this.  endTangent.eval(parse)).toValue() : PointValue.NaN;


        this.value = new VectorEdgeValue(
            this.nodeId,
            input0,
            input1,
            startTangent,
              endTangent);


        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.start.isValid()
            || !this.value.end  .isValid())
            return;
            
            
        this.value.objects = [];


        if (   this.value.start.isValid()
            && this.value.end  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                [ this.value.start,
                  this.value.startTangent.isValid() ? this.value.startTangent : this.value.start,
                  this.value.endTangent  .isValid() ? this.value.  endTangent : this.value.end,
                  this.value.end ],
                0,
                2, // cubic
                0,
                0);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const edge = new VectorEdgeValue(
            this.nodeId,
            this.input0 ? this.input0.toValue() : VectorVertexValue.NaN,
            this.input1 ? this.input1.toValue() : VectorVertexValue.NaN,
            this.startTangent.toValue(),
            this.endTangent  .toValue());

        edge.uniqueId = this.value.uniqueId;
        edge.objects  = this.value.objects.map(o => o.copy());

        return edge;
    }



    isValid()
    {
        return super.isValid()
            && this.input0      .isValid()
            && this.input1      .isValid()
            && this.startTangent.isValid()
            && this.endTangent  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0      ) this.input0      .pushValueUpdates(parse);
        if (this.input1      ) this.input1      .pushValueUpdates(parse);
        if (this.startTangent) this.startTangent.pushValueUpdates(parse);
        if (this.endTangent  ) this.endTangent  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input0      ) this.input0      .invalidateInputs(parse, from);
        if (this.input1      ) this.input1      .invalidateInputs(parse, from);
        if (this.startTangent) this.startTangent.invalidateInputs(parse, from);
        if (this.endTangent  ) this.endTangent  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0      ) this.input0      .iterateLoop(parse);
        if (this.input1      ) this.input1      .iterateLoop(parse);
        if (this.startTangent) this.startTangent.iterateLoop(parse);
        if (this.endTangent  ) this.endTangent  .iterateLoop(parse);
    }
}


class GVectorRegion
extends GShape
{
    inputs  = [];

    loops   = null;
    winding = null;



    constructor(nodeId, options)
    {
        super(VECTOR_REGION, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorRegion(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.winding) copy.winding = this.winding.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached()
            && this.winding.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const winding = this.winding ? (await this.winding.eval(parse)).toValue() : null;


        this.loops = new ListValue();


        const loop = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(input.type))
            {
                const _loop = new ListValue();

                for (const item of input.items)
                {
                    if (item.type == VECTOR_EDGE_VALUE)
                        _loop.items.push(item);
                }

                if (!isEmpty(_loop.items))
                    loops.items.push(_loop);
            }
            else
            {
                consoleAssert(
                     input.type == VECTOR_EDGE_VALUE, 
                    'input.type must be VECTOR_EDGE_VALUE');

                loop.items.push(input);
            }
        }


        if (!isEmpty(loop.items))
            this.loops.items.push(loop);


        this.value = new VectorRegionValue(
            this.nodeId,
            this.loops, 
            winding);


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['winding', winding   ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];

        
        if (   this.loops  .isValid()
            && this.winding.isValid())
        {
            const regions = [];


            for (let i = 0; i < this.loops.items.length; i++)
            {
                const loop = this.loops.items[i];


                const points = [];
    
                for (let j = 0; j < loop.items.length; j++)
                {
                    const edge = loop.items[j  ];
                    const next = loop.items[j == loop.items.length-1 ? 0 : j+1];

                    points.push(
                           edge.start.uniqueId == next.start.uniqueId
                        || edge.start.uniqueId == next.end  .uniqueId
                        ? edge.end  
                        : edge.start);
                }


                regions.push(new FigmaVectorPath(
                    this.nodeId,
                    this.nodeId + '/' + i,
                    this.nodeName,
                    points,
                    1,
                    0, // linear
                    this.winding.value,
                    0));
            }
            

            let bounds = getObjBounds(regions);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            for (const region of regions)
            {
                region.createDefaultTransform(x, y);
                region.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(region);
            }
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const region = new VectorRegionValue(
            this.nodeId,
            this.loops  .toValue(),
            this.winding.toValue(),
            this.props  .toValue());

        region.uniqueId = this.value.uniqueId;
        region.objects  = this.value.objects.map(o => o.copy());

        return region;
    }



    isValid()
    {
        if (!super.isValid())
            return false;
            
        for (const input of this.inputs)
            if (!input.isCached())
                return false;
        
        return this.winding.isValid()
            && this.props  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.props  ) this.props  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));

        if (this.winding) this.winding.invalidateInputs(parse, from);
        if (this.props  ) this.props  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.winding) this.winding.iterateLoop(parse);
        if (this.props  ) this.props  .iterateLoop(parse);
    }
}


class GVectorNetwork
extends GShape
{
    inputs  = [];



    constructor(nodeId, options)
    {
        super(VECTOR_NETWORK, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorNetwork(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const regions = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            consoleAssert(
                 input.type == VECTOR_REGION_VALUE, 
                'input.type must be VECTOR_REGION_VALUE');

            regions.items.push(input);
        }


        this.value = new VectorNetworkValue(
            this.nodeId,
            regions);


        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);

        
        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];


        if (!isEmpty(this.value.regions.items))
        {
            let points  = [];
            let edges   = [];
            let regions = [];


            for (const region of this.value.regions.items)
            {
                if (!isEmpty(region.objects))
                    region.fills = region.objects[0].fills;


                if (region.loops)
                {
                    for (const loop of region.loops.items)
                    {
                        for (const edge of loop.items)
                        {
                            pushUniqueBy(points, edge.start, p => p.uniqueId == edge.start.uniqueId);
                            pushUniqueBy(points, edge.end,   p => p.uniqueId == edge.end  .uniqueId);

                            pushUniqueBy(edges, edge, e => e.uniqueId == edge.uniqueId);
                        }
                    }

                    pushUniqueBy(regions, region, r => r.uniqueId == region.uniqueId);
                }
            }

            
            const network = new FigmaVectorNetwork(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                edges,
                regions);

            
            const bounds = getObjBounds([network]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            network.createDefaultTransform(x, y);
            network.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(network);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const network = new VectorNetworkValue(
            this.nodeId,
            this.regions.toValue());

        network.uniqueId = this.value.uniqueId;
        network.objects  = this.value.objects.map(o => o.copy());

        return network;
    }



    isValid()
    {
        return super.isValid()
            && this.regions.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GShapeGroup
extends GShapeBase
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(SHAPE_GROUP, nodeId, options);
    }



    copy()
    {
        const copy = new GShapeGroup(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ShapeGroupValue(this.nodeId);


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            
            // first copy the input objects

            // if (this.options.enabled)
            // {
            //     for (let j = 0; j < this.inputs[i].objects.length; j++, o++)
            //     {
            //         const obj = copyFigmaObject(this.inputs[i].objects[j]);

            //         obj.nodeId   = this.nodeId;
            //         obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            //         obj.listId   = -1;

            //         this.value.objects.push(obj);
            //     }
            // }


            // now create the output value

            if (   input
                && this.options.enabled)            
            {
                if (   input.type == SHAPE_LIST_VALUE
                    || input.type == LIST_VALUE)
                {
                    for (const item of input.items)
                    {
                        if (!SHAPE_VALUES.includes(item.type))
                            continue;

                        this.value.items.push(item.copy());   
                        //this.value.objects.push(...item.objects.map(o => this.copyObject(o, i)));
                    }
                }
                else
                {
                    this.value.items.push(input.copy());
                    //this.value.objects.push(...input.objects.map(o => this.copyObject(o, i)));
                }
            }
        }


        this.setUpdateValues(parse, [['value', this.value]]);


        //await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (this.value.items)
        {
            const group = new FigmaShapeGroup(
                this.nodeId,
                this.nodeId,
                this.nodeName);


            for (const item of this.value.items)
            {
                for (let i = 0; i < item.objects.length; i++)
                {
                    const obj = item.objects[i].copy();

                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;

                    group.children.push(obj);
                }
            }

            this.value.objects = [group];
        }
        else
        {
            this.value.objects = [];
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        if (!super.isValid()) 
            return false;

        for (const input of this.inputs)
            if (!input.isValid())
                return false;

        return true;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GFrame
extends GShape
{
    round    = null;
    children = null;



    constructor(nodeId, options)
    {
        super(FRAME, nodeId, options);
    }



    copy()
    {
        const copy = new GFrame(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round   ) copy.round    = this.round   .copy();
        if (this.children) copy.children = this.children.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round    = this.round    ? (await this.round   .eval(parse)).toValue() : null;
        let   children = this.children ? (await this.children.eval(parse)).toValue() : null;

        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
            children = new ListValue([children]);


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new FrameValue(
                this.nodeId,
                x        ?? input.x,
                y        ?? input.y,
                width    ?? input.width,
                height   ?? input.height,
                round    ?? input.round,
                children ?? input.children);
        }
        else
        {
            this.value = new FrameValue(
                this.nodeId, 
                x, 
                y, 
                width,
                height, 
                round, 
                children);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.children) this.children = this.value.children.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (   this.value.x
            && this.value.y
            && this.value.width
            && this.value.height
            && this.value.round)
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);


            const frame = new FigmaFrame(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x, y, w, h, r);


            // if (LIST_VALUES.includes(this.value.type))
            // {
            //     console.log('this.value.children =', this.value.children);
            //     for (let i = 0; i < this.value.children.objects.length; i++)
            //         this.addChildObject(frame.children, this.value.children.objects[i]);
            // }
            // else
            // {
                for (let i = 0; i < this.value.objects.length; i++)
                    this.addChildObject(frame.children, this.value.objects[i]);
            // }


            frame.createDefaultTransform(x, y);
            frame.createDefaultTransformPoints(x, y, w, h);
        
            this.value.objects = [frame];

            
            this.setUpdateValues(parse, 
            [
                ['nChildren', new NumberValue(frame.children.length)]
            ], 
            true);
        }


        await super.evalObjects(parse);
    }



    addChildObject(objects, _obj)
    {
        const obj = copyFigmaObject(_obj);
                    
        obj.nodeId   = this.nodeId;
        obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        obj.listId   = -1;
        
        objects.push(obj);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.round    && this.round   .isValid()
            && this.children && this.children.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.children) this.children.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round   ) this.round   .invalidateInputs(parse, from);
        if (this.children) this.children.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.children) this.children.iterateLoop(parse);
    }
}


class GApply
extends GShape
{
    constructor(nodeId, options)
    {
        super(SHAPE_APPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GApply(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [, , , ] = await this.evalBaseParams(parse);


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = input.copy();

            if (this.options.enabled)
                await this.evalShapeBase(parse);

            await this.evalObjects(parse);
        }
        else
        {
            await this.evalShapeBase(parse); // to updated anything connected to styles
            this.value = NullValue.copy();
        }

       
        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (this.value.isValid())
        {
            this.value.objects = 
                   this.input 
                && this.input.value
                ? this.input.value.objects.map(o => o.copy()) 
                : [];
        }

            
        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

            if (this.options.enabled)
            {
                obj.fills   = [];
                obj.strokes = [];
                obj.effects = [];

                obj.isMask  = false;
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}


class GShapeBoolean
extends GShapeBase
{
    input     = null;

    operation = null
    children  = null;



    constructor(nodeId, options)
    {
        super(BOOLEAN, nodeId, options);
    }



    copy()
    {
        const copy = new GShapeBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.operation) copy.operation = this.operation.copy();
        if (this.children ) copy.children  = this.children .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        await this.evalBaseParams(parse);

        const operation = this.operation ? (await this.operation.eval(parse)).toValue() : null;
        let   children  = this.children  ? (await this.children .eval(parse)).toValue() : null;


        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
            children = new ListValue([children]);


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new ShapeBooleanValue(
                this.nodeId,
                operation ?? input.operation,
                children  ?? input.children);
        }
        else
        {
            this.value = new ShapeBooleanValue(
                this.nodeId, 
                operation,
                children);
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value          ],
            ['operation', this.value.operation],
            ['children',  this.value.children ]
        ]);


        await this.evalShapeBase(parse);

        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (this.value.children)
        {
            const bool = new FigmaBoolean(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                this.operation);


            if (this.children.objects)
            {
                for (let i = 0; i < this.children.objects.length; i++)
                {
                    const obj    = this.children.objects[i].copy();
                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;
                    bool.children.push(obj);
                }
            }


            this.value.objects = [bool];

            this.updateValues.push(['nObjects', new NumberValue(
                this.children.objects 
                ? this.children.objects.length
                : 0)]);
        }
        else
        {
            this.value.objects = [];
            this.updateValues.push(['nObjects', new NumberValue(0)]);
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.children.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input   ) this.input   .pushValueUpdates(parse);
        if (this.children) this.children.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input   ) this.input   .invalidateInputs(parse, from);
        if (this.children) this.children.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input   ) this.input   .iterateLoop(parse);
        if (this.children) this.children.iterateLoop(parse);
    }
}














class GRender
extends GShapeBase
{
    inputs = [];

    retain = null;

    finalize;



    constructor(nodeId, options)
    {
        super(RENDER, nodeId, options);
    }



    copy()
    {
        const copy = new GRender(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const retain   = (await this.retain.eval(parse)).toValue();
        const finalize = this.finalize.value > 0;


        this.value = new ListValue();


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);

        
            if (   this.options.enabled
                && (   finalize
                    || retain.value == 1))
            {
                for (let j = 0; j < this.inputs[i].value.objects.length; j++, o++)
                {
                    let obj = this.inputs[i].value.objects[j];

                    obj = copyFigmaObject(obj);

                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;


                    if (  (   !isEmpty(obj.fills  )
                           || !isEmpty(obj.strokes))
                        && !obj.isDeco)
                        // && (   finalize
                        //     || retain.value == 1))
                            obj.retain = finalize ? 2 : 1;
                            

                    this.value.objects.push(obj);
                }
            }
        }


        this.setUpdateValues(parse, [['', NullValue]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && !this.inputs.find(i => !i.isValid())
            && this.retain && this.retain.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.retain) this.retain.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));

        if (this.retain) this.retain.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.retain) this.retain.iterateLoop(parse);
    }
}


class GMove
extends GOperator1
{
    x           = null;
    y           = null;
    moveType    = null;
    affectSpace = null;
    showCenter  = null;



    constructor(nodeId, options)
    {
        super(MOVE, nodeId, options);
    }



    copy()
    {
        const copy = new GMove(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x          ) copy.x           = this.x          .copy();
        if (this.y          ) copy.y           = this.y          .copy();
        if (this.moveType   ) copy.moveType    = this.moveType   .copy();
        if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();
        if (this.showCenter ) copy.showCenter  = this.showCenter .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x           = this.x           ? (await this.x          .eval(parse)).toValue() : null;
        const y           = this.y           ? (await this.y          .eval(parse)).toValue() : null;
        const moveType    = this.moveType    ? (await this.moveType   .eval(parse)).toValue() : null;
        const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).toValue() : null;
        const showCenter  = this.showCenter  ? (await this.showCenter .eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }


        await this.evalObjects(
            parse, 
            {
                x:           x, 
                y:           y,
                moveType:    moveType,
                showCenter:  showCenter,
                affectSpace: affectSpace
            });


        this.setUpdateValues(parse,
        [
            ['x',           x          ],
            ['y',           y          ],
            ['moveType',    moveType   ],
            ['affectSpace', affectSpace],
            ['showCenter',  showCenter ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);

            
            const bounds = getObjBounds(this.value.objects);


            const x           = options.x          .value;
            const y           = options.y          .value;
            const moveType    = options.moveType   .value;
            const affectSpace = options.affectSpace.value;
            const showCenter  = options.showCenter .value;


            const _a = y/360*Tau;
            const _v = vector(_a, x);
            
            const _x = moveType == 0 ? x : _v.x;
            const _y = moveType == 0 ? y : _v.y;


            const singlePoint = 
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            let _cx = 50;
            let _cy = 50;

            if (!singlePoint)
            {
                _cx /= 100;
                _cy /= 100;
            }


            const cx = singlePoint ? this.value.objects[0].x + _cx : bounds.x + _cx * bounds.width;
            const cy = singlePoint ? this.value.objects[0].y + _cy : bounds.y + _cy * bounds.height;

            const xform = 
                moveType == 0
                ? createTransform(_x, _y)
                : mulm3m3(
                    createTransform(cx, cy),
                    createTransform(_x, _y),
                    createRotateTransform(-_a), // for vector movement
                    createTransform(-cx, -cy));

                
            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.applyTransform(xform, affectSpace > 0);
            }


            if (showCenter > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.x           && this.x          .isValid()
            && this.y           && this.y          .isValid()
            && this.moveType    && this.moveType   .isValid()
            && this.affectSpace && this.affectSpace.isValid()
            && this.showCenter  && this.showCenter .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x          ) this.x          .pushValueUpdates(parse);
        if (this.y          ) this.y          .pushValueUpdates(parse);
        if (this.moveType   ) this.moveType   .pushValueUpdates(parse);
        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
        if (this.showCenter ) this.showCenter .pushValueUpdates(parse);
    }



   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x          ) this.x          .invalidateInputs(parse, from);
        if (this.y          ) this.y          .invalidateInputs(parse, from);
        if (this.moveType   ) this.moveType   .invalidateInputs(parse, from);
        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from);
        if (this.showCenter ) this.showCenter .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x          ) this.x          .iterateLoop(parse);
        if (this.y          ) this.y          .iterateLoop(parse);
        if (this.moveType   ) this.moveType   .iterateLoop(parse);
        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
        if (this.showCenter ) this.showCenter .iterateLoop(parse);
    }
}


class GAffine
extends GOperator1
{
    showCenter  = null;
    affectSpace = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.showCenter ) this.showCenter  = base.showCenter .copy();
        if (base.affectSpace) this.affectSpace = base.affectSpace.copy();
    }



    async evalBaseParams(parse)
    {
        const showCenter  = this.showCenter  ? (await this.showCenter .eval(parse)).toValue() : null;
        const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).toValue() : null;

        return [showCenter, affectSpace];
    }



    async evalAffineObjects(parse, options, scaleCorners, scaleStyle, getXform)
    {
        if (   !this.value
            || !this.value.isValid())
            return Rect.NaN;


        this.value.objects = getValidObjects(this.input.value);
        

        const bounds = getObjBounds(this.value.objects);
        const xform  = getXform();


        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


            if (this.options.enabled)
            {
                obj.applyTransform(xform, options.affectSpace.value > 0);

                obj.scaleCorners *= Math.abs(scaleCorners);
                obj.scaleStyle   *= Math.abs(scaleStyle  );
            }
        }


        if (options.showCenter.value > 0)
        {
            const objects = [...this.value.objects]; // avoids infinite growth
            objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
        }


        return bounds;
    }



    isValid()
    {
        return super.isValid()
            && this.showCenter  && this.showCenter .isValid()
            && this.affectSpace && this.affectSpace.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.showCenter ) this.showCenter .pushValueUpdates(parse);
        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.showCenter ) this.showCenter .invalidateInputs(parse, from);
        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.showCenter ) this.showCenter .iterateLoop(parse);
        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
    }
}


class GRotate
extends GAffine
{
    angle = null;



    constructor(nodeId, options)
    {
        super(ROTATE, nodeId, options);
    }



    copy()
    {
        const copy = new GRotate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.angle) copy.angle = this.angle.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const angle = this.angle ? (await this.angle.eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                angle:       angle, 
                showCenter:  showCenter,
                affectSpace: affectSpace
            });

        
        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['angle',       angle      ],
            ['showCenter',  showCenter ],
            ['affectSpace', affectSpace],
            ['bounds',      bounds     ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const a = options.angle.value/360*Tau;

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 
            1,
            () => createRotateTransform(a));
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.angle && this.angle.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.angle) this.angle.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from)

        if (this.angle) this.angle.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.angle) this.angle.iterateLoop(parse);
    }
}


class GScale
extends GAffine
{
    scaleX        = null;
    scaleY        = null;
    affectCorners = null;
    affectStyle   = null;



    constructor(nodeId, options)
    {
        super(SCALE, nodeId, options);
    }



    copy()
    {
        const copy = new GScale(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();
        if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();
        if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();
        if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const scaleX        = this.scaleX        ? (await this.scaleX       .eval(parse)).toValue() : null;
        const scaleY        = this.scaleY        ? (await this.scaleY       .eval(parse)).toValue() : null;
        const affectCorners = this.affectCorners ? (await this.affectCorners.eval(parse)).toValue() : null;
        const affectStyle   = this.affectStyle   ? (await this.affectStyle  .eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                scaleX:        scaleX, 
                scaleY:        scaleY, 
                showCenter:    showCenter,
                affectSpace:   affectSpace,
                affectCorners: affectCorners,
                affectStyle:   affectStyle
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['scaleX',        scaleX       ],
            ['scaleY',        scaleY       ],
            ['showCenter',    showCenter   ],
            ['affectSpace',   affectSpace  ],
            ['affectCorners', affectCorners],
            ['affectStyle',   affectStyle  ],
            ['bounds',        bounds       ]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const sx    = options.scaleX.value / 100;
        const sy    = options.scaleY.value / 100;

        const scale = Math.min(sx, sy);

        return await this.evalAffineObjects(
            parse,
            options, 
            this.affectCorners.value > 0 ? scale : 1,
            this.affectStyle  .value > 0 ? scale : 1,
            () => [[sx, 0,  0],
                   [0,  sy, 0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.scaleX        && this.scaleX       .isValid()
            && this.scaleY        && this.scaleY       .isValid()
            && this.affectCorners && this.affectCorners.isValid()
            && this.affectStyle   && this.affectStyle  .isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.scaleX       ) this.scaleX       .pushValueUpdates(parse);
        if (this.scaleY       ) this.scaleY       .pushValueUpdates(parse);
        if (this.affectCorners) this.affectCorners.pushValueUpdates(parse);
        if (this.affectStyle  ) this.affectStyle  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.scaleX       ) this.scaleX       .invalidateInputs(parse, from);
        if (this.scaleY       ) this.scaleY       .invalidateInputs(parse, from);
        if (this.affectCorners) this.affectCorners.invalidateInputs(parse, from);
        if (this.affectStyle  ) this.affectStyle  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.scaleX       ) this.scaleX       .iterateLoop(parse);
        if (this.scaleY       ) this.scaleY       .iterateLoop(parse);
        if (this.affectCorners) this.affectCorners.iterateLoop(parse);
        if (this.affectStyle  ) this.affectStyle  .iterateLoop(parse);
    }
}


class GSkew
extends GAffine
{
    skewX = null;
    skewY = null;



    constructor(nodeId, options)
    {
        super(SKEW, nodeId, options);
    }



    copy()
    {
        const copy = new GSkew(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.skewX) copy.skewX = this.skewX.copy();
        if (this.skewY) copy.skewY = this.skewY.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const skewX = this.skewX ? (await this.skewX.eval(parse)).toValue() : null;
        const skewY = this.skewY ? (await this.skewY.eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

        
        const _bounds = await this.evalObjects(
            parse, 
            {
                skewX:       skewX, 
                skewY:       skewY, 
                showCenter:  showCenter,
                affectSpace: affectSpace
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['skewX',       skewX      ],
            ['skewY',       skewY      ],
            ['showCenter',  showCenter ],
            ['affectSpace', affectSpace],
            ['bounds',      bounds     ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const sx = -options.skewX.value / 100;
        const sy = -options.skewY.value / 100;

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 1,
            () => [[1,  sx, 0],
                   [sy, 1,  0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.skewX && this.skewX.isValid()
            && this.skewY && this.skewY.isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);GVectorPath

        if (this.skewX) this.skewX.pushValueUpdates(parse);
        if (this.skewY) this.skewY.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.skewX) this.skewX.invalidateInputs(parse, from);
        if (this.skewY) this.skewY.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);GVectorPath

        if (this.skewX) this.skewX.iterateLoop(parse);
        if (this.skewY) this.skewY.iterateLoop(parse);
    }
}


class GCenter
extends GOperator1
{
    centerX    = null;
    centerY    = null;
    showCenter = null;



    constructor(nodeId, options)
    {
        super(CENTER, nodeId, options);
    }



    copy()
    {
        const copy = new GMove(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.centerX   ) copy.centerX    = this.centerX   .copy();
        if (this.centerY   ) copy.centerY    = this.centerY   .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const centerX    = this.centerX    ? (await this.centerX   .eval(parse)).toValue() : null;
        const centerY    = this.centerY    ? (await this.centerY   .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

        
        await this.evalObjects(
            parse, 
            {
                centerX:    centerX, 
                centerY:    centerY,
                showCenter: showCenter
            });


        this.setUpdateValues(parse,
        [
            ['centerX',    centerX   ],
            ['centerY',    centerY   ],
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);

            
            const centerX     = options.centerX   .value;
            const centerY     = options.centerY   .value;
            const showCenter  = options.showCenter.value;
     
            const cx          = centerX/100;
            const cy          = centerY/100;


            const bounds      = getObjBounds(this.value.objects);

            const singlePoint =  
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.resetSpace(bounds, singlePoint, cx, cy);
            }


            if (showCenter > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
            ? this.value.copy()
            : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.centerX    && this.centerX   .isValid()
            && this.centerY    && this.centerY   .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.centerX   ) this.centerX   .pushValueUpdates(parse);
        if (this.centerY   ) this.centerY   .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.centerX   ) this.centerX   .invalidateInputs(parse, from);
        if (this.centerY   ) this.centerY   .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.centerX   ) this.centerX   .iterateLoop(parse);
        if (this.centerY   ) this.centerY   .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GResetTransform
extends GOperator1
{
    showCenter = null;



    constructor(nodeId, options)
    {
        super(RESET_XFORM, nodeId, options);
    }



    copy()
    {
        const copy = new GResetTransform(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
            this.value = NullValue.copy();

        
        await this.evalObjects(parse, { showCenter: showCenter });


        this.setUpdateValues(parse,
        [
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const showCenter = options.showCenter.value;


            const bounds = getObjBounds(this.value.objects);

            const singlePoint =
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                {
                    obj.createDefaultSpace();
                    obj.resetSpace(bounds, singlePoint);
                }
            }


            if (showCenter)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GMeasurePoints
extends GOperator2
{
    distance = null;
    angle    = null;


    
    constructor(nodeId, options)
    {
        super(MEASURE_POINTS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMeasurePoints(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.distance) copy.distance = this.distance.copy();
        if (this.angle   ) copy.angle    = this.angle   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                const dist = distance(input0.toPoint(), input1.toPoint());

                let ang = angle(subv(input1.toPoint(), input0.toPoint()));
                if (ang > Tau/2) ang -= Tau;

                this.distance = new NumberValue(dist);
                this.angle    = new NumberValue(ang / Tau * 360);
            }
            else
            {
                this.distance = NumberValue.NaN;
                this.angle    = NumberValue.NaN;
            }
        }
        else
        {
            this.distance = NumberValue.NaN;
            this.angle    = NumberValue.NaN;
        }


        this.setUpdateValues(parse,
        [
            ['distance', this.distance],
            ['angle',    this.angle   ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.distance && this.distance.isValid()
            && this.angle    && this.angle   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.distance) this.distance.pushValueUpdates(parse);
        if (this.angle   ) this.angle   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.distance) this.distance.invalidateInputs(parse, from);
        if (this.angle   ) this.angle   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.distance) this.distance.iterateLoop(parse);
        if (this.angle   ) this.angle   .iterateLoop(parse);
    }
}


class GInterpolatePoint
extends GOperator2
{
    amount     = null;
    transform  = null;
    showCenter = null;


    
    constructor(nodeId, options)
    {
        super(INTERPOLATE_POINT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GInterpolatePoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.amount    ) copy.amount     = this.amount    .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount     = this.amount     ? (await this.amount    .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                const p0  = point(input0.objects[0].x, input0.objects[0].y);
                const p1  = point(input1.objects[0].x, input1.objects[0].y);
                const amt = amount.value / 100;

                const p   = lerpv(p0, p1, amt);

                    
                let sp0 = lerpv(input0.objects[0].sp0, input1.objects[0].sp0, amt);
                let sp1 = lerpv(input0.objects[0].sp1, input1.objects[0].sp1, amt);
                let sp2 = lerpv(input0.objects[0].sp2, input1.objects[0].sp2, amt);

                if (transform.value > 0)
                {
                    const l1 = distance(sp0, sp1);
                    const l2 = distance(sp0, sp2);

                    sp0 = clone(p);
                    sp1 = addv(sp0, mulvs(unitv(subv(p1, p0)), l1));
                    sp2 = addv(sp0, crossv(mulvs(unitv(subv(p1, p0)), l2)));
                }


                this.value = new PointValue(this.nodeId, new NumberValue(p.x), new NumberValue(p.y));

                const pt = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);
                pt.createDefaultTransform(p.x, p.y);
                this.value.objects = [pt];

                this.value.objects[0].sp0 = sp0;
                this.value.objects[0].sp1 = sp1;
                this.value.objects[0].sp2 = sp2;


                if (showCenter.value > 0)
                {
                    const objects = [...this.value.objects]; // avoids infinite growth
                    objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
                }
            }
        }


        this.setUpdateValues(parse,
        [
            ['amount',     amount    ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.amount     && this.amount    .isValid()
            && this.transform  && this.transform .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.amount    ) this.amount    .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.amount    ) this.amount    .invalidateInputs(parse, from);
        if (this.transform ) this.transform .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.amount    ) this.amount    .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GPointOnPath
extends GOperator2
{
    measure    = null;
    amount     = null;
    transform  = null;
    showCenter = null;


    
    constructor(nodeId, options)
    {
        super(POINT_ON_PATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GPointOnPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.measure   ) copy.measure    = this.measure   .copy();
        if (this.amount    ) copy.amount     = this.amount    .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const measure    = this.measure    ? (await this.measure   .eval(parse)).toValue() : null;
        const amount     = this.amount     ? (await this.amount    .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                // const p0  = point(input0.objects[0].x, input0.objects[0].y);
                // const p1  = point(input1.objects[0].x, input1.objects[0].y);
                // const amt = amount.value / 100;

                // const p   = lerpv(p0, p1, amt);

                    
                // let sp0 = lerpv(input0.objects[0].sp0, input1.objects[0].sp0, amt);
                // let sp1 = lerpv(input0.objects[0].sp1, input1.objects[0].sp1, amt);
                // let sp2 = lerpv(input0.objects[0].sp2, input1.objects[0].sp2, amt);

                // if (transform.value > 0)
                // {
                //     const l1 = distance(sp0, sp1);
                //     const l2 = distance(sp0, sp2);

                //     sp0 = clone(p);
                //     sp1 = addv(sp0, mulvs(unitv(subv(p1, p0)), l1));
                //     sp2 = addv(sp0, crossv(mulvs(unitv(subv(p1, p0)), l2)));
                // }


                // this.value = new PointValue(this.nodeId, new NumberValue(p.x), new NumberValue(p.y));

                // const pt = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);
                // pt.createDefaultTransform(p.x, p.y);
                // this.value.objects = [pt];

                // this.value.objects[0].sp0 = sp0;
                // this.value.objects[0].sp1 = sp1;
                // this.value.objects[0].sp2 = sp2;


                // if (showCenter.value > 0)
                // {
                //     const objects = [...this.value.objects]; // avoids infinite growth
                //     objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
                // }
            }
        }


        this.setUpdateValues(parse,
        [
            ['measure',    measure   ],
            ['amount',     amount    ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);
        

        this.validate();

        return this;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.measure   ) this.measure   .pushValueUpdates(parse);
        if (this.amount    ) this.amount    .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.measure   ) this.measure   .invalidateInputs(parse, from);
        if (this.amount    ) this.amount    .invalidateInputs(parse, from);
        if (this.transform ) this.transform .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.measure   ) this.measure   .iterateLoop(parse);
        if (this.amount    ) this.amount    .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GPlace
extends GOperator1
{
    position   = null;
    transform  = null;
    showCenter = null;



    constructor(nodeId, options)
    {
        super(PLACE, nodeId, options);
    }



    copy()
    {
        const copy = new GPlace(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position  ) copy.position   = this.position  .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const position   = this.position   ? (await this.position  .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;

        if (   this.input
            && position)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
            this.value = null;//NullValue.copy();



        if (   position
            && position.isValid())
            // && position.objects
            // && position.objects.length > 0)
        {
            const p0 = position.toPoint();//point(
                // position/*.objects[0]*/.x, 
                // position/*.objects[0]*/.y);

            const p1 = addv(p0, subv(position/*.objects[0]*/.sp1, position/*.objects[0]*/.sp0));
            const p2 = addv(p0, subv(position/*.objects[0]*/.sp2, position/*.objects[0]*/.sp0));

            await this.evalObjects(
                parse, 
                {
                    transform:  transform,
                    showCenter: showCenter,
                    sp0:        p0,
                    sp1:        p1,
                    sp2:        p2
                });
        }

        
        this.setUpdateValues(parse,
        [
            ['position',   position  ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const place = createTransform(
                options.sp0 ? options.sp0.x : 0,
                options.sp0 ? options.sp0.y : 0);


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


                if (this.options.enabled)
                {
                    let xform = mulm3m3(
                        createTransform(
                            -obj.sp0.x, 
                            -obj.sp0.y),
                        place);


                    if (   options.transform.value > 0
                        && options.sp0
                        && options.sp1
                        && options.sp2)
                    {
                        const sp = getTransformFromPoints(
                            options.sp0, 
                            options.sp1, 
                            options.sp2);

                        xform = mulm3m3(xform, sp);

                        obj.sp1 = addv(obj.sp0, point(1, 0));
                        obj.sp2 = addv(obj.sp0, point(0, 1));
                    }


                    obj.applyTransform(xform, true);
                }
            }


            if (options.showCenter.value > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.position   && this.position  .isValid()
            && this.transform  && this.transform .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position  ) this.position  .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.position  ) this.position  .invalidateInputs(parse, from);
        if (this.transform ) this.transform .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position  ) this.position  .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}



function getTransformFromPoints(p0, p1, p2) 
{
    const dx   = p1.x - p0.x;
    const dy   = p1.y - p0.y;

    const a    = Math.atan2(dy, dx);
  
    const cosa = Math.cos(a);
    const sina = Math.sin(a);


    const sx   = ((p1.y - p0.y) / nozero(p1.x - p0.x));
    const sy   = ((p2.x - p0.x) / nozero(p2.y - p0.y));

    // TODO add skew 

    return [[ cosa,         -sina /** sy*/, 0 ], 
            [ sina /** sx*/, cosa,          0 ], 
            [ 0,             0,             1 ]];
}


class GGroupNode
extends GOperator
{
    paramIds = [];
    params   = [];



    constructor(nodeId, options)
    {
        super(GROUP_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGroupNode(this.nodeId, this.options);

        copy.copyBase(this);

        copy.params = this.params.map(p => p.copy());

        return copy;
    }



    paramFromId(paramId)
    {
        return this.params[this.paramIds.findIndex(id => id == paramId)];
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];


        if (!isEmpty(this.params))
        {
            for (let i = 0; i < this.params.length; i++)
            {
                const param = await this.params[i].eval(parse);
                this.setUpdateValues(parse, [[this.paramIds[i], param.toValue()]], true);
            }
        }
        else
            this.setUpdateValues(parse, [['', NullValue]], true);
                
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse))
        this.params.forEach(p => p.pushValueUpdates(parse))
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from))
        this.params.forEach(p => p.invalidateInputs(parse, from))
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse))
        this.params.forEach(p => p.iterateLoop(parse))
    }
}



class GGroupParam
extends GOperator
{
    input = null;
    
    dataType = NULL;



    constructor(nodeId, options)
    {
        super(GROUP_PARAM, nodeId, options);
    }



    copy()
    {
        const copy = new GGroupParam(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.dataType = this.dataType;
      
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            if (!this.input.value)
                await this.input.eval(parse);

            this.value = this.input.toValue();
        }

        else if (this.dataType != NULL)
            this.value = nanFromType(this.dataType);
        
        else
            this.value = NullValue.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GComment
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GComment(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue.copy();


        this.setUpdateValues(parse, [['', NullValue]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GPanel
extends GOperator
{
    constructor(nodeId, options)
    {
        super(PANEL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GPanel(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue.copy();


        this.setUpdateValues(parse, [['', NullValue]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



var genFigMessagePosted = false;

var uiMessages          = [];


var figFonts            = [];
var figUniqueFontNames  = [];



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

var lastMessage = null;


onmessage = function(e)
{
    const msg = JSON.parse(e.data);


    if (msg.cmd == 'returnUiGetValue') // ignore this message in the queue
        return;
    

    if (msg.cmd == 'genRequest')
    {
        if (   lastMessage
            && lastMessage.cmd == 'genRequest')
            return;


        genRequest(msg.request, msg.save);         
    }
    else
    {
        switch (msg.cmd)
        {
            case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;
        
            case 'genEndUiMessage':  genEndUiMessage (msg.msgCmd);              break;
            case 'genEndFigMessage': genEndFigMessage();                        break;
        }

        lastMessage = null;
    }


    genPostMessageToUi(
    {
        cmd:   'uiEndGenMessage',
        msgCmd: msg.cmd
    });
};

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to UI
///////////////////////////////////////////////////////////////////////////////////////////////////

function genPostMessageToUi(msg)
{
    if (msg == undefined)
    {
        consoleError('undefined message');
        console.trace();
    }

    postMessage(JSON.stringify(msg));
}



function genQueueMessageToUi(msg)
{
    uiMessages.push(msg);
    genPostNextMessageToUi();
}



function genPostNextMessageToUi(msg)
{
    if (!isEmpty(uiMessages))
    //    && !genFigMessagePosted)
    {
        //console.log('yes');
        let msg = uiMessages.shift();

        // while (   !isEmpty(uiMessages)
        //        &&  uiMessages[0].cmd     == 'uiUpdateValuesAndObjects'
        //        &&  uiMessages[0].chunkId == 0)
        // {
        //     const nextFirst = uiMessages.find(m => 
        //            m.cmd     == msg.cmd 
        //         && m.chunkId == 0);

        //     if (nextFirst)
        //     {
        //         while (!isEmpty(uiMessages)
        //             &&  uiMessages[0].cmd           == msg.cmd
        //             &&  uiMessages[0].updateNodeId  == msg.updateNodeId
        //             &&  uiMessages[0].updateParamId == msg.updateParamId
        //             &&  uiMessages[0].cmd.chunkId   >  0)
        //             msg = uiMessages.shift();

        //         msg = uiMessages.shift();
        //     }
        // }

        genPostMessageToUi(msg);
    }
}



function genEndUiMessage(msgCmd)
{
    //console.log('next UI message');
    genPostNextMessageToUi();
}



function genEndFigMessage()
{
    genFigMessagePosted = false;
    
    if (   !isEmpty(lastUpdateValues )
        || !isEmpty(lastUpdateObjects)
        || !isEmpty(lastUpdateStyles ))
        genUpdateValuesAndObjects(lastRequestId, -1, lastUpdateNodeId, lastUpdateParamId, [], [], [], false);

    genPostNextMessageToUi();
}

///////////////////////////////////////////////////////////////////////////////////////////////////


var lastRequestId      = -1;
var lastUpdateNodeId   =  NULL;
var lastUpdateParamId  =  NULL;
var lastUpdateValues   =  [];
var lastUpdateObjects  =  [];
var lastUpdateStyles   =  [];


var curRequestIds      = [];



function initFonts(fonts, uniqueFontNames)
{
    figFonts           = fonts;
    figUniqueFontNames = uniqueFontNames;
}



function genRequest(request, save)
{
    const requestId     = parseInt(request[0]);
    const actionId      = parseInt(request[1]);
    const set           = parseInt(request[2]);

    curRequestIds.push(requestId);


    const settings =
    {
        showAllColorSpaces:  (set >> 0) & 1 != 0,
        logRequests:         (set >> 1) & 1 != 0,
        showTransformPoints: (set >> 2) & 1 != 0
    };


    const updateNodeId  = request[3];
    const updateParamId = request[4];

    const viewportZoom  = request[5];


    const parse = new Parse(
        request, 
        6,
        requestId,
        updateNodeId, 
        updateParamId, 
        viewportZoom,
        settings,
        save);


    const stackOverflowProtect = 100;

    while (   parse.pos < parse.request.length
           && parse.so  < stackOverflowProtect)
        genParse(parse);


    if (settings.logRequests)
        logRequest(parse);


    const    paramNodes = parse.paramNodeIds.map(id => parse.parsedNodes.find(n => n.nodeId == id));
    const topLevelNodes = parse.parsedNodes.filter(n => n.topLevel);


    (async () =>
    {
        for (const node of paramNodes) 
        { 
            await node.eval(parse);

            if (parse.stop()) 
            {
                genPostMessageToUi({cmd: 'uiEndRequest', requestId: requestId});
                genPostMessageToUi({cmd: 'uiEndGlobalProgress'});
                return; 
            }
        } 


        if (!parse.stop()) 
        {
            for (const node of topLevelNodes) 
            { 
                await node.eval(parse); 

                if (parse.stop()) 
                {
                    genPostMessageToUi({cmd: 'uiEndRequest', requestId: requestId});
                    genPostMessageToUi({cmd: 'uiEndGlobalProgress'});
                    return; 
                }
            }
        }
        else
        {
            genPostMessageToUi({cmd: 'uiEndRequest', requestId: requestId});
            genPostMessageToUi({cmd: 'uiEndGlobalProgress'});
            return;
        }


        genQueueMessageToUi({cmd: 'uiEndGlobalProgress'});


        if (parse.stop()) return;

        
        for (const node of topLevelNodes) 
            node.pushValueUpdates(parse);
        
        
        for (const node of parse.parsedNodes)
        {
            if (node.options.active === true)
            {
                if (   node.value
                    && node.value.objects)
                    node.value.objects.forEach(o => genPushUpdateObject(parse, o));

                if (node.colorStyle) 
                    genPushUpdateColorStyle(parse, node.colorStyle);
            }
        }


        if (parse.settings.showTransformPoints)
        {
            for (const node of parse.parsedNodes)
            {
                if (   node.options.active === true
                    && node.value)
                {
                    for (const obj of node.value.objects)
                    {
                        if (  !obj.isDeco
                            && obj.xp0
                            && obj.xp1
                            && obj.xp2)
                        {
                            const xp0 = clone(obj.xp0);//.toPoint();
                            const xp1 = clone(obj.xp1);//.toPoint();
                            const xp2 = clone(obj.xp2);//.toPoint();
                            const xp3 = addv(xp2, subv(xp1, xp0));

                            genPushUpdateObject(
                                parse, 
                                createDecoPoly(
                                    node, 
                                    obj.sp0, 
                                    [xp0, xp2, xp3, xp1], 
                                    true,
                                    '1, 2',
                                    [12, 140, 233], 
                                    XFORM_SUFFIX));
                        }
                    }
                }
            }
        }


        genUpdateValuesAndObjects(
            requestId,
            actionId,
            parse.updateNodeId,
            parse.updateParamId,
            parse.updateValues,
            parse.updateObjects,
            parse.updateStyles,
            save);


        genPostMessageToUi(
        {
            cmd:      'uiEndRequest',
            requestId: requestId
        });
    })();
}



function genPushUpdateValue(parse, nodeId, paramId, value)
{
    if (!value)
        return;
    
    // if (  !parse.save
    //     && value.hasInitValue())
    //     return;

    
    removeFromArrayWhere(parse.updateValues, v =>
           v.nodeId     == nodeId
        && v.paramId    == paramId
        && v.value.type == value.type);

        
    parse.updateValues.push(
    {
        nodeId:  nodeId,
        paramId: paramId,
        type:    value.type, // needed to correctly parse NAN_DISPLAY
        value:   value.toJson()
    });
}



function genPushUpdateObject(parse, object)
{
    pushUniqueExcept(
        parse.updateObjects,
        object,
        o =>    o.nodeId   == object.nodeId
             && o.objectId == object.objectId);
}



function genPushUpdateColorStyle(parse, style)
{
    pushUniqueExcept(
        parse.updateStyles,
        style,
        o => o.nodeId == style.nodeId);
}



function clearLastUpdate()
{
    lastRequestId     = -1;
    lastUpdateNodeId  =  NULL;
    lastUpdateParamId =  NULL;

    lastUpdateValues  =  [];
    lastUpdateObjects =  [];
    lastUpdateStyles  =  [];
}



function genUpdateValuesAndObjects(requestId, actionId, updateNodeId, updateParamId, updateValues, updateObjects, updateStyles, save)
{
    if (   isEmpty(updateValues )
        && isEmpty(updateObjects)
        && isEmpty(updateStyles ))
    {
        requestId     = lastRequestId;
        updateNodeId  = lastUpdateNodeId;
        updateParamId = lastUpdateParamId;
        
        updateValues  = lastUpdateValues;
        updateObjects = lastUpdateObjects;
        updateStyles  = lastUpdateStyles;

        clearLastUpdate();
    }
    else if (genFigMessagePosted)
    {
        lastRequestId     = requestId;
        lastUpdateNodeId  = updateNodeId;
        lastUpdateParamId = updateParamId;

        lastUpdateValues  = updateValues;
        lastUpdateObjects = updateObjects;
        lastUpdateStyles  = updateStyles;

        return;
    }


    const nodeIds = filterUnique(updateValues.map(v => v.nodeId));
    const counts  = nodeIds.map(id => updateValues.filter(v => v.nodeId == id).length);


    // send updates in chunks

    const approxNodeChunkSize = 1000000;//20;
    const objChunkSize        = 1000000;//200;
    const styleChunkSize      = 1000000;//20;

    
    let n  = 0; // node
    let o  = 0; // object
    let s  = 0; // style

    let nc = 0; // node chunk count
    let oc = 0; // object chunk count
    let sc = 0; // style chunk count


    let nodeValChunk   = [],
        objChunk       = [],
        styleChunk     = [];

    let nodeValChunkId = 0;

    let isFirstChunk   = true;
        

    genQueueMessageToUi(
    {
        cmd:      'uiInitGlobalProgress',
        requestId: requestId
    });


    while (   n < nodeIds      .length
           || o < updateObjects.length
           || s < updateStyles .length)
    {
        if (n < nodeIds.length)
        {
            nodeValChunk.push(nodeIds[n], counts[n]);

            const values = updateValues.filter(v => v.nodeId == nodeIds[n]);
            values.sort((a, b) => a.paramId - b.paramId);

            for (const v of values)
                nodeValChunk.push(v.paramId, v.type, v.value);

            n++, nc++;
        }


        if (o < updateObjects.length)
        {
            objChunk.push(updateObjects[o].toData());
            o++, oc++;
        }


        if (s < updateStyles.length)
        {
            styleChunk.push(updateStyles[s].toData());
            s++, sc++;
        }


        const chunkNotEmpty =
               nc >= approxNodeChunkSize
            || oc == objChunkSize
            || sc == styleChunkSize;


        if (chunkNotEmpty)
        {
            const isLastChunk =    
                   n >= nodeIds      .length
                && o >= updateObjects.length
                && s >= updateStyles .length
                && (   !isEmpty(nodeValChunk)
                    || !isEmpty(objChunk    )
                    || !isEmpty(styleChunk  ));

            genQueueChunk(
                requestId,
                actionId,
                updateNodeId,
                updateParamId,
                nodeValChunkId++,
                nodeValChunk,
                objChunk,
                styleChunk,
                n,
                nodeIds.length,
                isFirstChunk,
                isLastChunk,
                save);

            nodeValChunk = [];  nc = 0;
            objChunk     = [];  oc = 0;
            styleChunk   = [];  sc = 0;

            isFirstChunk = false;
        }
    }


    const lastChunkNotEmpty =
           !isEmpty(nodeValChunk)
        || !isEmpty(objChunk    )
        || !isEmpty(styleChunk  );


    if (lastChunkNotEmpty)
    {
        genQueueChunk(
            requestId,
            actionId,
            updateNodeId,
            updateParamId,
            nodeValChunkId++,
            nodeValChunk,
            objChunk,
            styleChunk,
            nodeIds.length,
            nodeIds.length,
            false,
            true,
            save);
    }


    genQueueMessageToUi({
        cmd: 'uiForwardToFigma',
        msg: {cmd: 'figCommitUndo'}
    })
}



function genQueueChunk(requestId, actionId, updateNodeId, updateParamId, nodeValChunkId, nodeValChunk, objChunk, styleChunk, updatedNodes, totalNodes, isFirstChunk, isLastChunk, save)
{
    genQueueMessageToUi({
        cmd:          'uiUpdateValuesAndObjects',
        requestId:     requestId,
        actionId:      actionId,
        updateNodeId:  updateNodeId,
        updateParamId: updateParamId,
        chunkId:       nodeValChunkId,
        values:        [...nodeValChunk].map(v => v.toString()),
        objects:       [...objChunk    ],
        styles:        [...styleChunk  ],
        updatedNodes:  updatedNodes,
        totalNodes:    totalNodes,
        isFirstChunk:  isFirstChunk,
        isLastChunk:   isLastChunk,
        save:          save
    });


    if (   !isEmpty(objChunk  )
        || !isEmpty(styleChunk))
        genFigMessagePosted = true;
}



function genInitNodeProgress(nodeId)
{
    genQueueMessageToUi(
    {
        cmd:   'uiInitNodeProgress',
        nodeId: nodeId
    });
}



function genUpdateNodeProgress(parse, nodeId, progress, updateGlobal = true)
{
    genQueueMessageToUi(
    {
        cmd:           'uiUpdateNodeProgress',
        nodeId:         nodeId,
        progress:       progress,
        globalProgress: parse.currentProgress / parse.totalProgress,
        updateGlobal:   updateGlobal
    });
}



function genEndNodeProgress(nodeId, endGlobal)
{
    genQueueMessageToUi(
    {
        cmd:      'uiEndNodeProgress',
        nodeId:    nodeId,
        endGlobal: endGlobal
    });
}



async function genGetObjectSizeFromFigma(obj) 
{
    return new Promise((resolve, reject) => 
    {
        const timeout = 1000;

        genPostMessageToUi(
        {
            cmd: 'uiForwardToFigma',
            msg:  
            {
                cmd:   'figGetObjectSize',
                object: obj
            }
        });

        const timeoutId = setTimeout(() => 
            reject(new Error('Timeout: Result not received within the specified time')),
            timeout);

        function handleMessage(event) 
        {
            const msg = JSON.parse(event.data);

            if (msg.cmd === 'returnFigGetObjectSize') 
            {
                clearTimeout(timeoutId);
                
                const { objectId, width, height } = msg;
                resolve({ objectId, width, height });

                self.removeEventListener('message', handleMessage);
            }
        }

        self.addEventListener('message', handleMessage);
    });
}



async function genGetValueFromUi(key) 
{
    return new Promise((resolve, reject) => 
    {
        const timeout = 1000;

        genPostMessageToUi(
        {
            cmd: 'uiGetValue',
            key:  key 
        });

        const timeoutId = setTimeout(() => 
            reject(new Error('Timeout: Result not received within the specified time')),
            timeout);

        function handleMessage(event) 
        {
            const msg = JSON.parse(event.data);

            if (msg.cmd === 'returnUiGetValue') 
            {
                clearTimeout(timeoutId);

                resolve(
                { 
                    key:   msg.key, 
                    value: msg.value 
                });

                self.removeEventListener('message', handleMessage);
            }
        }

        self.addEventListener('message', handleMessage);
    });
}


function genParseColorValue(parse)
{
    parse.pos++; // COLOR_VALUE

    const col = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_VALUE, col, parse);

    return parseColorValue(col)[0];
}



function genParseColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col = new GColor(nodeId, options);

    col.hasInputs = options.hasInputs;
    
  
    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(col, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    let paramIds;

    if (nInputs == 1)
    {
        col.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['space', 'convert', 'c1', 'c2', 'c3'];


    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'space':   col.space   = genParse(parse);  break;
        case 'convert': col.convert = genParse(parse);  break;
        case 'c1':      col.c1      = genParse(parse);  break;
        case 'c2':      col.c2      = genParse(parse);  break;
        case 'c3':      col.c3      = genParse(parse);  break;
        }
    }
    

    parse.nTab--;


    genParseNodeEnd(parse, col);
    return col;
}



function genParseValidColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const valid = new GValidColor(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(valid, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, valid);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        valid.input = genParse(parse);


    valid.quality = genParse(parse);
    valid.value   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, valid);
    return valid;
}



function genParseCorrectColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corr = new GCorrectColor(nodeId, options);

    corr.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, corr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
        corr.input = genParse(parse);


    paramIds = parse.move().split(',');

    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'order':    corr.order   = genParse(parse); break;
        case 'margin1':  corr.margin1 = genParse(parse); break;
        case 'margin2':  corr.margin2 = genParse(parse); break;
        case 'margin3':  corr.margin3 = genParse(parse); break;
        case 'value':    corr.value   = genParse(parse); break;
        }
    }
                

    parse.nTab--;


    genParseNodeEnd(parse, corr);
    return corr;
}



function genParseColorContrast(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cnt = new GColorContrast(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;

    
    if (parse.settings.logRequests) 
        logReqColorContrast(cnt, nInputs, valueIndex, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cnt.input0   = genParse(parse);
        cnt.input1   = genParse(parse);
        cnt.standard = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) cnt.input0 = genParse(parse); 
        else if (valueIndex == 1) cnt.input1 = genParse(parse); 

        cnt.standard = genParse(parse);
    }
    else if (nInputs == 0)
    {
        cnt.standard = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, cnt);
    return cnt;
}



function genParseColorConvertP3(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const convert = new GConvertP3(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(convert, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, convert);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        convert.input = genParse(parse);


    convert.from = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, convert);
    return convert;
}



function genParseColorBlind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cb = new GColorBlind(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cb, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cb);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cb.input = genParse(parse);

    cb.l = genParse(parse);
    cb.m = genParse(parse);
    cb.s = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cb);
    return cb;
}



function genParseColorInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GColorInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        consoleError('nInputs must be [0, 2]');


    lerp.space  = genParse(parse);
    lerp.amount = genParse(parse);
    lerp.gamma  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseColorBlend(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blend = new GColorBlend(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(blend, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, blend);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        blend.input0 = genParse(parse);
        blend.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        blend.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        consoleError('nInputs must be [0, 2]');


    blend.mode    = genParse(parse);
    blend.opacity = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, blend);
    return blend;
}


function genParseNull(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _null = new GNull(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(_null, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, _null);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        _null.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, _null);
    return _null;
}



function genParseListValue(parse)
{
    parse.pos++; // LIST_VALUE

    const list = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LIST_VALUE, list, parse);

    return parseListValue(list)[0];
}



function genParseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const list = new GList(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(list, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, list);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        list.inputs.push(genParse(parse));


    parse.nTab--;

        
    genParseNodeEnd(parse, list);
    return list;
}



function genParseCondense(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const condense = new GCondense(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(condense, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, condense);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        condense.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, condense);
    return condense;
}



function genParseSublist(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sub = new GSublist(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sub, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sub);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sub.input = genParse(parse);

    sub.start = genParse(parse);
    sub.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sub);
    return sub;
}



function genParseUnique(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const unique = new GUnique(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(unique, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, unique);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        unique.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, unique);
    return unique;
}



function genParseReverseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reverse = new GReverseList(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(reverse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, reverse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reverse.input = genParse(parse);
  
    
    parse.nTab--;


    genParseNodeEnd(parse, reverse);
    return reverse;
}



function genParseSort(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sort = new GSort(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sort, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sort);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sort.input = genParse(parse);

    sort.column  = genParse(parse);
    sort.reverse = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sort);
    return sort;
}



function genParseColumn(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const column = new GColumn(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(column, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, column);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        column.input = genParse(parse);

    column.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, column);
    return column;
}



function genParseCell(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cell = new GCell(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cell, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cell);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cell.input = genParse(parse);

    cell.column = genParse(parse);
    cell.row    = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cell);
    return cell;
}



function genParseItems(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const items = new GItems(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(items, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, items);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        items.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, items);
    return items;
}



function genParseSelect(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sel = new GSelect(nodeId, options);
    

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(sel, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sel.input = genParse(parse);

    sel.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sel);
    return sel;
}



function genParseListCount(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const count = new GListCount(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(count, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, count);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        count.input = genParse(parse);

    count.start = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, count);
    return count;
}



function genParseListContains(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cont = new GContains(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cont, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cont);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cont.input0 = genParse(parse);
        cont.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cont.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, cont);
    return cont;
}



function genParseIfElse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ifElse = new GIfElse(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;


    if (parse.settings.logRequests) 
        logReq(ifElse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, ifElse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        ifElse.input0    = genParse(parse);
        ifElse.input1    = genParse(parse);
        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) ifElse.input0 = genParse(parse); 
        else if (valueIndex == 1) ifElse.input1 = genParse(parse); 

        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 0)
    {
        ifElse.condition = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, ifElse);
    return ifElse;
}



function genParseStart(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const start = new GStart(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(start, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, start);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        start.input = genParse(parse);

    start.feedback = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, start);
    return start;
}



function genParseRepeat(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const repeat = new GRepeat(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(repeat, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, repeat);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        repeat.input = genParse(parse);

    repeat. count = genParse(parse);
    repeat._while = genParse(parse);
    repeat. loop  = genParse(parse);  // don't set target here


    parse.nTab--;


    genParseNodeEnd(parse, repeat);
    return repeat;
}



function genParseCache(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cache = new GCache(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cache, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cache);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cache.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cache);
    return cache;
}



function genParseFreeze(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const freeze = new GFreeze(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(freeze, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, freeze);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        freeze.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, freeze);
    return freeze;
}



function genParseTimer(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const timer = new GTimer(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(timer, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, timer);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        timer.input = genParse(parse);


    timer.delay = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, timer);
    return timer;
}



function genParseValueName(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const name = new GValueName(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(name, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, name);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        name.input = genParse(parse);

    name.name = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, name);
    return name;
}



function genParseComment(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmnt = new GComment(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(cmnt, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, cmnt);
    return cmnt;
}



function genParsePanel(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const panel = new GPanel(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(panel, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, panel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, panel);
    return panel;
}


function genParseGroupNode(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GGroupNode(nodeId, options);


    let nParams = -1;
    
    if (!ignore)
    {
        nParams = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore);//, nParams);


    if (ignore)
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    //const nParams = parseInt(parse.move());

    for (let i = 0; i < nParams; i++)
    {
        group.paramIds.push(parse.move());
        group.params  .push(genParse(parse));
    }


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseGroupParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const param = new GGroupParam(nodeId, options);


    let nInputs  = -1;
    let nOutputs = -1;
    
    if (!ignore)
    {
        nInputs  = parseInt(parse.move());
        nOutputs = parseInt(parse.move());

        consoleAssert(nInputs  == 0 || nInputs  == 1,  'nInputs must be [0, 1]');
        consoleAssert(nOutputs == 0 || nOutputs == 1, 'nOutputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(param, parse, ignore);//, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, param);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
    {
        param.input    = genParse(parse);
        param.dataType = parse.move();
    }
    else if (nOutputs == 1)
        param.dataType = parse.move();


    parse.nTab--;


    genParseNodeEnd(parse, param);
    return param;
}



function genParseFillValue(parse)
{
    parse.pos++; // FILL_VALUE

    const fill = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(FILL_VALUE, fill, parse);

    return parseFillValue(fill)[0];
}



function genParseFill(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fill = new GFill(nodeId, options);

    fill.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(fill, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, fill);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        fill.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['color', 'opacity', 'blend'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'color':   fill.color   = genParse(parse); break;
        case 'opacity': fill.opacity = genParse(parse); break;
        case 'blend':   fill.blend   = genParse(parse); break;
        }
    }

    
    parse.nTab--;


    genParseNodeEnd(parse, fill);
    return fill;
}



function genParseFillParam(parse)
{
    const fill = genParse(parse); 

    if (COLOR_TYPES.includes(fill.type))
        fill.options.opacity = genParse(parse);

    return fill;
}



function genParseGradientValue(parse)
{
    parse.pos++; // GRADIENT_VALUE

    const grad = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(GRADIENT_VALUE, grad, parse);

    return parseGradientValue(grad)[0];
}



function genParseGradient(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const grad = new GGradient(nodeId, options);

    grad.hasInputs = options.hasInputs;


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(grad, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, grad);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        grad.inputs.push(genParse(parse));


    grad.gradType = genParse(parse); 
    grad.x        = genParse(parse); 
    grad.y        = genParse(parse); 
    grad.size     = genParse(parse); 
    grad.angle    = genParse(parse); 
    grad.aspect   = genParse(parse); 
    grad.skew     = genParse(parse); 
    grad.blend    = genParse(parse); 

    
    parse.nTab--;


    genParseNodeEnd(parse, grad);
    return grad;
}



// function genParseGradientParam(parse)
// {
//     const grd = genParse(parse); 

//     if (COLOR_TYPES.includes(grd.type))
//         grd.options.opacity = genParse(parse);

//     return grd;
// }



function genParseColorStopValue(parse)
{
    parse.pos++; // COLOR_STOP_VALUE

    const stop = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_STOP_VALUE, stop, parse);

    return parseColorStopValue(stop)[0];
}



function genParseColorStop(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stop = new GColorStop(nodeId, options);

    stop.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(stop, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, stop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        stop.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'position'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'fill':     stop.fill     = genParse(parse); break;
        case 'position': stop.position = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, stop);
    return stop;
}



function genParseStrokeValue(parse)
{
    parse.pos++; // STROKE_VALUE

    const stroke = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(STROKE_VALUE, stroke, parse);

    return parseStrokeValue(stroke)[0];
}



function genParseStroke(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stroke = new GStroke(nodeId, options);

    stroke.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(stroke, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, stroke);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        stroke.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'fill':   stroke.fills  = genParse(parse); break;
        case 'weight': stroke.weight = genParse(parse); break;
        case 'fit':    stroke.fit    = genParse(parse); break;
        case 'join':   stroke.join   = genParse(parse); break;
        case 'miter':  stroke.miter  = genParse(parse); break;
        case 'cap':    stroke.cap    = genParse(parse); break;
        case 'dashes': stroke.dashes = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, stroke);
    return stroke;
}



function genParseStrokeParam(parse)
{
    const stroke = genParse(parse); 

    if (    FILL_TYPES.includes(stroke.type)
        || COLOR_TYPES.includes(stroke.type))
        stroke.data.weight = genParse(parse);

    return stroke;
}



function genParseDropShadowValue(parse)
{
    parse.pos++; // DROP_SHADOW_VALUE

    const shadow = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(DROP_SHADOW_VALUE, shadow, parse);

    return parseDropShadowValue(shadow)[0];
}



function genParseDropShadow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const shadow = new GDropShadow(nodeId, options);

    shadow.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(shadow, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, shadow);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        shadow.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      shadow.x      = genParse(parse); break;
        case 'y':      shadow.y      = genParse(parse); break;
        case 'blur':   shadow.blur   = genParse(parse); break;
        case 'spread': shadow.spread = genParse(parse); break;
        case 'fill':   shadow.fill   = genParse(parse); break;
        case 'blend':  shadow.blend  = genParse(parse); break;
        case 'behind': shadow.behind = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, shadow);
    return shadow;
}



function genParseInnerShadowValue(parse)
{
    parse.pos++; // INNER_SHADOW_VALUE

    const shadow = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(INNER_SHADOW_VALUE, shadow, parse);

    return parseInnerShadowValue(shadow)[0];
}



function genParseInnerShadow(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const shadow = new GInnerShadow(nodeId, options);

    shadow.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(shadow, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, shadow);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        shadow.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      shadow.x      = genParse(parse); break;
        case 'y':      shadow.y      = genParse(parse); break;
        case 'blur':   shadow.blur   = genParse(parse); break;
        case 'spread': shadow.spread = genParse(parse); break;
        case 'fill':   shadow.fill   = genParse(parse); break;
        case 'blend':  shadow.blend  = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, shadow);
    return shadow;
}



function genParseLayerBlurValue(parse)
{
    parse.pos++; // LAYER_BLUR_VALUE

    const blur = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_BLUR_VALUE, blur, parse);

    return parseLayerBlurValue(blur)[0];
}



function genParseLayerBlur(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blur = new GLayerBlur(nodeId, options);

    blur.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(blur, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, blur);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        blur.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['radius'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'radius': blur.radius = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, blur);
    return blur;
}



function genParseBackBlurValue(parse)
{
    parse.pos++; // BACK_BLUR_VALUE

    const blur = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(BACK_BLUR_VALUE, blur, parse);

    return parseBackBlurValue(blur)[0];
}



function genParseBackBlur(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blur = new GBackBlur(nodeId, options);

    blur.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(blur, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, blur);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        blur.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['radius'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'radius': blur.radius = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, blur);
    return blur;
}



function genParseLayerMaskValue(parse)
{
    parse.pos++; // LAYER_MASK_VALUE

    const mask = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LAYER_MASK_VALUE, mask, parse);

    return parseLayerMaskValue(mask)[0];
}



function genParseLayerMask(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const mask = new GLayerMask(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(mask, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, mask);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, mask);
    return mask;
}


function genParseNumValue(parse)
{
    parse.pos++; // N

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(NUMBER_VALUE, val, parse);

    return val.indexOf(',') >= 0
         ? parseNumberValue      (val)[0]
         : parseSimpleNumberValue(val)[0];
}



function genParseNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num = new GNumber(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == NUMBER_VALUE) num.value = genParse(parse);
    else                            num.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, num);
    return num;
}



function genParseConstant(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _const = new GConstant(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(_const, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, _const);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    _const.constant = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, _const);
    return _const;
}



function genParseDateTime(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const dateTime = new GDateTime(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(dateTime, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, dateTime);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    dateTime.seconds   = genParse(parse);
    dateTime.minutes   = genParse(parse);
    dateTime.hours     = genParse(parse);
    dateTime.dayOfWeek = genParse(parse);
    dateTime.date      = genParse(parse);
    dateTime.month     = genParse(parse);
    dateTime.year      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, dateTime);
    return dateTime;
}



function genParseSign(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sign = new GSign(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sign, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, sign);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sign.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sign);
    return sign;
}



function genParseAbsolute(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const abs = new GAbsolute(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(abs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, abs);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        abs.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, abs);
    return abs;
}



function genParseRound(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const round = new GRound(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(round, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, round);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        round.input = genParse(parse);

    round.type     = genParse(parse);
    round.decimals = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, round);
    return round;
}



function genParseMinMax(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const minmax = new GMinMax(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(minmax, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, minmax);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        minmax.inputs.push(genParse(parse));


    minmax.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, minmax);
    return minmax;
}



function genParseLimits(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const limits = new GLimits(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(limits, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, limits);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        limits.input = genParse(parse);

    limits.min = genParse(parse);
    limits.max = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, limits);
    return limits;
}



function genParseMath(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const math = newNode(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(math, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, math);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        math.inputs.push(genParse(parse));


    math.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, math);
    return math;
}



function genParseSimpleMath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const smath = new GSimpleMath(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(smath, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, smath);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        smath.input = genParse(parse);

    smath.operation = genParse(parse);
    smath.operand   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, smath);
    return smath;
}



function genParseArithmetic(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const arith = newNode(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(arith, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, arith);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        arith.inputs.push(genParse(parse));

    parse.nTab--;

        
    genParseNodeEnd(parse, arith);
    return arith;
}



function genParseDefine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const define = new GDefine(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(define, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, define);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        define.inputs.push(genParse(parse));


    parse.nTab--;


    genParseNodeEnd(parse, define);
    return define;
}



function genParseRange(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const dist = new GRange(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(dist, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, dist);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    dist.from   = genParse(parse);
    dist.start  = genParse(parse);
    dist.end    = genParse(parse);
    dist.spread = genParse(parse);
    dist.bias   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, dist);
    return dist;
}



function genParseSequence(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const seq = new GSequence(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(seq, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, seq);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    seq.start = genParse(parse);
    seq.step  = genParse(parse);
    seq.end   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, seq);
    return seq;
}



function genParseRandom(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rnd = new GRandom(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(rnd, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rnd);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    rnd.seed        = genParse(parse);
    rnd.min         = genParse(parse);
    rnd.max         = genParse(parse);
    rnd.unique      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, rnd);
    return rnd;
}



function genParseNoise(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const noise = new GNoise(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(noise, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, noise);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    noise.seed        = genParse(parse);
    noise.min         = genParse(parse);
    noise.max         = genParse(parse);
    noise.scale       = genParse(parse);
    noise.offset      = genParse(parse);
    noise.interpolate = genParse(parse);
    noise.detail      = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, noise);
    return noise;
}



function genParseProbability(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const prob = new GProbability(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(prob, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, prob);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    prob.seed   = genParse(parse);
    prob.chance = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, prob);
    return prob;
}



function genParseAccumulate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const accum = new GAccumulate(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(accum, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, accum);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        accum.input = genParse(parse);

    accum.when = genParse(parse);

        
    parse.nTab--;


    genParseNodeEnd(parse, accum);
    return accum;
}



function genParseInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 0)
    {
        lerp.amount = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseBoolean(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GBoolean(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        bool.inputs.push(genParse(parse));


    bool.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseCondition(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = new GCondition(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cond, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cond.input = genParse(parse);
  
    
    cond.operation = genParse(parse);
    cond.operand   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseConditionBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = newNode(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests)
        logReq(cond, parse, ignore, nInputs); 


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cond.input0 = genParse(parse);
        cond.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cond.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }

    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseTrigonometric(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trig = new GTrig(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(trig, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, trig);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trig.input = genParse(parse);

    trig.function = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, trig);
    return trig;
}



function genParseTrigBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const trig = newNode(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests)
        logReq(trig, parse, ignore, nInputs); 


    if (ignore) 
    {
        genParseNodeEnd(parse, trig);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trig.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, trig);
    return trig;
}



function genParseSolve(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const solve = new GSolve(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(solve, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, solve);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        solve.input = genParse(parse);

    solve.current = genParse(parse);
    solve.target  = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, solve);
    return solve;
}



function genParseAnimate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const anim = new GAnimate(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(anim, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, anim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    anim.from   = genParse(parse);
    anim.to     = genParse(parse);
    anim.curve  = genParse(parse);
    anim.repeat = genParse(parse);
    anim.length = genParse(parse);
    anim.time   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, anim);
    return anim;
}



function genParseRectangle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rect = new GRectangle(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rect, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rect.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      rect.x      = genParse(parse); break;
        case 'y':      rect.y      = genParse(parse); break;
        case 'width':  rect.width  = genParse(parse); break;
        case 'height': rect.height = genParse(parse); break;
        case 'round':  rect.round  = genParse(parse); break;
        case 'props':  rect.props  = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rect);
    return rect;
}



function genParseLine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);

  
    const line = new GLine(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(line, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        line.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     line.x     = genParse(parse); break;
        case 'y':     line.y     = genParse(parse); break;
        case 'width': line.width = genParse(parse); break;
        case 'props': line.props = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, line);
    return line;
}



function genParseEllipse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ellipse = new GEllipse(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(ellipse, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, ellipse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        ellipse.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      ellipse.x      = genParse(parse); break;
        case 'y':      ellipse.y      = genParse(parse); break;
        case 'width':  ellipse.width  = genParse(parse); break;
        case 'height': ellipse.height = genParse(parse); break;
        case 'from':   ellipse.from   = genParse(parse); break;
        case 'to':     ellipse.to     = genParse(parse); break;
        case 'inner':  ellipse.inner  = genParse(parse); break;
        case 'props':  ellipse.props  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, ellipse);
    return ellipse;
}



function genParseTrapeze(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trapeze = new GTrapeze(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(trapeze, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, trapeze);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trapeze.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      trapeze.x      = genParse(parse); break;
        case 'y':      trapeze.y      = genParse(parse); break;
        case 'width':  trapeze.width  = genParse(parse); break;
        case 'height': trapeze.height = genParse(parse); break;
        case 'round':  trapeze.round  = genParse(parse); break;
        case 'bias':   trapeze.bias   = genParse(parse); break;
        case 'props':  trapeze.props  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, trapeze);
    return trapeze;
}



function genParsePolygon(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const poly = new GPolygon(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(poly, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, poly);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        poly.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':       poly.x       = genParse(parse); break;
        case 'y':       poly.y       = genParse(parse); break;
        case 'width':   poly.width   = genParse(parse); break;
        case 'height':  poly.height  = genParse(parse); break;
        case 'round':   poly.round   = genParse(parse); break;
        case 'corners': poly.corners = genParse(parse); break;
        case 'props':   poly.props   = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, poly);
    return poly;
}



function genParseStar(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const star = new GStar(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(star, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, star);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        star.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      star.x      = genParse(parse); break;
        case 'y':      star.y      = genParse(parse); break;
        case 'width':  star.width  = genParse(parse); break;
        case 'height': star.height = genParse(parse); break;
        case 'round':  star.round  = genParse(parse); break;
        case 'points': star.points = genParse(parse); break;
        case 'convex': star.convex = genParse(parse); break;
        case 'props':  star.props  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, star);
    return star;
}



function genParseTextShape(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GTextShape(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'text':          text.text          = genParse(parse); break;
        case 'x':             text.x             = genParse(parse); break;
        case 'y':             text.y             = genParse(parse); break;
        case 'width':         text.width         = genParse(parse); break;
        case 'height':        text.height        = genParse(parse); break;
        case 'font':          text.font          = genParse(parse); break;
        case 'size':          text.size          = genParse(parse); break;
        case 'style':         text.style         = genParse(parse); break;
        case 'props':         text.props         = genParse(parse); break;
        case 'alignH':        text.alignH        = genParse(parse); break;
        case 'alignV':        text.alignV        = genParse(parse); break;
        case 'lineHeight':    text.lineHeight    = genParse(parse); break;
        case 'letterSpacing': text.letterSpacing = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}



function genParsePointValue(parse)
{
    parse.pos++; // POINT_VALUE

    const point = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(POINT_VALUE, point, parse);

    return parsePointValue(point)[0];
}



function genParsePoint(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const point = new GPoint(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(point, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, point);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        point.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x': point.x = genParse(parse); break;
        case 'y': point.y = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, point);
    return point;
}



function genParseVectorPathValue(parse)
{
    parse.pos++; // VECTOR_PATH_VALUE

    const path = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_PATH_VALUE, path, parse);

    return parseVectorPathValue(path)[0];
}



function genParseVectorPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const path = new GVectorPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(path, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, path);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        path.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'points':  path.points  = genParse(parse); break;
        case 'closed':  path.closed  = genParse(parse); break;
        case 'degree':  path.degree  = genParse(parse); break;
        case 'winding': path.winding = genParse(parse); break;
        case 'round':   path.round   = genParse(parse); break;
        case 'props':   path.props   = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, path);
    return path;
}



function genParseVectorVertexValue(parse)
{
    parse.pos++; // VECTOR_POINT_VALUE

    const point = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_VERTEX_VALUE, point, parse);

    return parseVectorVertexValue(point)[0];
}



function genParseVectorVertex(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const point = new GVectorVertex(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(point, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, point);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        point.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     point.x     = genParse(parse); break;
        case 'y':     point.y     = genParse(parse); break;
        case 'join':  point.join  = genParse(parse); break;
        case 'cap':   point.cap   = genParse(parse); break;
        case 'round': point.round = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, point);
    return point;
}



function genParseVectorEdgeValue(parse)
{
    parse.pos++; // VECTOR_EDGE_VALUE

    const edge = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_EDGE_VALUE, edge, parse);

    return parseVectorEdgeValue(edge)[0];
}



function genParseVectorEdge(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const edge = new GVectorEdge(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(edge, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, edge);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        edge.input0 = genParse(parse);
        edge.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        edge.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    edge.startTangent = genParse(parse);
    edge.  endTangent = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, edge);
    return edge;
}



function genParseVectorRegionValue(parse)
{
    parse.pos++; // VECTOR_REGION_VALUE

    const region = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_REGION_VALUE, region, parse);

    return parseVectorRegionValue(region)[0];
}



function genParseVectorRegion(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const region = new GVectorRegion(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(region, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, region);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        region.inputs.push(genParse(parse));


    region.winding = genParse(parse);
    region.props   = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, region);
    return region;
}



function genParseVectorNetworkValue(parse)
{
    parse.pos++; // VECTOR_NETWORKO_VALUE

    const region = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(VECTOR_NETWORK_VALUE, region, parse);

    return parseVectorNetworkValue(region)[0];
}



function genParseVectorNetwork(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const network = new GVectorNetwork(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(network, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, network);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        network.inputs.push(genParse(parse));

    network.props = genParse(parse);


    parse.nTab--;



    genParseNodeEnd(parse, network);
    return network;
}



function genParseShapeBoolean(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GShapeBoolean(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        bool.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'children':  bool.children  = genParse(parse); break;
        case 'operation': bool.operation = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseShapeGroup(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GShapeGroup(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        group.inputs.push(genParse(parse));


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseFrame(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const frame = new GFrame(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(frame, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, frame);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        frame.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':        frame.x        = genParse(parse); break;
        case 'y':        frame.y        = genParse(parse); break;
        case 'width':    frame.width    = genParse(parse); break;
        case 'height':   frame.height   = genParse(parse); break;
        //case 'angle':    frame.angle    = genParse(parse); break;
        case 'round':    frame.round    = genParse(parse); break;
        case 'children': frame.children = genParse(parse); break;
        case 'props':    frame.props    = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, frame);
    return frame;
}



function genParseMove(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const move = new GMove(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(move, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, move);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        move.input = genParse(parse);

    move.x           = genParse(parse);
    move.y           = genParse(parse);
    move.moveType    = genParse(parse);
    move.affectSpace = genParse(parse);
    move.showCenter  = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, move);
    return move;
}



function genParseRotate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rotate = new GRotate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rotate, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rotate);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rotate.input = genParse(parse);

    rotate.angle       = genParse(parse);
    rotate.showCenter  = genParse(parse);
    rotate.affectSpace = genParse(parse);

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rotate);
    return rotate;
}



function genParseScale(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const scale = new GScale(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(scale, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, scale);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        scale.input = genParse(parse);

    scale.scaleX        = genParse(parse);
    scale.scaleY        = genParse(parse);
    scale.affectCorners = genParse(parse);
    scale.affectStyle   = genParse(parse);
    scale.showCenter    = genParse(parse);
    scale.affectSpace   = genParse(parse);

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, scale);
    return scale;
}



function genParseSkew(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const skew = new GSkew(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(skew, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, skew);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        skew.input = genParse(parse);

    skew.skewX       = genParse(parse);
    skew.skewY       = genParse(parse);
    skew.showCenter  = genParse(parse);
    skew.affectSpace = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, skew);
    return skew;
}



function genParseCenter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const center = new GCenter(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(center, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, center);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        center.input = genParse(parse);

    center.centerX    = genParse(parse);
    center.centerY    = genParse(parse);
    center.showCenter = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, center);
    return center;
}



function genParseResetTransform(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const reset = new GResetTransform(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(reset, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, reset);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        reset.input = genParse(parse);

    reset.showCenter = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, reset);
    return reset;
}



function genParseMeasurePoints(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const measure = new GMeasurePoints(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(measure, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, measure);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    if (nInputs == 2)
    {
        measure.input0 = genParse(parse);
        measure.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        measure.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    parse.nTab--;


    genParseNodeEnd(parse, measure);
    return measure;
}



function genParseInterpolatePoint(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolatePoint(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    lerp.amount     = genParse(parse);
    lerp.transform  = genParse(parse);
    lerp.showCenter = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParsePointOnPath(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const pop = new GPointOnPath(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(pop, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, pop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        pop.input0 = genParse(parse);
        pop.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        pop.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }


    pop.measure    = genParse(parse);
    pop.amount     = genParse(parse);
    pop.transform  = genParse(parse);
    pop.showCenter = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, pop);
    return pop;
}



function genParsePlace(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const place = new GPlace(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(place, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, place);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        place.input = genParse(parse);

    place.position   = genParse(parse);
    place.transform  = genParse(parse);
    place.showCenter = genParse(parse);


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, place);
    return place;
}



function genParseShapeApply(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const apply = new GApply(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(apply, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, apply);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        apply.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'props': apply.props = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, apply);
    return apply;
}



function genParseRender(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const render = new GRender(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(render, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, render);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        render.inputs.push(genParse(parse));

    render.retain   = genParse(parse);
    render.finalize = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, render);
    return render;
}


// function genParseColorStyleValue(parse)
// {
//     parse.pos++; // COLOR_STYLE_VALUE

//     const style = parse.move();

//     if (parse.settings.logRequests) 
//         logReqStyleValue(style, parse);

//     return parseColorStyleValue(style)[0];
// }



function genParseColorStyle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const style = new GColorStyle(nodeId, options);

    style.existing = options.existing;


    if (parse.settings.logRequests) 
        logReq(style, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, style);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    style.id       = parse.move();
    style.name     = options.nodeName;
    
    style.genValue = genParse(parse);

    
    parse.nTab--;

    
    style.linked = style.id != NULL;


    genParseNodeEnd(parse, style);
    return style;
}



//function genParseStyleParam(parse)
//{
    // const style = genParse(parse); 

    // if (STYLE_TYPES.includes(style.type))
    //     style.options.opacity = genParse(parse);

    // return style;
//}




function genParseTextValue(parse)
{
    parse.pos++; // tag

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(TEXT_VALUE, val, parse);

    return parseTextValue(val)[0];
}



function genParseText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GText(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == TEXT_VALUE) text.value = genParse(parse);
    else                          text.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}



function genParseTextLength(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const len = new GTextLength(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(len, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, len);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        len.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, len);
    return len;
}



function genParseTextTrim(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const trim = new GTextTrim(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(trim, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, trim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        trim.input = genParse(parse);

    trim.start = genParse(parse);
    trim.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, trim);
    return trim;
}



function genParseTextSubstring(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sub = new GTextSubstring(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sub, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sub);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sub.input = genParse(parse);

    sub.start = genParse(parse);
    sub.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sub);
    return sub;
}



function genParseTextContains(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cont = new GTextContains(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cont, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cont);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cont.input0 = genParse(parse);
        cont.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cont.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    parse.nTab--;


    genParseNodeEnd(parse, cont);
    return cont;
}



function genParseTextCase(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const _case = new GTextCase(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(_case, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, _case);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        _case.input = genParse(parse);

    _case.case = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, _case);
    return _case;
}



function genParseTextReplace(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const replace = new GTextReplace(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(replace, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, replace);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        replace.input = genParse(parse);

    replace.what = genParse(parse);
    replace.with = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, replace);
    return replace;
}




function genParseTextJoin(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const join = new GTextJoin(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(join, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, join);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    for (let i = 0; i < nInputs; i++)
        join.inputs.push(genParse(parse));


    join.with = genParse(parse);

    
    parse.nTab--;

        
    genParseNodeEnd(parse, join);
    return join;
}



function genParseTextPad(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const pad = new GTextPad(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(pad, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, pad);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        pad.input = genParse(parse);

    pad.startPad   = genParse(parse);
    pad.startCount = genParse(parse);
    pad.endPad     = genParse(parse);
    pad.endCount   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, pad);
    return pad;
}



function genParseTextCompare(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmp = new GTextCompare(nodeId, options);
   

    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cmp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        cmp.input0 = genParse(parse);
        cmp.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cmp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }
  
    
    cmp.operation = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cmp);
    return cmp;
}



function genParseTextCharacter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const char = new GTextCharacter(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(char, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, char);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        char.input = genParse(parse);

    char.code = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, char);
    return char;
}



function genParseNumberToText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num2text = new GNumberToText(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(num2text, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, num2text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        num2text.input = genParse(parse);

    num2text.format = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, num2text);
    return num2text;
}



function genParseTextToNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text2num = new GTextToNumber(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text2num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text2num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text2num.input = genParse(parse);

    text2num.format = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, text2num);
    return text2num;
}



function genParseTextToColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text2col = new GTextToColor(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text2col, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text2col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text2col.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, text2col);
    return text2col;
}



function genParseTextSplit(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const split = new GTextSplit(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(split, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, split);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        split.input = genParse(parse);

    split.separator = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, split);
    return split;
}



function genParseTextCSV(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const csv = new GTextCSV(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(csv, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, csv);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        csv.input = genParse(parse);

    csv.rowSeparator    = genParse(parse);
    csv.columnSeparator = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, csv);
    return csv;
}



function genParseTextJson(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const json = new GTextJson(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        consoleAssert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(json, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, json);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        json.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, json);
    return json;
}



function genParseTextFetch(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fetch = new GTextFetch(nodeId, options);
   

    if (parse.settings.logRequests) 
        logReq(fetch, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, fetch);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    fetch.request     = genParse(parse);
    fetch.cachedValue = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, fetch);
    return fetch;
}



function genParseTextFile(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const file = new GTextFile(nodeId, options);
   

    if (parse.settings.logRequests) 
        logReq(file, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, file);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    file.cachedValue = genParse(parse);
    file.path        = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, file);
    return file;
}


class Parse
{
    request;
    requestId;
    
    pos; 
    so;

    settings = {};

    save;


    log  = '';
    
    nTab = 0;

    get tab() { return this.inParam ? ' ' : (NL + HTAB.repeat(Math.max(0, this.nTab))); }

    
    inParam = false;

    
    updateNodeId;
    updateParamId;

    viewportZoom;

    currentProgress = 0;
    totalProgress   = 0;

    scope         = []; // current parse stack
    parsedNodes   = []; // must be evaluated to create the value updates


    repeats       = [];

    stopGenerate  = false;


    paramNodeIds  = [];

    updateParams  = [];
    updateValues  = [];
    updateObjects = [];
    updateStyles  = [];

    

    get next() { return this.request[this.pos]; }

    get afterNext() 
    { 
        return this.pos+1 < this.request.length 
             ? this.request[this.pos+1]
             : null;
    }



    constructor(request, firstPos, requestId, updateNodeId, updateParamId, viewportZoom, settings, save)
    {
        this.request       = request;
        this.requestId     = requestId;
          
        this.pos           = firstPos; 
        this.so            = 0;
        
        this.updateNodeId  = updateNodeId; 
        this.updateParamId = updateParamId;
   
        this.viewportZoom  = viewportZoom;

        this.settings      = settings;

        this.save          = save;
    }



    move()
    {
        //return this.request[this.pos++];

        const token = this.request[this.pos++];
        //console.log('token =', token);
        return token;
    }



    isLastRepeat() 
    {
        return isEmpty(this.repeats)
            ||    this.repeats.length == 1
               && this.repeats[0].iteration == this.repeats[0].total-1;
    }



    stop()
    {
        if (curRequestIds.includes(this.requestId))
        {
            removeFromArray(curRequestIds, this.requestId);
            true;
        }

        return this.stopGenerate;
    }
}



function genParse(parse, inParam = true)
{
    //console.log('parse.next', parse.next);

    if (!inParam)
        parse.inParam = false;


    let result = null;


         if (parse.next == PARAM                  ) result = genParseParam             (parse);
        
    else if (parse.next ==        LIST_VALUE             
          || parse.next == NUMBER_LIST_VALUE             
          || parse.next ==   TEXT_LIST_VALUE             
          || parse.next ==  SHAPE_LIST_VALUE      ) result = genParseListValue         (parse);
 
    else if (parse.next == NULL_NODE              ) result = genParseNull              (parse);

    else if (parse.next == LIST                   ) result = genParseList              (parse);
    else if (parse.next == CONDENSE               ) result = genParseCondense          (parse);
    else if (parse.next == SUBLIST                ) result = genParseSublist           (parse);
    else if (parse.next == UNIQUE                 ) result = genParseUnique            (parse);
    else if (parse.next == REVERSE_LIST           ) result = genParseReverseList       (parse);
    else if (parse.next == SORT                   ) result = genParseSort              (parse);
    else if (parse.next == COLUMN                 ) result = genParseColumn            (parse);
    else if (parse.next == CELL                   ) result = genParseCell              (parse);
    else if (parse.next == ITEMS                  ) result = genParseItems             (parse);
    else if (parse.next == SELECT                 ) result = genParseSelect            (parse);
    else if (parse.next == LIST_COUNT             ) result = genParseListCount         (parse);
    else if (parse.next == CONTAINS               ) result = genParseListContains      (parse);
    else if (parse.next == IF_ELSE                ) result = genParseIfElse            (parse);
    else if (parse.next == START                  ) result = genParseStart             (parse);
    else if (parse.next == REPEAT                 ) result = genParseRepeat            (parse);
    else if (parse.next == CACHE                  ) result = genParseCache             (parse);
    else if (parse.next == DEFINE                 ) result = genParseDefine            (parse);
    else if (parse.next == FREEZE                 ) result = genParseFreeze            (parse);
    else if (parse.next == TIMER                  ) result = genParseTimer             (parse);
    else if (parse.next == VALUE_NAME             ) result = genParseValueName         (parse);
     
    else if (parse.next == NUMBER_VALUE           ) result = genParseNumValue          (parse);
    else if (parse.next == NUMBER                 ) result = genParseNumber            (parse);
     
    else if (parse.next == NUMBER_SIGN            ) result = genParseSign              (parse);
    else if (parse.next == NUMBER_ABSOLUTE        ) result = genParseAbsolute          (parse);
    else if (parse.next == NUMBER_ROUND           ) result = genParseRound             (parse);
    else if (parse.next == NUMBER_MINMAX          ) result = genParseMinMax            (parse);
    else if (parse.next == NUMBER_LIMITS          ) result = genParseLimits            (parse);
    else if (parse.next == NUMBER_CONSTANT        ) result = genParseConstant          (parse);
    else if (parse.next == NUMBER_DATETIME        ) result = genParseDateTime          (parse);
    else if (parse.next == NUMBER_SEQUENCE        ) result = genParseSequence          (parse);
    else if (parse.next == NUMBER_RANGE           ) result = genParseRange             (parse);
    else if (parse.next == NUMBER_RANDOM          ) result = genParseRandom            (parse);
    else if (parse.next == NUMBER_NOISE           ) result = genParseNoise             (parse);
    else if (parse.next == NUMBER_PROBABILITY     ) result = genParseProbability       (parse);
    else if (parse.next == NUMBER_ACCUMULATE      ) result = genParseAccumulate        (parse);
    else if (parse.next == NUMBER_INTERPOLATE     ) result = genParseInterpolate       (parse);
    else if (parse.next == NUMBER_SOLVE           ) result = genParseSolve             (parse);
    else if (parse.next == NUMBER_ANIMATE         ) result = genParseAnimate           (parse);
    
    else if (parse.next == NUMBER_MATH            ) result = genParseMath              (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_SIMPLE_MATH     ) result = genParseSimpleMath        (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_ADD             ) result = genParseArithmetic        (parse, (nodeId, options) => new GAdd           (nodeId, options));
    else if (parse.next == NUMBER_SUBTRACT        ) result = genParseArithmetic        (parse, (nodeId, options) => new GSubtract      (nodeId, options));
    else if (parse.next == NUMBER_MULTIPLY        ) result = genParseArithmetic        (parse, (nodeId, options) => new GMultiply      (nodeId, options));
    else if (parse.next == NUMBER_DIVIDE          ) result = genParseArithmetic        (parse, (nodeId, options) => new GDivide        (nodeId, options));
    else if (parse.next == NUMBER_MODULO          ) result = genParseArithmetic        (parse, (nodeId, options) => new GModulo        (nodeId, options));
    else if (parse.next == NUMBER_EXPONENT        ) result = genParseArithmetic        (parse, (nodeId, options) => new GExponent      (nodeId, options));
     
    else if (parse.next == NUMBER_BOOLEAN         ) result = genParseBoolean           (parse);
    else if (parse.next == NUMBER_NOT             ) result = genParseArithmetic        (parse, (nodeId, options) => new GNot           (nodeId, options));
    else if (parse.next == NUMBER_AND             ) result = genParseArithmetic        (parse, (nodeId, options) => new GAnd           (nodeId, options));
    else if (parse.next == NUMBER_OR              ) result = genParseArithmetic        (parse, (nodeId, options) => new GOr            (nodeId, options));
    else if (parse.next == NUMBER_XOR             ) result = genParseArithmetic        (parse, (nodeId, options) => new GXor           (nodeId, options));
     
    else if (parse.next == NUMBER_CONDITION       ) result = genParseCondition         (parse);
    else if (parse.next == NUMBER_EQUAL           ) result = genParseConditionBase     (parse, (nodeId, options) => new GEqual         (nodeId, options));
    else if (parse.next == NUMBER_NOT_EQUAL       ) result = genParseConditionBase     (parse, (nodeId, options) => new GNotEqual      (nodeId, options));
    else if (parse.next == NUMBER_LESS            ) result = genParseConditionBase     (parse, (nodeId, options) => new GLess          (nodeId, options));
    else if (parse.next == NUMBER_LESS_OR_EQUAL   ) result = genParseConditionBase     (parse, (nodeId, options) => new GLessOrEqual   (nodeId, options));
    else if (parse.next == NUMBER_GREATER         ) result = genParseConditionBase     (parse, (nodeId, options) => new GGreater       (nodeId, options));
    else if (parse.next == NUMBER_GREATER_OR_EQUAL) result = genParseConditionBase     (parse, (nodeId, options) => new GGreaterOrEqual(nodeId, options));
 
    else if (parse.next == NUMBER_TRIG            ) result = genParseTrigonometric     (parse);
    else if (parse.next == NUMBER_SIN             ) result = genParseTrigBase          (parse, (nodeId, options) => new GSine          (nodeId, options));
    else if (parse.next == NUMBER_COS             ) result = genParseTrigBase          (parse, (nodeId, options) => new GCosine        (nodeId, options));
    else if (parse.next == NUMBER_TAN             ) result = genParseTrigBase          (parse, (nodeId, options) => new GTangent       (nodeId, options));
 
    else if (parse.next == TEXT_VALUE             ) result = genParseTextValue         (parse);
    else if (parse.next == TEXT                   ) result = genParseText              (parse);
    else if (parse.next == TEXT_LENGTH            ) result = genParseTextLength        (parse);
    else if (parse.next == TEXT_TRIM              ) result = genParseTextTrim          (parse);
    else if (parse.next == TEXT_SUBSTRING         ) result = genParseTextSubstring     (parse);
    else if (parse.next == TEXT_CONTAINS          ) result = genParseTextContains      (parse);
    else if (parse.next == TEXT_CASE              ) result = genParseTextCase          (parse);
    else if (parse.next == TEXT_CHAR              ) result = genParseTextCharacter     (parse);
    else if (parse.next == NUMBER_TO_TEXT         ) result = genParseNumberToText      (parse);
    else if (parse.next == TEXT_TO_NUMBER         ) result = genParseTextToNumber      (parse);
    else if (parse.next == TEXT_TO_COLOR          ) result = genParseTextToColor       (parse);
    else if (parse.next == TEXT_REPLACE           ) result = genParseTextReplace       (parse);
    else if (parse.next == TEXT_JOIN              ) result = genParseTextJoin          (parse);
    else if (parse.next == TEXT_PAD               ) result = genParseTextPad           (parse);
    else if (parse.next == TEXT_COMPARE           ) result = genParseTextCompare       (parse);
    else if (parse.next == TEXT_SPLIT             ) result = genParseTextSplit         (parse);
    else if (parse.next == TEXT_CSV               ) result = genParseTextCSV           (parse);
    else if (parse.next == TEXT_JSON              ) result = genParseTextJson          (parse);
    else if (parse.next == TEXT_FETCH             ) result = genParseTextFetch         (parse);
    else if (parse.next == TEXT_FILE              ) result = genParseTextFile          (parse);
 
    else if (parse.next == COLOR_VALUE            ) result = genParseColorValue        (parse);
    else if (parse.next == COLOR                  ) result = genParseColor             (parse);
    else if (parse.next == VALID_COLOR            ) result = genParseValidColor        (parse);
    else if (parse.next == CORRECT_COLOR          ) result = genParseCorrectColor      (parse);
    else if (parse.next == COLOR_CONTRAST         ) result = genParseColorContrast     (parse);
    else if (parse.next == COLOR_CONVERT_P3       ) result = genParseColorConvertP3    (parse);
    else if (parse.next == COLORBLIND             ) result = genParseColorBlind        (parse);
    else if (parse.next == COLOR_INTERPOLATE      ) result = genParseColorInterpolate  (parse);
    else if (parse.next == COLOR_BLEND            ) result = genParseColorBlend        (parse);
      
    else if (parse.next == FILL_VALUE             ) result = genParseFillValue         (parse);
    else if (parse.next == FILL                   ) result = genParseFill              (parse);
      
    else if (parse.next == COLOR_STOP_VALUE       ) result = genParseColorStopValue    (parse);
    else if (parse.next == COLOR_STOP             ) result = genParseColorStop         (parse);
      
    else if (parse.next == GRADIENT_VALUE         ) result = genParseGradientValue     (parse);
    else if (parse.next == GRADIENT               ) result = genParseGradient          (parse);
      
    else if (parse.next == STROKE_VALUE           ) result = genParseStrokeValue       (parse);
    else if (parse.next == STROKE                 ) result = genParseStroke            (parse);
      
    else if (parse.next == DROP_SHADOW_VALUE      ) result = genParseDropShadowValue   (parse);
    else if (parse.next == DROP_SHADOW            ) result = genParseDropShadow        (parse);
      
    else if (parse.next == INNER_SHADOW_VALUE     ) result = genParseInnerShadowValue  (parse);
    else if (parse.next == INNER_SHADOW           ) result = genParseInnerShadow       (parse);
      
    else if (parse.next == LAYER_BLUR_VALUE       ) result = genParseLayerBlurValue    (parse);
    else if (parse.next == LAYER_BLUR             ) result = genParseLayerBlur         (parse);
      
    else if (parse.next == BACK_BLUR_VALUE        ) result = genParseBackBlurValue     (parse);
    else if (parse.next == BACK_BLUR              ) result = genParseBackBlur          (parse);

    else if (parse.next == LAYER_MASK_VALUE       ) result = genParseLayerMaskValue    (parse);
    else if (parse.next == LAYER_MASK             ) result = genParseLayerMask         (parse);
      
    else if (parse.next == COLOR_STYLE            ) result = genParseColorStyle        (parse);
      
    else if (parse.next == RECTANGLE              ) result = genParseRectangle         (parse);
    else if (parse.next == LINE                   ) result = genParseLine              (parse);
    else if (parse.next == ELLIPSE                ) result = genParseEllipse           (parse);
    else if (parse.next == TRAPEZE                ) result = genParseTrapeze           (parse);
    else if (parse.next == POLYGON                ) result = genParsePolygon           (parse);
    else if (parse.next == STAR                   ) result = genParseStar              (parse);
    else if (parse.next == TEXT_SHAPE             ) result = genParseTextShape         (parse);
 
    else if (parse.next == POINT_VALUE            ) result = genParsePointValue        (parse);
    else if (parse.next == POINT                  ) result = genParsePoint             (parse);
    else if (parse.next == VECTOR_PATH_VALUE      ) result = genParseVectorPathValue   (parse);
    else if (parse.next == VECTOR_PATH            ) result = genParseVectorPath        (parse);
    
    else if (parse.next == VECTOR_VERTEX_VALUE    ) result = genParseVectorVertexValue (parse);
    else if (parse.next == VECTOR_VERTEX          ) result = genParseVectorVertex      (parse);
    else if (parse.next == VECTOR_EDGE_VALUE      ) result = genParseVectorEdgeValue   (parse);
    else if (parse.next == VECTOR_EDGE            ) result = genParseVectorEdge        (parse);
    else if (parse.next == VECTOR_REGION_VALUE    ) result = genParseVectorRegionValue (parse);
    else if (parse.next == VECTOR_REGION          ) result = genParseVectorRegion      (parse);
    else if (parse.next == VECTOR_NETWORK_VALUE   ) result = genParseVectorNetworkValue(parse);
    else if (parse.next == VECTOR_NETWORK         ) result = genParseVectorNetwork     (parse);

    else if (parse.next == BOOLEAN_VALUE          ) result = genParseShapeBooleanValue (parse);
    else if (parse.next == BOOLEAN                ) result = genParseShapeBoolean      (parse);

    else if (parse.next == SHAPE_GROUP_VALUE      ) result = genParseShapeGroupValue   (parse);
    else if (parse.next == SHAPE_GROUP            ) result = genParseShapeGroup        (parse);
 
    else if (parse.next == FRAME_VALUE            ) result = genParseFrameValue        (parse);
    else if (parse.next == FRAME                  ) result = genParseFrame             (parse);
 
    else if (parse.next == MOVE                   ) result = genParseMove              (parse);
    else if (parse.next == ROTATE                 ) result = genParseRotate            (parse);
    else if (parse.next == SCALE                  ) result = genParseScale             (parse);
    else if (parse.next == SKEW                   ) result = genParseSkew              (parse);

    else if (parse.next == CENTER                 ) result = genParseCenter            (parse);
    else if (parse.next == RESET_XFORM            ) result = genParseResetTransform    (parse);

    else if (parse.next == MEASURE_POINTS         ) result = genParseMeasurePoints     (parse);
    else if (parse.next == INTERPOLATE_POINT      ) result = genParseInterpolatePoint  (parse);
    else if (parse.next == POINT_ON_PATH          ) result = genParsePointOnPath       (parse);

    else if (parse.next == PLACE                  ) result = genParsePlace             (parse);
    else if (parse.next == SHAPE_APPLY            ) result = genParseShapeApply        (parse);
    
    else if (parse.next == RENDER                 ) result = genParseRender            (parse);
 
    else if (parse.next == GROUP_NODE             ) result = genParseGroupNode         (parse);
    else if (parse.next == GROUP_PARAM            ) result = genParseGroupParam        (parse);
 
    else if (parse.next == COMMENT                ) result = genParseComment           (parse);
    else if (parse.next == PANEL                  ) result = genParsePanel             (parse);

    else consoleError('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);


    parse.inParam = false;


    if (result)
        return result;
    else
    {
        parse.so++;
        return null;
    }
}



function genParseNodeStart(parse)
{
    const type     = parse.move();
    const nodeId   = parse.move();
    const nodeName = parse.move();

    
    parse.scope.push(nodeId);


    if (parse.parsedNodes.find(n => n.nodeId == nodeId))
        return [type, nodeId, {nodeName: nodeName}, true];


    const options = genParseNodeOptions(parse);

    options.nodeName = nodeName;


    return [type, nodeId, options, false];
}



function genParseNodeEnd(parse, node = null)
{
    parse.scope.pop();

    if (node)
    {
        if (isEmpty(parse.scope))
            node.topLevel = true;

        pushUnique(parse.parsedNodes, node);
    }
}



function genParseNodeOptions(parse)
{
    const opt = parseInt(parse.move());

    const options = 
    {
        active:       ((opt >>  0) & 1) != 0,
        beforeActive: ((opt >>  1) & 1) != 0,
        enabled:      ((opt >>  2) & 1) != 0,
        cached:       ((opt >>  3) & 1) != 0,
        unknown:      ((opt >>  4) & 1) != 0,
        hasInputs:    ((opt >> 20) & 1) != 0,
        existing:     ((opt >> 21) & 1) != 0
    };

    return options;
}



function genParseParamCount(parse)
{
    const nParamIds = parseInt(parse.move());

    if (parse.settings.logRequests) 
        parse.log += parse.tab + nParamIds;

    return nParamIds;
}



function genParseParam(parse)
{
    if (parse.next != PARAM) 
        return null;
        
    parse.move(); // PARAM
    const type = parse.move(); // type

    
    const nodeId  = parse.move();
    const paramId = parse.move();
    
    const param   = new GParam(nodeId, paramId);
 
    
    pushUnique(parse.paramNodeIds, nodeId);


    if (parse.settings.logRequests) 
        logReqParam(param, type, parse);


    return param;
}



function genParseParamId(parse)
{
    const paramId = parse.move();

    if (parse.settings.logRequests)
        parse.log += parse.tab + paramId;

    return paramId;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + HTAB.repeat(Math.max(0, this.nTab)); 
    }
}



function log(str)
{
    debugInfo.innerHTML = str;
}



function logFunction(funcName, obj = null)
{
    let str = funcName;

    if (obj)
        str = obj.id + '.' + str;

    console.log(
        '%c ' + str + ' ', 
        'background: #fc0; color: #632;');
}



function logString(str, color = 'white', background = 'red')
{
    console.log(
        '%c ' + str + ' ', 
        'background: ' + background + '; color: ' + color + ';');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = '↓ ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nInputs = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + HTAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nInputs;

        newLine = true;

        nTab++;

        for (let j = 0; j < nInputs; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + HTAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logStyleUpdates(styles)
{
    console.log(
        '%cstyles', 
        'background: #b4d; color: white;', 
        styles);
}



function logSavePages(pageJson)
{
    console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;');
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;');
}



function logSaveConnections(conns)
{
    let log = 'SAVING ' + conns.length + ' ' + countString(conns.length, 'CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUpdateSavedConnections(conns)
{
    let log = 'UPDATING ' + conns.length + ' ' + countString(conns.length, 'SAVED CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUndoStack()
{
    let log = 
        'UNDO STACK:\n'
        + actionManager.actions.map(a => '    ' + a.name).join('\n');

    console.log('%c%s', 'background: #ffd; color: #b80;', log);
}



function logRedoStack()
{
    let log = 
         'REDO STACK:\n'
        + actionManager.redoActions.map(a => '    ' + a.name).join('\n');

    console.log('%c%s', 'background: #fff4e8; color: #c64;', log);
}


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = '↓ ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReq(node, parse, ignore, nInputs = -1)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node, ignore);

    if (    nInputs > -1
        && !ignore)
        parse.log += ' ' + nInputs;
}



function logReqNodeId(node, ignore = false)
{
    return ' ' 
         + logReqId(node.nodeId) 
         + ' ' + logReqId(node.nodeName)
         + (!ignore
            ? logReqOptions(node)
            : '');
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if ( node.options.active      ) log += ' ' + ACTIVE;
    if ( node.options.beforeActive) log += ' ' + BEFORE_ACTIVE;
    if (!node.options.enabled     ) log += ' ' + DISABLED;

    if (!node.cached              ) log += ' ' + NOCACHE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



function logReqColorContrast(lerp, nInputs, valueIndex, parse, ignore)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp, ignore);

    if (!ignore)
    {
        parse.log += ' ' + nInputs;

        if (nInputs == 1)
            parse.log += ' ' + valueIndex;
    }
}



function logReqValue(type, val, parse)
{
    parse.log += parse.tab + type + ' ' + displayValue(type, val);
}



// function logReqListValue(list, parse, ignore)
// {
//     parse.log += parse.tab + LIST_VALUE + ' ' + displayValue(LIST_VALUE, list);
// }



// function logReqColorValue(val, parse, ignore)
// {
//     parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
// }



// function logReqNumberValue(val, parse, ignore)
// {
//     parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
// }



// function logReqFillValue(fill, parse, ignore)
// {
//     parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
// }



// function logReqStrokeValue(stroke, parse, ignore)
// {
//     // parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
// }



// function logReqColorStopValue(stop, parse, ignore)
// {
//     // parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
// }



function logSavedNode(nodeKey, darkMode)
{
    const log  = formatSavedNodeJson(figGetPageData(nodeKey, false));

    if (darkMode)
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fa24; color: white;', 
            noNodeTag(nodeKey), 
            'background: #fa44; color: #edc;',
            log);
    }
    else
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fdb; color: black;', 
            noNodeTag(nodeKey), 
            'background: #fed; color: black;',
            log);
    }
}



function formatSavedNodeJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')

        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '')

        .split(HTAB + '"params":\n').join('') // have to do .split().join() because there's no .replace() in TS

        .split('": "').join(': ')
        .split('", "').join(': ')

        .split(HTAB + '"').join(HTAB)
        .split(HTAB + HTAB + '["').join(HTAB + HTAB)
        
        .split('",\n').join('\n')
        .split('"\n').join('\n')
        
        .split('"],\n').join('\n');


    if (formJson[formJson.length-1] == '"')
        formJson = formJson.substring(0, formJson.length - 1);

    if (formJson.substring(formJson.length-2) == '"]')    
        formJson = formJson.substring(0, formJson.length - 2);

    return formJson;
}



function formatSavedDataJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')
        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '');

    return formJson;
}



function logSavedConn(conn, darkMode)
{
    const strConn = connToString(conn, true);

    if (darkMode)
    {
        console.log(
            '%c%s', 
            'background: #4f44; color: #ded', 
            strConn); 
    }
    else
    {
        console.log(
            '%c%s', 
            'background: #cfc; color: black;', 
            strConn); 
    }
}


// Observer = 2°

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inversem3(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inversem3(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgbSaturateHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[1] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsl(rgb, amount)
{
    const hsl = rgb2hsl(rgb);
    hsl[1] *= amount;
    return hsl2rgb(hsl);
}


function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h++;
    h %= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    while (h < 0) h++;
    h %= 1;

    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    return lrgb2xyz(degamma(rgb, cs), cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    return regamma(xyz2lrgb(xyz, cs), cs);
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}


function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = 0.008856; //cube(6/29);
    const k = 903.3;    //cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;
    yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;
    zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;


    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = 0.008856 / 100; //cube(6/29) / 100;
    const k = 903.3    / 100; //cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l, a, b) 
{
    return [
        l + 0.3963377774 * a + 0.2158037573 * b,
        l - 0.1055613458 * a - 0.0638541728 * b,
        l - 0.0894841775 * a - 1.2914855480 * b ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


const hclok_C_scale = 0.89;


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclok2rgb(hcl, cs = sRGB)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 

    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclok2rgb_(h, c, l, cs = sRGB)
{
    return hclok2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclok(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));

    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclok_(r, g, b, cs = sRGB)
{
    return rgb2hclok([r, g, b], cs);
}



function hclab2lab(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hclab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hclab2lab(hcl), cs);
}



function lab2hclab(lab)
{
    let hcl = opp2pol(lab);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclab(rgb, cs = sRGB)
{
    return lab2hclab(rgb2lab(rgb, cs));
}



function hcluv2luv(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hcluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hcluv2luv(hcl), cs);
}



function luv2hcluv(luv)
{
    let hcl = opp2pol(luv);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hcluv(rgb, cs = sRGB)
{
    return luv2hcluv(rgb2luv(rgb, cs));
}


function srgb2p3(rgb)
{
    const p3 = 
        [ [ 0.8225, 0.1774, 0      ],
          [ 0.0332, 0.9669, 0      ],
          [ 0.0171, 0.0724, 0.9108 ] ];

    rgb = degamma(rgb);

    return regamma(dot3(p3, rgb));
}



function p32srgb(rgb) 
{
    const invp3 = 
        [ [ 1.2249, -0.2247, 0      ],
          [-0.0420,  1.0419, 0      ],
          [-0.0197, -0.0786, 1.0979 ] ];
  
    rgb = dot3(invp3, degamma(rgb));
  
    return regamma(rgb);
}


const ColorSpaces = 
[
    ['hex',   'Hex'   ],
    ['rgb',   'RGB'   ], 
    ['hsv',   'HSV'   ], 
    ['hsl',   'HSL'   ], 
    ['hclok', 'HCL/ok'],
    ['hclab', 'HCL/ab'],
    ['hcluv', 'HCL/uv'],
    ['oklab', 'okLab' ],
    ['lab',   'Lab'   ],
    ['luv',   'Luv'   ]
];



class ColorSpace
{
    hex   = Object.freeze(0);
    rgb   = Object.freeze(1);
    hsv   = Object.freeze(2);
    hsl   = Object.freeze(3);
    hclok = Object.freeze(4);
    hclab = Object.freeze(5);
    hcluv = Object.freeze(6);
    oklab = Object.freeze(7);
    lab   = Object.freeze(8);
    luv   = Object.freeze(9);
}



class Color
extends Float32Array
{
    get r() { return this[0]; }
    get g() { return this[1]; }
    get b() { return this[2]; }
    get a() { return this[3]; }
    get s() { return this[4]; }

    set r(r) { this[0] = r; }
    set g(g) { this[1] = g; }
    set b(b) { this[2] = b; }
    set a(a) { this[3] = a; }
    set s(s) { this[4] = s; }



    constructor(c = null)
    {
        super(5); // c1, c2, c3, a, s (space)

        if (c)
        {
            this.r = c.r;
            this.g = c.g;
            this.b = c.b;
            this.a = c.a;
            this.s = c.s;
        }
        else
        {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.s = ColorSpace.rgb;
        }
    }
}


const ColorEpsilon = 0.001;



function rgb2dataColor(rgb)
{
    const _space = 'rgb';

    return [
        _space, 
        getNormalColorValue(rgb[0], _space, 0), 
        getNormalColorValue(rgb[1], _space, 1), 
        getNormalColorValue(rgb[2], _space, 2) ]; 
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = ColorEpsilon)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}



function dataColorIsOk(col, lim = ColorEpsilon)
{
    return rgbIsOk(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const rgba_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN,
    Number.NaN ];


const rgbInvalid  = [0xff, 0, 0xff];
const rgbaInvalid = [0xff, 0, 0xff, 0xff];


const dataColor_NaN = Object.freeze([
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ]);


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inversem3(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inversem3(CAT);


const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],
            [ 0.0329845436, 0.9293118715,  0.0361456387 ],
            [ 0.0482003018, 0.2643662691,  0.6338517070 ]];

const invM1 = inversem3(M1);



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = ColorEpsilon)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbaIsValid(rgba, lim = ColorEpsilon)
{
    return rgba[0] > -lim && rgba[0] < 1 + lim 
        && rgba[1] > -lim && rgba[1] < 1 + lim 
        && rgba[2] > -lim && rgba[2] < 1 + lim
        && rgba[3] > -lim && rgba[3] < 1 + lim;
}



function rgbIsOk(rgb, lim = ColorEpsilon)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function rgbaIsOk(rgba, lim = ColorEpsilon)
{
    return !rgbaIsNaN  (rgba)
        &&  rgbaIsValid(rgba, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbaLerp(rgba1, rgba2, t)
{
    return [ lerp(rgba1[0], rgba2[0], t),
             lerp(rgba1[1], rgba2[1], t),
             lerp(rgba1[2], rgba2[2], t),
             lerp(rgba1[3], rgba2[3], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a !== undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a = 1)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a = 1)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclok(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < ColorEpsilon
        && Math.abs(rgb1[1] - rgb2[1]) < ColorEpsilon
        && Math.abs(rgb1[2] - rgb2[2]) < ColorEpsilon;        
}



function style2rgba(style) // SLOW
{
    utilContext.fillStyle = style;
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) // SLOW
{
    utilContext.fillStyle = getStyleValue(obj, style);
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])
               : (darkMode ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))
           : (darkMode ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningRgba(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])  
         : (darkMode ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);  
}



function getWarningStyles(colBack)
{
    let warnStyle1, 
        warnStyle2;
    
        
    const colWarning = getDefaultWarningRgba(colBack);

     
    if (!rgbIsNaN(colBack))
    {
        const hclBack = rgb2hclok(colBack);

        const hclBack1 = [...hclBack];
        const hclBack2 = [...hclBack];

        hclBack1[0] += 1/12;  if (hclBack1[0] > 1) hclBack1[0] -= 1;
        hclBack2[0] -= 1/12;  if (hclBack2[0] < 0) hclBack2[0] += 1;


        const altBack1 = rgb_a(clampRgb(hclok2rgb(hclBack1)), 0.35);
        const altBack2 = rgb_a(clampRgb(hclok2rgb(hclBack2)), 0.35);

        const factor   = getWarningFactor(colBack);

        const colWarn1 = rgbaLerp(colWarning, altBack1, factor);
        const colWarn2 = rgbaLerp(colWarning, altBack2, factor);
        
        warnStyle1     = rgba2style(colWarn1);
        warnStyle2     = rgba2style(colWarn2);
    }
    else
    {
        warnStyle1 = rgba2style(colWarning);
        warnStyle2 = rgba2style(colWarning);
    }


    return [warnStyle1, 
            warnStyle2];
}



function getWarningGradient(i, style1, style2)
{
    return 'repeating-linear-gradient('
            + '-45deg, '
            + 'transparent 0 ' + i   + 'px,' 
            +  style1 + ' '    + i   + 'px ' + i*2 +'px,'
            + 'transparent '   + i*2 + 'px ' + i*3 +'px,'
            +  style2 + ' '    + i*3 + 'px ' + i*4 +'px)';
}



function getWarningFactor(colBack)
{
    let dr, dg, db;

    if (colBack[0] < 0) dr = -colBack[0]; else if (colBack[0] > 1) dr = colBack[0] - 1; else dr = 0;
    if (colBack[1] < 0) dg = -colBack[1]; else if (colBack[1] > 1) dg = colBack[1] - 1; else dg = 0;
    if (colBack[2] < 0) db = -colBack[2]; else if (colBack[2] > 1) db = colBack[2] - 1; else db = 0;
    
    const d   = [dr, dg, db].sort()[1];
    const avg = (dr + dg + db) / 3;

    const factor = Math.min((d + avg) / 2, 1);

    // if (this.id == 'color')
    // {
    //     console.log('colBack =', colBack);
    //     console.log('dr     =', dr);
    //     console.log('dg     =', dg);
    //     console.log('db     =', db);
    //     console.log('d      =', d);
    //     console.log('avg    =', avg);
    //     console.log('factor =', factor);
    //     console.log('');
    // }

    return factor;
}



function getStripeBackColor(rgbBack)
{
    let rgbStripeBack = [...rgbBack];
        
    const factor = getWarningFactor(rgbBack);

    if (factor > 0)
    {
        const hcl = rgb2hclok(clampRgb(rgbBack));
        hcl[1] /= 2;
        

        rgbStripeBack = rgbLerp(rgbBack, clipChroma(hclok2rgb(hcl)), factor);
    }

    return rgbStripeBack;
}



function getDefaultWarningStyle(rgba)
{
    return !rgbaIsNaN(rgba)
         ? (isDark(rgba)  ? '#ffffff29' : '#00000022')
         : (darkMode ? '#ffffff08' : '#00000006'); 
}



function clampRgb(_rgb)
{
    const rgb = [..._rgb];

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function clampChan(val)
{
    return Math.min(Math.max(0, val), 1);
}



function setChan(_col, chan, val)
{
    const col = [..._col];
    col[chan] = val;
    return col;
}



function clipChroma(rgb)
{
    let hcl = rgb2hclok(rgb);

    let loopProtect = 10000;

    while (!rgbIsValid(hclok2rgb(hcl))
         && hcl[1] > 0.001
         && loopProtect-- > 0)
        hcl[1] -= 0.001;

    rgb = hclok2rgb(hcl);

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function noColorStyle(rgba)
{
    if (!rgbaIsNaN(rgba))
        return 'transparent';
    else
    {
        return darkMode
            ? 'rgba(56, 56, 56, 0.95)'
            : 'rgba(255, 255, 255, 0.95)';
    }
}


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function rgba2hex(rgba)
{
    let hex =
          Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function validHex2rgba(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgba_NaN 
           : hex2rgba(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }


    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    
    return rgb;
}



function hex2rgba(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgba = [];

    if (hex.length >= 8)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = parseInt(hex.slice(6, 8), 16); 
    }
    else if (hex.length >= 6)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = 0xff; 
    }
    else if (hex.length >= 4)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = parseInt(hex[3], 16) * 0x11; 
    }
    else if (hex.length == 3)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v; 
        rgba[1] = v; 
        rgba[2] = v; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v * 0x11; 
        rgba[1] = v * 0x11; 
        rgba[2] = v * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 0)
    {
        rgba[0] = 0; 
        rgba[1] = 0; 
        rgba[2] = 0;         
        rgba[3] = 0; 
    }


    rgba[0] /= 0xff;
    rgba[1] /= 0xff;
    rgba[2] /= 0xff;
    rgba[3] /= 0xff;


    return rgba;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


function colorSpace     (index) { return ColorSpaces[index][0]; }
function colorSpaceIndex(space) { return ColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.showAllColorSpaces 
           ? ColorSpaces.length
        : ColorSpaces.length - 5; 
}



const rgbFactor  = [255, 255, 255];
const hs_Factor  = [360, 100, 100];
const hclFactor  = [360, 100, 100];
const oppFactor  = [100, 100, 100];
  
 
const rgbScale   = [255, 255, 255];
  
const hs_Scale   = [360, 100, 100];
 
const hclokScale = [360, 50,  100];
const hclabScale = [360, 400, 100];
const hcluvScale = [360, 330, 100];
 
 
const oklabScale = [100,  30,  30];
const labScale   = [100, 100, 100];
const luvScale   = [100, 150, 150];
 


function colorFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':
        case 'hsl':   return hs_Factor;

        case 'hclok':
        case 'hclab':
        case 'hcluv': return hclFactor;

        case 'oklab':  
        case 'lab':      
        case 'luv':   return oppFactor;   
        
        default:      consoleError('invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    
        case 'rgb':   scale = rgbScale;   break;

        case 'hsv':    
        case 'hsl':   scale = hs_Scale;   break;

        case 'hclok': scale = hclokScale; break;
        case 'hclab': scale = hclabScale; break;
        case 'hcluv': scale = hcluvScale; break;

        case 'oklab': scale = oklabScale; break;
        case 'lab':   scale = labScale;   break;
        case 'luv':   scale = luvScale;   break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function normalizeRgb(rgb)
{
    return [ rgb[0] / 255,
             rgb[1] / 255,
             rgb[2] / 255 ];
}



function scaleRgb(rgb)
{
    return [ Math.round(rgb[0] * 255),
             Math.round(rgb[1] * 255),
             Math.round(rgb[2] * 255) ];
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':   switchToHex   (node); break;
        case 'rgb':   switchToRgb   (node); break;

        case 'hsv':   switchToHsv   (node); break;
        case 'hsl':   switchToHsl   (node); break;

        case 'hclok': switchToHclok (node); break;
        case 'hclab': switchToHclab (node); break;
        case 'hcluv': switchToHcluv (node); break;

        case 'oklab': switchToOklab (node); break;
        case 'lab':   switchToLab   (node); break;
        case 'luv':   switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex  (node) { switchToRgbControls   (node); switchToTextbox(node); }
function switchToRgb  (node) { switchToRgbControls   (node);                        }

function switchToHsv  (node) { switchToHs_Controls   (node, 'V');                   }
function switchToHsl  (node) { switchToHs_Controls   (node, 'L');                   }
             
function switchToHclok(node) { switchToHclOklControls(node);                        }
function switchToHclab(node) { switchToHclLabControls(node);                        }
function switchToHcluv(node) { switchToHclLuvControls(node);                        }
             
function switchToOklab(node) { switchToOklabControls (node, 'a', 'b');              }
function switchToLab  (node) { switchToLabControls   (node, 'a', 'b');              }
function switchToLuv  (node) { switchToLuvControls   (node, 'u', 'v');              }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.controls[0].min = 
    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.controls[0].max = 
    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hclokScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hclabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hcluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.controls[0].showHex = show;
    node.param2.controls[0].showHex = show;
    node.param3.controls[0].showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.controls[0].wrapValue = c1wrap;
    node.param1.controls[0].setSuffix(c1suffix, c1suffix != '');

    node.param1.controls[0].setMin(c1min); 
    node.param2.controls[0].setMin(c2min);
    node.param3.controls[0].setMin(c3min);
    
    node.param1.controls[0].setMax(c1max); 
    node.param2.controls[0].setMax(c2max); 
    node.param3.controls[0].setMax(c3max); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();

    node.param1.controls[0].suffixOffsetY = 0;
}



function switchToTextbox(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div, node.paramHolder);
    removeDivFrom(node.param2.div, node.paramHolder);
    removeDivFrom(node.param3.div, node.paramHolder);
        
    appendDivTo(node.paramColor.div, node.paramHolder);
}



function removeParamDivs(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div,     node.paramHolder);
    removeDivFrom(node.param2.div,     node.paramHolder);
    removeDivFrom(node.param3.div,     node.paramHolder);
    
    removeDivFrom(node.paramColor.div, node.paramHolder);
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    removeDivFrom(node.paramColor.div, node.paramHolder);

    appendDivTo(node.param1.div, node.paramHolder);
    appendDivTo(node.param2.div, node.paramHolder);
    appendDivTo(node.param3.div, node.paramHolder);
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':   return getNormalValueHs_ (value, chan);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':   return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':   return getNormalColorHs_(c1, c2, c3);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':   return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return getScaledDataColorRgb(         color[1], color[2], color[3]);

        case 'hsv':   return getScaledDataColorHs_('hsv',   color[1], color[2], color[3]);
        case 'hsl':   return getScaledDataColorHs_('hsl',   color[1], color[2], color[3]);

        case 'hclok': return getScaledDataColorHcl('hclok', color[1], color[2], color[3]);
        case 'hclab': return getScaledDataColorHcl('hclab', color[1], color[2], color[3]);
        case 'hcluv': return getScaledDataColorHcl('hcluv', color[1], color[2], color[3]);

        case 'oklab': return getScaledDataColorOpp('oklab', color[1], color[2], color[3]);
        case 'lab':   return getScaledDataColorOpp('lab',   color[1], color[2], color[3]);
        case 'luv':   return getScaledDataColorOpp('luv',   color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function colorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':   
        case 'hsl':   return hs_Factor;

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':   return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbScale;

        case 'hsv':   
        case 'hsl':   return hs_Scale;

        case 'hclok': return hclokScale;
        case 'hclab': return hclabScale;
        case 'hcluv': return hcluvScale;

        case 'oklab': return oklabScale;
        case 'lab':   return labScale;
        case 'luv':   return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return           col;

        case 'hsv':   return hsv2rgb  (col);
        case 'hsl':   return hsl2rgb  (col);

        case 'hclok': return hclok2rgb(col);
        case 'hclab': return hclab2rgb(col);
        case 'hcluv': return hcluv2rgb(col);

        case 'oklab': return oklab2rgb(col);
        case 'lab':   return lab2rgb  (col);
        case 'luv':   return luv2rgb  (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':   return convert2rgb    (color);

        case 'hsv':   return convert2hsv    (color);
        case 'hsl':   return convert2hsl    (color);

        case 'hclok': return convert2hclok  (color);
        case 'hclab': return convert2hclab  (color);
        case 'hcluv': return convert2hcluv  (color);

        case 'oklab': return dataColor2oklab(color);
        case 'lab':   return convert2lab    (color);
        case 'luv':   return convert2luv    (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   rgb =           col;  break;

        case 'hsv':   rgb = hsv2rgb  (col); break;
        case 'hsl':   rgb = hsl2rgb  (col); break;

        case 'hclok': rgb = hclok2rgb(col); break;
        case 'hclab': rgb = hclab2rgb(col); break;
        case 'hcluv': rgb = hcluv2rgb(col); break;

        case 'oklab': rgb = oklab2rgb(col); break;
        case 'lab':   rgb = lab2rgb  (col); break;
        case 'luv':   rgb = luv2rgb  (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsv = rgb2hsv(          col ); break;

        case 'hsv':   hsv =                   col;   break;
        case 'hsl':   hsv = rgb2hsv(hsl2rgb  (col)); break;

        case 'hclok': hsv = rgb2hsv(hclok2rgb(col)); break;
        case 'hclab': hsv = rgb2hsv(hclab2rgb(col)); break;
        case 'hcluv': hsv = rgb2hsv(hcluv2rgb(col)); break;

        case 'oklab': hsv = rgb2hsv(oklab2rgb(col)); break;
        case 'lab':   hsv = rgb2hsv(lab2rgb  (col)); break;
        case 'luv':   hsv = rgb2hsv(luv2rgb  (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsl = rgb2hsl(          col ); break;

        case 'hsv':   hsl = rgb2hsl(hsv2rgb  (col)); break;
        case 'hsl':   hsl =                   col;   break;

        case 'hclok': hsl = rgb2hsl(hclok2rgb(col)); break;
        case 'hclab': hsl = rgb2hsl(hclab2rgb(col)); break;
        case 'hcluv': hsl = rgb2hsl(hcluv2rgb(col)); break;

        case 'oklab': hsl = rgb2hsl(oklab2rgb(col)); break;
        case 'lab':   hsl = rgb2hsl(lab2rgb  (col)); break;
        case 'luv':   hsl = rgb2hsl(luv2rgb  (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function dataColor2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2oklab(          col ); break;

        case 'hsv':   lab = rgb2oklab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2oklab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2oklab(hclok2rgb(col)); break;
        case 'hclab': lab = rgb2oklab(hclab2rgb(col)); break;
        case 'hcluv': lab = rgb2oklab(hcluv2rgb(col)); break;

        case 'oklab': lab =                     col;   break;
        case 'lab':   lab = rgb2oklab(lab2rgb  (col)); break;
        case 'luv':   lab = rgb2oklab(luv2rgb  (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2lab(          col ); break;

        case 'hsv':   lab = rgb2lab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2lab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2lab(hclok2rgb(col)); break;
        case 'hclab': lab =         hclab2lab(col);  break;
        case 'hcluv': lab = rgb2lab(hcluv2rgb(col)); break;

        case 'oklab': lab = rgb2lab(oklab2rgb(col)); break;
        case 'lab':   lab =                   col;   break;
        case 'luv':   lab = rgb2lab(luv2rgb  (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   luv = rgb2luv(          col ); break;

        case 'hsv':   luv = rgb2luv(hsv2rgb  (col)); break;
        case 'hsl':   luv = rgb2luv(hsl2rgb  (col)); break;

        case 'hclok': luv = rgb2luv(hclok2rgb(col)); break;
        case 'hclab': luv = rgb2luv(hclab2rgb(col)); break;
        case 'hcluv': luv =         hcluv2luv(col);  break;

        case 'oklab': luv = rgb2luv(oklab2rgb(col)); break;
        case 'lab':   luv = rgb2luv(lab2rgb  (col)); break;
        case 'luv':   luv =                   col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclok(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclok(          col);  break;

        case 'hsv':   hcl = rgb2hclok(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclok(hsl2rgb  (col)); break;

        case 'hclok': hcl =                     col;   break;
        case 'hclab': hcl = rgb2hclok(hclab2rgb(col)); break;
        case 'hcluv': hcl = rgb2hclok(hcluv2rgb(col)); break;

        case 'oklab': hcl = rgb2hclok(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hclok(lab2rgb  (col)); break;
        case 'luv':   hcl = rgb2hclok(luv2rgb  (col)); break;
    }

    return [
       'hclok',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclab(          col) ; break;
        
        case 'hsv':   hcl = rgb2hclab(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclab(hsl2rgb  (col)); break;
        
        case 'hclok': hcl = rgb2hclab(hclok2rgb(col)); break;
        case 'hclab': hcl =                     col;   break;
        case 'hcluv': hcl = rgb2hclab(hcluv2rgb(col)); break;
        
        case 'oklab': hcl = rgb2hclab(oklab2rgb(col)); break;
        case 'lab':   hcl = lab2hclab(          col ); break;
        case 'luv':   hcl = rgb2hclab(luv2rgb  (col)); break;
    }

    return [
       'hclab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hcluv(          col ); break;

        case 'hsv':   hcl = rgb2hcluv(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hcluv(hsl2rgb  (col)); break;

        case 'hclab': hcl = rgb2hcluv(hclab2rgb(col)); break;
        case 'hcluv': hcl =                     col;   break;
        case 'hclok': hcl = rgb2hcluv(hclok2rgb(col)); break;

        case 'oklab': hcl = rgb2hcluv(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hcluv(lab2rgb  (col)); break;
        case 'luv':   hcl = luv2hcluv(          col ); break;
    }

    return [
       'hcluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


</script>


<script>
'use strict';

////////////////////////////////////////////////////



onerror = (event, source, line, pos, error) =>
{
    initCrashDialog(event, error);
    showCrashDialog();
};


const generatorVersion = 193;


const MAX_INT32        = 2147483647;
  
const NULL             = '';
  
const HTAB             = '  '; // half-tab
const TAB              = '    ';
const NL               = '\n';
  
const GENERATOR_LOGO   = '◦ G •';
const OBJECT_PREFIX    = GENERATOR_LOGO + ' ';

const nodeTag          = 'G_NODE';
const connTag          = 'G_CONN';
const pageTag          = 'G_PAGE';
const tempTag          = 'G_TEMP';


const identity = Object.freeze(
    [[1, 0, 0],
     [0, 1, 0],
     [0, 0, 1]]);



const Epsilon = 0.0000001;
const Tau     = Math.PI * 2;



var enableAsserts = false;



function almostZero(x, eps = 0.0000001) 
{ 
    return Math.abs(x) < eps ? 0 : x;
}



function nozero(x, eps = Epsilon) 
{ 
    return x != 0 
         ? x 
         : (x < 0 ? -eps : eps);
}



function nozerov(v) 
{ 
    return point(
        nozero(v.x), 
        nozero(v.y)); 
}



function equal(a, b, eps = Epsilon)
{
    return Math.abs(b - a) < eps;
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };
 

function toInt(f) { return Math.floor(f) | 0; }



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >>  1;
    x |= x >>  2;
    x |= x >>  4;
    x |= x >>  8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function gcd(a, b)
{
    let temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



function distance(p1, p2)
{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function dot(v1, v2)
{
    return v1.x * v2.x + v1.y * v2.y;
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(...mm)
{
    consoleAssert(mm.length > 0, 'mulm3m3() must take at least one argument');

    let result = clone(mm[0]);

    for (let a = 1; a < mm.length; a++)
    {
        const m1 = result;
        const m2 = mm[a];

        const m = [[0, 0, 0],
                   [0, 0, 0],
                   [0, 0, 0]];

        for (let i = 0; i < 3; i++)
        {
            for (let j = 0; j < 3; j++)
            {
                /*	calculate the dot product of ith row 
                    of this and jth column of m  */
                for (let k = 0; k < 3; k++)
                    m[i][j] += m1[i][k] * m2[k][j];
            }
        }

        result = m;
    }

    return result;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inversem3(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function createRotateTransform(angle)
{
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    return [[ cosA, sinA, 0],
            [-sinA, cosA, 0],
            [ 0,    0,    1]];
}



function createTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0)
{
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);

    return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],
            [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],
            [0,                         0,                         1]];
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return v1.x * v2.y - v1.y * v2.x;
}	



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divv(v1, v2)
{
    return point(
        v1.x / v2.x,
        v1.y / v2.y);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function charCodeArrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function stringToCharCodeArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    const newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    const size = Math.min(srcSize, dstSize);

    for (let i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function arraysAreEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (let i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function arraysIntersect(array1, array2)
{
    return array1.findIndex(i => array2.includes(i)) > -1;
}



function  leftArrowChar(list) { return list ? '⟸' : '⟵'; }
function rightArrowChar(list) { return list ? '⟹' : '⟶'; }

function nodeNameForStorage(nodeId) { return nodeTag + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag + ' ' + name;   }
function pageNameForStorage(name)   { return pageTag + ' ' + name;   }



function parseBool(str) 
{ 
    return str.toLowerCase() == 'true'
        || str == '1';
}



function connToString(_conn, logSpace = false)
{
    return getConnectionString(
        _conn.outputNodeId,
        _conn.outputId,
        _conn.outputOrder,
        _conn.inputNodeId,
        _conn.inputId,
        _conn.list,
        logSpace);
}



function getConnectionKey(outputNodeId, outputId, outputOrder, inputNodeId, inputId)
{
    return connNameForStorage(
          outputNodeId + ' '
        + outputId     + ' '
        + outputOrder  + ' '
        + inputNodeId  + ' '
        + inputId);
}



function getStorageConnKey(conn)
{
    return getConnectionKey(
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId);
}



function getConnKey(conn)
{
    return getConnectionKey(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id);
}



function getConnString(conn, logSpace = false)
{
    return getConnectionString(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id,
        conn.list,
        logSpace);
}



function getConnectionString(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, logSpace = false)
{
    const  sp   = logSpace ? ' ' : '  '; 
    const jsp   = logSpace ? ''  : ' '; 

    const arrow = 
          sp 
        + subscriptNumber(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder) 
        + rightArrowChar(typeof list == 'string' ? parseBool(list) : list) 
        + sp;

    const join  = jsp + '.' + jsp;

    return '( '
         + outputNodeId + join + outputId
         + arrow
         + inputNodeId  + join + inputId
         + ' )';
}



function getPageKey(pageId)
{
    return pageNameForStorage(pageId);
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '⁰';
        case '1': return '¹';
        case '2': return '²';
        case '3': return '³';
        case '4': return '⁴';
        case '5': return '⁵';
        case '6': return '⁶';
        case '7': return '⁷';
        case '8': return '⁸';
        case '9': return '⁹';
        case '.': return '·';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '₀';
        case '1': return '₁';
        case '2': return '₂';
        case '3': return '₃';
        case '4': return '₄';
        case '5': return '₅';
        case '6': return '₆';
        case '7': return '₇';
        case '8': return '₈';
        case '9': return '₉';
        case '.': return ' ';
    }
}



function boolToString(bool)
{
    return bool ? 'true' : 'false';
}



function isValid(val)
{
    return val != undefined
        && val != null;
}



function isEmpty(array)
{
    return array.length == 0;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (isEmpty(array))
        return null;

    let last = array.at(-1);
    array.splice(array.length-1, 1)

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}



function removeFromArray(array, item)
{
    const index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeArrayFromArray(fromArray, array)
{
    for (const item of array)
    {
        const index = fromArray.indexOf(item);
        
        if (index > -1)
            fromArray.splice(index, 1);
    }
}



function removeFromArrayWhere(array, where)
{
    const index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function cleanStyleId(styleId)
{
    return styleId.split(',')[0] + ',';
}



function getLinearPathData(points)
{
    let pathData = '';


    if (points.length < 2)
        return pathData;


    pathData += 'M';
    pathData += ' ' + almostZero(points[0].x);
    pathData += ' ' + almostZero(points[0].y);

    for (let i = 1; i < points.length; i++)
    {
        pathData += 
              ' L'
            + ' ' + almostZero(points[i].x)
            + ' ' + almostZero(points[i].y);
    }


    return pathData;
}



function point(x, y) { return {x: x, y: y}; }



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueBy(array, item, equal)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueBy(array, i, equal));
    else if (!array.find(equal))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function consoleAssert(...args)
{
    // if (  !settings 
    //     || settings.enableAsserts)
    if (enableAsserts)
        console.assert(...args);
}



function consoleError(...args)
{
    // if (  !settings
    //     || settings.enableAsserts)
    if (enableAsserts)
        console.error(...args);
}



function trimCharFromStart(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(0, trim.length) == trim) 
        str = str.substring(trim.length);

    return str;
}



function trimCharFromEnd(str, trim) 
{
    while (str.length >= trim.length
        && str.substring(str.length - trim.length) == trim) 
        str = str.substring(0, str.length - trim.length);

    return str;
}



function getObjectFills(genObjFills)
{
    const fills = [];


    for (const fill of genObjFills)
    {
        switch (fill[0])
        {
            case 'SOLID':
            {
                const color = {
                    r: Math.min(Math.max(0, fill[1] / 0xff), 1), 
                    g: Math.min(Math.max(0, fill[2] / 0xff), 1), 
                    b: Math.min(Math.max(0, fill[3] / 0xff), 1) };

                const opacity = Math.min(Math.max(0, fill[4] / 100), 1);


                if (   !isNaN(color.r)
                    && !isNaN(color.g)
                    && !isNaN(color.b)
                    && !isNaN(opacity))
                    fills.push(
                    {
                        type:      fill[0], 
                        color:     color,
                        opacity:   opacity,
                        blendMode: fill[5]
                    });


                break;
            }

            case 'GRADIENT_LINEAR':
            case 'GRADIENT_RADIAL':
            case 'GRADIENT_ANGULAR':
            case 'GRADIENT_DIAMOND':
            {
                const xform = fill[1];


                const stops = [];

                for (const stop of fill[2])
                {
                    stops.push({
                        color: 
                        {
                            r: Math.min(Math.max(0, stop[0]), 1),
                            g: Math.min(Math.max(0, stop[1]), 1),
                            b: Math.min(Math.max(0, stop[2]), 1),
                            a: Math.min(Math.max(0, stop[3]), 1)
                        },
                        position: stop[4]
                    })    
                }


                fills.push(
                {
                    type:              fill[0],
                    gradientTransform: xform,
                    gradientStops:     stops,
                    blendMode:         fill[3]
                });


                break;
            }
        }
    }


    return fills;
}


function rgbFromType(type, active)
{
    return rgbFromTypeMode(type, active, darkMode);
}



function rgbFromTypeMode(type, active, mode)
{
    if (NUMBER_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveNumberDark : rgbActiveNumberLight)
            : (mode ? rgbNumberDark       : rgbNumberLight      );

    else if (TEXT_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveTextDark   : rgbActiveTextLight)
            : (mode ? rgbTextDark         : rgbTextLight      );

    else if (SHAPE_TYPES.includes(type)
         || EFFECT_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveShapeDark  : rgbActiveShapeLight)
            : (mode ? rgbShapeDark        : rgbShapeLight      );

    else if (GROUP_TYPES.includes(type))
        return active 
            ? (mode ? rgbActiveGroupDark  : rgbActiveGroupLight)
            : (mode ? rgbGroupDark        : rgbGroupLight      );

    else if (FLOW_TYPES.includes(type)
          || type == ANY_VALUE)
        return active 
            ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (mode ? rgbFlowDark         : rgbFlowLight      );

    else if (type == COLOR_STYLE)
        return active 
            ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
            : (mode ? rgbFlowDark         : rgbFlowLight      );


    switch (type)
    {
        case COLOR_VALUE:      
        case FILL_VALUE:
        case STROKE_VALUE:
        case COLOR_STOP_VALUE:
        case GRADIENT_VALUE:

        case COLOR:           
        case COLOR_INTERPOLATE:
        case CORRECT_COLOR:
        case COLOR_CONTRAST:
        case COLORBLIND:
        case COLOR_BLEND:

        case COLOR_STOP:
        case GRADIENT:

            return active 
                ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
                : (mode ? rgbFlowDark         : rgbFlowLight      );
    }

    
    return [0xff, 0, 0xff];
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function isSimpleLatinLetter(c)
{
    return c >= 'a' && c <= 'z'
        || c >= 'A' && c <= 'Z';
}


function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function getDecimalFactor(dec)
{
    return Math.pow(10, -dec);
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function decDigits(num) 
{
    if (typeof num !== 'number')
        consoleError('Input must be a number');
    
    const strNum = num.toFixed(10);
    const iDec   = strNum.indexOf('.');
    
    if (iDec === -1)
        return 0;
    
    let count = 0;
    for (let i = iDec + 1; i < strNum.length; i++)
        if (strNum[i] !== '0')
            count++;
    
    return count;
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     lst str = Number(num).toFixed(dec).toString();

//     let i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function getQueryVariable(strVar)
{
    const query = window.location.search.substring(1);
    const vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function ceilTo(x, dec)
{
    const div = Math.ceil(Math.pow(10, dec));
    return Math.ceil((x + Number.EPSILON) * div) / div;    
}



function distance_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function angle_(x, y)
{
    let angle = Math.atan2(y, x);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



// function ipow(n, e)
// {
//     let res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    let carry = 0n;
    
    // multiply individual digits of res[] by n
    for (let i = 0; i < resSize; i++) 
    {
        const prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    const num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    let d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (let i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    let val = 0;
    let mul = 1;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function lerp2(f0, f1, f2, t)
{
    const c0 = lerp(f0, f1, t);
    const c1 = lerp(f1, f2, t);

    return lerp(c0, c1, t);
}



function lerp3(f0, f1, f2, f3, t)
{
    const c0  = lerp(f0, f1, t);
    const c1  = lerp(f1, f2, t);
    const c2  = lerp(f2, f3, t);

    const c01 = lerp(c0, c1, t);
    const c12 = lerp(c1, c2, t);

    return lerp(c01, c12, t);
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function dot3(m, v) 
{
    const result = [];

    for (let i = 0; i < m.length; i++) 
    {
        let sum = 0;

        for (let j = 0; j < v.length; j++) 
            sum += m[i][j] * v[j];

        result.push(sum);
    }
   
    return result;
}


const point_NaN = point(Number.NaN, Number.NaN);



function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function unit(v)
{
    return v.X != 0 
        || v.Y != 0
        ? mulvs(v, 1 / lengthv(v))
        : point(0, 0);
}



function lerpv(p0, p1, t)
{
    return point(
        lerp(p0.x, p1.x, t),
        lerp(p0.y, p1.y, t));
}



function lerpv2(p0, p1, p2, t)
{
    return point(
        lerp2(p0.x, p1.x, p2.x, t),
        lerp2(p0.y, p1.y, p2.y, t));
}



function lerpv3(p0, p1, p2, p3, t)
{
    return point(
        lerp3(p0.x, p1.x, p2.x, p3.x, t),
        lerp3(p0.y, p1.y, p2.y, p3.y, t));
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        const r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        const r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    const t0 = 0;
    const t1 = 1;

    const dx = x2 - x1;
    const dy = y2 - y1;

    const cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    const cr = clipEdge( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    const ct = clipEdge(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    const cb = clipEdge( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    const v1 = subv(p2, p1);
    const v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    const t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    const t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    const d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    const xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectInside(rect1, rect2)
{
    return rect1.l >= rect2.l
        && rect1.r <= rect2.r
        && rect1.t >= rect2.t
        && rect1.b <= rect2.b; 
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[ Math.cos(angle), Math.sin(angle), 0],
            [-Math.sin(angle), Math.cos(angle), 0],
            [ 0,               0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}



function circleCenter(p1, p2, p3)
{
    const v1 = subv(p2, p1);
    const v2 = subv(p3, p2);

    const m1 = divvs(addv(p1, p2), 2);
    const m2 = divvs(addv(p2, p3), 2);

    return intersectLines(
        m1, addv(m1, v2), 
        m2, subv(m2, v1), 
        false);
}



function halfArcAngle(p1, p2, p3)
{
    // returns the angle of the first half of the arc p1-p2

    const pc = circleCenter(p1, p2, p3);

    let a = angleDiff(
        angle(subv(p1, pc)),
        angle(subv(p2, pc)));

    // console.log('angle(subv(p1, pc) =', angle(subv(p1, pc)));    
    // console.log('angle(subv(p2, pc) =', angle(subv(p2, pc)));        
    // while (a < 0)
    //     a += Tau;

    return a;
}


function bezierTangent(x0, y0, x1, y1, x2, y2, x3, y3, t)
{
    const p0 = point(x0, y0);
    const p1 = point(x1, y1);
    const p2 = point(x2, y2);
    const p3 = point(x3, y3);

    return unit(addv(addv(
        mulvs(subv(p1, p0), 3*sqr(1-t)),
        mulvs(subv(p2, p1), 6*(1-t)*t)),
        mulvs(subv(p3, p2), 3*sqr(t))));
}



function positionOnSegment(p0, p1, p2, p3, arcLen, error = 0.001)
{
    const hullLength = 
          distance(p0, p1) 
        + distance(p1, p2)
        + distance(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = arcLen / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(arcLen - length) > error
        && loopProtect-- > 0)
    {
        t += (arcLen - length) / hullLength;

        halves = splitSeg(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        console.log('endless loop in positionOnSegment()');


    return t;
}



function splitSeg(p0, p1, p2, p3, t)
{
    const c0   = lerpv(p0, p1, t);
    const c1   = lerpv(p1, p2, t);
    const c2   = lerpv(p2, p3, t);
                
    const c01  = lerpv(c0, c1, t);
    const c12  = lerpv(c1, c2, t);

    const c012 = lerpv(c01, c12, t);

    return [
        [p0, c0, c01, c012],
        [c012, c12, c2, p3] ];
}



// function splitSegments(_p0, _p1, _p2, _p3, ts)
// {
//     const segments = [];


//     let p0 = _p0, 
//         p1 = _p1,
//         p2 = _p2,
//         p3 = _p3;

//     for (let i = 0; i < ts.length; i++)
//     {
//         const parts = split(p0, p1, p2, p3, ts[i]);
//         const l     = parts[0];
//         const r     = parts[1];


//         segments.push(l);


//         if (i < ts.length-1)
//         {
//             p0 = r[0];
//             p1 = r[1];
//             p2 = r[2];
//             p3 = r[3];

//             for (let j = i+1; j < ts.length; j++)
//                 ts[j] = 1 - (1 - ts[j]) / (1 - ts[i]);
//         }
//         else segments.push(r);
//     }


//     return segments;
// }



function arcLength(p0, p1, p2, p3, error = 0.0000001)
{
    const arcLen = 
          distance(p0, p1)
        + distance(p1, p2)
        + distance(p2, p3);

    const chord = distance(p0, p3);

    if ((arcLen - chord) > error)
    {
        const halves = splitSeg(p0, p1, p2, p3, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength(l[0], l[1], l[2], l[3], error)
             + arcLength(r[0], r[1], r[2], r[3], error);
    }

    return arcLen;
}



function bounds2(p0, p1, p2)
{
    let rect = Rect.NaN;


    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p2);

    /*	if p1 is between p0 and p2 then 
        p0 and p2 are opposite corners of the bounds  */

    if (   (   p0.x <= p1.x && p1.x <= p2.x
            || p2.x <= p1.x && p1.x <= p0.x)
        && (   p0.y <= p1.y && p1.y <= p2.y
            || p2.y <= p1.y && p1.y <= p0.y))
        return rect;


    const ax = p0.x - 2*p1.x + p2.x;
    const bx = 2 * (p1.x - p0.x);
    
    const ay = p0.y - 2*p1.y + p2.y;
    const by = 2 * (p1.y - p0.y);


    const tx = -bx / nozero(2*ax);
    const ty = -by / nozero(2*ay);


    if (tx >= 0 && tx <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, tx));
    if (ty >= 0 && ty <= 1) rect = expandRect_(rect, lerpv2(p0, p1, p2, ty));
    

    return rect;
}



function bounds3(p0, p1, p2, p3)
{
    let rect = Rect.NaN;


    rect = expandRect_(rect, p0);
    rect = expandRect_(rect, p3);


    const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;
    const bx =  3*p0.x - 6*p1.x + 3*p2.x;
    const cx = -3*p0.x + 3*p1.x;

    const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;
    const by =  3*p0.y - 6*p1.y + 3*p2.y;
    const cy = -3*p0.y + 3*p1.y;


    const roots = []; // there will be ≤4 solutions

    bounds3t(ax, bx, cx, roots);
    bounds3t(ay, by, cy, roots);


    for (const root of roots)
    {
        rect = expandRect_(
            rect, 
            lerpv3(p0, p1, p2, p3, root));
    }


    return rect;
}



function bounds3t(a, b, c, roots)
{
    let a_ = a * 3;
    let b_ = b * 2;


    let D = b_*b_ - 4*a_*c;
    let r;

    if (a_ == 0)
    {
        r = -c/b_;  if (r >= 0 && r <= 1) roots.push(r);
    }
    else
    {
        const _2a = 1/(2*a_);
        b_ *= _2a;
    
        if (D == 0)
        {
            if (b_ >= 0 && b_ <= 1) roots.push(-b_);
        }
        else if (D > 0)
        {
            D = Math.sqrt(D) * _2a;

            r = -b_ + D;  if (r >= 0 && r <= 1) roots.push(r);
            r = -b_ - D;  if (r >= 0 && r <= 1) roots.push(r);
        }
    }
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    const size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (let i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    let rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    let c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    let d = x - 1n;
    let s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (let i = 0; i < k; i++)    
    {
        const a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    let x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (let j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    let val = 0n;
    let mul = 1n;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    const gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    const gcd = bigGcdExtended(m % n, n);

    const x   = gcd[1];
    const y   = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l()            { return this.x;            }
    get c()            { return this.x + this.w/2; }
    get r()            { return this.x + this.w;   }
           
    get t()            { return this.y;            }
    get m()            { return this.y + this.h/2  }
    get b()            { return this.y + this.h;   }
          
    get tl()           { return point(this.l, this.t); }
    get tc()           { return point(this.c, this.t); }
    get tr()           { return point(this.r, this.t); }
    get ml()           { return point(this.l, this.m); }
    get mc()           { return point(this.c, this.m); }
    get cm()           { return point(this.c, this.m); }
    get mr()           { return point(this.r, this.m); }
    get bl()           { return point(this.l, this.b); }
    get bc()           { return point(this.c, this.b); }
    get br()           { return point(this.r, this.b); }
      
      
    get width()        { return this.w; }
    get height()       { return this.h; }
      
    get left()         { return this.l; }
    get center()       { return this.c; }
    get right()        { return this.r; }
          
    get top()          { return this.t; }
    get middle()       { return this.m; }
    get bottom()       { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromRect(rect)
    {
        return new Rect(rect.x, rect.y, rect.width, rect.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



function expandRect_(rect, p)
{
    if (rect.isNaN) return new Rect(p.x, p.y, 0, 0);

    return new AbsRect(
        Math.min(p.x, rect.l),
        Math.min(p.y, rect.t),
        Math.max(p.x, rect.r),
        Math.max(p.y, rect.b));
}



class Random
{
    seed;
    index; // for next()

    cache;



    constructor(seed = 0)
    { 
        this.seed  = seed; 
        this.index = 0;
        
        this.updateCache(256);
    }



    copy()
    {
        return new Random(this.seed, this.last);
    }



    updateCache(size)
    {
        this.cache = new Int32Array(size);

        let seed = this.seed;
        let last = seed;

        for (let i = 0; i < size; i++)
            this.cache[i] = seed = this.generate(seed, last);
    }



    next()
    {
        if (this.index >= this.cache.length)
            this.updateCache(nextPow2(this.index));

        return this.cache[this.index++] / -0x7fffffff;
    }



    get(index)
    {
        if (index >= this.cache.length)
            this.updateCache(nextPow2(index+1));

        return this.cache[index] / -0x7fffffff;
    }



    generate(seed, last)
    {
        last = seed;
        
        seed = (seed + 0x7ed55d16) + (seed << 12);
        seed = (seed ^ 0xc761c23c) ^ (seed >> 19);
        seed = (seed + 0x165667b1) + (seed <<  5);
        seed = (seed + 0xd3a2646c) ^ (seed <<  9);
        seed = (seed + 0xfd7046c5) + (seed <<  3);
        seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);

        return seed;
    }
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



var utilCanvas;
var utilContext;
    


function initUtilContext()
{
    utilCanvas  = document.createElement('canvas');
    utilContext = utilCanvas.getContext('2d');

    utilContext.willReadFrequently = true;
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function pluralString(count, pluralChar = 's')
{
    return count == 1 ? '' : pluralChar;
}



function countString(count, itemName)
{
    const lastChar   = itemName.at(-1);
    const pluralChar = lastChar == lastChar.toUpperCase() ? 'S' : 's';

    return itemName + pluralString(count, pluralChar);
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');
    const commaIndex = strValue.indexOf(',');

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    const svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    let str = '';

    for (let i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function printNum(num)
{
    return !isNaN(num) ? num : NAN_DISPLAY;
}



function parseNum(str)
{
    return str == NAN_DISPLAY
         ? Number.NaN 
         : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function osCtrl     (plus = true) { return isMac ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); }
function osAlt      (plus = true) { return isMac ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); }
function osShift    (plus = true) { return isMac ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); }
function osCtrlShift(plus = true) { return isMac ? osShift(plus) + osCtrl(plus) : osCtrl(plus) + osShift(plus); }



function getCreateNodeAction(type, creatingButton, options)
{
    return  options.insert != undefined
        &&  options.insert
        && (    options.autoConnect == undefined
            || !options.autoConnect)
        ? new CreateInsertNodeAction(type, creatingButton, options)
        : new CreateNodeAction      (type, creatingButton, options, options.autoConnect != undefined && options.autoConnect);
}



function simpleIntHash(x)
{
    return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32);
}



function getNewNumberId(nodes, checkExists, curId, id = curId, join = '')
{
    if (!checkExists(id))
        return id;
    

    let numLength = getNumLength(id);

    if (numLength > 0)
    {
        const len = id.length - numLength;
        let   num = parseInt(id.substring(len));

        let newId = '';
        while (newId == '' || checkExists(newId))
            newId = id.substring(0, len + join.length) + join + (++num);

        return newId;
    }

    else if (numLength == 0)
    {
        let num   = 2;
        let newId = id + join + num;

        while (checkExists(newId))
            newId = id + join + (++num);

        return newId;
    }

    else
        return id;
}



function getNumLength(name)
{
    let numLength = 0;

    for (let i = name.length - 1; i >= 0; i--)
    {
        if (isDigit(name[i])) numLength++;
        else break;
    }

    return numLength;
}



function isValidFloatString(str) 
{
    return /^-?\d*\.?\d*(e-?\d+)?$/.test(str);
}



function setControlFont(control, family, size, align = 'left')
{
    control.style.fontFamily = family;
    control.style.fontSize   = size + 'px';
    control.style.textAlign  = align;
}



function daysInMonth(month, year)
{
    if (month == 2)
    {
        return year % 4 != 0
             ? 28
             : 29;
    }
    else if (month == 4
          || month == 7
          || month == 9
          || month == 11)
        return 30;
    else
        return 31;
}



function getFontStyles(fontName)
{
    let fonts = figFonts.filter(f => f.fontName.family == fontName)


    fonts.sort((a, b) =>
    {
        if (a.fontName.style != b.fontName.style)
            return FONT_WEIGHTS.findIndex(w => w[0] == a.fontName.style.toLowerCase())
                 - FONT_WEIGHTS.findIndex(w => w[0] == b.fontName.style.toLowerCase());

        return 0;
    });

    
    return fonts.map(f => f.fontName.style);
}



function unescapeString(str)
{
    return str.replace(/\\(.)/g, (match, char) => 
    {
        const replacements = 
        {
            'n':  '\n',
            'r':  '\r',
            't':  '\t',
            '\\': '\\',
            '\'': '\'',
            '\"': '\"',
            '\`': '\`'
        };
      
        return replacements[char] || match;
    });
}



function getEditDistance(str1, str2)
{
    // calculate the Levenshtein distance between two strings
    // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html

    // TODO replace with Damerau-Levenshtein

    if (str1.length == 0) return str2.length;
    if (str2.length == 0) return str1.length;

    // make sure str1 is the shorter string

    if (str1.length > str2.length)
    {
        const _str = str1;
        str1 = str2;
        str2 = _str;
    } 

    let len1 = str1.length; // min length of the two strings
    let len2 = str2.length;

    // suffix common to both strings can be ignored

    while (len1 > 0 
        && str1[len1 - 1] == str2[len2 - 1])
    {
        len1--; 
        len2--; 
    }

    let start = 0;

    // if there's a shared prefix or str1 == str2's suffix

    if (str1[0] == str2[0])
    {
        while (start < len1 
            && str1[start] == str2[start]) 
            start++;

        len1 -= start; // length of the part excluding common prefix and suffix
        len2 -= start;

        // if str1 == prefix and/or suffix of str2, 
        // edit distance is just the number of additional characters in str2

        if (len1 == 0) return len2;

        str2 = str2.substring(start, len2); // faster than str2[start + j] in inner loop below
    }

    //

    let v0 = [];
    
    for (let j = 0; j < len2; j++) 
        v0.push(j + 1);

    //

    let current = 0;

    for (let i = 0; i < len1; i++)
    {
        const c = str1[start + i];

        let left = current = i;

        for (let j = 0; j < len2; j++)
        {
            const above = current;
           
            current = left; // cost on diagonal (substitution)
            left = v0[j];

            if (c != str2[j])
            {
                current++; // substitution

                let insDel = above + 1; // deletion

                if (insDel < current) 
                    current = insDel;

                insDel = left + 1; // insertion

                if (insDel < current) 
                    current = insDel;
            }

            v0[j] = current;
        }
    }
    
    return current;
}



function skipRandom(count)
{
    for (let i = 0; i < count; i++) 
        Math.random();
}



function includesSimilar(str, sub, levenshteinDistance)
{
    if (sub.length > str.length)
        return false;
    
    if (str.includes(sub))
        return true;
    
    for (let i = 0; i <= str.length - sub.length; i++) 
    {
        const s = str.substring(i, i + sub.length);
        
        if (getEditDistance(sub, s) <= levenshteinDistance)
            return true;
    }
}



function degamma(rgb, cs = sRGB)
{
    return [ cs.degamma(rgb[0]),
             cs.degamma(rgb[1]),
             cs.degamma(rgb[2]) ];
}



function regamma(rgb, cs = sRGB)
{
    return [ cs.regamma(rgb[0]),
             cs.regamma(rgb[1]),
             cs.regamma(rgb[2]) ];
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    const inLen  = base64.length;

    const outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    const bytes = new Uint8Array(outLen);

    for (let mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    let mod3   = 2, 
        base64 = "";

    const length = bytes.length;

    for (let i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    let   str    = "";

    const length = bytes.length;

    for (let i = 0; i < length; i++) 
    {
        const byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    let strLen = str.length, 
        arrLen = 0;


    // mapping

    for (let i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    const bytes = new Uint8Array(arrLen);


    // transcription

    for (let i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        const chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function appendDivTo(div, to)
{
    if (!to.contains(div))
        to.appendChild(div);
}



function removeDivFrom(div, from)
{
    if (from.contains(div))
        from.removeChild(div);
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function createTextarea(className = '')
{
    const textarea = document.createElement('textarea');

    if (className.trim() != '')
        textarea.className = className;
    
    textarea.spellcheck = false;
    
    return textarea;
}



function enableElementText(elem, enable, bold = true)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 

    if (bold)
        elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    const elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    const e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



function offsetRect(element)
{
    return new Rect(
        element.offsetLeft,
        element.offsetTop,
        element.offsetWidth,
        element.offsetHeight);
}



function clientRect(element)
{
    return new Rect(
        element.clientLeft,
        element.clientTop,
        element.clientWidth,
        element.clientHeight);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function selectElementText(elementId)
{
    if (document.selection) // IE
    {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(elementId));
        range.select();
    }
    else if (window.getSelection) 
    {
        var range = document.createRange();
        range.selectNode(document.getElementById(elementId));
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
}



function isTouchpad(e)
{
    return Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;
}



function showElement(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hideElement(element)              
{ 
    showElement(element, false); 
}



function isVisible(element)
{
    return element.offsetParent !== null;
}



function getSelectedText(element) // only allow input[type=text] & textarea
{ 
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        return element.value.substring(
            element.selectionStart,
            element.selectionEnd);
    }
}



function clearSelectedText(element)
{
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        const str = element.value;

        element.value = 
              str.slice(0, element.selectionStart) 
            + str.slice(element.selectionEnd)
    }
}



function scrollbarVisible(element) 
{
    return element.scrollHeight > element.clientHeight;
}



function clientPos(e)
{
    return point(e.clientX, e.clientY);
}



function elementHasSelectedText(div)
{
    const selection = window.getSelection();

    if (selection.rangeCount > 0) 
    {
        const range = selection.getRangeAt(0);
        
        if (   range.commonAncestorContainer === div
            || div.contains(range.commonAncestorContainer))
        {
            const selectedText = range.toString().trim();

            if (selectedText.length > 0)
                return true;
        }
    }

    return false; 
}



function selectDivText(div)
{
    var range = document.createRange();
    range.selectNode(div);

    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);    
}



function loadFromLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '.gen';
    
    input.onchange = e => 
    { 
        const file = e.target.files[0]; 

        const reader = new FileReader();
        reader.readAsText(file,'UTF-8');

        reader.onload = e => callback(e.target.result);
    }; 

    input.click();
}



function getLocalFile(callback)
{
    const input = document.createElement('input');

    input.type   = 'file';
    input.accept = '*.*';
    
    input.onchange = e => 
    { 
        callback(e.target.files[0]); 
    }; 

    input.click();
}



function saveToLocalFile(content, filename, contentType)
{
    const a    = document.createElement('a');
    const file = new Blob([content], {type: contentType});

    a.download = filename;
    a.href     = URL.createObjectURL(file);

    a.click();

    URL.revokeObjectURL(a.href);
}


const webColors = [
    {name: 'AliceBlue',            color: 'f0f8ff'},
    {name: 'AntiqueWhite',         color: 'faebd7'},
    {name: 'Aqua',                 color: '00ffff'},
    {name: 'Aquamarine',           color: '7fffd4'},
    {name: 'Azure',                color: 'f0ffff'},
    {name: 'Beige',                color: 'f5f5dc'},
    {name: 'Bisque',               color: 'ffe4c4'},
    {name: 'Black',                color: '000000'},
    {name: 'BlanchedAlmond',       color: 'ffebcd'},
    {name: 'Blue',                 color: '0000ff'},
    {name: 'BlueViolet',           color: '8a2be2'},
    {name: 'Brown',                color: 'a52a2a'},
    {name: 'BurlyWood',            color: 'deb887'},
    {name: 'CadetBlue',            color: '5f9ea0'},
    {name: 'Chartreuse',           color: '7fff00'},
    {name: 'Chocolate',            color: 'd2691e'},
    {name: 'Coral',                color: 'ff7f50'},
    {name: 'CornflowerBlue',       color: '6495ed'},
    {name: 'Cornsilk',             color: 'fff8dc'},
    {name: 'Crimson',              color: 'dc143c'},
    {name: 'Cyan',                 color: '00ffff'},
    {name: 'DarkBlue',             color: '00008b'},
    {name: 'DarkCyan',             color: '008b8b'},
    {name: 'DarkGoldenRod',        color: 'b8860b'},
    {name: 'DarkGray',             color: 'a9a9a9'},
    {name: 'DarkGrey',             color: 'a9a9a9'},
    {name: 'DarkGreen',            color: '006400'},
    {name: 'DarkKhaki',            color: 'bdb76b'},
    {name: 'DarkMagenta',          color: '8b008b'},
    {name: 'DarkOliveGreen',       color: '556b2f'},
    {name: 'DarkOrange',           color: 'ff8c00'},
    {name: 'DarkOrchid',           color: '9932cc'},
    {name: 'DarkRed',              color: '8b0000'},
    {name: 'DarkSalmon',           color: 'e9967a'},
    {name: 'DarkSeaGreen',         color: '8fbc8f'},
    {name: 'DarkSlateBlue',        color: '483d8b'},
    {name: 'DarkSlateGray',        color: '2f4f4f'},
    {name: 'DarkSlateGrey',        color: '2f4f4f'},
    {name: 'DarkTurquoise',        color: '00ced1'},
    {name: 'DarkViolet',           color: '9400d3'},
    {name: 'DeepPink',             color: 'ff1493'},
    {name: 'DeepSkyBlue',          color: '00bfff'},
    {name: 'DimGray',              color: '696969'},
    {name: 'DimGrey',              color: '696969'},
    {name: 'DodgerBlue',           color: '1e90ff'},
    {name: 'FireBrick',            color: 'b22222'},
    {name: 'FloralWhite',          color: 'fffaf0'},
    {name: 'ForestGreen',          color: '228b22'},
    {name: 'Fuchsia',              color: 'ff00ff'},
    {name: 'Gainsboro',            color: 'dcdcdc'},
    {name: 'GhostWhite',           color: 'f8f8ff'},
    {name: 'Gold',                 color: 'ffd700'},
    {name: 'GoldenRod',            color: 'daa520'},
    {name: 'Gray',                 color: '808080'},
    {name: 'Grey',                 color: '808080'},
    {name: 'Green',                color: '008000'},
    {name: 'GreenYellow',          color: 'adff2f'},
    {name: 'HoneyDew',             color: 'f0fff0'},
    {name: 'HotPink',              color: 'ff69b4'},
    {name: 'IndianRed',            color: 'cd5c5c'},
    {name: 'Indigo',               color: '4b0082'},
    {name: 'Ivory',                color: 'fffff0'},
    {name: 'Khaki',                color: 'f0e68c'},
    {name: 'Lavender',             color: 'e6e6fa'},
    {name: 'LavenderBlush',        color: 'fff0f5'},
    {name: 'LawnGreen',            color: '7cfc00'},
    {name: 'LemonChiffon',         color: 'fffacd'},
    {name: 'LightBlue',            color: 'add8e6'},
    {name: 'LightCoral',           color: 'f08080'},
    {name: 'LightCyan',            color: 'e0ffff'},
    {name: 'LightGoldenRodYellow', color: 'fafad2'},
    {name: 'LightGray',            color: 'd3d3d3'},
    {name: 'LightGrey',            color: 'd3d3d3'},
    {name: 'LightGreen',           color: '90ee90'},
    {name: 'LightPink',            color: 'ffb6c1'},
    {name: 'LightSalmon',          color: 'ffa07a'},
    {name: 'LightSeaGreen',        color: '20b2aa'},
    {name: 'LightSkyBlue',         color: '87cefa'},
    {name: 'LightSlateGray',       color: '778899'},
    {name: 'LightSlateGrey',       color: '778899'},
    {name: 'LightSteelBlue',       color: 'b0c4de'},
    {name: 'LightYellow',          color: 'ffffe0'},
    {name: 'Lime',                 color: '00ff00'},
    {name: 'LimeGreen',            color: '32cd32'},
    {name: 'Linen',                color: 'faf0e6'},
    {name: 'Magenta',              color: 'ff00ff'},
    {name: 'Maroon',               color: '800000'},
    {name: 'MediumAquaMarine',     color: '66cdaa'},
    {name: 'MediumBlue',           color: '0000cd'},
    {name: 'MediumOrchid',         color: 'ba55d3'},
    {name: 'MediumPurple',         color: '9370db'},
    {name: 'MediumSeaGreen',       color: '3cb371'},
    {name: 'MediumSlateBlue',      color: '7b68ee'},
    {name: 'MediumSpringGreen',    color: '00fa9a'},
    {name: 'MediumTurquoise',      color: '48d1cc'},
    {name: 'MediumVioletRed',      color: 'c71585'},
    {name: 'MidnightBlue',         color: '191970'},
    {name: 'MintCream',            color: 'f5fffa'},
    {name: 'MistyRose',            color: 'ffe4e1'},
    {name: 'Moccasin',             color: 'ffe4b5'},
    {name: 'NavajoWhite',          color: 'ffdead'},
    {name: 'Navy',                 color: '000080'},
    {name: 'OldLace',              color: 'fdf5e6'},
    {name: 'Olive',                color: '808000'},
    {name: 'OliveDrab',            color: '6b8e23'},
    {name: 'Orange',               color: 'ffa500'},
    {name: 'OrangeRed',            color: 'ff4500'},
    {name: 'Orchid',               color: 'da70d6'},
    {name: 'PaleGoldenRod',        color: 'eee8aa'},
    {name: 'PaleGreen',            color: '98fb98'},
    {name: 'PaleTurquoise',        color: 'afeeee'},
    {name: 'PaleVioletRed',        color: 'db7093'},
    {name: 'PapayaWhip',           color: 'ffefd5'},
    {name: 'PeachPuff',            color: 'ffdab9'},
    {name: 'Peru',                 color: 'cd853f'},
    {name: 'Pink',                 color: 'ffc0cb'},
    {name: 'Plum',                 color: 'dda0dd'},
    {name: 'PowderBlue',           color: 'b0e0e6'},
    {name: 'Purple',               color: '800080'},
    {name: 'RebeccaPurple',        color: '663399'},
    {name: 'Red',                  color: 'ff0000'},
    {name: 'RosyBrown',            color: 'bc8f8f'},
    {name: 'RoyalBlue',            color: '4169e1'},
    {name: 'SaddleBrown',          color: '8b4513'},
    {name: 'Salmon',               color: 'fa8072'},
    {name: 'SandyBrown',           color: 'f4a460'},
    {name: 'SeaGreen',             color: '2e8b57'},
    {name: 'SeaShell',             color: 'fff5ee'},
    {name: 'Sienna',               color: 'a0522d'},
    {name: 'Silver',               color: 'c0c0c0'},
    {name: 'SkyBlue',              color: '87ceeb'},
    {name: 'SlateBlue',            color: '6a5acd'},
    {name: 'SlateGray',            color: '708090'},
    {name: 'SlateGrey',            color: '708090'},
    {name: 'Snow',                 color: 'fffafa'},
    {name: 'SpringGreen',          color: '00ff7f'},
    {name: 'SteelBlue',            color: '4682b4'},
    {name: 'Tan',                  color: 'd2b48c'},
    {name: 'Teal',                 color: '008080'},
    {name: 'Thistle',              color: 'd8bfd8'},
    {name: 'Tomato',               color: 'ff6347'},
    {name: 'Turquoise',            color: '40e0d0'},
    {name: 'Violet',               color: 'ee82ee'},
    {name: 'Wheat',                color: 'f5deb3'},
    {name: 'White',                color: 'ffffff'},
    {name: 'WhiteSmoke',           color: 'f5f5f5'},
    {name: 'Yellow',               color: 'ffff00'},
    {name: 'YellowGreen',          color: '9acd32'}
];


var _clipboard = '';



function writeTextToClipboard(str) 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.writeText(str);

        else 
        {
            const prevActive = document.activeElement;
            const textArea   = document.createElement('textarea');

            textArea.value = str;

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus();
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('copy') ? res() : rej();
                textArea.remove();

                prevActive.focus();
            });
        }
    }
    else
        _clipboard = str;
}



function readTextFromClipboard() 
{
    if (subscribed())
    {
        if (   navigator.clipboard 
            && window.isSecureContext) 
            return navigator.clipboard.readText();

        else 
        {
            let textArea = document.createElement('textarea');

            textArea.style.position = 'fixed';
            textArea.style.left     = '-999999px';
            textArea.style.top      = '-999999px';
            
            document.body.appendChild(textArea);
            
            textArea.focus();
            textArea.select();
            
            return new Promise((res, rej) => 
            {
                document.execCommand('paste') ? res(textArea.value) : rej();
                textArea.remove();
            });
        }
    }
    else
        return new Promise((res, rej) => res(_clipboard));
}


function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isPageKey(key) { return isTagKey(key, pageTag); }
function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noPageTag(key) { return noTag(key, pageTag); }
function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


const NAN_CHAR               = '\uFFFD';
const NAN_DISPLAY            = '?';
    
const UNKNOWN_CHAR           = '?';
const UNKNOWN_DISPLAY        = UNKNOWN_CHAR;//'🤷‍♂️';

const OBJECT_SEPARATOR       = ' > ';
const   PROP_SEPARATOR       = ' / ';
const  INPUT_SEPARATOR       = ':';

const CENTER_SUFFIX          = ' •';
const  XFORM_SUFFIX          = ' ◇';
    

const  TRUE_DISPLAY_LIGHT    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const FALSE_DISPLAY_LIGHT    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    

const  TRUE_DISPLAY_DARK     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const FALSE_DISPLAY_DARK     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';

const  TRUE_DISPLAY_LIGHT_BW = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const FALSE_DISPLAY_LIGHT_BW = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';

const  TRUE_DISPLAY_DARK_BW  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_DARK_BW  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';

const  TRUE_DISPLAY_MENU     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_MENU     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';



function getTrueDisplay(color = true)
{
    return darkMode
         ? (color ? TRUE_DISPLAY_DARK  : TRUE_DISPLAY_DARK_BW )
         : (color ? TRUE_DISPLAY_LIGHT : TRUE_DISPLAY_LIGHT_BW);
}



function getFalseDisplay(color = true)
{
    return darkMode
         ? (color ? FALSE_DISPLAY_DARK  : FALSE_DISPLAY_DARK_BW )
         : (color ? FALSE_DISPLAY_LIGHT : FALSE_DISPLAY_LIGHT_BW);
}


function nodeIdArrayToString(nodeIds)
{
    let str = '';

    for (let i = 0; i < nodeIds.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodeIds[i];
    }

    return str;
}



function nodeArrayToString(nodes)
{
    let str = '';

    nodes.map(n => n ? n.id : 'undefined').join(', ');

    // for (let i = 0; i < nodes.length; i++)
    // {
    //     if (i > 0) str += ', ';
    //     str += nodes[i] ? nodes[i].id : 'undefined';
    // }

    return str;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + HTAB.repeat(Math.max(0, this.nTab)); 
    }
}



function log(str)
{
    debugInfo.innerHTML = str;
}



function logFunction(funcName, obj = null)
{
    let str = funcName;

    if (obj)
        str = obj.id + '.' + str;

    console.log(
        '%c ' + str + ' ', 
        'background: #fc0; color: #632;');
}



function logString(str, color = 'white', background = 'red')
{
    console.log(
        '%c ' + str + ' ', 
        'background: ' + background + '; color: ' + color + ';');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = '↓ ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nInputs = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + HTAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nInputs;

        newLine = true;

        nTab++;

        for (let j = 0; j < nInputs; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + HTAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logStyleUpdates(styles)
{
    console.log(
        '%cstyles', 
        'background: #b4d; color: white;', 
        styles);
}



function logSavePages(pageJson)
{
    console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;');
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;');
}



function logSaveConnections(conns)
{
    let log = 'SAVING ' + conns.length + ' ' + countString(conns.length, 'CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUpdateSavedConnections(conns)
{
    let log = 'UPDATING ' + conns.length + ' ' + countString(conns.length, 'SAVED CONNECTION');

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUndoStack()
{
    let log = 
        'UNDO STACK:\n'
        + actionManager.actions.map(a => '    ' + a.name).join('\n');

    console.log('%c%s', 'background: #ffd; color: #b80;', log);
}



function logRedoStack()
{
    let log = 
         'REDO STACK:\n'
        + actionManager.redoActions.map(a => '    ' + a.name).join('\n');

    console.log('%c%s', 'background: #fff4e8; color: #c64;', log);
}


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = '↓ ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReq(node, parse, ignore, nInputs = -1)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node, ignore);

    if (    nInputs > -1
        && !ignore)
        parse.log += ' ' + nInputs;
}



function logReqNodeId(node, ignore = false)
{
    return ' ' 
         + logReqId(node.nodeId) 
         + ' ' + logReqId(node.nodeName)
         + (!ignore
            ? logReqOptions(node)
            : '');
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if ( node.options.active      ) log += ' ' + ACTIVE;
    if ( node.options.beforeActive) log += ' ' + BEFORE_ACTIVE;
    if (!node.options.enabled     ) log += ' ' + DISABLED;

    if (!node.cached              ) log += ' ' + NOCACHE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



function logReqColorContrast(lerp, nInputs, valueIndex, parse, ignore)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp, ignore);

    if (!ignore)
    {
        parse.log += ' ' + nInputs;

        if (nInputs == 1)
            parse.log += ' ' + valueIndex;
    }
}



function logReqValue(type, val, parse)
{
    parse.log += parse.tab + type + ' ' + displayValue(type, val);
}



// function logReqListValue(list, parse, ignore)
// {
//     parse.log += parse.tab + LIST_VALUE + ' ' + displayValue(LIST_VALUE, list);
// }



// function logReqColorValue(val, parse, ignore)
// {
//     parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
// }



// function logReqNumberValue(val, parse, ignore)
// {
//     parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
// }



// function logReqFillValue(fill, parse, ignore)
// {
//     parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
// }



// function logReqStrokeValue(stroke, parse, ignore)
// {
//     // parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
// }



// function logReqColorStopValue(stop, parse, ignore)
// {
//     // parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
// }



function logSavedNode(nodeKey, darkMode)
{
    const log  = formatSavedNodeJson(figGetPageData(nodeKey, false));

    if (darkMode)
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fa24; color: white;', 
            noNodeTag(nodeKey), 
            'background: #fa44; color: #edc;',
            log);
    }
    else
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fdb; color: black;', 
            noNodeTag(nodeKey), 
            'background: #fed; color: black;',
            log);
    }
}



function formatSavedNodeJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')

        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '')

        .split(HTAB + '"params":\n').join('') // have to do .split().join() because there's no .replace() in TS

        .split('": "').join(': ')
        .split('", "').join(': ')

        .split(HTAB + '"').join(HTAB)
        .split(HTAB + HTAB + '["').join(HTAB + HTAB)
        
        .split('",\n').join('\n')
        .split('"\n').join('\n')
        
        .split('"],\n').join('\n');


    if (formJson[formJson.length-1] == '"')
        formJson = formJson.substring(0, formJson.length - 1);

    if (formJson.substring(formJson.length-2) == '"]')    
        formJson = formJson.substring(0, formJson.length - 2);

    return formJson;
}



function formatSavedDataJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')
        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '');

    return formJson;
}



function logSavedConn(conn, darkMode)
{
    const strConn = connToString(conn, true);

    if (darkMode)
    {
        console.log(
            '%c%s', 
            'background: #4f44; color: #ded', 
            strConn); 
    }
    else
    {
        console.log(
            '%c%s', 
            'background: #cfc; color: black;', 
            strConn); 
    }
}


// Observer = 2°

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inversem3(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inversem3(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgbSaturateHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[1] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsl(rgb, amount)
{
    const hsl = rgb2hsl(rgb);
    hsl[1] *= amount;
    return hsl2rgb(hsl);
}


function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h++;
    h %= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    while (h < 0) h++;
    h %= 1;

    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    return lrgb2xyz(degamma(rgb, cs), cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    return regamma(xyz2lrgb(xyz, cs), cs);
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}


function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = 0.008856; //cube(6/29);
    const k = 903.3;    //cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;
    yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;
    zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;


    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = 0.008856 / 100; //cube(6/29) / 100;
    const k = 903.3    / 100; //cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l, a, b) 
{
    return [
        l + 0.3963377774 * a + 0.2158037573 * b,
        l - 0.1055613458 * a - 0.0638541728 * b,
        l - 0.0894841775 * a - 1.2914855480 * b ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


const hclok_C_scale = 0.89;


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclok2rgb(hcl, cs = sRGB)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 

    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclok2rgb_(h, c, l, cs = sRGB)
{
    return hclok2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclok(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));

    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclok_(r, g, b, cs = sRGB)
{
    return rgb2hclok([r, g, b], cs);
}



function hclab2lab(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hclab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hclab2lab(hcl), cs);
}



function lab2hclab(lab)
{
    let hcl = opp2pol(lab);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclab(rgb, cs = sRGB)
{
    return lab2hclab(rgb2lab(rgb, cs));
}



function hcluv2luv(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hcluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hcluv2luv(hcl), cs);
}



function luv2hcluv(luv)
{
    let hcl = opp2pol(luv);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hcluv(rgb, cs = sRGB)
{
    return luv2hcluv(rgb2luv(rgb, cs));
}


function srgb2p3(rgb)
{
    const p3 = 
        [ [ 0.8225, 0.1774, 0      ],
          [ 0.0332, 0.9669, 0      ],
          [ 0.0171, 0.0724, 0.9108 ] ];

    rgb = degamma(rgb);

    return regamma(dot3(p3, rgb));
}



function p32srgb(rgb) 
{
    const invp3 = 
        [ [ 1.2249, -0.2247, 0      ],
          [-0.0420,  1.0419, 0      ],
          [-0.0197, -0.0786, 1.0979 ] ];
  
    rgb = dot3(invp3, degamma(rgb));
  
    return regamma(rgb);
}


const ColorSpaces = 
[
    ['hex',   'Hex'   ],
    ['rgb',   'RGB'   ], 
    ['hsv',   'HSV'   ], 
    ['hsl',   'HSL'   ], 
    ['hclok', 'HCL/ok'],
    ['hclab', 'HCL/ab'],
    ['hcluv', 'HCL/uv'],
    ['oklab', 'okLab' ],
    ['lab',   'Lab'   ],
    ['luv',   'Luv'   ]
];



class ColorSpace
{
    hex   = Object.freeze(0);
    rgb   = Object.freeze(1);
    hsv   = Object.freeze(2);
    hsl   = Object.freeze(3);
    hclok = Object.freeze(4);
    hclab = Object.freeze(5);
    hcluv = Object.freeze(6);
    oklab = Object.freeze(7);
    lab   = Object.freeze(8);
    luv   = Object.freeze(9);
}



class Color
extends Float32Array
{
    get r() { return this[0]; }
    get g() { return this[1]; }
    get b() { return this[2]; }
    get a() { return this[3]; }
    get s() { return this[4]; }

    set r(r) { this[0] = r; }
    set g(g) { this[1] = g; }
    set b(b) { this[2] = b; }
    set a(a) { this[3] = a; }
    set s(s) { this[4] = s; }



    constructor(c = null)
    {
        super(5); // c1, c2, c3, a, s (space)

        if (c)
        {
            this.r = c.r;
            this.g = c.g;
            this.b = c.b;
            this.a = c.a;
            this.s = c.s;
        }
        else
        {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.s = ColorSpace.rgb;
        }
    }
}


const ColorEpsilon = 0.001;



function rgb2dataColor(rgb)
{
    const _space = 'rgb';

    return [
        _space, 
        getNormalColorValue(rgb[0], _space, 0), 
        getNormalColorValue(rgb[1], _space, 1), 
        getNormalColorValue(rgb[2], _space, 2) ]; 
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = ColorEpsilon)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}



function dataColorIsOk(col, lim = ColorEpsilon)
{
    return rgbIsOk(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const rgba_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN,
    Number.NaN ];


const rgbInvalid  = [0xff, 0, 0xff];
const rgbaInvalid = [0xff, 0, 0xff, 0xff];


const dataColor_NaN = Object.freeze([
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ]);


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inversem3(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inversem3(CAT);


const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],
            [ 0.0329845436, 0.9293118715,  0.0361456387 ],
            [ 0.0482003018, 0.2643662691,  0.6338517070 ]];

const invM1 = inversem3(M1);



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = ColorEpsilon)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbaIsValid(rgba, lim = ColorEpsilon)
{
    return rgba[0] > -lim && rgba[0] < 1 + lim 
        && rgba[1] > -lim && rgba[1] < 1 + lim 
        && rgba[2] > -lim && rgba[2] < 1 + lim
        && rgba[3] > -lim && rgba[3] < 1 + lim;
}



function rgbIsOk(rgb, lim = ColorEpsilon)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function rgbaIsOk(rgba, lim = ColorEpsilon)
{
    return !rgbaIsNaN  (rgba)
        &&  rgbaIsValid(rgba, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbaLerp(rgba1, rgba2, t)
{
    return [ lerp(rgba1[0], rgba2[0], t),
             lerp(rgba1[1], rgba2[1], t),
             lerp(rgba1[2], rgba2[2], t),
             lerp(rgba1[3], rgba2[3], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a !== undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a = 1)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a = 1)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclok(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < ColorEpsilon
        && Math.abs(rgb1[1] - rgb2[1]) < ColorEpsilon
        && Math.abs(rgb1[2] - rgb2[2]) < ColorEpsilon;        
}



function style2rgba(style) // SLOW
{
    utilContext.fillStyle = style;
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) // SLOW
{
    utilContext.fillStyle = getStyleValue(obj, style);
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])
               : (darkMode ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))
           : (darkMode ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningRgba(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])  
         : (darkMode ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);  
}



function getWarningStyles(colBack)
{
    let warnStyle1, 
        warnStyle2;
    
        
    const colWarning = getDefaultWarningRgba(colBack);

     
    if (!rgbIsNaN(colBack))
    {
        const hclBack = rgb2hclok(colBack);

        const hclBack1 = [...hclBack];
        const hclBack2 = [...hclBack];

        hclBack1[0] += 1/12;  if (hclBack1[0] > 1) hclBack1[0] -= 1;
        hclBack2[0] -= 1/12;  if (hclBack2[0] < 0) hclBack2[0] += 1;


        const altBack1 = rgb_a(clampRgb(hclok2rgb(hclBack1)), 0.35);
        const altBack2 = rgb_a(clampRgb(hclok2rgb(hclBack2)), 0.35);

        const factor   = getWarningFactor(colBack);

        const colWarn1 = rgbaLerp(colWarning, altBack1, factor);
        const colWarn2 = rgbaLerp(colWarning, altBack2, factor);
        
        warnStyle1     = rgba2style(colWarn1);
        warnStyle2     = rgba2style(colWarn2);
    }
    else
    {
        warnStyle1 = rgba2style(colWarning);
        warnStyle2 = rgba2style(colWarning);
    }


    return [warnStyle1, 
            warnStyle2];
}



function getWarningGradient(i, style1, style2)
{
    return 'repeating-linear-gradient('
            + '-45deg, '
            + 'transparent 0 ' + i   + 'px,' 
            +  style1 + ' '    + i   + 'px ' + i*2 +'px,'
            + 'transparent '   + i*2 + 'px ' + i*3 +'px,'
            +  style2 + ' '    + i*3 + 'px ' + i*4 +'px)';
}



function getWarningFactor(colBack)
{
    let dr, dg, db;

    if (colBack[0] < 0) dr = -colBack[0]; else if (colBack[0] > 1) dr = colBack[0] - 1; else dr = 0;
    if (colBack[1] < 0) dg = -colBack[1]; else if (colBack[1] > 1) dg = colBack[1] - 1; else dg = 0;
    if (colBack[2] < 0) db = -colBack[2]; else if (colBack[2] > 1) db = colBack[2] - 1; else db = 0;
    
    const d   = [dr, dg, db].sort()[1];
    const avg = (dr + dg + db) / 3;

    const factor = Math.min((d + avg) / 2, 1);

    // if (this.id == 'color')
    // {
    //     console.log('colBack =', colBack);
    //     console.log('dr     =', dr);
    //     console.log('dg     =', dg);
    //     console.log('db     =', db);
    //     console.log('d      =', d);
    //     console.log('avg    =', avg);
    //     console.log('factor =', factor);
    //     console.log('');
    // }

    return factor;
}



function getStripeBackColor(rgbBack)
{
    let rgbStripeBack = [...rgbBack];
        
    const factor = getWarningFactor(rgbBack);

    if (factor > 0)
    {
        const hcl = rgb2hclok(clampRgb(rgbBack));
        hcl[1] /= 2;
        

        rgbStripeBack = rgbLerp(rgbBack, clipChroma(hclok2rgb(hcl)), factor);
    }

    return rgbStripeBack;
}



function getDefaultWarningStyle(rgba)
{
    return !rgbaIsNaN(rgba)
         ? (isDark(rgba)  ? '#ffffff29' : '#00000022')
         : (darkMode ? '#ffffff08' : '#00000006'); 
}



function clampRgb(_rgb)
{
    const rgb = [..._rgb];

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function clampChan(val)
{
    return Math.min(Math.max(0, val), 1);
}



function setChan(_col, chan, val)
{
    const col = [..._col];
    col[chan] = val;
    return col;
}



function clipChroma(rgb)
{
    let hcl = rgb2hclok(rgb);

    let loopProtect = 10000;

    while (!rgbIsValid(hclok2rgb(hcl))
         && hcl[1] > 0.001
         && loopProtect-- > 0)
        hcl[1] -= 0.001;

    rgb = hclok2rgb(hcl);

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function noColorStyle(rgba)
{
    if (!rgbaIsNaN(rgba))
        return 'transparent';
    else
    {
        return darkMode
            ? 'rgba(56, 56, 56, 0.95)'
            : 'rgba(255, 255, 255, 0.95)';
    }
}


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function rgba2hex(rgba)
{
    let hex =
          Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function validHex2rgba(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgba_NaN 
           : hex2rgba(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }


    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    
    return rgb;
}



function hex2rgba(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgba = [];

    if (hex.length >= 8)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = parseInt(hex.slice(6, 8), 16); 
    }
    else if (hex.length >= 6)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = 0xff; 
    }
    else if (hex.length >= 4)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = parseInt(hex[3], 16) * 0x11; 
    }
    else if (hex.length == 3)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v; 
        rgba[1] = v; 
        rgba[2] = v; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v * 0x11; 
        rgba[1] = v * 0x11; 
        rgba[2] = v * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 0)
    {
        rgba[0] = 0; 
        rgba[1] = 0; 
        rgba[2] = 0;         
        rgba[3] = 0; 
    }


    rgba[0] /= 0xff;
    rgba[1] /= 0xff;
    rgba[2] /= 0xff;
    rgba[3] /= 0xff;


    return rgba;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const base32chars = '12345679ABCDEFGHJKLMNPQRSTUVWXYZ';



function arrayToBase32(array, chars = base32chars)
{
    let base32 = '';

    
    let len = array.length;
    let i   = 0;

    while (len > 0)
    {
        if (len >= 5)
        {
            const a0 = array[i  ],
                  a1 = array[i+1],
                  a2 = array[i+2],
                  a3 = array[i+3],
                  a4 = array[i+4];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[ (a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) <<  3) | ((a4 & 0xE0) >>> 5)];
            base32 += chars[ (a4 & 0x1F)];
        }
        else if (len == 4)
        {
            const a0 = array[i  ],
                  a1 = array[i+1],
                  a2 = array[i+2],
                  a3 = array[i+3];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[ (a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) <<  3)];
        }
        else if (len == 3)
        {
            const a0 = array[i  ],
                  a1 = array[i+1],
                  a2 = array[i+2];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1)];
        }
        else if (len == 2)
        {
            const a0 = array[i  ],
                  a1 = array[i+1];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4)];
        }
        else if (len == 1)
        {
            const a0 = array[i];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2)];
        }


        i   += 5;
        len -= 5;
    }


    return base32;
}



function base32toArray(base32, chars = base32chars)
{
    const array = [];


    let len = base32.length;
    let c   = 0;

    while (len > 0)
    {
        if (len >= 8)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]),
                  c4 = chars.indexOf(base32[c+4]),
                  c5 = chars.indexOf(base32[c+5]),
                  c6 = chars.indexOf(base32[c+6]),
                  c7 = chars.indexOf(base32[c+7]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
            array.push(((c6 & 0x07) << 5) | c7);
        }
        else if (len == 7)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]),
                  c4 = chars.indexOf(base32[c+4]),
                  c5 = chars.indexOf(base32[c+5]),
                  c6 = chars.indexOf(base32[c+6]);

            array.push(( c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
        }
        else if (len == 5)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]),
                  c4 = chars.indexOf(base32[c+4]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
        }
        else if (len == 4)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
        }
        else if (len == 2)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
        }


        c   += 8;
        len -= 8;
    }


    return array;
}


const cryptoModulusSize     = 256; // to keep the keys short
const millerRabinIterations = 40;

const cryptoBufferSize      = cryptoModulusSize/8;
const cryptoPrimeBufferSize = cryptoBufferSize /2;
     
const cryptoBuffer          = new Uint8Array(cryptoPrimeBufferSize);


function bigCryptoRandom()
{
    for (let i = 0; i < cryptoPrimeBufferSize; i++)
        cryptoBuffer[i] = toInt(Math.random() * 0x100);

    cryptoBuffer[0]                       |= 0xC0; // set the top bit to ensure a relatively large number
    cryptoBuffer[cryptoPrimeBufferSize-1] |= 0x01; // set low bit to ensure the number is odd

    return bigFromBuffer(cryptoBuffer);
}



function bigNextCryptoPrime(n) 
{
    while (!bigIsPrime(n))
        n += 2n;
    
    return n;
}



function bigCryptoPrime(e)
{
    // set p so that gcd(e, p-1) = 1
    
    let p;

    do
    {
        const rnd = bigCryptoRandom();
        p         = bigNextCryptoPrime(rnd);
    }
    while (gcd(p-1n, e) != 1n); 
        
    return p;
}



function createCryptoPrimePair(e)
{
    let p = bigCryptoPrime(e);
    
    let q;
    do { q = bigCryptoPrime(e); } 
    while (q == p);

    if (p < q)
        [p,q] = [q,p];

    return [p, q];
}



function createCryptoKeys(e = 65537n) 
{
    // for a 64-bit modulus
    // const p   = 4177474087n,
    // const q   = 3438374081n;
    
    // for a 256-bit modulus
    const p = 324595347357507885811600545702775285127n;
    const q = 269975805195380507054350212467502676501n;

    // for a 2048-bit modulus
    // const p = 175174222516298387167194272697585437036810021236416760552899966284752011252198594013507417602600201436392264584002280023410776413073587129726141185393623449028440388452751264699475754683756720892485898644561628374159554994706803903659838117562670498436083060507993966358733361521299548446230454315603662036469n;
    // const q = 137903165485589693700981982313430857945541993940503493680067557312840527561097051166704349879274851836049344355243285831485925505832584105624064061259858226754867264793670708366732221684041373398786004227019387898423254675498301526584324375120659877872268262270523914099357199684086439264688977237417227910807n;
    
    const  n   = p * q;
    const _phi = (p-1n) * (q-1n);

    const  d   = bigModInvert(e, _phi);

    return {
        public:  {n:n, e:e },
        private: {n:n, d:d, p:p, q:q} };
}                        



function encryptDataBlock(n, key, sign  ) { return bigPowMod(n, (sign   ? key.d : key.e), key.n); }        
function decryptDataBlock(n, key, verify) { return bigPowMod(n, (verify ? key.e : key.d), key.n); }        



function encrypt(data, key) { return encryptData(data, key, false); }
function decrypt(data, key) { return decryptData(data, key, false); }

function sign   (data, key) { return encryptData(data, key, true); } // yes I know real sign/verify uses a hash,
function verify (data, key) { return decryptData(data, key, true); } // but I prefer it this way for what I need



function encryptData(data, key, sign)
{
    // prep array should be a multiple of cryptoBufferSize
    const prep   = new Uint8Array(Math.ceil((data.length) / cryptoBufferSize) * cryptoBufferSize); 
    const cipher = new Uint8Array(prep.length);


    const start = prep.length - data.length;
    for (let i = 0; i < data.length; i++)
        prep[start+i] = data[i];


    let length = prep.length;
    let nBlock = 0;

    while (length > 0)
    {
        const blockStart = nBlock * cryptoBufferSize;
        const blockSize  = Math.min(length, cryptoBufferSize);
        
        const block = bigFromBufferAt(prep, blockStart, cryptoBufferSize);
        const enc   = encryptDataBlock(block, key, sign);
        
        bigToBufferAt(enc, cipher, blockStart, cryptoBufferSize);
        
        nBlock++;
        length -= blockSize;
    }
    
    
    return cipher;
}



function decryptData(cipher, key, verify)
{
    const data = new Uint8Array(cipher.length);
    
    
    let length = cipher.length;
    let nBlock = 0;
    
    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);

        var block = bigFromBufferAt(cipher, blockStart, cryptoBufferSize);
        var dec   = decryptDataBlock(block, key, verify);
        bigToBufferAt(dec, data, blockStart, cryptoBufferSize); 

        nBlock++;
        length -= blockSize;
    }    


    return data;    
}


const licenseKeys     = createCryptoKeys();
const licenseHashSize = 4;



function createLicenseKey(license)
{
    const str  = createLicenseDataString(license);
    const hash = hashLicenseString(str, licenseHashSize);
    const enc  = sign(hash, licenseKeys.private);
    const key  = arrayToBase32(enc);

    return key;
}



function createLicenseFromData(userId, tier, lastDate) // DDMMYYYY
{
    return createLicense(
        userId,
        tier,
        parseInt(lastDate.substring(0, 2)),
        parseInt(lastDate.substring(2, 4)),
        parseInt(lastDate.substring(4   )));
}



function createLicense(userId, tier, lastDay, lastMonth, lastYear)
{
    return {
        userId:    userId,
        tier:      tier, // 0 = free trial, 1+ = subscription
        lastDay:   lastDay,
        lastMonth: lastMonth,
        lastYear:  lastYear,
    };
}



function createLicenseString(license)
{
    return license.userId
         + createLicenseInfoString(license);
}



function createLicenseInfoString(license)
{
    return license.tier     .toString()
         + license.lastDay  .toString().padStart(2, '0') 
         + license.lastMonth.toString().padStart(2, '0')
         + license.lastYear .toString(); 
}



function createLicenseDataString(license)
{
    const str = createLicenseInfoString(license);

    let comp1 = str;
    let comp2 = '';
    let comp3 = '';
    
    for (let i = 0; i < comp1.length; i++)
    {
        const code2 = ((parseInt(comp1[i]) + i) % 10);

        comp2 += code2.toString();
        comp3 += ((parseInt(comp1[i]) ^ code2) % 10).toString()
    }


    const compData = (comp1 + comp2 + comp3).substring(0, license.userId.length)

    return compactLicenseDataString(license.userId, compData);
}



function getLicenseCompData(license)
{
    const str = createLicenseInfoString(license);

    let comp1 = str;
    let comp2 = '';
    let comp3 = '';
    
    for (let i = 0; i < comp1.length; i++)
    {
        const code2 = (parseInt(comp1[i]) + i) % 10;

        comp2 += code2.toString();
        comp3 += ((parseInt(comp1[i]) ^ code2) % 10).toString()
    }


    return (comp1 + comp2 + comp3).substring(0, license.userId.length)
}



function compactLicenseDataString(userId, str)
{
    let comp = new Uint8Array(userId.length);

    for (let i = 0; i < comp.length; i++)
        comp[i] = (userId.charCodeAt(i) ^ str.charCodeAt(i)) % 0x100;

    return arrayToBase32(comp);
}



function hashLicenseString(str, nBytes)
{
    // XOR wrap name around a given number of bytes

    const bytes = stringToCharCodeArray(str);


    if (bytes.length > nBytes)
    {
        let pos    = nBytes;
        let length = bytes.length - nBytes;
        

        while (length > 1)
        {
            for (let i = 0; i < nBytes; i++)
                bytes[i] ^= bytes[pos+i];
                
            pos    += nBytes;
            length -= nBytes;
        }
    }
    

    return newSizeArrayFrom(bytes, nBytes);
}



function validateLicense(userId, licenseKey)
{
    const now = new Date(Date.now());


    for (let tier = 0; tier <= 1; tier++)
    {
        const license = createLicense(
            userId,
            tier,
            now.getDate(),
            now.getMonth()+1, // months start at 0
            now.getFullYear());


        let   curCheck  = 0;
        const maxCheck  = 31 * 24;


        while (curCheck++ < maxCheck)
        {
            if (validateLicenseKey(license, licenseKey))
            {
                license.tier = tier;
                return license;
            }

            license.lastDay++; // err on the side of client, include current day if it's last

            if (license.lastDay   > 31) { license.lastMonth++; license.lastDay   = 1; }
            if (license.lastMonth > 12) { license.lastYear ++; license.lastMonth = 1; }
        }
    }


    return null;
}



function validateLicenseKey(license, key, rec = false)
{
    const str   = createLicenseDataString(license);
    
    const hash  = hashLicenseString(str, licenseHashSize);
    
    const arr   = base32toArray(key.toUpperCase());
    const dec   = verify(arr, licenseKeys.public).subarray(licenseHashSize);
    const trim  = dec.subarray(dec.length - licenseHashSize);
   
    const valid = arraysAreEqual(hash, trim);


    if (valid && !rec)
    {
        let lowerKey = key;

        const lastChar  = lowerKey.at(-1);
        const lastIndex = base32chars.indexOf(lastChar);

        if (lastIndex > 0)
        {
            lowerKey = replaceInStringAt(lowerKey, lowerKey.length-1, base32chars[lastIndex-1]);

            if (validateLicenseKey(license, lowerKey, true))
                return false; // guard against the last bit
        }
    }


    return valid;
}


const LIST_VALUE              = 'LIST#';

const NUMBER_LIST_VALUE       = 'NLIST#';
const   TEXT_LIST_VALUE       = 'TLIST#';
const  SHAPE_LIST_VALUE       = 'SLIST#';


const NULL_NODE               = 'NULL';
const START                   = 'START';
const REPEAT                  = 'REPT';
const CACHE                   = 'CACHE';
const FREEZE                  = 'FRZ';
const TIMER                   = 'TIMER';
const VALUE_NAME              = 'VNAME';

const LIST                    = 'LIST';
const CONDENSE                = 'CDENSE';
const SUBLIST                 = 'SUBLST';
const UNIQUE                  = 'UNIQ';
const REVERSE_LIST            = 'REVLST';
const SORT                    = 'SORT';
const COLUMN                  = 'CLMN';
const CELL                    = 'CELL';
const ITEMS                   = 'ITEMS';
const LIST_COUNT              = 'COUNT';
const CONTAINS                = 'LCONT';
const SELECT                  = 'SEL';
const IF_ELSE                 = 'IF';
const FILTER                  = 'LSTFLT';
const DEFINE                  = 'DEFINE';  


const ANY_VALUE               = 'ANY#';


const LIST_TYPES =
[
    LIST_VALUE,
    NUMBER_LIST_VALUE,
    TEXT_LIST_VALUE,
    SHAPE_LIST_VALUE,
    LIST,
    SUBLIST,
    //ITEMS,
    LIST_COUNT,
    CONTAINS,
    REPEAT
];


const LIST_VALUES =
[
           LIST_VALUE,
    NUMBER_LIST_VALUE,
      TEXT_LIST_VALUE,
     SHAPE_LIST_VALUE
];


//const FOREACH = 'FOR';


const FLOW_TYPES =
[
    NULL_NODE,
    ...LIST_TYPES,
    CONDENSE,
    SUBLIST,
    UNIQUE,
    REVERSE_LIST,
    COLUMN,
    SORT,
    CELL,
    ITEMS,
    SELECT,
    IF_ELSE,
    FILTER,
    START,
    REPEAT,
    //FOREACH,
    DEFINE,
    CACHE,
    FREEZE,
    TIMER,
    VALUE_NAME
];


const NUMBER_VALUE            = 'NUM#';  
const NUMBER                  = 'NUM';   
const NUMBER_SIGN             = 'NSIGN';   
const NUMBER_ABSOLUTE         = 'ABS';   
const NUMBER_ROUND            = 'ROUND';   
const NUMBER_MINMAX           = 'MINMAX';   
const NUMBER_LIMITS           = 'LIM';   
const NUMBER_CONSTANT         = 'CONST';  
const NUMBER_DATETIME         = 'DATE';  
const NUMBER_RANGE            = 'RANGE';  
const NUMBER_SEQUENCE         = 'SEQ';  
const NUMBER_RANDOM           = 'RAND';  
const NUMBER_NOISE            = 'NOISE';  
const NUMBER_PROBABILITY      = 'PROB';  
const NUMBER_ACCUMULATE       = 'ACCUM';  
const NUMBER_INTERPOLATE      = 'LERP'; 
const NUMBER_SOLVE            = 'SOLVE';
const NUMBER_ANIMATE          = 'NANIM';

const NUMBER_MATH             = 'MATH';  
const NUMBER_SIMPLE_MATH      = 'SMATH';  
const NUMBER_ADD              = 'ADD';   
const NUMBER_SUBTRACT         = 'SUB';   
const NUMBER_MULTIPLY         = 'MUL';   
const NUMBER_DIVIDE           = 'DIV';   
const NUMBER_MODULO           = 'MOD';   
const NUMBER_EXPONENT         = 'EXP';

const NUMBER_BOOLEAN          = 'NBOOL';  
const NUMBER_NOT              = 'NOT';
const NUMBER_AND              = 'AND';
const NUMBER_OR               = 'OR';
const NUMBER_XOR              = 'XOR';

const NUMBER_CONDITION        = 'COND';
const NUMBER_EQUAL            = 'EQ';
const NUMBER_NOT_EQUAL        = 'NE';
const NUMBER_LESS             = 'LT';
const NUMBER_LESS_OR_EQUAL    = 'LE';
const NUMBER_GREATER          = 'GT';
const NUMBER_GREATER_OR_EQUAL = 'GE';

const NUMBER_TRIG             = 'TRIG';  
const NUMBER_SIN              = 'SIN';   
const NUMBER_COS              = 'COS';   
const NUMBER_TAN              = 'TAN';   


const MATH_TYPES =
[
    NUMBER_MATH,
    NUMBER_SIMPLE_MATH,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT
];


const NUMBER_BOOLEAN_TYPES =
[
    NUMBER_BOOLEAN,
    NUMBER_NOT,
    NUMBER_AND,
    NUMBER_OR,
    NUMBER_XOR
];


const CONDITION_TYPES =
[
    NUMBER_CONDITION,
    NUMBER_EQUAL,
    NUMBER_NOT_EQUAL,
    NUMBER_LESS,
    NUMBER_LESS_OR_EQUAL,
    NUMBER_GREATER,
    NUMBER_GREATER_OR_EQUAL
];


const TRIG_TYPES =
[
    NUMBER_TRIG,
    NUMBER_SIN,
    NUMBER_COS,
    NUMBER_TAN
];


const TEXT_VALUE     = 'TEXT#';
const TEXT           = 'TEXT';
const TEXT_LENGTH    = 'TLEN';
const TEXT_TRIM      = 'TTRIM';
const TEXT_SUBSTRING = 'TSUB';
const TEXT_CONTAINS  = 'TCONT';
const TEXT_CASE      = 'TCASE';
const TEXT_REPLACE   = 'TREPL';
const TEXT_JOIN      = 'TJOIN';
const TEXT_PAD       = 'TPAD';
const TEXT_COMPARE   = 'TCMP';
const TEXT_CHAR      = 'TCHAR';
const NUMBER_TO_TEXT = 'N2T';
const TEXT_TO_NUMBER = 'T2N';
const TEXT_TO_COLOR  = 'T2C';
const TEXT_SPLIT     = 'TSPLT';
const TEXT_JSON      = 'TJSON';
const TEXT_CSV       = 'TCSV';
const TEXT_FETCH     = 'FETCH';
const TEXT_FILE      = 'TFILE';


const NUMBER_TYPES =
[
    NUMBER_VALUE,
    NUMBER_LIST_VALUE,
    NUMBER,
    NUMBER_SIGN,
    NUMBER_ABSOLUTE,
    NUMBER_ROUND,
    NUMBER_MINMAX,
    NUMBER_LIMITS,
    NUMBER_CONSTANT,
    NUMBER_DATETIME,
    NUMBER_RANGE,
    NUMBER_SEQUENCE,
    NUMBER_RANDOM,
    NUMBER_NOISE,
    NUMBER_PROBABILITY,
    NUMBER_ACCUMULATE,
    NUMBER_INTERPOLATE,
    NUMBER_SOLVE,
    NUMBER_ANIMATE,
    NUMBER_TO_TEXT,

    ...MATH_TYPES,
    ...NUMBER_BOOLEAN_TYPES,
    ...CONDITION_TYPES,
    ...TRIG_TYPES
];


const TEXT_TYPES =
[
    TEXT_VALUE,
    TEXT_LIST_VALUE,
    TEXT,
    TEXT_LENGTH,
    TEXT_TRIM,
    TEXT_SUBSTRING,
    TEXT_CONTAINS,
    TEXT_CASE,
    TEXT_JOIN,
    TEXT_PAD,
    TEXT_REPLACE,
    TEXT_COMPARE,
    TEXT_CHAR,
    TEXT_TO_NUMBER,
    TEXT_TO_COLOR,
    TEXT_SPLIT,
    TEXT_JSON,
    TEXT_CSV,
    TEXT_FETCH,
    TEXT_FILE
];


const COLOR_VALUE        = 'COL#';  
const COLOR              = 'COL';   
const VALID_COLOR        = 'CVAL';  
const CORRECT_COLOR      = 'CCOR';  
const COLOR_CONVERT_P3   = 'COLP3';
const COLOR_CONTRAST     = 'CCNT';  
const COLORBLIND         = 'BLND';  
const COLOR_INTERPOLATE  = 'CLERP'; 
const COLOR_BLEND        = 'CBLND';


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    CORRECT_COLOR,
    COLOR_CONVERT_P3,
    COLORBLIND,
    COLOR_INTERPOLATE,
    COLOR_BLEND
];


const FILL_VALUE         = 'FILL#';
const FILL               = 'FILL';
const FILL_TYPES         = [FILL_VALUE, FILL];
  
const STROKE_VALUE       = 'STRK#';
const STROKE             = 'STRK';
const STROKE_TYPES       = [STROKE_VALUE, STROKE];
  
const COLOR_STOP_VALUE   = 'CSTOP#';
const COLOR_STOP         = 'CSTOP';
const COLOR_STOP_TYPES   = [COLOR_STOP_VALUE, COLOR_STOP];
  
const GRADIENT_VALUE     = 'GRAD#';
const GRADIENT           = 'GRAD';
const GRADIENT_TYPES     = [GRADIENT_VALUE, GRADIENT];
 

const DROP_SHADOW_VALUE  = 'DRSH#';
const DROP_SHADOW        = 'DRSH';
const DROP_SHADOW_TYPES  = [DROP_SHADOW_VALUE, DROP_SHADOW];

const INNER_SHADOW_VALUE = 'INSH#';
const INNER_SHADOW       = 'INSH';
const INNER_SHADOW_TYPES = [INNER_SHADOW_VALUE, INNER_SHADOW];

const LAYER_BLUR_VALUE   = 'LBLR#';
const LAYER_BLUR         = 'LBLR';
const LAYER_BLUR_TYPES   = [LAYER_BLUR_VALUE, LAYER_BLUR];

const BACK_BLUR_VALUE    = 'BBLR#';
const BACK_BLUR          = 'BBLR';
const BACK_BLUR_TYPES    = [BACK_BLUR_VALUE, BACK_BLUR];

const LAYER_MASK_VALUE   = 'MASK#';
const LAYER_MASK         = 'MASK';
const LAYER_MASK_TYPES   = [LAYER_MASK_VALUE, LAYER_MASK];

const VAR_COLOR          = 'CVAR';
const VAR_NUMBER         = 'NVAR';
const VAR_TEXT           = 'TVAR';
const VAR_BOOLEAN        = 'BVAR';


const EFFECT_TYPES =
[
    ...DROP_SHADOW_TYPES,
    ...INNER_SHADOW_TYPES,
    ...LAYER_BLUR_TYPES,
    ...BACK_BLUR_TYPES,
    ...LAYER_MASK_TYPES
];


const VARIABLE_TYPES =
[
    VAR_COLOR,
    VAR_NUMBER,
    VAR_TEXT,
    VAR_BOOLEAN
];


const STYLE_VALUES =
[
    COLOR_VALUE, 
    FILL_VALUE, 
    GRADIENT_VALUE, 
    STROKE_VALUE,
    DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
    LAYER_BLUR_VALUE,
    BACK_BLUR_VALUE,
    LAYER_MASK_VALUE
];


const COLOR_STYLE          = 'CSTL';
 
 
const SHAPE_VALUE          = 'SHP#'; // abstract placeholder
 
const RECTANGLE_VALUE      = 'RECT#';
const RECTANGLE            = 'RECT'; 
const RECTANGLE_TYPES      = [RECTANGLE_VALUE, RECTANGLE];
 
const LINE_VALUE           = 'LINE#';
const LINE                 = 'LINE'; 
const LINE_TYPES           = [LINE_VALUE, LINE];
   
const ELLIPSE_VALUE        = 'ELPS#';
const ELLIPSE              = 'ELPS'; 
const ELLIPSE_TYPES        = [ELLIPSE_VALUE, ELLIPSE];
 
const TRAPEZE_VALUE        = 'TRPZ#';
const TRAPEZE              = 'TRPZ';
const TRAPEZE_TYPES        = [TRAPEZE_VALUE, TRAPEZE];
 
const POLYGON_VALUE        = 'POLY#';
const POLYGON              = 'POLY'; 
const POLYGON_TYPES        = [POLYGON_VALUE, POLYGON];
   
const STAR_VALUE           = 'STAR#';
const STAR                 = 'STAR'; 
const STAR_TYPES           = [STAR_VALUE, STAR];
   
const TEXT_SHAPE_VALUE     = 'TXTS#';
const TEXT_SHAPE           = 'TXTS'; 
const TEXT_SHAPE_TYPES     = [TEXT_SHAPE_VALUE, TEXT_SHAPE];
  
const POINT                = 'PT';
const POINT_VALUE          = 'PT#';
const POINT_TYPES          = [POINT_VALUE, POINT];

const VECTOR_PATH_VALUE    = 'VPATH#';
const VECTOR_PATH          = 'VPATH'; 
const VECTOR_PATH_TYPES    = [VECTOR_PATH_VALUE, VECTOR_PATH];
 
const VECTOR_VERTEX_VALUE  = 'VPT#';
const VECTOR_VERTEX        = 'VPT'; 
const VECTOR_VERTEX_TYPES  = [VECTOR_VERTEX_VALUE, VECTOR_VERTEX];
 
const VECTOR_EDGE_VALUE    = 'VEDGE#';
const VECTOR_EDGE          = 'VEDGE'; 
const VECTOR_EDGE_TYPES    = [VECTOR_EDGE_VALUE, VECTOR_EDGE];
 
const VECTOR_REGION_VALUE  = 'VREG#';
const VECTOR_REGION        = 'VREG'; 
const VECTOR_REGION_TYPES  = [VECTOR_REGION_VALUE, VECTOR_REGION];
 
const VECTOR_NETWORK_VALUE = 'VNET#';
const VECTOR_NETWORK       = 'VNET'; 
const VECTOR_NETWORK_TYPES = [VECTOR_NETWORK_VALUE, VECTOR_NETWORK];
 
const SHAPE_GROUP_VALUE    = 'SGRP#';
const SHAPE_GROUP          = 'SGRP';
const SHAPE_GROUP_TYPES    = [SHAPE_GROUP_VALUE, SHAPE_GROUP];
 
const FRAME_VALUE          = 'FRM#';
const FRAME                = 'FRM';
const FRAME_TYPES          = [FRAME_VALUE, FRAME];
 

const MOVE                 = 'MOVE';
const ROTATE               = 'ROT';
const SCALE                = 'SCALE';
const SKEW                 = 'SKEW';

const CENTER               = 'CENTR';
const RESET_XFORM          = 'RSTX';

const PLACE                = 'PLACE';
const SHAPE_APPLY          = 'APPLY';
  
const MEASURE_POINTS       = 'MESPT';
const INTERPOLATE_POINT    = 'PTLERP';
const POINT_ON_PATH        = 'PONPT';


const BOOLEAN              = 'BOOL';
const BOOLEAN_VALUE        = 'BOOL#';

const BOOL_UNION           = 'BOOLU';
const BOOL_SUBTRACT        = 'BOOLS';
const BOOL_INTERSECT       = 'BOOLI';
const BOOL_EXCLUDE         = 'BOOLE';


const BOOLEAN_TYPES =
[
    BOOLEAN,
    BOOLEAN_VALUE,
    BOOL_UNION,
    BOOL_SUBTRACT,
    BOOL_INTERSECT,
    BOOL_EXCLUDE
]


const RENDER             = 'RENDER';


const SHAPE_VALUES =
[
    SHAPE_VALUE,
    SHAPE_LIST_VALUE,
    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    TRAPEZE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE,
    TEXT_SHAPE_VALUE,
    POINT_VALUE,
    VECTOR_PATH_VALUE,
    VECTOR_VERTEX_VALUE,
    VECTOR_EDGE_VALUE,
    VECTOR_REGION_VALUE,
    VECTOR_NETWORK_VALUE,
    SHAPE_GROUP_VALUE,
    FRAME_VALUE,
    BOOLEAN_VALUE,
    DROP_SHADOW_VALUE
];


const AFFINE_TYPES =
[
    ROTATE,
    SCALE,
    SKEW
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    ...RECTANGLE_TYPES,
    ...LINE_TYPES,
    ...ELLIPSE_TYPES,
    ...TRAPEZE_TYPES,
    ...POLYGON_TYPES,
    ...STAR_TYPES,
    ...TEXT_SHAPE_TYPES,
    ...POINT_TYPES,
    ...VECTOR_PATH_TYPES,
    ...VECTOR_VERTEX_TYPES,
    ...VECTOR_EDGE_TYPES,
    ...VECTOR_REGION_TYPES,
    ...VECTOR_NETWORK_TYPES,
    ...SHAPE_GROUP_TYPES,
    ...FRAME_TYPES,
    ...BOOLEAN_TYPES,

    MOVE,
    ...AFFINE_TYPES,
    CENTER,
    RESET_XFORM,

    PLACE,
    SHAPE_APPLY,

    MEASURE_POINTS,
    INTERPOLATE_POINT,
    POINT_ON_PATH,

    RENDER
];


const ALL_VALUES =
[
            LIST_VALUE,
     NUMBER_LIST_VALUE,
       TEXT_LIST_VALUE,
      SHAPE_LIST_VALUE,
     
          NUMBER_VALUE,
            TEXT_VALUE,
           COLOR_VALUE,
 
            FILL_VALUE,
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
          STROKE_VALUE,
 
      COLOR_STOP_VALUE,
        GRADIENT_VALUE,
 
           SHAPE_VALUE,
       RECTANGLE_VALUE,
            LINE_VALUE,
         ELLIPSE_VALUE,
         TRAPEZE_VALUE,
         POLYGON_VALUE,
            STAR_VALUE,
      TEXT_SHAPE_VALUE,
           POINT_VALUE,
     VECTOR_PATH_VALUE,
   VECTOR_VERTEX_VALUE,
     VECTOR_EDGE_VALUE,
   VECTOR_REGION_VALUE,
  VECTOR_NETWORK_VALUE,
     SHAPE_GROUP_VALUE,
           FRAME_VALUE,

     DROP_SHADOW_VALUE,
    INNER_SHADOW_VALUE,
      LAYER_BLUR_VALUE,
       BACK_BLUR_VALUE
];


const GROUP_NODE    = 'GROUP';
const GROUP_PARAM   = 'GPARAM';


const GROUP_TYPES =
[
    GROUP_NODE,
    GROUP_PARAM
];


const COMMENT       = 'CMNT';
const PANEL         = 'PANEL';


const ACTIVE        = 'ACT';
const BEFORE_ACTIVE = 'BEF';
const DISABLED      = 'DIS';
const NOCACHE       = 'NOC';
 
const PARAM         = 'PARAM'; // nodeId paramId
 

const LOG           = 'LOG';


const GRAPH         = 'GRAPH';


const MATH_OPS = 
[   // the order is important for logical keyboard value changes
    [NUMBER_SUBTRACT, '−' ],
    [NUMBER_ADD,      '+' ],
    [NUMBER_MODULO,   '%' ],
    [NUMBER_DIVIDE,   '/' ], //'÷' ],
    [NUMBER_MULTIPLY, '×' ],
    [NUMBER_EXPONENT, 'e<sup>x'] 
];



const BOOLEAN_NOT = 0;
const BOOLEAN_XOR = 1;
const BOOLEAN_OR  = 2;
const BOOLEAN_AND = 3;


const BOOLEAN_OPS = 
[   
    [BOOLEAN_NOT, 'not'],
    [BOOLEAN_XOR, 'xor'], 
    [BOOLEAN_OR,  'or' ],
    [BOOLEAN_AND, 'and']
];



const CONDITION_LESS             = 0;
const CONDITION_LESS_OR_EQUAL    = 1;
const CONDITION_NOT_EQUAL        = 2;
const CONDITION_EQUAL            = 3;
const CONDITION_GREATER_OR_EQUAL = 4;
const CONDITION_GREATER          = 5;


const CONDITION_OPS = 
[   
    [CONDITION_LESS,             '<'],
    [CONDITION_LESS_OR_EQUAL,    '≤'],
    [CONDITION_NOT_EQUAL,        '≠'],
    [CONDITION_EQUAL,            '='],
    [CONDITION_GREATER_OR_EQUAL, '≥'],
    [CONDITION_GREATER,          '>']
];



const TRIG_SIN = 0;
const TRIG_COS = 1;
const TRIG_TAN = 2;


const TRIG_OPS = 
[   
    [TRIG_SIN, 'sin'],
    [TRIG_COS, 'cos'],
    [TRIG_TAN, 'tan']
];



const EMPTY_ACTION               = 'EMPTY';
const CONNECT_ACTION             = 'CONNECT';
const CREATE_ACTION              = 'CREATE';
const CREATE_INSERT_ACTION       = 'CREATE_INSERT';
const DELETE_ACTION              = 'DELETE';
const DISCONNECT_ACTION          = 'DISCONNECT';
const LINK_STYLE_ACTION          = 'LINK_STYLE';
const MAKE_ACTIVE_ACTION         = 'MAKE_ACTIVE';
const MAKE_PASSIVE_ACTION        = 'MAKE_PASSIVE';
const PASTE_ACTION               = 'PASTE';
const RECONNECT_ACTION           = 'RECONNECT';
const REMOVE_ACTION              = 'REMOVE';
const RENAME_ACTION              = 'RENAME';
const REORDER_INPUTS_ACTION      = 'REORDER_INPUTS';
const REORDER_CONNECTIONS_ACTION = 'REORDER_CONNECTIONS';
const SELECT_ACTION              = 'SELECT';
const SELECT_MOVE_ACTION         = 'SELECT_MOVE';
const MOVE_NODES_ACTION          = 'MOVE_NODES';
const SET_PARAM_VALUE_ACTION     = 'SET_PARAM_VALUE';
const SET_PARAM_SETTING_ACTION   = 'SET_PARAM_SETTING';
const SET_NODE_RECT_ACTION       = 'SET_NODE_RECT';
const TOGGLE_DISABLE_ACTION      = 'TOGGLE_DISABLE';
const TOGGLE_PARAM_HEADER_ACTION = 'TOGGLE_PARAM_HEADER';
const SET_CURRENT_GRAPH_ACTION   = 'SET_CURRENT_GRAPH';
const CREATE_PAGE_ACTION         = 'CREATE_PAGE';
const DELETE_PAGE_ACTION         = 'DELETE_PAGE';
const GROUP_NODES_ACTION         = 'GROUP_NODES';
const UNGROUP_NODES_ACTION       = 'UNGROUP_NODES';
const HIGHLIGHT_NODES_ACTION     = 'HIGHLIGHT_NODES';


const BLEND_NORMAL               = 'BNORM';
const BLEND_DARKEN               = 'BDARK';
const BLEND_MULTIPLY             = 'BMULT';
const BLEND_COLOR_BURN           = 'BBURN';
const BLEND_LIGNTEN              = 'BLITE';
const BLEND_SCREEN               = 'BSCRN';
const BLEND_COLOR_DODGE          = 'BDODG';
const BLEND_OVERLAY              = 'BOVER';
const BLEND_SOFT_LIGHT           = 'BSOFT';
const BLEND_HARD_LIGHT           = 'BHARD';
const BLEND_DIFFERENCE           = 'BDIFF';
const BLEND_EXCLUSION            = 'BEXCL';
const BLEND_HUE                  = 'BHUE';
const BLEND_SATURATION           = 'BSAT';
const BLEND_COLOR                = 'BCOL';
const BLEND_LUMINOSITY           = 'BLUM';


const BlendModes =
[
    [BLEND_NORMAL,      'normal',      'NORMAL'     ],
    [BLEND_DARKEN,      'darken',      'DARKEN'     ],
    [BLEND_MULTIPLY,    'multiply',    'MULTIPLY'   ],
    [BLEND_COLOR_BURN,  'color burn',  'COLOR_BURN' ],
    [BLEND_LIGNTEN,     'lighten',     'LIGHTEN'    ],
    [BLEND_SCREEN,      'screen',      'SCREEN'     ],
    [BLEND_COLOR_DODGE, 'color dodge', 'COLOR_DODGE'],
    [BLEND_OVERLAY,     'overlay',     'OVERLAY'    ],
    [BLEND_SOFT_LIGHT,  'soft light',  'SOFT_LIGHT' ],
    [BLEND_HARD_LIGHT,  'hard light',  'HARD_LIGHT' ],
    [BLEND_DIFFERENCE,  'difference',  'DIFFERENCE' ],
    [BLEND_EXCLUSION,   'exclusion',   'EXCLUSION'  ],
    [BLEND_HUE,         'hue',         'HUE'        ],
    [BLEND_SATURATION,  'saturation',  'SATURATION' ],
    [BLEND_COLOR,       'color',       'COLOR'      ],
    [BLEND_LUMINOSITY,  'luminosity',  'LUMINOSITY' ]
];



const FONT_WEIGHTS =
[
    ['thin',        100],
    ['extra light', 200],
    ['light',       300],
    ['regular',     400],
    ['medium',      500],
    ['semi bold',   600],
    ['bold',        700],
    ['extra bold',  800],
    ['black',       900]
];



const FO_TYPE           =  0;
const FO_NODE_ID        =  1;

const FO_OBJECT_ID      =  2;   const FO_STYLE_ID     = 2;
const FO_OBJECT_NAME    =  3;   const FO_STYLE_NAME   = 3;

const FO_FEEDBACK       =  4;   const FO_STYLE_PAINTS = 4;
const FO_RETAIN         =  5;


const FO_XP0            =  6;
const FO_XP1            =  7;
const FO_XP2            =  8;

const FO_SCALE          =  9;

const FO_FILLS          = 10;
const FO_STROKES        = 11;


const FO_STROKE_WEIGHT  = 12;
const FO_STROKE_ALIGN   = 13;
const FO_STROKE_JOIN    = 14;                                    
const FO_STROKE_MITER   = 15;
const FO_STROKE_CAP     = 16;
const FO_STROKE_DASHES  = 17;

const FO_EFFECTS        = 18;

const FO_DECO           = 19;

const FO_MASK           = 20;

const FO_X              = 21;                                                                                                                                                                                                         const FO_GROUP_CHILDREN = 21;
const FO_Y              = 22;                                    
const FO_WIDTH          = 23;   const FO_POINT_IS_CENTER = 23;   
const FO_HEIGHT         = 24;                                    

const FO_RECT_ROUND     = 25;   const FO_ELLIPSE_FROM    = 25;   const FO_VECTOR_NETWORK_DATA = 25;   const FO_VECTOR_PATH_DATA    = 25;   const FO_POLY_ROUND   = 25;   const FO_STAR_ROUND  = 25;   const FO_FIG_WIDTH      = 25;   const FO_FRAME_ROUND    = 25;
                                const FO_ELLIPSE_TO      = 26;                                        const FO_VECTOR_PATH_WINDING = 26;   const FO_POLY_CORNERS = 26;   const FO_STAR_POINTS = 26;   const FO_FIG_HEIGHT     = 26;   const FO_FRAME_CHILDREN = 26;
                                const FO_ELLIPSE_INNER   = 27;                                        const FO_VECTOR_PATH_ROUND   = 27;                                 const FO_STAR_CONVEX = 27;   const FO_TEXT           = 27; 
                                                                                                                                 
                                                                                                                                                                                                      const FO_FONT           = 28;
                                                                                                                                                                                                      const FO_FONT_SIZE      = 29;
                                                                                                                                                                                                      const FO_FONT_STYLE     = 30;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_ALIGN_H        = 31;
                                                                                                                                                                                                      const FO_ALIGN_V        = 32;
                                                                                                                                                                                                                                    
                                                                                                                                                                                                      const FO_LINE_HEIGHT    = 33;
                                                                                                                                                                                                      const FO_LETTER_SPACING = 34;                                


class FigmaObject
{
    type;
    

    nodeId     = '';


    objectId   = NULL;
    objectName = NULL;

    inputIndex = -1; // for unique object IDs

    retain     = 0;
    feedback   = false;


    xform;

    xp0 = null; //  xp0 ------- xp1 
    xp1 = null; //   |     
    xp2 = null; //  xp2

    sp0 = null; //  sp0 ------- sp1 
    sp1 = null; //   |
    sp2 = null; //  sp2


    scaleCorners;
    scaleStyle;



    constructor(type, nodeId, objectId, objectName)
    {
        this.type         = type;
        this.nodeId       = nodeId;
        this.objectId     = objectId;
        this.objectName   = objectName;

        this.xform        = clone(identity);

        this.scaleCorners = 1;
        this.scaleStyle   = 1;
    }



    copyBase(base)
    {
        this.inputIndex   = base.inputIndex;
        
        this.feedback     = base.feedback;
        this.retain       = base.retain;
        
        this.xform        = clone(base.xform);

        this.xp0          = clone(base.xp0); //base.xp0 ? base.xp0.copy() : null;
        this.xp1          = clone(base.xp1); //base.xp1 ? base.xp1.copy() : null;
        this.xp2          = clone(base.xp2); //base.xp2 ? base.xp2.copy() : null;

        this.sp0          = clone(base.sp0);
        this.sp1          = clone(base.sp1);
        this.sp2          = clone(base.sp2);

        this.scaleCorners = base.scaleCorners;
        this.scaleStyle   = base.scaleStyle;
    }



    copy()
    {
        consoleError('invalid use of abstract method FigmaObject.copy()');
        return null;
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5)
    {
        if (singlePoint)
        {
            cx *= 100;
            cy *= 100;
        }


        const _cx = singlePoint ? this.x + cx : bounds.x + cx * bounds.width;
        const _cy = singlePoint ? this.y + cy : bounds.y + cy * bounds.height;            


        const ds1 = subv(this.sp1, this.sp0);
        const ds2 = subv(this.sp2, this.sp0);

        this.sp0  = point(_cx, _cy);

        this.sp1  = addv(this.sp0, ds1);
        this.sp2  = addv(this.sp0, ds2);
    }



    createDefaultTransform(x, y, a = 0)
    {
        this.xform =
            [[Math.cos(a), -Math.sin(a), x],
             [Math.sin(a),  Math.cos(a), y],
             [0,            0,           1]];
    }



    createDefaultTransformPoints(x, y, w, h)
    {
        this.xp0 = point(x,     y    );
        this.xp1 = point(x + w, y    );
        this.xp2 = point(x,     y + h);

        // this.xp0 = new FigmaPoint(this.nodeId, this.objectId+'.0', this.objectName+' ^ 0', x,     y,     true, false, true);
        // this.xp1 = new FigmaPoint(this.nodeId, this.objectId+'.1', this.objectName+' ^ 1', x + w, y,     true, false, true);
        // this.xp2 = new FigmaPoint(this.nodeId, this.objectId+'.2', this.objectName+' ^ 2', x,     y + h, true, false, true);

        // w = Math.sign(w) * Math.max(0.000001, Math.abs(w));
        // h = Math.sign(h) * Math.max(0.000001, Math.abs(h));

        // this.xp0.createDefaultTransform(x,     y    );
        // this.xp1.createDefaultTransform(x + w, y    );
        // this.xp2.createDefaultTransform(x,     y + h);
    }



    updateTransformPoints()
    {
        // if (this.xp0) this.xp0.nodeId     = this.nodeId;
        // if (this.xp1) this.xp1.nodeId     = this.nodeId;
        // if (this.xp2) this.xp2.nodeId     = this.nodeId;

        // if (this.xp0) this.xp0.objectId   = this.objectId+'.0';
        // if (this.xp1) this.xp1.objectId   = this.objectId+'.1';
        // if (this.xp2) this.xp2.objectId   = this.objectId+'.2';

        // if (this.xp0) this.xp0.objectName = this.objectName+' ^ 0';
        // if (this.xp1) this.xp1.objectName = this.objectName+' ^ 1';
        // if (this.xp2) this.xp2.objectName = this.objectName+' ^ 2';
    }



    createSpaceTransform()
    {
        let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);
        let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);
    
    
        let sx = nozero(vr.x);
        let sy = nozero(vb.y);
    
        let kx = vr.y;
        let ky = vb.x;
        
        let dx = this.sp0.x;
        let dy = this.sp0.y;
    
    
        let xform = mulm3m3(
            createTransform(dx, dy),
            [[sx, ky, 0],
             [kx, sy, 0],
             [0,  0,  1]]);
    

        return xform;
    }
    
    

    getBounds()
    {
        let bounds = Rect.NaN;

        const dp = subv(this.xp1, this.xp0);

        bounds = expandRect_(bounds, this.xp0);
        bounds = expandRect_(bounds, this.xp1);
        bounds = expandRect_(bounds, this.xp2);
        bounds = expandRect_(bounds, addv(this.xp2, dp));

        return bounds;
    }



    applyTransform(xform, affectSpace)
    {
        const space = this.createSpaceTransform();


        if (this.type == POINT)
        {
            const p = transformPoint(point(this.x, this.y), xform, space);

            this.x = p.x;
            this.y = p.y;

            if (affectSpace)
                this.applySpaceTransform(xform, space);
        }
        // else if (this.type == VECTOR_PATH)
        // {
        //     this.updatePoints(xform, space);

        //     if (affectSpace)
        //         this.applySpaceTransform(xform, space);
        // }
        else if (this.type == SHAPE_GROUP)
        {
            for (const obj of this.children)
            {
                obj.applyObjectTransform(xform, space);

                if (affectSpace)
                    obj.applySpaceTransform(xform, space);
            }                
        }
        else
        {
            this.applyObjectTransform(xform, space);

            if (affectSpace)
                this.applySpaceTransform(xform, space);
        }
    }



    applyObjectTransform(xform, space)
    {
        this.updateTransformPoints();

        this.xp0 = transformPoint(this.xp0, xform, space);
        this.xp1 = transformPoint(this.xp1, xform, space);
        this.xp2 = transformPoint(this.xp2, xform, space);

        // const xp0 = transformPoint(this.xp0.toPoint(), xform, space);
        // const xp1 = transformPoint(this.xp1.toPoint(), xform, space);
        // const xp2 = transformPoint(this.xp2.toPoint(), xform, space);

        // this.xp0.x = xp0.x;
        // this.xp0.y = xp0.y;

        // this.xp1.x = xp1.x;
        // this.xp1.y = xp1.y;

        // this.xp2.x = xp2.x;
        // this.xp2.y = xp2.y;
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    toJsonObject()
    {
        return {
            type:       this.type,
            nodeId:     this.nodeId,

            objectId:   this.objectId,
            objectName: this.objectName,
            
            feedback:   this.feedback,

            xp0:        this.xp0 ? this.xp0/*.toPoint()*/ : null,
            xp1:        this.xp1 ? this.xp1/*.toPoint()*/ : null,
            xp2:        this.xp2 ? this.xp2/*.toPoint()*/ : null
        };
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.objectId,
        /* 3 */ this.objectName,
            
        /* 4 */ this.feedback,
        /* 5 */ this.retain,
        
        /* 6 */ this.xp0 ? this.xp0/*.toPoint()*/ : null,
        /* 7 */ this.xp1 ? this.xp1/*.toPoint()*/ : null,
        /* 8 */ this.xp2 ? this.xp2/*.toPoint()*/ : null,

        /* 9 */ 0 // for future use
        ];
    }



    // isValid()
    // {
    //     return true;
    // }
}



function transformPoint(p, xform, space)
{
    p = mulv2m3(p, inversem3(space));
    p = mulv2m3(p, xform);
    p = mulv2m3(p, space);

    return p;
}



function copyFigmaObject(obj)
{
    switch (obj.type)
    {
        case RECTANGLE:   return FigmaRectangle .prototype.copy.call(obj);
        case LINE:        return FigmaLine      .prototype.copy.call(obj);
        case ELLIPSE:     return FigmaEllipse   .prototype.copy.call(obj);
        case TRAPEZE:     return FigmaTrapeze   .prototype.copy.call(obj);
        case POLYGON:     return FigmaPolygon   .prototype.copy.call(obj);
        case STAR:        return FigmaStar      .prototype.copy.call(obj);
        case TEXT_SHAPE:  return FigmaText      .prototype.copy.call(obj);
        case POINT:       return FigmaPoint     .prototype.copy.call(obj);
        case VECTOR_PATH: return FigmaVectorPath.prototype.copy.call(obj);
        case BOOLEAN:     return FigmaBoolean   .prototype.copy.call(obj);
        case SHAPE_GROUP: return FigmaShapeGroup.prototype.copy.call(obj);
        case FRAME:       return FigmaFrame     .prototype.copy.call(obj);
    }

    consoleError('invalid Figma object type \'' + obj.type + '\'');
    return null;
}



function getPointBounds(points)
{
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;

    for (const p of points)
    {
        minX = Math.min(minX, p.x.value);
        minY = Math.min(minY, p.y.value);
        maxX = Math.max(maxX, p.x.value);
        maxY = Math.max(maxY, p.y.value);
    }

    return new AbsRect(minX, minY, maxX, maxY);
}



function getObjBounds(objects)
{
    let bounds = Rect.NaN;

    for (const obj of objects)
        bounds = expandRect(bounds, obj.getBounds());

    return bounds;
}



function addObjectCenter(node, obj, zoom)
{
    const length = 10;
    
    const sp0 = point(
        obj.sp0.x /*+ 0.5*/, 
        obj.sp0.y /*+ 0.5*/);

    const sp1 = addv(sp0, mulvs(      subv(obj.sp1, obj.sp0),      length));
    const sp2 = addv(sp0, mulvs(mulvs(subv(obj.sp2, obj.sp0), -1), length));    

    node.value.objects.push(
        createDecoPoly(
            node, 
            sp0, 
            [sp2, sp0, sp1],
            false,
            '',
            [242, 72, 34], 
            CENTER_SUFFIX));
}



function createDecoPoly(node, center, points, closed, dashes, color, suffix)
{
    const line = new FigmaVectorPath(
        node.nodeId,
        node.nodeId   + suffix,
        node.nodeName + suffix,
        points.map(p => PointValue.fromPoint(node.nodeId, p)),
        closed ? 1 : 0, 
        0, 
        0, 
        0);


    line.strokes.push([
        'SOLID', 
        color[0], 
        color[1], 
        color[2], 
        100, 
        'NORMAL']);

    line.strokeWeight = 1;
    line.strokeAlign  = 'CENTER';
    line.strokeJoin   = 'MITER';
    line.strokeCap    = 'NONE';
    line.strokeDashes = dashes;
    line.isDeco       = true;


    line.createDefaultTransform(center.x, center.y);


    return line;
}



function getValidObjects(value)
{
    return value
        && value.objects
        ? value.objects
              .filter(o => 
                     o.isDeco  === false
                  || o.isXform === true)
              .map(o => o.copy()) 
        : [];
}



// function getValidInputObjects(input)
// {
//     const objects = [];
    

//     if (!input)
//         return objects;

//     // if (LIST_VALUES.includes(input.type))
//     //     for (const item of input.items)
//     //         objects.push(...getValidInputObjects(item));

//     if (   input.value
//         && input.value.objects)
//         objects.push(...input.value.objects
//               .filter(o => 
//                      o.isDeco  === false
//                   || o.isXform === true)
//               .map(o => o.copy()));


//     return objects;
// }


function addColorProp(obj, prop)
{
    const rgb = scaleRgb(prop.toRgb());

    obj.fills.push([
        'SOLID', 
        rgb[0], 
        rgb[1], 
        rgb[2], 
        255   ]);
}



function addFillProp(obj, prop, target = obj.fills)
{
    const rgb = scaleRgb(prop.color.toRgb());

    target.push([
        'SOLID', 
        rgb[0], 
        rgb[1], 
        rgb[2], 
        prop.opacity.toValue().toNumber(),
        BlendModes[prop.blend.value][2]]);
}



function addGradientProp(obj, prop, target = obj.fills)                
{
    const gradient = 
    [
        '', // type
        [], // transform
        []  // stops
    ];


    switch(prop.gradType.value)
    {
        case 0: gradient[0] = 'GRADIENT_LINEAR';  break;
        case 1: gradient[0] = 'GRADIENT_RADIAL';  break;
        case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;
        case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;
    }


    const isLinear = prop.gradType.value == 0;


    let   x   =        prop.x     .toNumber() / 100;
    let   y   =        prop.y     .toNumber() / 100;
    const a   =        prop.angle .toNumber()/360*Tau;
    let   s   = nozero(prop.size  .toNumber() / 100);
    let   asp = nozero(prop.aspect.toNumber() / 100);
    let   sk  =        prop.skew  .toNumber() / 100;


    if (!isLinear)
    {
        x   -= s * Math.cos(a);
        y   -= s * Math.sin(a);

        s   *= 2;

        asp /= 2;
    }

    
    const p0 = point(x, y);
    const p1 = addv(p0, vector(a, s));
    
    const p2 = addv(
        addv(p0, vector(a + Tau/4, s * asp)),
        mulvs(unitv(subv(p1, p0)), distance(p0, p1) * sk));


    const identityHandles = 
        [[0,   1,   0],
         [0.5, 0.5, 1],
         [1,   1,   1]];


    let xform = [
        [p0.x, p1.x, p2.x],
        [p0.y, p1.y, p2.y],
        [1,    1,    1   ]];


    xform = mulm3m3(identityHandles, inversem3(xform));


    gradient[1] = [
        xform[0],
        xform[1] ];
        

    const stops = validateColorStops(prop.stops.items);
    
    setColorStopPositions(stops);


    for (let j = 0; j < stops.length; j++)
    {
        const stop = stops[j];
        const rgba = stop.fill.toRgba();

        gradient[2].push([
            rgba[0], 
            rgba[1], 
            rgba[2], 
            rgba[3],
            stop.position.toNumber() / 100]);
    }


    gradient[3] = BlendModes[prop.blend.value][2];    


    target.push(gradient);
}



function validateColorStops(_stops)
{
    const stops = [];


    for (let i = 0; i < _stops.length; i++)
    {
        const stop = _stops[i];

        if (stop.type == COLOR_VALUE)
        {
            // if (isNaN(stop.toRgb()[0]))
            //     console.log('stop =', stop);
            stops.push(new ColorStopValue(
                FillValue.fromRgb(scaleRgb(stop.toRgb()), 100),
                NumberValue.NaN));
        }

        else if (stop.type == FILL_VALUE)
            stops.push(new ColorStopValue(
                stop,
                NumberValue.NaN));

        else if (stop.type == LIST_VALUE)
            stops.push(...validateColorStops(stop.items));

        else
            stops.push(stop);
    }


    return stops;
}



function setColorStopPositions(stops)
{
    if (    stops.length > 0
        && !stops[0].position.isValid()) 
        stops[0].position = new NumberValue(0);

    if (    stops.length > 1
        && !stops.at(-1).position.isValid()) 
        stops.at(-1).position = new NumberValue(100);
    

    if (stops.length > 2)
    {
        for (let i = 1; i < stops.length-1; i++)
        {
            const stop = stops[i];

            if (!stop.position.isValid())
            {
                let prevValid = i-1;
                let nextValid = i+1;

                while ( prevValid > 0
                    && !stops[prevValid].position.isValid()) 
                    prevValid--;

                while ( nextValid < stops.length-1
                    && !stops[nextValid].position.isValid()) 
                    nextValid++;
                        
                const pv = stops[prevValid].position.toNumber();
                const nv = stops[nextValid].position.toNumber();

               stop.position = new NumberValue((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid)))); 
            }
        }
    }
}



function addStrokeProp(obj, prop)
{
    for (const fill of prop.fills.items)
    {
        if (fill.type ==     FILL_VALUE) addFillProp    (obj, fill, obj.strokes);
        if (fill.type == GRADIENT_VALUE) addGradientProp(obj, fill, obj.strokes);
    }


    obj.strokeWeight = prop.weight.toValue().toNumber();

    switch (prop.fit.toValue().value)
    {
        case 0: obj.strokeAlign = 'INSIDE';  break;
        case 1: obj.strokeAlign = 'CENTER';  break;
        case 2: obj.strokeAlign = 'OUTSIDE'; break;
    }

    switch (prop.join.toValue().value)
    {
        case 0: obj.strokeJoin = 'MITER'; break;
        case 1: obj.strokeJoin = 'BEVEL'; break;
        case 2: obj.strokeJoin = 'ROUND'; break;
    }

    switch (prop.cap.toValue().value)
    {
        case 0: obj.strokeCap = 'NONE';   break;
        case 1: obj.strokeCap = 'SQUARE'; break;
        case 2: obj.strokeCap = 'ROUND';  break;
    }

    obj.strokeDashes     = prop.dashes.toValue().value;
    
    obj.strokeMiterLimit = prop.miter.toValue().value;
}



function addDropShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'DROP_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .toNumber(),
        prop.y     .toNumber(),
        prop.blur  .toNumber(),
        prop.spread.toNumber(),
        BlendModes[prop.blend.value][2],
        prop.behind.value > 0,
        prop.visible ]);
}



function addInnerShadowProp(obj, prop)
{
    const rgba = prop.fill.toRgba();

    obj.effects.push([
        'INNER_SHADOW', 
        rgba[0],
        rgba[1],
        rgba[2],
        rgba[3],
        prop.x     .toNumber(),
        prop.y     .toNumber(),
        prop.blur  .toNumber(),
        prop.spread.toNumber(),
        BlendModes[prop.blend.value][2],
        prop.visible ]);
}



function addLayerBlurProp(obj, prop)
{
    obj.effects.push([
        'LAYER_BLUR', 
        prop.radius.toNumber(),
        prop.visible ]);
}



function addBackBlurProp(obj, prop)
{
    obj.effects.push([
        'BACKGROUND_BLUR', 
        prop.radius.toNumber(),
        prop.visible ]);
}



function addMaskProp(obj)
{
    obj.isMask = true;
}



class FigmaShape
extends FigmaObject
{
    skewX;
    skewY;

    fills   = [];
    strokes = [];

    strokeWeight;
    strokeAlign;
    strokeJoin;
    strokeMiterLimit;
    strokeCap;
    strokeDashes;

    effects = [];

    isDeco;
    isXform;

    isMask  = false;



    constructor(type, nodeId, objectId, objectName, isDeco = false, isXform = false)
    {
        super(type, nodeId, objectId, objectName);

        this.skewX   = 0;
        this.skewY   = 0;

        this.isDeco  = isDeco;
        this.isXform = isXform;
    }



    copyBase(base)
    {
        super.copyBase(base);

        this.skewX            = base.skewX;
        this.skewY            = base.skewY;

        this.fills            = clone(base.fills);
        this.strokes          = clone(base.strokes);

        this.strokeWeight     = base.strokeWeight;
        this.strokeAlign      = base.strokeAlign;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
        this.strokeCap        = base.strokeCap;
        this.strokeDashes     = base.strokeDashes;

        this.effects          = clone(base.effects);

        this.isDeco           = base.isDeco;
        this.isXform          = base.isXform;

        this.isMask           = base.isMask;
    }



    toData()
    {
        const weight = this.strokeWeight * Math.abs(this.scaleStyle);

        const dashes = 
            this.strokeDashes
            ? this.strokeDashes
                .split(',')
                .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))
                .join(',')
            : '';

        
        return [
            ...super.toData(),
   
            /* 10 */ this.fills,
            /* 11 */ this.strokes,

            /* 12 */ weight,
            /* 13 */ this.strokeAlign,
            /* 14 */ this.strokeJoin,
            /* 15 */ this.strokeMiterLimit,
            /* 16 */ this.strokeCap,
            /* 17 */ dashes,

            /* 18 */ this.effects,

            /* 19 */ this.isDeco,

            /* 20 */ this.isMask
        ];
    }
}



class FigmaRectangle
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, round)
    {
        super(RECTANGLE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;

        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaRectangle(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round);


        copy.copyBase(this);

        
        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round * Math.abs(this.scaleCorners)
        ];
    }
}



class FigmaLine
extends FigmaShape
{
    x;
    y;
    width;



    constructor(nodeId, objectId, objectName, x, y, width)
    {
        super(LINE, nodeId, objectId, objectName);
        
        this.x     = x;
        this.y     = y;
        this.width = width;

        
        this.createDefaultSpace(
            x + width/2, 
            y);
    }



    copy()
    {
        const copy = new FigmaLine(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width
        ];
    }
}


class FigmaEllipse
extends FigmaShape
{
    x;
    y;
    width;
    height;

    from;
    to;
    inner;

    

    constructor(nodeId, objectId, objectName, x, y, width, height, from, to, inner)
    {
        super(ELLIPSE, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.from   = from;
        this.to     = to;
        this.inner  = inner;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaEllipse(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.from,
            this.to,
            this.inner);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.from,
            /* 26 */ this.to,
            /* 27 */ this.inner
        ];
    }
}


class FigmaVectorPath
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;
    closed;
    degree;

    pathPoints;

    pathData;
    winding;
    round;



    constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)
    {
        super(VECTOR_PATH, nodeId, objectId, objectName);
        
        this.points  = points.map(p => p.copy());

        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;

        this.round   = round;
        

        this.updatePathPoints();


        let bounds = this.getBounds();

        this.createDefaultSpace(
            bounds.x + bounds.width /2,            
            bounds.y + bounds.height/2            
        );
    }



    copy()
    {
        const copy = new FigmaVectorPath(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points, 

            this.closed, 
            this.degree,
            this.winding,

            this.round);


        copy.x      = this.x;
        copy.y      = this.y;
        copy.width  = this.width;
        copy.height = this.height;


        copy.copyBase(this);


        return copy;
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.points) this.points = base.points.map(p => p.copy());
    }



    getBounds()
    {
        let bounds = Rect.NaN;

        
        switch (this.degree)
        {
            case 0:
                for (const p of this.pathPoints)
                    bounds = expandRect_(bounds, p);

                break;

            case 1:
                for (let i = 0; i < this.pathPoints.length-2; i += 2)
                {
                    bounds = expandRect(
                        bounds, 
                        bounds2(
                            this.pathPoints[i  ], 
                            this.pathPoints[i+1],
                            this.pathPoints[i+2]));
                }
                break;

            case 2:
            case 3:
            case 4:
            case 5:
                for (let i = 0; i < this.pathPoints.length-3; i += 3)
                {
                    bounds = expandRect(
                        bounds, 
                        bounds3(
                            this.pathPoints[i  ], 
                            this.pathPoints[i+1],
                            this.pathPoints[i+2],
                            this.pathPoints[i+3]));
                }
                break;

            default:
                console.error('invalid curve degree');
        }


        return bounds;
    }



    applyObjectTransform(xform, space)
    {
        super.applyObjectTransform(xform, space);
        this.updatePoints(xform, space);
    }



    updatePoints(xform, space)
    {
        for (let i = 0; i < this.points.length; i++)
        {
            let p = this.points[i].toPoint();
            p = transformPoint(p, xform, space);
            this.points[i] = PointValue.fromPoint(this.nodeId, p);
        }
    }



    updatePathPoints()
    {
        switch (this.degree)
        {
        case 0: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 1: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 2: this.pathPoints = this.points.map(p => p.toPoint());                           break;
        case 3: this.pathPoints = getSmoothPoints(this.points, this.closed, getSmoothSegment); break;
        case 4: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineXSegment ); break;
        case 5: this.pathPoints = getSmoothPoints(this.points, this.closed, getSineYSegment ); break;
        }
    }



    updatePathData()
    {
        const bounds = this.getBounds();

        this.x      = bounds.x;
        this.y      = bounds.y;
        this.width  = bounds.width;
        this.height = bounds.height;

        this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);

        this.pathData = getPathDataFromPoints(this.pathPoints, this.closed, this.degree);
    }



    toData()
    {
        this.updatePathPoints();
        this.updatePathData();


        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.pathData,
            /* 26 */ this.winding,
            /* 27 */ this.round * Math.abs(this.scaleCorners)
        ];
    }
}



function getPathDataFromPoints(points, closed, degree)
{
    for (const p of points)
        if (   isNaN(p.x)
            || isNaN(p.y))
            return '';

            
    let pathData = '';


    switch (degree)
    {
    case 0: pathData = getLinearPathData   (points);         break;
    case 1: pathData = getQuadraticPathData(points, closed); break;
    case 2: 
    case 3: 
    case 4: 
    case 5: pathData = getCubicPathData    (points, closed); break;
    }


    const pointsAreValid =
           degree == 0 && points.length > 2
        || degree == 1 && points.length > 2
        || degree == 2 && points.length > 3
        || degree == 3 && points.length > 2
        || degree == 4 && points.length > 2
        || degree == 5 && points.length > 2;


    if (   pointsAreValid
        && (   closed
            || equalv(points[0], points.at(-1))))
        pathData += ' Z';


    return pathData;
}



function getQuadraticPathData(points, closed)
{
    let pathData = '';


    if (points.length < 3)
        return pathData;


    pathData += 'M';
    pathData += ' ' + almostZero(points[0].x);
    pathData += ' ' + almostZero(points[0].y);

    let i;
    for (i = 1; i < points.length-1; i += 2)
    {
        pathData += 
              ' Q'
            + ' ' + almostZero(points[i  ].x)
            + ' ' + almostZero(points[i  ].y)
            + ' ' + almostZero(points[i+1].x)
            + ' ' + almostZero(points[i+1].y);
    }


    if (   points.length - i == 1
        && closed)
    {
        pathData += 
              ' Q'
            + ' ' + almostZero(points.at(-1).x)
            + ' ' + almostZero(points.at(-1).y)
            + ' ' + almostZero(points.at( 0).x)
            + ' ' + almostZero(points.at( 0).y);
    }


    return pathData;
}



function getCubicPathData(points, closed)
{
    let pathData = '';


    if (points.length < 4)
        return pathData;


    pathData += 'M';
    pathData += ' ' + almostZero(points[0].x);
    pathData += ' ' + almostZero(points[0].y);

    let i;
    for (i = 1; i < points.length-2; i += 3)
    {
        pathData += 
              ' C'
            + ' ' + almostZero(points[i  ].x)
            + ' ' + almostZero(points[i  ].y)
            + ' ' + almostZero(points[i+1].x)
            + ' ' + almostZero(points[i+1].y)
            + ' ' + almostZero(points[i+2].x)
            + ' ' + almostZero(points[i+2].y);
    }


    if (points.length - i == 2)
    {
        pathData += 
              ' C'
            + ' ' + almostZero(points.at(-2).x)
            + ' ' + almostZero(points.at(-2).y)
            + ' ' + almostZero(points.at(-1).x)
            + ' ' + almostZero(points.at(-1).y)
            + ' ' + almostZero(points.at( 0).x)
            + ' ' + almostZero(points.at( 0).y);
    }


    return pathData;
}



function getSmoothPoints(points, closed, getSegment)
{
    if (points.length < 2)
        return '';


    const bp = [];


    // first point
    let [pp, p, pn] = getSegment(
        closed ? points.at(-1) : points[0], 
        points[0],
        points[1]);

    bp.push(p);


    let _pp = pn;


    // middle segments
    for (let i = 1; i < points.length; i++)
    {
        [pp, p, pn] = getSegment(
            points[i-1], 
            points[i],
            i == points.length-1 
            ? (closed ? points[0] : points[i])
            : points[i+1]);

        bp.push(_pp, pp, p);

        _pp = pn;
    }


    if (bp.length > 3)
    {
        if (closed)
        {
            if (   equal(bp[0].x, bp.at(-1).x, 0.01)
                && equal(bp[0].y, bp.at(-1).y, 0.01))
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-2), 
                    points.at( 0),
                    points.at( 1));

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
            else
            {
                // last segment
                [pp, p, pn] = getSegment(
                    points.at(-1), 
                    points.at( 0),
                    points.at( 1));

                bp.push(_pp, pp, p);

                bp[1]           = pn;
                bp[bp.length-2] = pp;
            }
        }
        else // open
        {
            bp[1]           = addv(bp[0],     mulvs(unitv(subv(bp[2],     bp[0]    )), distance(bp[3],     bp[0]    )/3));
            bp[bp.length-2] = addv(bp.at(-1), mulvs(unitv(subv(bp.at(-3), bp.at(-1))), distance(bp.at(-4), bp.at(-1))/3));
        }
    }


    return bp;
}



function getSmoothSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);


    const v = subv(_pn, _pp);
    
    
    let a = angleDiff(
        angle(subv(_p, _pp)), 
        angle(subv(_pn, _p)));

    a = Math.abs(a);
    while (a >= Tau/2) a -= Tau;


    const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248; // slight improvement (see Bézier Curves p. 13, Gernot Hoffmann);

    let f =
        a > Tau/4
        ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)
        : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));
    

    const pp = addv(_p, mulvs(unitv(v), -lengthv(v)/2 * f));
    const pn = addv(_p, mulvs(unitv(v),  lengthv(v)/2 * f));
    //console.log('pp =', pp);
    //console.log('pn =', pn);


    return [pp, _p, pn];
}



function getSineXSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);
    const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);

    return [pp, _p, pn];
}



function getSineYSegment(_pointP, _point, _pointN)
{
    const _pp = point(_pointP.x.value, _pointP.y.value);
    const _p  = point(_point .x.value, _point .y.value);
    const _pn = point(_pointN.x.value, _pointN.y.value);

    const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);
    const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);

    return [pp, _p, pn];
}


class FigmaVectorNetwork
extends FigmaShape
{
    x;
    y;
    width;
    height;
    
    points;
    edges;
    regions;

    networkData;



    constructor(nodeId, objectId, objectName, points, edges, regions)
    {
        super(VECTOR_NETWORK, nodeId, objectId, objectName);
        
        this.points  = points .map(p => p.copy());
        this.edges   = edges  .map(e => e.copy());
        this.regions = regions.map(r => r.copy());


        this.updateNetworkData();


        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            bounds = expandRect(
                bounds, 
                bounds3(
                    this.edges[i].start.toPoint(), 
                    this.edges[i].start.toPoint(),
                    this.edges[i].end  .toPoint(),
                    this.edges[i].end  .toPoint()));
        }

        this.createDefaultSpace(
            bounds.x + bounds.width /2,            
            bounds.y + bounds.height/2            
        );
    }



    copy()
    {
        const copy = new FigmaVectorNetwork(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.points, 
            this.edges, 
            this.regions);


        copy.x      = this.x;
        copy.y      = this.y;
        copy.width  = this.width;
        copy.height = this.height;


        copy.copyBase(this);


        return copy;
    }



    updateNetworkData()
    {
        let minX = Number.MAX_SAFE_INTEGER;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;

        for (const p of this.points)
        {
            minX = Math.min(minX, p.x.value);
            minY = Math.min(minY, p.y.value);
            maxX = Math.max(maxX, p.x.value);
            maxY = Math.max(maxY, p.y.value);
        }


        this.x      = minX;
        this.y      = minY;
        this.width  = maxX - minX;
        this.height = maxY - minY;

        this.createDefaultTransformPoints(this.x, this.y, this.width, this.height);


        this.networkData = getNetworkData(this.points, this.edges, this.regions);
    }



    getBounds()
    {
        let bounds = Rect.NaN;

        for (let i = 0; i < this.edges.length; i++)
        {
            bounds = expandRect(
                bounds, 
                bounds3(
                    this.edges[i].start.toPoint(), 
                    this.edges[i].start.toPoint(),
                    this.edges[i].end  .toPoint(),
                    this.edges[i].end  .toPoint()));
        }

        return bounds;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.networkData
        ];
    }
}



function getNetworkData(points, edges, _regions)
{
    const vertices = [];
    const segments = [];
    const regions  = [];


    for (const point of points)
    {
        let join;
        let cap;

        switch (point.join.value)
        {
            case 0: join = 'MITER'; break;
            case 1: join = 'BEVEL'; break;
            case 2: join = 'ROUND'; break;
        }
    
        switch (point.cap.value)
        {
            case 0: cap = 'NONE';   break;
            case 1: cap = 'SQUARE'; break;
            case 2: cap = 'ROUND';  break;
        }
    
        vertices.push(
        {
            x:            point.x.value,
            y:            point.y.value,
            strokeJoin:   join,
            strokeCap:    cap,
            cornerRadius: point.round.value
        });
    }


    for (const edge of edges)
    {
        segments.push(
        {
            start: points.findIndex(p => p.uniqueId == edge.start.uniqueId),
            end:   points.findIndex(p => p.uniqueId == edge.end  .uniqueId)
        });
    }


    for (const region of _regions)
    {
        const loops = [];

        for (const _loop of region.loops.items)
        {
            const loop = [];

            for (const _edge of _loop.items)
                loop.push(edges.findIndex(e => e.uniqueId == _edge.uniqueId));

            loops.push(loop);
        }


        regions.push(
        {
            windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',
            loops:       loops,
            fills:       getObjectFills(region.fills)
        });
    }


    let networkData = 
    {
        vertices: vertices,
        segments: segments,
        regions:  regions
    };


    return networkData;
}


class FigmaTrapeze
extends FigmaVectorPath
{
    width;
    height;

    round;

    bias;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)
    {
        const tw = width * (1 + Math.min(0,  bias/100));
        const bw = width * (1 + Math.min(0, -bias/100));
        
        const tx = x + (width - tw) / 2;
        const bx = x + (width - bw) / 2;

        const points =
        [
            PointValue.create(nodeId, tx,      y         ),
            PointValue.create(nodeId, bx,      y + height),
            PointValue.create(nodeId, bx + bw, y + height),
            PointValue.create(nodeId, tx + tw, y         )
        ];

    
        super(
            nodeId, 
            objectId,
            objectName, 
            points,
            1, // closed
            0, // linear
            0, // even-odd winding
            round);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.bias   = bias;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaTrapeze(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.bias);


        copy.x = this.x;
        copy.y = this.y;


        copy.copyBase(this);

        
        return copy;
    }
}



class FigmaPolygon
extends FigmaShape
{
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)
    {
        super(POLYGON, nodeId, objectId, objectName);
        
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;

        this.round   = round;
        this.corners = corners;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaPolygon(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,
            
            this.round,
            this.corners);


        copy.copyBase(this);


        return copy;
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round * Math.abs(this.scaleCorners),
            /* 26 */ this.corners
        ];
    }
}



class FigmaStar
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    points;
    convex;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)
    {
        super(STAR, nodeId, objectId, objectName);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;

        this.round  = round;
        this.points = points;
        this.convex = convex;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaStar(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.x,
            this.y,
            this.width,
            this.height,

            this.round,
            this.points,
            this.convex);

        copy.copyBase(this);

        return copy;
    }


    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round * Math.abs(this.scaleCorners),
            /* 26 */ this.points,
            /* 27 */ this.convex
        ];
    }
}



class FigmaText
extends FigmaShape
{
    text;
    
    x;
    y;
    width;
    height;
    
    figWidth;
    figHeight;
    
    font;
    size;
    style;
    
    alignH;
    alignV;
    
    lineHeight;
    letterSpacing;



    constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignH, alignV, lineHeight, letterSpacing)
    {
        super(TEXT_SHAPE, nodeId, objectId, objectName);
        
        this.text          = text;
    
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
    
        this.figWidth      = width;
        this.figHeight     = height;
    
        this.font          = font;
        this.size          = size;
        this.style         = style;
    
        this.alignH        = alignH;
        this.alignV        = alignV;
    
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        
        this.createDefaultSpace(
            x + width /2, 
            y + height/2);
    }



    copy()
    {
        const copy = new FigmaText(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.text,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.font,
            this.size,
            this.style,
    
            this.alignH,
            this.alignV,
    
            this.lineHeight,
            this.letterSpacing);


        copy.figWidth  = this.figWidth;
        copy.figHeight = this.figHeight;


        copy.copyBase(this);


        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:             this.x,
            y:             this.y,
            width:         this.width,
            height:        this.height,

            figWidth:      this.figWidth,
            figHeight:     this.figHeight,

            text:          this.text,

            font:          this.font,
            size:          this.size,
            style:         this.style,

            alignH:        this.alignH,
            alignV:        this.alignV,
            
            lineHeight:    this.lineHeight,
            letterSpacing: this.letterSpacing
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,
            
            /* 25 */ this.figWidth,
            /* 26 */ this.figHeight,
            
            /* 27 */ this.text,

            /* 28 */ this.font,
            /* 29 */ this.size,
            /* 30 */ this.style,
            
            /* 31 */ this.alignH,
            /* 32 */ this.alignV,
            
            /* 33 */ this.lineHeight,
            /* 34 */ this.letterSpacing
        ];
    }



    // isValid()
    // {
    //     return super.isValid()

    //         && this.x
    //         && this.y
    //         && this.width
    //         && this.height

    //         && this.figWidth
    //         && this.figHeight

    //         && this.text

    //         && this.font
    //         && this.size
    //         && this.style

    //         && this.alignH
    //         && this.alignV
        
    //         && this.lineHeight
    //         && this.letterSpacing;
    // }
}



class FigmaPoint
extends FigmaShape
{
    x;
    y;
    isCenter;



    constructor(nodeId, objectId, objectName, x, y, isDeco = false, isCenter = false, isXform = false)
    {
        super(POINT, nodeId, objectId, objectName, isDeco, isXform);
        
        this.x        = x;
        this.y        = y;
        this.isCenter = isCenter;

        
        this.createDefaultSpace(x, y);

        this.createDefaultTransform(x, y);
    }



    copy()
    {
        const copy = new FigmaPoint(
            this.nodeId,
            this.objectId,
            this.objectName, 
            this.x,
            this.y,
            this.isDeco,
            this.isCenter);

        copy.copyBase(this);

        return copy;
    }



    getBounds()
    {
        return new Rect(this.x-0.005, this.y-0.005, 0.01, 0.01);
    }



    toPoint()
    {
        return point(this.x, this.y);
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.isCenter
        ];
    }
}



class FigmaBoolean
extends FigmaShape
{
    operation;
    children;



    constructor(nodeId, objectId, objectName, operation, children = [])
    {
        super(BOOLEAN, nodeId, objectId, objectName);
        
        this.operation = operation;
        this.children  = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaBoolean(
            this.nodeId,
            this.objectId,
            this.objectName,
            this.operation,
            this.children);

        copy.copyBase(this);

        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            operation: this.operation,
            children:  this.children
        };
    }
}


class FigmaShapeGroup
extends FigmaShape
{
    children;



    constructor(nodeId, objectId, objectName, children = [])
    {
        super(SHAPE_GROUP, nodeId, objectId, objectName);
        
        this.children = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaShapeGroup(
            this.nodeId,
            this.objectId,
            this.objectName,

            this.children);

        copy.copyBase(this);

        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.children.map(o => o.toData())
        ];
    }
}


class FigmaFrame
extends FigmaShape
{
    x;
    y;
    width;
    height;

    round;
    
    children;



    constructor(nodeId, objectId, objectName, x, y, width, height, round, children = [])
    {
        super(FRAME, nodeId, objectId, objectName);
        
        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
    
        this.round    = round;
    
        this.children = children.map(c => c.copy());
    }



    copy()
    {
        const copy = new FigmaFrame(
            this.nodeId,
            this.objectId,
            this.objectName,
    
            this.x,
            this.y,
            this.width,
            this.height,
    
            this.round,
    
            this.children);


        copy.copyBase(this);


        return copy;
    }



    toJsonObject()
    {
        return {
            ...super.toJsonObject(),
   
            x:        this.x,
            y:        this.y,
            width:    this.width,
            height:   this.height,
        
            round:    this.round,
        
            children: this.children
        };
    }



    toData()
    {
        return [
            ...super.toData(),
   
            /* 21 */ this.x,
            /* 22 */ this.y,
            /* 23 */ this.width,
            /* 24 */ this.height,

            /* 25 */ this.round,

            /* 26 */ this.children.map(o => o.toData())
        ];
    }
}






class FigmaColorStyle
{
    type;
    
    nodeId = '';

    styleId;
    styleName;

    paints = [];

//    existing;



    constructor(nodeId, styleId, styleName)
    {
        this.type      = COLOR_STYLE;
        this.nodeId    = nodeId;

        this.styleId   = styleId;
        this.styleName = styleName;
    }



    copy()
    {
        const copy = new FigmaColorStyle(this.nodeId, this.styleId, this.styleName);

//        copy.existing = this.existing;

        return copy;
    }



    toData()
    {
        return [
        /* 0 */ this.type,
        /* 1 */ this.nodeId,

        /* 2 */ this.styleId,
        /* 3 */ this.styleName,
        
        /* 4 */ this.paints
        ];
    }
}


class GNode
{
    static nextUniqueId = 0;

    type;


    valid; // has been evaluated

    listId        = -1;
    uniqueId;

    cached        = true;
    unknown       = false;

    loopId        = NULL;

    iteration     = 0;
    iterated      = false;


    updateValues  = null;



    constructor(type, options) 
    {
        this.type    = type;

        if (options && options.cached ) this.cached  = options.cached;
        if (options && options.unknown) this.unknown = options.unknown;
     
        this.uniqueId = GNode.nextUniqueId++;
    }



    copy()
    {
        consoleError('abstract type GNode cannot be copied');
        return null;
    }



    copyBase(base)
    {
        this.data     = clone(base.data   );

        this.uniqueId = base.uniqueId;
    }



    toValue()
    {
        return null;
    }



    toString() 
    { 
        return this.type; 
    }



    toJson()
    {
        return this.toString();
    }



    isValid() // is a valid value
    {
        return false;
    }


    
    validate()
    {
        this.valid = true;
    }



    pushValueUpdates(parse)
    {

    }



    invalidateInputs(parse, from)
    {
        if (this.unknown)
            this.valid = false;

        return true;
    }



    initLoop(parse, nodeId)
    {

    }



    invalidateLoop(parse, nodeId)
    {

    }



    iterateLoop(parse)
    {

    }



    resetLoop(parse, nodeId)
    {

    }    
}



class GValue
extends GNode
{
    valueId;

    objects = null;



    constructor(type, options) 
    {
        super(type, options);

        this.valueId = '';
    }



    copy()
    {
        consoleError('abstract class GValue cannot be copied');
        return null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.valueId = base.valueId;

        if (base.objects)
            this.copyObjects(base.objects);
    }



    copyObjects(objects)
    {
        this.objects = objects.map(o => o.copy());
    }



    // eval()
    // {
    //     return this;
    // }



    hasInitValue()
    {
        return false;
    }



    toValue()
    {
        return this.copy();
    }



    toJson() 
    { 
        return this.toString(); 
    }



    toString() 
    { 
        return this.type; 
    }



    toDisplayString()
    {
        return this.toString();
    }



    toJsCode(gen)
    {
        consoleError('invalid abstract method');
        return '';
    }



    getNaN()
    {
        consoleError('invalid abstract method');
        return null;
    }



    isCached()
    {
        return true;
    }
}



function parseValueFromType(type, value)
{
    switch (type)
    {
        case           LIST_VALUE: 
        case    NUMBER_LIST_VALUE: 
        case      TEXT_LIST_VALUE: 
        case     SHAPE_LIST_VALUE: return parseListValue         (value)[0];

        case         NUMBER_VALUE: return parseNumberValue       (value)[0];
        case           TEXT_VALUE: return parseTextValue         (value)[0];
        case          COLOR_VALUE: return parseColorValue        (value)[0];

        case           FILL_VALUE: return parseFillValue         (value)[0];
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0];
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0];
        case         STROKE_VALUE: return parseStrokeValue       (value)[0];
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0];
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0];
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0];
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0];
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0];

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0];
        case           LINE_VALUE: return parseLineValue         (value)[0];
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0];
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0];
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0];
        case           STAR_VALUE: return parseStarValue         (value)[0];
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0];
        case          POINT_VALUE: return parsePointValue        (value)[0];
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0];
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0];
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0];
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0];
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0];
        case        BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0];
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0];
        case          FRAME_VALUE: return parseFrameValue        (value)[0];
        
        default: 
            console.error('unknown type \'' + type + '\'');
            return null;
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case           LIST_VALUE: return parseListValue         (value)[0].toDisplayString();

        case         NUMBER_VALUE: return parseNumberValue       (value)[0].toDisplayString();
        case           TEXT_VALUE: const val = parseTextValue    (value)[0]; return val == '' ? '\'\'' : val.toDisplayString();
        case          COLOR_VALUE: return parseColorValue        (value)[0].toDisplayString();
        case           FILL_VALUE: return parseFillValue         (value)[0].toDisplayString();
        case     COLOR_STOP_VALUE: return parseColorStopValue    (value)[0].toDisplayString();
        case       GRADIENT_VALUE: return parseGradientValue     (value)[0].toDisplayString();
        case         STROKE_VALUE: return parseStrokeValue       (value)[0].toDisplayString();
        case    DROP_SHADOW_VALUE: return parseDropShadowValue   (value)[0].toDisplayString();
        case   INNER_SHADOW_VALUE: return parseInnerShadowValue  (value)[0].toDisplayString();
        case     LAYER_BLUR_VALUE: return parseLayerBlurValue    (value)[0].toDisplayString();
        case      BACK_BLUR_VALUE: return parseBackBlurValue     (value)[0].toDisplayString();
        case     LAYER_MASK_VALUE: return parseLayerMaskValue    (value)[0].toDisplayString();

        case      RECTANGLE_VALUE: return parseRectangleValue    (value)[0].toDisplayString();
        case           LINE_VALUE: return parseLineValue         (value)[0].toDisplayString();
        case        ELLIPSE_VALUE: return parseEllipseValue      (value)[0].toDisplayString();
        case        TRAPEZE_VALUE: return parseTrapezeValue      (value)[0].toDisplayString();
        case        POLYGON_VALUE: return parsePolygonValue      (value)[0].toDisplayString();
        case           STAR_VALUE: return parseStarValue         (value)[0].toDisplayString();
        case     TEXT_SHAPE_VALUE: return parseTextShapeValue    (value)[0].toDisplayString();
        case          POINT_VALUE: return parsePointValue        (value)[0].toDisplayString();
        case    VECTOR_PATH_VALUE: return parseVectorPathValue   (value)[0].toDisplayString();
        case  VECTOR_VERTEX_VALUE: return parseVectorVertexValue (value)[0].toDisplayString();
        case    VECTOR_EDGE_VALUE: return parseVectorEdgeValue   (value)[0].toDisplayString();
        case  VECTOR_REGION_VALUE: return parseVectorRegionValue (value)[0].toDisplayString();
        case VECTOR_NETWORK_VALUE: return parseVectorNetworkValue(value)[0].toDisplayString();
        case        BOOLEAN_VALUE: return parseShapeBooleanValue (value)[0].toDisplayString();
        case    SHAPE_GROUP_VALUE: return parseShapeGroupValue   (value)[0].toDisplayString();
        case          FRAME_VALUE: return parseFrameValue        (value)[0].toDisplayString();
    }


    consoleError('cannot display value of type \'' + type + '\'');
}



function nanFromType(type)
{
    switch (type)
    {
        case            LIST_VALUE: return          ListValue.NaN;

        case          NUMBER_VALUE: return        NumberValue.NaN;
        case            TEXT_VALUE: return        new TextValue();
        case           COLOR_VALUE: return         ColorValue.NaN;
        case            FILL_VALUE: return          FillValue.NaN;
        case      COLOR_STOP_VALUE: return     ColorStopValue.NaN;
        case        GRADIENT_VALUE: return      GradientValue.NaN;
        case          STROKE_VALUE: return        StrokeValue.NaN;
        case     DROP_SHADOW_VALUE: return    DropShadowValue.NaN;
        case    INNER_SHADOW_VALUE: return   InnerShadowValue.NaN;
        case      LAYER_BLUR_VALUE: return     LayerBlurValue.NaN;
        case       BACK_BLUR_VALUE: return      BackBlurValue.NaN;
        case      LAYER_MASK_VALUE: return     LayerMaskValue.NaN;

        case       RECTANGLE_VALUE: return     RectangleValue.NaN;
        case            LINE_VALUE: return          LineValue.NaN;
        case         ELLIPSE_VALUE: return       EllipseValue.NaN;
        case         POLYGON_VALUE: return       PolygonValue.NaN;
        case            STAR_VALUE: return          StarValue.NaN;
        case      TEXT_SHAPE_VALUE: return     TextShapeValue.NaN;
        case           POINT_VALUE: return         PointValue.NaN;
        case     VECTOR_PATH_VALUE: return    VectorPathValue.NaN;
        case   VECTOR_VERTEX_VALUE: return  VectorVertexValue.NaN;
        case     VECTOR_EDGE_VALUE: return    VectorEdgeValue.NaN;
        case   VECTOR_REGION_VALUE: return  VectorRegionValue.NaN;
        case  VECTOR_NETWORK_VALUE: return VectorNetworkValue.NaN;
        case         BOOLEAN_VALUE: return  ShapeBooleanValue.NaN;
        case     SHAPE_GROUP_VALUE: return    ShapeGroupValue.NaN;
        case           FRAME_VALUE: return         FrameValue.NaN;
    }

    consoleError('cannot determine null value from type \'' + type + '\'');
}


class GOperator
extends GNode
{
    nodeId;
    nodeName;

    topLevel;

    value;

    options      = {};

    updateValues = [];

   
    
    constructor(type, nodeId, options)
    {
        super(type, options);

        this.nodeId   = nodeId;
        this.nodeName = options.nodeName;

        this.options  = clone(options);

        this.valid    = false;
        this.topLevel = false;

        this.value    = null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId   = base.nodeId;
        this.nodeName = base.nodeName;

        this.options  = clone(base.options);

        this.valid    = base.valid;
        this.topLevel = base.topLevel;

        if (base.value) 
            this.value = base.value.copy();
    }



    paramFromId(paramId)
    {
        return paramId == 'value'
            ?  this.value
            :  this[paramId];
    }



    isCached()
    {
        return this.options.cached
            && this.valid;
    }



    async eval(parse)
    {
        // calculate and add value update here

        return this;
    }



    async evalObjects(parse)
    {

    }



    copyObjects(value, listId = -1)
    {
        const objects = getValidObjects(value);
        const copies  = [];
                        
        for (let i = 0; i < objects.length; i++)//, o++)
        {
            const obj = copyFigmaObject(objects[i]);
    
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            obj.listId   = listId;
    
            copies.push(obj);
        }

        return copies;
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        //if (this.unknown)
            this.valid = false;

        this.iterated = false;
    }



    initLoop(parse, nodeId)
    {
        this.loopId    = nodeId;
        this.iteration = 0;
    }



    invalidateLoop(parse, nodeId)
    {
        this.valid = false;
    }



    iterateLoop(parse)
    {
        const repeatIndex = parse.repeats.findIndex(r => r.repeatId == this.loopId);
        
        if (   (   repeatIndex < 0
                || repeatIndex == parse.repeats.length-1)
            && !this.iterated)
        {
            this.iteration++;
            this.iterated = true;
        }
    }



    resetLoop(parse, nodeId)
    {
        this.valid     = false;
        this.iteration = 0;
    }    



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    setUpdateValues(parse, values, add = false)
    {
        // if (this.nodeId == 'num')
        // {
        //     console.log('parse.repeats.length =', parse.repeats.length);
        //     console.log('this.unknown =', this.unknown);

        //     if (parse.repeats.length > 0)
        //         console.log('parse.repeats[0].total == 0 =', parse.repeats[0].total == 0);

        //     console.log('parse.repeats.length =', parse.repeats.length);
            
        //     if (parse.repeats.length > 0)
        //         console.log('parse.repeats.at(-1) =', parse.repeats.at(-1));
        // }

        if (    parse.repeats.length == 0
            ||  this.unknown && parse.repeats[0].total == 0
            || !this.unknown
            ||  parse.repeats.at(-1).iteration == parse.repeats.at(-1).total-1)
        {
            // if (this.nodeId == 'num') console.log('1');
            // if (this.nodeId == 'num') console.log('values =', [...values]);
            if (add) this.updateValues.push(...values);
            else     this.updateValues = [...values];
        }
        else if (!add)
        {
            // if (this.nodeId == 'num') console.log('2');
            this.updateValues = [];
        }
    }



    pushValueUpdates(parse)
    {
        if (!this.updateValues)
            return;

        for (const value of this.updateValues)
            genPushUpdateValue(parse, this.nodeId, value[0], value[1]);

        if (this.isValid())
            this.updateValues = [];
    }



    updateValueObjects()
    {
        if (   !this.value
            || !this.value.objects)
            return;


        for (let i = 0; i < this.value.objects.length; i++)
        {
            const obj    = this.value.objects[i];

            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            obj.listId   = -1;
        }
    }
}


class GOperator1
extends GOperator
{
    input = null;



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input) this.input = base.input.copy();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GOperator2
extends GOperator
{
    input0 = null;
    input1 = null;



    copyBase(base)
    {
        super.copyBase(base);

        if (base.input0) this.input0 = base.input0.copy();
        if (base.input1) this.input1 = base.input1.copy();
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    isValid()
    {
        return this.input0 && this.input0.isValid()
            && this.input1 && this.input1.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0) this.input0.pushValueUpdates(parse);
        if (this.input1) this.input1.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input0) this.input0.invalidateInputs(parse, from);
        if (this.input1) this.input1.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0) this.input0.iterateLoop(parse);
        if (this.input1) this.input1.iterateLoop(parse);
    }
}


class GParam
extends GOperator
{
    paramId;
    
    node;
    param;
    


    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    copy()
    {
        const copy = new GParam(this.nodeId, this.paramId);

        copy.copyBase(this);

        copy.node = this.node;
    
        return copy;
    }



    async eval(parse)
    {
        this.node = parse.parsedNodes.find(v => v.nodeId == this.nodeId);
        consoleAssert(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');


        await this.node.eval(parse);


        this.param = this.node.paramFromId(this.paramId);

        if (this.node.type == ITEMS)
            this.param = this.node[this.paramId];

        
        if (isValid(this.param))
        {
            const value = (await this.param.eval(parse)).toValue();
            this.value = value;
            
            return this.value;
        }
        else
            return this.value = NullValue.copy();
    }



    isCached()
    {
        return super.isCached();
//            && this.node.isCached();
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.node) this.node.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.node) this.node.invalidateInputs(parse, from);
    }



    initLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.initLoop(parse, nodeId);
    }



    invalidateLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.invalidateLoop(parse, nodeId);
    }



    iterateLoop(parse)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        const node = parse.parsedNodes.find(n => n.nodeId == this.nodeId);
        node.resetLoop(parse, nodeId);
    }
}


class ListValue
extends GValue
{
    items;

    condensed = false;



    constructor(items = [])
    {
        super(LIST_VALUE);

        if (items)
        {
            this.items = [];

            for (const item of items)
            {
                this.items.push(item.copy());

                if (   this.objects
                    && item.objects)
                    this.objects.push(...item.objects.map(o => o.copy()));
            }
        }
    }



    copy()
    {
        const copy = new ListValue(this.items);

        copy.copyBase(this);

        copy.condensed = this.condensed;

        return copy;
    }



    equals(list)
    {
        if (!list)                                  return false;
        if (!(list instanceof ListValue))           return false;
        if (this.items.length != list.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(list.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        if (!this.items)
            return false;
            
        for (const item of this.items)
            if (!item.hasInitValue())
                return false;

        return true;
    }



    isValid()
    {
        //console.log('invalid =', this.items.find(i => !i.isValid()));
        return  this.items;
        //    && !this.items.find(i => !i.isValid());
    }



    toJson()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toJson();
        }


        return str;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        const nItems = Math.min(this.items.length, 10);


        let str = '';

        for (let i = 0; i < nItems; i++)
        {
            if (i > 0) 
                str += '<br/>';


            const item = this.items[i];

            if (LIST_VALUES.includes(item.type))
                // str += 'list [' + item.items.length + ']';
            {
                for (let j = 0; j < item.items.length; j++)
                {
                    if (j > 0) 
                        str += ', ';
                    
                    str += item.items[j].toPreviewString();
                }
            }
            else
                str += item.toPreviewString();
        }

        if (this.items.length > 10) 
            str += '<br/>. . .';
        
        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    getNaN()
    {
        return ListValue.NaN;
    }



    static NaN = Object.freeze(new ListValue(null));
}



function parseListValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        
    
    const iStart  = i;
    const nInputs = parseInt(str[i++]);
    
    
    const list = new ListValue();


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];

        switch (type)
        {
            case         LIST_VALUE:  
            case  NUMBER_LIST_VALUE:  
            case    TEXT_LIST_VALUE:  
            case   SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }
 
            case       NUMBER_VALUE: { const num     = parseNumberValue      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }
            case         TEXT_VALUE: { const text    = parseTextValue        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }
            case        COLOR_VALUE: { const color   = parseColorValue       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }

            case         FILL_VALUE: { const fill    = parseFillValue        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }
            case   COLOR_STOP_VALUE: { const stop    = parseColorStopValue   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }
            case     GRADIENT_VALUE: { const grad    = parseGradientValue    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }
            case       STROKE_VALUE: { const stroke  = parseStrokeValue      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }
            case  DROP_SHADOW_VALUE: { const shadow  = parseDropShadowValue  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case INNER_SHADOW_VALUE: { const shadow  = parseInnerShadowValue (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }
            case   LAYER_BLUR_VALUE: { const blur    = parseLayerBlurValue   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case    BACK_BLUR_VALUE: { const blur    = parseBackBlurValue    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }
            case   LAYER_MASK_VALUE: { const mask    = parseLayerMaskValue   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }

            case    RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }
            case         LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }
            case      ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }
            case      TRAPEZE_VALUE: { const trapeze = parseTrapezeValue     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }
            case      POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }
            case         STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }
            case   TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }
            case        POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }
            case  VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }
            case      BOOLEAN_VALUE: { const bool    = parseShapeBooleanValue(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }
            case  SHAPE_GROUP_VALUE: { const group   = parseShapeGroupValue  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }
            case        FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        list, 
        i - iStart];
}



function getItemTypes(items, debug)
{
    const types = [];

    for (const item of items)
    {
        if (   item.type ==        LIST_VALUE
            || item.type == NUMBER_LIST_VALUE
            || item.type ==   TEXT_LIST_VALUE
            || item.type ==  SHAPE_LIST_VALUE)
            pushUnique(types, finalListTypeFromItems(item.items, debug));

        else
            pushUnique(types, item.type);
    }

    return types;
}



function finalTypeFromItems(items)
{
    return finalTypeFromTypes(getItemTypes(items));
}



function finalListTypeFromItems(items)
{
    return finalListTypeFromTypes(getItemTypes(items));
}



function finalTypeFromTypes(types)
{
    let _type = NULL;


    for (const type of types)
    {
        if (_type == NULL)
            _type = type;

        else if (_type != type
                 &&  SHAPE_VALUES.includes(_type) 
                 && !SHAPE_VALUES.includes( type))
        { 
            _type = ANY_VALUE;
            break; 
        }
    }


    return _type;
}



function finalListTypeFromTypes(types)
{
    //console.log('types =', types);
    let _type = finalTypeFromTypes(types);
    
         if (  _type == NUMBER_VALUE || _type == NUMBER_LIST_VALUE)  return NUMBER_LIST_VALUE;
    else if (  _type ==   TEXT_VALUE || _type ==   TEXT_LIST_VALUE)  return   TEXT_LIST_VALUE;
    else if (SHAPE_VALUES.includes(_type))                           return  SHAPE_LIST_VALUE;
    else                                                             return        LIST_VALUE;
}


class NumberValue
extends GValue
{
    value;
    initValue;
    decimals;



    constructor(val = Number.NaN, dec = 0)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
            consoleError('NumberValue(value) is ' + typeof val + ', must be a number');


        this.value     = val;
        this.initValue = val;
        this.decimals  = dec;
    }



    static fromString(str)
    {
        return new NumberValue(
            parseFloat(str),
            decCount(str));
    }



    copy()
    {
        const copy = new NumberValue(
            this.value, 
            this.decimals);

        copy.initValue = this.initValue;

        copy.copyBase(this);

        return copy;
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.value == this.initValue;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    toInteger()
    {
        return new NumberValue(Math.round(this.value));
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals);
    }



    toPreviewString()
    {
        return this.isValid()
             ? numToString(this.value, this.decimals)
             : NAN_DISPLAY;
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? subscriptNumber(this.decimals)
                : '');
    }



    toJsCode(gen)
    {
        return this.toPreviewString();
    }



    getNaN()
    {
        return NumberValue.NaN;
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



const NullValue = Object.freeze(NumberValue.NaN);



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
    {
        console.trace();
        consoleError('number value \'' + str + '\' missing \',\'');
    }

    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == NAN_DISPLAY
        ? NumberValue.NaN
        : NumberValue.fromString(str);

    return [num, 1];
}


class TextValue
extends GValue
{
    value;
    initValue;



    constructor(val = '')
    {
        super(TEXT_VALUE);


        if (   val !== null
            && typeof val !== 'string')
        {
            console.trace();
            consoleError('TextValue('+val+') is ' + typeof val + ', must be a string');
        }

        
        this.value        = val;
        this.initValue    = val;

        // this.updateValues = [];
    }



    copy()
    {
        const copy = new TextValue(this.value);

        copy.initValue = this.initValue;
        
        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.value == text.value;
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        this.value == this.initValue;
    }



    isValid()
    {
        return this.value !== null;
    }



    toJson()
    {
        return encodeURIComponent(this.value);
    }



    toString()
    {
        return this.value;
    }



    toPreviewString()
    {
        const lines = this.value.split('\n');

        let str = '';

        for (let i = 0; i < Math.min(lines.length, 10); i++)
        {
            if (i > 0)
                str += '\n';

            str += lines[i];
        }

        if (lines.length > 10)
            str += '\n. . .';
        
        return str;
    }



    toDisplayString()
    {
        return '\'' 
             + this.value.replaceAll('\n', '↵')
             + '\'';
    }



    getNaN()
    {
        return TextValue.NaN;
    }



    static NaN = Object.freeze(new TextValue());
}



function parseTextValue(str)
{
    const text = new TextValue(decodeURIComponent(str));

    return [text, 1];
}


class ColorValue
extends GValue
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        consoleAssert(typeof space == 'number', 'ColorValue.create() space must be a number');
        consoleAssert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        consoleAssert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        consoleAssert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    static fromDataColor(_color, spaceIndex = -1)
    {
        if (spaceIndex < 0)
            spaceIndex = colorSpaceIndex (_color[0]);

        const space  = colorSpace(spaceIndex);
        const factor = colorSpaceFactor(space);

        return ColorValue.create(
            spaceIndex,
            _color[1] * factor[0],
            _color[2] * factor[1],
            _color[3] * factor[2]);
    }



    copy()
    {
        const copy = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.space.hasInitValue()
            && this.c1   .hasInitValue()
            && this.c2   .hasInitValue()
            && this.c3   .hasInitValue();
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    async eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        const space = this.space.copy();

        space.value = Math.round(Math.min(Math.max(0, space.value), ColorSpaces.length-1));

        return makeDataColor(
            space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toPreviewString()
    {
        return      this.space.toPreviewString()
            + ' ' + this.c1   .toPreviewString()
            + ' ' + this.c2   .toPreviewString()
            + ' ' + this.c3   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    toPreviewString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return '#' + rgb2hex(rgb);
    }



    toRgbString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    getNaN()
    {
        return ColorValue.NaN;
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart ];
}


class FillValue
extends GValue
{
    color;
    opacity;
    blend;



    constructor(color   = ColorValue.NaN, 
                opacity = new NumberValue(100),
                blend   = new NumberValue(0))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();
        this.blend   = blend  .copy();

        this.valid   = true;
    }


    
    static create(r, g, b, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    static fromRgb(rgb, opacity, blend = 0)
    {
        consoleAssert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity),
            new NumberValue(blend));
    }



    copy()
    {
        const copy = new FillValue(
            this.color  .copy(),
            this.opacity.copy(),
            this.blend  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(fill)
    {
        return this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity)
            && this.blend  .equals(fill.blend  );
    }



    async eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString()
              + ' ' + this.blend             .toString();
    }



    toPreviewString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toPreviewString()
              + ' ' + new NumberValue(rgb[1]).toPreviewString()
              + ' ' + new NumberValue(rgb[2]).toPreviewString()
              + ' ' + this.opacity           .toPreviewString()
              + ' ' + this.blend             .toPreviewString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString()
              + ' ' + this.blend             .toDisplayString();
    }



    hasInitValue()
    {
        return this.color  .hasInitValue()
            && this.opacity.hasInitValue()
            && this.blend  .hasInitValue();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid()
            && this.blend  .isValid();
    }



    getNaN()
    {
        return FillValue.NaN;
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r  = parseNumberValue(str[i]); i += r [1];
    const g  = parseNumberValue(str[i]); i += g [1];
    const b  = parseNumberValue(str[i]); i += b [1];
    const a  = parseNumberValue(str[i]); i += a [1];
    const bl = parseNumberValue(str[i]); i += bl[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0], bl[0]),
        i - iStart ];
}






// async function evalFillValue(fillValue, parse)
// {
//     await fillValue.eval(parse);

//          if ( FILL_TYPES.includes(fillValue.type)) return fill;
//     else if (COLOR_TYPES.includes(fillValue.type)) return new FillValue(fill, fillValue.data.opacity);

//     else consoleError('fill must have type');
// }


class ColorStopValue
extends GValue
{
    fill;
    position;



    constructor(fill     = FillValue.NaN, 
                position = new NumberValue(1))
    {
        if (fill.type != FILL_VALUE)
            consoleError('fill.type is ' + fill.type + ', must be FILL_VALUE');


        super(COLOR_STOP_VALUE);

        this.fill     = fill    .copy();
        this.position = position.copy();

        this.valid    = true;
    }


    
    copy()
    {
        const copy = new ColorStopValue(
            this.fill    .copy(),
            this.position.copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.fill    .isValid()
            && this.position.isValid();
    }



    equals(stop)
    {
        return stop
            && this.fill    .equals(stop.fill    )
            && this.position.equals(stop.position);
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fill    .toString()
            + ' ' + this.position.toString();
    }



    toPreviewString()
    {
        return      this.fill    .toPreviewString()
            + ' ' + this.position.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fill    .toDisplayString()
            + ' ' + this.position.toDisplayString();
    }



    getNaN()
    {
        return ColorStopValue.NaN;
    }



    static NaN = Object.freeze(new ColorStopValue(
        FillValue  .NaN,
        NumberValue.NaN));
}



function parseColorStopValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ColorStopValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill     = parseFillValue  (str, i); i += fill    [1];
    const position = parseNumberValue(str[i]); i += position[1];


    return [
        new ColorStopValue(fill[0], position[0]),
        i - iStart ];
}


class GradientValue
extends GValue
{
    stops;
    gradType;
    x;
    y;
    size;
    angle;
    aspect;
    skew;
    blend;



    constructor(stops    = new ListValue(),
                gradType = new NumberValue(0),
                x        = new NumberValue(0),
                y        = new NumberValue(0),
                size     = new NumberValue(0),
                angle    = new NumberValue(0),
                aspect   = new NumberValue(0),
                skew     = new NumberValue(0),
                blend    = new NumberValue(0))
    {
        super(GRADIENT_VALUE);

        this.stops    = stops   .copy();
        this.gradType = gradType.copy();
        this.x        = x       .copy();
        this.y        = y       .copy();
        this.size     = size    .copy();
        this.angle    = angle   .copy();
        this.aspect   = aspect  .copy();
        this.skew     = skew    .copy();
        this.blend    = blend   .copy();

        this.valid = true;
    }


    
    copy()
    {
        const copy = new GradientValue(
            this.stops,
            this.gradType,
            this.x,
            this.y,
            this.size,
            this.angle,
            this.aspect,
            this.skew,
            this.blend);

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.stops   .isValid()
            && this.gradType.isValid()
            && this.x       .isValid()
            && this.y       .isValid()
            && this.size    .isValid()
            && this.angle   .isValid()
            && this.aspect  .isValid()
            && this.skew    .isValid()
            && this.blend   .isValid();
    }



    equals(grad)
    {
        return grad
            && this.stops   .equals(grad.stops   )
            && this.gradType.equals(grad.gradType)
            && this.x       .equals(grad.x       )
            && this.y       .equals(grad.y       )
            && this.size    .equals(grad.size    )
            && this.angle   .equals(grad.angle   )
            && this.aspect  .equals(grad.aspect  )
            && this.skew    .equals(grad.skew    )
            && this.blend   .equals(grad.blend   );
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.stops   .toString()
            + ' ' + this.gradType.toString()
            + ' ' + this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.size    .toString()
            + ' ' + this.angle   .toString()
            + ' ' + this.aspect  .toString()
            + ' ' + this.skew    .toString()
            + ' ' + this.blend   .toString();
    }



    toPreviewString()
    {
        return      this.stops   .toPreviewString()
            + ' ' + this.gradType.toPreviewString()
            + ' ' + this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.size    .toPreviewString()
            + ' ' + this.angle   .toPreviewString()
            + ' ' + this.aspect  .toPreviewString()
            + ' ' + this.skew    .toPreviewString()
            + ' ' + this.blend   .toPreviewString();
    }



    toDisplayString()
    {
        return      this.stops   .toDisplayString()
            + ' ' + this.gradType.toDisplayString()
            + ' ' + this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.size    .toDisplayString()
            + ' ' + this.angle   .toDisplayString()
            + ' ' + this.aspect  .toDisplayString()
            + ' ' + this.skew    .toDisplayString()
            + ' ' + this.blend   .toDisplayString();
    }



    getNaN()
    {
        return GradientValue.NaN;
    }



    static NaN = Object.freeze(new GradientValue(
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    // static default = Object.freeze(new StrokeValue(
    //     FillValue.create(0, 0, 0, 100),
    //     new NumberValue(1),
    //     new NumberValue(0),
    //     new NumberValue(0),
    //     new NumberValue(28.96)));
}



function parseGradientValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [GradientValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const stops    = parseListValue  (str, i); i += stops   [1];
    const gradType = parseNumberValue(str[i]); i += gradType[1];
    const x        = parseNumberValue(str[i]); i += x       [1];
    const y        = parseNumberValue(str[i]); i += y       [1];
    const size     = parseNumberValue(str[i]); i += size    [1];
    const angle    = parseNumberValue(str[i]); i += angle   [1];
    const aspect   = parseNumberValue(str[i]); i += aspect  [1];
    const skew     = parseNumberValue(str[i]); i += skew    [1];
    const blend    = parseNumberValue(str[i]); i += blend   [1];


    return [
        new GradientValue(stops[0], gradType[0], x[0], y[0], size[0], angle[0], aspect[0], skew[0], blend[0]),
        i - iStart ];
}


class StrokeValue
extends GValue
{
    fills;
    weight;
    fit;
    join;
    miter;
    cap;
    dashes;



    constructor(fills  = new ListValue(), 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2),
                cap    = new NumberValue(0),
                dashes = new TextValue())
    {
        if (fills.type != LIST_VALUE)
            consoleError('fill.type is ' + fills.type + ', must be LIST_VALUE');


        super(STROKE_VALUE);

        this.fills  = fills .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();
        this.cap    = cap   .copy();
        this.dashes = dashes.copy();

        this.valid  = true;
    }


    
    copy()
    {
        const copy = new StrokeValue(
            this.fills .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy(),
            this.cap   .copy(),
            this.dashes.copy());

        copy.copyBase(this);

        return copy;
    }



    hasInitValue()
    {
        return this.fills .hasInitValue()
            && this.weight.hasInitValue()
            && this.fit   .hasInitValue()
            && this.join  .hasInitValue()
            && this.miter .hasInitValue()
            && this.cap   .hasInitValue()
            && this.dashes.hasInitValue();
    }



    isValid()
    {
        return this.fills .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid()
            && this.cap   .isValid()
            && this.dashes.isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fills .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter )
            && this.cap   .equals(stroke.cap   )
            && this.dashes.equals(stroke.dashes);
    }



    async eval(parse)
    {
        return this;
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fills .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString()
            + ' ' + this.cap   .toString()
            + ' ' + this.dashes.toString();
    }



    toPreviewString()
    {
        return      this.fills .toPreviewString()
            + ' ' + this.weight.toPreviewString()
            + ' ' + this.fit   .toPreviewString()
            + ' ' + this.join  .toPreviewString()
            + ' ' + this.miter .toPreviewString()
            + ' ' + this.cap   .toPreviewString()
            + ' ' + this.dashes.toPreviewString();
    }



    toDisplayString()
    {
        return      this.fills .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString()
            + ' ' + this.cap   .toDisplayString()
            + ' ' + this.dashes.toDisplayString();
    }



    getNaN()
    {
        return StrokeValue.NaN;
    }



    static NaN = Object.freeze(new StrokeValue(
        new ListValue(),
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        new TextValue()));



    static default = Object.freeze(new StrokeValue(
        new ListValue(),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96),
        new NumberValue(0),
        new TextValue()));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fills  = parseListValue  (str, i); i += fills [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];
    const cap    = parseNumberValue(str[i]); i += cap   [1];
    const dashes = parseTextValue  (str[i]); i += dashes[1];

    return [

        new StrokeValue(
            fills [0], 
            weight[0], 
            fit   [0], 
            join  [0], 
            miter [0], 
            cap   [0], 
            dashes[0]),
        
        i - iStart ];
}



class DropShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    behind;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                behind  = new NumberValue(0),
                visible = true)
    {
        super(DROP_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.behind  = behind;
        this.visible = visible;
        
        consoleAssert(fill.type == FILL_VALUE, 'fill.type must be FILL_VALUE');
    }


    
    // static create(x, y, blur, spread, fill, blend, behind)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new DropShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.behind.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.behind.equals(shadow.behind)
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString()
            + ' ' + this.behind.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString()
            + ' ' + this.behind.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString()
            + ' ' + this.behind.toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid()
            && this.behind.isValid();
    }



    getNaN()
    {
        return DropShadowValue.NaN;
    }



    static NaN = Object.freeze(new DropShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        false));


    // static default = Object.freeze(DropShadowValue.create(217, 217, 217, 100));
}



function parseDropShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [DropShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];
    const behind = parseNumberValue(str[i]); i += behind[1];


    const shadow = new DropShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0],
        behind[0]);


    return [shadow, i - iStart];
}



class InnerShadowValue
extends GValue
{
    x;
    y;
    blur;
    spread;
    fill;
    blend;
    visible;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                blur    = new NumberValue(0), 
                spread  = new NumberValue(0), 
                fill    = FillValue.NaN,
                blend   = new NumberValue(0),
                visible = true)
    {
        super(INNER_SHADOW_VALUE);

        this.x       = x;
        this.y       = y;
        this.blur    = blur;
        this.spread  = spread;
        this.fill    = fill;
        this.blend   = blend;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new InnerShadowValue(
            this.x     .copy(),
            this.y     .copy(),
            this.blur  .copy(),
            this.spread.copy(),
            this.fill  .copy(),
            this.blend .copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(shadow)
    {
        return this.x     .equals(shadow.x     )
            && this.y     .equals(shadow.y     )
            && this.blur  .equals(shadow.blur  )
            && this.spread.equals(shadow.spread)
            && this.fill  .equals(shadow.fill  )
            && this.blend .equals(shadow.blend )
            && this.visible === shadow.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.blur  .toString()
            + ' ' + this.spread.toString()
            + ' ' + this.fill  .toString()
            + ' ' + this.blend .toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.blur  .toPreviewString()
            + ' ' + this.spread.toPreviewString()
            + ' ' + this.fill  .toPreviewString()
            + ' ' + this.blend .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.blur  .toDisplayString()
            + ' ' + this.spread.toDisplayString()
            + ' ' + this.fill  .toDisplayString()
            + ' ' + this.blend .toDisplayString();
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.blur  .isValid()
            && this.spread.isValid()
            && this.fill  .isValid()
            && this.blend .isValid();
    }



    getNaN()
    {
        return InnerShadowValue.NaN;
    }



    static NaN = Object.freeze(new InnerShadowValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        FillValue .NaN,
        NumberValue.NaN,
        false));



    // static default = Object.freeze(InnerShadowValue.create(217, 217, 217, 100));
}



function parseInnerShadowValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [InnerShadowValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const blur   = parseNumberValue(str[i]); i += blur  [1];
    const spread = parseNumberValue(str[i]); i += spread[1];
    const fill   = parseFillValue  (str, i); i += fill  [1];
    const blend  = parseNumberValue(str[i]); i += blend [1];


    const shadow = new InnerShadowValue(
        x     [0],
        y     [0],
        blur  [0],
        spread[0],
        fill  [0],
        blend [0]);


    return [shadow, i - iStart];
}



class LayerBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0), 
                visible = true)
    {
        super(LAYER_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new LayerBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return LayerBlurValue.NaN;
    }



    static NaN = Object.freeze(new LayerBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(LayerBlurValue.create(217, 217, 217, 100));
}



function parseLayerBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LayerBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new LayerBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class BackBlurValue
extends GValue
{
    radius;
    visible;



    constructor(radius  = new NumberValue(0),
                visible = true)
    {
        super(BACK_BLUR_VALUE);

        this.radius  = radius;
        this.visible = visible;
    }


    
    // static create(x, y, blur, spread, fill, blend)
    // {
    //     return new FillValue(
    //         new Number,
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new BackBlurValue(
            this.radius.copy(),
            this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(blur)
    {
        return this.radius.equals(blur.radius)
            && this.visible === blur.visible;
    }



    async eval(parse)
    {
        return this;
    }



    // toRgba()
    // {
    //     return [
    //         ...this.color.toRgb(),
    //         this.opacity.value / 100 ];
    // }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        return this.radius.toString();
    }



    toPreviewString()
    {
        return this.radius.toPreviewString();
    }



    toDisplayString()
    {
        return this.radius.toDisplayString();
    }



    isValid()
    {
        return this.radius.isValid();
    }



    getNaN()
    {
        return BackBlurValue.NaN;
    }



    static NaN = Object.freeze(new BackBlurValue(
        NumberValue.NaN,
        false));



    // static default = Object.freeze(BackBlurValue.create(217, 217, 217, 100));
}



function parseBackBlurValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [BackBlurValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const radius = parseNumberValue(str[i]); i += radius[1];


    const shadow = new BackBlurValue(
        radius[0]);


    return [shadow, i - iStart];
}



class LayerMaskValue
extends GValue
{
    visible;



    constructor(visible = true)
    {
        super(LAYER_MASK_VALUE);

        this.visible = visible;
    }


    
    copy()
    {
        const copy = new LayerMaskValue(this.visible);

        copy.copyBase(this);

        return copy;
    }



    equals(mask)
    {
        return this.visible === mask.visible;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return 'mask';
    }



    toPreviewString()
    {
        return 'mask';
    }



    toDisplayString()
    {
        return 'mask';
    }



    isValid()
    {
        return super.isValid();
    }



    getNaN()
    {
        return LayerMaskValue.NaN;
    }



    static NaN = Object.freeze(new LayerMaskValue(false));
}



function parseLayerMaskValue(str)
{
    const mask = 
        str == NAN_DISPLAY
        ? LayerMaskValue.NaN
        : new LayerMaskValue(true);

    return [mask, 1];
}



/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeValue
extends GValue
{
    nodeId;

    props = null;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 

        this.objects = [];
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId  = base.nodeId;

        this.objects = base.objects.map(o => o.copy());

        if (base.props) this.props = base.props.copy();
    }



    hasInitValue()
    {
        return !this.props
            ||  this.props.hasInitValue();
    }



    isValid()
    {
        return !this.props
            ||  this.props.isValid();
    }
}



function parseShapeBaseValue(str, i, obj)
{
    const props = parseListValue(str, i); i += props[1];

    obj.props = props[0];

    return i;
}


class RectangleValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'rectangle';
            // + ' ' + this.x     .toPreviewString()
            // + ' ' + this.y     .toPreviewString()
            // + ' ' + this.width .toPreviewString()
            // + ' ' + this.height.toPreviewString()
            // + ' ' + this.round .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends ShapeValue
{
    x;
    y;
    width;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0))
    {
        super(LINE_VALUE, nodeId);

        this.x     = x;
        this.y     = y;
        this.width = width;
    }



    copy()
    {
        const copy = new LineValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.width.copy())

        copy.copyBase(this);

        return copy;
    }



    equals(line)
    {
        return line
            && this.x    .equals(line.x    )
            && this.y    .equals(line.y    )
            && this.width.equals(line.width);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.width.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.width.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.width.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.width.toDisplayString();
    }



    static NaN = new LineValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LineValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const width = parseNumberValue(str[i]); i += width[1];


    const line = new LineValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        width[0]);


    i = parseShapeBaseValue(str, i, line);

    
    return [line, i - iStart];
}



class EllipseValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    from;
    to;
    inner;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                from   = new NumberValue(0),
                to     = new NumberValue(0),
                inner  = new NumberValue(0))
    {
        super(ELLIPSE_VALUE, nodeId);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.from    = from;
        this.to      = to;
        this.inner   = inner;
    }



    copy()
    {
        const copy = new EllipseValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.from  .copy(),
            this.to    .copy(),
            this.inner .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(ellipse)
    {
        return ellipse
            && this.x     .equals(ellipse.x     )
            && this.y     .equals(ellipse.y     )
            && this.width .equals(ellipse.width )
            && this.height.equals(ellipse.height)
            && this.from  .equals(ellipse.from  )
            && this.to    .equals(ellipse.to    )
            && this.inner .equals(ellipse.inner );
    }



    async eval(parse)
    {
        return this;
    }
    
    
    
    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.from  .hasInitValue()
            && this.to    .hasInitValue()
            && this.inner .hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.from  .isValid()
            && this.to    .isValid()
            && this.inner .isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.from  .toString()
            + ' ' + this.to    .toString()
            + ' ' + this.inner .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return 'ellipse';
            // + ' ' + this.x     .toPreviewString()
            // + ' ' + this.y     .toPreviewString()
            // + ' ' + this.width .toPreviewString()
            // + ' ' + this.height.toPreviewString()
            // + ' ' + this.inner .toPreviewString() + '%'
            // + ' ' + this.from  .toPreviewString() + '°'
            // + ' ' + this.to    .toPreviewString() + '°';
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.from  .toDisplayString()
            + ' ' + this.to    .toDisplayString()
            + ' ' + this.inner .toDisplayString();
    }



    static NaN = new EllipseValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [EllipseValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const from   = parseNumberValue(str[i]); i += from  [1];
    const to     = parseNumberValue(str[i]); i += to    [1];
    const inner  = parseNumberValue(str[i]); i += inner [1];


    const ellipse = new EllipseValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        from  [0],
        to    [0],
        inner [0]);


    i = parseShapeBaseValue(str, i, ellipse);

    
    return [ellipse, i - iStart];
}



class TrapezeValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    bias;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0),
                bias   = new NumberValue(0))
    {
        super(TRAPEZE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
        this.bias   = bias;
    }



    copy()
    {
        const copy = new TrapezeValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy(),
            this.bias  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.round .equals(rect.round )
            && this.bias  .equals(rect.bias  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + this.bias  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.width .toPreviewString()
            + ' ' + this.height.toPreviewString()
            + ' ' + this.round .toPreviewString()
            + ' ' + this.bias  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.bias  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue()
            && this.bias  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid()
            && this.bias  .isValid();
    }


    
    static NaN = new TrapezeValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTrapezeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TrapezeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const bias   = parseNumberValue(str[i]); i += bias  [1];


    const rect = new TrapezeValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        bias  [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class PolygonValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    corners;



    constructor(nodeId,
                x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                width   = new NumberValue(0), 
                height  = new NumberValue(0), 
                round   = new NumberValue(0), 
                corners = new NumberValue(0))
    {
        super(POLYGON_VALUE, nodeId);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new PolygonValue(
            this.nodeId,
            this.x      .copy(), 
            this.y      .copy(), 
            this.width  .copy(), 
            this.height .copy(), 
            this.round  .copy(), 
            this.corners.copy());
    
        copy.copyBase(this);

        return copy;
    }



    equals(poly)
    {
        return poly
            && this.x      .equals(poly.x      )
            && this.y      .equals(poly.y      )
            && this.width  .equals(poly.width  )
            && this.height .equals(poly.height )
            && this.round  .equals(poly.round  )
            && this.corners.equals(poly.corners);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x      .hasInitValue()
            && this.y      .hasInitValue()
            && this.width  .hasInitValue()
            && this.height .hasInitValue()
            && this.round  .hasInitValue()
            && this.corners.hasInitValue();
    }



    isValid()
    {
        return super.isValid()
            && this.x      .isValid()
            && this.y      .isValid()
            && this.width  .isValid()
            && this.height .isValid()
            && this.round  .isValid()
            && this.corners.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x      .toString()
            + ' ' + this.y      .toString()
            + ' ' + this.width  .toString()
            + ' ' + this.height .toString()
            + ' ' + this.round  .toString()
            + ' ' + this.corners.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x      .toPreviewString()
            + ' ' + this.y      .toPreviewString()
            + ' ' + this.width  .toPreviewString()
            + ' ' + this.height .toPreviewString()
            + ' ' + this.round  .toPreviewString()
            + ' ' + this.corners.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x      .toDisplayString()
            + ' ' + this.y      .toDisplayString()
            + ' ' + this.width  .toDisplayString()
            + ' ' + this.height .toDisplayString()
            + ' ' + this.round  .toDisplayString()
            + ' ' + this.corners.toDisplayString();
    }



    static NaN = new PolygonValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PolygonValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x       = parseNumberValue(str[i]); i += x      [1];
    const y       = parseNumberValue(str[i]); i += y      [1];
    const width   = parseNumberValue(str[i]); i += width  [1];
    const height  = parseNumberValue(str[i]); i += height [1];
    const round   = parseNumberValue(str[i]); i += round  [1];
    const corners = parseNumberValue(str[i]); i += corners[1];


    const poly = new PolygonValue(
        '', // set node ID elsewhere
        x      [0],
        y      [0],
        width  [0],
        height [0],
        round  [0],
        corners[0]);


    i = parseShapeBaseValue(str, i, poly);

    
    return [poly, i - iStart];
}



class StarValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    points;
    convex;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                round  = new NumberValue(0), 
                points = new NumberValue(0),
                convex = new NumberValue(0))
    {
        super(STAR_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new StarValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.round .copy(), 
            this.points.copy(),
            this.convex.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(star)
    {
        return star
            && this.x     .equals(star.x     )
            && this.y     .equals(star.y     )
            && this.width .equals(star.width )
            && this.height.equals(star.height)
            && this.round .equals(star.round )
            && this.points.equals(star.points)
            && this.convex.equals(star.convex);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.x     .hasInitValue()
            && this.y     .hasInitValue()
            && this.width .hasInitValue()
            && this.height.hasInitValue()
            && this.round .hasInitValue()
            && this.points.hasInitValue()
            && this.convex.hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.round .isValid()
            && this.points.isValid()
            && this.convex.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.round .toString()
            + ' ' + this.points.toString()
            + ' ' + this.convex.toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.x     .toPreviewString()
            + ' ' + this.y     .toPreviewString()
            + ' ' + this.width .toPreviewString()
            + ' ' + this.height.toPreviewString()
            + ' ' + this.round .toPreviewString()
            + ' ' + this.points.toPreviewString()
            + ' ' + this.convex.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.points.toDisplayString()
            + ' ' + this.convex.toDisplayString();
    }



    static NaN = new StarValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StarValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const points = parseNumberValue(str[i]); i += points[1];
    const convex = parseNumberValue(str[i]); i += convex[1];


    const star = new StarValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        round [0],
        points[0],
        convex[0]);


    i = parseShapeBaseValue(str, i, star);

    
    return [star, i - iStart];
}



class TextShapeValue
extends ShapeValue
{
    text;
    x;
    y;
    width;
    height;
    font;
    style;
    size;
    alignH;
    alignV;
    lineHeight;
    letterSpacing;

    

    constructor(nodeId,
                text          = new TextValue(),
                x             = new NumberValue(0), 
                y             = new NumberValue(0), 
                width         = new NumberValue(0), 
                height        = new NumberValue(0), 
                font          = new NumberValue(0),
                style         = new NumberValue(0),
                size          = new NumberValue(0),
                alignH        = new NumberValue(0),
                alignV        = new NumberValue(0),
                lineHeight    = new NumberValue(0),
                letterSpacing = new NumberValue(0))
    {
        super(TEXT_SHAPE_VALUE, nodeId);

        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignH        = alignH;
        this.alignV        = alignV;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;

        this.objects       = [];
    }



    copy()
    {
        const copy = new TextShapeValue(
            this.nodeId,
            this.text         .copy(),
            this.x            .copy(), 
            this.y            .copy(), 
            this.width        .copy(), 
            this.height       .copy(), 
            this.font         .copy(),
            this.style        .copy(),
            this.size         .copy(),
            this.alignH       .copy(),
            this.alignV       .copy(),
            this.lineHeight   .copy(),
            this.letterSpacing.copy()); 

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.text         .equals(text.text         )
            && this.x            .equals(text.x            )
            && this.y            .equals(text.y            )
            && this.width        .equals(text.width        )
            && this.height       .equals(text.height       )
            && this.font         .equals(text.font         )
            && this.style        .equals(text.style        )
            && this.size         .equals(text.size         )
            && this.alignH       .equals(text.alignH       )
            && this.alignV       .equals(text.alignV       )
            && this.lineHeight   .equals(text.lineHeight   )
            && this.letterSpacing.equals(text.letterSpacing);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.text         .hasInitValue()
            && this.x            .hasInitValue()
            && this.y            .hasInitValue()
            && this.width        .hasInitValue()
            && this.height       .hasInitValue()
            && this.font         .hasInitValue()
            && this.style        .hasInitValue()
            && this.size         .hasInitValue()
            && this.alignH       .hasInitValue()
            && this.alignV       .hasInitValue()
            && this.lineHeight   .hasInitValue()
            && this.letterSpacing.hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignH       .isValid()
            && this.alignV       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.text         .toJson() // otherwise the string can't contain another string
            + ' ' + this.x            .toString()
            + ' ' + this.y            .toString()
            + ' ' + this.width        .toString()
            + ' ' + this.height       .toString()
            + ' ' + this.font         .toString()
            + ' ' + this.style        .toString()
            + ' ' + this.size         .toString()
            + ' ' + this.alignH       .toString()
            + ' ' + this.alignV       .toString()
            + ' ' + this.lineHeight   .toString()
            + ' ' + this.letterSpacing.toString()
            + ' ' + super.toString();
        }



    toPreviewString()
    {
        return      this.text         .toJson() // otherwise the string can't contain another string
            + ' ' + this.x            .toPreviewString()
            + ' ' + this.y            .toPreviewString()
            + ' ' + this.width        .toPreviewString()
            + ' ' + this.height       .toPreviewString()
            + ' ' + this.font         .toPreviewString()
            + ' ' + this.style        .toPreviewString()
            + ' ' + this.size         .toPreviewString()
            + ' ' + this.alignH       .toPreviewString()
            + ' ' + this.alignV       .toPreviewString()
            + ' ' + this.lineHeight   .toPreviewString()
            + ' ' + this.letterSpacing.toPreviewString();
    }



    toDisplayString()
    {
        return      this.text         .toDisplayString()
            + ' ' + this.x            .toDisplayString()
            + ' ' + this.y            .toDisplayString()
            + ' ' + this.width        .toDisplayString()
            + ' ' + this.height       .toDisplayString()
            + ' ' + this.font         .toDisplayString()
            + ' ' + this.style        .toDisplayString()
            + ' ' + this.size         .toDisplayString()
            + ' ' + this.alignH       .toDisplayString()
            + ' ' + this.alignV       .toDisplayString()
            + ' ' + this.lineHeight   .toDisplayString()
            + ' ' + this.letterSpacing.toDisplayString();
    }



    toJson()
    {
        return      this.text         .toJson()
            + ' ' + this.x            .toJson()
            + ' ' + this.y            .toJson()
            + ' ' + this.width        .toJson()
            + ' ' + this.height       .toJson()
            + ' ' + this.font         .toJson()
            + ' ' + this.style        .toJson()
            + ' ' + this.size         .toJson()
            + ' ' + this.alignH       .toJson()
            + ' ' + this.alignV       .toJson()
            + ' ' + this.lineHeight   .toJson()
            + ' ' + this.letterSpacing.toJson();
    }



    static NaN = new TextShapeValue(
        '',
        TextValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTextShapeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TextShapeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const text          = parseTextValue  (str[i]); i += text         [1];
    const x             = parseNumberValue(str[i]); i += x            [1];
    const y             = parseNumberValue(str[i]); i += y            [1];
    const width         = parseNumberValue(str[i]); i += width        [1];
    const height        = parseNumberValue(str[i]); i += height       [1];
    const font          = parseNumberValue(str[i]); i += font         [1];
    const style         = parseNumberValue(str[i]); i += style        [1];
    const size          = parseNumberValue(str[i]); i += size         [1];
    const alignH        = parseNumberValue(str[i]); i += alignH       [1];
    const alignV        = parseNumberValue(str[i]); i += alignV       [1];
    const lineHeight    = parseNumberValue(str[i]); i += lineHeight   [1];
    const letterSpacing = parseNumberValue(str[i]); i += letterSpacing[1];


    const txts = new TextShapeValue(
        '', // set node ID elsewhere
        text         [0],
        x            [0],
        y            [0],
        width        [0],
        height       [0],
        font         [0],
        style        [0],
        size         [0],
        alignH       [0],
        alignV       [0],
        lineHeight   [0],
        letterSpacing[0]);


    i = parseShapeBaseValue(str, i, txts);

    
    return [txts, i - iStart];
}



class PointValue
extends GValue
{
    nodeId;

    x;
    y;

    sp0 = null; //  sp0 ------- sp1 
    sp1 = null; //   |
    sp2 = null; //  sp2



    constructor(nodeId,
                x = new NumberValue(0), 
                y = new NumberValue(0))
    {
        super(POINT_VALUE);

        this.nodeId  = nodeId;

        this.x       = x;
        this.y       = y;

        this.createDefaultSpace();
    }



    copy()
    {
        const copy = new PointValue(
            this.nodeId,
            this.x.copy(), 
            this.y.copy());

        copy.copyBase(this);

        copy.sp0 = clone(this.sp0);
        copy.sp1 = clone(this.sp1);
        copy.sp2 = clone(this.sp2);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x.equals(p.x)
            && this.y.equals(p.y);
    }



    createDefaultSpace(cx = 0, cy = 0)
    {
        this.sp0 = point(cx,   cy  );
        this.sp1 = point(cx+1, cy  );
        this.sp2 = point(cx,   cy+1);
    }



    applySpaceTransform(xform, space)
    {
        this.sp0 = transformPoint(this.sp0, xform, space);
        this.sp1 = transformPoint(this.sp1, xform, space);
        this.sp2 = transformPoint(this.sp2, xform, space);
    }



    static create(nodeId, x, y)
    {
        return new PointValue(
            nodeId,
            new NumberValue(x),
            new NumberValue(y));
    }



    static fromPoint(nodeId, p)
    {
        return new PointValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.x.hasInitValue()
            && this.y.hasInitValue();
    }



    isValid()
    {
        return this.x.isValid()
            && this.y.isValid();
    }



    toString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toString()
              + ' ' + this.y.toString()
            : NAN_DISPLAY;
    }



    toPreviewString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?   '(' + this.x.toPreviewString()
              + ', ' + this.y.toPreviewString()
              + ')'
            : NAN_DISPLAY;
    }



    toDisplayString()
    {
        return this.x.isValid()
            && this.y.isValid()
            ?         this.x.toDisplayString()
              + ' ' + this.y.toDisplayString()
            : NAN_DISPLAY;
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return PointValue.NaN;
    }



    static NaN = Object.freeze(new PointValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parsePointValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PointValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x = parseNumberValue(str[i]); i += x[1];
    const y = parseNumberValue(str[i]); i += y[1];


    const rect = new PointValue(
        '', // set node ID elsewhere
        x[0],
        y[0]);


    return [rect, i - iStart];
}



class VectorPathValue
extends ShapeValue
{
    points;
    closed;
    degree;
    winding;
    round;



    constructor(nodeId,
                points  = new ListValue(), 
                closed  = new NumberValue(0), 
                degree  = new NumberValue(0), 
                winding = new NumberValue(0), 
                round   = new NumberValue(0))
    {
        super(VECTOR_PATH_VALUE, nodeId);

        this.points  = points ?? new ListValue();
        this.closed  = closed;
        this.degree  = degree;
        this.winding = winding;
        this.round   = round;
    }



    copy()
    {
        const copy = new VectorPathValue(
            this.nodeId,
            this.points .copy(), 
            this.closed .copy(), 
            this.degree .copy(), 
            this.winding.copy(), 
            this.round  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.points .equals(rect.points )
            && this.closed .equals(rect.closed )
            && this.degree .equals(rect.degree )
            && this.winding.equals(rect.winding)
            && this.round  .equals(rect.round  );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.points .toString()
            + ' ' + this.closed .toString()
            + ' ' + this.degree .toString()
            + ' ' + this.winding.toString()
            + ' ' + this.round  .toString()
            + ' ' + super.toString();
    }



    toPreviewString()
    {
        return      this.points .toPreviewString()
            + ' ' + this.closed .toPreviewString()
            + ' ' + this.degree .toPreviewString()
            + ' ' + this.winding.toPreviewString()
            + ' ' + this.round  .toPreviewString();
    }



    toDisplayString()
    {
        return      this.points .toDisplayString()
            + ' ' + this.closed .toDisplayString()
            + ' ' + this.degree .toDisplayString()
            + ' ' + this.winding.toDisplayString()
            + ' ' + this.round  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    hasInitValue()
    {
        return super.hasInitValue()
            && this.points .hasInitValue()
            && this.closed .hasInitValue()
            && this.degree .hasInitValue()
            && this.winding.hasInitValue()
            && this.round  .hasInitValue();
    }


    
    isValid()
    {
        return super.isValid()
            && this.points .isValid()
            && this.closed .isValid()
            && this.degree .isValid()
            && this.winding.isValid()
            && this.round  .isValid();
    }


    
    static NaN = new VectorPathValue(
        '',
        ListValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseVectorPathValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorPathValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const points  = parseListValue  (str, i); i += points [1];
    const closed  = parseNumberValue(str[i]); i += closed [1];
    const degree  = parseNumberValue(str[i]); i += degree [1];
    const winding = parseNumberValue(str[i]); i += winding[1];
    const round   = parseNumberValue(str[i]); i += round  [1];

    const path = new VectorPathValue(
        '', // set node ID elsewhere
        points [0],
        closed [0],
        degree [0],
        winding[0],
        round  [0]);


    i = parseShapeBaseValue(str, i, path);

    
    return [path, i - iStart];
}



class VectorVertexValue
extends GValue
{
    nodeId;

    x;
    y;
    join;
    cap;
    round;



    constructor(nodeId,
                x     = new NumberValue(0), 
                y     = new NumberValue(0),
                join  = new NumberValue(0),
                cap   = new NumberValue(0),
                round = new NumberValue(0))
    {
        super(VECTOR_VERTEX_VALUE);

        this.nodeId = nodeId;

        this.x      = x    .copy();
        this.y      = y    .copy();
        this.join   = join .copy();
        this.cap    = cap  .copy();
        this.round  = round.copy();
    }



    copy()
    {
        const copy = new VectorVertexValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.join .copy(), 
            this.cap  .copy(), 
            this.round.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(p)
    {
        return p
            && this.x    .equals(p.x    )
            && this.y    .equals(p.y    )
            && this.join .equals(p.join )
            && this.cap  .equals(p.cap  )
            && this.round.equals(p.round);
    }



    static create(nodeId, x, y)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(x    ),
            new NumberValue(y    ),
            new NumberValue(join ),
            new NumberValue(cap  ),
            new NumberValue(round));
    }



    static fromPoint(nodeId, p)
    {
        return new VectorVertexValue(
            nodeId,
            new NumberValue(p.x),
            new NumberValue(p.y),
            new NumberValue(0),
            new NumberValue(0),
            new NumberValue(0));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.x    .hasInitValue()
            && this.y    .hasInitValue()
            && this.join .hasInitValue()
            && this.cap  .hasInitValue()
            && this.round.hasInitValue();
    }



    isValid()
    {
        return this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    toString()
    {
        return      this.x    .toString()
            + ' ' + this.y    .toString()
            + ' ' + this.join .toString()
            + ' ' + this.cap  .toString()
            + ' ' + this.round.toString();
    }



    toPreviewString()
    {
        return      this.x    .toPreviewString()
            + ' ' + this.y    .toPreviewString()
            + ' ' + this.join .toPreviewString()
            + ' ' + this.cap  .toPreviewString()
            + ' ' + this.round.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x    .toDisplayString()
            + ' ' + this.y    .toDisplayString()
            + ' ' + this.join .toDisplayString()
            + ' ' + this.cap  .toDisplayString()
            + ' ' + this.round.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toPoint()
    {
        return point(
            this.x.value,
            this.y.value);
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorVertexValue.NaN;
    }



    static NaN = Object.freeze(new VectorVertexValue(
        '',
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN, 
        NumberValue.NaN));
}



function parseVectorVertexValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorVertexValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const join  = parseNumberValue(str[i]); i += join [1];
    const cap   = parseNumberValue(str[i]); i += cap  [1];
    const round = parseNumberValue(str[i]); i += round[1];


    const point = new VectorVertexValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        join [0],
        cap  [0],
        round[0]);


    return [point, i - iStart];
}



class VectorEdgeValue
extends GValue
{
    nodeId;

    start;
    end;
    startTangent;
    endTangent;



    constructor(nodeId,
                start, 
                end,
                startTangent = PointValue.create(nodeId, 0, 0),
                endTangent   = PointValue.create(nodeId, 0, 0))
    {
        super(VECTOR_EDGE_VALUE);

        this.nodeId = nodeId;

        this.start        = start       .copy();       
        this.end          = end         .copy();         
        this.startTangent = startTangent.copy();
        this.endTangent   = endTangent  .copy();  
    }



    copy()
    {
        const copy = new VectorEdgeValue(
            this.nodeId,
            this.start       .copy(), 
            this.end         .copy(), 
            this.startTangent.copy(), 
            this.endTangent  .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(edge)
    {
        return edge
            && this.start       .equals(edge.start       )
            && this.end         .equals(edge.end         )
            && this.startTangent.equals(edge.startTangent)
            && this.  endTangent.equals(edge.  endTangent);
    }



    static create(nodeId, start, end, startTangent, endTangent)
    {
        return new VectorEdgeValue(
            nodeId,
            start,
            end,
            PointValue.create(nodeId, startTangent.x, startTangent.y),
            PointValue.create(nodeId,   endTangent.x,   endTangent.y));
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.start       .hasInitValue()
            && this.end         .hasInitValue()
            && this.startTangent.hasInitValue()
            && this.endTangent  .hasInitValue();
    }



    isValid()
    {
        return this.start       .isValid()
            && this.end         .isValid();
            // && this.startTangent.isValid()
            // && this.endTangent  .isValid();
    }



    toString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toPreviewString()
    {
        return      this.start       .toString()
            + ' ' + this.end         .toString()
            + ' ' + this.startTangent.toString()
            + ' ' + this.endTangent  .toString();
    }



    toDisplayString()
    {
        return      this.start       .toDisplayString()
            + ' ' + this.end         .toDisplayString()
            + ' ' + this.startTangent.toDisplayString()
            + ' ' + this.endTangent  .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN;
    }



    static NaN = Object.freeze(new VectorEdgeValue(
        '',
        VectorVertexValue.NaN, 
        VectorVertexValue.NaN, 
        PointValue.NaN, 
        PointValue.NaN));
}



function parseVectorEdgeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorEdgeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const start        = parseVectorVertexValue(str, i); i += start       [1];
    const end          = parseVectorVertexValue(str, i); i += end         [1];
    const startTangent = parsePointValue       (str, i); i += startTangent[1];
    const endTangent   = parsePointValue       (str, i); i +=   endTangent[1];


    const edge = new VectorEdgeValue(
        '', // set node ID elsewhere
        start       [0],
        end         [0],
        startTangent[0],
          endTangent[0]);


    return [edge, i - iStart];
}



class VectorRegionValue
extends ShapeValue
{
    loops;  
    winding;

    fills = [];



    constructor(nodeId,
                loops   = new ListValue(), 
                winding = new NumberValue(0))
    {
        super(VECTOR_REGION_VALUE, nodeId);

        this.loops   = loops;  
        this.winding = winding;
    }



    copy()
    {
        const copy = new VectorRegionValue(
            this.nodeId,
            this.loops  .copy(), 
            this.winding.copy());

        copy.fills = clone(this.fills);
        
        copy.copyBase(this);

        return copy;
    }



    equals(region)
    {
        return region
            && this.loops  .equals(region.loops  )
            && this.winding.equals(region.winding);
    }



    // static create(nodeId, loops, winding, props)
    // {
    //     return new VectorRegionValue(
    //         nodeId,
    //         loops,
    //         new NumberValue(winding));
    // }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.loops  .hasInitValue()
            && this.winding.hasInitValue();
    }



    isValid()
    {
        return this.loops  .isValid()
            && this.winding.isValid();
    }



    toString()
    {
        return      this.loops  .toString()
            + ' ' + this.winding.toString();
    }



    toPreviewString()
    {
        return      this.loops  .toPreviewString()
            + ' ' + this.winding.toPreviewString();
    }



    toDisplayString()
    {
        return      this.loops  .toDisplayString()
            + ' ' + this.winding.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorEdgeValue.NaN;
    }



    static NaN = Object.freeze(new VectorRegionValue(
        '',
        ListValue  .NaN, 
        NumberValue.NaN));
}



function parseVectorRegionValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorRegionValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const loops   = parseListValue  (str, i); i += loops  [1];
    const winding = parseNumberValue(str[i]); i += winding[1];


    const region = new VectorRegionValue(
        '', // set node ID elsewhere
        loops  [0],
        winding[0]);


    i = parseShapeBaseValue(str, i, region);


    return [region, i - iStart];
}



class VectorNetworkValue
extends GValue
{
    nodeId;

    regions;



    constructor(nodeId,
                regions = new ListValue())
    {
        super(VECTOR_NETWORK_VALUE);

        this.nodeId  = nodeId;

        this.regions = regions; 
    }



    copy()
    {
        const copy = new VectorNetworkValue(
            this.nodeId,
            this.regions.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(region)
    {
        return region
            && this.regions.equals(region.regions);
    }



    static create(nodeId, regions)
    {
        return new VectorNetworkValue(
            nodeId,
            regions);
    }



    async eval(parse)
    {
        return this;
    }



    hasInitValue()
    {
        return this.regions.hasInitValue();
    }



    isValid()
    {
        return this.regions.isValid();
    }



    toString()
    {
        return this.regions.toString();
    }



    toPreviewString()
    {
        return this.regions.toPreviewString();
    }



    toDisplayString()
    {
        return this.regions.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    toJsCode(gen)
    {
        return '';//this.toPreviewString();
    }



    getNaN()
    {
        return VectorNetworkValue.NaN;
    }



    static NaN = Object.freeze(new VectorNetworkValue(
        '',
        ListValue.NaN));
}



function parseVectorNetworkValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [VectorNetworkValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const regions = parseListValue(str, i); i += regions[1];


    const net = new VectorNetworkValue(
        '', // set node ID elsewhere
        regions[0]);


    return [net, i - iStart];
}



class ShapeBooleanValue
extends ShapeValue
{
    operation;
    children;



    constructor(nodeId, operation, children)
    {
        super(BOOLEAN_VALUE, nodeId);

        this.operation = operation;
        this.children  = children;

        this.objects = 
            children.objects
            ? children.objects.map(o => o.copy())
            : null;
    }



    copy()
    {
        const copy = new ShapeGroupValue(
            this.nodeId,
            this.operation.copy(),
            this.children .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(bool)
    {
        return bool
            && this.operation.equals(bool.operation)
            && this.children .equals(bool.children );
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.operation.toString()
            + ' ' + this.children .toString();
    }



    toPreviewString()
    {
        return      this.operation.toPreviewString()
            + ' ' + this.children .toPreviewString();
    }



    toDisplayString()
    {
        return      this.operation.toDisplayString()
            + ' ' + this.children .toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.operation.isValid()
            && this.children .isValid();
    }


    
    static NaN = new ShapeBooleanValue(
        '',
        NumberValue.NaN,
        ListValue  .NaN);
}



function parseShapeBooleanValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [ShapeBooleanValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const operation = parseNumberValue(str[i]); i += operation[1];
    const children  = parseListValue  (str, i); i += children [1];

    const bool = new ShapeBooleanValue(
        '', // set node ID elsewhere
        operation[0],
        children [0]);


    i = parseShapeBaseValue(str, i, bool);

    
    return [bool, i - iStart];
}



class ShapeGroupValue
extends GValue
{
    items = [];



    constructor(nodeId, items = [])
    {
        super(SHAPE_GROUP_VALUE, nodeId);

        this.items = items;

        //this.objects = children.objects.map(o => o.copy());
    }



    copy()
    {
        const copy = new ShapeGroupValue(
            this.nodeId,
            this.items.map(i => i.copy()));

        copy.copyBase(this);

        return copy;
    }



    equals(group)
    {
        if (!group)                                  return false;
        if (!(group instanceof ShapeGroupValue))     return false;
        if (this.items.length != group.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(group.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toPreviewString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toPreviewString();
        }


        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return  this.items
            && !this.items.find(i => !i.isValid());
    }


    
    static NaN = new ShapeGroupValue(
        '',
        ListValue.NaN);
}



function parseShapeGroupValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const group = new ShapeGroupValue();
    

    const nInputs = parseInt(str[i++]);


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];
        
        switch (type)
        {
            case         LIST_VALUE:  
            // case  NUMBER_LIST_VALUE:  
            // case    TEXT_LIST_VALUE:  
            case   SHAPE_LIST_VALUE: { const _list   = parseListValue        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }
 
            // case       NUMBER_VALUE: { const num     = parseNumberValue      (str[i]);  i += num    [1];  group.items.push(num    [0]);  break; }
            // case         TEXT_VALUE: { const text    = parseTextValue        (str[i]);  i += text   [1];  group.items.push(text   [0]);  break; }
            // case        COLOR_VALUE: { const color   = parseColorValue       (str, i);  i += color  [1];  group.items.push(color  [0]);  break; }

            // case         FILL_VALUE: { const fill    = parseFillValue        (str, i);  i += fill   [1];  group.items.push(fill   [0]);  break; }
            // case       STROKE_VALUE: { const stroke  = parseStrokeValue      (str, i);  i += stroke [1];  group.items.push(stroke [0]);  break; }
            // case  DROP_SHADOW_VALUE: { const shadow  = parseDropShadowValue  (str, i);  i += shadow [1];  group.items.push(shadow [0]);  break; }
            // case INNER_SHADOW_VALUE: { const shadow  = parseInnerShadowValue (str, i);  i += shadow [1];  group.items.push(shadow [0]);  break; }
            // case   LAYER_BLUR_VALUE: { const blur    = parseLayerBlurValue   (str, i);  i += blur   [1];  group.items.push(blur   [0]);  break; }
            // case    BACK_BLUR_VALUE: { const blur    = parseBackBlurValue    (str, i);  i += blur   [1];  group.items.push(blur   [0]);  break; }
            // case   LAYER_MASK_VALUE: { const mask    = parseLayerMaskValue   (str[i]);  i += mask   [1];  group.items.push(mask   [0]);  break; }

            case    RECTANGLE_VALUE: { const rect    = parseRectangleValue   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }
            case         LINE_VALUE: { const line    = parseLineValue        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }
            case      ELLIPSE_VALUE: { const ellipse = parseEllipseValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case      TRAPEZE_VALUE: { const ellipse = parseTrapezeValue     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }
            case      POLYGON_VALUE: { const poly    = parsePolygonValue     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }
            case         STAR_VALUE: { const star    = parseStarValue        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }
            case   TEXT_SHAPE_VALUE: { const text    = parseTextShapeValue   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }
            case        POINT_VALUE: { const point   = parsePointValue       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }
            case  VECTOR_PATH_VALUE: { const path    = parseVectorPathValue  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case      BOOLEAN_VALUE: { const path    = parseShapeBooleanValue(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }
            case  SHAPE_GROUP_VALUE: { const _group  = parseShapeGroupValue  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }
            case        FRAME_VALUE: { const frame   = parseFrameValue       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }
        }
    }

    
    return [
        group, 
        i - iStart];
}



class FrameValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    round;
    children;



    constructor(nodeId, x, y, width, height, round, children)
    {
        super(FRAME_VALUE, nodeId);

        this.x        = x;
        this.y        = y;
        this.width    = width;
        this.height   = height;
        this.round    = round;
        this.children = children;

        this.objects = 
               children
            && children.objects 
            ? children.objects.map(o => o.copy()) 
            : [];
    }



    copy()
    {
        const copy = new FrameValue(
            this.nodeId,
            this.x       .copy(),
            this.y       .copy(),
            this.width   .copy(),
            this.height  .copy(),
            this.round   .copy(),
            this.children.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(frame)
    {
        return frame
            && this.x       .equals(frame.x       )
            && this.y       .equals(frame.y       )
            && this.width   .equals(frame.width   )
            && this.height  .equals(frame.height  )
            && this.round   .equals(frame.round   )
            && this.children.equals(frame.children);
    }



    async eval(parse)
    {
        return this;
    }



    toString()
    {
        return      this.x       .toString()
            + ' ' + this.y       .toString()
            + ' ' + this.width   .toString()
            + ' ' + this.height  .toString()
            + ' ' + this.round   .toString()
            + ' ' + this.children.toString();
    }



    toPreviewString()
    {
        return      this.x       .toPreviewString()
            + ' ' + this.y       .toPreviewString()
            + ' ' + this.width   .toPreviewString()
            + ' ' + this.height  .toPreviewString()
            + ' ' + this.round   .toPreviewString()
            + ' ' + this.children.toPreviewString();
    }



    toDisplayString()
    {
        return      this.x       .toDisplayString()
            + ' ' + this.y       .toDisplayString()
            + ' ' + this.width   .toDisplayString()
            + ' ' + this.height  .toDisplayString()
            + ' ' + this.round   .toDisplayString()
            + ' ' + this.children.toDisplayString();
    }



    toValue()
    {
        return this.copy();
    }



    isValid()
    {
        return this.x       .isValid()
            && this.y       .isValid()
            && this.width   .isValid()
            && this.height  .isValid()
            && this.round   .isValid()
            && this.children.isValid()
            && super.isValid();
    }


    
    static NaN = new FrameValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        ListValue  .NaN);
}



function parseFrameValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [FrameValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x        = parseNumberValue(str[i]); i += x      [1];
    const y        = parseNumberValue(str[i]); i += y      [1];
    const width    = parseNumberValue(str[i]); i += width  [1];
    const height   = parseNumberValue(str[i]); i += height [1];
    const round    = parseNumberValue(str[i]); i += round  [1];
    const children = parseListValue  (str, i); i += children[1];

    const frame = new FrameValue(
        '', // set node ID elsewhere
        x       [0],
        y       [0],
        width   [0],
        height  [0],
        round   [0],
        children[0]);


    i = parseShapeBaseValue(str, i, frame);

    
    return [frame, i - iStart];
}



class GStart
extends GOperator
{
    input    = null;

    feedback = null;
    from     = null;

    loopId   = NULL;

    

    constructor(nodeId, options)
    {
        super(START, nodeId, options);
    }


    
    copy()
    {
        const copy = new GStart(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value   ) copy.value    = this.value   .copy();
        if (this.input   ) copy.input    = this.input   .copy();
        if (this.feedback) copy.feedback = this.feedback.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const feedback = this.feedback ? (await this.feedback.eval(parse)).toValue() : null;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;


        this.setUpdateValues(parse, 
        [
            ['feedback', feedback]
        ]);


        await this.evalObjects(parse, {feedback: feedback.value > 0});

        
        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);


        this.updateObjects(
               this.from
            && repeat
            && repeat.iteration > 0
            && options.feedback
            ? this.from.iterationObjects 
            : (   this.input 
               && this.input.value.objects 
               ? this.input.value.objects 
               : []),
            repeat 
            ? repeat.iteration.toString()
            : '');

        this.from = null;

        
        await super.evalObjects(parse);
    }



    updateObjects(objects, iteration)
    {
        if (!this.value.isValid())
            return;
            
        this.value.objects = objects.map(o => o.copy());

        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        }
    }
    

    
    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input    && this.input   .isValid()
            && this.feedback && this.feedback.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input   ) this.input   .pushValueUpdates(parse);
        if (this.feedback) this.feedback.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.from = from;

        if (this.input   ) this.input   .invalidateInputs(parse, from);
        if (this.feedback) this.feedback.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input   ) this.input   .iterateLoop(parse);
        if (this.feedback) this.feedback.iterateLoop(parse);
    }
}



class GRepeat
extends GOperator1
{
    count = null;
   _while = null;
    loop  = null;

    iterationObjects = [];



    constructor(nodeId, options)
    {
        super(REPEAT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRepeat(this.nodeId, this.options);

        copy.copyBase(this);

        copy. value = this. value.copy();
        copy. count = this. count.copy();
        copy._while = this._while.copy();
        copy. loop  = this. loop .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        let   count = (await this.count.eval(parse)).toValue();
        let  _while = new NumberValue(1);
        const loop  = (await this.loop.eval(parse)).toValue();


        count = 
            count
            ? new NumberValue(Math.round(count.value))
            : new NumberValue(0);


        if (this.loop.type != NUMBER_VALUE) assertVolatile(this.loop, this);


        this.value = new ListValue();
        this.value.objects = [];


        if (count.value > 0)
        {
            if (this.input)
                //&& this.input.isValid())
            {
                const startTime    = Date.now();
                let   showProgress = false;


                const nRepeats = 
                       this.options.enabled 
                    && (   this.options.active
                        || this.options.beforeActive)
                    ? count.value 
                    : 0;
                

                let repeat =
                {
                    repeatId:  this.nodeId,
                    iteration: 0,
                    total:     nRepeats
                };

                    
                parse.repeats.push(repeat);

                if (parse.repeats.length == 1)
                    parse.totalProgress += nRepeats;


                if (this.loop.type != NUMBER_VALUE) 
                    this.loop.initLoop(parse, this.nodeId);


                for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)
                {
                    //console.log('repeat');
                    _while = (await this._while.eval(parse)).toValue();

                    if (_while.value == 0)
                        break;


                    if (  !showProgress
                        && Date.now() - startTime > 50)
                    {
                        genInitNodeProgress(this.nodeId);
                        showProgress = true;
                    }


                    repeat.iteration = i;

                    this.input.invalidateInputs(parse, this);
                    

                    const input = (await this.input.eval(parse)).toValue();


                    if (   input
                        && nRepeats > 0)
                    {
                        this.value.items.push(input.copy());


                        this.iterationObjects = [];
                    
                        if (this.input.value.objects)
                        {
                            for (let j = 0; j < this.input.value.objects.length; j++, o++)
                            {
                                const obj = copyFigmaObject(this.input.value.objects[j]);

                                this.iterationObjects.push(obj.copy());

                                obj.nodeId      = this.nodeId;
                                obj.listId      = i;

                                obj.objectId    = obj.objectId + OBJECT_SEPARATOR + this.nodeId + ':' + (o+1).toString();
                                obj.objectName += ' ' + (o+1).toString();

                                if (this.value.objects)
                                    this.value.objects.push(obj);
                            }
                        }
                    }


                    this.input.iterateLoop(parse);


                    if (parse.repeats.length == 1)
                    {
                        parse.currentProgress++;
                        
                        const stopRequestId = await genGetValueFromUi('stopRequestId');

                        if (   parse.requestId == stopRequestId.value
                            || curRequestIds.includes(parse.requestId)) 
                        { 
                            parse.stopGenerate = true;
                            break; 
                        }
                    }


                    if (showProgress)
                        genUpdateNodeProgress(parse, this.nodeId, i / nRepeats);
                }


                if (this.loop.type != NUMBER_VALUE)
                    this.loop.resetLoop(parse, this.nodeId);


                if (this.startTimer > -1)
                {
                    clearTimeout(this.startTimer);
                    this.startTimer = -1;
                }


                genEndNodeProgress(this.nodeId);


                consoleAssert(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');
                parse.repeats.pop();
            }
            else if (this.input)
                await this.input.eval(parse);
        }
        else
        {
            if (this.input)
                await this.input.eval(parse);
        }


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type',  type ],
            ['count', count]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this. count && this. count.isValid()
            && this._while && this._while.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this. count) this. count.pushValueUpdates(parse);
        if (this._while) this._while.pushValueUpdates(parse);
        if (this. loop ) this. loop .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this. count) this. count.invalidateInputs(parse, from);
        if (this._while) this._while.invalidateInputs(parse, from);
        if (this. loop ) this. loop .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this. count) this. count.iterateLoop(parse);
        if (this._while) this._while.iterateLoop(parse);
        if (this. loop ) this. loop .iterateLoop(parse);
    }
}



function assertVolatile(loop, node)
{
    consoleAssert(
           loop.type == DEFINE
        || loop.type == FREEZE
        || loop.type == NUMBER_RANGE
        || loop.type == NUMBER_SEQUENCE
        || loop.type == NUMBER_RANDOM
        || loop.type == NUMBER_NOISE
        || loop.type == NUMBER_PROBABILITY
        || loop.type == LIST
        || loop.type == PARAM, // for OpStart
        'only volatile types can be repeated');
}


class GNull
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(NULL_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNull(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.input) copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}



class GCache
extends GOperator1
{
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(CACHE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCache(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.cachedValue)
            this.value = this.cachedValue.copy();

        else
        {
            this.value = 
                this.input 
                ? (await this.input.eval(parse)).toValue() 
                : NullValue;

            this.cachedValue = this.value.copy();
        }


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.cachedValue = null;
    }



    // iterateLoop(parse)
    // {
    //     super.iterateLoop(parse);

    //     this.cachedValue = null;
    // }
}



class GFreeze
extends GOperator1
{
    frozen = false;

    loopId  = NULL;



    constructor(nodeId, options)
    {
        super(FREEZE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GFreeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const repeat = parse.repeats.find(r => r.repeatId == this.loopId);

        if (      repeat
               && repeat.iteration == 0
            || !this.options.enabled)
            this.frozen = false;


        if (!this.frozen)
        {
            this.value = 
                this.input 
                ? (await this.input.eval(parse)).toValue()
                : NullValue;

            this.frozen = true;

            this.updateValueObjects();
        }


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type],
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}



class GTimer
extends GOperator
{
    input = null;

    delay = null;



    constructor(nodeId, options)
    {
        super(TIMER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTimer(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.delay) copy.delay = this.delay.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const delay = (await this.delay.eval(parse)).toValue();
            

        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            this.value = input ? input : NullValue;
        }
        else
            this.value = NullValue.copy();
            

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['delay', delay     ]
        ]);

        
        this.updateValueObjects();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.delay && this.delay.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.delay) this.delay.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.delay) this.delay.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.delay) this.delay.iterateLoop(parse);
    }
}



class GValueName
extends GOperator
{
    input = null;

    name  = null;



    constructor(nodeId, options)
    {
        super(VALUE_NAME, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNull(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.input) copy.input = this.input.copy();
        if (this.name ) copy.name  = this.name .copy();

        return copy;
    }



    async eval(parse)
    {
        // if (this.isCached())
        //     return this;


        this.value = 
            this.input 
            ? (await this.input.eval(parse)).toValue() 
            : NullValue;

        
        const name = (await this.name.eval(parse)).toValue();

        if (this.value.isValid())
            this.value.valueId = name.value;


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['type', type],
            ['name', name]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.name  && this.name .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.name ) this.name .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.name ) this.name .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.name ) this.name .iterateLoop(parse);
    }
}



class GList
extends GOperator
{
    inputs = [];

    value;



    constructor(nodeId, options)
    {
        super(LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GList(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());
        copy.value  = this.value.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        this.value.objects = [];


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);
            
            
            // first copy the input objects
            // to display when list is the active node

            // if (   this.options.enabled
            //     && this.inputs[i].value)
            // {
            //     const objects = getValidObjects(this.inputs[i].value);
                
            //     for (let j = 0; j < objects.length; j++, o++)
            //     {
            //         const obj = objects[j];//copyFigmaObject(objects[j]);

            //         obj.nodeId   = this.nodeId;
            //         obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            //         obj.listId   = i;

            //         //this.value.objects.push(obj);
            //     }
            // }


            // now create the output value

            const input = this.inputs[i].toValue();


            if (   input
                && this.options.enabled)
            {
                if (LIST_VALUES.includes(input.type))
                {
                    if (input.condensed === true)
                        this.value.items.push(input.copy());
                    else
                    {
                        for (const item of input.items)
                            this.value.items.push(item.copy());   
                    }
                }
                else
                    this.value.items.push(input.copy());
            }


            this.value.objects.push(...this.copyObjects(input, i));
        }


        // reset object space

        const bounds = getObjBounds(this.value.objects);

        const singlePoint =
               this.value.objects.length  == 1 
            && this.value.objects[0].type == POINT;


        for (const obj of this.value.objects)
        {
            obj.createDefaultSpace(obj.sp0.x, obj.sp0.y);
            obj.resetSpace(bounds, singlePoint);
        }


        const preview = new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)));
        const length  = new NumberValue(this.value.items.length);
        const type    = new TextValue(finalListTypeFromItems(this.value.items));

        
        this.setUpdateValues(parse,
        [
            ['preview', preview],
            ['length',  length ],
            ['type',    type   ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    initLoop(parse, loopId)
    {
        this.inputs.forEach(i => i.initLoop(parse, loopId));
    }



    invalidateLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.invalidateLoop(parse, nodeId));
    }



    iterateLoop(parse)
    {
        this.inputs.forEach(i => i.iterateLoop(parse));
    }



    resetLoop(parse, nodeId)
    {
        this.inputs.forEach(i => i.resetLoop(parse, nodeId));
    }
}


class GCondense
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(CONDENSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondense(this.nodeId, this.options);

        copy.copyBase(this);

        //copy.value  = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();
        this.value.condensed = true;

        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            length = input.items.length;
               
                
            if (input)
            {
                if (   LIST_VALUES.includes(input.type)
                    && this.options.enabled)
                {
                    for (const item of input.items)
                    {
                        const copy = item.copy();

                        this.value.items.push(copy);
                        //this.value.objects.push(...copy.objects);
                    }
                }
                else
                {
                    const copy = input.copy();

                    this.value.items.push(copy);
                    this.value.objects.push(...copy.objects);
                }
            }
        }


        this.updateValueObjects();
    

        this.setUpdateValues(parse,
        [
            ['length', new NumberValue(length)                              ],
            ['type', new TextValue(finalListTypeFromItems(this.value.items))]
        ]);
        

        this.validate();

        return this;
    }
}



class GSublist
extends GOperator1
{
    start;
    end;


    
    constructor(nodeId, options)
    {
        super(SUBLIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSublist(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start) copy.start = this.start.copy();
        if (this.end  ) copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = this.start ? (await this.start.eval(parse)).toValue() : null;
        const end   = this.end   ? (await this.end  .eval(parse)).toValue() : null;


        this.value = new ListValue();

        let length = 0;
        

        if (   this.input
            && start
            && end)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (   input
                && input.items)
            {
                length = input.items.length;


                const _end =
                    end.isValid()
                    ? end
                    : new NumberValue(input.items.length);


                if (start.value < _end.value)
                {
                    if (this.options.enabled)
                    {
                        for (let i = start.value; i < _end.value; i++)
                        {
                            const item = input.items[i];
                            
                            this.value.items.push(item ? item.copy() : NullValue);
                            
                            if (   item
                                && this.value.objects) 
                                this.value.objects.push(...input.items[i].objects);
                        }
                    }
                    else
                        this.value = input.copy();
                }
            }
            else
                this.value = ListValue.NaN.copy();
        }


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview',    new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['type',       type                                                                           ],
            ['length',     new NumberValue(this.value.items.length)                                                        ], // used to set start and end maxima
            ['fullLength', new NumberValue(length)                                                        ], // used to set start and end maxima
            ['start',      start                                                                          ],
            ['end',        end                                                                            ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.end  ) this.end  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GUnique
extends GOperator1
{
    counts = null;


    
    constructor(nodeId, options)
    {
        super(UNIQUE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GUnique(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = this.input ? (await this.input.eval(parse)).toValue() : null;


        this.counts = new ListValue();


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();

                for (let i = 0; i < input.items.length; i++)
                {
                    const item       = input.items[i];
                    const foundIndex = this.value.items.findIndex(i => i.equals(item));

                    if (foundIndex < 0)
                    {
                        this.value.items.push(item.copy());
                        this.value.objects.push(...item.objects);

                        this.counts.items.push(new NumberValue(1));
                    }
                    else
                        this.counts.items[foundIndex].value++;
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = new ListValue();//TextValue.NaN;


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)))],
            ['type',    type                                                                           ],
            ['length',  new NumberValue(this.value.items.length)                                       ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.counts && this.counts.isValid();
    }
}



class GReverseList
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(REVERSE_LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GReverseList(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input = this.input ? (await this.input.eval(parse)).toValue() : null;


        this.counts = new ListValue();


        if (input)
        {
            if (this.options.enabled)
            {
                this.value = new ListValue();

                for (let i = input.items.length-1; i >= 0; i--)
                {
                    this.value.items.push(input.items[i].copy());
                    this.value.objects.push(...input.items[i].objects);
                }
            }
            else
                this.value = input.copy();
        }
        else
            this.value = ListValue.NaN.copy();


        this.updateValueObjects();


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;

        this.setUpdateValues(parse, 
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 10)))],
            ['type',    type                                                                           ],
            ['length', new NumberValue(this.value.items.length)                                        ]
        ]); 
               

        this.validate();

        return this;
    }
}



class GSort
extends GOperator1
{
    column  = null;
    reverse = null;


    
    constructor(nodeId, options)
    {
        super(SORT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSort(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.column ) copy.column  = this.column .copy();
        if (this.reverse) copy.reverse = this.reverse.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const column  = this.column  ? (await this.column .eval(parse)).toValue() : null;
        const reverse = this.reverse ? (await this.reverse.eval(parse)).toValue() : null;

        
        this.value = new ListValue();

        let maxColumns = 0;

        
        if (   this.input
            && column
            && reverse)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            const sortMultiplier = reverse.value > 0 ? -1 : 1;

            input.items.sort((a, b) => 
            {
                const ca = a ? (LIST_VALUES.includes(a.type) ? a.items[column.value].value : a.value) : 0;
                const cb = b ? (LIST_VALUES.includes(b.type) ? b.items[column.value].value : b.value) : 0;

                if (ca < cb) return -1 * sortMultiplier;
                if (ca > cb) return  1 * sortMultiplier;

                return 0;
            });


            input.items.forEach(i => maxColumns = Math.max(maxColumns, LIST_VALUES.includes(i.type) ? i.items.length : 1));

            for (let i = 0; i < input.items.length; i++)
            {
                const row = input.items[i];
                this.value.items.push(row.copy());

                if (   row.objects
                    && this.value.objects)
                    this.value.objects.push(...row.objects);
            }
        }


        const preview = new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)));

        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', preview                                 ],
            ['type',    type                                    ],
            ['length',  new NumberValue(this.value.items.length)],
            ['columns', new NumberValue(maxColumns)             ],
            ['column',  column                                  ],
            ['reverse', reverse                                 ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.column  && this.column .isValid()
            && this.reverse && this.reverse.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.column ) this.column .pushValueUpdates(parse);
        if (this.reverse) this.reverse.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.column ) this.column .invalidateInputs(parse, from);
        if (this.reverse) this.reverse.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.column ) this.column .iterateLoop(parse);
        if (this.reverse) this.reverse.iterateLoop(parse);
    }
}


class GColumn
extends GOperator1
{
    index;


    
    constructor(nodeId, options)
    {
        super(COLUMN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColumn(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.index) copy.index = this.index.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const index = (await this.index.eval(parse)).toValue();

        
        this.value = new ListValue();

        let maxColumns = 0;


        if (   this.input
            && index)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (isTable(input))
            {
                input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));

                if (index.value < maxColumns)
                {
                    for (let i = 0; i < input.items.length; i++)
                    {
                        const row = input.items[i];

                        if (index.value < row.items.length)
                        {
                            this.value.items.push(row.items[index.value].copy());

                            if (   this.value.objects 
                                && row.items[index.value].objects)
                                this.value.objects.push(...row.items[index.value].objects);
                        }
                    }
                }
            }
            else if (LIST_VALUES.includes(input.type))
                this.value = input.copy();
        }


        const type = 
            this.value
            ? new TextValue(finalListTypeFromItems(this.value.items))
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['type',    type                                                                           ],
            ['length',  new NumberValue(this.value.items.length)                                       ],
            ['columns', new NumberValue(maxColumns)                                                    ],
            ['index',   index                                                                          ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.index) this.index.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.index) this.index.iterateLoop(parse);
    }
}



function isTable(value)
{
    if (!LIST_VALUES.includes(value.type))
        return false;

    for (const item of value.items)
    {
        if (!LIST_VALUES.includes(item.type))
            return false;
    }

    return true;
}


class GCell
extends GOperator
{
    column;
    row;


    
    constructor(nodeId, options)
    {
        super(CELL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCell(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.column) copy.column = this.column.copy();
        if (this.row   ) copy.row    = this.row   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const column = this.column ? (await this.column.eval(parse)).toValue() : null;
        const row    = this.row    ? (await this.row   .eval(parse)).toValue() : null;


        let columns = 0;
        let rows    = 0;

        if (   this.input
            && column
            && row)
        {
            const input = this.input ? (await this.input.eval(parse)).toValue() : null;

            
            if (   input
                && isTable(input))
            {
                rows = input.items.length;

                input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));

                if (row.value < rows)
                {
                    const _row = input.items[row.value];

                    if (column.value < columns)
                        this.value = _row.items[column.value].copy()
                    else
                        this.value = NullValue.copy();
                }
                else
                    this.value = NullValue.copy();
            }
            else
                this.value = NullValue.copy();
        }
        else
            this.value = NullValue.copy();


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', this.value              ],
            ['type',    type                    ],
            ['columns', new NumberValue(columns)],
            ['rows',    new NumberValue(rows   )]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.column && this.column.isValid()
            && this.row    && this.row   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.column) this.column.pushValueUpdates(parse);
        if (this.row   ) this.row   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.column) this.column.invalidateInputs(parse, from);
        if (this.row   ) this.row   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.column) this.column.iterateLoop(parse);
        if (this.row   ) this.row   .iterateLoop(parse);
    }
}


class GItems
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(ITEMS, nodeId, options);
    }



    copy()
    {
        const copy = new GItems(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (this[key] instanceof GValue)
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = this.input ? (await this.input.eval(parse)).toValue() : ListValue.NaN;


        this.updateValues = [];

        
        if (    this.value.isValid()
            && !isEmpty(this.value.items))
        {
            for (let i = 0; i < this.value.items.length; i++)
            {
                const item = this.value.items[i];

                const valueId = 
                    item.valueId != ''
                    ? item.valueId
                    : i;//'item' + i;

                Object.assign(this, {[valueId]: item});
                this.setUpdateValues(parse, [[valueId, item]], true);

                item.sortId = i;
            }

            this.updateValues.sort((a, b) => a.sortId - b.sortId);
        }
        else
            this.setUpdateValues(parse, [['', NullValue]], true);


        //this.updateValues.push(['value', this.value]); // first so it can be separated out in OpItems


        if (this.value.objects)
            for (let j = 0; j < this.value.objects.length; j++)
                this.value.objects[j].nodeId = this.nodeId;


        this.validate();

        return this;
    }
    
    

    paramFromId(paramId)
    {
        return paramId != 'value'
              ? this.value.items.find(i => i.valueId == paramId) //this[paramId]
              : null;
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return this.input && this.input.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GSelect
extends GOperator
{
    input = null;
    
    index;



    constructor(nodeId, options)
    {
        super(SELECT, nodeId, options);
    }



    copy()
    {
        const copy = new GSelect(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.index) copy.index = this.index.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let index = this.index ? (await this.index.eval(parse)).toValue() : null;


        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            

            if (   index
                && input
                && input.items
                && input.items.length > 0)
            {
                length = input.items.length;


                index = 
                       index.isValid()
                    && index.value >= 0
                    && index.value <  input.items.length
                    ? new NumberValue(Math.round(index.value))
                    : new NumberValue(0);


                if (   index.isValid()
                    && index.value >= 0
                    && index.value < input.items.length)
                {
                    this.value = input.items[index.value].copy();
                
                    if (this.value.objects)
                    {
                        for (const obj of this.value.objects)
                        {
                            obj.nodeId = this.nodeId;
                            obj.listId = -1;

                            if (obj.objectId != NULL) 
                                obj.objectId += '/';

                            obj.objectId += index.value.toString();
                        }
                    }
                }
                else
                {
                    this.value = NullValue.copy();
                    index      = NumberValue.NaN;
                }                    
            }
            else
            {
                this.value = NullValue.copy();
                index      = NumberValue.NaN;
            }
        }
        else
        {
            this.value = NullValue.copy();
            index      = NumberValue.NaN;
        }


        const type = 
            this.value
            ? new TextValue(
                LIST_VALUES.includes(this.value.type)
                ? finalListTypeFromItems(this.value.items)
                : this.value.type)
            : TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['preview', this.value              ],
            ['type',    type                    ],
            ['length',  new NumberValue(length) ],
            ['index',   index                   ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.index && this.index.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.index) this.index.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.index) this.index.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.index) this.index.iterateLoop(parse);
    }
}


class GListCount
extends GOperator
{
    input = null;
    start = null;

    value = null;



    constructor(nodeId, options)
    {
        super(LIST_COUNT, nodeId, options);
    }



    copy()
    {
        const copy = new GListCount(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.start)  copy.start  = this.start .copy();
        
        if (this.count) copy.count = this.count.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            this.value = new NumberValue(input.items.length - (start.value == 0 ? 1 : 0));
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['start', start     ]
        ]);


        this.validate();

        return this;
    }



    // toValue()
    // {
    //     return this.value.copy();
    // }



    isValid()
    {
        return this.input && this.input.isValid()
            && this.start && this.start.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.start) this.start.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.start) this.start.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.start) this.start.iterateLoop(parse);
    }    
}


class GContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(CONTAINS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GContains(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
        const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];

            
            if (   input1
                && input1.isValid())
            {
                for (let i = 0; i < input0.items.length; i++)
                {
                    if (input0.items[i].equals(input1))
                        indices.push(i);
                }  


                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN;
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN;

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN;
                this.last  = NumberValue.NaN;
                this.all   =   ListValue.NaN;
            }
        }
        else                  
        {
            this.value = NumberValue.NaN;
            this.first = NumberValue.NaN;
            this.last  = NumberValue.NaN;
            this.all   =   ListValue.NaN;
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}


class GIfElse
extends GOperator
{
    input0 = null;
    input1 = null;

    condition;



    constructor(nodeId, options)
    {
        super(IF_ELSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GIfElse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0   ) copy.input0    = this.input0   .copy();
        if (this.input1   ) copy.input1    = this.input1   .copy();

        if (this.condition) copy.condition = this.condition.copy();

        if (this.value    ) copy.value     = this.value    .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.input0 || this.input0.isCached())
            && (!this.input1 || this.input1.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const cond = (await this.condition.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = cond.value != 0 ? input0 : input1;
        }
        else if (this.input0)
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.value = 
                cond.value != 0
                ? input0
                : null;
        }
        else if (this.input1)
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = 
                cond.value == 0
                ? input1
                : null;
        }
        else                  
            this.value = null;


        this.updateValueObjects();


        this.setUpdateValues(parse,
        [
            ['type',      new TextValue(this.value ? this.value.type : ANY_VALUE)],
            ['condition', cond                                                   ]
        ]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    isValid()
    {
        return this.input0    && this.input0   .isValid()
            && this.input1    && this.input1   .isValid()
            && this.condition && this.condition.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0   ) this.input0   .pushValueUpdates(parse);
        if (this.input1   ) this.input1   .pushValueUpdates(parse);
        if (this.condition) this.condition.pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input0   ) this.input0   .invalidateInputs(parse, from);
        if (this.input1   ) this.input1   .invalidateInputs(parse, from);
        if (this.condition) this.condition.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0   ) this.input0   .iterateLoop(parse);
        if (this.input1   ) this.input1   .iterateLoop(parse);
        if (this.condition) this.condition.iterateLoop(parse);
    }    
}



class GArithmetic
extends GOperator
{
    inputs = [];



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    isValid()
    {
        return  this.inputs.length > 0
            && !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GNumber
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.input || this.input.isValid();
    }
}


class GSign
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIGN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSign(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.sign(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }
}


class GAbsolute
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_ABSOLUTE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAbsolute(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.abs(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GRound
extends GOperator1
{
    type;
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_ROUND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        copy.type     = this.type    .copy();
        copy.decimals = this.decimals.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const type = (await this.type    .eval(parse)).toValue();
        const dec  = (await this.decimals.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                switch (type.value)
                {
                    case 0: this.value.value = floorTo(this.value.value, dec.value); break;
                    case 1: this.value.value = roundTo(this.value.value, dec.value); break;
                    case 2: this.value.value =  ceilTo(this.value.value, dec.value); break;
                }

                this.value.decimals = dec.value;
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['type',     type      ],
            ['decimals', dec       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.type     && this.type    .isValid()
            && this.decimals && this.decimals.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.type    ) this.type    .pushValueUpdates(parse);
        if (this.decimals) this.decimals.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.type    ) this.type    .invalidateInputs(parse, from);
        if (this.decimals) this.decimals.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.type    ) this.type    .iterateLoop(parse);
        if (this.decimals) this.decimals.iterateLoop(parse);
    }
}



class GMinMax
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MINMAX, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMinMax(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

        
        this.value = await evalMinMaxInputs(this.inputs, op.value, parse);

        
        this.setUpdateValues(parse,
        [
            ['operation', op        ],
            ['value',     this.value]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalMinMaxInputs(inputs, op, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    let value = new NumberValue(0);


    const val0 = (await inputs[0].eval(parse)).toValue();

    if (   inputs.length == 1
        && val0.type == NUMBER_VALUE)
    {
        value = new NumberValue(-val0.value, val0.decimals);
    }
    else if (LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
    {
        const item0 = val0.items[0];

        value.value    = item0.value;
        value.decimals = item0.decimals;

        for (let i = 1; i < val0.items.length; i++)
        {
            const item = val0.items[i];

            if (item.type == NUMBER_VALUE)
            {
                value.value = 
                    op == 0
                    ? Math.min(value.value, item.value)
                    : Math.max(value.value, item.value);

                value.decimals = Math.max(value.decimals, item.decimals);
            }                    
        }
    }
    else
    {
        if (val0.type != NUMBER_VALUE)
            return NumberValue.NaN;

        value.value    = val0.value;
        value.decimals = val0.decimals;
    }


    for (let i = 1; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        if (LIST_VALUES.includes(val.type))
        {
            for (const item of val.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value.value = 
                        op == 0
                        ? Math.min(value.value, item.value)
                        : Math.max(value.value, item.value);

                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            consoleAssert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = 
                op == 0
                ? Math.min(value.value, val.value)
                : Math.max(value.value, val.value);

            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GLimits
extends GOperator1
{
    min;
    max;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        copy.min = this.min.copy();
        copy.max = this.max.copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && (!this.min || this.min.isCached())
            && (!this.max || this.max.isCached());
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const min = (await this.min.eval(parse)).toValue();
        const max = (await this.max.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                this.value.value = Math.min(Math.max(
                    min.value,
                    this.value.value),
                    max.value);
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['min',   min       ],
            ['max',   max       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.min && this.min.isValid()
            && this.max && this.max.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.min  ) this.min  .pushValueUpdates(parse);
        if (this.max  ) this.max  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.min  ) this.min  .invalidateInputs(parse, from);
        if (this.max  ) this.max  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.min  ) this.min  .iterateLoop(parse);
        if (this.max  ) this.max  .iterateLoop(parse);
    }
}



class GConstant
extends GOperator
{
    constant;



    constructor(nodeId, options)
    {
        super(NUMBER_CONSTANT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GConstant(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.constant) copy.constant = this.constant.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const constant = (await this.constant.eval(parse)).toValue();
    
        let value;

        switch (Math.min(Math.max(0, constant.toNumber()), 5))
        {
            case 0: value = 1.4142135623; break; // √̅2
            case 1: value = 2.7182818284; break; // e
            case 2: value = 0.6180339887; break; // phi
            case 3: value = 1.6180339887; break; // PHI
            case 4: value = 3.1415926536; break; // pi
            case 5: value = 6.2831853072; break; // tau
        }


        this.value = new NumberValue(value, 10);

        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['constant', constant ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.constant && this.constant.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.constant) this.constant.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.constant) this.constant.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.constant) this.constant.iterateLoop(parse);
    }
}



class GDateTime
extends GOperator
{
    seconds   = null;
    minutes   = null;
    hours     = null;
    dayOfWeek = null;
    date      = null;
    month     = null;
    year      = null;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);
        
        copy.copyBase(this);
        
        copy.seconds   = this.seconds  .copy();
        copy.minutes   = this.minutes  .copy();
        copy.hours     = this.hours    .copy();
        copy.dayOfWeek = this.dayOfWeek.copy();
        copy.date      = this.date     .copy();
        copy.month     = this.month    .copy();
        copy.year      = this.year     .copy();

        return copy;
    }    
    
    
    
    isCached()
    {
        return super.isCached()
            && (!this.year      || this.year     .isCached())
            && (!this.month     || this.month    .isCached())
            && (!this.date      || this.date     .isCached())
            && (!this.dayOfWeek || this.dayOfWeek.isCached())
            && (!this.hours     || this.hours    .isCached())
            && (!this.minutes   || this.minutes  .isCached())
            && (!this.seconds   || this.seconds  .isCached())
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];

        
        if (this.options.enabled)
        {
            const dateTime = new Date();

            const seconds   = new NumberValue(dateTime.getSeconds() );
            const minutes   = new NumberValue(dateTime.getMinutes() );
            const hours     = new NumberValue(dateTime.getHours()   );
            const dayOfWeek = new NumberValue(dateTime.getDay()     );
            const date      = new NumberValue(dateTime.getDate()    );
            const month     = new NumberValue(dateTime.getMonth()   );
            const year      = new NumberValue(dateTime.getFullYear());


            this.setUpdateValues(parse,
            [
                ['seconds',   seconds  ],
                ['minutes',   minutes  ],
                ['hours',     hours    ],
                ['dayOfWeek', dayOfWeek],
                ['date',      date     ],
                ['month',     month    ],
                ['year',      year     ]
            ]);    
        }    

        
        this.validate();

        return this;
    }    



    isValid()
    {
        return this.year      && this.year     .isValid()
            && this.month     && this.month    .isValid()
            && this.date      && this.date     .isValid()
            && this.dayOfWeek && this.dayOfWeek.isValid()
            && this.hours     && this.hours    .isValid()
            && this.minutes   && this.minutes  .isValid()
            && this.seconds   && this.seconds  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.year     ) this.year     .pushValueUpdates(parse);
        if (this.month    ) this.month    .pushValueUpdates(parse);
        if (this.date     ) this.date     .pushValueUpdates(parse);
        if (this.dayOfWeek) this.dayOfWeek.pushValueUpdates(parse);
        if (this.hours    ) this.hours    .pushValueUpdates(parse);
        if (this.minutes  ) this.minutes  .pushValueUpdates(parse);
        if (this.seconds  ) this.seconds  .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.year     ) this.year     .invalidateInputs(parse, from);
        if (this.month    ) this.month    .invalidateInputs(parse, from);
        if (this.date     ) this.date     .invalidateInputs(parse, from);
        if (this.dayOfWeek) this.dayOfWeek.invalidateInputs(parse, from);
        if (this.hours    ) this.hours    .invalidateInputs(parse, from);
        if (this.minutes  ) this.minutes  .invalidateInputs(parse, from);
        if (this.seconds  ) this.seconds  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.year     ) this.year     .iterateLoop(parse);
        if (this.month    ) this.month    .iterateLoop(parse);
        if (this.date     ) this.date     .iterateLoop(parse);
        if (this.dayOfWeek) this.dayOfWeek.iterateLoop(parse);
        if (this.hours    ) this.hours    .iterateLoop(parse);
        if (this.minutes  ) this.minutes  .iterateLoop(parse);
        if (this.seconds  ) this.seconds  .iterateLoop(parse);
    }    
}



class GDefine
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(DEFINE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDefine(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _values = [];

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            if (   input
                && this.options.enabled)            
            {
                if (LIST_VALUES.includes(input.type))
                {
                    for (const item of input.items)
                        _values.push(item.copy());   
                }
                else
                    _values.push(input.copy());
            }
        }
            

        this.value = _values[this.iteration % _values.length];


        this.setUpdateValues(parse,
        [
            ['type', new TextValue(finalTypeFromItems(_values))]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



class GRange
extends GOperator
{
    from;
    start;
    end;
    spread;
    bias;



    constructor(nodeId, options)
    {
        super(NUMBER_RANGE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRange(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from   ) copy.from    = this.from   .copy();
        if (this.start  ) copy.start   = this.start  .copy();
        if (this.end    ) copy.end     = this.end    .copy();
        if (this.spread ) copy.spread  = this.spread .copy();
        if (this.bias   ) copy.bias    = this.bias   .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const from   = (await this.from  .eval(parse)).toValue();
        const start  = (await this.start .eval(parse)).toValue();
        const end    = (await this.end   .eval(parse)).toValue();
        const spread = (await this.spread.eval(parse)).toValue();
        const bias   = (await this.bias  .eval(parse)).toValue();
    

        const repeat    = parse.repeats.find(r => r.repeatId == this.loopId);
        const iteration = repeat ? repeat.iteration : 0;


        let delta = end.toNumber() - start.toNumber();

        let step = 
               repeat
            && this.options.enabled
            ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))
            : 0;

            
        let startOffset;

             if (from  .value == 2) startOffset = step;
        else if (from  .value == 1
              && repeat
              && repeat.total == 1) startOffset = delta/2;
        else                        startOffset = 0;


        let f;
        
        if (repeat)
        {
            const sd = delta ? start.value/delta : 0;

                 if (from.value == 2) f = sd + iteration/repeat.total;
            else if (from.value == 1) f = sd + (repeat.total > 1 ? iteration/(repeat.total-1) : 0);
            else if (from.value == 0) f = sd + iteration/repeat.total;
        }
        else
            f = 0;


        switch(spread.value)
        {
            case 0:
                break;

            case 1:
            {
                const b = bias.toNumber() / 50;

                f = 
                    b >= 0
                    ? 1 - Math.pow(1-f, 1+b)
                    :     Math.pow(  f, 1-b);

                break;
            }
            case 2:
            {
                const b = bias.toNumber() / 50;

                     if (b >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+b) / 2;
                else if (b >= 0 && f <  0.5) f = Math.pow(f*2, 1+b) / 2;
                else if (b < 0)              f = lerp3(0, (1-b)/3, (2+b)/3, 1, f);

                break;
            }
        }


        this.value = new NumberValue(
            start.toNumber() + startOffset + delta * f,
            Math.max(start.decimals, end.decimals));

        this.setUpdateValues(parse,
        [
            ['from',   from  ],
            ['start',  start ],
            ['end',    end   ],
            ['spread', spread],
            ['bias',   bias  ]
        ]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.from   && this.from  .isValid()
            && this.start  && this.start .isValid()
            && this.end    && this.end   .isValid()
            && this.spread && this.spread.isValid()
            && this.bias   && this.bias  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from  ) this.from  .pushValueUpdates(parse);
        if (this.start ) this.start .pushValueUpdates(parse);
        if (this.end   ) this.end   .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.bias  ) this.bias  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from  ) this.from  .invalidateInputs(parse, from);
        if (this.start ) this.start .invalidateInputs(parse, from);
        if (this.end   ) this.end   .invalidateInputs(parse, from);
        if (this.spread) this.spread.invalidateInputs(parse, from);
        if (this.bias  ) this.bias  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from  ) this.from  .iterateLoop(parse);
        if (this.start ) this.start .iterateLoop(parse);
        if (this.end   ) this.end   .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.bias  ) this.bias  .iterateLoop(parse);
    }
}



class GSequence
extends GOperator
{
    start;
    step;
    end;

    current;



    constructor(nodeId, options)
    {
        super(NUMBER_SEQUENCE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSequence(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start  ) copy.start   = this.start  .copy();
        if (this.step   ) copy.step    = this.step   .copy();
        if (this.end    ) copy.end     = this.end    .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        // input not used for evaluation


        const start = (await this.start.eval(parse)).toValue();
        const step  = (await this.step .eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();
    

        if (   start
            && end
            && step)
        {
            const value = start.toNumber() + (this.options.enabled ? step.toNumber() * this.iteration : 0);

            // console.log('sequence');

            if (!end.isValid())
                this.value = new NumberValue(value, Math.max(start.decimals, step.decimals));

            else if (end.isValid()   
                     && (   step.toNumber() == 0
                         || step.toNumber() >  0 && start.toNumber() < end.toNumber()
                                                 && value < end.toNumber()
                         || step.toNumber() <  0 && start.toNumber() > end.toNumber()
                                                 && value > end.toNumber()))
            {
                this.value = new NumberValue(
                    start.toNumber() + (this.options.enabled ? step.toNumber() * this.iteration : 0),
                    Math.max(start.decimals, step.decimals));
            }

            else
                this.value = NumberValue.NaN.copy();
        }
        else
            this.value = NumberValue.NaN.copy();


        this.setUpdateValues(parse,
        [
            ['start', start],
            ['step',  step ],
            ['end',   end  ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.start && this.start.isValid()
            && this.step  && this.step .isValid()
            && (!this.end || this.end.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.step ) this.step .pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.end  ) this.end  .invalidateInputs(parse, from);
        if (this.step ) this.step .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.step ) this.step .iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GRandom
extends GOperator
{
    seed;
    min;
    max;
    unique;

    random       = null;
    randomUnique = null;

    lastValue1   = -1;
    lastValue2   = -1;
    uniqueOffset =  0;



    constructor(nodeId, options)
    {
        super(NUMBER_RANDOM, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.min   ) copy.min    = this.min   .copy();
        if (this.max   ) copy.max    = this.max   .copy();
        if (this.unique) copy.unique = this.unique.copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const seed   = (await this.seed  .eval(parse)).toValue();
        const min    = (await this.min   .eval(parse)).toValue();
        const max    = (await this.max   .eval(parse)).toValue();
        const unique = (await this.unique.eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
        {
            this.random       = new Random(seed.value);
            this.randomUnique = new Random(seed.value+1);
        }



        this.value = new NumberValue(
            min.value + this.random.get(this.iteration + this.uniqueOffset) * (max.value - min.value), 
            Math.max(min.decimals, max.decimals));

            
        const _unique = unique.value/100;
        

        if (max.value - min.value >= 1)
        {
            while (this.value.toNumber() == this.lastValue1
                && this.randomUnique.get(this.iteration) < _unique)
                this.value = new NumberValue(
                    min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),
                    Math.max(min.decimals, max.decimals));
        }

        if (max.value - min.value >= 2)
        {
            while ((   this.value.toNumber() == this.lastValue1
                    || this.value.toNumber() == this.lastValue2)
                && this.randomUnique.get(this.iteration) < Math.max(_unique - 1))
                this.value = new NumberValue(
                    min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),
                    Math.max(min.decimals, max.decimals));
        }        


        this.lastValue2 = this.lastValue1;
        this.lastValue1 = this.value.toNumber();


        this.setUpdateValues(parse,
        [
            ['seed',   seed  ],
            ['min',    min   ],
            ['max',    max   ],
            ['unique', unique]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed   && this.seed  .isValid()
            && this.min    && this.min   .isValid()
            && this.max    && this.max   .isValid()
            && this.unique && this.unique.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed  ) this.seed  .pushValueUpdates(parse);
        if (this.min   ) this.min   .pushValueUpdates(parse);
        if (this.max   ) this.max   .pushValueUpdates(parse);
        if (this.unique) this.unique.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.seed  ) this.seed  .invalidateInputs(parse, from);
        if (this.min   ) this.min   .invalidateInputs(parse, from);
        if (this.max   ) this.max   .invalidateInputs(parse, from);
        if (this.unique) this.unique.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed  ) this.seed  .iterateLoop(parse);
        if (this.min   ) this.min   .iterateLoop(parse);
        if (this.max   ) this.max   .iterateLoop(parse);
        if (this.unique) this.unique.iterateLoop(parse);
    }



    initLoop(parse, nodeId)
    {
        super.initLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.uniqueOffset = 0;
    }
}



class GNoise
extends GOperator
{
    seed;
    min;
    max;
    scale;
    interpolate;
    offset;
    detail;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_NOISE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNoise(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed       ) copy.seed        = this.seed       .copy();
        if (this.min        ) copy.min         = this.min        .copy();
        if (this.max        ) copy.max         = this.max        .copy();
        if (this.scale      ) copy.scale       = this.scale      .copy();
        if (this.offset     ) copy.offset      = this.offset     .copy();
        if (this.interpolate) copy.interpolate = this.interpolate.copy();
        if (this.detail     ) copy.detail      = this.detail     .copy();

        if (this.random     ) copy.random      = this.random     .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const seed        = (await this.seed       .eval(parse)).toValue();
        const min         = (await this.min        .eval(parse)).toValue();
        const max         = (await this.max        .eval(parse)).toValue();
        const scale       = (await this.scale      .eval(parse)).toValue();
        const offset      = (await this.offset     .eval(parse)).toValue();
        const interpolate = (await this.interpolate.eval(parse)).toValue();
        const detail      = (await this.detail     .eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
            this.random = new Random(seed.value);

        
        let size  = 1;
        let power = 1;
        
        const avg = (min.value + max.value) / 2;
        let   r;

        
        if (   this.options.enabled
            && scale
            && offset)
        {
            r = avg;
            
            for (let c = 0; c < detail.value; c++)
            {
                const i = this.iteration / (scale.value * size) + offset.value;
                
                const i0 = Math.floor(i);
                const i1 = Math.ceil (i);

                const r0 = this.random.get(i0);
                const r1 = this.random.get(i1);


                let _r;
                
                switch (interpolate.value)
                {
                    case 0: _r = power * r0;                                                 break;
                    case 1: _r = power * lerp(r0, r1, i-i0);                                 break;
                    case 2: _r = power * (r0 + (r1 - r0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;
                }

                r += 
                    - power * (avg       - min.value)
                    + _r    * (max.value - min.value);


                size  /= 2;
                power /= 2;
            }
        }
        else
        {
            r = min.value;
        }


        this.value = new NumberValue(r, Math.max(min.decimals, max.decimals));


        this.setUpdateValues(parse,
        [
            ['seed',        seed       ],
            ['min',         min        ],
            ['max',         max        ],
            ['scale',       scale      ],
            ['offset',      offset     ],
            ['interpolate', interpolate],
            ['detail',      detail     ]
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed        && this.seed       .isValid()
            && this.min         && this.min        .isValid()
            && this.max         && this.max        .isValid()
            && this.scale       && this.scale      .isValid()
            && this.offset      && this.offset     .isValid()
            && this.interpolate && this.interpolate.isValid()
            && this.detail      && this.detail     .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed       ) this.seed       .pushValueUpdates(parse);
        if (this.min        ) this.min        .pushValueUpdates(parse);
        if (this.max        ) this.max        .pushValueUpdates(parse);
        if (this.scale      ) this.scale      .pushValueUpdates(parse);
        if (this.offset     ) this.offset     .pushValueUpdates(parse);
        if (this.interpolate) this.interpolate.pushValueUpdates(parse);
        if (this.detail     ) this.detail     .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.seed       ) this.seed       .invalidateInputs(parse, from);
        if (this.min        ) this.min        .invalidateInputs(parse, from);
        if (this.max        ) this.max        .invalidateInputs(parse, from);
        if (this.scale      ) this.scale      .invalidateInputs(parse, from);
        if (this.offset     ) this.offset     .invalidateInputs(parse, from);
        if (this.interpolate) this.interpolate.invalidateInputs(parse, from);
        if (this.detail     ) this.detail     .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed       ) this.seed       .iterateLoop(parse);
        if (this.min        ) this.min        .iterateLoop(parse);
        if (this.max        ) this.max        .iterateLoop(parse);
        if (this.scale      ) this.scale      .iterateLoop(parse);
        if (this.offset     ) this.offset     .iterateLoop(parse);
        if (this.interpolate) this.interpolate.iterateLoop(parse);
        if (this.detail     ) this.detail     .iterateLoop(parse);
    }
}



class GProbability
extends GOperator
{
    seed;
    chance;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_PROBABILITY, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.chance) copy.chance = this.chance.copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const seed   = (await this.seed  .eval(parse)).toValue();
        const chance = (await this.chance.eval(parse)).toValue();
    

        if (  !this.random
            || this.random.seed != seed.value)
            this.random = new Random(seed.value);


        const r = 
            this.options.enabled
            ? (this.random.get(this.iteration) > 1 - chance.value/100 ? 1 : 0)
            : 0;


        this.value = new NumberValue(Math.round(r));


        this.setUpdateValues(parse,
        [
            ['seed', seed  ],
            ['min',  chance],
        ]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return this.seed   && this.seed  .isValid()
            && this.chance && this.chance.isValid()
            && this.max    && this.max   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.seed  ) this.seed  .pushValueUpdates(parse);
        if (this.chance) this.chance.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.seed  ) this.seed  .invalidateInputs(parse, from);
        if (this.chance) this.chance.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.seed  ) this.seed  .iterateLoop(parse);
        if (this.chance) this.chance.iterateLoop(parse);
    }
}



class GAccumulate
extends GOperator
{
    current;
    when;



    constructor(nodeId, options)
    {
        super(NUMBER_ACCUMULATE, nodeId, options);

        this.current = new NumberValue(0);
    }


    
    copy()
    {
        const copy = new GAccumulate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.when   ) copy.when    = this.when   .copy();
        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const when = (await this.when.eval(parse)).toValue();
            

        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (when.value == 0)
                this.value = this.current.copy();

            if (input)
            {
                this.current.value += input.value;
                this.current.decimals = Math.max(this.current.decimals, input.decimals);
            }

            if (when.value > 0)
                this.value = this.current.copy();
        }


        this.setUpdateValues(parse, [['', NullValue]]);
        

        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.when && this.when.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.step ) this.step .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.step ) this.step .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.step ) this.step .iterateLoop(parse);
    }



    resetLoop(parse, nodeId)
    {
        super.resetLoop(parse, nodeId);

        this.current = new NumberValue(0);
    }
}



class GInterpolate
extends GOperator2
{
    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount = (await this.amount.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = (await this.input0.eval(parse)).toValue();
            const val1 = (await this.input1.eval(parse)).toValue();

            const maxDec = Math.max(val0.decimals, val1.decimals);

            this.value = new NumberValue(
                val0.value + amount.value * (val1.value - val0.value) / 100,
                maxDec);
        }
        else if (this.input0)
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();

        else                  
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['amount', amount    ],
            ['value',  this.value]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.amount && this.amount.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.amount) this.amount.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.amount) this.amount.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.amount) this.amount.iterateLoop(parse);
    }
}



class GSolve
extends GOperator1
{
    current;
    target;

    temp;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSolve(this.nodeId, this.options);

        copy.copyBase(this);

        copy.current = this.current.copy();
        copy.target  = this.target .copy();

        return copy;
    }



    isCached()
    {
        return super.isCached()
            && this.current.isCached()
            && this.target .isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let   current = (await this.current.eval(parse)).toValue();
        const target  = (await this.target .eval(parse)).toValue();


        if (   this.input
            //&& current.isValid()
            && target .isValid())
        {
            let input = (await this.input.eval(parse)).toValue();

            consoleAssert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                const diffStart = target.value - current.value;
                let   diff      = diffStart;
                let   prevDiff  = 0;


                let   temp      = 0;
                let   step      = Number.MAX_SAFE_INTEGER/2;


                let   iter      = 0;
                const maxIter   = 1000;
                

                genInitNodeProgress(this.nodeId);


                parse.totalProgress += maxIter;


                while (iter++ < maxIter)
                {
                    temp += step;


                    if (this.input.type == PARAM)
                        this.input.node[this.input.paramId].value = temp;
                        
                    this.current.invalidateInputs(parse, this);
                    current = (await this.current.eval(parse)).toValue();


                    if (!current.isValid())
                        diff = Number.MAX_SAFE_INTEGER;
                    else
                        diff = target.value - current.value;

                    if (Math.abs(diff) < 0.0000001)
                        break;
                        

                    if (   Math.abs (diff) >  Math.abs (prevDiff)
                        || Math.sign(diff) != Math.sign(prevDiff))
                        step /= -2;


                    prevDiff = diff;


                    parse.currentProgress++;


                    genUpdateNodeProgress(parse, this.nodeId, iter / maxIter);
                }


                if (iter < maxIter)
                {
                    parse.currentProgress += maxIter - iter;

                    input = (await this.input.eval(parse)).toValue();
                    this.value = input;
                }
                else
                {
                    this.value = NumberValue.NaN;
                    console.warn('max solve iterations');
                }
            }
            else
                this.value = input;
        }
        else
        {
            if (this.input) 
                await this.input.eval(parse);

            this.value = NumberValue.NaN;
        }

        
        // TODO push good result value to input 

        this.setUpdateValues(parse,
        [
            //['value',   this.value],
            ['current', current   ],
            ['target',  target    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.current && this.current.isValid()
            && this.target  && this.target .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.current) this.current.pushValueUpdates(parse);
        if (this.target ) this.target .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.current) this.current.invalidateInputs(parse, from);
        if (this.target ) this.target .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.current) this.current.iterateLoop(parse);
        if (this.target ) this.target .iterateLoop(parse);
    }
}



class GAnimate
extends GOperator
{
    from;
    to;
    curve;
    repeat;
    length;
    time;



    constructor(nodeId, options)
    {
        super(NUMBER_ANIMATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnimate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from  ) copy.from   = this.from  .copy();
        if (this.to    ) copy.to     = this.to    .copy();
        if (this.curve ) copy.curve  = this.curve .copy();
        if (this.repeat) copy.repeat = this.repeat.copy();
        if (this.length) copy.length = this.length.copy();
        if (this.time  ) copy.time   = this.time  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const from   = (await this.from  .eval(parse)).toValue();
        const to     = (await this.to    .eval(parse)).toValue();
        const curve  = (await this.curve .eval(parse)).toValue();
        const repeat = (await this.repeat.eval(parse)).toValue();
        const length = (await this.length.eval(parse)).toValue();
        const time   = (await this.time  .eval(parse)).toValue();
    

        const maxDec = Math.max(from.decimals, to.decimals);

        switch (curve.value)
        {
            case 0: 
            {
                this.value = new NumberValue(
                    time.value < length.value ? from.value : to.value, 
                    maxDec);
    
                break;
            }
            case 1: 
            {
                this.value = new NumberValue(
                    from.value + (to.value - from.value) * time.value / length.value,
                    maxDec);

                break;
            }
            case 2: 
            {
                let f = time.value / length.value;

                f = 1 - sqr(1 - f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 3: 
            {
                let f = time.value / length.value;

                f = sqr(f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 4: 
            {
                let f = time.value / length.value;

                f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
        }
        

        this.setUpdateValues(parse,
        [
            ['from',   from  ],
            ['to',     to    ],
            ['curve',  curve ],
            ['repeat', repeat],
            ['length', length],
            ['time',   time  ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return this.from   && this.from  .isValid()
            && this.to     && this.to    .isValid()
            && this.curve  && this.curve .isValid()
            && this.repeat && this.repeat.isValid()
            && this.length && this.length.isValid()
            && this.time   && this.time  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from  ) this.from  .pushValueUpdates(parse);
        if (this.to    ) this.to    .pushValueUpdates(parse);
        if (this.curve ) this.curve .pushValueUpdates(parse);
        if (this.repeat) this.repeat.pushValueUpdates(parse);
        if (this.length) this.length.pushValueUpdates(parse);
        if (this.time  ) this.time  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from  ) this.from  .invalidateInputs(parse, from);
        if (this.to    ) this.to    .invalidateInputs(parse, from);
        if (this.curve ) this.curve .invalidateInputs(parse, from);
        if (this.repeat) this.repeat.invalidateInputs(parse, from);
        if (this.length) this.length.invalidateInputs(parse, from);
        if (this.time  ) this.time  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from  ) this.from  .iterateLoop(parse);
        if (this.to    ) this.to    .iterateLoop(parse);
        if (this.curve ) this.curve .iterateLoop(parse);
        if (this.repeat) this.repeat.iterateLoop(parse);
        if (this.length) this.length.iterateLoop(parse);
        if (this.time  ) this.time  .iterateLoop(parse);
    }
}



class GMath
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.operation) copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

        switch (op.value)
        {
            case 0: this.value = await evalSubtractInputs(this.inputs, parse); break;
            case 1: this.value = await evalAddInputs     (this.inputs, parse); break;
            case 2: this.value = await evalModuloInputs  (this.inputs, parse); break;
            case 3: this.value = await evalDivideInputs  (this.inputs, parse); break;
            case 4: this.value = await evalMultiplyInputs(this.inputs, parse); break;
            case 5: this.value = await evalExponentInputs(this.inputs, parse); break;
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



class GSimpleMath
extends GOperator1
{
    operation;
    operand;



    constructor(nodeId, options)
    {
        super(NUMBER_SIMPLE_MATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();
        copy.operand   = this.operand  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const op      = (await this.operation.eval(parse)).toValue();
        const operand = (await this.operand  .eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

                switch (op.value)
                {
                    case 0: 
                        this.value = new NumberValue(
                            this.value.value - operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 1: 
                        this.value = new NumberValue(
                            this.value.value + operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 2: 
                        this.value = new NumberValue(
                            this.value.value % operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 3: 
                        if (operand.value == 0)
                            this.value = NumberValue.NaN;
                        else
                        {
                            const val = this.value.value / operand.value;

                            this.value = new NumberValue(
                                val, 
                                Math.max(Math.max(this.value.decimals, operand.decimals)), decDigits(val));
                        }
                        break;

                    case 4: 
                        this.value = new NumberValue(
                            this.value.value * operand.value,
                            Math.max(this.value.decimals, operand.decimals));
                        break;

                    case 5: 
                        this.value = new NumberValue(
                            Math.pow(this.value.value, operand.value),
                            Math.max(this.value.decimals, operand.decimals));
                        break;
                }
            }
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ],
            ['operand',   operand   ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
    }
}



class GAdd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAdd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalAddInputs(this.inputs, parse);
        
        this.setUpdateValues(parse, [['value', this.value]]);

        this.validate();

        return this;
    }
}



async function evalAddInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        if (LIST_VALUES.includes(val.type))
        {
            if (   isEmpty(val.items)
                || val.items[0].type != NUMBER_VALUE)
                return NumberValue.NaN;

            for (const item of val.items)
            {
                if (item.type == NUMBER_VALUE)
                {
                    value.value   += item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
        }
        else
        {
            consoleAssert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            value.value   += val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GSubtract
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSubtract(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalSubtractInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalSubtractInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    let value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (   inputs.length == 1
            && val0.type == NUMBER_VALUE)
        {
            value = new NumberValue(-val0.value, val0.decimals);
        }
        else if (LIST_VALUES.includes(val0.type)
             && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];

                if (item.type == NUMBER_VALUE)
                {
                    value.value   -= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        value.value   -= item.value;
                        value.decimals = Math.max(value.decimals, item.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                value.value   -= val.value;
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GMultiply
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GMultiply(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }

    

    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalMultiplyInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalMultiplyInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        value.value = 1;

        for (let i = 0; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                if (   isEmpty(val.items)
                    || val.items[0].type != NUMBER_VALUE)
                    return NumberValue.NaN;

                for (const item of val.items)
                {
                    value.value   *= item.value;
                    value.decimals = Math.max(value.decimals, item.decimals);
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value   *= val.value;
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GDivide
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDivide(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        this.value = await evalDivideInputs(this.inputs, parse);
    
        
        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalDivideInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();


        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                console.log('item =', item);
                
                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.value    = value.value / item.value;
                    value.decimals = Math.max(Math.max(value.decimals, item.decimals), decDigits(value.value));
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }

        
        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value.value    = value.value / item.value;
                        value.decimals = Math.max(Math.max(value.decimals, item.decimals), decDigits(value.value));
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }
    
                value.value    = value.value / val.value;
                value.decimals = Math.max(Math.max(value.decimals, val.decimals), decDigits(value.value));
            }
        }
    }


    return value;
}


class GModulo
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const copy = new GModulo(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalModuloInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalModuloInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                {
                    if (item.value == 0) 
                    { 
                        value.value    = Number.NaN; 
                        value.decimals = 0;
                        break; 
                    }

                    value.decimals = Math.max(value.decimals, item.decimals);
                    value.value    = value.value % item.value;
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        if (item.value == 0) 
                        { 
                            value.value    = Number.NaN; 
                            value.decimals = 0;
                            break; 
                        }

                        value.decimals = Math.max(value.decimals, item.decimals);
                        value.value    = floorTo(value.value % item.value, value.decimals);
                    }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.value == 0) 
                { 
                    value.value    = Number.NaN; 
                    value.decimals = 0;
                    break; 
                }

                value.decimals = Math.max(value.decimals, val.decimals);
                value.value    = floorTo(value.value % val.value, value.decimals);
            }
        }
    }


    return value;
}


class GExponent
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GExponent(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalExponentInputs(this.inputs, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalExponentInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value    = item0.value;
            value.decimals = item0.decimals;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                {
                    value.value    = Math.pow(value.value,    item.value);
                    value.decimals = Math.max(value.decimals, item.decimals);
                }                    
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value    = val0.value;
            value.decimals = val0.decimals;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                    {
                        value.value    = Math.pow(value.value,    item.value);
                        value.decimals = Math.max(value.decimals, item.decimals);
                            }                    
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value    = Math.pow(value.value,    val.value);
                value.decimals = Math.max(value.decimals, val.decimals);
            }
        }
    }


    return value;
}


class GBoolean
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_BOOLEAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), BOOLEAN_OPS.length-1);

        
        switch (op.value)
        {
            case BOOLEAN_NOT: this.value = await evalNandInputs(this.inputs, parse); break;
            case BOOLEAN_XOR: this.value = await evalXorInputs (this.inputs, parse); break;
            case BOOLEAN_OR:  this.value = await evalOrInputs  (this.inputs, parse); break;
            case BOOLEAN_AND: this.value = await evalAndInputs (this.inputs, parse); break;
        }

        
        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}


class GNot
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNot(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalNandInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalNandInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber() != 0 ? 0 : 1;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() == 0)
                    value.value = 1;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber() != 0 ? 0 : 1;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() == 0)
                        value.value = 1;
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                if (val.toNumber() == 0)
                    value.value = 1;
            }
        }
    }


    return value;
}



class GAnd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_AND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalAndInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);

        
        this.validate();

        return this;
    }
}



async function evalAndInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.min(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.min(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');

                value.value = Math.min(value.value, val.toNumber());
            }
        }

        
        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GOr
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_OR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GOr(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalOrInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalOrInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            value.value = item0.toNumber();

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (item.type == NUMBER_VALUE)
                    value.value = Math.max(value.value, item.toNumber());
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            value.value = val0.toNumber();
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (item.type == NUMBER_VALUE)
                        value.value = Math.max(value.value, item.toNumber());
                }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                value.value = Math.max(value.value, val.toNumber());
            }
        }


        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GXor
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_XOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GXor(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalXorInputs(this.inputs, parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalXorInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    let flipped;

    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        if (    LIST_VALUES.includes(val0.type)
            && !isEmpty(val0.items))
        {
            const item0 = val0.items[0];

            flipped = item0.toNumber() != 0;

            for (let i = 1; i < val0.items.length; i++)
            {
                const item = val0.items[i];
                
                if (   item.type == NUMBER_VALUE
                    && item.toNumber() != 0)
                    flipped++;
            }
        }
        else
        {
            if (val0.type != NUMBER_VALUE)
                return NumberValue.NaN;

            flipped = val0.toNumber() != 0;
        }


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            if (LIST_VALUES.includes(val.type))
            {
                for (const item of val.items)
                {
                    if (   item.type == NUMBER_VALUE
                        && item.toNumber() != 0)
                        flipped++;
                    }
            }
            else
            {
                consoleAssert(
                    val.type == NUMBER_VALUE, 
                    'val.type must be NUMBER_VALUE');
                    
                if (val.toNumber() != 0)
                    flipped++;
            }
        }


        value.value = flipped == 1 ? 1 : 0;
    }


    return value;
}


class GCondition
extends GOperator1
{
    operation;
    operand;



    constructor(nodeId, options)
    {
        super(NUMBER_CONDITION, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondition(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();
        copy.operand   = this.operand  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op      = (await this.operation.eval(parse)).toValue();
        const operand = (await this.operand  .eval(parse)).toValue();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        switch (op.value)
        {
            case CONDITION_LESS:              this.value = await evalConditionInputs(this.input, operand, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     this.value = await evalConditionInputs(this.input, operand, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         this.value = await evalConditionInputs(this.input, operand, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             this.value = await evalConditionInputs(this.input, operand, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  this.value = await evalConditionInputs(this.input, operand, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           this.value = await evalConditionInputs(this.input, operand, ((a, b) => a >  b), parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['operation', op        ],
            ['operand',   operand   ]
        ]);


        this.validate();

    return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid()
            && this.operand   && this.operand  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
        if (this.operand  ) this.operand  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
        if (this.operand  ) this.operand  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
        if (this.operand  ) this.operand  .iterateLoop(parse);
    }
}



async function evalConditionInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : NumberValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : NumberValue.NaN;

    if (   val0.isValid() 
        && val1.isValid())
        return new NumberValue(op(val0.toNumber(), val1.toNumber()) ? 1 : 0);
    else                  
        return NumberValue.NaN;
}


class GEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a == b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GNotEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNotEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a != b, 
            parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GLess
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLess(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a < b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GLessOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLessOrEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a <= b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GGreater
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreater(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a > b, 
            parse);
        

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}


class GGreaterOrEqual
extends GOperator2
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreaterOrEqual(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a >= b, 
            parse);
            

        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



class GTrig
extends GOperator1
{
    function;



    constructor(nodeId, options)
    {
        super(NUMBER_TRIG, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTrig(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const func = (await this.function.eval(parse)).toValue().toInteger();

        func.value = Math.min(Math.max(0, func.value), TRIG_OPS.length-1);

        
        switch (func.value)
        {
            case TRIG_SIN: this.value = await evalSine   (this.input, parse);  break;
            case TRIG_COS: this.value = await evalCosine (this.input, parse);  break;
            case TRIG_TAN: this.value = await evalTangent(this.input, parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['value',    this.value],
            ['function', func      ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.function && this.function.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.function) this.function.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.function) this.function.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.function) this.function.iterateLoop(parse);
    }
}


class GSine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_SIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalSine(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



async function evalSine(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    value = new NumberValue(Math.sin(value.value, 10));

    return value;
}


class GCosine
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_COS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCosine(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalCosine(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalCosine(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    value = new NumberValue(Math.cos(value.value, 10));

    return value;
}


class GTangent
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(NUMBER_TAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTangent(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalTangent(this.input, parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }
}



async function evalTangent(input, parse)
{
    if (!input)
        return NumberValue.NaN;

    let value = (await input.eval(parse)).toValue();

    value = new NumberValue(Math.tan(value.value, 10));

    return value;
}


class GText
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT, nodeId, options);
    }



    copy()
    {
        const copy = new GText(this.nodeId, this.options);
        
        copy.copyBase(this);

        copy.value = this.value;
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return   !this.input
               && this.value != NAN_CHAR 
            || this.input.isValid();
    }



    isValid()
    {
        return ;
    }
}


class GTextLength
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_LENGTH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextLength(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.length) copy.length = this.length.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let length;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            consoleAssert(input.type == TEXT_VALUE, 'input must be TEXT_VALUE');

            length = new NumberValue(input.value.length);
        }
        else
            length = NumberValue.NaN;
    

        this.setUpdateValues(parse,
        [
            ['length', length]
        ]);


        this.validate();

        return this;
    }
}



class GTextTrim
extends GOperator1
{
    start;
    end;


    
    constructor(nodeId, options)
    {
        super(TEXT_TRIM, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextTrim(this.nodeId, this.options);

        copy.copyBase(this);

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            if (this.options.enabled)
            {
                if (start.value.length > 0) this.value.value = trimCharFromStart(this.value.value, unescapeString(start.value));
                if (end  .value.length > 0) this.value.value = trimCharFromEnd  (this.value.value, unescapeString(end  .value));
            }
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['start', start     ],
            ['end',   end       ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.start) this.start.invalidateInputs(parse, from);
        if (this.end  ) this.end  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.start) this.start.iterateLoop(parse);
        if (this.end  ) this.end  .iterateLoop(parse);
    }
}



class GTextSubstring
extends GOperator1
{
    start;
    end;


    
    constructor(nodeId, options)
    {
        super(TEXT_SUBSTRING, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextSubstring(this.nodeId, this.options);

        copy.copyBase(this);

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();

        let   length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            length = input.value.length;
            
            this.value = input.copy();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            const _end =
                end.isValid()
                ? end
                : new NumberValue(input.value.length);


            if (start.value <= _end.value)
            {
                if (this.options.enabled)
                    this.value.value = this.value.value.substring(start.value, _end.value);
            }
            else
                this.value = new TextValue();//TextValue.NaN;
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',  this.value             ],
            ['length', new NumberValue(length)], // used to set start and end maxima
            ['start',  start                  ],
            ['end',    end                    ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.start && this.start.isValid()
            && this.end   && this.end  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.start) this.start.pushValueUpdates(parse);
        if (this.end  ) this.end  .pushValueUpdates(parse);
    }



    iterateLoop(parse, from)
    {
        super.iterateLoop(parse, from);

        if (this.start) this.start.iterateLoop(parse, from);
        if (this.end  ) this.end  .iterateLoop(parse, from);
    }
}



class GTextContains
extends GOperator2
{
    first;
    last;
    all;



    constructor(nodeId, options)
    {
        super(TEXT_CONTAINS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextContains(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
        const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;
    

        if (   input0 && input0.isValid() 
            && input1 && input1.isValid())
        {
            const indices = [];
            let   index   = 0;

            if (input1.value != '')
            {
                while (index != -1) 
                {
                    index = input0.value.indexOf(input1.value, index);

                    if (index != -1) 
                    {
                        indices.push(index);
                        index += 1;
                    }
                }

                
                this.value = new NumberValue(indices.length > 0 ? 1 : 0);

                this.first = indices.length > 0 ? new NumberValue(indices.at( 0)) : NumberValue.NaN;
                this.last  = indices.length > 0 ? new NumberValue(indices.at(-1)) : NumberValue.NaN;

                this.all   = new ListValue();

                for (const index of indices)
                    this.all.items.push(new NumberValue(index));
            }
            else
            {
                this.value = new NumberValue(1);

                this.first = NumberValue.NaN;
                this.last  = NumberValue.NaN;
                this.all   =   ListValue.NaN;
            }
        }
        else                  
        {
            this.value = NumberValue.NaN;
            this.first = NumberValue.NaN;
            this.last  = NumberValue.NaN;
            this.all   =   ListValue.NaN;
        }
    

        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['first', this.first],
            ['last',  this.last ],
            ['all',   this.all  ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.first && this.first.isValid()
            && this.last  && this.last .isValid()
            && this.all   && this.all  .isValid();
    }
}


class GTextCase
extends GOperator1
{
    case;


    
    constructor(nodeId, options)
    {
        super(TEXT_CASE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCase(this.nodeId, this.options);

        copy.copyBase(this);

        copy.case = this.case.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _case = (await this.case.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            if (this.options.enabled)
            {
                const val = this.value.value;

                if (_case.value == 0) 
                     this.value.value = val.toLowerCase();

                else if (_case.value == 1)
                {
                    this.value.value = '';

                    if (val.length > 0) this.value.value += val.substring(0, 1).toUpperCase();
                    if (val.length > 1) this.value.value += val.substring(1)   .toLowerCase();
                }

                else if (_case.value == 2)
                {
                    this.value.value = '';

                    let i = 0;
                    while (i < val.length)
                    {
                        while (i < val.length
                            && /\s/.test(val.charAt(i)))
                            this.value.value += val.charAt(i++);

                        if (i < val.length)
                            this.value.value += val.charAt(i++).toUpperCase();

                        while (i < val.length
                            && !/\s/.test(val.charAt(i)))
                            this.value.value += val.charAt(i++).toLowerCase();
                    }
                }

                else if (_case.value == 3) 
                    this.value.value = val.toUpperCase();
            }
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['case',  _case     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.case && this.case.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.case) this.case.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.case) this.case.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.case) this.case.iterateLoop(parse);
    }
}



class GNumberToText
extends GOperator1
{
    number;
    format;


    
    constructor(nodeId, options)
    {
        super(NUMBER_TO_TEXT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNumberToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            let str = NAN_CHAR;

            switch (format.value)
            {
                case 0: // dec
                    str = numToString(input.value, -input.decimals);
                break;

                case 1: // hex
                    str = numToString(Math.round(input.value), input.decimals, true).toUpperCase();
                    break;
            }

            this.value = new TextValue(str);
        }
        else
            this.value = TextValue.NaN;

            
        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['format', format    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.format) this.format.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



class GTextToNumber
extends GOperator1
{
    format;


    
    constructor(nodeId, options)
    {
        super(TEXT_TO_NUMBER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextToNumber(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.format) copy.format = this.format.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            let num = Number.NaN;

            switch (format.value)
            {
                case 0: // dec
                    num = parseFloat(input.value);
                    break;

                case 1: // hex
                    num = parseInt(input.value, 16);
                    break;
            }

            this.value = new NumberValue(num, decDigits(num));
        }
        else
            this.value = NumberValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',  this.value],
            ['format', format    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.format && this.format.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.format) this.format.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.format) this.format.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.format) this.format.iterateLoop(parse);
    }
}



class GTextToColor
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_TO_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextToColor(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            let rgb = 
                input.value.trim() != ''
                ? validHex2rgb(input.value)
                : rgb_NaN;
                
            this.value = ColorValue.fromRgb(scaleRgb(rgb));
        }
        else
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }
}



class GTextCharacter
extends GOperator1
{
    code;


    
    constructor(nodeId, options)
    {
        super(TEXT_CHAR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCharacter(this.nodeId, this.options);

        copy.copyBase(this);

        copy.code = this.code.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const code = (await this.code.eval(parse)).toValue();


        this.value = new TextValue(String.fromCharCode(code.value));


        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['code',  code      ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.code && this.code.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.code) this.code.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.code) this.code.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.code) this.code.iterateLoop(parse);
    }
}



class GTextReplace
extends GOperator1
{
    what;
    with;



    constructor(nodeId, options)
    {
        super(TEXT_REPLACE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextReplace(this.nodeId, this.options);

        copy.copyBase(this);

        copy.what  = this.what .copy();
        copy.with  = this.with .copy();

        copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _what = (await this.what.eval(parse)).toValue();
        const _with = (await this.with.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');

            this.value.value = this.value.value.replaceAll(
                unescapeString(_what.value),
                unescapeString(_with.value));
        }
        else
            this.value = new TextValue();//TextValue.NaN;

            
        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['what',  _what     ],
            ['with',  _with     ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.what && this.what.isValid()
            && this.with && this.with.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.what) this.what.pushValueUpdates(parse);
        if (this.with) this.with.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.what) this.what.invalidateInputs(parse, from);
        if (this.with) this.with.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.what) this.what.iterateLoop(parse);
        if (this.with) this.with.iterateLoop(parse);
    }
}



class GTextJoin
extends GOperator
{
    inputs = [];

    with;


    
    constructor(nodeId, options)
    {
        super(TEXT_JOIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextJoin(this.nodeId, this.options);
        copy.copyBase(this);
        
        copy.inputs = this.inputs.map(i => i.copy());
        copy.with   = this.with;

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _with = (await this.with.eval(parse)).toValue();

        this.value = await evalJoinInputs(this.inputs, _with, parse);

        
        this.setUpdateValues(parse,
        [
            ['value', this.value],
            ['with',  _with     ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.with && this.with.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}



async function evalJoinInputs(inputs, _with, parse)
{
    if (isEmpty(inputs))
        return new TextValue();//TextValue.NaN;


    const value = new TextValue();
    const w     = unescapeString(_with.value);

    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();
        if (!val) continue;


        if (i > 0)
            value.value += w;


        if (LIST_VALUES.includes(val.type))
        {
            for (let j = 0; j < val.items.length; j++)
            {
                if (j > 0)
                    value.value += w;


                const item = val.items[j];

                if (item.type == TEXT_VALUE)
                    value.value += item.value;
            }
        }
        else
        {
            consoleAssert(val.type == TEXT_VALUE, 'val.type must be TEXT_VALUE');

            value.value += val.value;
        }
    }


    return value;
}


class GTextPad
extends GOperator1
{
    startPad;
    startCount;
    endPad;
    endCount;


    
    constructor(nodeId, options)
    {
        super(TEXT_PAD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextPad(this.nodeId, this.options);

        copy.copyBase(this);

        copy.startPad   = this.startPad  .copy();
        copy.startCount = this.startCount.copy();
        copy.endPad     = this.endPad    .copy();
        copy.endCount   = this.endCount  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const startPad   = (await this.startPad  .eval(parse)).toValue();
        const startCount = (await this.startCount.eval(parse)).toValue();
        const endPad     = (await this.endPad    .eval(parse)).toValue();
        const endCount   = (await this.endCount  .eval(parse)).toValue();


        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            length = input.value.length;
            
            this.value = input.copy();
            
            consoleAssert(this.value.type == TEXT_VALUE, 'this.value.type must be TEXT_VALUE');
                
                
            if (this.options.enabled)
                this.value.value = this.value.value
                    .padStart(startCount.value, unescapeString(startPad.value))
                    .padEnd  (  endCount.value, unescapeString(  endPad.value));
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',      this.value             ],
            ['length',     new NumberValue(length)], // used to set start and end maxima
            ['startPad',   startPad               ],
            ['startCount', startCount             ],
            ['endPad',     endPad                 ],
            ['endCount',   endCount               ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.startPad   && this.startPad  .isValid()
            && this.startCount && this.startCount.isValid()
            && this.endPad     && this.endPad    .isValid()
            && this.endCount   && this.endCount  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.startPad  ) this.startPad  .pushValueUpdates(parse);
        if (this.startCount) this.startCount.pushValueUpdates(parse);
        if (this.endPad    ) this.endPad    .pushValueUpdates(parse);
        if (this.endCount  ) this.endCount  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.startPad  ) this.startPad  .invalidateInputs(parse, from);
        if (this.startCount) this.startCount.invalidateInputs(parse, from);
        if (this.endPad    ) this.endPad    .invalidateInputs(parse, from);
        if (this.endCount  ) this.endCount  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.startPad  ) this.startPad  .iterateLoop(parse);
        if (this.startCount) this.startCount.iterateLoop(parse);
        if (this.endPad    ) this.endPad    .iterateLoop(parse);
        if (this.endCount  ) this.endCount  .iterateLoop(parse);
    }
}



class GTextSplit
extends GOperator1
{
    value;
    separator;



    constructor(nodeId, options)
    {
        super(TEXT_SPLIT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextSplit(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value    ) copy.value     = this.value    .copy();
        if (this.separator) copy.separator = this.separator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const separator = this.separator ? (await this.separator.eval(parse)).toValue() : null;


        this.value = new ListValue();


        if (   this.input
            && separator)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            if (   input
                && input.value)
            {
                consoleAssert(input.type == TEXT_VALUE, 'input must be TEXT_VALUE');
                const items = input.value.split(unescapeString(separator.value));

                for (const item of items)
                    this.value.items.push(new TextValue(item));
            }
        }
    

        this.setUpdateValues(parse,
        [
            ['value',     this.value],
            ['separator', separator ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.separator && this.separator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.separator) this.separator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.separator) this.separator.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.separator) this.separator.iterateLoop(parse);
    }
}



class GTextCompare
extends GOperator2
{
    operation;



    constructor(nodeId, options)
    {
        super(TEXT_COMPARE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCompare(this.nodeId, this.options);

        copy.copyBase(this);

        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        let result;

        switch (op.value)
        {
            case CONDITION_LESS:              result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           result = await evalCompareInputs(this.input0, this.input1, ((a, b) => a >  b), parse);  break;
        }


        this.setUpdateValues(parse,
        [
            ['result',    result],
            ['operation', op    ]
        ]);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.operation && this.operation.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.operation) this.operation.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.operation) this.operation.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.operation) this.operation.iterateLoop(parse);
    }
}



async function evalCompareInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : TextValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : TextValue.NaN;

    if (   val0 && val0.isValid() 
        && val1 && val1.isValid())
        return new NumberValue(op(val0.value, val1.value) ? 1 : 0);
    else                  
        return NullValue;//new NumberValue(0);
}


class GTextCSV
extends GOperator1
{
    rowSeparator;
    columnSeparator;



    constructor(nodeId, options)
    {
        super(TEXT_CSV, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCSV(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.rowSeparator   ) copy.rowSeparator    = this.rowSeparator   .copy();
        if (this.columnSeparator) copy.columnSeparator = this.columnSeparator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const rowSeparator    = this.rowSeparator    ? (await this.rowSeparator   .eval(parse)).toValue() : null;
        const columnSeparator = this.columnSeparator ? (await this.columnSeparator.eval(parse)).toValue() : null;


        this.value = new ListValue();


        let maxColumns = 0;

        
        let nRows    = 0;
        let nColumns = 0;


        if (   this.input
            && rowSeparator
            && columnSeparator
            && rowSeparator.value != '')
        {
            const input = this.input ? (await this.input.eval(parse)).toValue() : null;
            

            const rows = 
                   input
                && input.value            
                ? input.value.split(unescapeString(rowSeparator.value))
                : [];


            for (const _row of rows)
            {
                const cells = 
                    _row
                    ? _row.split(unescapeString(columnSeparator.value))
                    : [];


                const row = new ListValue();

                for (const cell of cells)
                    row.items.push(new TextValue(cell));

                maxColumns = Math.max(maxColumns, row.items.length);


                this.value.items.push(row);
            }


            nRows    = this.value.items.length;
            nColumns = maxColumns;
        }
    

        this.setUpdateValues(parse,
        [
            ['preview',         new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['rowSeparator',    rowSeparator             ],
            ['columnSeparator', columnSeparator          ],
            ['rows',            new NumberValue(nRows   )],
            ['columns',         new NumberValue(nColumns)]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.rowSeparator    && this.rowSeparator   .isValid()
            && this.columnSeparator && this.columnSeparator.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.rowSeparator   ) this.rowSeparator   .pushValueUpdates(parse);
        if (this.columnSeparator) this.columnSeparator.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.rowSeparator   ) this.rowSeparator   .invalidateInputs(parse, from);
        if (this.columnSeparator) this.columnSeparator.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.rowSeparator   ) this.rowSeparator   .iterateLoop(parse);
        if (this.columnSeparator) this.columnSeparator.iterateLoop(parse);
    }
}



class GTextJson
extends GOperator1
{
    constructor(nodeId, options)
    {
        super(TEXT_JSON, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextJson(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            try
            {
                const json = JSON.parse(input.value);
                this.value = this.evalItems(json);
            }
            catch (e)
            {
                this.value = new ListValue();
            }
        }
    

        // console.log('this.value =', this.value);
        this.setUpdateValues(parse,
        [
            ['preview', new ListValue(this.value.items.slice(0, Math.min(this.value.items.length, 11)))],
            ['length',  new NumberValue(this.value.items.length)]
            //['value',   this.value]
        ]);
        

        this.validate();

        return this;
    }



    evalItems(json)
    {
        let list = new ListValue();


        for (const key in json)
        {
            if (   typeof json[key] === 'object'
                && json[key] !== null)
            {
                const obj = this.evalItems(json[key]);
                obj.valueId = key;
                list.items.push(obj);
            }
            else
            {
                let value;

                if (   typeof json[key] === 'number'
                    || isValidFloatString(json[key]))
                    value = NumberValue.fromString(json[key].toString());
                else if (typeof json[key] === 'boolean')
                    value = new NumberValue(parseBool(json[key].toString()) ? 1 : 0);
                else
                    value = new TextValue(json[key]);

                    
                value.valueId = 
                    key == 'value'
                    ? '(value)' // reserved param name in Generator
                    : key;

                list.items.push(value);
            }
        }

        
        return list;
    }
}



class GTextFetch
extends GOperator
{
    request;
    cachedValue;



    constructor(nodeId, options)
    {
        super(TEXT_FETCH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextFetch(this.nodeId, this.options);

        copy.copyBase(this);

        copy.request     = this.request    .copy();
        copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const request     = (await this.request    .eval(parse)).toValue();
        const cachedValue = (await this.cachedValue.eval(parse)).toValue();

        
        genInitNodeProgress(this.nodeId);


        if (cachedValue.value == '')
        {
            try 
            {
                const response = await fetch(request.value);
                const content  = await response.text();
                
                this.value = new TextValue(content);
            }
            catch (e)
            {
                // const parts = e.message.split(':');
                
                this.value = 
                    request.value.trim() == NULL
                    ? new TextValue()
                    : new TextValue('invalid request');//parts[Math.min(1, parts.length-1)]);
            }
        }
        else
        {
            this.value = this.cachedValue.copy();
        }


        this.setUpdateValues(parse,
        [
            ['preview', this.value],
            ['value',   this.value],
            ['request', request   ]
        ]);
        
        
        this.validate();

        return this;
    }



    isValid()
    {
        return this.request && this.request.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.request) this.request.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.request) this.request.invalidateInputs(parse, from);

        this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.request) this.request.iterateLoop(parse);
    }
}


class GTextFile
extends GOperator
{
    path;
    
    cachedValue = null;



    constructor(nodeId, options)
    {
        super(TEXT_FILE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextFile(this.nodeId, this.options);

        copy.copyBase(this);

        copy.cachedValue = this.cachedValue.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const cachedValue = this.cachedValue ? (await this.cachedValue.eval(parse)).toValue() : null;
        const path        = this.path        ? (await this.path       .eval(parse)).toValue() : null;

        
        genInitNodeProgress(this.nodeId);


        this.value = cachedValue ?? new TextValue();


        this.setUpdateValues(parse,
        [
            ['preview', this.value],
            ['path',    path      ]
        ]);
        
        
        this.validate();

        return this;
    }



    isValid()
    {
        return this.path && this.path.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.path) this.path.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.path) this.path.invalidateInputs(parse, from);

        //this.cachedValue = new TextValue();
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.path) this.path.iterateLoop(parse);
    }
}


class ColorCorrection
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    
    constructor(name = '', max = 0, value = 0)//, locked = false)
    {
        this.name  = name;
        this.max   = max;
        this.value = value;
    }
}



async function findCorrection(parse,
                        nodeId,
                        color,
                        order,       margin1, margin2, margin3,
                        lockedOrder, locked1, locked2, locked3) 
{
    const refOklab = dataColor2array(dataColor2oklab(color));

    
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = order ? order.value : -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);

        
    let d = 1;
        
    parse.totalProgress += 1024;


    dLoop:
    while (d > 1/1024)
    {
        if (parse.stop()) break dLoop;

        let _closestColor = [...closestColor];


        for (let _order = 0; _order < 6; _order++)
        {
            if (parse.stop()) break dLoop;

            closestColor = [..._closestColor];

            const [min1, min2, min3] = getMinCorrections(color[0], _order);
            const [max1, max2, max3] = getMaxCorrections(color[0], _order);

            let start1 = lerp(min1, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(min2, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(min3, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = margin1.toNumber(); start1 = closest1; end1 = closest1+Epsilon; }
            if (locked2) { closest2 = margin2.toNumber(); start2 = closest2; end2 = closest2+Epsilon; }
            if (locked3) { closest3 = margin3.toNumber(); start3 = closest3; end3 = closest3+Epsilon; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = await findCorrectionInOrder(
                parse,
                nodeId,
                refOklab,
                _order, 
                lockedOrder, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }


        if (parse.stopGenerate)
            break;

        
        d /= 2;


        parse.currentProgress++;
    }


    if (   !parse.stop()
        && !parse.stopGenerate)
    {
        // reduce closest to necessary minimums

        const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

        let c1 = closest1;
        let c2 = closest2;
        let c3 = closest3;

        while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
        while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
        while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

        closest1 = Math.max(0, c1);
        closest2 = Math.max(0, c2);
        closest3 = Math.max(0, c3);
    }

    
    return [
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



async function findCorrectionInOrder(parse,
                                     nodeId,
                                     refOklab,
                                     order, 
                                     lockedOrder, 
                                     locked1,  locked2,  locked3,
                                     closest1, closest2, closest3,
                                     start1,   start2,   start3, 
                                     end1,     end2,     end3,
                                     closestColor,
                                     closestOklab,
                                     closestOrder,
                                     progress,
                                     total)
{
    const color = [...closestColor];
    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    cLoop:
    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
       if (parse.stop()) break cLoop;

        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            if (parse.stop()) break cLoop;

            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                if (parse.stop()) break cLoop;

                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsOk(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    
                    if (!lockedOrder)
                        closestOrder = order;

                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;
                }

                progress++;
            }
        }

        
        if (parse.repeats.length == 1)
        {
            const stopRequestId = await genGetValueFromUi('stopRequestId');

            if (   parse.requestId == stopRequestId.value
                || curRequestIds.includes(parse.requestId)) 
            { 
                parse.stopGenerate = true;
                break; 
            }
        }


        genUpdateNodeProgress(parse, nodeId, progress / total, false);
    }

    
    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = correctColor(color, order, m1, m2, m3);
    const oklab  = dataColor2array(dataColor2oklab(_color));
    const rgb    = oklab2rgb(oklab);

    return [_color, oklab, rgb];
}



function correctColor(color, order, margin1, margin2, margin3)
{
    if (order < 0)
        return color;


    const [i1, i2, i3] = getCorrectionsInOrder(order);

                               color = correctChannel(color, i1, margin1);
    if (!dataColorIsOk(color)) color = correctChannel(color, i2, margin2);
    if (!dataColorIsOk(color)) color = correctChannel(color, i3, margin3);


    // clip colors that are reasonably valid but stick over the fence
    
    let rgb = dataColor2rgb(color);

    if (rgbIsOk(rgb))
        rgb = invalid2validRgb(rgb);
    
        
    color = convertDataColorToSpace(
        rgb2dataColor(rgb),
        color[0]);

        
    return color;
}



function correctChannel(color, iChan, margin)
{
    const factor = colorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsOk(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorOk(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorOk( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsOk(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorOk(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsOk(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorOk(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorOk(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsOk(color);
}



function getCorrectionsInOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }

    // should never get here
    consoleError('invalid correction order ' + order);
    return [0, 0, 0];
}



function getMinCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let min;

    switch (space)
    {
        case 'hex':
        case 'rgb':    min = [0, 0, 0]; break

        case 'hsv': 
        case 'hsl':    min = [0, 0, 0]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': min = [0, 0, 0]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    min = [0, -oppFactor[1]/2, -oppFactor[2]/2]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [min[c1], min[c2], min[c3]];
}



function getMaxCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let max;

    switch (space)
    {
        case 'hex':
        case 'rgb':    max = [...rgbFactor]; break;

        case 'hsv': 
        case 'hsl':    max = [hs_Factor[0]/2, hs_Factor[1], hs_Factor[2]]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': max = [hclFactor[0]/2, hclFactor[1], hclFactor[2]]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    max = [...oppFactor]; break;
        
        default:
            // should never get here
            consoleError('invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [max[c1], max[c2], max[c3]];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Epsilon
        && c2.closest <  Epsilon
        && c3.closest >= Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Epsilon
          && c2.closest <  Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getColorCorrections(colorSpace)
{
    switch (colorSpace)
    {
    case 'hex':
    case 'rgb':
        return [
            new ColorCorrection('R', rgbFactor[0]),
            new ColorCorrection('G', rgbFactor[1]),
            new ColorCorrection('B', rgbFactor[2]) ];

    case 'hsv':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('V', hs_Factor[2]) ];

    case 'hsl':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('L', hs_Factor[2]) ];

    case 'hclok':
    case 'hclab':
    case 'hcluv':
        return [
            new ColorCorrection('H', hclFactor[0]/2),
            new ColorCorrection('C', hclFactor[1]),
            new ColorCorrection('L', hclFactor[2]) ];

    case 'oklab': 
    case 'lab':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('a', oppFactor[1]),
            new ColorCorrection('b', oppFactor[2]) ];

    case 'luv':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('u', oppFactor[1]),
            new ColorCorrection('v', oppFactor[2]) ];
    }


    consoleError('invalid color space ' + colorSpace);
    return [
        new ColorCorrection(),
        new ColorCorrection(),
        new ColorCorrection() ];
}


class GColor
extends GOperator1
{
    space   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;

    hasInputs;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColor(this.nodeId, this.options);

        copy.copyBase(this);

        copy.space = this.space.copy();

        if (this.c1) copy.c1 = this.c1.copy();
        if (this.c2) copy.c2 = this.c2.copy();
        if (this.c3) copy.c3 = this.c3.copy();

        if (this.convert) 
            copy.convert = this.convert.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space = this.space ? (await this.space.eval(parse)).toValue().toInteger() : null; 
        let   c1    = this.c1    ? (await this.c1   .eval(parse)).toValue()             : null;
        let   c2    = this.c2    ? (await this.c2   .eval(parse)).toValue()             : null;
        let   c3    = this.c3    ? (await this.c3   .eval(parse)).toValue()             : null;

        //console.log('COLOR c3 =', c3.value);
        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (   input.isValid()
                && this.input.type != START)
            {
                if (this.options.enabled)
                {
                    this.value = input.copy();
                    

                    const fromSpaceIndex = input.space.value;

                    const toSpaceIndex = Math.min(Math.max(
                        0,
                        Math.round(space.value)), // round because a value can come in with decimals (TODO fix this)
                        colorSpaceCount(parse)-1);


                    if (toSpaceIndex != fromSpaceIndex)
                    {
                        this.convertColor(
                            this.value,
                            colorSpace(fromSpaceIndex), 
                            colorSpace(  toSpaceIndex));

                        this.value.space.value = toSpaceIndex;
                    }


                    if (!c1) c1 = this.value.c1;
                    if (!c2) c2 = this.value.c2;
                    if (!c3) c3 = this.value.c3;
                
                    if (c1) this.value.c1 = c1;
                    if (c2) this.value.c2 = c2;
                    if (c3) this.value.c3 = c3;
                }
                else
                    this.value = input;
            }
            else
                this.value = ColorValue.NaN;


            if (!this.convert)
                this.convert = NumberValue.NaN;
        }
        else
        {
            this.value = new ColorValue(space, c1, c2, c3);


            const toSpaceIndex = Math.min(Math.max(
                0,
                Math.round(this.value.space.value)), // round because a value can come in with decimals (TODO fix this)
                colorSpaceCount(parse)-1);

            this.value.space.value = toSpaceIndex;

            if (    this.convert
                &&  this.convert.isValid()
                &&  this.convert.value > -1
                &&  this.value.isValid()
                && !this.hasInputs)
            {
                await this.convert.eval(parse);

                this.convertColor(
                    this.value,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }
        }


        if (!this.value.space.isValid())
            this.value = new ColorValue(
                this.space.toValue(),
                NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN);


        this.setUpdateValues(parse,
        [
            ['convert', this.convert    ],
            ['space',   this.value.space],
            ['c1',      this.value.c1   ],
            ['c2',      this.value.c2   ],
            ['c3',      this.value.c3   ]
        ]);


        if (!this.c1) this.c1 = this.value.c1.copy();
        if (!this.c2) this.c2 = this.value.c2.copy();
        if (!this.c3) this.c3 = this.value.c3.copy();


        this.validate();

        return this;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2) ];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    toValue()
    {
        return this.options.enabled
             ? this.value.copy()
             : ColorValue.NaN;
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.space && this.space.isValid()
            && this.c1    && this.c1   .isValid()
            && this.c2    && this.c2   .isValid()
            && this.c3    && this.c3   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space) this.space.pushValueUpdates(parse);
        if (this.c1   ) this.c1   .pushValueUpdates(parse);
        if (this.c2   ) this.c2   .pushValueUpdates(parse);
        if (this.c3   ) this.c3   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.space) this.space.invalidateInputs(parse, from);
        if (this.c1   ) this.c1   .invalidateInputs(parse, from);
        if (this.c2   ) this.c2   .invalidateInputs(parse, from);
        if (this.c3   ) this.c3   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space) this.space.iterateLoop(parse);
        if (this.c1   ) this.c1   .iterateLoop(parse);
        if (this.c2   ) this.c2   .iterateLoop(parse);
        if (this.c3   ) this.c3   .iterateLoop(parse);
    }
}


class GValidColor
extends GOperator1
{
    quality      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(VALID_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GValidColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value  ) copy.value   = this.value  .copy();
        if (this.quality) copy.quality = this.quality.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const quality = this.quality ? (await this.quality.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                // if (   !isValid(this.value) 
                //     || !this.value.isValid()) 
                // {
                    let rgb = input.toRgb();

                    if (quality.value == 0) // clip sRGB
                    {
                        rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
                        rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
                        rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
                        
                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else if (quality.value == 1) // clip chroma
                    {
                        rgb = clipChroma(rgb);

                        rgb[0] = Math.round(rgb[0] * 0xff);   
                        rgb[1] = Math.round(rgb[1] * 0xff);   
                        rgb[2] = Math.round(rgb[2] * 0xff); 

                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else // find corrections
                    {
                        if (!rgbIsOk(rgb))
                            genInitNodeProgress(this.nodeId);
                        

                        const inputColor = input.toDataColor();


                        const
                      [ closestOrder,
                        closest1,
                        closest2,
                        closest3 ] = await findCorrection(
                            parse,
                            this.nodeId,
                            inputColor, 
                            quality, null,  null,  null, 
                            false,   false, false, false); 

                            
                        if (!parse.stopGenerate)
                        {
                            if (   closestOrder >= 0 
                                && closestOrder <  6)
                            {
                                this._color = correctColor(
                                    inputColor,
                                    closestOrder,
                                    closest1,
                                    closest2,
                                    closest3);

                                this.value = ColorValue.fromDataColor(this._color);
                            }
                            else
                            {
                                this.value = ColorValue.NaN;
                            }
                        }
                    }
                //}
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['quality', quality   ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.quality && this.quality.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.quality) this.quality.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.quality) this.quality.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.quality) this.quality.iterateLoop(parse);
    }
}



class GCorrectColor
extends GOperator1
{
    order        = null;
    margin1      = null;
    margin2      = null;
    margin3      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(CORRECT_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCorrectColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.order  ) copy.order   = this.order  .copy();
        if (this.margin1) copy.margin1 = this.margin1.copy();
        if (this.margin2) copy.margin2 = this.margin2.copy();
        if (this.margin3) copy.margin3 = this.margin3.copy();
        if (this.value  ) copy.value   = this.value  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const order   = this.order   ? (await this.order  .eval(parse)).toValue().toInteger() : null;
        const margin1 = this.margin1 ? (await this.margin1.eval(parse)).toValue()             : null;
        const margin2 = this.margin2 ? (await this.margin2.eval(parse)).toValue()             : null;
        const margin3 = this.margin3 ? (await this.margin3.eval(parse)).toValue()             : null;

    
        if (order)
            order.value = Math.min(Math.max(0, order.value), 5);


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                // if (   isValid(this.order  ) && this.order  .isValid()
                //     && isValid(this.margin1) && this.margin1.isValid()
                //     && isValid(this.margin2) && this.margin2.isValid()
                //     && isValid(this.margin3) && this.margin3.isValid()
                //     && isValid(this.value  ) && this.value  .isValid())
                // {
                //     genPushUpdateValue(parse, this.nodeId, 'order'  , this.order  );
                //     genPushUpdateValue(parse, this.nodeId, 'margin1', this.margin1);
                //     genPushUpdateValue(parse, this.nodeId, 'margin2', this.margin2);
                //     genPushUpdateValue(parse, this.nodeId, 'margin3', this.margin3);
                //     genPushUpdateValue(parse, this.nodeId, 'value'  , this.value  );
                // }
                // else
                // {
                    const rgb = input.toRgb();
                    
                    if (!rgbIsOk(rgb))
                        genInitNodeProgress(this.nodeId);


                    const inputColor = input.toDataColor();


                    const
                  [ closestOrder,
                    closest1,
                    closest2,
                    closest3 ] = await findCorrection(
                        parse,
                        this.nodeId,
                        inputColor, 
                        order, margin1, margin2, margin3, 
                        this.order   != null,
                        this.margin1 != null, 
                        this.margin2 != null, 
                        this.margin3 != null); 

                        
                    if (   !parse.stop()
                        && !parse.stopGenerate)
                    {
                        if (   closestOrder >= 0 
                            && closestOrder <  6)
                        {
                            this._color = correctColor(
                                inputColor,
                                closestOrder,
                                closest1,
                                closest2,
                                closest3);

                                
                            this.order   = new NumberValue(closestOrder);
                            this.margin1 = new NumberValue(closest1);
                            this.margin2 = new NumberValue(closest2);
                            this.margin3 = new NumberValue(closest3);
                            this.value   = ColorValue.fromDataColor(this._color);

                            this.setUpdateValues(parse,
                            [
                                ['order',   new NumberValue(closestOrder)],
                                ['margin1', new NumberValue(closest1    )],
                                ['margin2', new NumberValue(closest2    )],
                                ['margin3', new NumberValue(closest3    )],
                                ['value',   this.value                   ]
                            ]);
                        }
                        // else
                        // {
                        //     this.order   = NumberValue.NaN;
                        //     this.margin1 = NumberValue.NaN;
                        //     this.margin2 = NumberValue.NaN;
                        //     this.margin3 = NumberValue.NaN;
                        //     this.value   = ColorValue .NaN;

                        //     this.setUpdateValues(parse,
                        //     [
                        //         ['order',   NumberValue.NaN],
                        //         ['margin1', NumberValue.NaN],
                        //         ['margin2', NumberValue.NaN],
                        //         ['margin3', NumberValue.NaN],
                        //         ['value',   ColorValue .NaN]
                        //     ]);
                        // }
                    }
                    else
                    {
                        this.order   = NumberValue.NaN;
                        this.margin1 = NumberValue.NaN;
                        this.margin2 = NumberValue.NaN;
                        this.margin3 = NumberValue.NaN;
                        this.value   = input;
        
                        this.setUpdateValues(parse,
                        [
                            ['order'  , this.order  ],
                            ['margin1', this.margin1],
                            ['margin2', this.margin2],
                            ['margin3', this.margin3],
                            ['value',   this.value  ]
                        ]);
                    }
                //}
            }
            else
            {
                this.order   = NumberValue.NaN;
                this.margin1 = NumberValue.NaN;
                this.margin2 = NumberValue.NaN;
                this.margin3 = NumberValue.NaN;
                this.value   = input;

                this.setUpdateValues(parse,
                [
                    ['order'  , this.order  ],
                    ['margin1', this.margin1],
                    ['margin2', this.margin2],
                    ['margin3', this.margin3],
                    ['value',   this.value  ]
                ]);
            }
        }
        else
        {
            this.order   = NumberValue.NaN;
            this.margin1 = NumberValue.NaN;
            this.margin2 = NumberValue.NaN;
            this.margin3 = NumberValue.NaN;
            this.value   = ColorValue .NaN;

            this.setUpdateValues(parse,
            [
                ['order',   NumberValue.NaN],
                ['margin1', NumberValue.NaN],
                ['margin2', NumberValue.NaN],
                ['margin3', NumberValue.NaN],
                ['value',   ColorValue .NaN]
            ]);
        }


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.order   && this.order  .isValid()
            && this.margin1 && this.margin1.isValid()
            && this.margin2 && this.margin2.isValid()
            && this.margin3 && this.margin3.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.order  ) this.order  .pushValueUpdates(parse);
        if (this.margin1) this.margin1.pushValueUpdates(parse);
        if (this.margin2) this.margin2.pushValueUpdates(parse);
        if (this.margin3) this.margin3.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.order  ) this.order  .invalidateInputs(parse, from);
        if (this.margin1) this.margin1.invalidateInputs(parse, from);
        if (this.margin2) this.margin2.invalidateInputs(parse, from);
        if (this.margin3) this.margin3.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.order  ) this.order  .iterateLoop(parse);
        if (this.margin1) this.margin1.iterateLoop(parse);
        if (this.margin2) this.margin2.iterateLoop(parse);
        if (this.margin3) this.margin3.iterateLoop(parse);
    }
}



class GColorContrast
extends GOperator2
{
    standard = null;
    contrast = null;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorContrast(this.nodeId, this.options);

        copy.copyBase(this);

        copy.standard = this.standard.copy();
        copy.contrast = this.contrast.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const standard = (await this.standard.eval(parse)).toValue().toInteger();

        
        if (standard.isValid())
            standard.value = Math.min(Math.max(0, standard.value), 1);


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();


            if (   input0.isValid()
                && input1.isValid())
            {
                if (   dataColorIsValid(input0.toDataColor())
                    && dataColorIsValid(input1.toDataColor()))
                {
                    if (standard.value == 0)
                    {
                        const value = getContrastRatio2(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 2);
                    }
                    else
                    {
                        const value = getContrastRatio3(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 1);
                    }
                }
                else
                    this.contrast = NumberValue.NaN;
            }
            else
                this.contrast = NumberValue.NaN;


            this.value = input0 ? input0.copy() : ColorValue.NaN;


            this.setUpdateValues(parse,
            [
                ['text', input0],
                ['back', input1]
            ]);
        }

        else if (this.input0) 
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.setUpdateValues(parse,
            [
                ['text', input0.isValid() ? input0 : ColorValue.NaN],
                ['back', ColorValue.NaN                            ]
            ]);
            
            this.value    = input0.copy();
            this.contrast = NumberValue.NaN;
        }

        else if (this.input1) 
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN                            ],
                ['back', input1.isValid() ? input1 : ColorValue.NaN]
            ]);

            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else
        {
            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;

            this.setUpdateValues(parse,
            [
                ['text', ColorValue.NaN],
                ['back', ColorValue.NaN]
            ]);
        }
        


        this.setUpdateValues(parse,
        [
            ['standard', standard     ],
            ['contrast', this.contrast]
        ],
        true);


        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.standard && this.standard.isValid()
            && (!this.contrast || this.contrast.isValid());
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.standard) this.standard.pushValueUpdates(parse);
        if (this.contrast) this.contrast.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.standard) this.standard.invalidateInputs(parse, from);
        if (this.contrast) this.contrast.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.standard) this.standard.iterateLoop(parse);
        if (this.contrast) this.contrast.iterateLoop(parse);
    }
}



class GConvertP3
extends GOperator1
{
    from = null;



    constructor(nodeId, options)
    {
        super(COLOR_CONVERT_P3, nodeId, options);
    }


    
    copy()
    {
        const copy = new GConvertP3(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.from ) copy.from  = this.from .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const from = this.from ? (await this.from.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            if (this.options.enabled)
            {
                this.value = ColorValue.fromRgb(
                    from.value == 0 
                    ? scaleRgb(srgb2p3(input.toRgb()))
                    : scaleRgb(p32srgb(input.toRgb())));
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        
        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['quality', from      ]
        ]);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.from && this.from.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.from) this.from.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from) this.from.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.from) this.from.iterateLoop(parse);
    }
}



class GColorBlind
extends GOperator1
{
    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlind(this.nodeId, this.options);

        copy.copyBase(this);

        copy.l = this.l.copy();
        copy.m = this.m.copy();
        copy.s = this.s.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const l = (await this.l.eval(parse)).toValue();        
        const m = (await this.m.eval(parse)).toValue();
        const s = (await this.s.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            const rgb   = input.toRgb();

            if (this.options.enabled)
            {
                const rgbCb = rgb2colorblind(
                    rgb,
                    l.value / 2,
                    m.value / 2,
                    s.value / 2);

                if (   !rgbIsNaN(rgb)
                    && !rgbIsNaN(rgbCb))
                {
                    const validRgbCb = rgbCb;
                
                    const validCol = convertDataColorToSpace(
                        rgb2dataColor(validRgbCb), 
                        colorSpace(input.space.value));

                    this.value = ColorValue.fromDataColor(validCol);
                }
                else
                    this.value = ColorValue.NaN;
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['l',     l         ],
            ['m',     m         ],
            ['s',     s         ],
            ['value', this.value]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.l && this.l.isValid()
            && this.m && this.m.isValid()
            && this.s && this.s.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.l) this.l.pushValueUpdates(parse);
        if (this.m) this.m.pushValueUpdates(parse);
        if (this.s) this.s.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.l) this.l.invalidateInputs(parse, from);
        if (this.m) this.m.invalidateInputs(parse, from);
        if (this.s) this.s.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.l) this.l.iterateLoop(parse);
        if (this.m) this.m.iterateLoop(parse);
        if (this.s) this.s.iterateLoop(parse);
    }
}



class GColorInterpolate
extends GOperator2
{
    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        copy.space  = this.space .copy();
        copy.amount = this.amount.copy();
        copy.gamma  = this.gamma .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space  = (await this.space .eval(parse)).toValue().toInteger();
        const amount = (await this.amount.eval(parse)).toValue();
        const gamma  = (await this.gamma .eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            consoleAssert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const f = amount.value / 100;


            const spaceIndex = Math.min(Math.max(0, space.value), colorSpaceCount()-1);
            const gammaValue = Math.max(0.0001, gamma.value);

            const _space = colorSpace(spaceIndex);

            const _color = this.interpolate(
                spaceIndex,
                convertDataColorToSpace(input0.toDataColor(), _space),
                convertDataColorToSpace(input1.toDataColor(), _space),
                f,
                gammaValue);


            // allow interpolating invalid colors,
            // so no valid color check here

            this.value = ColorValue.fromDataColor(_color, spaceIndex);
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['space',  space     ],
            ['amount', amount    ],
            ['gamma',  gamma     ],
            ['value',  this.value]
        ]);
        

        this.validate();
        
        return this;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (   space <= 1
            || space >  6) // hex, rgb, okLab, lab, luv
        {
            gamma = Math.max(0.01, gamma);

            const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);  
            const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);  
            const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);  

            const r1 = Math.sign(col1[1]) * Math.pow(Math.abs(col1[1]), gamma);
            const g1 = Math.sign(col1[2]) * Math.pow(Math.abs(col1[2]), gamma);
            const b1 = Math.sign(col1[3]) * Math.pow(Math.abs(col1[3]), gamma);

            const r = lerp(r0, r1, f);        
            const g = lerp(g0, g1, f);            
            const b = lerp(b0, b1, f);        

            return [
                colorSpace(space),
                Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),
                Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),
                Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }



    isValid()
    {
        return super.isValid()
            && this.space  && this.space .isValid()
            && this.amount && this.amount.isValid()
            && this.gamma  && this.gamma .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.space ) this.space .pushValueUpdates(parse);
        if (this.amount) this.amount.pushValueUpdates(parse);
        if (this.gamma ) this.gamma .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.space ) this.space .invalidateInputs(parse, from);
        if (this.amount) this.amount.invalidateInputs(parse, from);
        if (this.gamma ) this.gamma .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.space ) this.space .iterateLoop(parse);
        if (this.amount) this.amount.iterateLoop(parse);
        if (this.gamma ) this.gamma .iterateLoop(parse);
    }
}



class GColorBlend
extends GOperator2
{
    mode;
    opacity;
    

    constructor(nodeId, options)
    {
        super(COLOR_BLEND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlend(this.nodeId, this.options);

        copy.copyBase(this);

        copy.mode    = this.mode   .copy();
        copy.opacity = this.opacity.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const mode    = (await this.mode   .eval(parse)).toValue().toInteger();
        const opacity = (await this.opacity.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            consoleAssert(
                opacity.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const _opacity = opacity.value / 100;

            const modeIndex = Math.min(Math.max(0, mode.value), BlendModes.length-1);


            const col = this.blend(
                modeIndex,
                input0.toRgb(),
                input1.toRgb(),
                _opacity);

            this.value = ColorValue.fromRgb(scaleRgb(col));
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['mode',    mode      ],
            ['opacity', opacity   ]
        ]);


        this.validate();
        
        return this;
    }



    blend(mode, col0, col1, opacity)
    {
        switch (mode)
        {
            case  0: return blendNormal    (col0, col1, opacity);

            case  1: return blendDarken    (col0, col1, opacity);
            case  2: return blendMultiply  (col0, col1, opacity);
            case  3: return blendColorBurn (col0, col1, opacity);

            case  4: return blendLighten   (col0, col1, opacity);
            case  5: return blendScreen    (col0, col1, opacity);
            case  6: return blendColorDodge(col0, col1, opacity);

            case  7: return blendOverlay   (col0, col1, opacity);
            case  8: return blendSoftLight (col0, col1, opacity);
            case  9: return blendHardLight (col0, col1, opacity);

            case 10: return blendDifference(col0, col1, opacity);
            case 11: return blendExclusion (col0, col1, opacity);

            case 12: return blendHue       (col0, col1, opacity);
            case 13: return blendSaturation(col0, col1, opacity);
            case 14: return blendColor     (col0, col1, opacity);
            case 15: return blendLuminosity(col0, col1, opacity);
        }
    }



    isValid()
    {
        return super.isValid()
            && this.mode    && this.mode   .isValid()
            && this.opacity && this.opacity.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.mode   ) this.mode   .pushValueUpdates(parse);
        if (this.opacity) this.opacity.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.mode   ) this.mode   .invalidateInputs(parse, from);
        if (this.opacity) this.opacity.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.mode   ) this.mode   .iterateLoop(parse);
        if (this.opacity) this.opacity.iterateLoop(parse);
    }
}



function blendNormal(col, back, opacity)
{
    return [ col[0] * opacity + back[0] * (1 - opacity),
             col[1] * opacity + back[1] * (1 - opacity),
             col[2] * opacity + back[2] * (1 - opacity) ];
}



function blendDarken(col, back, opacity)
{
    return blendNormal(
        [ Math.min(back[0], col[0]),
          Math.min(back[1], col[1]),
          Math.min(back[2], col[2]) ],
        back,
        opacity);
}



function chanMultiply(c, b)
{
    return c * b;
}



function blendMultiply(col, back, opacity)
{
    return blendNormal(
        [ chanMultiply(col[0], back[0]),
          chanMultiply(col[1], back[1]),
          chanMultiply(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorBurn(c, b)
{
         if (b == 1) return 1;
    else if (c == 0) return 0;
    else             return 1 - Math.min((1 - b) / c, 1);
}



function blendColorBurn(col, back, opacity)
{
    return blendNormal(
         [ chanColorBurn(col[0], back[0]),
           chanColorBurn(col[1], back[1]),
           chanColorBurn(col[2], back[2]) ],
        back,
        opacity);
}



function blendLighten(col, back, opacity)
{
    return blendNormal(
        [ Math.max(back[0], col[0]),
          Math.max(back[1], col[1]),
          Math.max(back[2], col[2]) ],
        back,
        opacity);
}



function chanScreen(c, b)
{
    return b + c - b*c;
}



function blendScreen(col, back, opacity)
{
    return blendNormal(
        [ chanScreen(col[0], back[0]),
          chanScreen(col[1], back[1]),
          chanScreen(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorDodge(c, b)
{
         if (b == 0) return 0;
    else if (c == 1) return 1;
    else             return Math.min(b / (1 - c), 1);
}



function blendColorDodge(col, back, opacity)
{
    return blendNormal(
        [ chanColorDodge(col[0], back[0]),
          chanColorDodge(col[1], back[1]),
          chanColorDodge(col[2], back[2]) ],
        back,
        opacity);
}



function blendOverlay(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(back[0], col[0]),
          chanHardLight(back[1], col[1]),
          chanHardLight(back[2], col[2]) ],
        back,
        opacity);
}



function bSL_D(b)
{
    return b <= 0.25
         ? ((16 * b - 12) * b + 4) * b
         : Math.sqrt(b);
}



function chanSoftLight(c, b)
{
    return c <= 0.5
         ? b - (1 - 2*c) * b * (1 - b)
         : b + (2*c - 1) * (bSL_D(b) - b);
}



function blendSoftLight(col, back, opacity)
{
    return blendNormal(
        [ chanSoftLight(col[0], back[0]),
          chanSoftLight(col[1], back[1]),
          chanSoftLight(col[2], back[2]) ],
        back,
        opacity);
}



function chanHardLight(c, b)
{
    if (c <= 0.5) return chanMultiply(b, 2 * c);
    else          return chanScreen(b, 2 * c - 1);
}



function blendHardLight(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(col[0], back[0]),
          chanHardLight(col[1], back[1]),
          chanHardLight(col[2], back[2]) ],
        back,
        opacity);
}



function blendDifference(col, back, opacity)
{
    return [ Math.abs(back[0] - col[0]),
             Math.abs(back[1] - col[1]),
             Math.abs(back[2] - col[2]) ];
}



function chanExclusion(c, b)
{
    return b + c - 2*b*c;
}



function blendExclusion(col, back, opacity)
{
    return blendNormal(
        [ chanExclusion(col[0], back[0]),
          chanExclusion(col[1], back[1]),
          chanExclusion(col[2], back[2]) ],
        back,
        opacity);
}



function bl_lum(col)
{
    return col[0] * 0.30
         + col[1] * 0.59
         + col[2] * 0.11;
}



function bl_setLum(_col, l)
{
    const col = [..._col];

    const d = l - bl_lum(col);

    col[0] += d;
    col[1] += d;
    col[2] += d;

    return bl_clamp(col);
}



function bl_sat(col)
{
    return Math.max(col[0], col[1], col[2]) 
         - Math.min(col[0], col[1], col[2]);
}



function bl_min(col)
{
         if (col[0] <= col[1] 
          && col[0] <= col[2]) return 0;
    else if (col[1] <= col[1] 
          && col[1] <= col[2]) return 1;
    else                       return 2;
}



function bl_mid(col)
{
         if (   col[0] >= col[1] 
             && col[0] <= col[2]
          ||    col[0] <= col[1] 
             && col[0] >= col[2]) return 0;
    else if (   col[1] >= col[0] 
             && col[1] <= col[2]
          ||    col[1] <= col[0] 
             && col[1] >= col[2]) return 1;
    else                          return 2;
}



function bl_max(col)
{
         if (col[0] >= col[1] 
          && col[0] >= col[2]) return 0;
    else if (col[1] >= col[1] 
          && col[1] >= col[2]) return 1;
    else                       return 2;
}



function bl_ndx(col) // get min/mid/max chan indices
{
    if (   col[0] == col[1] 
        && col[0] == col[2])
        return [0, 1, 2];

    else 
        return [
            bl_min(col), 
            bl_mid(col), 
            bl_max(col)];
}



function bl_setSat(_col, s)
{
    const col       = [..._col];
    const [n, d, x] = bl_ndx(col);

    if (col[x] > col[n])
    {
        col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));
        col[x] = s;
    }
    else
        col[d] = col[x] = 0;

    col[n] = 0;

    return col;
}



function bl_chanClamp(c, l, n, x)
{
         if (n < 0) return l + (((c - l) * l) / (l - n));
    else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));
    else            return c;
}



function bl_clamp(col)
{
    const l   = bl_lum(col);

    const n = Math.min(col[0], col[1], col[2]);
    const x = Math.max(col[0], col[1], col[2]);

    return [ bl_chanClamp(col[0], l, n, x),
             bl_chanClamp(col[1], l, n, x),
             bl_chanClamp(col[2], l, n, x) ];
}



function blendHue(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(col, bl_sat(back)), bl_lum(back)),
        back,
        opacity);
}



function blendSaturation(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(back, bl_sat(col)), bl_lum(back)),
        back,
        opacity);
}



function blendColor(col, back, opacity)
{
    return blendNormal(
        bl_setLum(col, bl_lum(back)),
        back,
        opacity);
}



function blendLuminosity(col, back, opacity)
{
    return blendNormal(
        bl_setLum(back, bl_lum(col)),
        back,
        opacity);
}


class GColorStyle
extends GOperator
{
    id;

    colorStyle;
    genValue;

    //existing;
    linked;



    constructor(nodeId, options, styleId)
    {
        super(COLOR_STYLE, nodeId, options);

        this.id == styleId;
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        copy.id         = this.id;
        copy.colorStyle = this.colorStyle.copy();
        copy.genValue   = this.genValue  .copy();
        
        //copy.existing   = this.existing;
        copy.linked     = this.linked;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        this.value = (await this.genValue.eval(parse)).toValue();


        if (   this.value.isValid()
            && this.linked)
            // (  !this.existing
            //     || this.linked))
        {
            if (this.value.type == COLOR_VALUE)
                this.value = FillValue.fromRgb(scaleRgb(this.value.toRgb()), 0xff);

            const rgba       = this.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            this.evalStyle({rgba: rgbaStripe});
        }
        else
            this.value = FillValue.NaN;


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    evalStyle(options = {})
    {
        if (!this.options.enabled)
            return;

            
        const colorStyle = new FigmaColorStyle(this.nodeId, this.id, this.name);

        //colorStyle.existing = this.existing;


        colorStyle.paints = 
        [
            [ 'SOLID', 
                      Math.round(options.rgba[0] * 0xff)
              + ' ' + Math.round(options.rgba[1] * 0xff)
              + ' ' + Math.round(options.rgba[2] * 0xff)
              + ' ' + Math.round(options.rgba[3] * 100 ) ]
        ];


        this.colorStyle = colorStyle;
    }



    isValid()
    {
        return this.genValue && this.genValue.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.genValue) this.genValue.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.genValue) this.genValue.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.genValue) this.genValue.iterateLoop(parse);
    }
}


class GFill
extends GOperator1
{
    color   = null;
    opacity = null;
    blend   = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    copy()
    {
        const copy = new GFill(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.color  ) copy.color   = this.color  .copy();
        if (this.opacity) copy.opacity = this.opacity.copy();
        if (this.blend  ) copy.blend   = this.blend  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let color   = this.color   ? (await this.color  .eval(parse)).toValue() : null;
        let opacity = this.opacity ? (await this.opacity.eval(parse)).toValue() : null;
        let blend   = this.blend   ? (await this.blend  .eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new FillValue(
                color   ?? input.color,
                opacity ?? input.opacity,
                blend   ?? input.blend);
        }
        else
        {
            this.value = new FillValue(
                color, 
                opacity,
                blend);
        }


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['color',   color     ],
            ['opacity', opacity   ],
            ['blend',   blend     ]
        ]);
        

        if (!this.color  ) this.color   = this.value.color  .copy();
        if (!this.opacity) this.opacity = this.value.opacity.copy();
        if (!this.blend  ) this.blend   = this.value.blend  .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.options.enabled
            ? new FillValue(
                this.color   ? this.color  .toValue() : this.input.value.color  .toValue(),
                this.opacity ? this.opacity.toValue() : this.input.value.opacity.toValue(),
                this.blend   ? this.blend  .toValue() : this.input.value.blend  .toValue())
            : FillValue.NaN;
    }



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.color   && this.color  .isValid()
            && this.opacity && this.opacity.isValid()
            && this.blend   && this.blend  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.color  ) this.color  .pushValueUpdates(parse);
        if (this.opacity) this.opacity.pushValueUpdates(parse);
        if (this.blend  ) this.blend  .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.color  ) this.color  .invalidateInputs(parse, from);
        if (this.opacity) this.opacity.invalidateInputs(parse, from);
        if (this.blend  ) this.blend  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.color  ) this.color  .iterateLoop(parse);
        if (this.opacity) this.opacity.iterateLoop(parse);
        if (this.blend  ) this.blend  .iterateLoop(parse);
    }
}


class GColorStop
extends GOperator1
{
    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }



    copy()
    {
        const copy = new GColorStop(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fill    ) copy.fill     = this.fill    .copy();
        if (this.position) copy.position = this.position.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fill = this.fill ? (await this.fill.eval(parse)).toValue() : null;

        fill = this.validateFill(fill);


        const position = this.position ? (await this.position.eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new ColorStopValue(
                fill     ?? input.fill,
                position ?? input.position);
        }
        else
        {
            this.value = new ColorStopValue(
                fill, 
                position);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);
        

        if (!this.fill    ) this.fill     = this.value.fill    .copy();
        if (!this.position) this.position = this.value.position.copy();


        this.validate();

        return this;
    }



    validateFill(fill)
    {
        if (!fill)
            return null;


        if (fill.type == COLOR_VALUE)
            return FillValue.fromRgb(scaleRgb(fill.toRgb()), 100);
        else
            return fill;
    }



    toValue()
    {
        return new ColorStopValue(
            this.options.enabled
            ? this.validateFill(this.fill ? this.fill.toValue() : this.input.fill.toValue())
            : FillValue.NaN,
            this.position ? this.position.toValue() : this.input.position.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fill     && this.fill    .isValid()
            && this.position && this.position.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.fill    ) this.fill    .pushValueUpdates(parse);
        if (this.position) this.position.pushValueUpdates(parse);
    }    

    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.fill    ) this.fill    .invalidateInputs(parse, from);
        if (this.position) this.position.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.fill    ) this.fill    .iterateLoop(parse);
        if (this.position) this.position.iterateLoop(parse);
    }
}


class GGradient
extends GOperator
{
    inputs = [];

    gradType = null;
    x        = null;
    y        = null;
    size     = null;
    angle    = null;
    aspect   = null;
    skew     = null;
    blend    = null;



    constructor(nodeId, options)
    {
        super(GRADIENT, nodeId, options);
    }



    copy()
    {
        const copy = new GGradient(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.gradType) copy.gradType = this.x     .copy();
        if (this.x       ) copy.x        = this.x     .copy();
        if (this.y       ) copy.y        = this.y     .copy();
        if (this.size    ) copy.size     = this.size  .copy();
        if (this.angle   ) copy.angle    = this.angle .copy();
        if (this.aspect  ) copy.aspect   = this.aspect.copy();
        if (this.skew    ) copy.skew     = this.skew  .copy();
        if (this.blend   ) copy.blend    = this.blend .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        const gradType = this.gradType ? (await this.gradType.eval(parse)).toValue() : null;
        const x        = this.x        ? (await this.x       .eval(parse)).toValue() : null;
        const y        = this.y        ? (await this.y       .eval(parse)).toValue() : null;
        const size     = this.size     ? (await this.size    .eval(parse)).toValue() : null;
        const angle    = this.angle    ? (await this.angle   .eval(parse)).toValue() : null;
        const aspect   = this.aspect   ? (await this.aspect  .eval(parse)).toValue() : null;
        const skew     = this.skew     ? (await this.skew    .eval(parse)).toValue() : null;
        const blend    = this.blend    ? (await this.blend   .eval(parse)).toValue() : null;


        const stops = new ListValue();

        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);
            stops.items.push(this.inputs[i].toValue());
        }


        this.value = new GradientValue(
            stops,
            gradType,
            x, 
            y, 
            size, 
            angle, 
            aspect,
            skew,
            blend);

            
        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);
        

        if (!this.gradType) this.gradType = this.value.gradType.copy();
        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.size    ) this.size     = this.value.size    .copy();
        if (!this.angle   ) this.angle    = this.value.angle   .copy();
        if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();
        if (!this.skew    ) this.skew     = this.value.skew    .copy();
        if (!this.blend   ) this.blend    = this.value.blend   .copy();


        this.validate();

        return this;
    }

    
    
    toValue()
    {
        const stops = new ListValue();

        for (let i = 0, o = 0; i < this.inputs.length; i++)
            stops.items.push(this.inputs[i].toValue());


        return new GradientValue(
            stops,
            this.gradType ? this.gradType.toValue() : this.input.gradType.toValue(),
            this.x        ? this.x       .toValue() : this.input.x       .toValue(),
            this.y        ? this.y       .toValue() : this.input.y       .toValue(),
            this.size     ? this.size    .toValue() : this.input.size    .toValue(),
            this.angle    ? this.angle   .toValue() : this.input.angle   .toValue(),
            this.aspect   ? this.aspect  .toValue() : this.input.aspect  .toValue(),
            this.skew     ? this.skew    .toValue() : this.input.skew    .toValue(),
            this.blend    ? this.blend   .toValue() : this.input.blend   .toValue());
    }                 



    isValid()
    {
        return !this.inputs.find(i => !i.isValid())
            && this.gradType && this.gradType.isValid()
            && this.x        && this.x       .isValid()
            && this.y        && this.y       .isValid()
            && this.size     && this.size    .isValid()
            && this.angle    && this.angle   .isValid()
            && this.aspect   && this.aspect  .isValid()
            && this.skew     && this.skew    .isValid()
            && this.blend    && this.blend   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.gradType) this.gradType.pushValueUpdates(parse);
        if (this.x       ) this.x       .pushValueUpdates(parse);
        if (this.y       ) this.y       .pushValueUpdates(parse);
        if (this.size    ) this.size    .pushValueUpdates(parse);
        if (this.angle   ) this.angle   .pushValueUpdates(parse);
        if (this.aspect  ) this.aspect  .pushValueUpdates(parse);
        if (this.skew    ) this.skew    .pushValueUpdates(parse);
        if (this.blend   ) this.blend   .pushValueUpdates(parse);
    }    



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
        
        if (this.gradType) this.gradType.invalidateInputs(parse, from);
        if (this.x       ) this.x       .invalidateInputs(parse, from);
        if (this.y       ) this.y       .invalidateInputs(parse, from);
        if (this.size    ) this.size    .invalidateInputs(parse, from);
        if (this.angle   ) this.angle   .invalidateInputs(parse, from);
        if (this.aspect  ) this.aspect  .invalidateInputs(parse, from);
        if (this.skew    ) this.skew    .invalidateInputs(parse, from);
        if (this.blend   ) this.blend   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.gradType) this.gradType.iterateLoop(parse);
        if (this.x       ) this.x       .iterateLoop(parse);
        if (this.y       ) this.y       .iterateLoop(parse);
        if (this.size    ) this.size    .iterateLoop(parse);
        if (this.angle   ) this.angle   .iterateLoop(parse);
        if (this.aspect  ) this.aspect  .iterateLoop(parse);
        if (this.skew    ) this.skew    .iterateLoop(parse);
        if (this.blend   ) this.blend   .iterateLoop(parse);
    }    
}


class GStroke
extends GOperator1
{
    fills  = null;
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;
    cap    = null;
    dashes = null;



    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }



    copy()
    {
        const copy = new GStroke(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.fills ) copy.fills  = this.fills .copy();
        if (this.weight) copy.weight = this.weight.copy();
        if (this.fit   ) copy.fit    = this.fit   .copy();
        if (this.join  ) copy.join   = this.join  .copy();
        if (this.miter ) copy.miter  = this.miter .copy();
        if (this.cap   ) copy.cap    = this.cap   .copy();
        if (this.dashes) copy.dashes = this.dashes.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fills = this.fills ? (await this.fills.eval(parse)).toValue() : null;

        fills = this.validateFills(fills);


        const weight = this.weight ? (await this.weight.eval(parse)).toValue() : null;
        const fit    = this.fit    ? (await this.fit   .eval(parse)).toValue() : null;
        const join   = this.join   ? (await this.join  .eval(parse)).toValue() : null;
        const miter  = this.miter  ? (await this.miter .eval(parse)).toValue() : null;
        const cap    = this.cap    ? (await this.cap   .eval(parse)).toValue() : null;
        const dashes = this.dashes ? (await this.dashes.eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new StrokeValue(
                fills  ?? input.fills,
                weight ?? input.weight,
                fit    ?? input.fit,
                join   ?? input.join,
                miter  ?? input.miter,
                cap    ?? input.cap,
                dashes ?? input.dashes);
        }
        else
        {
            this.value = new StrokeValue(
                fills, 
                weight, 
                fit, 
                join,
                miter,
                cap,
                dashes);
        }


        if (!this.fills ) this.fills  = this.value.fills .copy();
        if (!this.weight) this.weight = this.value.weight.copy();
        if (!this.fit   ) this.fit    = this.value.fit   .copy();
        if (!this.join  ) this.join   = this.value.join  .copy();
        if (!this.miter ) this.miter  = this.value.miter .copy();
        if (!this.cap   ) this.cap    = this.value.cap   .copy();
        if (!this.dashes) this.dashes = this.value.dashes.copy();


        this.setUpdateValues(parse,
            [
                ['value',  this.value],
                ['fills',  fills     ],
                ['weight', weight    ],
                ['fit',    fit       ],
                ['join',   join      ],
                ['miter',  miter     ],
                ['cap',    cap       ],
                ['dashes', dashes    ]
            ]);


        this.validate();

        return this;
    }



    validateFills(fills)
    {
        if (!fills)
            return null;

            
        if (fills.type == COLOR_VALUE)
            return new ListValue([FillValue.fromRgb(scaleRgb(fills.toRgb()), 255)]);

        else if (fills.type ==     FILL_VALUE
              || fills.type == GRADIENT_VALUE)
            return new ListValue([fills]);
        else
        {
            consoleAssert(fills.type == LIST_VALUE, 'stroke.fills must be a LIST_VALUE');
            return fills;
        }
    }



    toValue()
    {
        return new StrokeValue(
            this.options.enabled
            ? this.validateFills(this.fills ? this.fills.toValue() : this.input.fills.toValue())
            : new ListValue(),
            this.weight ? this.weight.toValue() : this.input.weight.toValue(),
            this.fit    ? this.fit   .toValue() : this.input.fit   .toValue(),
            this.join   ? this.join  .toValue() : this.input.join  .toValue(),
            this.miter  ? this.miter .toValue() : this.input.miter .toValue(),
            this.cap    ? this.cap   .toValue() : this.input.cap   .toValue(),
            this.dashes ? this.dashes.toValue() : this.input.dashes.toValue());
    }                 



    isValid()
    {
        return (!this.input || this.input.isValid())
            && this.fills  && this.fills .isValid()
            && this.weight && this.weight.isValid()
            && this.fit    && this.fit   .isValid()
            && this.join   && this.join  .isValid()
            && this.miter  && this.miter .isValid()
            && this.cap    && this.cap   .isValid()
            && this.dashes && this.dashes.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.fills ) this.fills .pushValueUpdates(parse);
        if (this.weight) this.weight.pushValueUpdates(parse);
        if (this.fit   ) this.fit   .pushValueUpdates(parse);
        if (this.join  ) this.join  .pushValueUpdates(parse);
        if (this.miter ) this.miter .pushValueUpdates(parse);
        if (this.cap   ) this.cap   .pushValueUpdates(parse);
        if (this.dashes) this.dashes.pushValueUpdates(parse);
    }    
    
    

    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.fills ) this.fills .invalidateInputs(parse, from);
        if (this.weight) this.weight.invalidateInputs(parse, from);
        if (this.fit   ) this.fit   .invalidateInputs(parse, from);
        if (this.join  ) this.join  .invalidateInputs(parse, from);
        if (this.miter ) this.miter .invalidateInputs(parse, from);
        if (this.cap   ) this.cap   .invalidateInputs(parse, from);
        if (this.dashes) this.dashes.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.fills ) this.fills .iterateLoop(parse);
        if (this.weight) this.weight.iterateLoop(parse);
        if (this.fit   ) this.fit   .iterateLoop(parse);
        if (this.join  ) this.join  .iterateLoop(parse);
        if (this.miter ) this.miter .iterateLoop(parse);
        if (this.cap   ) this.cap   .iterateLoop(parse);
        if (this.dashes) this.dashes.iterateLoop(parse);
    }    
}


class GDropShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;
    behind = null;



    constructor(nodeId, options)
    {
        super(DROP_SHADOW, nodeId, options);
    }



    copy()
    {
        const copy = new GDropShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();
        if (this.behind) copy.behind = this.behind.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const blur   = this.blur   ? (await this.blur  .eval(parse)).toValue() : null;
        const spread = this.spread ? (await this.spread.eval(parse)).toValue() : null;
        let   fill   = this.fill   ? (await this.fill  .eval(parse)).toValue() : null;
        const blend  = this.blend  ? (await this.blend .eval(parse)).toValue() : null;
        const behind = this.behind ? (await this.behind.eval(parse)).toValue() : null;


        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new DropShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                behind ?? input.behind,
                this.options.enabled);
        }
        else
        {
            this.value = new DropShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend, 
                behind,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
            ['behind', this.value.behind]
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();
        if (!this.behind) this.behind = this.value.behind.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid()
            && this.behind && this.behind.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
        if (this.behind) this.behind.pushValueUpdates(parse);
    }
    
    
    
   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x     ) this.x     .invalidateInputs(parse, from);
        if (this.y     ) this.y     .invalidateInputs(parse, from);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from);
        if (this.spread) this.spread.invalidateInputs(parse, from);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from);
        if (this.blend ) this.blend .invalidateInputs(parse, from);
        if (this.behind) this.behind.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
        if (this.behind) this.behind.iterateLoop(parse);
    }
}


class GInnerShadow
extends GOperator1
{
    x      = null;
    y      = null;
    blur   = null;
    spread = null;
    fill   = null;
    blend  = null;



    constructor(nodeId, options)
    {
        super(INNER_SHADOW, nodeId, options);
    }



    copy()
    {
        const copy = new GInnerShadow(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.blur  ) copy.blur   = this.blur  .copy();
        if (this.spread) copy.spread = this.spread.copy();
        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.blend ) copy.blend  = this.blend .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const blur   = this.blur   ? (await this.blur  .eval(parse)).toValue() : null;
        const spread = this.spread ? (await this.spread.eval(parse)).toValue() : null;
        let   fill   = this.fill   ? (await this.fill  .eval(parse)).toValue() : null;
        const blend  = this.blend  ? (await this.blend .eval(parse)).toValue() : null;

        
        if (   fill
            && fill.type == COLOR_VALUE)
            fill = new FillValue(fill);


         if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new InnerShadowValue(
                x      ?? input.x,
                y      ?? input.y,
                blur   ?? input.blur,
                spread ?? input.spread,
                fill   ?? input.fill,
                blend  ?? input.blend,
                this.options.enabled);
        }
        else
        {
            this.value = new InnerShadowValue(
                x, 
                y, 
                blur, 
                spread, 
                fill, 
                blend,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['x',      this.value.x     ],
            ['y',      this.value.y     ],
            ['blur',   this.value.blur  ],
            ['spread', this.value.spread],
            ['fill',   this.value.fill  ],
            ['blend',  this.value.blend ],
        ]);
        

        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.blur  ) this.blur   = this.value.blur  .copy();
        if (!this.spread) this.spread = this.value.spread.copy();
        if (!this.fill  ) this.fill   = this.value.fill  .copy();
        if (!this.blend ) this.blend  = this.value.blend .copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.blur   && this.blur  .isValid()
            && this.spread && this.spread.isValid()
            && this.fill   && this.fill  .isValid()
            && this.blend  && this.blend .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.blur  ) this.blur  .pushValueUpdates(parse);
        if (this.spread) this.spread.pushValueUpdates(parse);
        if (this.fill  ) this.fill  .pushValueUpdates(parse);
        if (this.blend ) this.blend .pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x     ) this.x     .invalidateInputs(parse, from);
        if (this.y     ) this.y     .invalidateInputs(parse, from);
        if (this.blur  ) this.blur  .invalidateInputs(parse, from);
        if (this.spread) this.spread.invalidateInputs(parse, from);
        if (this.fill  ) this.fill  .invalidateInputs(parse, from);
        if (this.blend ) this.blend .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.blur  ) this.blur  .iterateLoop(parse);
        if (this.spread) this.spread.iterateLoop(parse);
        if (this.fill  ) this.fill  .iterateLoop(parse);
        if (this.blend ) this.blend .iterateLoop(parse);
    }
}


class GLayerBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(LAYER_BLUR, nodeId, options);
    }



    copy()
    {
        const copy = new GLayerBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const radius = this.radius ? (await this.radius.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new LayerBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new LayerBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new LayerBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.radius) this.radius.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GBackBlur
extends GOperator1
{
    radius = null;



    constructor(nodeId, options)
    {
        super(BACK_BLUR, nodeId, options);
    }



    copy()
    {
        const copy = new GBackBlur(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.radius) copy.radius = this.radius.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const radius = this.radius ? (await this.radius.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new BackBlurValue(
                radius ?? input.radius,
                this.options.enabled);
        }
        else
        {
            this.value = new BackBlurValue(
                radius,
                this.options.enabled);
        }


        this.setUpdateValues(parse,
        [
            ['radius', this.value.radius]
        ]);
        

        if (!this.radius) this.radius = this.value.radius.copy();


        this.validate();

        return this;
    }



    toValue()
    {
        return new BackBlurValue(
            this.radius ? this.radius.toValue() : this.input.radius.toValue(),
            this.options.enabled);
    }



    isValid()
    {
        return super.isValid()
            && this.radius && this.radius.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.radius) this.radius.pushValueUpdates(parse);
    }
    
    
    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.radius) this.radius.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.radius) this.radius.iterateLoop(parse);
    }
}


class GLayerMask
extends GOperator
{
    constructor(nodeId, options)
    {
        super(LAYER_MASK, nodeId, options);
    }



    copy()
    {
        const copy = new GLayerMask(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        this.value = new LayerMaskValue(this.options.enabled);


        this.setUpdateValues(parse, [['', NullValue]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return new LayerMaskValue(this.options.enabled);
    }



    isValid()
    {
        return true;
    }
}


class GShapeBase
extends GOperator
{
    x      = null;
    y      = null;
    width  = null;
    height = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.x     ) this.x      = base.x     .copy();
        if (base.y     ) this.y      = base.y     .copy();
        if (base.width ) this.width  = base.width .copy();
        if (base.height) this.height = base.height.copy();
    }



    async evalBaseParams(parse, evalHeight = true)
    {
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;

        const height = evalHeight
                    && this.height ? (await this.height.eval(parse)).toValue() : null;

        return [x, y, width, height];
    }



    evalStyle(options = {})
    {
        // for (const style of this.styles)
        //     style.nodeId = this.nodeId;
    }



    isValid()
    {
        return this.x      && this.x     .isValid()
            && this.y      && this.y     .isValid()
            && this.width  && this.width .isValid()
            && this.height && this.height.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x     ) this.x     .pushValueUpdates(parse);
        if (this.y     ) this.y     .pushValueUpdates(parse);
        if (this.width ) this.width .pushValueUpdates(parse);
        if (this.height) this.height.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x     ) this.x     .invalidateInputs(parse, from);
        if (this.y     ) this.y     .invalidateInputs(parse, from);
        if (this.width ) this.width .invalidateInputs(parse, from);
        if (this.height) this.height.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x     ) this.x     .iterateLoop(parse);
        if (this.y     ) this.y     .iterateLoop(parse);
        if (this.width ) this.width .iterateLoop(parse);
        if (this.height) this.height.iterateLoop(parse);
    }
}



function validateObjectRect(x, y, w, h, a = 0, _a = 0)
{
    if (w < 0)
    {
        x += w * Math.cos(_a);
        y += w * Math.sin(_a);
    }

    if (h < 0)
    {
        y += h * Math.cos(_a);
        x -= h * Math.sin(_a);
    }
  
    
    w = Math.abs(w);
    h = Math.abs(h);


    return [x, y, w, h, a, _a];
}


class GShape
extends GShapeBase
{
    input = null;

    props = null;
   


    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        if (base.input) this.input = base.input.copy();
        if (base.props) this.props = base.props.copy();
    }



    baseIsValid()
    {
        return this.props.isValid();
    }



    isCached()
    {
        return super.isCached()
            && (  !this.input 
                || this.input.isCached());
    }



    async evalShapeBase(parse)
    {
        let props = this.props ? (await this.props.eval(parse)).toValue() : null;

        if (   props
            && STYLE_VALUES.includes(props.type))
            props = new ListValue([props]);

        
        if (this.value)
        {
            if (this.input)
                this.value.props = props ?? this.input.value.props;
            else
                this.value.props = props;

                    
            if (   this.value
                && this.value.isValid()
                && this.value.props != undefined) 
            {
                this.setUpdateValues(parse, 
                [
                    ['props', this.value.props]
                ], 
                true);


                if (!this.props) this.props = this.value.props.copy();
            }
        }
    }



    async evalObjects(parse)
    {
        if (!this.value)
            return;


        for (const obj of this.value.objects)
        {
            consoleAssert(obj.fills,   'obj.fills must not be null'  );
            consoleAssert(obj.strokes, 'obj.strokes must not be null');
            consoleAssert(obj.effects, 'obj.effects must not be null');


            if (  !this.value.props
                || this.value.props.items == undefined) 
                continue;


            for (let i = this.value.props.items.length-1; i >= 0; i--)
            {
                const prop = this.value.props.items[i];
                
                     if (prop.type ==        COLOR_VALUE)  addColorProp      (obj, prop);
                else if (prop.type ==         FILL_VALUE)  addFillProp       (obj, prop);
                else if (prop.type ==     GRADIENT_VALUE)  addGradientProp   (obj, prop);
                else if (prop.type ==       STROKE_VALUE)  addStrokeProp     (obj, prop);
                else if (prop.type ==  DROP_SHADOW_VALUE)  addDropShadowProp (obj, prop);
                else if (prop.type == INNER_SHADOW_VALUE)  addInnerShadowProp(obj, prop);
                else if (prop.type ==   LAYER_BLUR_VALUE)  addLayerBlurProp  (obj, prop);
                else if (prop.type ==    BACK_BLUR_VALUE)  addBackBlurProp   (obj, prop);
                else if (prop.type ==   LAYER_MASK_VALUE)  addLayerMaskProp  (obj);
            }
        }
    }



    evalStyle(options = {})
    {

    }



    isValid()
    {
        return super.isValid()
            && (!this.input || this.input.isValid())
            && this.props && this.props.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
        if (this.props) this.props.pushValueUpdates(parse);
    }


    
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
        if (this.props) this.props.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
        if (this.props) this.props.iterateLoop(parse);
    }
}


class GRectangle
extends GShape
{
    round = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    copy()
    {
        const copy = new GRectangle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round = this.round ? (await this.round.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new RectangleValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round);
        }
        else
        {
            this.value = new RectangleValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round);
        }

       
        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const rect = new FigmaRectangle(
                    this.nodeId, 
                    this.nodeId, 
                    this.nodeName, 
                    x, y, w, h, r);

                rect.createDefaultTransform(x, y);
                rect.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(rect);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const rect = new RectangleValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue());

        rect.props   = this.props.toValue();
        rect.objects = this.value.objects.map(o => o.copy());

        return rect;
    }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round) this.round.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
    }
}


class GLine
extends GShape
{
    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const copy = new GLine(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, ] = await this.evalBaseParams(parse, false);

            
        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new LineValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                width ?? input.width);
        }
        else
        {
            this.value = new LineValue(
                this.nodeId, 
                x, 
                y, 
                width);
        }


        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x    ) this.x     = this.value.x    .copy();
        if (!this.y    ) this.y     = this.value.y    .copy();
        if (!this.width) this.width = this.value.width.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x    .isValid()
            && this.value.y    .isValid()
            && this.value.width.isValid()) 
        {
            let x = this.value.x    .value;
            let y = this.value.y    .value;
            let w = this.value.width.value;


            [x, y, w, , , ] = validateObjectRect(x, y, w, 0);


            if (w != 0)
            {
                const line = new FigmaLine(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w);

                line.createDefaultTransform(x, y);
                line.createDefaultTransformPoints(x, y, w, 0.01);
                
                this.value.objects.push(line);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const line = new LineValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue());

        line.props   = this.props.toValue();
        line.objects = this.value.objects.map(o => o.copy());

        return line;
    }
}


class GEllipse
extends GShape
{
    from  = null;
    to    = null;
    inner = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    copy()
    {
        const copy = new GEllipse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from ) copy.from  = this.from .copy();
        if (this.to   ) copy.to    = this.to   .copy();
        if (this.inner) copy.inner = this.inner.copy();
        
        return copy;
    }


    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, height] = await this.evalBaseParams(parse);

        const from  = this.from  ? (await this.from .eval(parse)).toValue() : null;
        const to    = this.to    ? (await this.to   .eval(parse)).toValue() : null;
        const inner = this.inner ? (await this.inner.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new EllipseValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                from   ?? input.from,
                to     ?? input.to,
                inner  ?? input.inner);
        }
        else
        {
            this.value = new EllipseValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                from,
                to, 
                inner);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.from  ) this.from   = this.value.from  .copy();
        if (!this.to    ) this.to     = this.value.to    .copy();
        if (!this.inner ) this.inner  = this.value.inner .copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid()) 
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const f = this.value.from  .value;
            const t = this.value.to    .value;
            const i = this.value.inner .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const ellipse = new FigmaEllipse(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, f, t, i);

                ellipse.createDefaultTransform(x, y);
                ellipse.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(ellipse);
            }
        }

       
        await super.evalObjects(parse);
    }
   
    
        
    toValue()
    {
        const ellipse = new EllipseValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.from  .toValue(),
            this.to    .toValue(),
            this.inner .toValue());

        ellipse.props   = this.props.toValue();

        ellipse.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];
        
        return ellipse;
    }
    

    
    isValid()
    {
        return super.isValid()
            && this.from  && this.from .isValid()
            && this.to    && this.to   .isValid()
            && this.inner && this.inner.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
 
        if (this.from ) this.from .pushValueUpdates(parse);
        if (this.to   ) this.to   .pushValueUpdates(parse);
        if (this.inner) this.inner.pushValueUpdates(parse);
    }

   
        
    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.from ) this.from .invalidateInputs(parse, from);
        if (this.to   ) this.to   .invalidateInputs(parse, from);
        if (this.inner) this.inner.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
 
        if (this.from ) this.from .iterateLoop(parse);
        if (this.to   ) this.to   .iterateLoop(parse);
        if (this.inner) this.inner.iterateLoop(parse);
    }
}


class GTrapeze
extends GShape
{
    round = null;
    bias  = null;



    constructor(nodeId, options)
    {
        super(TRAPEZE, nodeId, options);
    }



    copy()
    {
        const copy = new GTrapeze(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round) copy.round = this.round.copy();
        if (this.bias ) copy.bias  = this.bias .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round = this.round ? (await this.round.eval(parse)).toValue() : null;
        const bias  = this.bias  ? (await this.bias .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TrapezeValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round,
                bias   ?? input.bias);
        }
        else
        {
            this.value = new TrapezeValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round,
                bias);
        }

       
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
     
        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()    
            && this.value.y     .isValid()    
            && this.value.width .isValid()
            && this.value.height.isValid()
            && this.value.round .isValid()
            && this.value.bias  .isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);
            let   b = this.value.bias  .value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const trapeze = new FigmaTrapeze(
                    this.nodeId, 
                    this.nodeId, 
                    this.nodeName, 
                    x, y, w, h, r, b);

                trapeze.createDefaultTransform(x, y);
                trapeze.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(trapeze);
            }
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const trap = new TrapezeValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue(),
            this.bias  .toValue());

        trap.props   = this.props.toValue();
        trap.objects = this.value.objects.map(o => o.copy());

        return trap;
    }



    isValid()
    {
        return super.isValid()
            && this.round && this.round.isValid()
            && this.bias  && this.bias .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round) this.round.pushValueUpdates(parse);
        if (this.bias ) this.bias .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round) this.round.invalidateInputs(parse, from);
        if (this.bias ) this.bias .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round) this.round.iterateLoop(parse);
        if (this.bias ) this.bias .iterateLoop(parse);
    }
}


class GPolygon
extends GShape
{
    round   = null;
    corners = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    copy()
    {
        const copy = new GPolygon(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round  ) copy.round   = this.round  .copy();
        if (this.corners) copy.corners = this.corners.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round   = this.round   ? (await this.round  .eval(parse)).toValue() : null;
        const corners = this.corners ? (await this.corners.eval(parse)).toValue() : null;


        let input = null;
             
        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new PolygonValue(
                this.nodeId,
                x       ?? input.x,
                y       ?? input.y,
                width   ?? input.width,
                height  ?? input.height,
                round   ?? input.round,
                corners ?? input.corners);
        }
        else
        {
            this.value = new PolygonValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round, 
                corners);
        }

        
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x      ) this.x       = this.value.x      .copy();
        if (!this.y      ) this.y       = this.value.y      .copy();
        if (!this.width  ) this.width   = this.value.width  .copy();
        if (!this.height ) this.height  = this.value.height .copy();
        if (!this.round  ) this.round   = this.value.round  .copy();
        if (!this.corners) this.corners = this.value.corners.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x      .isValid()
            && this.value.y      .isValid()
            && this.value.width  .isValid()
            && this.value.height .isValid()
            && this.value.round  .isValid()
            && this.value.corners.isValid())
        {
            let   x = this.value.x      .value;
            let   y = this.value.y      .value;
            let   w = this.value.width  .value;
            let   h = this.value.height .value;
            const r = Math.max(0, this.value.round.value);
            const c = this.value.corners.value;


            [x, y, w, h, , ] = validateObjectRect(x, y, w, h);


            if (   w != 0 
                && h != 0)
            {
                const poly = new FigmaPolygon(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, c);

                poly.createDefaultTransform(x, y);
                poly.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(poly);
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        const poly = new PolygonValue(
            this.nodeId,
            this.x      .toValue(),
            this.y      .toValue(),
            this.width  .toValue(),
            this.height .toValue(),
            this.round  .toValue(),
            this.corners.toValue());

        poly.props   = this.props.toValue();
        poly.objects = this.value.objects.map(o => o.copy());

        return poly;
    }



    isValid()
    {
        return super.isValid()
            && this.round   && this.round  .isValid()
            && this.corners && this.corners.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round  ) this.round  .pushValueUpdates(parse);
        if (this.corners) this.corners.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round  ) this.round  .invalidateInputs(parse, from);
        if (this.corners) this.corners.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round  ) this.round  .iterateLoop(parse);
        if (this.corners) this.corners.iterateLoop(parse);
    }
}



class GStar
extends GShape
{
    round  = null;
    points = null;
    convex = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    copy()
    {
        const copy = new GStar(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round ) copy.round  = this.round .copy();
        if (this.points) copy.points = this.points.copy();
        if (this.convex) copy.convex = this.convex.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round  = this.round  ? (await this.round .eval(parse)).toValue() : null;
        const points = this.points ? (await this.points.eval(parse)).toValue() : null;
        const convex = this.convex ? (await this.convex.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new StarValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                round  ?? input.round,
                points ?? input.points,
                convex ?? input.convex);
        }
        else
        {
            this.value = new StarValue(
                this.nodeId, 
                x, 
                y, 
                width, 
                height, 
                round, 
                points, 
                convex);
        }

             
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x     ) this.x      = this.value.x     .copy();
        if (!this.y     ) this.y      = this.value.y     .copy();
        if (!this.width ) this.width  = this.value.width .copy();
        if (!this.height) this.height = this.value.height.copy();
        if (!this.round ) this.round  = this.value.round .copy();
        if (!this.points) this.points = this.value.points.copy();
        if (!this.convex) this.convex = this.value.convex.copy();



        this.validate();

        return this;
   }



   async evalObjects(parse, options = {})
   {
       if (!this.options.enabled)
           return;
           
           
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.x     .isValid()
            && this.value.y     .isValid()
            && this.value.width .isValid()
            && this.value.height.isValid() 
            && this.value.round .isValid()
            && this.value.points.isValid()
            && this.value.convex.isValid())
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);
            const p = this.value.points.value;
            const c = this.value.convex.value;


            if (   w != 0
                && h != 0)
            {
                const star = new FigmaStar(
                    this.nodeId,
                    this.nodeId,
                    this.nodeName,
                    x, y, w, h, r, p, c);

                star.createDefaultTransform(x, y);
                star.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(star);
            }
        }

       
        await super.evalObjects(parse);
    }



    toValue()
    {
        const star = new StarValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.round .toValue(),
            this.points.toValue(),
            this.convex.toValue());
 
        star.props   = this.props.toValue();
        star.objects = this.value.objects.map(o => o.copy());
 
        return star;
    }



    isValid()
    {
        return super.isValid()
            && this.round  && this.round .isValid()
            && this.points && this.points.isValid()
            && this.convex && this.convex.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round ) this.round .pushValueUpdates(parse);
        if (this.points) this.points.pushValueUpdates(parse);
        if (this.convex) this.convex.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round ) this.round .invalidateInputs(parse, from);
        if (this.points) this.points.invalidateInputs(parse, from);
        if (this.convex) this.convex.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round ) this.round .iterateLoop(parse);
        if (this.points) this.points.iterateLoop(parse);
        if (this.convex) this.convex.iterateLoop(parse);
    }
}


class GTextShape
extends GShape
{
    text          = null;
    x             = null;
    y             = null;
    width         = null;
    height        = null;
    font          = null;
    size          = null;
    style         = null;
    alignH        = null;
    alignV        = null;
    lineHeight    = null;
    letterSpacing = null;



    constructor(nodeId, options)
    {
        super(TEXT_SHAPE, nodeId, options);
    }



    copy()
    {
        const copy = new GTextShape(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.text         ) copy.text          = this.text         .copy();
        if (this.x            ) copy.x             = this.x            .copy();
        if (this.y            ) copy.y             = this.y            .copy();
        if (this.width        ) copy.width         = this.width        .copy();
        if (this.height       ) copy.height        = this.height       .copy();
        if (this.font         ) copy.font          = this.font         .copy();
        if (this.style        ) copy.style         = this.style        .copy();
        if (this.size         ) copy.size          = this.size         .copy();
        if (this.alignH       ) copy.alignH        = this.alignH       .copy();
        if (this.alignV       ) copy.alignV        = this.alignV       .copy();
        if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();
        if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const text          = this.text          ? (await this.text         .eval(parse)).toValue() : null;
        const x             = this.x             ? (await this.x            .eval(parse)).toValue() : null;
        const y             = this.y             ? (await this.y            .eval(parse)).toValue() : null;
        const width         = this.width         ? (await this.width        .eval(parse)).toValue() : null;
        const height        = this.height        ? (await this.height       .eval(parse)).toValue() : null;
        const font          = this.font          ? (await this.font         .eval(parse)).toValue() : null;
        const style         = this.style         ? (await this.style        .eval(parse)).toValue() : null;
        const size          = this.size          ? (await this.size         .eval(parse)).toValue() : null;
        const alignH        = this.alignH        ? (await this.alignH       .eval(parse)).toValue() : null;
        const alignV        = this.alignV        ? (await this.alignV       .eval(parse)).toValue() : null;
        const lineHeight    = this.lineHeight    ? (await this.lineHeight   .eval(parse)).toValue() : null;
        const letterSpacing = this.letterSpacing ? (await this.letterSpacing.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TextShapeValue(
                this.nodeId,
                text          ?? input.text,
                x             ?? input.x,
                y             ?? input.y,
                width         ?? input.width,
                height        ?? input.height,
                font          ?? input.font,
                style         ?? input.style,
                size          ?? input.size,
                alignH        ?? input.size,
                alignV        ?? input.size,
                lineHeight    ?? input.size,
                letterSpacing ?? input.size);
        }
        else
        {
            this.value = new TextShapeValue(
                this.nodeId, 
                text, 
                x, 
                y, 
                this.width .type != NUMBER_VALUE ? width  : new NumberValue(0), 
                this.height.type != NUMBER_VALUE ? height : new NumberValue(0), 
                font, 
                style,
                size,
                alignH,
                alignV,
                lineHeight,
                letterSpacing);
        }

       
        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.text         ) this.text          = this.value.text         .copy();
        if (!this.x            ) this.x             = this.value.x            .copy();
        if (!this.y            ) this.y             = this.value.y            .copy();
        if (!this.width        ) this.width         = this.value.width        .copy();
        if (!this.height       ) this.height        = this.value.height       .copy();
        if (!this.font         ) this.font          = this.value.font         .copy();
        if (!this.style        ) this.style         = this.value.style        .copy();
        if (!this.size         ) this.size          = this.value.size         .copy();
        if (!this.alignH       ) this.alignH        = this.value.alignH       .copy();
        if (!this.alignV       ) this.alignV        = this.value.alignV       .copy();
        if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();
        if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;

        
        this.value.objects = [];


        if (   super.baseIsValid()   
            && this.value.text         .isValid()
            && this.value.x            .isValid()
            && this.value.y            .isValid()
            && this.value.width        .isValid()
            && this.value.height       .isValid()
            && this.value.font         .isValid()
            && this.value.style        .isValid()
            && this.value.size         .isValid()
            && this.value.alignH       .isValid()
            && this.value.alignV       .isValid()
            && this.value.lineHeight   .isValid()
            && this.value.letterSpacing.isValid())
        {
            let x = this.value.x     .value;
            let y = this.value.y     .value;
            let w = this.value.width .value;
            let h = this.value.height.value;

            const fontName   = figUniqueFontNames[this.value.font.value];
            const fontStyles = getFontStyles(fontName);

            const text = new FigmaText(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                this.value.text.value,
                x, y, w, h,
                fontName,
                this.value.size         .value,
                fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],
                this.value.alignH       .value,
                this.value.alignV       .value,
                this.value.lineHeight   .value,
                this.value.letterSpacing.value);


            text.createDefaultTransform(x, y);
 
            if (   text.width  == 0
                && text.height == 0)
            {
                const {objectId, width, height} = await genGetObjectSizeFromFigma(text.toData());

                text.width  = width;
                text.height = height;

                this.value.width.value  = width;
                this.value.height.value = height;

                text.createDefaultTransformPoints(x, y, width, height);

                this.value.objects.push(text);
            }
            else
            {
                text.createDefaultTransformPoints(x, y, w, h)

                this.value.objects.push(text);
            }
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return super.isValid()
            && this.text          && this.text         .isValid()
            && this.x             && this.x            .isValid()
            && this.y             && this.y            .isValid()
            && this.width         && this.width        .isValid()
            && this.height        && this.height       .isValid()
            && this.font          && this.font         .isValid()
            && this.style         && this.style        .isValid()
            && this.size          && this.size         .isValid()
            && this.alignH        && this.alignH       .isValid()
            && this.alignV        && this.alignV       .isValid()
            && this.lineHeight    && this.lineHeight   .isValid()
            && this.letterSpacing && this.letterSpacing.isValid();
    }



    toValue()
    {
        const text = new TextShapeValue(
            this.nodeId,
            
            this.text         .toValue(),
            
            this.x            .toValue(),
            this.y            .toValue(),
            
            this.width        .toValue(),
            this.height       .toValue(),
            
            this.font         .toValue(),
            this.style        .toValue(),
            this.size         .toValue(),
            
            this.alignH       .toValue(),
            this.alignV       .toValue(),
            
            this.lineHeight   .toValue(),
            this.letterSpacing.toValue());

            
        text.props = this.props.toValue();

        text.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];

        
        return text;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);
        
        if (this.text         ) this.text         .pushValueUpdates(parse);
        if (this.x            ) this.x            .pushValueUpdates(parse);
        if (this.y            ) this.y            .pushValueUpdates(parse);
        if (this.width        ) this.width        .pushValueUpdates(parse);
        if (this.height       ) this.height       .pushValueUpdates(parse);
        if (this.font         ) this.font         .pushValueUpdates(parse);
        if (this.style        ) this.style        .pushValueUpdates(parse);
        if (this.size         ) this.size         .pushValueUpdates(parse);
        if (this.alignH       ) this.alignH       .pushValueUpdates(parse);
        if (this.alignV       ) this.alignV       .pushValueUpdates(parse);
        if (this.lineHeight   ) this.lineHeight   .pushValueUpdates(parse);
        if (this.letterSpacing) this.letterSpacing.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);
        
        if (this.text         ) this.text         .invalidateInputs(parse, from);
        if (this.x            ) this.x            .invalidateInputs(parse, from);
        if (this.y            ) this.y            .invalidateInputs(parse, from);
        if (this.width        ) this.width        .invalidateInputs(parse, from);
        if (this.height       ) this.height       .invalidateInputs(parse, from);
        if (this.font         ) this.font         .invalidateInputs(parse, from);
        if (this.style        ) this.style        .invalidateInputs(parse, from);
        if (this.size         ) this.size         .invalidateInputs(parse, from);
        if (this.alignH       ) this.alignH       .invalidateInputs(parse, from);
        if (this.alignV       ) this.alignV       .invalidateInputs(parse, from);
        if (this.lineHeight   ) this.lineHeight   .invalidateInputs(parse, from);
        if (this.letterSpacing) this.letterSpacing.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);
        
        if (this.text         ) this.text         .iterateLoop(parse);
        if (this.x            ) this.x            .iterateLoop(parse);
        if (this.y            ) this.y            .iterateLoop(parse);
        if (this.width        ) this.width        .iterateLoop(parse);
        if (this.height       ) this.height       .iterateLoop(parse);
        if (this.font         ) this.font         .iterateLoop(parse);
        if (this.style        ) this.style        .iterateLoop(parse);
        if (this.size         ) this.size         .iterateLoop(parse);
        if (this.alignH       ) this.alignH       .iterateLoop(parse);
        if (this.alignV       ) this.alignV       .iterateLoop(parse);
        if (this.lineHeight   ) this.lineHeight   .iterateLoop(parse);
        if (this.letterSpacing) this.letterSpacing.iterateLoop(parse);
    }
}


class GPoint
extends GOperator1
{
    x = null;
    y = null;



    constructor(nodeId, options)
    {
        super(POINT, nodeId, options);
    }



    copy()
    {
        const copy = new GPoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.value) copy.value = this.value.copy();
        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const x = this.x ? (await this.x.eval(parse)).toValue() : null;
        const y = this.y ? (await this.y.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new PointValue(
                this.nodeId,
                x ?? input.x,
                y ?? input.y);
        }
        else
        {
            this.value = new PointValue(
                this.nodeId, 
                x, 
                y);
        }


        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        if (!this.x) this.x = this.value.x.copy();
        if (!this.y) this.y = this.value.y.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x.isValid()
            && this.value.y.isValid())
        {
            const x = this.value.x.value;
            const y = this.value.y.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const point = new PointValue(
            this.nodeId,
            this.x.toValue(),
            this.y.toValue());

        point.objects = 
            this.value.objects
            ? this.value.objects.map(o => o.copy())
            : [];

        return point;
    }



    isValid()
    {
        return super.isValid()
            && this.x && this.x.isValid()
            && this.y && this.y.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x) this.x.pushValueUpdates(parse);
        if (this.y) this.y.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x) this.x.invalidateInputs(parse, from);
        if (this.y) this.y.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x) this.x.iterateLoop(parse);
        if (this.y) this.y.iterateLoop(parse);
    }
}


class GVectorPath
extends GShape
{
    points  = null;
    closed  = null;
    degree  = null;
    winding = null;
    round   = null;



    constructor(nodeId, options)
    {
        super(VECTOR_PATH, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.points ) copy.points  = this.points .copy();
        if (this.closed ) copy.closed  = this.closed .copy();
        if (this.degree ) copy.degree  = this.degree .copy();
        if (this.winding) copy.winding = this.winding.copy();
        if (this.round  ) copy.round   = this.round  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const points  = this.points  ? (await this.points .eval(parse)).toValue() : null;
        const closed  = this.closed  ? (await this.closed .eval(parse)).toValue() : null;
        const degree  = this.degree  ? (await this.degree .eval(parse)).toValue() : null;
        const winding = this.winding ? (await this.winding.eval(parse)).toValue() : null;
        const round   = this.round   ? (await this.round  .eval(parse)).toValue() : null;

        
        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new VectorPathValue(
                this.nodeId,
                points  ?? input.points,
                closed  ?? input.closed,
                degree  ?? input.degree,
                winding ?? input.winding,
                round   ?? input.round);
        }
        else
        {
            this.value = new VectorPathValue(
                this.nodeId, 
                points, 
                closed, 
                degree, 
                winding, 
                round);
        }

        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.points ) this.points  = this.value.points .copy();
        if (!this.closed ) this.closed  = this.value.closed .copy();
        if (!this.degree ) this.degree  = this.value.degree .copy();
        if (!this.winding) this.winding = this.value.winding.copy();
        if (!this.round  ) this.round   = this.value.round  .copy();



        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        const points = [];

        if (this.value.points.objects)
        {
            const objPoints = this.value.points.objects.filter(o => o.type == POINT);

            for (const pt of objPoints)
                points.push(PointValue.create(this.nodeId, pt.x, pt.y));
        }


        this.value.objects = [];


        if (   super.baseIsValid()   
            && points.length >= 2
            && this.value.closed .isValid()
            && this.value.degree .isValid()
            && this.value.winding.isValid()
            && this.value.round  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                this.value.closed .value,
                this.value.degree .value,
                this.value.winding.value,
                this.value.round  .value);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;

            
            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const path = new VectorPathValue(
            this.nodeId,
            this.points .toValue(),
            this.closed .toValue(),
            this.degree .toValue(),
            this.winding.toValue(),
            this.round  .toValue());

        path.props   = this.props.toValue();
        path.objects = this.value.objects.map(o => o.copy());

        return path;
    }



    isValid()
    {
        return super.isValid()
            && this.points  && this.points .isValid()
            && this.closed  && this.closed .isValid()
            && this.degree  && this.degree .isValid()
            && this.winding && this.winding.isValid()
            && this.round   && this.round  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.points ) this.points .pushValueUpdates(parse);
        if (this.closed ) this.closed .pushValueUpdates(parse);
        if (this.degree ) this.degree .pushValueUpdates(parse);
        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.round  ) this.round  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.points ) this.points .invalidateInputs(parse, from);
        if (this.closed ) this.closed .invalidateInputs(parse, from);
        if (this.degree ) this.degree .invalidateInputs(parse, from);
        if (this.winding) this.winding.invalidateInputs(parse, from);
        if (this.round  ) this.round  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.points ) this.points .iterateLoop(parse);
        if (this.closed ) this.closed .iterateLoop(parse);
        if (this.degree ) this.degree .iterateLoop(parse);
        if (this.winding) this.winding.iterateLoop(parse);
        if (this.round  ) this.round  .iterateLoop(parse);
    }
}


class GVectorVertex
extends GOperator1
{
    x     = null;
    y     = null;
    join  = null;
    cap   = null;
    round = null;



    constructor(nodeId, options)
    {
        super(VECTOR_VERTEX, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorVertex(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x    ) copy.x     = this.x    .copy();
        if (this.y    ) copy.y     = this.y    .copy();
        if (this.join ) copy.join  = this.join .copy();
        if (this.cap  ) copy.cap   = this.cap  .copy();
        if (this.round) copy.round = this.round.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const x     = this.x     ? (await this.x    .eval(parse)).toValue() : null;
        const y     = this.y     ? (await this.y    .eval(parse)).toValue() : null;
        const join  = this.join  ? (await this.join .eval(parse)).toValue() : null;
        const cap   = this.cap   ? (await this.cap  .eval(parse)).toValue() : null;
        const round = this.round ? (await this.round.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new VectorVertexValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                join  ?? input.join,
                cap   ?? input.cap,
                round ?? input.round);
        }
        else
        {
            this.value = new VectorVertexValue(
                this.nodeId, 
                x, 
                y, 
                join, 
                cap, 
                round);
        }

       
        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        this.value.objects = [];


        if (   this.value.x    
            && this.value.y    
            && this.value.join 
            && this.value.cap  
            && this.value.round)
        {
            const x     = this.value.x    .value;
            const y     = this.value.y    .value;
            //const join  = this.value.join .value;
            //const cap   = this.value.cap  .value;
            //const round = this.value.round.value;

            const point = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, x, y);

            point.createDefaultTransform(x, y);

            this.value.objects = [point];
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const point = new VectorVertexValue(
            this.nodeId,
            this.x    .toValue(),
            this.y    .toValue(),
            this.join .toValue(),
            this.cap  .toValue(),
            this.round.toValue());

        point.objects  = this.value.objects.map(o => o.copy());
        point.uniqueId = this.value.uniqueId;

        return point;
    }



    isValid()
    {
        return super.isValid()
            && this.x    .isValid()
            && this.y    .isValid()
            && this.join .isValid()
            && this.cap  .isValid()
            && this.round.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x    ) this.x    .pushValueUpdates(parse);
        if (this.y    ) this.y    .pushValueUpdates(parse);
        if (this.join ) this.join .pushValueUpdates(parse);
        if (this.cap  ) this.cap  .pushValueUpdates(parse);
        if (this.round) this.round.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x    ) this.x    .invalidateInputs(parse, from);
        if (this.y    ) this.y    .invalidateInputs(parse, from);
        if (this.join ) this.join .invalidateInputs(parse, from);
        if (this.cap  ) this.cap  .invalidateInputs(parse, from);
        if (this.round) this.round.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x    ) this.x    .iterateLoop(parse);
        if (this.y    ) this.y    .iterateLoop(parse);
        if (this.join ) this.join .iterateLoop(parse);
        if (this.cap  ) this.cap  .iterateLoop(parse);
        if (this.round) this.round.iterateLoop(parse);
    }
}


class GVectorEdge
extends GOperator1
{
    input0       = null;
    input1       = null;

    startTangent = null;
    endTangent   = null;



    constructor(nodeId, options)
    {
        super(VECTOR_EDGE, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorEdge(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0      ) copy.input0       = this.input0      .copy();
        if (this.input1      ) copy.input1       = this.input1      .copy();
        if (this.startTangent) copy.startTangent = this.startTangent.copy();
        if (this.endTangent  ) copy.endTangent   = this.endTangent  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const input0       = this.input0       ? (await this.input0      .eval(parse)).toValue() : VectorVertexValue.NaN;
        const input1       = this.input1       ? (await this.input1      .eval(parse)).toValue() : VectorVertexValue.NaN;
        const startTangent = this.startTangent ? (await this.startTangent.eval(parse)).toValue() : PointValue.NaN;
        const   endTangent = this.  endTangent ? (await this.  endTangent.eval(parse)).toValue() : PointValue.NaN;


        this.value = new VectorEdgeValue(
            this.nodeId,
            input0,
            input1,
            startTangent,
              endTangent);


        await this.evalObjects(parse);


        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.start.isValid()
            || !this.value.end  .isValid())
            return;
            
            
        this.value.objects = [];


        if (   this.value.start.isValid()
            && this.value.end  .isValid())
        {
            const path = new FigmaVectorPath(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                [ this.value.start,
                  this.value.startTangent.isValid() ? this.value.startTangent : this.value.start,
                  this.value.endTangent  .isValid() ? this.value.  endTangent : this.value.end,
                  this.value.end ],
                0,
                2, // cubic
                0,
                0);

            
            const bounds = getObjBounds([path]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            path.createDefaultTransform(x, y);
            path.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(path);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const edge = new VectorEdgeValue(
            this.nodeId,
            this.input0 ? this.input0.toValue() : VectorVertexValue.NaN,
            this.input1 ? this.input1.toValue() : VectorVertexValue.NaN,
            this.startTangent.toValue(),
            this.endTangent  .toValue());

        edge.uniqueId = this.value.uniqueId;
        edge.objects  = this.value.objects.map(o => o.copy());

        return edge;
    }



    isValid()
    {
        return super.isValid()
            && this.input0      .isValid()
            && this.input1      .isValid()
            && this.startTangent.isValid()
            && this.endTangent  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input0      ) this.input0      .pushValueUpdates(parse);
        if (this.input1      ) this.input1      .pushValueUpdates(parse);
        if (this.startTangent) this.startTangent.pushValueUpdates(parse);
        if (this.endTangent  ) this.endTangent  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input0      ) this.input0      .invalidateInputs(parse, from);
        if (this.input1      ) this.input1      .invalidateInputs(parse, from);
        if (this.startTangent) this.startTangent.invalidateInputs(parse, from);
        if (this.endTangent  ) this.endTangent  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input0      ) this.input0      .iterateLoop(parse);
        if (this.input1      ) this.input1      .iterateLoop(parse);
        if (this.startTangent) this.startTangent.iterateLoop(parse);
        if (this.endTangent  ) this.endTangent  .iterateLoop(parse);
    }
}


class GVectorRegion
extends GShape
{
    inputs  = [];

    loops   = null;
    winding = null;



    constructor(nodeId, options)
    {
        super(VECTOR_REGION, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorRegion(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        if (this.winding) copy.winding = this.winding.copy();

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached()
            && this.winding.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const winding = this.winding ? (await this.winding.eval(parse)).toValue() : null;


        this.loops = new ListValue();


        const loop = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            if (LIST_VALUES.includes(input.type))
            {
                const _loop = new ListValue();

                for (const item of input.items)
                {
                    if (item.type == VECTOR_EDGE_VALUE)
                        _loop.items.push(item);
                }

                if (!isEmpty(_loop.items))
                    loops.items.push(_loop);
            }
            else
            {
                consoleAssert(
                     input.type == VECTOR_EDGE_VALUE, 
                    'input.type must be VECTOR_EDGE_VALUE');

                loop.items.push(input);
            }
        }


        if (!isEmpty(loop.items))
            this.loops.items.push(loop);


        this.value = new VectorRegionValue(
            this.nodeId,
            this.loops, 
            winding);


        this.setUpdateValues(parse,
        [
            ['value',   this.value],
            ['winding', winding   ]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];

        
        if (   this.loops  .isValid()
            && this.winding.isValid())
        {
            const regions = [];


            for (let i = 0; i < this.loops.items.length; i++)
            {
                const loop = this.loops.items[i];


                const points = [];
    
                for (let j = 0; j < loop.items.length; j++)
                {
                    const edge = loop.items[j  ];
                    const next = loop.items[j == loop.items.length-1 ? 0 : j+1];

                    points.push(
                           edge.start.uniqueId == next.start.uniqueId
                        || edge.start.uniqueId == next.end  .uniqueId
                        ? edge.end  
                        : edge.start);
                }


                regions.push(new FigmaVectorPath(
                    this.nodeId,
                    this.nodeId + '/' + i,
                    this.nodeName,
                    points,
                    1,
                    0, // linear
                    this.winding.value,
                    0));
            }
            

            let bounds = getObjBounds(regions);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            for (const region of regions)
            {
                region.createDefaultTransform(x, y);
                region.createDefaultTransformPoints(x, y, w, h);

                this.value.objects.push(region);
            }
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const region = new VectorRegionValue(
            this.nodeId,
            this.loops  .toValue(),
            this.winding.toValue(),
            this.props  .toValue());

        region.uniqueId = this.value.uniqueId;
        region.objects  = this.value.objects.map(o => o.copy());

        return region;
    }



    isValid()
    {
        if (!super.isValid())
            return false;
            
        for (const input of this.inputs)
            if (!input.isCached())
                return false;
        
        return this.winding.isValid()
            && this.props  .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.winding) this.winding.pushValueUpdates(parse);
        if (this.props  ) this.props  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));

        if (this.winding) this.winding.invalidateInputs(parse, from);
        if (this.props  ) this.props  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.winding) this.winding.iterateLoop(parse);
        if (this.props  ) this.props  .iterateLoop(parse);
    }
}


class GVectorNetwork
extends GShape
{
    inputs  = [];



    constructor(nodeId, options)
    {
        super(VECTOR_NETWORK, nodeId, options);
    }



    copy()
    {
        const copy = new GVectorNetwork(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const regions = new ListValue();

        for (let i = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            consoleAssert(
                 input.type == VECTOR_REGION_VALUE, 
                'input.type must be VECTOR_REGION_VALUE');

            regions.items.push(input);
        }


        this.value = new VectorNetworkValue(
            this.nodeId,
            regions);


        this.setUpdateValues(parse, [['value', this.value]]);


        await this.evalShapeBase(parse);

        
        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   !this.options.enabled
            || !this.value.isValid())
            return;
            
            
        this.value.objects = [];


        if (!isEmpty(this.value.regions.items))
        {
            let points  = [];
            let edges   = [];
            let regions = [];


            for (const region of this.value.regions.items)
            {
                if (!isEmpty(region.objects))
                    region.fills = region.objects[0].fills;


                if (region.loops)
                {
                    for (const loop of region.loops.items)
                    {
                        for (const edge of loop.items)
                        {
                            pushUniqueBy(points, edge.start, p => p.uniqueId == edge.start.uniqueId);
                            pushUniqueBy(points, edge.end,   p => p.uniqueId == edge.end  .uniqueId);

                            pushUniqueBy(edges, edge, e => e.uniqueId == edge.uniqueId);
                        }
                    }

                    pushUniqueBy(regions, region, r => r.uniqueId == region.uniqueId);
                }
            }

            
            const network = new FigmaVectorNetwork(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                points,
                edges,
                regions);

            
            const bounds = getObjBounds([network]);

            let x = bounds.x;
            let y = bounds.y;
            let w = bounds.w;
            let h = bounds.h;


            network.createDefaultTransform(x, y);
            network.createDefaultTransformPoints(x, y, w, h);

            this.value.objects.push(network);
        }


        await super.evalObjects(parse);
    }



    toValue()
    {
        const network = new VectorNetworkValue(
            this.nodeId,
            this.regions.toValue());

        network.uniqueId = this.value.uniqueId;
        network.objects  = this.value.objects.map(o => o.copy());

        return network;
    }



    isValid()
    {
        return super.isValid()
            && this.regions.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GShapeGroup
extends GShapeBase
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(SHAPE_GROUP, nodeId, options);
    }



    copy()
    {
        const copy = new GShapeGroup(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ShapeGroupValue(this.nodeId);


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            const input = (await this.inputs[i].eval(parse)).toValue();

            
            // first copy the input objects

            // if (this.options.enabled)
            // {
            //     for (let j = 0; j < this.inputs[i].objects.length; j++, o++)
            //     {
            //         const obj = copyFigmaObject(this.inputs[i].objects[j]);

            //         obj.nodeId   = this.nodeId;
            //         obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
            //         obj.listId   = -1;

            //         this.value.objects.push(obj);
            //     }
            // }


            // now create the output value

            if (   input
                && this.options.enabled)            
            {
                if (   input.type == SHAPE_LIST_VALUE
                    || input.type == LIST_VALUE)
                {
                    for (const item of input.items)
                    {
                        if (!SHAPE_VALUES.includes(item.type))
                            continue;

                        this.value.items.push(item.copy());   
                        //this.value.objects.push(...item.objects.map(o => this.copyObject(o, i)));
                    }
                }
                else
                {
                    this.value.items.push(input.copy());
                    //this.value.objects.push(...input.objects.map(o => this.copyObject(o, i)));
                }
            }
        }


        this.setUpdateValues(parse, [['value', this.value]]);


        //await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (this.value.items)
        {
            const group = new FigmaShapeGroup(
                this.nodeId,
                this.nodeId,
                this.nodeName);


            for (const item of this.value.items)
            {
                for (let i = 0; i < item.objects.length; i++)
                {
                    const obj = item.objects[i].copy();

                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;

                    group.children.push(obj);
                }
            }

            this.value.objects = [group];
        }
        else
        {
            this.value.objects = [];
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        if (!super.isValid()) 
            return false;

        for (const input of this.inputs)
            if (!input.isValid())
                return false;

        return true;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));
    }
}


class GFrame
extends GShape
{
    round    = null;
    children = null;



    constructor(nodeId, options)
    {
        super(FRAME, nodeId, options);
    }



    copy()
    {
        const copy = new GFrame(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.round   ) copy.round    = this.round   .copy();
        if (this.children) copy.children = this.children.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const [x, y, width, height] = await this.evalBaseParams(parse);

        const round    = this.round    ? (await this.round   .eval(parse)).toValue() : null;
        let   children = this.children ? (await this.children.eval(parse)).toValue() : null;

        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
            children = new ListValue([children]);


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new FrameValue(
                this.nodeId,
                x        ?? input.x,
                y        ?? input.y,
                width    ?? input.width,
                height   ?? input.height,
                round    ?? input.round,
                children ?? input.children);
        }
        else
        {
            this.value = new FrameValue(
                this.nodeId, 
                x, 
                y, 
                width,
                height, 
                round, 
                children);
        }


        this.setUpdateValues(parse, 
        [
            ['value', this.value]
        ]);


        await this.evalShapeBase(parse);


        await this.evalObjects(parse);


        if (!this.x       ) this.x        = this.value.x       .copy();
        if (!this.y       ) this.y        = this.value.y       .copy();
        if (!this.width   ) this.width    = this.value.width   .copy();
        if (!this.height  ) this.height   = this.value.height  .copy();
        if (!this.round   ) this.round    = this.value.round   .copy();
        if (!this.children) this.children = this.value.children.copy();


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (   this.value.x
            && this.value.y
            && this.value.width
            && this.value.height
            && this.value.round)
        {
            let   x = this.value.x     .value;
            let   y = this.value.y     .value;
            let   w = this.value.width .value;
            let   h = this.value.height.value;
            const r = Math.max(0, this.value.round.value);


            const frame = new FigmaFrame(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                x, y, w, h, r);


            // if (LIST_VALUES.includes(this.value.type))
            // {
            //     console.log('this.value.children =', this.value.children);
            //     for (let i = 0; i < this.value.children.objects.length; i++)
            //         this.addChildObject(frame.children, this.value.children.objects[i]);
            // }
            // else
            // {
                for (let i = 0; i < this.value.objects.length; i++)
                    this.addChildObject(frame.children, this.value.objects[i]);
            // }


            frame.createDefaultTransform(x, y);
            frame.createDefaultTransformPoints(x, y, w, h);
        
            this.value.objects = [frame];

            
            this.setUpdateValues(parse, 
            [
                ['nChildren', new NumberValue(frame.children.length)]
            ], 
            true);
        }


        await super.evalObjects(parse);
    }



    addChildObject(objects, _obj)
    {
        const obj = copyFigmaObject(_obj);
                    
        obj.nodeId   = this.nodeId;
        obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
        obj.listId   = -1;
        
        objects.push(obj);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.round    && this.round   .isValid()
            && this.children && this.children.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.round   ) this.round   .pushValueUpdates(parse);
        if (this.children) this.children.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.round   ) this.round   .invalidateInputs(parse, from);
        if (this.children) this.children.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.round   ) this.round   .iterateLoop(parse);
        if (this.children) this.children.iterateLoop(parse);
    }
}


class GApply
extends GShape
{
    constructor(nodeId, options)
    {
        super(SHAPE_APPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GApply(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const [, , , ] = await this.evalBaseParams(parse);


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = input.copy();

            if (this.options.enabled)
                await this.evalShapeBase(parse);

            await this.evalObjects(parse);
        }
        else
        {
            await this.evalShapeBase(parse); // to updated anything connected to styles
            this.value = NullValue.copy();
        }

       
        this.setUpdateValues(parse, [['value', this.value]]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (this.value.isValid())
        {
            this.value.objects = 
                   this.input 
                && this.input.value
                ? this.input.value.objects.map(o => o.copy()) 
                : [];
        }

            
        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

            if (this.options.enabled)
            {
                obj.fills   = [];
                obj.strokes = [];
                obj.effects = [];

                obj.isMask  = false;
            }
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
}


class GShapeBoolean
extends GShapeBase
{
    input     = null;

    operation = null
    children  = null;



    constructor(nodeId, options)
    {
        super(BOOLEAN, nodeId, options);
    }



    copy()
    {
        const copy = new GShapeBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.operation) copy.operation = this.operation.copy();
        if (this.children ) copy.children  = this.children .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        await this.evalBaseParams(parse);

        const operation = this.operation ? (await this.operation.eval(parse)).toValue() : null;
        let   children  = this.children  ? (await this.children .eval(parse)).toValue() : null;


        if (   children
            && SHAPE_VALUES.includes(children.type)
            && children.type != SHAPE_LIST_VALUE)
            children = new ListValue([children]);


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new ShapeBooleanValue(
                this.nodeId,
                operation ?? input.operation,
                children  ?? input.children);
        }
        else
        {
            this.value = new ShapeBooleanValue(
                this.nodeId, 
                operation,
                children);
        }


        this.setUpdateValues(parse,
        [
            ['value',     this.value          ],
            ['operation', this.value.operation],
            ['children',  this.value.children ]
        ]);


        await this.evalShapeBase(parse);

        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            

        if (this.value.children)
        {
            const bool = new FigmaBoolean(
                this.nodeId,
                this.nodeId,
                this.nodeName,
                this.operation);


            if (this.children.objects)
            {
                for (let i = 0; i < this.children.objects.length; i++)
                {
                    const obj    = this.children.objects[i].copy();
                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;
                    bool.children.push(obj);
                }
            }


            this.value.objects = [bool];

            this.updateValues.push(['nObjects', new NumberValue(
                this.children.objects 
                ? this.children.objects.length
                : 0)]);
        }
        else
        {
            this.value.objects = [];
            this.updateValues.push(['nObjects', new NumberValue(0)]);
        }

        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    isValid()
    {
        return super.isValid()
            && this.children.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input   ) this.input   .pushValueUpdates(parse);
        if (this.children) this.children.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input   ) this.input   .invalidateInputs(parse, from);
        if (this.children) this.children.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input   ) this.input   .iterateLoop(parse);
        if (this.children) this.children.iterateLoop(parse);
    }
}














class GRender
extends GShapeBase
{
    inputs = [];

    retain = null;

    finalize;



    constructor(nodeId, options)
    {
        super(RENDER, nodeId, options);
    }



    copy()
    {
        const copy = new GRender(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const retain   = (await this.retain.eval(parse)).toValue();
        const finalize = this.finalize.value > 0;


        this.value = new ListValue();


        for (let i = 0, o = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);

        
            if (   this.options.enabled
                && (   finalize
                    || retain.value == 1))
            {
                for (let j = 0; j < this.inputs[i].value.objects.length; j++, o++)
                {
                    let obj = this.inputs[i].value.objects[j];

                    obj = copyFigmaObject(obj);

                    obj.nodeId   = this.nodeId;
                    obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;
                    obj.listId   = -1;


                    if (  (   !isEmpty(obj.fills  )
                           || !isEmpty(obj.strokes))
                        && !obj.isDeco)
                        // && (   finalize
                        //     || retain.value == 1))
                            obj.retain = finalize ? 2 : 1;
                            

                    this.value.objects.push(obj);
                }
            }
        }


        this.setUpdateValues(parse, [['', NullValue]]);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    isValid()
    {
        return super.isValid()
            && !this.inputs.find(i => !i.isValid())
            && this.retain && this.retain.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse));

        if (this.retain) this.retain.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from));

        if (this.retain) this.retain.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse));

        if (this.retain) this.retain.iterateLoop(parse);
    }
}


class GMove
extends GOperator1
{
    x           = null;
    y           = null;
    moveType    = null;
    affectSpace = null;
    showCenter  = null;



    constructor(nodeId, options)
    {
        super(MOVE, nodeId, options);
    }



    copy()
    {
        const copy = new GMove(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.x          ) copy.x           = this.x          .copy();
        if (this.y          ) copy.y           = this.y          .copy();
        if (this.moveType   ) copy.moveType    = this.moveType   .copy();
        if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();
        if (this.showCenter ) copy.showCenter  = this.showCenter .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x           = this.x           ? (await this.x          .eval(parse)).toValue() : null;
        const y           = this.y           ? (await this.y          .eval(parse)).toValue() : null;
        const moveType    = this.moveType    ? (await this.moveType   .eval(parse)).toValue() : null;
        const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).toValue() : null;
        const showCenter  = this.showCenter  ? (await this.showCenter .eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }


        await this.evalObjects(
            parse, 
            {
                x:           x, 
                y:           y,
                moveType:    moveType,
                showCenter:  showCenter,
                affectSpace: affectSpace
            });


        this.setUpdateValues(parse,
        [
            ['x',           x          ],
            ['y',           y          ],
            ['moveType',    moveType   ],
            ['affectSpace', affectSpace],
            ['showCenter',  showCenter ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);

            
            const bounds = getObjBounds(this.value.objects);


            const x           = options.x          .value;
            const y           = options.y          .value;
            const moveType    = options.moveType   .value;
            const affectSpace = options.affectSpace.value;
            const showCenter  = options.showCenter .value;


            const _a = y/360*Tau;
            const _v = vector(_a, x);
            
            const _x = moveType == 0 ? x : _v.x;
            const _y = moveType == 0 ? y : _v.y;


            const singlePoint = 
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            let _cx = 50;
            let _cy = 50;

            if (!singlePoint)
            {
                _cx /= 100;
                _cy /= 100;
            }


            const cx = singlePoint ? this.value.objects[0].x + _cx : bounds.x + _cx * bounds.width;
            const cy = singlePoint ? this.value.objects[0].y + _cy : bounds.y + _cy * bounds.height;

            const xform = 
                moveType == 0
                ? createTransform(_x, _y)
                : mulm3m3(
                    createTransform(cx, cy),
                    createTransform(_x, _y),
                    createRotateTransform(-_a), // for vector movement
                    createTransform(-cx, -cy));

                
            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.applyTransform(xform, affectSpace > 0);
            }


            if (showCenter > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.x           && this.x          .isValid()
            && this.y           && this.y          .isValid()
            && this.moveType    && this.moveType   .isValid()
            && this.affectSpace && this.affectSpace.isValid()
            && this.showCenter  && this.showCenter .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.x          ) this.x          .pushValueUpdates(parse);
        if (this.y          ) this.y          .pushValueUpdates(parse);
        if (this.moveType   ) this.moveType   .pushValueUpdates(parse);
        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
        if (this.showCenter ) this.showCenter .pushValueUpdates(parse);
    }



   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.x          ) this.x          .invalidateInputs(parse, from);
        if (this.y          ) this.y          .invalidateInputs(parse, from);
        if (this.moveType   ) this.moveType   .invalidateInputs(parse, from);
        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from);
        if (this.showCenter ) this.showCenter .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.x          ) this.x          .iterateLoop(parse);
        if (this.y          ) this.y          .iterateLoop(parse);
        if (this.moveType   ) this.moveType   .iterateLoop(parse);
        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
        if (this.showCenter ) this.showCenter .iterateLoop(parse);
    }
}


class GAffine
extends GOperator1
{
    showCenter  = null;
    affectSpace = null;



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        super.copyBase(base);

        if (base.showCenter ) this.showCenter  = base.showCenter .copy();
        if (base.affectSpace) this.affectSpace = base.affectSpace.copy();
    }



    async evalBaseParams(parse)
    {
        const showCenter  = this.showCenter  ? (await this.showCenter .eval(parse)).toValue() : null;
        const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).toValue() : null;

        return [showCenter, affectSpace];
    }



    async evalAffineObjects(parse, options, scaleCorners, scaleStyle, getXform)
    {
        if (   !this.value
            || !this.value.isValid())
            return Rect.NaN;


        this.value.objects = getValidObjects(this.input.value);
        

        const bounds = getObjBounds(this.value.objects);
        const xform  = getXform();


        for (const obj of this.value.objects)
        {
            obj.nodeId   = this.nodeId;
            obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


            if (this.options.enabled)
            {
                obj.applyTransform(xform, options.affectSpace.value > 0);

                obj.scaleCorners *= Math.abs(scaleCorners);
                obj.scaleStyle   *= Math.abs(scaleStyle  );
            }
        }


        if (options.showCenter.value > 0)
        {
            const objects = [...this.value.objects]; // avoids infinite growth
            objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
        }


        return bounds;
    }



    isValid()
    {
        return super.isValid()
            && this.showCenter  && this.showCenter .isValid()
            && this.affectSpace && this.affectSpace.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.showCenter ) this.showCenter .pushValueUpdates(parse);
        if (this.affectSpace) this.affectSpace.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.showCenter ) this.showCenter .invalidateInputs(parse, from);
        if (this.affectSpace) this.affectSpace.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.showCenter ) this.showCenter .iterateLoop(parse);
        if (this.affectSpace) this.affectSpace.iterateLoop(parse);
    }
}


class GRotate
extends GAffine
{
    angle = null;



    constructor(nodeId, options)
    {
        super(ROTATE, nodeId, options);
    }



    copy()
    {
        const copy = new GRotate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.angle) copy.angle = this.angle.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const angle = this.angle ? (await this.angle.eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                angle:       angle, 
                showCenter:  showCenter,
                affectSpace: affectSpace
            });

        
        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['angle',       angle      ],
            ['showCenter',  showCenter ],
            ['affectSpace', affectSpace],
            ['bounds',      bounds     ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const a = options.angle.value/360*Tau;

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 
            1,
            () => createRotateTransform(a));
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.angle && this.angle.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.angle) this.angle.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from)

        if (this.angle) this.angle.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.angle) this.angle.iterateLoop(parse);
    }
}


class GScale
extends GAffine
{
    scaleX        = null;
    scaleY        = null;
    affectCorners = null;
    affectStyle   = null;



    constructor(nodeId, options)
    {
        super(SCALE, nodeId, options);
    }



    copy()
    {
        const copy = new GScale(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();
        if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();
        if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();
        if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const scaleX        = this.scaleX        ? (await this.scaleX       .eval(parse)).toValue() : null;
        const scaleY        = this.scaleY        ? (await this.scaleY       .eval(parse)).toValue() : null;
        const affectCorners = this.affectCorners ? (await this.affectCorners.eval(parse)).toValue() : null;
        const affectStyle   = this.affectStyle   ? (await this.affectStyle  .eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

       
        const _bounds = await this.evalObjects(
            parse, 
            {
                scaleX:        scaleX, 
                scaleY:        scaleY, 
                showCenter:    showCenter,
                affectSpace:   affectSpace,
                affectCorners: affectCorners,
                affectStyle:   affectStyle
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['scaleX',        scaleX       ],
            ['scaleY',        scaleY       ],
            ['showCenter',    showCenter   ],
            ['affectSpace',   affectSpace  ],
            ['affectCorners', affectCorners],
            ['affectStyle',   affectStyle  ],
            ['bounds',        bounds       ]
        ]);
        

        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const sx    = options.scaleX.value / 100;
        const sy    = options.scaleY.value / 100;

        const scale = Math.min(sx, sy);

        return await this.evalAffineObjects(
            parse,
            options, 
            this.affectCorners.value > 0 ? scale : 1,
            this.affectStyle  .value > 0 ? scale : 1,
            () => [[sx, 0,  0],
                   [0,  sy, 0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.scaleX        && this.scaleX       .isValid()
            && this.scaleY        && this.scaleY       .isValid()
            && this.affectCorners && this.affectCorners.isValid()
            && this.affectStyle   && this.affectStyle  .isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.scaleX       ) this.scaleX       .pushValueUpdates(parse);
        if (this.scaleY       ) this.scaleY       .pushValueUpdates(parse);
        if (this.affectCorners) this.affectCorners.pushValueUpdates(parse);
        if (this.affectStyle  ) this.affectStyle  .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.scaleX       ) this.scaleX       .invalidateInputs(parse, from);
        if (this.scaleY       ) this.scaleY       .invalidateInputs(parse, from);
        if (this.affectCorners) this.affectCorners.invalidateInputs(parse, from);
        if (this.affectStyle  ) this.affectStyle  .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.scaleX       ) this.scaleX       .iterateLoop(parse);
        if (this.scaleY       ) this.scaleY       .iterateLoop(parse);
        if (this.affectCorners) this.affectCorners.iterateLoop(parse);
        if (this.affectStyle  ) this.affectStyle  .iterateLoop(parse);
    }
}


class GSkew
extends GAffine
{
    skewX = null;
    skewY = null;



    constructor(nodeId, options)
    {
        super(SKEW, nodeId, options);
    }



    copy()
    {
        const copy = new GSkew(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.skewX) copy.skewX = this.skewX.copy();
        if (this.skewY) copy.skewY = this.skewY.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const skewX = this.skewX ? (await this.skewX.eval(parse)).toValue() : null;
        const skewY = this.skewY ? (await this.skewY.eval(parse)).toValue() : null;

        const [showCenter, affectSpace] = await this.evalBaseParams(parse);


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

        
        const _bounds = await this.evalObjects(
            parse, 
            {
                skewX:       skewX, 
                skewY:       skewY, 
                showCenter:  showCenter,
                affectSpace: affectSpace
            });


        const bounds = new RectangleValue(
            this.nodeId,
            new NumberValue(_bounds.x     ), 
            new NumberValue(_bounds.y     ), 
            new NumberValue(_bounds.width ),
            new NumberValue(_bounds.height),
            new NumberValue(0));


        this.setUpdateValues(parse,
        [
            ['skewX',       skewX      ],
            ['skewY',       skewY      ],
            ['showCenter',  showCenter ],
            ['affectSpace', affectSpace],
            ['bounds',      bounds     ]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        const sx = -options.skewX.value / 100;
        const sy = -options.skewY.value / 100;

        return await this.evalAffineObjects(
            parse,
            options, 
            1, 1,
            () => [[1,  sx, 0],
                   [sy, 1,  0],
                   [0,  0,  1]]);
    }



    isValid()
    {
        return super.isValid()
            && this.skewX && this.skewX.isValid()
            && this.skewY && this.skewY.isValid();
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);GVectorPath

        if (this.skewX) this.skewX.pushValueUpdates(parse);
        if (this.skewY) this.skewY.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.skewX) this.skewX.invalidateInputs(parse, from);
        if (this.skewY) this.skewY.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);GVectorPath

        if (this.skewX) this.skewX.iterateLoop(parse);
        if (this.skewY) this.skewY.iterateLoop(parse);
    }
}


class GCenter
extends GOperator1
{
    centerX    = null;
    centerY    = null;
    showCenter = null;



    constructor(nodeId, options)
    {
        super(CENTER, nodeId, options);
    }



    copy()
    {
        const copy = new GMove(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.centerX   ) copy.centerX    = this.centerX   .copy();
        if (this.centerY   ) copy.centerY    = this.centerY   .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const centerX    = this.centerX    ? (await this.centerX   .eval(parse)).toValue() : null;
        const centerY    = this.centerY    ? (await this.centerY   .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
        {
            this.value = NullValue.copy();
        }

        
        await this.evalObjects(
            parse, 
            {
                centerX:    centerX, 
                centerY:    centerY,
                showCenter: showCenter
            });


        this.setUpdateValues(parse,
        [
            ['centerX',    centerX   ],
            ['centerY',    centerY   ],
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);

            
            const centerX     = options.centerX   .value;
            const centerY     = options.centerY   .value;
            const showCenter  = options.showCenter.value;
     
            const cx          = centerX/100;
            const cy          = centerY/100;


            const bounds      = getObjBounds(this.value.objects);

            const singlePoint =  
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                    obj.resetSpace(bounds, singlePoint, cx, cy);
            }


            if (showCenter > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
            ? this.value.copy()
            : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.centerX    && this.centerX   .isValid()
            && this.centerY    && this.centerY   .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.centerX   ) this.centerX   .pushValueUpdates(parse);
        if (this.centerY   ) this.centerY   .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.centerX   ) this.centerX   .invalidateInputs(parse, from);
        if (this.centerY   ) this.centerY   .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.centerX   ) this.centerX   .iterateLoop(parse);
        if (this.centerY   ) this.centerY   .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GResetTransform
extends GOperator1
{
    showCenter = null;



    constructor(nodeId, options)
    {
        super(RESET_XFORM, nodeId, options);
    }



    copy()
    {
        const copy = new GResetTransform(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
            this.value = NullValue.copy();

        
        await this.evalObjects(parse, { showCenter: showCenter });


        this.setUpdateValues(parse,
        [
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const showCenter = options.showCenter.value;


            const bounds = getObjBounds(this.value.objects);

            const singlePoint =
                   this.value.objects.length  == 1 
                && this.value.objects[0].type == POINT;


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;

                if (this.options.enabled)
                {
                    obj.createDefaultSpace();
                    obj.resetSpace(bounds, singlePoint);
                }
            }


            if (showCenter)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
        ? this.value.copy()
        : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



   invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GMeasurePoints
extends GOperator2
{
    distance = null;
    angle    = null;


    
    constructor(nodeId, options)
    {
        super(MEASURE_POINTS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMeasurePoints(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.distance) copy.distance = this.distance.copy();
        if (this.angle   ) copy.angle    = this.angle   .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                const dist = distance(input0.toPoint(), input1.toPoint());

                let ang = angle(subv(input1.toPoint(), input0.toPoint()));
                if (ang > Tau/2) ang -= Tau;

                this.distance = new NumberValue(dist);
                this.angle    = new NumberValue(ang / Tau * 360);
            }
            else
            {
                this.distance = NumberValue.NaN;
                this.angle    = NumberValue.NaN;
            }
        }
        else
        {
            this.distance = NumberValue.NaN;
            this.angle    = NumberValue.NaN;
        }


        this.setUpdateValues(parse,
        [
            ['distance', this.distance],
            ['angle',    this.angle   ]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.distance && this.distance.isValid()
            && this.angle    && this.angle   .isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.distance) this.distance.pushValueUpdates(parse);
        if (this.angle   ) this.angle   .pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.distance) this.distance.invalidateInputs(parse, from);
        if (this.angle   ) this.angle   .invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.distance) this.distance.iterateLoop(parse);
        if (this.angle   ) this.angle   .iterateLoop(parse);
    }
}


class GInterpolatePoint
extends GOperator2
{
    amount     = null;
    transform  = null;
    showCenter = null;


    
    constructor(nodeId, options)
    {
        super(INTERPOLATE_POINT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GInterpolatePoint(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.amount    ) copy.amount     = this.amount    .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount     = this.amount     ? (await this.amount    .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                const p0  = point(input0.objects[0].x, input0.objects[0].y);
                const p1  = point(input1.objects[0].x, input1.objects[0].y);
                const amt = amount.value / 100;

                const p   = lerpv(p0, p1, amt);

                    
                let sp0 = lerpv(input0.objects[0].sp0, input1.objects[0].sp0, amt);
                let sp1 = lerpv(input0.objects[0].sp1, input1.objects[0].sp1, amt);
                let sp2 = lerpv(input0.objects[0].sp2, input1.objects[0].sp2, amt);

                if (transform.value > 0)
                {
                    const l1 = distance(sp0, sp1);
                    const l2 = distance(sp0, sp2);

                    sp0 = clone(p);
                    sp1 = addv(sp0, mulvs(unitv(subv(p1, p0)), l1));
                    sp2 = addv(sp0, crossv(mulvs(unitv(subv(p1, p0)), l2)));
                }


                this.value = new PointValue(this.nodeId, new NumberValue(p.x), new NumberValue(p.y));

                const pt = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);
                pt.createDefaultTransform(p.x, p.y);
                this.value.objects = [pt];

                this.value.objects[0].sp0 = sp0;
                this.value.objects[0].sp1 = sp1;
                this.value.objects[0].sp2 = sp2;


                if (showCenter.value > 0)
                {
                    const objects = [...this.value.objects]; // avoids infinite growth
                    objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
                }
            }
        }


        this.setUpdateValues(parse,
        [
            ['amount',     amount    ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);
        

        this.validate();

        return this;
    }



    isValid()
    {
        return super.isValid()
            && this.amount     && this.amount    .isValid()
            && this.transform  && this.transform .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.amount    ) this.amount    .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.amount    ) this.amount    .invalidateInputs(parse, from);
        if (this.transform ) this.transform .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.amount    ) this.amount    .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GPointOnPath
extends GOperator2
{
    measure    = null;
    amount     = null;
    transform  = null;
    showCenter = null;


    
    constructor(nodeId, options)
    {
        super(POINT_ON_PATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GPointOnPath(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.measure   ) copy.measure    = this.measure   .copy();
        if (this.amount    ) copy.amount     = this.amount    .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const measure    = this.measure    ? (await this.measure   .eval(parse)).toValue() : null;
        const amount     = this.amount     ? (await this.amount    .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;


        if (   this.input0
            && this.input1)
        {
            const input0 = this.input0 ? (await this.input0.eval(parse)).toValue() : null;
            const input1 = this.input1 ? (await this.input1.eval(parse)).toValue() : null;

            if (   input0
                && input1)
            {
                // const p0  = point(input0.objects[0].x, input0.objects[0].y);
                // const p1  = point(input1.objects[0].x, input1.objects[0].y);
                // const amt = amount.value / 100;

                // const p   = lerpv(p0, p1, amt);

                    
                // let sp0 = lerpv(input0.objects[0].sp0, input1.objects[0].sp0, amt);
                // let sp1 = lerpv(input0.objects[0].sp1, input1.objects[0].sp1, amt);
                // let sp2 = lerpv(input0.objects[0].sp2, input1.objects[0].sp2, amt);

                // if (transform.value > 0)
                // {
                //     const l1 = distance(sp0, sp1);
                //     const l2 = distance(sp0, sp2);

                //     sp0 = clone(p);
                //     sp1 = addv(sp0, mulvs(unitv(subv(p1, p0)), l1));
                //     sp2 = addv(sp0, crossv(mulvs(unitv(subv(p1, p0)), l2)));
                // }


                // this.value = new PointValue(this.nodeId, new NumberValue(p.x), new NumberValue(p.y));

                // const pt = new FigmaPoint(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);
                // pt.createDefaultTransform(p.x, p.y);
                // this.value.objects = [pt];

                // this.value.objects[0].sp0 = sp0;
                // this.value.objects[0].sp1 = sp1;
                // this.value.objects[0].sp2 = sp2;


                // if (showCenter.value > 0)
                // {
                //     const objects = [...this.value.objects]; // avoids infinite growth
                //     objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
                // }
            }
        }


        this.setUpdateValues(parse,
        [
            ['measure',    measure   ],
            ['amount',     amount    ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);
        

        this.validate();

        return this;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.measure   ) this.measure   .pushValueUpdates(parse);
        if (this.amount    ) this.amount    .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.measure   ) this.measure   .invalidateInputs(parse, from);
        if (this.amount    ) this.amount    .invalidateInputs(parse, from);
        if (this.transform ) this.transform .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.measure   ) this.measure   .iterateLoop(parse);
        if (this.amount    ) this.amount    .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}


class GPlace
extends GOperator1
{
    position   = null;
    transform  = null;
    showCenter = null;



    constructor(nodeId, options)
    {
        super(PLACE, nodeId, options);
    }



    copy()
    {
        const copy = new GPlace(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.position  ) copy.position   = this.position  .copy();
        if (this.transform ) copy.transform  = this.transform .copy();
        if (this.showCenter) copy.showCenter = this.showCenter.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const position   = this.position   ? (await this.position  .eval(parse)).toValue() : null;
        const transform  = this.transform  ? (await this.transform .eval(parse)).toValue() : null;
        const showCenter = this.showCenter ? (await this.showCenter.eval(parse)).toValue() : null;

        if (   this.input
            && position)
        {
            this.value = (await this.input.eval(parse)).toValue();

            if (this.value)
                this.value.nodeId = this.nodeId;
        }
        else
            this.value = null;//NullValue.copy();



        if (   position
            && position.isValid())
            // && position.objects
            // && position.objects.length > 0)
        {
            const p0 = position.toPoint();//point(
                // position/*.objects[0]*/.x, 
                // position/*.objects[0]*/.y);

            const p1 = addv(p0, subv(position/*.objects[0]*/.sp1, position/*.objects[0]*/.sp0));
            const p2 = addv(p0, subv(position/*.objects[0]*/.sp2, position/*.objects[0]*/.sp0));

            await this.evalObjects(
                parse, 
                {
                    transform:  transform,
                    showCenter: showCenter,
                    sp0:        p0,
                    sp1:        p1,
                    sp2:        p2
                });
        }

        
        this.setUpdateValues(parse,
        [
            ['position',   position  ],
            ['transform',  transform ],
            ['showCenter', showCenter]
        ]);


        this.validate();

        return this;
    }



    async evalObjects(parse, options)
    {
        if (   this.value
            && this.value.isValid())
        {
            this.value.objects = getValidObjects(this.input.value);


            const place = createTransform(
                options.sp0 ? options.sp0.x : 0,
                options.sp0 ? options.sp0.y : 0);


            for (const obj of this.value.objects)
            {
                obj.nodeId   = this.nodeId;
                obj.objectId = obj.objectId + OBJECT_SEPARATOR + this.nodeId;


                if (this.options.enabled)
                {
                    let xform = mulm3m3(
                        createTransform(
                            -obj.sp0.x, 
                            -obj.sp0.y),
                        place);


                    if (   options.transform.value > 0
                        && options.sp0
                        && options.sp1
                        && options.sp2)
                    {
                        const sp = getTransformFromPoints(
                            options.sp0, 
                            options.sp1, 
                            options.sp2);

                        xform = mulm3m3(xform, sp);

                        obj.sp1 = addv(obj.sp0, point(1, 0));
                        obj.sp2 = addv(obj.sp0, point(0, 1));
                    }


                    obj.applyTransform(xform, true);
                }
            }


            if (options.showCenter.value > 0)
            {
                const objects = [...this.value.objects]; // avoids infinite growth
                objects.forEach(o => addObjectCenter(this, o, parse.viewportZoom));
            }
        }
        
        
        await super.evalObjects(parse);
    }



    toValue()
    {
        return this.value
             ? this.value.copy()
             : null;
    }
    
    
    
    isValid()
    {
        return super.isValid()
            && this.position   && this.position  .isValid()
            && this.transform  && this.transform .isValid()
            && this.showCenter && this.showCenter.isValid();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.position  ) this.position  .pushValueUpdates(parse);
        if (this.transform ) this.transform .pushValueUpdates(parse);
        if (this.showCenter) this.showCenter.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.position  ) this.position  .invalidateInputs(parse, from);
        if (this.transform ) this.transform .invalidateInputs(parse, from);
        if (this.showCenter) this.showCenter.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.position  ) this.position  .iterateLoop(parse);
        if (this.transform ) this.transform .iterateLoop(parse);
        if (this.showCenter) this.showCenter.iterateLoop(parse);
    }
}



function getTransformFromPoints(p0, p1, p2) 
{
    const dx   = p1.x - p0.x;
    const dy   = p1.y - p0.y;

    const a    = Math.atan2(dy, dx);
  
    const cosa = Math.cos(a);
    const sina = Math.sin(a);


    const sx   = ((p1.y - p0.y) / nozero(p1.x - p0.x));
    const sy   = ((p2.x - p0.x) / nozero(p2.y - p0.y));

    // TODO add skew 

    return [[ cosa,         -sina /** sy*/, 0 ], 
            [ sina /** sx*/, cosa,          0 ], 
            [ 0,             0,             1 ]];
}


class GGroupNode
extends GOperator
{
    paramIds = [];
    params   = [];



    constructor(nodeId, options)
    {
        super(GROUP_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGroupNode(this.nodeId, this.options);

        copy.copyBase(this);

        copy.params = this.params.map(p => p.copy());

        return copy;
    }



    paramFromId(paramId)
    {
        return this.params[this.paramIds.findIndex(id => id == paramId)];
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.updateValues = [];


        if (!isEmpty(this.params))
        {
            for (let i = 0; i < this.params.length; i++)
            {
                const param = await this.params[i].eval(parse);
                this.setUpdateValues(parse, [[this.paramIds[i], param.toValue()]], true);
            }
        }
        else
            this.setUpdateValues(parse, [['', NullValue]], true);
                
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        this.inputs.forEach(i => i.pushValueUpdates(parse))
        this.params.forEach(p => p.pushValueUpdates(parse))
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        this.inputs.forEach(i => i.invalidateInputs(parse, from))
        this.params.forEach(p => p.invalidateInputs(parse, from))
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        this.inputs.forEach(i => i.iterateLoop(parse))
        this.params.forEach(p => p.iterateLoop(parse))
    }
}



class GGroupParam
extends GOperator
{
    input = null;
    
    dataType = NULL;



    constructor(nodeId, options)
    {
        super(GROUP_PARAM, nodeId, options);
    }



    copy()
    {
        const copy = new GGroupParam(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.dataType = this.dataType;
      
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            if (!this.input.value)
                await this.input.eval(parse);

            this.value = this.input.toValue();
        }

        else if (this.dataType != NULL)
            this.value = nanFromType(this.dataType);
        
        else
            this.value = NullValue.copy();


        this.setUpdateValues(parse,
        [
            ['value', this.value]
        ]);


        this.validate();

        return this;
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    toValue()
    {
        return this.value.copy();
    }



    pushValueUpdates(parse)
    {
        super.pushValueUpdates(parse);

        if (this.input) this.input.pushValueUpdates(parse);
    }



    invalidateInputs(parse, from)
    {
        super.invalidateInputs(parse, from);

        if (this.input) this.input.invalidateInputs(parse, from);
    }



    iterateLoop(parse)
    {
        super.iterateLoop(parse);

        if (this.input) this.input.iterateLoop(parse);
    }
}


class GComment
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GComment(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue.copy();


        this.setUpdateValues(parse, [['', NullValue]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GPanel
extends GOperator
{
    constructor(nodeId, options)
    {
        super(PANEL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GPanel(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue.copy();


        this.setUpdateValues(parse, [['', NullValue]]);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



const settings =
{
    dataMode:                      false,
    debugMode:                     false,
        
    enableZoomedOutParams:         false,
    minZoomForParams:              0.35,
    showPages:                     false,
    showAllColorSpaces:            false,
    showNodeIcons:                 true,
    showBoolValues:                true,
    showColorLegendInMenus:        false,
    showOperationResults:          false,
    showClearUndoWarning:          true,
    showDebugMenu:                 false,
        
    showNodeId:                    false, // instead of name
    showTransformPoints:           false,
    enableAsserts:                 false,

    showTooltipLongText:           true,
    showTooltipColorInterpolation: true,
    showTooltipColorBlindness:     true,
    showTooltipColorContrast:      true,

    //enableBetaFeatures:            false,
            
    logThreadMessages:             false,
    logDataMessages:               false,
    logMessages:                   false,

    logActions:                    false, 
            
    logLoading:                    false, 
    logRequests:                   false, 
    logValueUpdates:               false, 
    logObjectUpdates:              false,
    logStyleUpdates:               false,
            
    logRawLoadPages:               false, 
    logRawLoadNodes:               false, 
    logRawLoadConnections:         false, 
        
    logRawSavePages:               false, 
    logRawSaveNodes:               false, 
    logRawSaveConnections:         false, 
        
    logRawRequests:                false, 
    logRawValues:                  false,

    sessionId:                     ''
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'dataMode':                      settings.dataMode                      = value;  break;
        case 'debugMode':                     settings.debugMode                     = value;  break;
                
        case 'enableZoomedOutParams':         settings.enableZoomedOutParams         = value;  break;
        case 'minZoomForParams':              settings.minZoomForParams              = value;  break;
        case 'showPages':                     settings.showPages                     = value;  break;
        case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;
        case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;
        case 'showBoolValues':                settings.showBoolValues                = value;  break;
        case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;
        case 'showOperationResults':          settings.showOperationResults          = value;  break;
        case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;
        case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;
                        
        case 'showNodeId':                    settings.showNodeId                    = value;  break;
        case 'showTransformPoints':           settings.showTransformPoints           = value;  break;
        case 'enableAsserts':                 settings.enableAsserts                 = value;  break;

        case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;
        case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;
        case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;
        case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;

        //case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;
                   
        case 'logThreadMessages':             settings.logThreadMessages             = value;  break;
        case 'logDataMessages':               settings.logDataMessages               = value;  break;
        case 'logMessages':                   settings.logMessages                   = value;  break;

        case 'logActions':                    settings.logActions                    = value;  break;
        case 'logLoading':                    settings.logLoading                    = value;  break;
        case 'logRequests':                   settings.logRequests                   = value;  break;
        case 'logValueUpdates':               settings.logValueUpdates               = value;  break;
        case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;
        case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;
                   
        case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;
        case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;
        case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;
                
        case 'logRawSavePages':               settings.logRawSavePages               = value;  break;
        case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;
        case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;
                
        case 'logRawRequests':                settings.logRawRequests                = value;  break;
        case 'logRawValues':                  settings.logRawValues                  = value;  break;

        case 'sessionId':                     settings.sessionId                     = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'dataMode':                      updateSettingAndMenu_(valid, settingName, value, menuItemDataMode                     ); break;
        case 'debugMode':                     updateSettingAndMenu_(valid, settingName, value                                       ); break;
              
        case 'enableZoomedOutParams':         updateSettingAndMenu_(valid, settingName, value, menuItemEnableZoomedOutParams        ); break;
        case 'showPages':                     updateSettingAndMenu_(valid, settingName, value, menuItemShowPages                    ); break;
        case 'showAllColorSpaces':            updateSettingAndMenu_(valid, settingName, value, menuItemShowAllColorSpaces           ); break;
        case 'showNodeIcons':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeIcons                ); break;
        case 'showBoolValues':                updateSettingAndMenu_(valid, settingName, value, menuItemShowBoolValues               ); break;
        case 'showColorLegendInMenus':        updateSettingAndMenu_(valid, settingName, value, menuItemShowColorLegendInMenus       ); break;
        case 'showOperationResults':          updateSettingAndMenu_(valid, settingName, value, menuItemShowOperationResults         ); break;
        case 'showClearUndoWarning':          updateSettingAndMenu_(valid, settingName, value, menuItemShowClearUndoWarning         ); break;
        case 'showDebugMenu':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowDebugMenu                ); break;
                      
        case 'showNodeId':                    updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId                   ); break;
        case 'showTransformPoints':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTransformPoints          ); break;
        case 'enableAsserts':                 updateSettingAndMenu_(valid, settingName, value, menuItemEnableAsserts                ); enableAsserts = value; break;
        
        case 'showTooltipLongText':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipLongText          ); break;
        case 'showTooltipColorContrast':      updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorContrast     ); break;
        case 'showTooltipColorInterpolation': updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorInterpolation); break;
        case 'showTooltipColorBlindness':     updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorBlindness    ); break;

        //case 'enableBetaFeatures':            //updateSettingAndMenu_(valid, settingName, value, menuItemEnableBetaFeatures           ); break;
                      
        case 'logThreadMessages':             updateSettingAndMenu_(valid, settingName, value, menuItemLogThreadMessages            ); break;
        case 'logDataMessages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogDataMessages              ); break;
        case 'logMessages':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages                  ); break;

        case 'logActions':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogActions                   ); break;
        case 'logLoading':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading                   ); break;
        case 'logRequests':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests                  ); break;
        case 'logValueUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates              ); break;
        case 'logObjectUpdates':              updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates             ); break;
        case 'logStyleUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogStyleUpdates              ); break;
                      
        case 'logRawLoadPages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadPages              ); break;
        case 'logRawLoadNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadNodes              ); break;
        case 'logRawLoadConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadConnections        ); break;
                      
        case 'logRawSavePages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSavePages              ); break;
        case 'logRawSaveNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveNodes              ); break;
        case 'logRawSaveConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveConnections        ); break;
                      
        case 'logRawRequests':                updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests               ); break;
        case 'logRawValues':                  updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues                 ); break;
    } 


    if (   save
        && settingName != 'showAllColorSpaces')
        uiSetLocalData(settingName, boolToString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  


    if (setting == 'showNodeId')
    {
        uiPostMessageToFigma(
        {
            cmd:    'figUpdateShowIds',
            showIds: settings.showNodeId
        });
    }


    if (menu)
        menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemDataMode                     .setVisible(settings.dataMode                     );
    menuItemDebug                        .setVisible(settings.debugMode                    );
                
    menuItemEnableZoomedOutParams        .setChecked(settings.enableZoomedOutParams        );
    menuItemShowPages                    .setChecked(settings.showPages                    );
    menuItemShowAllColorSpaces           .setChecked(settings.showAllColorSpaces           );
    menuItemShowNodeIcons                .setChecked(settings.showNodeIcons                );
    menuItemShowBoolValues               .setChecked(settings.showBoolValues               );
    menuItemShowColorLegendInMenus       .setChecked(settings.showColorLegendInMenus       );
    menuItemShowOperationResults         .setChecked(settings.showOperationResults         );
    menuItemShowClearUndoWarning         .setChecked(settings.showClearUndoWarning         );
    menuItemShowDebugMenu                .setChecked(settings.showDebugMenu                );
                
    menuItemShowNodeId                   .setChecked(settings.showNodeId                   );
    menuItemShowTransformPoints          .setChecked(settings.showTransformPoints          );
    menuItemEnableAsserts                .setChecked(settings.enableAsserts                );

    menuItemShowTooltipLongText          .setChecked(settings.showTooltipLongText          );
    menuItemShowTooltipColorInterpolation.setChecked(settings.showTooltipColorInterpolation);
    menuItemShowTooltipColorBlindness    .setChecked(settings.showTooltipColorBlindness    );
    menuItemShowTooltipColorContrast     .setChecked(settings.showTooltipColorContrast     );

  //menuItemEnableBetaFeatures           .setChecked(settings.enableBetaFeatures           );
                  
    menuItemLogThreadMessages            .setChecked(settings.logThreadMessages            );
    menuItemLogDataMessages              .setChecked(settings.logDataMessages              );
    menuItemLogMessages                  .setChecked(settings.logMessages                  );

    menuItemLogActions                   .setChecked(settings.logActions                   );
                  
    menuItemLogLoading                   .setChecked(settings.logLoading                   );
    menuItemLogRequests                  .setChecked(settings.logRequests                  );
    menuItemLogValueUpdates              .setChecked(settings.logValueUpdates              );
    menuItemLogObjectUpdates             .setChecked(settings.logObjectUpdates             );
    menuItemLogStyleUpdates              .setChecked(settings.logStyleUpdates              );
                  
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadPages              );
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadNodes              );
    menuItemLogRawLoadConnections        .setChecked(settings.logRawLoadConnections        );
                    
    menuItemLogRawSavePages              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveNodes              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveConnections        .setChecked(settings.logRawSaveConnections        );
                
    menuItemLogRawRequests               .setChecked(settings.logRawRequests               );
    menuItemLogRawValues                 .setChecked(settings.logRawValues                 );
}



function updateMenuItemShowPages()
{
    uiSetPageData('showPages', boolToString(settings.showPages));
    graph.updatePages();
    graphView.update();
}



function updateMenuItemShowAllColorSpaces()
{
    uiSetPageData('showAllColorSpaces', boolToString(settings.showAllColorSpaces));

    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowNodeIcons()
{
    graph.nodes.forEach(n => n.updateNode());
}



function updateMenuItemShowBoolValues()
{
    graph.nodes
        .filter(n => 
               NUMBER_BOOLEAN_TYPES.includes(n.type)
            ||      CONDITION_TYPES.includes(n.type)
            ||         AFFINE_TYPES.includes(n.type)
            || n.type == IF_ELSE)
        .forEach(n => n.updateNode());
}



function updateMenuItemShowColorLegendInMenus()
{
    for (const menu of menuBarMenus)
        menu.items.forEach(i => i.updateLegend());
}



function updateMenuItemShowOperationResults()
{
    const nodes = graph.nodes
        .filter(n => n.params.find(p => p.isResult));

    nodes.forEach(n => 
    {
        const rectd = n.measureData.divOffset;
        const recth = n.measureData.headerOffset;

        n.setRect(rectd.x, rectd.y, recth.w, recth.h, false);
        n.updateNode();
    });

    graphView.updateNodeTransforms(nodes);
}



function enableFeatures(sub, beta = false)
{
    enableSubscribedMenuItem(menuItemSaveToFile,   sub);
    enableSubscribedMenuItem(menuItemTimer,        sub);
    enableSubscribedMenuItem(menuItemAnimate,      sub);
    enableSubscribedMenuItem(menuItemFetch,        sub);
    enableSubscribedMenuItem(menuItemTextFile,     sub);
    enableSubscribedMenuItem(menuItemDateTime,     sub);
    enableSubscribedMenuItem(menuItemSolve,        sub);
    enableSubscribedMenuItem(menuItemTextJson,     sub);
    enableSubscribedMenuItem(menuItemCorrectColor, sub);
    enableSubscribedMenuItem(menuItemConvertToP3,  sub);
    enableSubscribedMenuItem(menuItemShapeRender,  sub);

    graph.nodes.forEach(n => n.updateSubscribeStatus(sub));
}



function enableSubscribedMenuItem(menuItem, sub)
{
    menuItem.enabled   =  sub;  
    menuItem.subscribe = !sub;    
    menuItem.update();
}



function updateMenuItemShowDebugMenu()
{
    updateElementDisplay(menuItemDebug.div, settings.showDebugMenu);

    menuMain.update(
        boundingRect(menuMain.div).x + 6,
        boundingRect(menuMain.div).y - 4,
        true);
}

 

function updateElementDisplay(menuItem, enable)
{
    menuItem.style.display = enable ? 'block' : 'none';
}



function loadLocalSettings()
{
    uiGetLocalData('dataMode'                     );
    uiGetLocalData('debugMode'                    );
        
    uiGetLocalData('enableZoomedOutParams'        );
    uiGetLocalData('minZoomForParams'             );
    uiGetLocalData('showNodeIcons'                );
    uiGetLocalData('showBoolValues'               );
    uiGetLocalData('showColorLegendInMenus'       );
    uiGetLocalData('showPages'                    );
    uiGetLocalData('showOperationResults'         );
    uiGetLocalData('showClearUndoWarning'         );
    uiGetLocalData('showDebugMenu'                );
        
    uiGetLocalData('showNodeId'                   );
    uiGetLocalData('showTransformPoints'          );
    uiGetLocalData('enableAsserts'                );

    uiGetLocalData('showTooltipLongText'          );
    uiGetLocalData('showTooltipColorInterpolation');
    uiGetLocalData('showTooltipColorBlindness'    );
    uiGetLocalData('showTooltipColorContrast'     );

  //uiGetLocalData('enableBetaFeatures'           );
            
    uiGetLocalData('logThreadMessages'            );
    uiGetLocalData('logDataMessages'              );
    uiGetLocalData('logMessages'                  );

    uiGetLocalData('logActions'                   );
            
    uiGetLocalData('logLoading'                   );
    uiGetLocalData('logRequests'                  );
    uiGetLocalData('logValueUpdates'              );
    uiGetLocalData('logObjectUpdates'             );
    uiGetLocalData('logStyleUpdates'              );
            
    uiGetLocalData('logRawLoadPages'              );
    uiGetLocalData('logRawLoadNodes'              );
    uiGetLocalData('logRawLoadConnections'        );
        
    uiGetLocalData('logRawSavePages'              );
    uiGetLocalData('logRawSaveNodes'              );
    uiGetLocalData('logRawSaveConnections'        );
        
    uiGetLocalData('logRawRequests'               );
    uiGetLocalData('logRawValues'                 );

    uiGetLocalData('sessionId'                    );
}


function crashAssert(condition, error, showDebugButton = true)
{
    if (condition) return;

    initCrashDialog(error, null, showDebugButton);
    showCrashDialog();

    consoleError(error);
}



function initCrashDialog(event, error, showDebugButton = true)
{
    if (error)
    {
        let stack = error.stack
            .replaceAll('<anonymous>', '')
            .replaceAll('.<', '<')
            .replaceAll(/\(?data[a-zA-Z0-9/,;:=]*\)?/g, '')
            .replaceAll('at \n', '')
            .replaceAll('at ', '<br/>&nbsp;&nbsp;&nbsp;&nbsp;at ')
            .replaceAll(/\(:[^\)]*\)/g, '')
            .replaceAll(/at :[0-9]+:[0-9]+/g, '');

        crashDetails.innerHTML += stack + '<br/>';
    }
    else
        crashDetails.innerHTML += event + '<br/>';
        

    if (!crashed)
    {
        crashBack.addEventListener('pointerdown', e => { e.preventDefault(); });

        btnCrashRestart.addEventListener('click', () => uiRestartGenerator(true));
        btnCrashRestart.style.display = showDebugButton ? 'block' : 'none';

        crashDetails.addEventListener('pointerup', e =>
        {
            if (e.button == 2)
            {
                e.preventDefault();
                e.stopImmediatePropagation();

                initCopyMenu();
                menuCopy.showAt(e.clientX, e.clientY, false, false);
            }
        });
    }
}



function showCrashDialog()
{
    crashed = true;


    if (loadRestartTimer > -1) 
    {
        clearTimeout(loadRestartTimer);
        loadRestartTimer = -1;
    }


    crashBack  .style.display = 'block';
    crashDialog.style.display = 'block';

    dialogShown = true;
}



function hideCrashDialog()
{
    crashBack  .style.display = 'none';
    crashDialog.style.display = 'none';

    dialogShown = false;
}


class Control
extends EventTarget
{
    param;

    id;
    
    name;
    savedName    = '';

    overrideText = '';
    
    
    div;
    divValue;


    width;
    height;


    pointerEvents = true;


    measureData = { divBounds: new Rect(0, 0, 0, 0) };
 

    
    constructor(divValue, param, id, name, width = defNodeWidth, height = defParamHeight)
    {
        super();

        this.div           = createDiv('control');
        this.divValue      = divValue;
        
        this.param         = param;
        
        this.id            = id;
        this.name          = name;


        this.onstartchange = new Event('startchange');
        this.onchange      = new Event('change');
        this.onconfirm     = new Event('confirm');


        this.setSize(width, height);
    }



    setSize(w, h)
    {
        this.width            = w;
        this.height           = h;
        
        this.div.style.width  = '100%';//w + 'px';
        this.div.style.height = '100%';//Math.max(20, h) + 'px';
    }



    updateMeasureData()
    {
        this.measureData = 
        {
            offsetRect: offsetRect(this.div),
            clientRect: clientRect(this.div)
        };
    }


    
    update()
    {

    }



    lockPointer(pointerId)
    {
        clearTimeout(this.clickTimer);

        this.div.requestPointerLock =    
               this.div.      requestPointerLock 
            || this.div.   mozRequestPointerLock
            || this.div.webkitRequestPointerLock;

        this.div.requestPointerLock();
    }



    unlockPointer(pointerId)
    {
        document.exitPointerLock =    
               document.      exitPointerLock    
            || document.   mozExitPointerLock
            || document.webkitExitPointerLock;

        document.exitPointerLock();
    }



    isPointerLocked()
    {
        return (document.      pointerLockElement === this.div 
             || document.   mozPointerLockElement === this.div
             || document.webkitPointerLockElement === this.div);
    }



    checkDragConnection()
    {
        let savedInput = 
            graphView.savedConn
            ? graphView.savedConn.input
            : null;


        if (    graphView.tempConn.output
            &&  this.param.input
            &&  this.param.input.canConnectFrom(graphView.tempConn.output)
            && !graphView.tempConn.output.node.isOrFollows(this.param.node)
            && (  !this.param.input.connected // not already connected to this input
                || this.param.input.connectedOutput != graphView.tempConn.output
                || this.param.input == savedInput))
        {
            graphView.overInput = this.param.input;
                
            this.param.input.mouseOver = true;
            this.param.input.updateControl();


            const rect = boundingRect(this.param.input.div);

            graphView.tempConn.wire.inputPos = point(
                rect.x + rect.w/2,
                rect.y + rect.h/2 - getTopHeight());

            graphView.tempConn.wire.update();


            graphView.tempConn.output.updateControl();
        }
        else if ( graphView.tempConn.input
                &&  this.param.output
                &&  graphView.tempConn.input.canConnectFrom(this.param.output)
                && !this.param.node.isOrFollows(graphView.tempConn.input.node))
        {
            graphView.overOutput = this.param.output;
                
            this.param.output.mouseOver = true;
            this.param.output.updateControl();


            const rect = boundingRect(this.param.output.div);

            graphView.tempConn.wire.outputPos = point(
                rect.x + rect.w/2,
                rect.y + rect.h/2 - getTopHeight());

            graphView.tempConn.wire.update();


            graphView.tempConn.input.updateControl();
        }
    }
}



function controlTimer_confirm(control)
{
    if (control.param)
        control.param.changing = false;
}


class EmptyControl
extends Control
{
    constructor(div, param)
    {
        super(div, param, NULL, NULL);
    }



    canReact(e)
    {
        return false;
    }
}



class NumberControl
extends Control
{
    divBar;
    divPrecision;
    textbox;
    divFocus;

    extLeft;
    extRight;



    value;
    valueScale            = 1;

    min;
    max;

    displayMin;
    displayMax;

    thinMinus             = false;
    displayAbsolute       = false;
    
    epsilon               = Epsilon;

    acc;
     
    decimals;
    displayDec;
    
    
    wrapValue             = false;


    showHex               = false;

               
    suffix;
    valueCanContainSuffix = false;
    suffixOffsetY         = 0;
     
    dragReverse           = false;
    dragScale;
    wheelScale;
             
    backStyleLight        = 'rgba(255, 255, 255, 0.95)';
    valueStyleLight       = '#7772';
    textStyleLight        = '#000';
                
    backStyleDark         = 'rgba(56, 56, 56, 0.95)';
    valueStyleDark        = '#ffffff20';
    textStyleDark         = '#eee';
                
            
    enableChangeEvent     = true;
    
    successOnFocusOut     = false;
    keyBlur               = false;
    
    readOnly              = false;
     
    allowEditDecimals     = true;
    

    delayUse              = 0;
    delayUseTimer         = null;


    valueText             = '';

    
    showNanValueName      = true; // show the name even if the value is NaN
    showBar               = true;

    barTop                = 0;
    barBottom             = 1;
     
    ranges                = [];
    rangeDivs             = [];
    
    showExtRanges         = true;

    options               = []; // if dec == 0, show named choices instead of a value


    mouseOver             = false;
    buttonDown0           = false;
    buttonDown1           = false;
    shiftDown             = false;
    
    clickSize             = 4;
    moved                 = false;
         
    tabIndex              = 0;
    inFocus               = false;
    clicked               = false;
 
    startValue            = 0;
    oldValue; 
 

    confirmTimer          = null;
    
    
    
    constructor(param, id, name, defaultValue, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER, dec = 0, dragScale = 0.05, wheelScale = 1, acc = 0, suffix = '')
    {
        const divValue = createDiv('numberControlValue');


        super(divValue, param, id, name);


        this.value                 = defaultValue;
    
        this.min                   = min;
        this.max                   = max;
    
        this.displayMin            = min;
        this.displayMax            = max;
    
        this.thinMinus             = false;
        this.displayAbsolute       = false;
        
        this.epsilon               = Epsilon;
    
        this.acc                   = acc;
         
        this.decimals                   =
        this.displayDec            = dec;
             
        this.valueScale            = 1;
                    
        this.suffix                = suffix;
        this.valueCanContainSuffix = false;
         

        this.dragReverse           = false;
        this.dragScale             = dragScale;
        this.wheelScale            = wheelScale;
    

        this.divBar                = createDiv('numberControlBar');
        this.divPrecision          = createDiv('numberControlPrecision');
        this.divValue              = divValue;
        this.divFocus              = createDiv('numberControlFocus');
        this.extLeft               = createDiv('numberControlExt numberControlExtLeft');
        this.extRight              = createDiv('numberControlExt numberControlExtRight');


        this.div.appendChild(this.divPrecision);
        this.div.appendChild(this.divValue);
        
        this.param.div.appendChild(this.divBar);
        this.param.div.appendChild(this.divFocus);
        
        this.param.div.appendChild(this.extLeft);
        this.param.div.appendChild(this.extRight);
        


        this.initTextbox();
        this.initEvents ();


        this.div.style.position  = 'relative';
        // this.div.style.boxShadow = '0 0 0 2px blue inset';
    }



    canReact(e)
    {
        if (   (   settings.enableZoomedOutParams
                || graph.currentPage.zoom > settings.minZoomForParams)
            && !this.delayUseTimer)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.param.node.header);

        return false;
    }



    startDelayUseTimer()
    {
        if (this.delayUseTimer)
            clearTimeout(this.delayTimer);

        this.delayUseTimer = setTimeout(() => 
        {
            this.delayUseTimer = false;
            this.updateCursor();    
        }, 
        this.delayUse);
    }



    setName(name)
    {
        this.name      = name;
        this.savedName = name;
        
        this.update();
    }



    setValue(value, fireChangeEvent = true, confirm = true, fullRange = true)
    {
        const oldValue = this.value;

        
        if (this.wrapValue)
        {
            const range = this.displayMax - this.displayMin;

            value %= range;

            while (value < this.displayMin) value += range;
        }

        else if (fullRange)
            value = Math.min(Math.max(this.min, value), this.max);

        else
            value = Math.min(Math.max(this.displayMin, value), this.displayMax);

         
        if (    isNaN(value) && !isNaN(oldValue)
            || !isNaN(value) &&  isNaN(oldValue)
            || Math.abs(value - oldValue) > Number.EPSILON)
        {
            if (   value > -this.epsilon
                && value <  0) // guard against -0
                value = 0;

            this.value = value;

            this.update();

            if (   fireChangeEvent
                && this.enableChangeEvent
                && value != oldValue)
                this.dispatchEvent(this.onchange);
        }


        if (   confirm
            && this.enableChangeEvent)
            this.dispatchEvent(this.onconfirm);
    }




    setSuffix(suffix, valueCanContainSuffix = false)
    {
        this.suffix                = suffix;
        this.valueCanContainSuffix = valueCanContainSuffix;
    }
    


    setMin(displayMin = Number.MIN_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER)
    {
        this.min        = min;
        this.displayMin = displayMin;
    }



    setMax(displayMax = Number.MAX_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)
    {
        this.max        = max;
        this.displayMax = displayMax;
    }



    setDecimals(dec, dspDec = dec)
    {
        this.decimals        = dec;
        this.displayDec = dspDec;
    }



    formatValue = () => 
    {
        return [
            this.param.div.offsetLeft,
            this.param.div.offsetWidth ];
    };



    update()
    {
        super.update();


        if (typeof this.value !== 'number')
            consoleError('NumberControl.update() value is ' + typeof this.value + ', must be a number');

        if (!this.measureData.offsetRect)
            return;

            
        const [sx, sw] = this.formatValue();

        const sh =  this.measureData.clientRect.height;

        const cx = -this.displayMin / (this.displayMax - this.displayMin) * sw;

        const v = 
            this.displayAbsolute
            ?   Math.abs(this.value) 
              / (this.value < 0 
                 ? (-this.displayMin - Math.max(0, this.displayMin))
                 : ( this.displayMax - Math.max(0, this.displayMin)))
            : this.value / (this.displayMax - this.displayMin);


        this.updateBar(sx, cx, v, sw, sh);
        this.updatePrecision(sx, cx, v, sw, sh);
        this.updateColors();
        this.updateText();
        this.updateFocus(sw, sh);
        this.updateExt();

        this.updateRanges(sw, sh);
    }



    updateBar(sx, cx, v, sw, sh)
    {
        if (this.dragReverse)
            v *= -1;

            
        if (    isNaN(this.value)
            || !this.showBar)
            this.divBar.style.display = 'none';

        else
        {
            this.divBar.style.display = 'block';

            const x =
                this.displayAbsolute
                ? 0
                : (v >= 0
                   ? cx
                   : cx + v * sw);

            this.divBar.style.left   = Math.max(0, x);
            this.divBar.style.width  = Math.min(Math.max(0, Math.round(Math.abs(v) * sw) + Math.min(0, x)), Math.max(0, sw - Math.max(0, x)));

            this.divBar.style.top    = sh * this.barTop;
            this.divBar.style.height = sh * (this.barBottom - this.barTop);
        }
    }



    updatePrecision(sx, cx, v, sw, sh)
    {
        // if (this.dragReverse)
        //     v *= -1;

            
        // if (    isNaN(this.value)
        //     || !this.showBar)
        //     this.bar.style.display = 'none';

        // else
        // {
            this.divPrecision.style.display = 'block';

            const x = cx; 
            //     this.displayAbsolute
            //     ? 0
            //     : (v >= 0
            //        ? cx
            //        : cx + v * sw);

            this.divPrecision.style.left   = Math.max(0, x);
            this.divPrecision.style.width  = 10;//Math.min(Math.max(0, Math.round(Math.abs(v) * sw) + Math.min(0, x)), Math.max(0, this.measureData.offsetRect.width - Math.max(0, x)));

            this.divPrecision.style.top    = 0;
            this.divPrecision.style.height = sh;
        // }
    }



    updateColors()
    {
        this.divBar  .style.background = darkMode ? this.valueStyleDark : this.valueStyleLight;
        this.divValue.style.color      = darkMode ? this. textStyleDark : this. textStyleLight;
    }



    updateText()
    {
        if (this.overrideText != '')
        {
            this.divValue.innerHTML = this.overrideText;
        }
        else
        {
            const valueText = this.getValueText();

            this.divValue.innerHTML = 
                  valueText 
                + (valueText == UNKNOWN_DISPLAY
                   ? ''
                   : '<span style="font-size: 8px; opacity: 50%; font-weight: 200; position: relative; top: ' + this.suffixOffsetY + 'px;">&nbsp;' + this.suffix + '</span>');
        }


        this.divValue.style.position  = 'absolute';
        this.divValue.style.top       = '50%';
        this.divValue.style.transform = 'translateY(-50%)';
        this.divValue.style.width     = 'fit-content';

        
        if (this.param.showName)
        {
            this.divValue.style.left = '3px';
        }
        else
        {
            this.divValue.style.left       = '50%';
            this.divValue.style.transform += ' translateX(-50%)';
        }
    }



    updateFocus(sw, sh)
    {
        this.divFocus.style.left   = 0;
        this.divFocus.style.top    = 0;
        this.divFocus.style.width  = sw;
        this.divFocus.style.height = sh;
    }



    updateExt()
    {
        if (this.shiftDown)
        {
            const style = 
                darkMode
                ? this.textStyleDark
                : this.textStyleLight;
                
            this.extLeft .innerHTML =
            this.extRight.innerHTML =
                '<svg width="1" height="10" viewBox="0 0 1 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 4H1V6H0V4Z"  fill="'+style+'"/><path d="M0 8H1V10H0V8Z" fill="'+style+'"/><path d="M0 0H1V2H0V0Z"  fill="'+style+'"/></svg>';

            this.extLeft .style.display = this.min < this.displayMin ? 'block' : 'none';
            this.extRight.style.display = this.max > this.displayMax ? 'block' : 'none';
        }
        else
        {
            this.extLeft .style.display = 'none';
            this.extRight.style.display = 'none';
        }
    }



    updateCursor()
    {
        this.divValue.style.cursor = 
               this.readOnly 
            || containsChild(this.divValue, this.textbox)
            || graphView.wheelTimer 
            || this.delayUseTimer
            || overNumberControlCtrl == this
            ? 'default'
            : 'ew-resize';
    };
    
    
    
    getValueText()
    {
        if (this.valueText != '')
        {
            return this.valueText;
        }
        else if (  !isEmpty(this.options)
                 && this.displayDec == 0)
        {
            if (   this.value <  0 
                || this.value >= this.options.length)
                return NAN_DISPLAY;
            else
                return this.options[Math.round(this.value)];
        }
        else
        {
            if (isNaN(this.value))
                return NAN_DISPLAY;


            let str;
          

            const val = this.value * this.valueScale;

            if (Math.abs(val) >= 100_000_000_000)
                str = val.toExponential(1);
            else
            {
                str = numToString(val, this.displayDec, this.showHex);

                if (Math.abs(val) >= 10_000) // add thousand separators
                {
                    for (let i = str.length-3; i > 0; i -= 3)
                        str = str.substring(0, i) + ' ' + str.substring(i);
                }
                
                str = str.toUpperCase();
            }


            if (this.thinMinus)
                str = str.replace('-', '<span style="font-weight: 300;">-</span>');


            return str;
        }
    }
}



NumberControl.prototype.initTextbox = function()
{
    this.textbox = createTextbox('numberControlTextbox');
    this.textbox.control = this;
    


    this.textbox.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();
    });
    
    
    
    this.textbox.addEventListener('pointerup', e =>
    {
        e.stopPropagation();

        if (e.button == 2)
        {
            initTextMenu(this.textbox);
            menuText.showAt(e.clientX, e.clientY, false, false);
        }
    });



    this.textbox.addEventListener('dblclick', e =>
    {
        e.stopPropagation();
    });



    this.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();

        this.textbox.style.cursor = 'default';
    });



    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyX'
            && getCtrlKey(e)
            && !this.readOnly)
        {
            //
        }

        else if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            //
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !this.readOnly)
        {
            //
        }
        
        else if (   (   e.code == 'Enter'
                || e.code == 'NumpadEnter')
            && !this.readOnly)
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(false);
        }
        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            if (this.param)
            {
                const params = this.param.node.getTabParams();
                let   index  = params.indexOf(this.param);

                this.textbox.keyBlur = true;
                this.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (index > 0
                        && params[--index].controls[0].readOnly); // ; on purpose

                    if (   index >= 0
                        && params[index].controls[0].showTextbox)
                        params[index].controls[0].showTextbox();
                    else
                        findParamAbove(this.param.node);
                }
                else if (   e.shiftKey 
                    && index == 0)
                {
                    findParamAbove(this.param.node);
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (index < params.length-1
                        && params[++index].controls[0].readOnly); // ; on purpose

                    if (   index < params.length
                        && params[index].controls[0].showTextbox)
                        params[index].controls[0].showTextbox();
                    else
                        findParamBelow(this.param.node);
                }
                else if (!e.shiftKey 
                      && index == params.length-1) 
                {
                    findParamBelow(this.param.node);
                }
            }
        }

        else if ((   e.key == 'ArrowUp'
                  || e.key == 'ArrowDown')
              && !this.readOnly)
        {
            e.preventDefault();

            let text = this.textbox.value;

            if (   this.valueCanContainSuffix   
                && text.length >= this.suffix.length
                && text.substring(text.length - this.suffix.length) == this.suffix)
                text = text.substring(0, text.length - this.suffix.length);


            if (this.textbox.selectionStart != this.textbox.selectionEnd)
                this.textbox.selectionStart =  this.textbox.selectionEnd;

            const pos = Math.min(
                this.textbox.selectionStart,
                text.length);

            const revPos = 0;//text.length - pos;
            const sign   = e.key == 'ArrowUp' ? 1 : -1;


            if (this.showHex)
            {
                const val = parseInt(text, 16);

                let decIndex = text.indexOf('.');
                if (decIndex < 0) decIndex = text.indexOf(',');
                
                if (   text[0] != '-'
                    || pos > 0)
                {
                    if (decIndex < 0) // integer
                    {
                        let dec = Math.pow(10, revPos);

                        if (e.shiftKey) 
                            dec *= 10;

                        this.setValue((val + sign * dec) / this.valueScale);
                        this.updateTextbox();
                    }
                    else // floating point
                    {
                        const _edit = pos - decIndex - 1;

                        let  dec  = 
                            _edit < 0
                            ?     Math.pow(10, -_edit - 1)
                            : 1 / Math.pow(10,  _edit    );

                        if (e.shiftKey) 
                            dec *= 10;

                        this.displayDec = text.length-1 - decIndex;
                        this.setValue((val + sign * dec) / this.valueScale);
                        this.updateTextbox();
                    }

                    this.textbox.selectionStart =
                    this.textbox.selectionEnd   = this.textbox.savedValue.length - revPos - this.suffix.length;


                    if (this.param) this.param.changing = true;
                    if (this.confirmTimer) clearTimeout(this.confirmTimer);
                    this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
                }
            }
            else
            {
                const val = parseFloat(text);

                let decIndex = text.indexOf('.');
                if (decIndex < 0) decIndex = text.indexOf(',');
                
                if (   text[0] != '-'
                    || pos > 0)
                {
                    if (decIndex < 0) // integer
                    {
                        let dec = Math.pow(10, revPos);

                        if (e.shiftKey) 
                            dec *= 10;

                        this.setValue((val + sign * dec) / this.valueScale);
                        this.updateTextbox();
                    }
                    else // floating point
                    {
                        const _edit = pos - decIndex - 1;

                        let  dec  = 
                            _edit < 0
                            ?     Math.pow(10, -_edit - 1)
                            : 1 / Math.pow(10,  _edit    );

                        if (e.shiftKey) 
                            dec *= 10;

                        this.displayDec = text.length-1 - decIndex;
                        this.setValue((val + sign * dec) / this.valueScale);
                        this.updateTextbox();
                    }

                    this.textbox.selectionStart =
                    this.textbox.selectionEnd   = this.textbox.savedValue.length - revPos - this.suffix.length;


                    if (this.param) this.param.changing = true;
                    if (this.confirmTimer) clearTimeout(this.confirmTimer);
                    this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
                }
            }
        }
        // else if (e.code == 'KeyZ'
        //       && getCtrlKey(e))
        // {
        //     // e.preventDefault();
        //     //e.stopImmediatePropagation();

        //     //      if (e.shiftKey && !actionManager.redoing) actionManager.redo();
        //     // else if (              !actionManager.undoing) actionManager.undo();
            
        //     // this.updateTextbox();
        // }
        else if (this.readOnly)
            e.preventDefault();
        //{
        //     let curVal = this.textbox.value;

        //     if (      e.key.length == 1
        //            && !isDigit(e.key)
        //            && e.key != NAN_DISPLAY
        //            && (   !this.valueCanContainSuffix
        //                || !this.suffix.includes(e.key))
        //            && (   !this.showHex 
        //                || !isHexDigit(e.key))
        //            && (   this.showHex
        //                ||    e.key != '.'
        //                   && e.key != ',')
        //            && !(   ((      e.code == 'Minus'
        //                         || e.code == 'NumpadSubtract')
        //                      && !curVal.includes('-'))
        //                 && this.min < 0)
        //         ||     this.readOnly
        //            && !isArrowKey(e.code))
        //         e.preventDefault();

        //     if (    e.key == '.'
        //         &&  this.decimals == 0
        //         && !this.allowEditDecimals)
        //         e.preventDefault();
                
                    
        //     curVal =
        //            curVal ==     NAN_DISPLAY
        //         || curVal == UNKNOWN_DISPLAY
        //         ? ''
        //         :   curVal.substring(0, this.textbox.selectionStart) 
        //           + curVal.substring(this.textbox.selectionEnd, curVal.length);

                  
        //     const nextVal = parseFloat(curVal + e.key);

        //     if (   nextVal < this.min - 0.001
        //         || nextVal > this.max)
        //         e.preventDefault();            
        //}
    });



    // this.textbox.addEventListener('paste', e =>
    // {
    //     //e.preventDefault();
    //     //e.stopPropagation();
        

    //     // const str = e.clipboardData.getData('text/plain');

    //     // let val = 
    //     //     this.showHex
    //     //     ? parseInt(str, 16)
    //     //     : parseFloat(str);

    //     // val = Math.min(Math.max(this.min, val), this.max);
        
    //     // const strVal = isNaN(val) ? '' : val;

    //     // this.textbox.value = 
    //     //       this.textbox.value.substring(0, this.textbox.selectionStart)
    //     //     + strVal
    //     //     + this.textbox.value.substring(this.textbox.selectionEnd);

    //     // this.setValue(
    //     //     parseFloat(this.textbox.value), 
    //     //     true, //!this.textbox.managing, 
    //     //     true);
    // });



    
    this.textbox.addEventListener('focus', () =>
    {
        if (currentTooltip) 
            hideTooltip(currentTooltip);
    });
    


    this.textbox.addEventListener('focusout', () =>
    {
        if (!this.textbox.keyBlur) this.textbox.finish(this.textbox.value.trim() != '');
        else                       this.textbox.keyBlur = false;


        if (this.savedSuccessOnFocusOut != null)
        {
            this.successOnFocusOut      = this.savedSuccessOnFocusOut;
            this.savedSuccessOnFocusOut = null;
        }


        this.param.div.parentNode.removeChild(this.textbox);
        this.clicked = false;
    });
    


    this.textbox.addEventListener('wheel', e =>
    {
        e.stopPropagation();
        forwardEvent(e, this.div);
    });
    


    this.textbox.finish = (success, focusControl = true) =>
    {
        let   value      = this.textbox.value;
        const savedValue = this.textbox.savedValue;

        value = value.replace(this.suffix, '');
        
        
        let isHex = this.showHex;

        if (   value.length >= 2
            && value.substring(0, 2) == '0x')
        {
            isHex = true;
            value = value.substring(2);   
        }

        
        let val = 
            value.trim() == NAN_DISPLAY 
            ? Number.NaN 
            : (isHex
               ? parseInt(value, 16) 
               : parseFloat(value));


        let savedVal = 
            savedValue.trim() == NAN_DISPLAY  
            ? Number.NaN 
            : (isHex
               ? parseInt(savedValue, 16) 
               : parseFloat(savedValue));

        
        if (!isNaN(val))
            val /= this.valueScale;

       
        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           val,
            'oldValue':        savedVal,
            'valueString':     value     .replace(this.suffix, ''),
            'oldValueString':  savedValue.replace(this.suffix, ''),
            'preventSetValue': false }});

        this.dispatchEvent(e);


        if (!e.preventSetValue)
        {
            if (success) 
            {
                this.setValue(
                    value.trim() != ''
                    ? val
                    : savedVal);
            }
            else
                this.setValue(savedVal);
        }
         
        
        this.textbox.blur();

        this.divValue.style.display = 'block';

        if (   this.inFocus
            && focusControl)
            this.param.div.focus();
    };    
};



NumberControl.prototype.showTextbox = function()
{
    this.divValue.style.display = 'none';

    this.inFocus = 
           hasFocus(this.param.div)
        && !this.clicked;


    this.param.formatControlTextbox(this);


    this.updateTextbox();
    
    this.param.div.parentNode.appendChild(this.textbox);
    
    this.textbox.focus();
    this.textbox.select();

    this.textbox.style.cursor = 'default';
};



NumberControl.prototype.updateTextbox = function()
{
    this.textbox.value =
        (   isNaN(this.value)
            ? NAN_DISPLAY
            : numToString(
                  this.value * this.valueScale, 
                  this.displayDec, 
                  this.showHex
              ).toUpperCase())
         + (  !isNaN(this.value)
            && this.valueCanContainSuffix 
            ? this.suffix 
            : '');
        
    this.textbox.savedValue = this.textbox.value;
};



function findParamAbove(node)
{
    const nodeAbove = findNodeAbove(node);

    if (nodeAbove)
    {
        let index = nodeAbove.params.length;

        while (index > 0
            && nodeAbove.params.length > 0 
            && nodeAbove.params[--index].controls[0].readOnly); // ; on purpose

        if (   index >= 0
            && nodeAbove.params[index].controls[0].showTextbox)
            nodeAbove.params[index].controls[0].showTextbox();
    }
}



function findParamBelow(node)
{
    const nodeBelow = findNodeBelow(node);

    if (nodeBelow)
    {
        let index = -1;

        while (index < nodeBelow.params.length-1
            && nodeBelow.params.length > 0
            && nodeBelow.params[++index].controls[0].readOnly); // ; on purpose

        if (   index < nodeBelow.params.length
            && nodeBelow.params[index].controls[0].showTextbox)
            nodeBelow.params[index].controls[0].showTextbox();
    }
}


class NumberControlRange
{
    start;
    end;

    background;

    top;
    bottom;


    constructor(start, end = start, background = '#f0f', top = 0, bottom = 1)
    {
        this.start      = start;
        this.end        = end;

        this.background = background;

        this.top        = top;
        this.bottom     = bottom;
    }



    copy()
    {
        return new NumberControlRange(
            this.start,
            this.end,
            this.background,
            this.top,
            this.bottom);
    }
}



NumberControl.prototype.updateRanges = function(controlWidth, controlHeight)
{
    if (this.overrideText != '') // assuming this is only used in emergencies where ranges are irrelevant
        this.resetRangeDivs();

    else
    {
        if (   this.showExtRanges
            && (   this.min < this.displayMin
                || this.max > this.displayMax))
        {
            this.resetRanges();

            const warnLineStyle = getWarningRangeStyle();

            const val = (this.value - this.displayMin) / (this.displayMax - this.displayMin);

            if (this.value < this.displayMin) this.ranges.push(new NumberControlRange(0, Math.min(-val, 1), warnLineStyle, 0.8));
            if (this.value > this.displayMax) this.ranges.push(new NumberControlRange(2-Math.min(val, 2), 1, warnLineStyle, 0.8));    
        }


        if (this.ranges.length == this.rangeDivs.length) // update
        {
            for (let i = 0; i < this.ranges.length; i++)
            {
                updateControlRangeDiv(
                    this.ranges   [i],
                    this.rangeDivs[i],
                    controlWidth,
                    controlHeight);
            }
        }
        else // recreate
        {
            this.resetRangeDivs();

            for (const range of this.ranges)
            {
                const div = createDiv('numberControlRange');
                
                div.style.zIndex = 0;

                this.rangeDivs.push(div);
                this.param.div.appendChild(div);
            
                updateControlRangeDiv(range, div, controlWidth, controlHeight);
            }
        }
    }
};



NumberControl.prototype.resetRanges = function()
{
    this.ranges = [];
    this.resetRangeDivs();        
};



NumberControl.prototype.resetRangeDivs = function()
{
    for (const div of this.rangeDivs)
        if (this.param.div.contains(div))
            this.param.div.removeChild(div);

    this.rangeDivs = [];
};



function getWarningRangeStyle()
{
    return darkMode
        ? 'rgba(255, 96, 96, 0.5)'
        : 'rgba(255, 0, 0, 0.16)';
}



function updateControlRangeDiv(range, div, controlWidth, controlHeight)
{
    if (range.start == range.end)
        div.style.display = 'none';
    else
    {
        div.style.display    = 'block';
        div.style.left       = controlWidth * range.start;  
        div.style.top        = range.top * controlHeight;
        div.style.width      = controlWidth * (range.end - range.start);
        div.style.height     = (range.bottom - range.top) * controlHeight;
        div.style.background = range.background;
    }
};



NumberControl.prototype.initEvents = function()
{
    const controlDiv = 
        this.param 
        ? this.param.div 
        : this.div;

        
    controlDiv.addEventListener('pointerenter', e =>
    {
        const param = this.param;
        

        if (this.delayUse > 0)
        {
            controlDiv.style.cursor = 'default';
            this.startDelayUseTimer();
        }


        if (!this.canReact(e))
            return;


        //tooltip_pointerLeave(currentTooltip);


        overNumberControl = this;


        if (panMode)
        {
            setCursor(panCursor);
            return;
        }


        if (   !graphView.spaceDown
            &&  this.pointerEvents)
        {
            if (   graphView.tempConn
                ||   !settings.enableZoomedOutParams
                   && graph.currentPage.zoom <= settings.minZoomForParams)
                   controlDiv.style.cursor = 'default';
            else
                this.updateCursor();

                    
            const colShadow = 
                darkMode
                ? 'rgba(255, 255, 255, 0.1)'
                : 'rgba(0, 0, 0, 0.1)';

            if (param)
            {
                this.divFocus.style.boxShadow = '0 1px 0 0 ' + colShadow + ' inset';

                if (    param.node
                    &&  param.node.params.includes(param)
                    && !isLastInArray(param.node.params, param))
                    this.divFocus.style.boxShadow += ', 0 -1px 0 0 ' + colShadow + ' inset';
            }
            else
            {
                this.divFocus.style.boxShadow  = '0 0 0 1px ' + colShadow + ' inset ';
            }


            this.divFocus.style.visibility = 'visible';
            this.divFocus.style.opacity    = '100%';
    
            this.update();
        }
    });



    controlDiv.addEventListener('pointerdown', e =>
    {
        const param = this.param;

    
        if (   graphView.overOutput && graphView.overOutput == this.param.output
            || graphView.overInput  && graphView.overInput  == this.param.input )
        {
            e.preventDefault();
            return;
        }

        
        if (e.button == 0)
        {
            this.buttonDown0  = true;
            this.buttonDown0_ = true;
        }


        if (!this.canReact(e))
            return;


        if (   graphView.spaceDown
            || panMode)
            return;

        
        window.focus();

        hideAllMenus();


        if (this.param.node.div.style.zIndex < graphView.getTopNodeIndex())
            graphView.putNodeOnTop(this.param.node);


        if (e.button == 0)
        {
            if (!this.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let nodeDiv = 
                   this.parentNode
                && this.parentNode.parentNode
                && this.parentNode.parentNode.parentNode
                ? this.parentNode.parentNode.parentNode
                : null;

            if (   nodeDiv 
                && nodeDiv.className == 'node') 
                graphView.putNodeOnTop(nodeDiv.node);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();
                

            this.moved        = false;
            this.clientX      = e.clientX;
            this.movedX       = 0;


            if (!this.readOnly)
            {
                this.oldValue   = this.value;
                this.startValue = this.value;
                this.prevValue  = this.value;
                this.sx         = e.clientX;

                this.clickTimer = setTimeout(() => 
                {
                    if (!document.menuHadFocus)
                    {
                        numberControlChanging = this;
                        this.shiftDown = e.shiftKey;
                        this.update();

                        this.moved = true;
                        this.lockPointer(e.pointerId);
                    }
                }, 
                500);
            }


            if (   !param
                || !param.node.selected)
                this.divFocus.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand) inset';

            else
            {
                this.divFocus.style.boxShadow = '0 1px 0 0 var(--figma-color-bg-brand) inset';
                    
                if (param.index < param.node.params.length-1)
                    this.divFocus.style.boxShadow += ', 0 -1px 0 0 var(--figma-color-bg-brand) inset';
            }


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();


            if (param)
                param.noUpdate = true;  
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            this.buttonDown1 = true;
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            this.buttonDown2 = true;

            if (    param
                && !isEmpty(this.options))
            {
                initSelectParamMenu(param);
                menuSelectParam.showAt(e.clientX, e.clientY, false);
            }
        }
    });



    controlDiv.addEventListener('pointermove', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        if (panMode)
        {
            setCursor(panCursor);
            return;
        }

        if (!this.pointerEvents)
            return;
        


        // if (   !document.canResizeL
        //     && !document.canResizeR
        //     && !document.canResizeB)
            this.updateCursor();


        let rect = boundingRect(controlDiv);
        
        this.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top
            && e.clientY <  rect.bottom;


        this.clientX = e.clientX;

        
        if (    this.buttonDown0
            && !this.readOnly)
        {
            if (this.isPointerLocked())
            {
                numberControlChanging = this;

                this.movedX += e.movementX;
                
                if (!isNaN(this.value))
                {
                    const dx       = this.movedX * (this.dragReverse ? -1 : 1);
                    const adaptive = 10 * Math.pow(Math.abs(dx), this.acc);
                    const grain    = Math.pow(10, -this.decimals);
                    const drag     = grain * sqr(this.dragScale);

                    const val      = this.startValue + dx * drag * adaptive;

                    
                    // reset control movement at the limits for better UX
                    const min = e.shiftKey ? this.min : this.displayMin;
                    const max = e.shiftKey ? this.max : this.displayMax;

                    this.setValue(
                        Math.round(val / grain) * grain, 
                        true, 
                        false,
                        e.shiftKey);


                    if (   val <= min
                        || val >= max)
                    {
                        this.movedX     = 0;
                        this.startValue = this.value;
                        this.sx         = e.clientX;
                    }


                    if (this.value != this.prevValue)
                        pushUpdateFromParam(null, [param.node], param);

                    this.prevValue = this.value;
                }


                this.shiftDown = e.shiftKey;
            }
            else
            {
                if (Math.abs(e.clientX - this.sx) > this.clickSize/2)
                {
                    this.moved = true;
                    this.lockPointer(e.pointerId);

                    this.dispatchEvent(this.onstartchange);
                }
            }
        }
        else if (graphView.tempConn
              && param)
        {
            this.checkDragConnection();
        }
        else if (this.readOnly)
        {
            this.moved = true;
        }
    });
    
    
    
    controlDiv.addEventListener('pointerleave', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        overNumberControl = null;


        if (panMode)
            return;


        controlDiv.style.cursor        = 'default';
        
        //this.divFocus.style.boxShadow  = 'none';
        this.divFocus.style.visibility = 'hidden';
        this.divFocus.style.opacity    = 0;

        this.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    controlDiv.addEventListener('losecapture', () =>
    {
        this.buttonDown0 = false;
        this.buttonDown1 = false;
        this.buttonDown2 = false;
        this.mouseOver   = false;
        this.shiftDown   = false;

        numberControlChanging = null;
        
        this.update();
    });



    controlDiv.addEventListener('pointerup', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        if (panMode)
            return;


        clearTimeout(this.clickTimer);


        if (e.button == 0)
        {
            const colShadow = 
                darkMode
                ? 'rgba(255, 255, 255, 0.1)'
                : 'rgba(0, 0, 0, 0.1)';

            this.divFocus.style.boxShadow = '0 1px 0 0 ' + colShadow + ' inset';

            if (    param.node
                &&  param.node.params.includes(param)
                && !isLastInArray(param.node.params, param))
                this.divFocus.style.boxShadow += ', 0 -1px 0 0 ' + colShadow + ' inset';
        }


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(param.node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !param.node.isOrFollows(graphView.tempConn.input.node)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overOutput.endConnection();
            }
        }
        
        else if (this.moved
              || document.menuHadFocus)
        {
            if (param)
                param.noUpdate = false;  

            this.shiftDown        = false;
            numberControlChanging = null;
 

            this.setValue(
                this.value,
                false, 
                true,
                e.shiftKey);

            this.unlockPointer(e.pointerId);


            this.update();


            pushUpdateFromParam(null, [param.node], param);


            return;            
        }

        else if (this.buttonDown0_)
        {
            this.clicked = true;
            this.showTextbox();
        }


        if (e.button == 0) 
        {
            this.buttonDown0 = false;
            this.shiftDown   = false;

            numberControlChanging = null;
            overNumberControl     = null;

            this.updateCursor();
            this.startDelayUseTimer();
        }

        else if (e.button == 1) 
            this.buttonDown1 = false;

        else if (e.button == 2) 
        {
            e.stopPropagation();
            this.buttonDown2 = false;
        }



        this.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', e =>
    {
        if (   e.button == 0 
            && this.buttonDown0)
        {
            this.buttonDown0 = false;
            this.unlockPointer(e.pointerId);
        }
        else if (e.button == 1
              && this.buttonDown1)
        {
            this.buttonDown1 = false;            
        }
    });


    
    controlDiv.addEventListener('wheel', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        if (  !this.pointerEvents
            || panMode
            || graphView.wheelTimer)
            return;


        const touchpad = isTouchpad(e);

        if (touchpad)
        {
            e.preventDefault();
            return;
        }


        const dWheelX = e.deltaX /  20 * (this.dragReverse ? -1 : 1);
        const dWheelY = e.deltaY / 100 * (this.dragReverse ? -1 : 1);


        if (   !getCtrlKey(e)
            && !this.buttonDown1)
        {
            e.stopPropagation();

            if (!this.readOnly)
            {
                if (   document.activeElement
                    && (   document.activeElement.tagName.toLowerCase() == 'input'
                        || document.activeElement.tagName.toLowerCase() == 'textarea')
                    && document.activeElement.control)
                    document.activeElement.control.textbox.finish(true, false);

                this.oldValue = this.value;

                const dec = Math.pow(10, -this.decimals);

                const val =
                    touchpad
                    ? this.value -  dWheelX               * this.wheelScale * dec
                    : this.value + (dWheelY > 0 ? -1 : 1) * this.wheelScale * dec;


                this.setValue(val, true, true, false);

                if (this.param) this.param.changing = true;
                if (this.confirmTimer) clearTimeout(this.confirmTimer);
                this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
            }
        }
    });

    
    
    controlDiv.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            this.showTextbox();

        // else if (e.key == 'Shift')
        // {
        //     this.shiftDown = true;
        //     this.update();
        // }

    }, true);



    // controlDiv.addEventListener('keyup', e =>
    // {
    //     // if (e.key == 'Shift')
    //     // {
    //     //     this.shiftDown = true;
    //     //     this.update();
    //     // }

    // }, true);



    controlDiv.addEventListener('focus', () =>
    {
        if (   !graphView.spaceDown
            && !panMode
            && !this.buttonDown1
            &&  this.pointerEvents)
            this.showTextbox();
    });
}


class TextControl
extends Control
{
    value;


    textBehind;
    textbox;
    placeholder;

    valueText         = '';


    enableChangeEvent = true;
    
    successOnFocusOut = false;
    keyBlur           = false;

    
    readOnly          = false;
    
    tabSize           = 4;
    

    confirmTimer      = null;
    
    

    constructor(param, id, name, defaultValue = '')
    {
        const textbox = createTextarea('textControlTextarea');


        super(textbox, param, id, name);


        this.value = defaultValue;
        
        
        this.initTextarea(textbox);
        this.initEvents();
        

        this.div.appendChild(textbox);


        createTooltipSrc(this.div, this.div, () => 
                settings.showTooltipLongText
            &&  scrollbarVisible(this.textbox)
            && !hasFocus(this.textbox)
            ? ttText
            : null);


        this.div.style.position  = 'relative';
        // this.div.style.boxShadow = '0 0 0 2px orange inset';
    }    



    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.param.node.header);

        return false;
    }



    setName(name)
    {
        this.name      = name;
        this.savedName = name;
        
        this.update();
    }



    setSize(w, h)
    {
        h = Math.max(defParamHeight, h);


        super.setSize(w, h);


        // if (this.textbox) 
        // {
        //     this.textbox.style.width  = '100%';
        //     this.textbox.style.height = '100%';
        // }
    }



    // updateTextboxSize()
    // {
    //     const  input = this.param && this.param. input;
    //     const output = this.param && this.param.output;

    //     const left = input ? 12 : 0;

    //     const dw = 
    //           ( input ? 12 : 0) 
    //         + (output ? 12 : 0);


    //     // this.textbox.style.left  = left + 'px';
    //     // this.textbox.style.width = 'calc(100% - ' + dw + 'px)';
    // }



    setValue(value, fireChangeEvent = true, updateControl = true)
    {
        if (typeof value != 'string')
            consoleError('TextControl.setValue(value) is ' + typeof value + ', must be a string');

            
        this.value = value;

        if (updateControl)
            this.textbox.value = value;


        this.update();


        if (   fireChangeEvent
            && this.enableChangeEvent)
            this.dispatchEvent(this.onchange);
    }




    update()
    {
        super.update();


        if (typeof this.textbox.value !== 'string')
        {
            //console.trace();
            consoleError('TextControl.update() value is ' + typeof this.textbox.value + ', must be a string');
        }


        if (!this.measureData.offsetRect)
            return;
            

        this.textbox.placeholder = 
            this.value == NAN_CHAR
            ? UNKNOWN_DISPLAY
            : this.textbox.defPlaceholder;


        this.textbox.style.height        = '100%';
        this.textbox.style.pointerEvents = this.readOnly ? 'none' : 'all';



        if (this.param.showName)
            this.textbox.style.textAlign = 'left';


             if (this.valueText != '')   this.textbox.value = this.valueText;
        else if (this.value == NAN_CHAR) this.textbox.value = '';
    }



    updateCursor()
    {
        this.textbox.style.cursor = 
               hasFocus(this.textbox)
            && graph.currentPage.zoom >= settings.minZoomForParams
            ? 'text'
            : 'default';
    }
}


TextControl.prototype.initTextarea = function(textbox)
{
    this.textbox                 = textbox;

    this.textbox.control         = this;
    this.textbox.defPlaceholder  = '...';//' . . .';
    this.textbox.placeholder     = this.textbox.defPlaceholder;

    this.textbox.style.height    = defParamHeight;
    this.textbox.style.textAlign = 'center';

    this.textbox.savedValue      = this.textbox.value;



    this.textbox.addEventListener('pointerdown', e =>
    {
        if (this.param.node.div.style.zIndex < graphView.getTopNodeIndex())
            graphView.putNodeOnTop(this.param.node);


        hideAllMenus();


        if (      graphView.overOutput 
               && graphView.overOutput == this.param.output
            ||    graphView.overInput  
               && graphView.overInput  == this.param.input )
        {
            e.preventDefault();
            return;
        }


        if (e.button == 1)
        {
            e.preventDefault();
            return;
        }


        if (this.readOnly)
        {
            e.preventDefault();
            e.stopPropagation();
            return;
        }


        if (!this.canReact(e))
            return;


        if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            initTextboxMenu(this.textbox);
            menuTextbox.showAt(e.clientX, e.clientY, false, false);
        }
        else    
            e.stopPropagation();
    });
    
    
    
    // this.textbox.addEventListener('pointermove', e =>
    // {
    //     //e.preventDefault();
    //     //e.stopPropagation();
    // });



    // this.textbox.addEventListener('pointerup', e =>
    // {
    //     // e.stopPropagation();


    //     if (e.button == 2)
    //     {
    //         initTextboxMenu(this.textbox);
    //         menuTextbox.showAt(e.clientX, e.clientY, false, false);
    //     }
    // });



    // this.textbox.addEventListener('dblclick', e =>
    // {
    //     e.stopPropagation();
    // });



    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   (      e.code == 'Enter'
                        && getCtrlKey(e)
                     || e.code == 'NumpadEnter')
                 && !this.readOnly)
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Tab')
        {
            e.preventDefault();

            const tab = Array(this.tabSize + 1).join(' ');

            const selStart = this.textbox.selectionStart;
            const selEnd   = this.textbox.selectionEnd;

            this.textbox.value = 
                  this.textbox.value.slice(0, selStart)
                + tab
                + this.textbox.value.slice(selEnd);

            this.textbox.selectionStart = 
            this.textbox.selectionEnd   = selStart + this.tabSize;
        }
    });



    this.textbox.addEventListener('input', e =>
    {
        this.setValue(this.textbox.value, true, true);
    });



    this.textbox.addEventListener('focus', () =>
    {
        hideAllMenus();

        if (currentTooltip) 
            hideTooltip(currentTooltip);

        this.updateCursor();
    });
    


    this.textbox.addEventListener('focusout', () =>
    {
        if (this.textbox.keyBlur)
            this.textbox.keyBlur = false;


        if (this.savedSuccessOnFocusOut != null)
        {
            this.successOnFocusOut      = this.savedSuccessOnFocusOut;
            this.savedSuccessOnFocusOut = null;
        }


        this.textbox.blur();
        this.clicked = false;

        this.updateCursor();


        window.getSelection().removeAllRanges();
    });
    


    this.textbox.addEventListener('wheel', e =>
    {
        if (graphView.wheelTimer)
            e.preventDefault();

        e.stopPropagation();
        forwardEvent(e, this.div);

        this.updateCursor();
    });
    


    this.textbox.finish = (success, focusControl = true) =>
    {
        let   value      = this.textbox.value;
        const savedValue = this.textbox.savedValue;

        value = value.replace(this.suffix, '');


        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           value     .replace(this.suffix, ''),
            'oldValue':        savedValue.replace(this.suffix, ''),
            'preventSetValue': false }});

        this.dispatchEvent(e);


        if (!e.preventSetValue)
        {
            if (success) 
            {
                this.setValue(
                    value != NAN_CHAR
                    ? value 
                    : savedValue);
            }
            else
                this.setValue(savedVal);
        }
         
        
        this.textbox.blur();


        if (   this.inFocus
            && focusControl)
            this.div.focus();
    };    
};



TextControl.prototype.showTextarea = function()
{
    this.inFocus = 
           hasFocus(this.div)
        && !this.clicked;

        
    this.focus.style.visibility = 'hidden';
    this.focus.style.opacity    = 0;


    this.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
    this.textbox.style.outline   = 'none';


    this.updateTextarea();

    
    this.textbox.focus();
    this.textbox.select();
};



TextControl.prototype.updateTextarea = function()
{
    this.textbox.value      = this.value;
    this.textbox.savedValue = this.value;
};



TextControl.prototype.getTextAlignment = function()
{
    const style = getComputedStyle(this.textbox);

    switch (style.textAlign)
    {
    case '': 
    case 'start': 
    case 'left':    return 'left';
    case 'center':  return 'center';
    case 'right':   return 'right';
    case 'justify': return 'justify';
    }
};


TextControl.prototype.initEvents = function()
{
    this.div.addEventListener('pointerenter', e =>
    {
        if (panMode)
        {
            setCursor(panCursor);
            return;
        }


        //if (   !graphView.spaceDown
        //    &&  this.pointerEvents)
        //{
        //    // if (graphView.tempConn)
        //    //     this.divControl.style.cursor = 'default';
//
        //        
        //    // this.textbox.style.visibility = 'visible';
        //    // this.textbox.style.opacity    = '100%';
    //
        //    this.update();
        //}
        //else 
        if (!currentTooltip)
            initTextTooltip(this.value);
    });



    this.div.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            e.stopPropagation();
        }

        else if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            if (this.param instanceof TextParam)
            {
                initTextboxMenu(this.textbox);
                menuTextbox.showAt(e.clientX, e.clientY, false, false);
            }
        }
    });



    this.div.addEventListener('pointermove', e =>
    {
        e.stopPropagation();


        if (panMode)
        {
            setCursor(panCursor);
            return;
        }

        if (!this.pointerEvents)
            return;

            
        let rect = boundingRect(this.div);
        
        this.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        this.clientX = e.clientX;

        
        if (    this.buttonDown0
            && !this.readOnly)
        {
            //forwardEvent(e, this.textbox);
            // ...
        }
        else if (graphView.tempConn
              && this.param)
        {
            this.checkDragConnection();
        }
        // else if (this.readOnly)
        // {
        //     this.moved = true;
        // }
    });



    this.div.addEventListener('pointerleave', e =>
    {
        if (panMode)
            return;


        // this.divControl.style.cursor  = 'default';
        
        // this.textbox.style.visibility = 'hidden';
        // this.textbox.style.opacity    = 0;

        
        this.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != this.param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire .inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != this.param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire .outputPos = point_NaN;

                graphView.tempConn.input.updateControl();
           }
        }
    });



    this.div.addEventListener('pointerup', e =>
    {
        e.stopPropagation();


        const param = this.param;


        if (!this.canReact(e))
            return;


        if (panMode)
            return;


        clearTimeout(this.clickTimer);

  
        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(param.node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !param.node.isOrFollows(graphView.tempConn.input.node)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overOutput.endConnection();
            }
        }


        if (e.button == 0) 
        {
            this.buttonDown0 = false;
            this.shiftDown   = false;

            this.updateCursor();
        }

        else if (e.button == 1) 
            this.buttonDown1 = false;

        else if (e.button == 2) 
        {
            //e.stopPropagation();
            this.buttonDown2 = false;
        }



        this.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', e =>
    {
        if (   e.button == 0 
            && this.buttonDown0)
        {
            this.buttonDown0 = false;
            this.unlockPointer(e.pointerId);

            this.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
        }
        else if (e.button == 1
              && this.buttonDown1)
        {
            this.buttonDown1 = false;            
        }
    });



    this.div.addEventListener('dblclick', e =>
    {
        e.stopPropagation();
    });



    this.div.addEventListener('wheel', e =>
    {
        if (  !this.pointerEvents
            || panMode
            || graphView.wheelTimer)
            return;


        const touchpad = isTouchpad(e);

        if (touchpad)
        {
            e.preventDefault();
            e.stopPropagation();
            return;
        }


        if (   !getCtrlKey(e)
            && !this.buttonDown1)
            e.stopPropagation();
    });
};


class ColorControl
extends Control
{
    value;
    acc;
     
     
    dragReverse       = false;
    dragScale;
    wheelScale;
             
    nameStyleLight    = 'rgba(255, 255, 255, 0.5 )';
    backStyleLight    = 'rgba(255, 255, 255, 0.95)';
    valueStyleLight   = 'transparent';
    textStyleLight    = '#000';
                
    nameStyleDark     = 'rgba(56, 56, 56, 0.5 )';
    backStyleDark     = 'rgba(56, 56, 56, 0.95)';
    valueStyleDark    = 'transparent';
    textStyleDark     = '#eee';

    //fontSize          = 11;
             
    mouseOver         = false;
    buttonDown0       = false;
    buttonDown1       = false;
             
    clickSize         = 4;
    moved             = false;
         
    tabIndex          = 0;
    inFocus           = false;
    clicked           = false;
 
    oldValue; 
 
    enableChangeEvent = true;
    
    successOnFocusOut = false;
    keyBlur           = false;
    
    readOnly          = false;
     
    valueText         = '';
    
    

    constructor(param, id, name, defaultValue, dragScale = 0.05, wheelScale = 1, acc = 0)
    {
        const divValue = createDiv('colorControlText');


        super(divValue, param, id, name);


        this.value       = defaultValue;
        this.acc         = acc;
         
        
        this.dragReverse = false;
        this.dragScale   = dragScale;
        this.wheelScale  = wheelScale;
                 

        this.divFocus    = createDiv('colorControlFocus');
        this.divValue    = divValue;
    
        this.div.appendChild(this.divFocus);
        this.div.appendChild(this.divValue);

        
        this.initTextbox();
        this.initEvents ();


        // this.div.style.boxShadow = '0 0 0 1px red inset';
    }    
    

    
    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.param.node.header);

        return false;
    }



    setName(name)
    {
        this.name = name;
        this.update();
    };



    setValue(value, fireChangeEvent = true, confirm = true)
    {
        //if (!(value instanceof ColorValue))
            //console.error('ColorControl.setValue(value) is ' + typeof value + ', must be a ColorValue');


        const oldValue = this.value.copy();

        this.value = value.copy();
        this.update();
        
        this.dispatchSetEvents(fireChangeEvent, value, oldValue, confirm);
    };




    dispatchSetEvents(fireChangeEvent, value, oldValue, confirm)
    {
        if (   fireChangeEvent
            && this.enableChangeEvent
            && !value.equals(this.prevValue))
            this.dispatchEvent(this.onchange);

        if (   confirm
            && this.enableChangeEvent
            && !value.equals(oldValue))
            this.dispatchEvent(this.onconfirm);
    }



    update()
    {
        if (!this.measureData.offsetRect)
            return;


        super.update();


        const sw = this.measureData.clientRect.width;
        const sh = this.measureData.clientRect.height;

        this.updateColors();
        this.updateText();
        this.updateFocus(sw, sh);
    };



    updateColors()
    {
        // this.param.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;
        
        this.param.divName.style.color = !isDark(this.value.toRgb()) ? this.textStyleDark : this.textStyleLight;
        this.param.divName.style.opacity = 0.5;
        
        //this.textbox.style.background = 'transparent';

        this.divValue.style.color = 
        this.textbox .style.color = 
            darkMode 
            ? this.textStyleDark 
            : this.textStyleLight;
    };



    updateText()
    {
        this.divValue.innerHTML = this.getValueText();

        this.textbox.value = this.divValue.innerText;
        
        this.divValue.style.position = 'static';    
        this.divValue.style.width    = 'fit-content';    

        this.divValue.style.margin = 
            this.param.showName
            ? '4px auto 0 3px'
            : '4px auto 0 auto';
    };



    getValueText()
    {
        if (this.valueText != '')
            return this.valueText;

        else
            return this.value.isValid()
                && rgbIsValid(this.value.toRgb())
                ? rgb2hex(this.value.toRgb())
                : UNKNOWN_DISPLAY;
    }



    updateFocus(sw, sh)
    {
        this.divFocus.style.left   = 0;
        this.divFocus.style.top    = 0;
        this.divFocus.style.width  = sw;
        this.divFocus.style.height = sh;
    };



    updateFocusBorder()
    {
        const colShadow = 
            darkMode
            ? 'rgba(255, 255, 255, 0.1)'
            : 'rgba(0, 0, 0, 0.1)';

        if (this.param)
        {
            this.divFocus.style.boxShadow = '0 1px 0 0 ' + colShadow + ' inset';

            if (    this.param.node
                &&  this.param.node.params.includes(this.param)
                && !isLastInArray(this.param.node.params, this.param))
                this.divFocus.style.boxShadow += ', 0 -1px 0 0 ' + colShadow + ' inset';
        }
        else
        {
            this.divFocus.style.boxShadow  = '0 0 0 1px ' + colShadow + ' inset ';
        }
    }
}


ColorControl.prototype.initTextbox = function()
{
    this.textbox         = createTextbox('colorControlTextbox');
    this.textbox.control = this;
    this.textbox.shown   = false;



    this.textbox.addEventListener('pointerdown', e =>
    {
        e.stopImmediatePropagation();
    });



    this.textbox.addEventListener('pointerup', e =>
    {
        e.stopPropagation();

        if (e.button == 0)
        {
            if (!this.textbox.shown)
                this.textbox.select();
    
            this.textbox.shown = true;
        }
        else if (e.button == 2)
        {
            initTextMenu(this.textbox);
            menuText.showAt(e.clientX, e.clientY, false, false);
        }
    });



    this.textbox.addEventListener('dblclick', e =>
    {
        e.stopPropagation();
    });



    this.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();
        this.textbox.style.cursor = 'default';
    });



    this.textbox.addEventListener('focus', e =>
    {
        if (   this.textbox.value ==     NAN_DISPLAY
            || this.textbox.value == UNKNOWN_DISPLAY)
            this.textbox.value = NAN_DISPLAY;
    });



    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyX'
            && getCtrlKey(e)
            && !this.readOnly)
        {
            //
        }

        else if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            // 
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !this.readOnly)
        {
            // 
        }
        
        else if (   (   e.code == 'Enter'
                || e.code == 'NumpadEnter')
            && !this.readOnly)
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(false);
        }
        else if (e.code == 'Tab')
        {
            e.preventDefault();
            //e.stopPropagation();
            
            if (this.param)
            {
                const params = this.param.node.getTabParams();
                let   index  = params.indexOf(this.param);

                this.textbox.keyBlur = true;
                this.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (params[--index].controls[0].readOnly);
                    params[index].controls[0].showTextbox();
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (params[++index].controls[0].readOnly);
                    params[index].controls[0].showTextbox();
                }
            }
        }

        else if ((   e.key == 'ArrowUp'
                  || e.key == 'ArrowDown')
              && !this.readOnly)
        {
            e.preventDefault();

            
            if (   this.textbox.selectionStart == this.textbox.selectionEnd
                && this.textbox.selectionStart % 2 == 0
                && this.textbox.selectionStart > 0)
                this.textbox.selectionStart--;

            const iStart =  Math.floor(this.textbox.selectionStart / 2);
            let   iEnd   =  Math.ceil (this.textbox.selectionEnd   / 2);

            if (iStart == iEnd) iEnd++;


            const rgb = scaleRgb(validHex2rgb(this.textbox.value));
            
            for (let i = iStart; i < iEnd; i++)
                rgb[i] = Math.min(Math.max(0, rgb[i] + (e.key == 'ArrowUp' ? 1 : -1)), 0xff);


            this.setValue(ColorValue.fromRgb(rgb));
            this.updateTextbox();


            this.textbox.selectionStart = iStart * 2;
            this.textbox.selectionEnd   = iEnd   * 2;


            if (this.param) this.param.changing = true;
            if (this.confirmTimer) clearTimeout(this.confirmTimer);
            this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
        }

        else if (e.code == 'KeyZ'
              && getCtrlKey(e))
        {
            if (e.shiftKey)
            {
                if (  !isEmpty(actionManager.redoActions)
                    && actionManager.redoActions.at(-1).type == SET_PARAM_VALUE_ACTION
                    && actionManager.redoActions.at(-1).param == this.param)
                    actionManager.redo();
                else
                {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            }
            else
            {
                if (  !isEmpty(actionManager.actions)
                    && actionManager.actions.at(-1).type == SET_PARAM_VALUE_ACTION
                    && actionManager.actions.at(-1).param == this.param)
                    actionManager.undo();
                else
                {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            }
        }

        else if (this.readOnly)
            e.preventDefault();

        else if (e.key != 'Control'
              && e.key != 'Shift'
              && e.key != 'Alt')           
            actionManager.redoActions = [];
    });



    // this.textbox.addEventListener('paste', e =>
    // {
    //     e.preventDefault();


    //     const oldValue = this.value.copy();


    //     let str = e.clipboardData.getData('text/plain');

    //     const rgb = hex2rgb(
    //           this.textbox.value.substring(0, this.textbox.selectionStart)
    //         + str
    //         + this.textbox.value.substring(this.textbox.selectionEnd));

    //     const value = ColorValue.fromRgb(scaleRgb(rgb));


    //     this.textbox.value = rgb2hex(rgb);


    //     this.setValue(
    //         value, 
    //         true, //!this.textbox.managing, 
    //         true);
    // });



    this.textbox.addEventListener('focus', () =>
    {
        if (currentTooltip) 
            hideTooltip(currentTooltip);
    });
    


    this.textbox.addEventListener('focusout', () =>
    {
        //console.log('this.successOnFocusOut', this.successOnFocusOut);

        if (   !this.textbox.keyBlur
            && !this.readOnly) this.textbox.finish(true);
        else                   this.textbox.keyBlur = false;

        if (this.savedSuccessOnFocusOut != null)
        {
            this.successOnFocusOut      = this.savedSuccessOnFocusOut;
            this.savedSuccessOnFocusOut = null;
        }

        if (this.param.div.parentNode.contains(this.textbox))
            this.param.div.parentNode.removeChild(this.textbox);

        this.textbox.shown = false;

        this.divValue.style.display = 'block';
        
        this.clicked = false;
    });
    


    this.textbox.addEventListener('pointerdown', e =>
    {
        forwardEvent(e, this.div);

        if (e.button == 1)
        {
            e.preventDefault();
            return;
        }

        e.stopPropagation();
    });



    this.textbox.addEventListener('wheel', e =>
    {
        e.stopPropagation();
        forwardEvent(e, this.div);
    });



    this.textbox.finish = (success, focusControl = true) =>
    {
        let   value      = this.textbox.value;
        const savedValue = this.textbox.savedValue;

        
        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           value,
            'oldValue':        savedValue,
            'preventSetValue': false }});
            
        this.dispatchEvent(e);
            
        
        // const webColor = webColors.find(wc => wc.name.toLowerCase() == e.detail.value.toLowerCase());

        // const rgb = validHex2rgb(webColor ? webColor.color : e.detail.value);
        // const val = ColorValue.fromRgb(scaleRgb(rgb));


        let rgb      = validHex2rgb(value);
        let savedRgb = validHex2rgb(savedValue);
        

        if (!e.preventSetValue)
        {
            if (success) 
            {
                this.setValue(
                      value.trim() != '' 
                    ? ColorValue.fromRgb(scaleRgb(rgb     )) 
                    : ColorValue.fromRgb(scaleRgb(savedRgb)));
            }
            else
                this.setValue(ColorValue.fromRgb(scaleRgb(savedRgb)));
        }

        
        this.textbox.blur();

        this.divValue.style.display = 'block';

        if (   this.inFocus
            && focusControl)
            this.div.focus();


        actionManager.redoActions = [];
    };    
};



ColorControl.prototype.showTextbox = function()
{
    this.divValue.style.display = 'none';

    this.inFocus = 
           hasFocus(this.div)
        && !this.clicked;

    // this.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
    // this.textbox.style.outline   = 'none';


    this.param.formatControlTextbox(this);

    this.updateTextbox();

    
    this.param.div.parentNode.appendChild(this.textbox);
    
    this.textbox.focus();
    // this.textbox.select();

    this.textbox.style.cursor = 'default';
};



ColorControl.prototype.updateTextbox = function()
{
    const rgb = this.value.toRgb();

    this.textbox.value =
        !this.value.isValid()
        ? UNKNOWN_CHAR
        : rgbIsValid(rgb)
          ? rgb2hex(rgb).toUpperCase()
          : UNKNOWN_CHAR;
    
    this.textbox.savedValue = this.textbox.value;
};



ColorControl.prototype.initEvents = function()
{
    this.div.addEventListener('pointerenter', e =>
    {
        if (panMode)
        {
            setCursor(panCursor);
            return;
        }


        if (   !graphView.spaceDown
            &&  this.pointerEvents)
        {
            if (graphView.tempConn)
                this.div.style.cursor = 'default';

                
            this.updateFocusBorder();


            this.divFocus.style.visibility = 'visible';
            this.divFocus.style.opacity    = '100%';
    
            this.update();
        }
    });



    this.div.addEventListener('pointerdown', e =>
    {
        if (e.button == 1)
        {
            e.preventDefault();
            return;
        }


        if (!this.canReact(e))
            return;
    
    
        if (   graphView.spaceDown
            || panMode)
            return;


        window.focus();
        
        hideAllMenus();


        if (this.param.node.div.style.zIndex < graphView.getTopNodeIndex())
            graphView.putNodeOnTop(this.param.node);


        if (e.button == 0)
        {
            if (!this.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let nodeDiv = 
                   this.parentNode
                && this.parentNode.parentNode
                && this.parentNode.parentNode.parentNode
                ? this.parentNode.parentNode.parentNode
                : null;

            if (nodeDiv && nodeDiv.className == 'node') 
                graphView.putNodeOnTop(nodeDiv.node);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();

            
            this.buttonDown0  = true;
            this.buttonDown0_ = true;
            //this.moved        = false;
            this.clientX      = e.clientX;
            //this.movedX       = 0;


            if (!this.readOnly)
            {
                this.oldValue   = this.value;
                //this.startValue = this.value;
                //this.prevValue  = this.value;
                //this.sx         = e.clientX;
            }


            this.updateFocusBorder();



            this.textbox.selectionStart = 0;
            this.textbox.selectionEnd   = 0;

            this.showTextbox();

            //forwardEvent(e, this.textbox);


            if (this.param)
                this.param.noUpdate = true;  
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            this.buttonDown1 = true;
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();
            this.buttonDown2 = true;
        }
    });



    this.div.addEventListener('pointermove', e =>
    {
        if (panMode)
        {
            setCursor(panCursor);
            return;
        }

        if (!this.pointerEvents)
            return;
        

        let rect = boundingRect(this.div);
        
        this.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        this.clientX = e.clientX;

        
        if (    this.buttonDown0
            && !this.readOnly)
        {
            //forwardEvent(e, this.textbox);
            // ...
        }
        else if (graphView.tempConn
              && this.param)
        {
            this.checkDragConnection();
        }
        // else if (this.readOnly)
        // {
        //     this.moved = true;
        // }
    });
    
    
    
    this.div.addEventListener('pointerleave', e =>
    {
        if (panMode)
            return;


        this.div.style.cursor       = 'default';
        
        this.divFocus.style.visibility = 'hidden';
        this.divFocus.style.opacity    = 0;

        this.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != this.param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
                //graphView.tempConn.output.updateControl();
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != this.param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                //graphView.tempConn.input.updateControl();
           }
        }
    });



    this.div.addEventListener('losecapture', () =>
    {
        this.buttonDown0 = false;
        this.buttonDown1 = false;
        this.buttonDown2 = false;
        this.mouseOver   = false;
        
        this.update();
    });



    this.div.addEventListener('pointerup', e =>
    {
        clearTimeout(this.clickTimer);


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(this.param.node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !this.param.node.isOrFollows(graphView.tempConn.input.node)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overOutput.endConnection();
            }
        }
        
        else if (/*this.moved
              ||*/ document.menuHadFocus)
        {
            this.unlockPointer(e.pointerId);

            if (this.param)
                this.param.noUpdate = false;  

            return;            
        }

        else if (this.buttonDown0_)
        {
            this.clicked = true;
            // this.showTextbox();
        }

             if (e.button == 0) this.buttonDown0 = false;
        else if (e.button == 1) this.buttonDown1 = false;
        else if (e.button == 2) this.buttonDown2 = false;

        this.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', e =>
    {
        e.stopPropagation();


        if (panMode)
            return;

            
        if (   e.button == 0 
            && this.buttonDown0)
        {
            this.buttonDown0 = false;
            this.unlockPointer(e.pointerId);

            this.divFocus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            // if (    this.value != this.oldValue
            //     && !this.readOnly)
            //     this.dispatchEvent(this.onconfirm);
        }
        // else if (   e.button == 1
        //     && this.buttonDown1)
        // {
        //     this.buttonDown1 = false;            
        // }
    });


    
    this.div.addEventListener('wheel', e =>
    {
        if (  !this.pointerEvents
            || panMode
            || graphView.wheelTimer)
            return;


        const touchpad = isTouchpad(e);

        if (touchpad)
        {
            e.preventDefault();
            return;
        }


        // const dWheelX = e.deltaX /  20 * (this.dragReverse ? -1 : 1);
        // const dWheelY = e.deltaY / 100 * (this.dragReverse ? -1 : 1);


        if (   !getCtrlKey(e)
            && !this.buttonDown1)
        {
            e.stopPropagation();

            if (!this.readOnly)
            {
                // if (   document.activeElement
                //     && document.activeElement.tagName.toLowerCase() == 'input'
                //     && document.activeElement.control)
                //     document.activeElement.control.textbox.finish(true, false);

                // this.oldValue = this.value;

                // const dec = Math.pow(10, -this.decimals);

                // const val =
                //     touchpad
                //     ? this.value -  dWheelX               * this.wheelScale * dec
                //     : this.value + (dWheelY > 0 ? -1 : 1) * this.wheelScale * dec;
                
                // this.setValue(val, true, true, false, false);
            }
        }
    });



    // graphView.div.addEventListener('touchstart', e =>
    // {
    //     graphView.touches.push(e);
    //     e.preventDefault();
    // });
    
    
    
    // graphView.div.addEventListener('touchmove', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches[i] = e;
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.div.addEventListener('touchend', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.div.addEventListener('touchcancel', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    this.div.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            this.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    this.div.addEventListener('focus', () =>
    {
        if (   !graphView.spaceDown
            && !panMode
            && !this.buttonDown1
            && this.pointerEvents)
            this.showTextbox();
    });
};



class ColorListMenuItem
{
    parentMenu    = null;
    index         = -1;

    enabled       = true;

    callback      = null;

    noColorLine   = null;

    div;
    divHighlight;

    divColor1;
    divColor2;
    divColor3;
    divColor4;
    divColor5;
    divColor6;
    divColor7;
    divColor8;

    mouseOver = false;



    constructor(options = {})
    {
        this.initOptions(options);
        this.createControls();

        this.update();
    }



    initOptions(options)
    {
        if (options.callback != undefined) this.callback = options.callback;
    }



    createControls()
    {
        this.div          = createDiv('menuItem');
        this.divHighlight = createDiv('menuItemHighlight');

        this.divColor1    = createDiv('menuItemColor');
        this.divColor2    = createDiv('menuItemColor');
        this.divColor3    = createDiv('menuItemColor');
        this.divColor4    = createDiv('menuItemColor');
        this.divColor5    = createDiv('menuItemColor');
        this.divColor6    = createDiv('menuItemColor');
        this.divColor7    = createDiv('menuItemColor');
        this.divColor8    = createDiv('menuItemColor');

        this.div      .style.textAlign  = 'center';
        this.div      .style.top        = '-8px';
        this.div      .style.height     = '41px';
        
        this.divColor1.style.background = 'transparent';
        this.divColor1.style.boxShadow  = '0 0 0 1px inset #fff2';
        

        this.noColorLine = createDiv();
        
        this.noColorLine.style.width      = '1px';
        this.noColorLine.style.height     = '19px';
        this.noColorLine.style.transform  = 'rotate(45deg)';
        this.noColorLine.style.position   = 'relative';
        this.noColorLine.style.left       = '8px';
        this.noColorLine.style.top        = '-2px';
        this.noColorLine.style.background = '#fff2';

        this.divColor1.appendChild(this.noColorLine);


        this.divColor2.style.background = '#d44';
        this.divColor3.style.background = '#f94';
        this.divColor4.style.background = '#dd4';
        this.divColor5.style.background = '#4d4';
        this.divColor6.style.background = '#36f';
        this.divColor7.style.background = '#d4d';
        this.divColor8.style.background = darkMode ? '#ddd' : '#333';

        this.divHighlight.style.zIndex = -2;

        
        this.div.appendChild(this.divHighlight);

        this.div.appendChild(this.divColor1);
        this.div.appendChild(this.divColor2);
        this.div.appendChild(this.divColor3);
        this.div.appendChild(this.divColor4);
        this.div.appendChild(this.divColor5);
        this.div.appendChild(this.divColor6);
        this.div.appendChild(this.divColor7);
        this.div.appendChild(this.divColor8);



        this.div.addEventListener('pointerup', e => 
        {
            e.stopPropagation();
            e.preventDefault();


            if (e.button == 0)
            {
                const rect = boundingRect(this.div);

                if (this.callback)
                {
                    let index = Math.round((e.clientX - (rect.x-8)) / 24) - 1;
                        index = Math.min(Math.max(0, index), 7);

                    this.callback(index);
                }
            }
        });



        this.div.addEventListener('pointermove', e =>
        {
            if (this.enabled)
            {
                this.mouseOver = true;
                this.update();


                const rect = boundingRect(this.div);

                let index = Math.round((e.clientX - (rect.x-8)) / 24) - 1;
                    index = Math.min(Math.max(0, index), 7);

                this.divHighlight.style.left   = (4 + index*24) + 'px';
                this.divHighlight.style.width  = '24px';
                this.divHighlight.style.top    = '0px';
                this.divHighlight.style.height = '41px';

                this.enteredDiv  = true;
            }
        });
    

    
        this.div.addEventListener('pointerleave', () =>
        {
            this.mouseOver = false;
            this.update();

            this.enteredDiv    = false;
            this.enteredExpand = false;
        });


        this.update();
    }



    select(shift = false, ctrl = false, alt = false, x = Number.NaN, y = Number.NaN)
    {
        if (!this.enabled)
            return;


        if (!isEmpty(currentMenus)) // this lets the item be selected without its parent menu being involved
        {
            if (this.parentMenu.button)
                this.parentMenu.button.update();
        }

        if (!shift) 
            hideAllMenus();


        const e = 
        {
            shiftKey: shift,
            ctrlKey:  ctrl,
            altKey:   alt
        };


        if (!isNaN(x)) e.clientX = x;
        if (!isNaN(y)) e.clientY = y;

        if (this.callback)
            this.callback(e);
    }



    // setEnabled(enabled)
    // {
    //     this.enabled = enabled;
    //     this.update();
    // }



    setVisible(visible)
    {
        this.div.style.display = visible ? 'inline-block' : 'none';
    }



    update()
    {
        this.divHighlight.style.background = 
               this.mouseOver
            ||    this.childMenu
               && this.childMenu.visible
            ? 'var(--figma-color-bg-brand)'
            : 'transparent';

        this.divColor8  .style.background = darkMode ? '#ddd' : '#333';
        this.noColorLine.style.background = darkMode ? 'transparent' : '#fff2';
        
        this.div.style.opacity = this.enabled ? '100%' : '40%';
    }
}


const iconGenerator         = '<svg width="20" height="10" viewBox="0 0 20 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.4662 3.05966C12.3952 2.82955 12.2972 2.62358 12.1722 2.44176C12.05 2.2571 11.9023 2.09943 11.729 1.96875C11.5585 1.83807 11.3625 1.74006 11.1409 1.67472C10.9193 1.60653 10.6779 1.57244 10.4165 1.57244C9.94775 1.57244 9.53014 1.69034 9.16366 1.92614C8.79718 2.16193 8.50883 2.50852 8.2986 2.96591C8.09122 3.42045 7.98752 3.97443 7.98752 4.62784C7.98752 5.28693 8.09122 5.84517 8.2986 6.30256C8.50599 6.75994 8.79434 7.10795 9.16366 7.34659C9.53298 7.58239 9.96196 7.70028 10.4506 7.70028C10.8938 7.70028 11.2773 7.61506 11.6012 7.4446C11.9279 7.27415 12.1793 7.03267 12.3554 6.72017C12.5316 6.40483 12.6196 6.03551 12.6196 5.61222L12.9776 5.66761H10.6083V4.43182H14.1495V5.48011C14.1495 6.22727 13.9904 6.87358 13.6722 7.41903C13.354 7.96449 12.9165 8.38494 12.3597 8.6804C11.8029 8.97301 11.1637 9.11932 10.4421 9.11932C9.63809 9.11932 8.93213 8.93892 8.32417 8.57812C7.71906 8.21449 7.24605 7.69886 6.90514 7.03125C6.56707 6.3608 6.39804 5.56534 6.39804 4.64489C6.39804 3.94034 6.49747 3.31108 6.69633 2.7571C6.89804 2.20312 7.17929 1.73295 7.54008 1.34659C7.90088 0.957386 8.32417 0.661932 8.80997 0.460227C9.29576 0.255682 9.82417 0.153409 10.3952 0.153409C10.8781 0.153409 11.3284 0.224432 11.746 0.366477C12.1637 0.505682 12.5344 0.704545 12.8583 0.963068C13.185 1.22159 13.4534 1.52841 13.6637 1.88352C13.8739 2.23864 14.0117 2.63068 14.077 3.05966H12.4662Z" fill="white"/><circle cx="2.5" cy="4.5" r="2" stroke="white"/><circle cx="18" cy="4.9" r="2" fill="white"/></svg>';

const iconPage              = '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="14" height="14" rx="2.5" fill="#0C8CE9"/><path d="M7.4745 3.79841C7.83778 3.52553 8.2647 3.34457 8.78006 3.32152C8.92706 2.6837 9.49845 2.20813 10.1809 2.20813C10.9749 2.20813 11.6185 2.85175 11.6185 3.64569C11.6185 4.43963 10.9749 5.08325 10.1809 5.08325C9.61362 5.08325 9.12307 4.75465 8.88923 4.2774C8.54486 4.27815 8.28313 4.38963 8.0501 4.56468C7.73976 4.79779 7.47714 5.14458 7.16592 5.57207L7.10258 5.65929C6.7792 6.1051 6.39914 6.62905 5.86696 6.99999C6.39914 7.37093 6.7792 7.89489 7.10258 8.3407L7.16592 8.42792C7.47714 8.85541 7.73976 9.2022 8.0501 9.43531C8.28313 9.61036 8.54486 9.72184 8.88923 9.7226C9.12307 9.24535 9.61362 8.91674 10.1809 8.91674C10.9749 8.91674 11.6185 9.56035 11.6185 10.3543C11.6185 11.1482 10.9749 11.7919 10.1809 11.7919C9.49845 11.7919 8.92706 11.3163 8.78006 10.6785C8.2647 10.6554 7.83778 10.4745 7.4745 10.2016C7.03044 9.86801 6.68787 9.39958 6.39113 8.99198C5.871 8.27753 5.4567 7.71987 4.80484 7.54038C4.59126 8.06653 4.07511 8.43755 3.47231 8.43755C2.67837 8.43755 2.03475 7.79393 2.03475 6.99999C2.03475 6.20605 2.67837 5.56243 3.47231 5.56243C4.07512 5.56243 4.59127 5.93346 4.80485 6.45961C5.4567 6.28012 5.871 5.72245 6.39113 5.00801C6.68787 4.6004 7.03044 4.13197 7.4745 3.79841Z" fill="white"/></svg>';
const iconPageClose         = '<svg width="9" height="10" viewBox="0 0 9 10" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="1.23505" y="9.01202" width="1.6925" height="9.641" transform="rotate(-135 1.23505 9.01202)" fill="white"/><rect x="8.05226" y="7.81525" width="1.6925" height="9.641" transform="rotate(135 8.05226 7.81525)" fill="white"/></svg>';
// const iconAddPage           = '<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M6 0.5H4V4L0.5 4V6H4V9.5H6V6H9.5V4L6 4V0.5Z" fill="white"/></svg>';

const iconFlow              = '<svg width="15" height="13" viewBox="0 0 15 13" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12.687" cy="2" r="1.5" stroke="white"/><circle cx="12.687" cy="11" r="1.5" stroke="white"/><circle cx="1.84381" cy="6.49994" r="1.8432" fill="white"/><path d="M10.9606 2C7.44962 2 7.12345 6.5 3.41345 6.5C7.12345 6.5 7.44962 11 10.9606 11" stroke="white"/></svg>';
const iconMulti             = '<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2" cy="2" r="1.5" transform="matrix(-1 0 0 1 14 10)" stroke="white"/><circle cx="2" cy="2" r="1.5" transform="matrix(-1 0 0 1 14 5)" stroke="white"/><circle cx="2" cy="2" r="1.5" transform="matrix(-1 0 0 1 14 0)" stroke="white"/><path d="M10.5347 2.03381C7.36042 2.60771 4.09524 2.05543 1.27273 0.467569" stroke="white"/><path d="M10.5347 12C7.36042 11.4261 4.09524 11.9784 1.27273 13.5662" stroke="white"/><rect x="0.554077" y="6.5" width="9.98065" height="1" fill="white"/></svg>';

const iconStart             = '<svg width="17" height="8" viewBox="0 0 17 8" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="1.5" cy="3.5" r="1.5" fill="white"/><path d="M12.7071 0L16.2427 3.53553L16.2241 3.55415L16.2371 3.56723L12.7202 7.08416L12.0131 6.37705L14.3901 4.00001H7V3.00001H14.2929L12 0.707107L12.7071 0Z" fill="white"/></svg>';
const iconRepeat            = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle r="1.5" transform="matrix(-1 0 0 1 8.5 13.6003)" fill="white"/><path d="M12.996 11.5078C14.0482 10.4921 14.7227 9.16438 14.9093 7.74161C15.0958 6.31883 14.7834 4.88515 14.023 3.67489C13.2626 2.46463 12.0993 1.54937 10.7232 1.0787C9.34705 0.608019 7.83949 0.609769 6.44689 1.08365C5.05429 1.55754 3.85902 2.47553 3.05643 3.6876C2.25383 4.89967 1.89138 6.33413 2.02832 7.75654C2.12729 8.78463 2.48292 9.76246 3.05643 10.6082" stroke="white"/><rect width="4.97369" height="1" transform="matrix(-1 0 0 1 5.00183 10.0282)" fill="white"/><rect width="4.01843" height="1" transform="matrix(1.19249e-08 -1 -1 -1.19249e-08 5.00183 11.0282)" fill="white"/></svg>';
const iconNull              = '<svg width="9" height="15" viewBox="0 0 9 15" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="4.5" cy="7.5" r="4.15" stroke="white" stroke-width="0.7"/><rect x="7.95483" y="0.834351" width="0.681603" height="15" transform="rotate(30 7.95483 0.834351)" fill="white"/></svg>';
const iconCache             = '<svg width="16" height="11" viewBox="0 0 16 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.30354 1C1.68389 1.65376 1.20536 2.44219 0.906305 3.31653C0.435625 4.69266 0.437375 6.20022 0.911255 7.59282C1.21859 8.49597 1.71272 9.31613 2.35271 10" stroke="white"/><path d="M12.7415 1C13.3612 1.65376 13.8397 2.44219 14.1387 3.31653C14.6094 4.69266 14.6077 6.20022 14.1338 7.59282C13.8265 8.49597 13.3323 9.31613 12.6923 10" stroke="white"/><circle cx="1.5" cy="1.5" r="1.5" transform="matrix(-1 0 0 1 9 4)" fill="white"/></svg>';
const iconFreeze            = '<svg width="18" height="11" viewBox="0 0 18 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.0334 0V11H14.0334V10H16.0667L16.0334 1H14L14.0334 0H17.0334Z" fill="white"/><path d="M0 11V0H3V1H0.966639V10H3V11H0Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.9143 6.37823L11.4429 6.08713C11.4802 5.89844 11.5 5.70228 11.5 5.5C11.5 5.29772 11.4802 5.10156 11.4429 4.91287L12.9143 4.62177C12.9705 4.90581 13 5.19947 13 5.5C13 5.80053 12.9705 6.09419 12.9143 6.37823ZM12.242 2.99973L10.9956 3.83421C10.7761 3.50641 10.4936 3.22387 10.1658 3.00441L11.0003 1.75796C11.491 2.08649 11.9135 2.509 12.242 2.99973ZM9.37823 1.08565L9.08713 2.55714C8.89844 2.51981 8.70228 2.5 8.5 2.5C8.29772 2.5 8.10156 2.51981 7.91287 2.55714L7.62177 1.08565C7.90581 1.02946 8.19947 1 8.5 1C8.80053 1 9.09419 1.02946 9.37823 1.08565ZM5.99973 1.75796L6.83421 3.00441C6.50641 3.22387 6.22387 3.50641 6.00441 3.83421L4.75796 2.99973C5.08649 2.509 5.509 2.08649 5.99973 1.75796ZM4.08565 4.62177C4.02946 4.90581 4 5.19947 4 5.5C4 5.80053 4.02946 6.09419 4.08565 6.37823L5.55714 6.08713C5.51981 5.89844 5.5 5.70228 5.5 5.5C5.5 5.29772 5.51981 5.10156 5.55714 4.91287L4.08565 4.62177ZM4.75796 8.00027L6.00441 7.16579C6.22387 7.49359 6.50641 7.77613 6.83421 7.99559L5.99973 9.24204C5.509 8.91351 5.08649 8.491 4.75796 8.00027ZM7.62177 9.91435L7.91287 8.44286C8.10156 8.48019 8.29772 8.5 8.5 8.5C8.70228 8.5 8.89844 8.48019 9.08713 8.44286L9.37823 9.91435C9.09419 9.97054 8.80053 10 8.5 10C8.19947 10 7.90581 9.97054 7.62177 9.91435ZM11.0003 9.24204L10.1658 7.99559C10.4936 7.77613 10.7761 7.49359 10.9956 7.16579L12.242 8.00027C11.9135 8.491 11.491 8.91351 11.0003 9.24204Z" fill="white"/></svg>';
const iconTimer             = '<svg width="13" height="18" viewBox="0 -1 13 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 0H4L4 2H5.5V4.07645C2.38491 4.55745 0 7.25021 0 10.5C0 14.0899 2.91015 17 6.5 17C10.0899 17 13 14.0899 13 10.5C13 7.25021 10.6151 4.55745 7.5 4.07645V2L9 2V0ZM6.5 5C3.46243 5 1 7.46243 1 10.5C1 13.5376 3.46243 16 6.5 16C9.53757 16 12 13.5376 12 10.5C12 7.46243 9.53757 5 6.5 5Z" fill="white"/><path d="M6.65821 9.51244L9.70667 6.46399L10.6001 7.35747L7.49915 10.4585C7.49972 10.4722 7.5 10.4861 7.5 10.5C7.5 11.0523 7.05229 11.5 6.5 11.5C5.94771 11.5 5.5 11.0523 5.5 10.5C5.5 9.94771 5.94771 9.5 6.5 9.5C6.55384 9.5 6.60668 9.50425 6.65821 9.51244Z" fill="white"/></svg>';
const iconValueName         = '<svg width="15" height="6" viewBox="0 0 15 6" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="4" y="5" width="7" height="1" fill="white"/><path d="M14.28 1.14446L14.28 0L12.735 -1.35074e-07L12.735 1.15568C12.7385 1.58953 12.6706 1.98597 12.5311 2.34502C12.388 2.70781 12.211 3.05563 12 3.3885L12.9013 4C13.1624 3.77934 13.3984 3.50818 13.6094 3.18654C13.8169 2.86863 13.9814 2.53015 14.103 2.17111C14.221 1.8158 14.28 1.47359 14.28 1.14446Z" fill="white"/><path d="M3.22168 1.14446L3.22168 0L1.67662 -1.35074e-07L1.67662 1.15568C1.68019 1.58953 1.61224 1.98597 1.47275 2.34502C1.32969 2.70781 1.15265 3.05563 0.941637 3.3885L1.84292 4C2.10401 3.77934 2.34006 3.50818 2.55108 3.18654C2.75852 2.86863 2.92304 2.53015 3.04464 2.17111C3.16267 1.8158 3.22168 1.47359 3.22168 1.14446Z" fill="white"/></svg>';

const iconList              = '<svg width="12" height="9" viewBox="0 0 12 9" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="1" fill="white"/><rect y="4" width="9" height="1" fill="white"/><rect y="8" width="9" height="1" fill="white"/></svg>';
const iconCondense          = '<svg width="13" height="9" viewBox="0 0 13 9" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="5" height="1" fill="white"/><rect y="8" width="5" height="1" fill="white"/><rect y="4" width="13" height="1" fill="white"/><rect x="4.99963" width="5.52856" height="1" transform="rotate(49.2368 4.99963 0)" fill="white"/><rect width="5.52856" height="1" transform="matrix(0.652935 -0.757414 -0.757414 -0.652935 4.99963 8.98938)" fill="white"/></svg>';
const iconSublist           = '<svg width="15" height="13" viewBox="-1 0 15 13" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="1" fill="white"/><rect y="12" width="9" height="1" fill="white"/><rect x="5" y="4" width="9" height="1" fill="white"/><rect x="5" y="8" width="9" height="1" fill="white"/></svg>';
const iconUnique            = '<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="1" fill="white"/><rect x="4" y="12" width="9" height="1" fill="white"/><rect x="4" y="4" width="9" height="1" fill="white"/><rect y="8" width="9" height="1" fill="white"/></svg>';
const iconReverseList       = '<svg width="19" height="15" viewBox="-2 0 19 15" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="3" width="9" height="1" fill="white"/><rect y="7" width="9" height="1" fill="white"/><rect y="11" width="9" height="1" fill="white"/><path d="M11.9899 13.7828L11.9886 13.9778L15.9189 14.004L15.9268 12.8194L13.9576 12.8063C14.7313 11.9939 15.4826 10.933 15.9038 9.70503C16.1407 9.01413 16.2718 8.27255 16.245 7.49996H15.0596C15.0877 8.13674 14.98 8.74699 14.7833 9.3207C14.4072 10.417 13.7011 11.3868 12.97 12.1229L12.6764 9.8487L11.5016 10.0004L11.9899 13.7828Z" fill="white"/><path d="M11.9899 1.21724L11.9886 1.02219L15.9189 0.995972L15.9268 2.18055L13.9576 2.19368C14.7313 3.00606 15.4826 4.06702 15.9038 5.29496C16.1407 5.98586 16.2718 6.72737 16.245 7.49996H15.0596C15.0877 6.86318 14.98 6.253 14.7833 5.67929C14.4072 4.58301 13.7011 3.61316 12.97 2.87713L12.6764 5.15129L11.5016 4.99962L11.9899 1.21724Z" fill="white"/></svg>';
const iconSort              = '<svg width="11" height="9" viewBox="0 0 11 9" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="4" width="3" height="1" fill="white"/><rect x="2" y="4" width="7" height="1" fill="white"/><rect y="8" width="11" height="1" fill="white"/></svg>';
const iconColumn            = '<svg width="9" height="11" viewBox="0 0 9 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="11" width="11" height="1" transform="rotate(-90 0 11)" fill="white"/><rect x="4" y="11" width="11" height="1" transform="rotate(-90 4 11)" fill="white"/><rect x="8" y="11" width="11" height="1" transform="rotate(-90 8 11)" fill="white"/></svg>';
const iconCell              = '<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="2" width="13" height="1" fill="white"/><rect x="11" width="13" height="1" transform="rotate(90 11 0)" fill="white"/><rect y="6" width="13" height="1" fill="white"/><rect x="7" width="13" height="1" transform="rotate(90 7 0)" fill="white"/><rect y="10" width="13" height="1" fill="white"/><rect x="3" width="13" height="1" transform="rotate(90 3 0)" fill="white"/></svg>';
const iconItems             = '<svg width="17" height="11" viewBox="-1 0 17 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="1" transform="matrix(-1 0 0 1 9 1)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 9 5)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 9 9)" fill="white"/><circle r="1.5" transform="matrix(-1 0 0 1 13.5 9.5)" fill="white"/><circle r="1.5" transform="matrix(-1 0 0 1 13.5 5.5)" fill="white"/><circle r="1.5" transform="matrix(-1 0 0 1 13.5 1.5)" fill="white"/></svg>';
const iconSelect            = '<svg width="15" height="9" viewBox="0 0 15 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 0H9V1H0V0Z" fill="white"/><path d="M0 4H9V5H0V4Z" fill="white"/><path d="M0 8H9V9H0V8Z" fill="white"/><path d="M13.5 6C12.6716 6 12 5.32843 12 4.5C12 3.67157 12.6716 3 13.5 3C14.3284 3 15 3.67157 15 4.5C15 5.32843 14.3284 6 13.5 6Z" fill="white"/></svg>';
const iconCount             = '<svg width="16" height="11" viewBox="0 0 16 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.0334 0V11H12.0334V10H14.0667L14.0334 1H12L12.0334 0H15.0334Z" fill="white"/><path d="M0 11V0H3V1H0.966639V10H3V11H0Z" fill="white"/><path d="M7.5 11C6.67157 11 6 10.3284 6 9.5C6 8.67157 6.67157 8 7.5 8C8.32843 8 9 8.67157 9 9.5C9 10.3284 8.32843 11 7.5 11Z" fill="white"/><path d="M7.5 7C6.67157 7 6 6.32843 6 5.5C6 4.67157 6.67157 4 7.5 4C8.32843 4 9 4.67157 9 5.5C9 6.32843 8.32843 7 7.5 7Z" fill="white"/><path d="M7.5 3C6.67157 3 6 2.32843 6 1.5C6 0.671573 6.67157 0 7.5 0C8.32843 0 9 0.671573 9 1.5C9 2.32843 8.32843 3 7.5 3Z" fill="white"/></svg>';
const iconContains          = '<svg width="16" height="11" viewBox="0 0 16 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.0334 0V11H12.0334V10H14.0667L14.0334 1H12L12.0334 0H15.0334Z" fill="white"/><path d="M0 11V0H3V1H0.966639V10H3V11H0Z" fill="white"/><path d="M6.89844 6.69572V6.5825C6.9005 6.19398 6.9325 5.88427 6.99444 5.65338C7.05845 5.42249 7.15136 5.236 7.27318 5.09392C7.39499 4.95183 7.54158 4.82306 7.71295 4.70762C7.84096 4.61881 7.95555 4.52668 8.05672 4.43121C8.15789 4.33575 8.23841 4.23029 8.29828 4.11485C8.35816 3.99718 8.3881 3.8662 8.3881 3.72189C8.3881 3.5687 8.35403 3.43438 8.28589 3.31894C8.21776 3.20349 8.12588 3.11469 8.01026 3.05253C7.8967 2.99036 7.77076 2.95928 7.63243 2.95928C7.49822 2.95928 7.37125 2.99147 7.2515 3.05586C7.13175 3.11802 7.03367 3.21126 6.95728 3.33559C6.88089 3.4577 6.83959 3.60977 6.8334 3.79182H5.56982C5.58015 3.3478 5.67925 2.98148 5.86714 2.69287C6.05502 2.40203 6.30381 2.18557 6.61351 2.04349C6.92321 1.89918 7.26492 1.82703 7.63862 1.82703C8.04949 1.82703 8.41287 1.90029 8.72877 2.04682C9.04466 2.19112 9.29242 2.40092 9.47205 2.67622C9.65167 2.95151 9.74149 3.28342 9.74149 3.67194C9.74149 3.93169 9.70122 4.16258 9.6207 4.36461C9.54225 4.56442 9.43179 4.74203 9.28932 4.89744C9.14686 5.05062 8.97859 5.18938 8.78451 5.31371C8.6214 5.41805 8.4872 5.52684 8.3819 5.64006C8.27867 5.75329 8.20124 5.88427 8.14963 6.03302C8.10007 6.18177 8.07427 6.36493 8.0722 6.5825V6.69572H6.89844Z" fill="white"/><path d="M6.8875 9.16541C7.06026 9.34855 7.26829 9.44012 7.51161 9.44012C7.66733 9.44012 7.81088 9.39826 7.94227 9.31454C8.07366 9.2282 8.17951 9.11439 8.2598 8.97311C8.34253 8.82921 8.38511 8.67092 8.38754 8.49824C8.38511 8.24184 8.2963 8.02207 8.12111 7.83892C7.94592 7.65578 7.74276 7.56421 7.51161 7.56421C7.26829 7.56421 7.06026 7.65578 6.8875 7.83892C6.71718 8.02207 6.63324 8.24184 6.63567 8.49824C6.63324 8.75726 6.71718 8.97965 6.8875 9.16541Z" fill="white"/></svg>';
const iconForEach           = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="9" width="9" height="1" fill="white"/><circle cx="1.5" cy="9.5" r="1.5" fill="white"/><circle cx="1.5" cy="5.5" r="1.5" fill="white"/><circle cx="1.5" cy="1.5" r="1.5" fill="white"/></svg>';
const iconDefine            = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 1H6V2H15V1Z" fill="white"/><path d="M15 5H6V6H15V5Z" fill="white"/><path d="M15 9H6V10H15V9Z" fill="white"/><path d="M1.5 11C2.32843 11 3 10.3284 3 9.5C3 8.67157 2.32843 8 1.5 8C0.671573 8 0 8.67157 0 9.5C0 10.3284 0.671573 11 1.5 11Z" fill="white"/><path d="M1.5 7C2.32843 7 3 6.32843 3 5.5C3 4.67157 2.32843 4 1.5 4C0.671573 4 0 4.67157 0 5.5C0 6.32843 0.671573 7 1.5 7Z" fill="white"/><path d="M1.5 3C2.32843 3 3 2.32843 3 1.5C3 0.671573 2.32843 0 1.5 0C0.671573 0 0 0.671573 0 1.5C0 2.32843 0.671573 3 1.5 3Z" fill="white"/></svg>';
//const iconFeedback          = '<svg width="14" height="12" viewBox="0 0 14 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.70714 0L11.2427 3.53553L11.2241 3.55415L11.2371 3.56723L7.7202 7.08416L7.0131 6.37705L9.39014 4.00001H4V4C2.34315 4 1 5.34315 1 7C1 8.65685 2.34315 10 4 10H14V11H4C1.79086 11 0 9.20914 0 7C0 4.79086 1.79086 3 4 3V3.00001H9.29294L7.00004 0.707107L7.70714 0Z" fill="white"/></svg>';
const iconIfElse            = '<svg width="17" height="7" viewBox="-1 0 17 7" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="1" width="9" height="1" fill="white"/><rect y="5" width="9" height="1" fill="white"/><path d="M13.157 4.8687V4.75547C13.1591 4.36695 13.1911 4.05725 13.253 3.82636C13.317 3.59546 13.4099 3.40898 13.5318 3.26689C13.6536 3.1248 13.8002 2.99604 13.9715 2.88059C14.0995 2.79179 14.2141 2.69965 14.3153 2.60419C14.4165 2.50872 14.497 2.40327 14.5569 2.28782C14.6167 2.17016 14.6467 2.03917 14.6467 1.89486C14.6467 1.74167 14.6126 1.60736 14.5445 1.49191C14.4763 1.37647 14.3845 1.28766 14.2688 1.2255C14.1553 1.16334 14.0293 1.13225 13.891 1.13225C13.7568 1.13225 13.6298 1.16445 13.5101 1.22883C13.3903 1.29099 13.2922 1.38424 13.2159 1.50856C13.1395 1.63067 13.0982 1.78275 13.092 1.9648H11.8284C11.8387 1.52077 11.9378 1.15446 12.1257 0.865842C12.3136 0.575008 12.5624 0.358548 12.8721 0.21646C13.1818 0.0721535 13.5235 0 13.8972 0C14.3081 0 14.6714 0.0732636 14.9873 0.219791C15.3032 0.364098 15.551 0.573898 15.7306 0.849191C15.9102 1.12448 16.0001 1.45639 16.0001 1.84491C16.0001 2.10466 15.9598 2.33555 15.8793 2.53758C15.8008 2.73739 15.6904 2.915 15.5479 3.07041C15.4054 3.2236 15.2372 3.36235 15.0431 3.48668C14.88 3.59102 14.7458 3.69981 14.6405 3.81304C14.5372 3.92626 14.4598 4.05725 14.4082 4.20599C14.3587 4.35474 14.3328 4.5379 14.3308 4.75547V4.8687H13.157ZM13.7702 6.9C13.5638 6.9 13.3872 6.8223 13.2406 6.66689C13.0961 6.50926 13.0249 6.32055 13.0269 6.10076C13.0249 5.88319 13.0961 5.6967 13.2406 5.54129C13.3872 5.38589 13.5638 5.30818 13.7702 5.30818C13.9664 5.30818 14.1388 5.38589 14.2874 5.54129C14.4361 5.6967 14.5114 5.88319 14.5135 6.10076C14.5114 6.24729 14.4753 6.38161 14.4051 6.50371C14.337 6.6236 14.2472 6.72017 14.1357 6.79344C14.0242 6.86448 13.9024 6.9 13.7702 6.9Z" fill="white"/></svg>';
 
const iconNumber            = '<svg width="16" height="7" viewBox="0 0 16 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13.4917 7C13.0139 7 12.5892 6.91793 12.2176 6.7538C11.8483 6.58967 11.5563 6.36122 11.3417 6.06844C11.1272 5.77567 11.0133 5.43742 11 5.05371H12.2475C12.2586 5.2378 12.3194 5.39861 12.43 5.53612C12.5406 5.67142 12.6877 5.77677 12.8713 5.85219C13.0548 5.9276 13.2605 5.9653 13.4884 5.9653C13.7317 5.9653 13.9473 5.92316 14.1353 5.83888C14.3234 5.75238 14.4705 5.6326 14.5766 5.47956C14.6828 5.32652 14.7348 5.15019 14.7326 4.95057C14.7348 4.7443 14.6817 4.56242 14.5733 4.40494C14.4649 4.24747 14.3079 4.12437 14.1022 4.03565C13.8987 3.94693 13.6532 3.90257 13.3656 3.90257H12.7651V2.95105H13.3656C13.6023 2.95105 13.8091 2.91001 13.986 2.82795C14.1652 2.74588 14.3057 2.63055 14.4074 2.48194C14.5092 2.33112 14.5589 2.157 14.5567 1.9596C14.5589 1.76664 14.5158 1.59918 14.4273 1.45722C14.3411 1.31305 14.2183 1.20105 14.059 1.1212C13.902 1.04135 13.7173 1.00143 13.505 1.00143C13.297 1.00143 13.1046 1.03913 12.9277 1.11454C12.7507 1.18996 12.608 1.29753 12.4997 1.43726C12.3913 1.57478 12.3338 1.73891 12.3271 1.92966H11.1427C11.1515 1.54816 11.261 1.21324 11.4711 0.924905C11.6835 0.634347 11.9666 0.408112 12.3205 0.246198C12.6744 0.0820661 13.0714 0 13.5116 0C13.965 0 14.3588 0.0853929 14.6927 0.256179C15.029 0.424746 15.2888 0.652091 15.4724 0.938213C15.656 1.22433 15.7478 1.5404 15.7478 1.88641C15.75 2.27012 15.6372 2.59173 15.4094 2.85124C15.1838 3.11074 14.8874 3.28042 14.5202 3.36027V3.4135C14.998 3.48004 15.3641 3.65748 15.6184 3.94582C15.875 4.23194 16.0022 4.58793 16 5.01378C16 5.39528 15.8916 5.73685 15.6748 6.0385C15.4603 6.33793 15.1639 6.57304 14.7856 6.74382C14.4096 6.91461 13.9783 7 13.4917 7Z" fill="white"/><path d="M5.04237 7V6.09634L7.66243 3.75289C7.90254 3.52136 8.10264 3.31567 8.26271 3.13584C8.42279 2.95601 8.54284 2.78179 8.62288 2.6132C8.70292 2.44461 8.74294 2.26477 8.74294 2.0737C8.74294 1.85565 8.69115 1.66908 8.58757 1.51397C8.48399 1.35662 8.34157 1.23523 8.16031 1.14981C7.97905 1.06439 7.66361 1.01493 7.43291 1.01493C7.19515 1.01493 6.98682 1.06214 6.80791 1.15655C6.629 1.24872 6.49011 1.38022 6.39124 1.55106C6.29473 1.7219 6.24647 1.92534 6.24647 2.16137H5C5 1.72302 5.10476 1.342 5.31427 1.0183C5.52378 0.694605 5.81215 0.443963 6.17938 0.266378C6.54896 0.0887927 6.97269 0 7.45056 0C7.9355 0 8.47105 0.0932886 8.83828 0.266378C9.20551 0.439467 9.49035 0.676622 9.6928 0.977842C9.8976 1.27906 10 1.62299 10 2.00963C10 2.26814 9.94821 2.52216 9.84463 2.77168C9.74105 3.02119 9.55862 3.29769 9.29732 3.60116C9.03837 3.90462 8.67467 4.27216 8.20622 4.70376L6.85028 5.90751V5.95472H10V7H5.04237Z" fill="white"/><path d="M3 0V7H1.70882V1.23389H1.66705L0 2.27979V1.11768L1.77146 0H3Z" fill="white"/></svg>';
const iconConstant          = '<svg width="17" height="19" viewBox="0 0 17 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.05788 19V12.8733C3.05788 12.4342 3.18522 12.1014 3.43991 11.8749C3.69681 11.646 4.04894 11.5316 4.4963 11.5316C4.95252 11.5316 5.3578 11.6472 5.71215 11.8784C6.06871 12.1073 6.34886 12.426 6.55261 12.8347C6.75857 13.2411 6.86155 13.7105 6.86155 14.2429C6.86155 14.6143 6.80619 14.9704 6.69545 15.3113C6.58472 15.65 6.40533 15.9524 6.15729 16.2186C5.90925 16.4849 5.58037 16.695 5.17066 16.8492C4.76317 17.0033 4.26376 17.0804 3.67245 17.0804C3.07449 17.0804 2.56955 17.001 2.15762 16.8422C1.74791 16.681 1.41792 16.4615 1.16767 16.1836C0.919625 15.9034 0.73913 15.5846 0.626182 15.2273C0.515449 14.8676 0.460083 14.4893 0.460083 14.0923C0.460083 13.7116 0.505484 13.359 0.596285 13.0344C0.687086 12.7098 0.814428 12.4202 0.978313 12.1657C1.1422 11.9111 1.33155 11.6998 1.54637 11.5316L2.33701 12.2392C2.19084 12.3957 2.06571 12.5673 1.96162 12.7542C1.85975 12.9387 1.78113 13.1418 1.72576 13.3637C1.67261 13.5855 1.64382 13.8284 1.63939 14.0923C1.63939 14.4473 1.7014 14.7731 1.82542 15.0696C1.95166 15.3639 2.16205 15.5998 2.4566 15.7772C2.75336 15.9524 3.15864 16.04 3.67245 16.04C4.15967 16.04 4.55056 15.9594 4.84511 15.7983C5.14187 15.6371 5.3578 15.4211 5.4929 15.1502C5.62799 14.877 5.69554 14.5746 5.69554 14.2429C5.69111 13.9253 5.64238 13.6393 5.54937 13.3847C5.45635 13.1301 5.32569 12.9281 5.15737 12.7787C4.99127 12.6292 4.79306 12.5545 4.56274 12.5545C4.44315 12.5545 4.35235 12.5977 4.29034 12.6841C4.22832 12.7682 4.19732 12.8768 4.19732 13.0099V19H3.05788Z" fill="white"/><path d="M13.0339 8V7.22543L15.0424 5.21098C15.2345 5.01252 15.3945 4.83622 15.5226 4.68208C15.6507 4.52794 15.7467 4.37861 15.8107 4.2341C15.8748 4.0896 15.9068 3.93545 15.9068 3.77168C15.9068 3.58478 15.8653 3.42486 15.7825 3.29191C15.6996 3.15703 15.5857 3.05299 15.4407 2.97977C15.2957 2.90655 15.1309 2.86994 14.9463 2.86994C14.7561 2.86994 14.5895 2.9104 14.4463 2.99133C14.3032 3.07033 14.1921 3.18304 14.113 3.32948C14.0358 3.47592 13.9972 3.65029 13.9972 3.8526H13C13 3.47688 13.0838 3.15029 13.2514 2.87283C13.419 2.59538 13.6497 2.38054 13.9435 2.22832C14.2392 2.07611 14.5782 2 14.9605 2C15.3484 2 15.6893 2.07418 15.9831 2.22254C16.2768 2.37091 16.5047 2.57418 16.6667 2.83237C16.8305 3.09056 16.9124 3.38536 16.9124 3.71676C16.9124 3.93834 16.871 4.15607 16.7881 4.36994C16.7053 4.58382 16.5593 4.82081 16.3503 5.08093C16.1431 5.34104 15.8522 5.65607 15.4774 6.02601L14.4802 7.06358V7.10405H17V8H13.0339Z" fill="white"/><path d="M17 2.38419e-07V1L11.9544 1L11 8H10L8 3.3811L8.91932 2.98759L10.2404 6.17006L11.0812 0.0021975L11.0867 0.00294638V0L17 2.38419e-07Z" fill="white"/><path d="M13.6064 17.0714C13.0675 17.0714 12.6022 16.9504 12.2103 16.7082C11.8207 16.4636 11.521 16.1181 11.3111 15.6717C11.1011 15.2227 10.9962 14.6944 10.9962 14.0865C10.9962 13.4888 11.1011 12.9642 11.3111 12.5128C11.5233 12.0588 11.8196 11.7057 12.1998 11.4535C12.58 11.1988 13.0267 11.0714 13.5399 11.0714C13.8711 11.0714 14.1837 11.1294 14.4776 11.2454C14.7739 11.3589 15.0351 11.5355 15.2614 11.7751C15.49 12.0147 15.6696 12.3198 15.8002 12.6906C15.9308 13.0588 15.9962 13.4976 15.9962 14.0071V14.427H11.591V13.5039H14.782C14.7797 13.2417 14.7272 13.0084 14.6246 12.8041C14.5219 12.5973 14.3785 12.4346 14.1942 12.3161C14.0122 12.1975 13.8 12.1382 13.5574 12.1382C13.2985 12.1382 13.071 12.2063 12.8751 12.3425C12.6791 12.4762 12.5264 12.6527 12.4167 12.8722C12.3094 13.0891 12.2546 13.3274 12.2523 13.5872V14.393C12.2523 14.7309 12.3094 15.021 12.4237 15.2631C12.538 15.5027 12.6978 15.6868 12.9031 15.8154C13.1084 15.9415 13.3486 16.0046 13.6239 16.0046C13.8081 16.0046 13.9749 15.9768 14.1242 15.9213C14.2735 15.8633 14.403 15.7789 14.5126 15.6679C14.6222 15.5569 14.705 15.4195 14.761 15.2555L15.9437 15.3993C15.869 15.7372 15.7267 16.0323 15.5168 16.2845C15.3092 16.5342 15.0433 16.7284 14.719 16.8671C14.3948 17.0033 14.0239 17.0714 13.6064 17.0714Z" fill="white"/><path d="M5.94385 2V3.03274H0.460083V2H5.94385ZM2.44478 2V7.62512H1.26397V2H2.44478ZM3.96916 2H5.14664V5.98812C5.14664 6.14682 5.16999 6.26767 5.21668 6.35068C5.26338 6.43369 5.32787 6.49106 5.41015 6.5228C5.49243 6.5521 5.58805 6.56675 5.69701 6.56675C5.77485 6.56675 5.84934 6.56187 5.9205 6.5521C5.99166 6.54233 6.05059 6.53257 6.09729 6.5228V7.5592C5.99722 7.59094 5.88047 7.62024 5.74705 7.64709C5.61585 7.67639 5.46908 7.69104 5.30675 7.69104C4.90202 7.69104 4.57736 7.57019 4.33274 7.32848C4.09036 7.08678 3.96916 6.68028 3.96916 6.10897V2Z" fill="white"/></svg>';
const iconDateTime          = '<svg width="18" height="21" viewBox="0 -3 18 21" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="4" width="2" height="2" fill="white"/><rect x="2" y="7" width="2" height="2" fill="white"/><rect x="2" y="10" width="2" height="2" fill="white"/><rect x="5" y="4" width="2" height="2" fill="white"/><rect x="5" y="7" width="2" height="2" fill="white"/><rect x="5" y="10" width="2" height="2" fill="white"/><rect x="8" y="4" width="2" height="2" fill="white"/><rect x="11" y="4" width="2" height="2" fill="white"/><path d="M13 8H12V13H16V12H13V8Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M3 0H2V1H0V14H7.20703C7.85996 16.3085 9.98245 18 12.5 18C15.5376 18 18 15.5376 18 12.5C18 10.3627 16.7808 8.51007 15 7.59971V1H13V0H12V1H3V0ZM2 2V3H3V2H12V3H13V2H14V7.20703C13.5232 7.07217 13.02 7 12.5 7C11.5998 7 10.7501 7.21628 10 7.59971V7H8V9H8.25716C7.47182 9.95094 7 11.1704 7 12.5C7 12.6685 7.00758 12.8353 7.02242 13H1V2H2ZM12.5 17C14.9853 17 17 14.9853 17 12.5C17 10.0147 14.9853 8 12.5 8C10.0147 8 8 10.0147 8 12.5C8 14.9853 10.0147 17 12.5 17Z" fill="white"/></svg>';
const iconArray             = '<svg width="17" height="11" viewBox="0 -3 17 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.48667 0.0807575V5.98759H1.30863V1.26616H1.27598L0 2.11412V1.00658L1.37937 0.0807575H2.48667Z" fill="white"/><path d="M5.83103 5.98759V5.08772L7.81438 3.14089C7.98306 2.96784 8.12454 2.81209 8.2388 2.67365C8.35489 2.53521 8.44285 2.39965 8.50271 2.26698C8.56256 2.13238 8.59249 1.98721 8.59249 1.83146C8.59249 1.65841 8.55531 1.5094 8.48094 1.38441C8.40658 1.25751 8.30501 1.16041 8.17623 1.09311C8.04745 1.02389 7.90144 0.989279 7.73821 0.989279C7.56771 0.989279 7.41898 1.02581 7.29202 1.09888C7.16505 1.17194 7.06711 1.27674 6.99819 1.41326C6.92927 1.54977 6.8948 1.71225 6.8948 1.90068H5.77662C5.77662 1.5142 5.85914 1.17867 6.0242 0.894101C6.18925 0.609527 6.4205 0.389366 6.71796 0.23362C7.01542 0.0778732 7.35822 0 7.74637 0C8.1454 0 8.49273 0.0749891 8.78838 0.224967C9.08583 0.373023 9.31709 0.578762 9.48214 0.842185C9.64719 1.10561 9.72972 1.40749 9.72972 1.74782C9.72972 1.97087 9.688 2.19103 9.60457 2.4083C9.52295 2.62558 9.37694 2.86689 9.16655 3.13224C8.95615 3.39566 8.6596 3.71196 8.27689 4.08114L7.46342 4.92621V4.96658H9.80318V5.98759H5.83103Z" fill="white"/><path d="M14.8561 6.06835C14.4498 6.06835 14.088 5.99432 13.7706 5.84626C13.455 5.69629 13.2056 5.49055 13.0224 5.22905C12.841 4.96562 12.7476 4.66182 12.7422 4.31764H13.9284C13.9356 4.46185 13.9801 4.58875 14.0617 4.69835C14.1451 4.80603 14.2557 4.88967 14.3936 4.94928C14.5314 5.00889 14.6865 5.03869 14.8588 5.03869C15.0384 5.03869 15.1971 5.00504 15.3349 4.93774C15.4728 4.87044 15.5807 4.77719 15.6587 4.65798C15.7367 4.53876 15.7757 4.40128 15.7757 4.24554C15.7757 4.08787 15.734 3.94846 15.6505 3.82733C15.5689 3.70427 15.451 3.60813 15.2968 3.53891C15.1445 3.46969 14.9631 3.43508 14.7527 3.43508H14.2331V2.5179H14.7527C14.9305 2.5179 15.0874 2.48522 15.2234 2.41984C15.3612 2.35446 15.4682 2.26409 15.5444 2.14873C15.6206 2.03144 15.6587 1.89492 15.6587 1.73917C15.6587 1.59111 15.6251 1.46133 15.558 1.3498C15.4927 1.23636 15.4002 1.14791 15.2805 1.08446C15.1626 1.02101 15.0248 0.989279 14.867 0.989279C14.7074 0.989279 14.5614 1.02004 14.429 1.08157C14.2966 1.14118 14.1905 1.22674 14.1106 1.33827C14.0308 1.44979 13.9882 1.58054 13.9828 1.73052H12.8537C12.8591 1.39018 12.9507 1.09023 13.1285 0.830648C13.3062 0.571071 13.5457 0.368216 13.8467 0.222083C14.1496 0.0740277 14.4915 0 14.8724 0C15.2569 0 15.5934 0.0740277 15.8818 0.222083C16.1702 0.370138 16.3942 0.570109 16.5538 0.821996C16.7152 1.07196 16.795 1.35269 16.7932 1.66418C16.795 1.9949 16.698 2.27082 16.5021 2.49194C16.308 2.71307 16.055 2.85343 15.743 2.91304V2.95918C16.1529 3.01495 16.4649 3.16589 16.6789 3.412C16.8948 3.6562 17.0018 3.96192 17 4.32918C17.0018 4.66567 16.9102 4.96466 16.7252 5.22616C16.542 5.48766 16.289 5.6934 15.9661 5.84338C15.6433 5.99336 15.2733 6.06835 14.8561 6.06835Z" fill="white"/><path d="M4.86855 5.17999L4.8254 5.56683C4.79141 5.8763 4.72604 6.1846 4.62929 6.49173C4.53516 6.8012 4.4358 7.08137 4.33121 7.33223C4.22923 7.58309 4.14686 7.78002 4.08411 7.92303H3.00159C3.04081 7.78471 3.09441 7.59129 3.1624 7.34278C3.23038 7.09661 3.29444 6.81996 3.35458 6.51283C3.41472 6.2057 3.45264 5.89271 3.46833 5.57387L3.48794 5.17999H4.86855Z" fill="white"/><path d="M12.1554 5.17999L12.1123 5.56683C12.0783 5.8763 12.0129 6.1846 11.9162 6.49173C11.822 6.8012 11.7227 7.08137 11.6181 7.33223C11.5161 7.58309 11.4337 7.78002 11.371 7.92303H10.2885C10.3277 7.78471 10.3813 7.59129 10.4493 7.34278C10.5172 7.09661 10.5813 6.81996 10.6414 6.51283C10.7016 6.2057 10.7395 5.89271 10.7552 5.57387L10.7748 5.17999H12.1554Z" fill="white"/></svg>';
const iconSequence          = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="12" width="1" height="4" fill="white"/><rect x="5" y="8" width="1" height="4" fill="white"/><rect x="10" y="4" width="1" height="4" fill="white"/><rect x="15" width="1" height="4" fill="white"/></svg>';
const iconRange        = '<svg width="17" height="11" viewBox="0 0 17 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="16" width="1" height="11" fill="white"/><rect width="1" height="11" fill="white"/><rect x="8" y="4" width="1" height="3" fill="white"/><rect x="4" y="4" width="1" height="3" fill="white"/><rect x="12" y="4" width="1" height="3" fill="white"/></svg>';
const iconRandom            = '<svg width="7" height="11" viewBox="0 0 7 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.57613 7.88313V7.82014C2.58313 7.15175 2.65312 6.61983 2.7861 6.22439C2.91908 5.82895 3.10805 5.50875 3.35302 5.26379C3.59798 5.01883 3.89193 4.79311 4.23488 4.58664C4.44135 4.46066 4.62682 4.31193 4.79129 4.14046C4.95577 3.96549 5.08525 3.76427 5.17973 3.5368C5.27772 3.30934 5.32671 3.05738 5.32671 2.78092C5.32671 2.43797 5.24622 2.14052 5.08525 1.88856C4.92427 1.6366 4.70906 1.44238 4.4396 1.3059C4.17014 1.16942 3.87094 1.10118 3.54199 1.10118C3.25503 1.10118 2.97857 1.16067 2.71261 1.27965C2.44665 1.39863 2.22444 1.58585 2.04597 1.84131C1.86749 2.09677 1.76426 2.43097 1.73626 2.84391H0.413467C0.441463 2.249 0.595439 1.73983 0.875396 1.31639C1.15885 0.89296 1.53155 0.56926 1.99347 0.345294C2.4589 0.121329 2.97507 0.00934601 3.54199 0.00934601C4.15789 0.00934601 4.69331 0.131827 5.14824 0.376789C5.60667 0.621752 5.96011 0.9577 6.20858 1.38463C6.46054 1.81157 6.58652 2.29799 6.58652 2.84391C6.58652 3.22885 6.52703 3.57705 6.40804 3.8885C6.29256 4.19995 6.12459 4.47816 5.90412 4.72312C5.68716 4.96808 5.4247 5.18505 5.11674 5.37402C4.80879 5.56649 4.56208 5.76946 4.37661 5.98293C4.19114 6.19289 4.05641 6.44311 3.97242 6.73356C3.88843 7.02402 3.84294 7.38621 3.83594 7.82014V7.88313H2.57613ZM3.24803 10.9907C2.98907 10.9907 2.76686 10.8979 2.58138 10.7124C2.39591 10.527 2.30318 10.3048 2.30318 10.0458C2.30318 9.78684 2.39591 9.56463 2.58138 9.37915C2.76686 9.19368 2.98907 9.10095 3.24803 9.10095C3.50699 9.10095 3.72921 9.19368 3.91468 9.37915C4.10015 9.56463 4.19289 9.78684 4.19289 10.0458C4.19289 10.2173 4.14914 10.3748 4.06166 10.5182C3.97767 10.6617 3.86394 10.7772 3.72046 10.8647C3.58048 10.9487 3.423 10.9907 3.24803 10.9907Z" fill="white"/></svg>';
const iconNoise             = '<svg width="16" height="9" viewBox="0 0 16 9" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="1" cy="8" r="1" fill="white"/><circle cx="3" cy="5" r="1" fill="white"/><circle cx="5" cy="3" r="1" fill="white"/><circle cx="7" cy="6" r="1" fill="white"/><circle cx="9" cy="1" r="1" fill="white"/><circle cx="11" cy="4" r="1" fill="white"/><circle cx="13" cy="2" r="1" fill="white"/><circle cx="15" cy="8" r="1" fill="white"/></svg>';
const iconProbability       = '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.4802 4C11.0324 4 11.4802 3.55228 11.4802 3C11.4802 2.44772 11.0324 2 10.4802 2C9.92788 2 9.48016 2.44772 9.48016 3C9.48016 3.55228 9.92788 4 10.4802 4Z" fill="white"/><path d="M10.4802 6.5C11.0324 6.5 11.4802 6.05228 11.4802 5.5C11.4802 4.94772 11.0324 4.5 10.4802 4.5C9.92788 4.5 9.48016 4.94772 9.48016 5.5C9.48016 6.05228 9.92788 6.5 10.4802 6.5Z" fill="white"/><path d="M14.5198 9C15.0721 9 15.5198 8.55229 15.5198 8C15.5198 7.44772 15.0721 7 14.5198 7C13.9676 7 13.5198 7.44772 13.5198 8C13.5198 8.55229 13.9676 9 14.5198 9Z" fill="white"/><path d="M15.5198 5.5C15.5198 6.05228 15.0721 6.5 14.5198 6.5C13.9676 6.5 13.5198 6.05228 13.5198 5.5C13.5198 4.94772 13.9676 4.5 14.5198 4.5C15.0721 4.5 15.5198 4.94772 15.5198 5.5Z" fill="white"/><path d="M14.5198 4C15.0721 4 15.5198 3.55228 15.5198 3C15.5198 2.44772 15.0721 2 14.5198 2C13.9676 2 13.5198 2.44772 13.5198 3C13.5198 3.55228 13.9676 4 14.5198 4Z" fill="white"/><path d="M7.5 11.5C8.05229 11.5 8.5 11.0523 8.5 10.5C8.5 9.94771 8.05229 9.5 7.5 9.5C6.94772 9.5 6.5 9.94771 6.5 10.5C6.5 11.0523 6.94772 11.5 7.5 11.5Z" fill="white"/><path d="M8.5 14.5C8.5 15.0523 8.05229 15.5 7.5 15.5C6.94772 15.5 6.5 15.0523 6.5 14.5C6.5 13.9477 6.94772 13.5 7.5 13.5C8.05229 13.5 8.5 13.9477 8.5 14.5Z" fill="white"/><path d="M3.5 15.5C4.05228 15.5 4.5 15.0523 4.5 14.5C4.5 13.9477 4.05228 13.5 3.5 13.5C2.94772 13.5 2.5 13.9477 2.5 14.5C2.5 15.0523 2.94772 15.5 3.5 15.5Z" fill="white"/><path d="M4.5 10.5C4.5 11.0523 4.05228 11.5 3.5 11.5C2.94772 11.5 2.5 11.0523 2.5 10.5C2.5 9.94771 2.94772 9.5 3.5 9.5C4.05228 9.5 4.5 9.94771 4.5 10.5Z" fill="white"/><path d="M6.5 12.5C6.5 13.0523 6.05228 13.5 5.5 13.5C4.94772 13.5 4.5 13.0523 4.5 12.5C4.5 11.9477 4.94772 11.5 5.5 11.5C6.05228 11.5 6.5 11.9477 6.5 12.5Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7.00079 1.50079C7.00079 0.672366 7.67237 0.000793457 8.50079 0.000793457H16.4992C17.3276 0.000793457 17.9992 0.672366 17.9992 1.50079V9.49921C17.9992 10.3276 17.3276 10.9992 16.4992 10.9992H11V17C11 17.5523 10.5523 18 10 18H1C0.447715 18 0 17.5523 0 17V8C0 7.44771 0.447715 7 1 7H7.00079V1.50079ZM16.4992 9.99921H11V8.85427L11.0082 8.8492C11.1667 8.75064 11.2945 8.60969 11.377 8.44229C11.4596 8.27489 11.4936 8.08773 11.4753 7.90198C11.4571 7.71624 11.3871 7.53932 11.2735 7.39124C11.1599 7.24316 11.0071 7.12984 10.8324 7.06409C10.6577 6.99835 10.4681 6.9828 10.2851 7.01921C10.2701 7.02218 10.2553 7.02549 10.2406 7.02913C10.1635 7.0101 10.0829 7 10 7H8.00079V1.50079C8.00079 1.22465 8.22465 1.00079 8.50079 1.00079H16.4992C16.7753 1.00079 16.9992 1.22465 16.9992 1.50079V9.49921C16.9992 9.77535 16.7753 9.99921 16.4992 9.99921ZM10 8H1L1 17H10V8Z" fill="white"/></svg>';
const iconAccumulate        = '<svg width="16" height="11" viewBox="0 0 16 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="9" width="1" height="2" fill="white"/><rect x="5" y="6" width="1" height="5" fill="white"/><rect x="10" y="3" width="1" height="8" fill="white"/><rect x="15" width="1" height="11" fill="white"/></svg>';
const iconInterpolate       = '<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.52103 8.3389L8.95824 8.95823L8.35357 6.50635L9.47656 5.38337L10.189 8.81096L13.6401 9.5L12.523 10.6171L10.0795 10.0795L10.6259 12.5142L9.50001 13.6401L8.80218 10.1978L5.39511 9.46482L6.52103 8.3389Z" fill="white"/><rect x="7.5874" y="10.7054" width="1" height="7.09972" transform="rotate(45 7.5874 10.7054)" fill="white"/><rect x="4.39026" y="18.2929" width="1" height="5.20878" transform="rotate(135 4.39026 18.2929)" fill="white"/><rect x="11.3986" y="8.30853" width="1" height="7.11945" transform="rotate(-135 11.3986 8.30853)" fill="white"/><rect x="14.6097" y="0.707092" width="1" height="5.20878" transform="rotate(-45 14.6097 0.707092)" fill="white"/></svg>';
const iconSolve             = '<svg width="18" height="14" viewBox="-4 0 18 14" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="5.5" cy="5.5" r="5" stroke="white"/><rect x="9.44473" y="8.55527" width="6.21958" height="1.25789" transform="rotate(45 9.44473 8.55527)" fill="white"/><path d="M4.40227 3L5.5 4.8457L6.61544 3H7.97167L6.33215 5.5L8 8H6.65085L5.5 6.19987L4.35977 8H3L4.65722 5.5L3.04249 3H4.40227Z" fill="white"/></svg>';
const iconAnimate           = '<svg width="9" height="13" viewBox="0 0 9 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 13V0L9 6.5L0 13Z" fill="white"/></svg>';
 
const iconMath              = '<svg width="17" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.138 6.57967V0.485922H13.1039V6.57967H14.138ZM16.6678 4.04984V3.01575H10.5741V4.04984H16.6678Z" fill="white"/><path d="M11.3681 15.5004L16.5755 10.293L15.8738 9.59129L10.6664 14.7987L11.3681 15.5004ZM15.8738 15.5004L16.5755 14.7987L11.3681 9.59129L10.6664 10.293L15.8738 15.5004Z" fill="white"/><path d="M0.576652 12.0288V13.0629H6.48574V12.0288H0.576652ZM3.5312 15.7589C3.76202 15.7589 3.95899 15.6789 4.12211 15.5188C4.28214 15.3557 4.36216 15.1588 4.36216 14.9279C4.36216 14.7063 4.28214 14.5155 4.12211 14.3555C3.95899 14.1955 3.76202 14.1154 3.5312 14.1154C3.30961 14.1154 3.11879 14.1955 2.95875 14.3555C2.79872 14.5155 2.7187 14.7063 2.7187 14.9279C2.7187 15.1588 2.79872 15.3557 2.95875 15.5188C3.11879 15.6789 3.30961 15.7589 3.5312 15.7589ZM3.5312 10.9762C3.68508 10.9762 3.82511 10.9393 3.9513 10.8654C4.07748 10.7916 4.1775 10.6915 4.25137 10.5654C4.32523 10.4392 4.36216 10.2991 4.36216 10.1453C4.36216 9.92367 4.28214 9.73286 4.12211 9.57282C3.95899 9.41278 3.76202 9.33276 3.5312 9.33276C3.30961 9.33276 3.11879 9.41278 2.95875 9.57282C2.79872 9.73286 2.7187 9.92367 2.7187 10.1453C2.7187 10.3761 2.79872 10.5731 2.95875 10.7362C3.11879 10.8962 3.30961 10.9762 3.5312 10.9762Z" fill="white"/><path d="M0.576652 3.01575V4.04984H6.48574V3.01575H0.576652Z" fill="white"/></svg>';
const iconAdd               = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.78932 10.1318V0.756822H6.38023V10.1318H4.78932ZM0.897271 6.23978V4.64887H10.2723V6.23978H0.897271Z" fill="white"/></svg>';
const iconSubtract          = '<svg width="10" height="3" viewBox="0 0 10 3" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.13022 0.648869V2.23978H0.0393143V0.648869H9.13022Z" fill="white"/></svg>';
const iconMultiply          = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.05068 9.98978L0.0393206 1.97841L1.11887 0.898868L9.13023 8.91023L8.05068 9.98978ZM1.11887 9.98978L0.0393206 8.91023L8.05068 0.898868L9.13023 1.97841L1.11887 9.98978Z" fill="white"/></svg>';
const iconDivide            = '<svg width="11" height="12" viewBox="0 0 11 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.1054 1.42632L2.05001 11.9731L0.832778 11.1289L8.88819 0.582087L10.1054 1.42632Z" fill="white"/></svg>';
const iconExponent          = '<svg width="15" height="14" viewBox="-2 0 15 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.24574 13.6818C3.40483 13.6818 2.67945 13.4962 2.0696 13.125C1.46354 12.75 0.995739 12.2273 0.666193 11.5568C0.340436 10.8826 0.177557 10.0985 0.177557 9.20455C0.177557 8.31061 0.340436 7.52273 0.666193 6.84091C0.995739 6.1553 1.45407 5.62121 2.04119 5.23864C2.6321 4.85227 3.3215 4.65909 4.10938 4.65909C4.56392 4.65909 5.01278 4.73485 5.45597 4.88636C5.89915 5.03788 6.30256 5.28409 6.66619 5.625C7.02983 5.96212 7.3196 6.40909 7.53551 6.96591C7.75142 7.52273 7.85938 8.20833 7.85938 9.02273V9.59091H1.1321V8.43182H6.49574C6.49574 7.93939 6.39725 7.5 6.20028 7.11364C6.0071 6.72727 5.73059 6.42235 5.37074 6.19886C5.01468 5.97538 4.59422 5.86364 4.10938 5.86364C3.57528 5.86364 3.11316 5.99621 2.72301 6.26136C2.33665 6.52273 2.0393 6.86364 1.83097 7.28409C1.62263 7.70455 1.51847 8.1553 1.51847 8.63636V9.40909C1.51847 10.0682 1.6321 10.6269 1.85938 11.0852C2.09044 11.5398 2.41051 11.8864 2.8196 12.125C3.22869 12.3598 3.70407 12.4773 4.24574 12.4773C4.59801 12.4773 4.91619 12.428 5.20028 12.3295C5.48816 12.2273 5.73627 12.0758 5.9446 11.875C6.15294 11.6705 6.31392 11.4167 6.42756 11.1136L7.72301 11.4773C7.58665 11.9167 7.35748 12.303 7.03551 12.6364C6.71354 12.9659 6.31581 13.2235 5.84233 13.4091C5.36884 13.5909 4.83665 13.6818 4.24574 13.6818Z" fill="white"/><path d="M9.39205 0.545454L10.6989 2.77557L12.0057 0.545454H12.9716L11.2102 3.27273L12.9716 6H12.0057L10.6989 3.88352L9.39205 6H8.42614L10.1591 3.27273L8.42614 0.545454H9.39205Z" fill="white"/></svg>';
const iconModulo            = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.07556 8.75853V8.21776C6.07556 7.8439 6.15233 7.50175 6.30588 7.19131C6.46277 6.87753 6.68976 6.62718 6.98685 6.44024C7.28728 6.24997 7.65113 6.15484 8.0784 6.15484C8.51235 6.15484 8.8762 6.24997 9.16995 6.44024C9.4637 6.62718 9.68568 6.87753 9.83589 7.19131C9.9861 7.50175 10.0612 7.8439 10.0612 8.21776V8.75853C10.0612 9.1324 9.98444 9.47622 9.83088 9.78999C9.68067 10.1004 9.45702 10.3508 9.15993 10.5411C8.86618 10.728 8.50567 10.8215 8.0784 10.8215C7.64445 10.8215 7.27893 10.728 6.98184 10.5411C6.68475 10.3508 6.45943 10.1004 6.30588 9.78999C6.15233 9.47622 6.07556 9.1324 6.07556 8.75853ZM7.09701 8.21776V8.75853C7.09701 9.06897 7.17044 9.3477 7.31732 9.59472C7.46419 9.8384 7.71789 9.96024 8.0784 9.96024C8.4289 9.96024 8.67591 9.8384 8.81945 9.59472C8.96632 9.3477 9.03976 9.06897 9.03976 8.75853V8.21776C9.03976 7.90732 8.96966 7.63026 8.82946 7.38659C8.68926 7.13957 8.43891 7.01606 8.0784 7.01606C7.7279 7.01606 7.47588 7.13957 7.32233 7.38659C7.17211 7.63026 7.09701 7.90732 7.09701 8.21776ZM0.968313 2.89021V2.34944C0.968313 1.97558 1.04509 1.63342 1.19864 1.32298C1.35553 1.00921 1.58252 0.758851 1.87961 0.571919C2.18003 0.381649 2.54388 0.286514 2.97115 0.286514C3.4051 0.286514 3.76895 0.381649 4.0627 0.571919C4.35645 0.758851 4.57843 1.00921 4.72865 1.32298C4.87886 1.63342 4.95397 1.97558 4.95397 2.34944V2.89021C4.95397 3.26407 4.87719 3.60789 4.72364 3.92167C4.57343 4.23211 4.34978 4.48247 4.05269 4.67274C3.75894 4.85967 3.39843 4.95313 2.97115 4.95313C2.5372 4.95313 2.17169 4.85967 1.8746 4.67274C1.57751 4.48247 1.35219 4.23211 1.19864 3.92167C1.04509 3.60789 0.968313 3.26407 0.968313 2.89021ZM1.98976 2.34944V2.89021C1.98976 3.20065 2.0632 3.47938 2.21007 3.72639C2.35695 3.97007 2.61064 4.09191 2.97115 4.09191C3.32165 4.09191 3.56867 3.97007 3.7122 3.72639C3.85908 3.47938 3.93252 3.20065 3.93252 2.89021V2.34944C3.93252 2.039 3.86242 1.76194 3.72222 1.51826C3.58202 1.27124 3.33167 1.14774 2.97115 1.14774C2.62066 1.14774 2.36863 1.27124 2.21508 1.51826C2.06487 1.76194 1.98976 2.039 1.98976 2.34944ZM1.34885 10.6813L8.39885 0.426713H9.54047L2.49047 10.6813H1.34885Z" fill="white"/></svg>';

const iconBoolean           = '<svg width="13" height="16" viewBox="0 0 13 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.28269 9.19418V15.0124H2.05257V10.3618H2.01848L0.686096 11.197V10.1061L2.12644 9.19418H3.28269Z" fill="white"/><path d="M2.53269 6.02495C2.04405 6.02306 1.6236 5.90279 1.27132 5.66416C0.920945 5.42552 0.651058 5.07988 0.461664 4.62722C0.274164 4.17457 0.181361 3.63006 0.183255 2.9937C0.183255 2.35923 0.277005 1.81851 0.464505 1.37154C0.653899 0.924572 0.923786 0.58461 1.27416 0.351655C1.62644 0.116807 2.04594 -0.000617504 2.53269 -0.000617504C3.01943 -0.000617504 3.43799 0.116807 3.78837 0.351655C4.14064 0.586504 4.41148 0.927413 4.60087 1.37438C4.79026 1.81946 4.88401 2.35923 4.88212 2.9937C4.88212 3.63196 4.78742 4.17741 4.59803 4.63006C4.41053 5.08272 4.14159 5.42836 3.79121 5.667C3.44083 5.90563 3.02132 6.02495 2.53269 6.02495ZM2.53269 5.00506C2.86602 5.00506 3.13212 4.83745 3.33098 4.50222C3.52985 4.167 3.62833 3.66416 3.62644 2.9937C3.62644 2.55241 3.58098 2.18499 3.49007 1.89143C3.40106 1.59787 3.27416 1.37722 3.10939 1.2295C2.94651 1.08177 2.75428 1.00791 2.53269 1.00791C2.20125 1.00791 1.9361 1.17363 1.73723 1.50506C1.53837 1.8365 1.43799 2.33272 1.4361 2.9937C1.4361 3.44067 1.4806 3.81378 1.56962 4.11302C1.66053 4.41037 1.78837 4.63385 1.95314 4.78347C2.11791 4.9312 2.3111 5.00506 2.53269 5.00506Z" fill="white"/><path d="M9.87382 15.0638C9.38518 15.0619 8.96473 14.9416 8.61246 14.703C8.26208 14.4643 7.99219 14.1187 7.8028 13.666C7.6153 13.2134 7.52249 12.6689 7.52439 12.0325C7.52439 11.398 7.61814 10.8573 7.80564 10.4104C7.99503 9.96339 8.26492 9.62343 8.6153 9.39047C8.96757 9.15563 9.38708 9.0382 9.87382 9.0382C10.3606 9.0382 10.7791 9.15563 11.1295 9.39047C11.4818 9.62532 11.7526 9.96623 11.942 10.4132C12.1314 10.8583 12.2251 11.398 12.2233 12.0325C12.2233 12.6708 12.1286 13.2162 11.9392 13.6689C11.7517 14.1215 11.4827 14.4672 11.1323 14.7058C10.782 14.9445 10.3625 15.0638 9.87382 15.0638ZM9.87382 14.0439C10.2072 14.0439 10.4733 13.8763 10.6721 13.541C10.871 13.2058 10.9695 12.703 10.9676 12.0325C10.9676 11.5912 10.9221 11.2238 10.8312 10.9302C10.7422 10.6367 10.6153 10.416 10.4505 10.2683C10.2876 10.1206 10.0954 10.0467 9.87382 10.0467C9.54238 10.0467 9.27723 10.2124 9.07837 10.5439C8.8795 10.8753 8.77912 11.3715 8.77723 12.0325C8.77723 12.4795 8.82174 12.8526 8.91075 13.1518C9.00166 13.4492 9.1295 13.6727 9.29427 13.8223C9.45905 13.97 9.65223 14.0439 9.87382 14.0439Z" fill="white"/><path d="M11.0028 0.181818V6H9.77273V1.34943H9.73864L8.40625 2.18466V1.09375L9.84659 0.181818H11.0028Z" fill="white"/></svg>';
const iconNot               = '<svg width="8" height="4" viewBox="0 0 8 4" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 0V1.59459H0V0H8ZM8 0.729729V4H6.08298V0.729729H8Z" fill="white"/></svg>';
const iconAnd               = '<svg width="9" height="9" viewBox="0 -1 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.93182 2.15577e-07L3.65909 1.59944e-07L-3.29822e-07 7.54545L1.73295 7.54546L4.27273 1.97727L4.17045 2.02841L4.41477 2.02841L4.31818 1.97727L6.85227 7.54546L8.59091 7.54546L4.93182 2.15577e-07Z" fill="white"/></svg>';
const iconOr                = '<svg width="9" height="9" viewBox="0 -1 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.93182 7.54546L3.65909 7.54546L-3.29822e-07 9.53674e-07L1.73295 8.77924e-07L4.27273 5.56818L4.17045 5.51705L4.41477 5.51705L4.31818 5.56818L6.85227 6.54152e-07L8.59091 5.78154e-07L4.93182 7.54546Z" fill="white"/></svg>';
const iconXor               = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 10.2363C8.11581 10.2363 10.2363 8.11581 10.2363 5.5C10.2363 2.88419 8.11581 0.763657 5.5 0.763657C2.88419 0.763657 0.763657 2.88419 0.763657 5.5C0.763657 8.11581 2.88419 10.2363 5.5 10.2363ZM5.5 9C7.433 9 9 7.433 9 5.5C9 3.567 7.433 2 5.5 2C3.567 2 2 3.567 2 5.5C2 7.433 3.567 9 5.5 9Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9 6L2 6L2 5L9 5V6Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 2L6 9L5 9L5 2L6 2Z" fill="white"/></svg>';
 
const iconCondition         = '<svg width="17" height="17" viewBox="0 0 17 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.53875 4.35405L15.9422 7.61541V6.34268L11.0302 3.97621L11.07 4.05575V3.85689L11.0302 3.93643L15.9422 1.56996V0.29723L9.53875 3.55859V4.35405Z" fill="white"/><path d="M13.5986 9.37666H15.1207L12.1775 16.6948H10.6554L13.5986 9.37666ZM9.87942 12.1011V11.0272H16.0044V12.1011H9.87942ZM9.87942 15.0443V13.9704H16.0044V15.0443H9.87942Z" fill="white"/><path d="M7.29069 13.4335V12.638L0.887281 9.37667V10.6494L5.79921 13.0159L5.75944 12.9363V13.1352L5.79921 13.0556L0.887281 15.4221V16.6948L7.29069 13.4335Z" fill="white"/><path d="M6.67738 3.02166V1.9478H0.552379V3.02166H6.67738ZM6.67738 5.96484V4.89098H0.552379V5.96484H6.67738Z" fill="white"/></svg>';
const iconEqual             = '<svg width="9" height="7" viewBox="0 0 9 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.78409 1.98295V0.448863H0.03409V1.98295H8.78409ZM8.78409 6.1875V4.65341H0.03409V6.1875H8.78409Z" fill="white"/></svg>';
const iconNotEqual          = '<svg width="9" height="11" viewBox="0 0 9 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.89773 0.0909088H7.48864L3.28409 10.5455H1.69318L5.89773 0.0909088ZM0.215909 3.98295V2.44886H8.96591V3.98295H0.215909ZM0.215909 8.1875V6.65341H8.96591V8.1875H0.215909Z" fill="white"/></svg>';
const iconLess              = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.0170455 5.88636V4.75L9.16477 0.0909088V1.90909L2.14773 5.28977L2.20455 5.17614V5.46023L2.14773 5.34659L9.16477 8.72727V10.5455L0.0170455 5.88636Z" fill="white"/></svg>';
const iconLessOrEqual       = '<svg width="10" height="12" viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.16477 11.3182H0.0170455V9.72727H9.16477V11.3182ZM0.0170455 5.29545V4.15909L9.16477 0.863636V2.59659L2.77273 4.69886L2.82955 4.58523V4.86932L2.77273 4.75568L9.16477 6.85795V8.59091L0.0170455 5.29545Z" fill="white"/></svg>';
const iconGreater           = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.16477 5.88636L0.0170455 10.5455V8.72727L7.03409 5.34659L6.97727 5.46023V5.17614L7.03409 5.28977L0.0170455 1.90909V0.0909088L9.16477 4.75V5.88636Z" fill="white"/></svg>';
const iconGreaterOrEqual    = '<svg width="10" height="12" viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.0170455 11.3182V9.72727H9.16477V11.3182H0.0170455ZM9.16477 5.29545L0.0170455 8.59091V6.85795L6.40909 4.75568L6.35227 4.86932V4.58523L6.40909 4.69886L0.0170455 2.59659V0.863636L9.16477 4.15909V5.29545Z" fill="white"/></svg>';

const iconFunctions         = '<svg width="19" height="13" viewBox="0 0 19 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.91534 3.92272V5.1159H0.599995V3.92272H4.91534ZM1.78323 11.5591V3.03778C1.78323 2.56051 1.88764 2.16444 2.09644 1.84957C2.30525 1.53139 2.582 1.29441 2.9267 1.13863C3.2714 0.97954 3.64592 0.899994 4.05028 0.899994C4.34857 0.899994 4.60378 0.924852 4.8159 0.974568C5.02803 1.02097 5.18546 1.06406 5.28821 1.10383L4.94019 2.30695C4.87059 2.28707 4.7811 2.26387 4.67173 2.23735C4.56235 2.20752 4.42978 2.19261 4.274 2.19261C3.91273 2.19261 3.65421 2.2821 3.49843 2.46107C3.34597 2.64005 3.26974 2.89857 3.26974 3.23664V11.5591H1.78323Z" fill="white"/><path d="M8.3 6.33878C8.3 5.09257 8.46406 3.94579 8.79218 2.89844C9.12031 1.85109 9.59924 0.884943 10.229 0H11.5912C11.3459 0.328125 11.1172 0.730824 10.9051 1.2081C10.693 1.68537 10.5074 2.20904 10.3483 2.77912C10.1892 3.34588 10.0649 3.93419 9.97542 4.54403C9.88594 5.15057 9.84119 5.74882 9.84119 6.33878C9.84119 7.1276 9.91908 7.92637 10.0749 8.73509C10.2306 9.5438 10.4411 10.2945 10.7062 10.9872C10.9714 11.6799 11.2664 12.245 11.5912 12.6825H10.229C9.59924 11.7976 9.12031 10.8314 8.79218 9.78409C8.46406 8.73674 8.3 7.58831 8.3 6.33878Z" fill="white"/><path d="M18.2912 6.33878C18.2912 7.58831 18.1271 8.73674 17.799 9.78409C17.4709 10.8314 16.992 11.7976 16.3622 12.6825H15C15.2453 12.3544 15.474 11.9517 15.6861 11.4744C15.8982 10.9972 16.0838 10.4751 16.2429 9.90838C16.402 9.33831 16.5263 8.74834 16.6158 8.13849C16.7053 7.52865 16.75 6.92874 16.75 6.33878C16.75 5.55327 16.6721 4.75616 16.5163 3.94744C16.3606 3.13873 16.1501 2.38802 15.8849 1.69531C15.6198 1.0026 15.3248 0.4375 15 0H16.3622C16.992 0.884943 17.4709 1.85109 17.799 2.89844C18.1271 3.94579 18.2912 5.09257 18.2912 6.33878Z" fill="white"/></svg>';
const iconSign              = '<svg width="7" height="11" viewBox="0 0 7 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.90606 7V0H4.09394V7H2.90606ZM0 4.09394V2.90606H7V4.09394H0Z" fill="white"/><path d="M7 10V11H0V10H7Z" fill="white"/></svg>';
const iconAbsolute          = '<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.40227 4L6.5 5.8457L7.61544 4H8.97167L7.33215 6.5L9 9H7.65085L6.5 7.19987L5.35977 9H4L5.65722 6.5L4.04249 4H5.40227Z" fill="white"/><rect width="1" height="13" transform="matrix(-1 0 0 1 13 0)" fill="white"/><rect width="1" height="13" transform="matrix(-1 0 0 1 1 0)" fill="white"/></svg>';
const iconRound             = '<svg width="17" height="13" viewBox="0 0 17 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.74422 12.2978C3.1 12 1.51382 9.72099 1.51382 6.5C1.51382 3.27901 3.1 1 4.74422 0.702217" stroke="white" stroke-width="1.1"/><path d="M12.3 12.2978C13.9442 12 15.5304 9.72099 15.5304 6.5C15.5304 3.27901 13.9442 1 12.3 0.702217" stroke="white" stroke-width="1.1"/><path d="M7.40227 4L8.5 5.8457L9.61544 4H10.9717L9.33215 6.5L11 9H9.65085L8.5 7.19987L7.35977 9H6L7.65722 6.5L6.04249 4H7.40227Z" fill="white"/></svg>';
const iconMinMax            = '<svg width="19" height="11" viewBox="0 0 19 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.8444 10.2709C14.1756 10.2709 13.581 10.1536 13.0608 9.91916C12.5436 9.68469 12.1349 9.35833 11.8345 8.94008C11.5341 8.52182 11.3747 8.03862 11.3561 7.49046H13.1026C13.1181 7.75345 13.2032 7.98317 13.3581 8.17962C13.5129 8.3729 13.7188 8.52341 13.9758 8.63114C14.2329 8.73887 14.5208 8.79274 14.8398 8.79274C15.1804 8.79274 15.4824 8.73253 15.7456 8.61213C16.0088 8.48855 16.2147 8.31745 16.3633 8.09882C16.512 7.88019 16.5848 7.62829 16.5817 7.34312C16.5848 7.04844 16.5104 6.78862 16.3587 6.56365C16.207 6.33868 15.9871 6.16283 15.6991 6.03608C15.4142 5.90934 15.0705 5.84597 14.6679 5.84597H13.8272V4.48665H14.6679C14.9993 4.48665 15.2888 4.42804 15.5365 4.3108C15.7874 4.19356 15.984 4.0288 16.1265 3.8165C16.2689 3.60104 16.3386 3.35231 16.3355 3.0703C16.3386 2.79464 16.2782 2.55541 16.1543 2.35262C16.0336 2.14667 15.8617 1.98665 15.6387 1.87259C15.4189 1.75852 15.1603 1.70148 14.863 1.70148C14.5719 1.70148 14.3025 1.75535 14.0548 1.86308C13.8071 1.97081 13.6073 2.12449 13.4556 2.32411C13.3039 2.52056 13.2234 2.75503 13.2141 3.02753H11.5558C11.5682 2.48253 11.7215 2.00408 12.0157 1.59217C12.3129 1.17708 12.7093 0.853891 13.2048 0.622586C13.7002 0.388111 14.2561 0.270874 14.8723 0.270874C15.5071 0.270874 16.0583 0.392864 16.5259 0.636844C16.9966 0.877655 17.3605 1.20243 17.6175 1.61118C17.8745 2.01992 18.003 2.47144 18.003 2.96574C18.0061 3.5139 17.8482 3.97335 17.5292 4.34407C17.2134 4.71479 16.7984 4.95719 16.2844 5.07125V5.1473C16.9533 5.24236 17.4658 5.49584 17.8219 5.90776C18.1811 6.3165 18.3591 6.82506 18.356 7.43342C18.356 7.97842 18.2043 8.46637 17.9008 8.8973C17.6005 9.32506 17.1855 9.66092 16.656 9.9049C16.1296 10.1489 15.5257 10.2709 14.8444 10.2709Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M5.24842 10.1V9.0123L7.66849 6.52853C7.88612 6.28767 8.06673 6.07455 8.21068 5.88899C8.35269 5.70591 8.45728 5.53101 8.52624 5.36431C8.59409 5.20031 8.6283 5.0249 8.6283 4.83713C8.6283 4.62249 8.58395 4.44513 8.49997 4.30082C8.41452 4.15187 8.29762 4.03742 8.1486 3.95683C8.00288 3.87804 7.73308 3.82752 7.5318 3.82752C7.33035 3.82752 7.15849 3.87323 7.01275 3.96148L7.01185 3.96203C6.86598 4.04825 6.75209 4.17123 6.6699 4.334C6.59008 4.49632 6.54817 4.69358 6.54817 4.92901V5.02901H5.20972V4.92901C5.20972 4.45551 5.30843 4.03865 5.50965 3.68192C5.70993 3.32685 5.98655 3.05079 6.33837 2.85557C6.69258 2.66028 7.09684 2.56384 7.54792 2.56384C8.00206 2.56384 8.50883 2.66353 8.86295 2.85505C9.21365 3.04473 9.48747 3.30584 9.68201 3.63789C9.87905 3.97053 9.97643 4.34886 9.97643 4.76999C9.97643 5.05282 9.927 5.33053 9.82856 5.60265C9.7295 5.87647 9.55696 6.175 9.31475 6.49779C9.07497 6.82022 8.73989 7.20853 8.31074 7.66222L8.30946 7.66357L7.18939 8.80454H9.97643V10.1H5.24842Z" fill="white"/><path d="M3.05113 5V10H2.05113V6.37158H2.02328L0.740662 7L0.740662 5.79834L2.2321 5H3.05113Z" fill="white"/></svg>';
const iconLimits            = '<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.40227 4L6.5 5.8457L7.61544 4H8.97167L7.33215 6.5L9 9H7.65085L6.5 7.19987L5.35977 9H4L5.65722 6.5L4.04249 4H5.40227Z" fill="white"/><rect width="1" height="13" transform="matrix(4.37114e-08 1 1 -4.37114e-08 0 0)" fill="white"/><rect width="1" height="13" transform="matrix(4.37114e-08 1 1 -4.37114e-08 0 12)" fill="white"/></svg>';

const iconTrigonometric     = '<svg width="17" height="13" viewBox="0 0 17 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 6H17V7H0V6Z" fill="white"/><path d="M16.5001 6.50003C15.2694 9.83336 14.0386 11.5 12.5001 11.5C10.9617 11.5 9.73089 9.83336 8.50012 6.50003C7.26935 3.1667 6.03858 1.50003 4.50012 1.50003C2.96166 1.50003 1.73089 3.1667 0.500122 6.50003" stroke="white"/><path d="M-5.68248e-07 13L0 0L1 4.37114e-08L1 13L-5.68248e-07 13Z" fill="white"/><path d="M17 1.50003C15.4615 1.50003 14.2308 3.1667 13 6.50003C11.7692 9.83336 10.5385 11.5 9 11.5C7.46154 11.5 6.23077 9.83336 5 6.50003C3.76923 3.1667 2.53846 1.50003 1 1.50003" stroke="white"/><path d="M11.4999 -1.64154e-07C11.4999 2.99999 10.282 4.99999 8.99988 6.49998C7.71779 7.99998 6.49988 10 6.49988 13" stroke="white"/></svg>';
const iconSine              = '<svg width="17" height="14" viewBox="0 0 17 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 7H17V8H0V7Z" fill="white"/><path d="M16.5001 7.50003C15.2694 10.8334 14.0386 12.5 12.5001 12.5C10.9617 12.5 9.73089 10.8334 8.50012 7.50003C7.26935 4.1667 6.03858 2.50003 4.50012 2.50003C2.96166 2.50003 1.73089 4.1667 0.500122 7.50003" stroke="white"/><path d="M-6.11959e-07 14L0 0L1 4.37114e-08L1 14L-6.11959e-07 14Z" fill="white"/></svg>';
const iconCosine            = '<svg width="17" height="14" viewBox="0 0 17 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 7H17V8H0V7Z" fill="white"/><path d="M0 2.00003H1.81134V3.00003H0V2.00003Z" fill="white"/><path d="M17 2.50003C15.5396 2.50003 14.3712 4.1667 13.2028 7.50003C12.0345 10.8334 10.8661 12.5 9.40567 12.5C7.94522 12.5 6.77686 10.8334 5.60851 7.50003C4.44015 4.1667 3.27179 2.50003 1.81134 2.50003" stroke="white"/><path d="M-6.11959e-07 14L0 0L1 4.37114e-08L1 14L-6.11959e-07 14Z" fill="white"/></svg>';
const iconTangent           = '<svg width="17" height="15" viewBox="0 0 17 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 7H17V8H0V7Z" fill="white"/><path d="M4.50047 1C4.50047 3.76923 2.90784 5.93552 1.90784 7.32014" stroke="white"/><path d="M13.4999 14C13.4999 11.2308 15.0925 9.06447 16.0925 7.67986" stroke="white"/><path d="M11.4999 1C11.4999 3.99999 10.282 5.99999 8.99988 7.49998C7.71779 8.99998 6.49988 11 6.49988 14" stroke="white"/><path d="M-6.55671e-07 15L0 0L1 4.37114e-08L1 15L-6.55671e-07 15Z" fill="white"/></svg>';

const iconText              = '<svg width="19" height="7" viewBox="0 0 19 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 2.39211H17.7568C17.7213 2.18805 17.656 2.00729 17.5607 1.84981C17.4654 1.69011 17.3468 1.55482 17.205 1.44392C17.0632 1.33302 16.9014 1.24984 16.7197 1.19439C16.5402 1.13672 16.3463 1.10789 16.1379 1.10789C15.7679 1.10789 15.4399 1.20105 15.154 1.38736C14.8681 1.57145 14.6443 1.84205 14.4825 2.19914C14.3208 2.55402 14.2399 2.98764 14.2399 3.5C14.2399 4.02123 14.3208 4.46039 14.4825 4.81749C14.6465 5.17237 14.8704 5.44075 15.154 5.62262C15.4399 5.80228 15.7668 5.89211 16.1346 5.89211C16.3385 5.89211 16.5291 5.86549 16.7064 5.81226C16.8859 5.75681 17.0465 5.67586 17.1884 5.56939C17.3324 5.46293 17.4532 5.33207 17.5507 5.17681C17.6504 5.02155 17.7191 4.84411 17.7568 4.64449L19 4.65114C18.9535 4.97497 18.8526 5.27883 18.6975 5.56274C18.5446 5.84664 18.344 6.09727 18.0958 6.31464C17.8476 6.52978 17.5573 6.69835 17.2249 6.82034C16.8925 6.94011 16.5235 7 16.118 7C15.5197 7 14.9856 6.86138 14.5158 6.58413C14.046 6.30688 13.6759 5.90653 13.4055 5.38308C13.1352 4.85963 13 4.23194 13 3.5C13 2.76584 13.1363 2.13815 13.4089 1.61692C13.6814 1.09347 14.0526 0.693124 14.5224 0.415875C14.9922 0.138625 15.5241 0 16.118 0C16.497 0 16.8493 0.0532321 17.1751 0.159696C17.5008 0.26616 17.7911 0.422529 18.046 0.628803C18.3008 0.832858 18.5103 1.08349 18.6742 1.3807C18.8404 1.6757 18.949 2.01283 19 2.39211Z" fill="white"/><path d="M7 7V0H9.56545C10.0497 0 10.4522 0.0797524 10.7729 0.239258C11.0958 0.396484 11.3368 0.611816 11.4961 0.885254C11.6575 1.15869 11.7382 1.46859 11.7382 1.81494C11.7382 2.09977 11.6859 2.34359 11.5812 2.54639C11.4764 2.74691 11.3357 2.90983 11.159 3.03516C10.9823 3.16048 10.7849 3.25049 10.5668 3.30518V3.37354C10.8045 3.38721 11.0325 3.46354 11.2507 3.60254C11.471 3.73926 11.651 3.93294 11.7906 4.18359C11.9302 4.43424 12 4.7373 12 5.09277C12 5.45508 11.916 5.78092 11.748 6.07031C11.5801 6.35742 11.327 6.58415 10.9889 6.75049C10.6507 6.91683 10.2253 7 9.7127 7H7ZM8.21401 5.94043H9.51963C9.9603 5.94043 10.2777 5.8527 10.4719 5.67725C10.6682 5.49951 10.7664 5.27165 10.7664 4.99365C10.7664 4.7863 10.7173 4.59945 10.6191 4.43311C10.5209 4.26449 10.3813 4.13232 10.2003 4.03662C10.0192 3.93864 9.80323 3.88965 9.55236 3.88965H8.21401V5.94043ZM8.21401 2.97705H9.41492C9.62435 2.97705 9.81305 2.93717 9.98102 2.85742C10.149 2.77539 10.281 2.66032 10.377 2.51221C10.4751 2.36182 10.5242 2.18408 10.5242 1.979C10.5242 1.70784 10.4326 1.48454 10.2493 1.30908C10.0683 1.13363 9.79887 1.0459 9.4411 1.0459H8.21401V2.97705Z" fill="white"/><path d="M1.24987 7H0L2.27564 0H3.7212L6 7H4.75013L3.02367 1.43555H2.97317L1.24987 7ZM1.2909 4.25537H4.69963V5.27393H1.2909V4.25537Z" fill="white"/></svg>';
const iconTextLength        = '<svg width="19" height="13" viewBox="0 0 19 13" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="10" width="1" height="3" fill="white"/><rect x="6" y="10" width="1" height="3" fill="white"/><rect x="12" y="10" width="1" height="3" fill="white"/><rect x="18" y="10" width="1" height="3" fill="white"/><rect y="12" width="19" height="1" fill="white"/><path d="M19 2.39211H17.7568C17.7213 2.18805 17.656 2.00729 17.5607 1.84981C17.4654 1.69011 17.3468 1.55482 17.205 1.44392C17.0632 1.33302 16.9014 1.24984 16.7197 1.19439C16.5402 1.13672 16.3463 1.10789 16.1379 1.10789C15.7679 1.10789 15.4399 1.20105 15.154 1.38736C14.8681 1.57145 14.6443 1.84205 14.4825 2.19914C14.3208 2.55402 14.2399 2.98764 14.2399 3.5C14.2399 4.02123 14.3208 4.46039 14.4825 4.81749C14.6465 5.17237 14.8704 5.44075 15.154 5.62262C15.4399 5.80228 15.7668 5.89211 16.1346 5.89211C16.3385 5.89211 16.5291 5.86549 16.7064 5.81226C16.8859 5.75681 17.0465 5.67586 17.1884 5.56939C17.3324 5.46293 17.4532 5.33207 17.5507 5.17681C17.6504 5.02155 17.7191 4.84411 17.7568 4.64449L19 4.65114C18.9535 4.97497 18.8526 5.27883 18.6975 5.56274C18.5446 5.84664 18.344 6.09727 18.0958 6.31464C17.8476 6.52978 17.5573 6.69835 17.2249 6.82034C16.8925 6.94011 16.5235 7 16.118 7C15.5197 7 14.9856 6.86138 14.5158 6.58413C14.046 6.30688 13.6759 5.90653 13.4055 5.38308C13.1352 4.85963 13 4.23194 13 3.5C13 2.76584 13.1363 2.13815 13.4089 1.61692C13.6814 1.09347 14.0526 0.693124 14.5224 0.415875C14.9922 0.138625 15.5241 0 16.118 0C16.497 0 16.8493 0.0532321 17.1751 0.159696C17.5008 0.26616 17.7911 0.422529 18.046 0.628803C18.3008 0.832858 18.5103 1.08349 18.6742 1.3807C18.8404 1.6757 18.949 2.01283 19 2.39211Z" fill="white"/><path d="M7 7V0H9.56545C10.0497 0 10.4522 0.0797524 10.7729 0.239258C11.0958 0.396484 11.3368 0.611816 11.4961 0.885254C11.6575 1.15869 11.7382 1.46859 11.7382 1.81494C11.7382 2.09977 11.6859 2.34359 11.5812 2.54639C11.4764 2.74691 11.3357 2.90983 11.159 3.03516C10.9823 3.16048 10.7849 3.25049 10.5668 3.30518V3.37354C10.8045 3.38721 11.0325 3.46354 11.2507 3.60254C11.471 3.73926 11.651 3.93294 11.7906 4.18359C11.9302 4.43424 12 4.7373 12 5.09277C12 5.45508 11.916 5.78092 11.748 6.07031C11.5801 6.35742 11.327 6.58415 10.9889 6.75049C10.6507 6.91683 10.2253 7 9.7127 7H7ZM8.21401 5.94043H9.51963C9.9603 5.94043 10.2777 5.8527 10.4719 5.67725C10.6682 5.49951 10.7664 5.27165 10.7664 4.99365C10.7664 4.7863 10.7173 4.59945 10.6191 4.43311C10.5209 4.26449 10.3813 4.13232 10.2003 4.03662C10.0192 3.93864 9.80323 3.88965 9.55236 3.88965H8.21401V5.94043ZM8.21401 2.97705H9.41492C9.62435 2.97705 9.81305 2.93717 9.98102 2.85742C10.149 2.77539 10.281 2.66032 10.377 2.51221C10.4751 2.36182 10.5242 2.18408 10.5242 1.979C10.5242 1.70784 10.4326 1.48454 10.2493 1.30908C10.0683 1.13363 9.79887 1.0459 9.4411 1.0459H8.21401V2.97705Z" fill="white"/><path d="M1.24987 7H0L2.27564 0H3.7212L6 7H4.75013L3.02367 1.43555H2.97317L1.24987 7ZM1.2909 4.25537H4.69963V5.27393H1.2909V4.25537Z" fill="white"/></svg>';
const iconTextTrim          = '<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.10001 9.93637V3.10001H6.71705C7.21109 3.10001 7.62167 3.17789 7.9488 3.33367C8.27815 3.48722 8.52406 3.69752 8.68651 3.96457C8.85119 4.23161 8.93353 4.53426 8.93353 4.87252C8.93353 5.15069 8.88012 5.38881 8.7733 5.58687C8.66648 5.7827 8.52295 5.94181 8.34269 6.06421C8.16243 6.18661 7.96104 6.27451 7.7385 6.32792V6.39468C7.98107 6.40803 8.21362 6.48258 8.43616 6.61833C8.66092 6.75185 8.84451 6.94101 8.98694 7.1858C9.12936 7.43059 9.20057 7.72657 9.20057 8.07373C9.20057 8.42756 9.1149 8.74579 8.94354 9.02842C8.77219 9.30881 8.51405 9.53024 8.16911 9.69269C7.82418 9.85514 7.39023 9.93637 6.86726 9.93637H4.10001ZM5.33843 8.90157H6.67032C7.11985 8.90157 7.44364 8.81589 7.6417 8.64454C7.84198 8.47096 7.94212 8.24842 7.94212 7.97692C7.94212 7.77441 7.89205 7.59193 7.79191 7.42948C7.69177 7.2648 7.54934 7.13573 7.36464 7.04226C7.17993 6.94657 6.95962 6.89873 6.7037 6.89873H5.33843V8.90157ZM5.33843 6.00746H6.5635C6.77714 6.00746 6.96963 5.96852 7.14099 5.89063C7.31234 5.81052 7.44698 5.69814 7.54489 5.55349C7.64503 5.40661 7.69511 5.23303 7.69511 5.03275C7.69511 4.76793 7.60164 4.54984 7.41471 4.37849C7.23 4.20713 6.95517 4.12145 6.59021 4.12145H5.33843V6.00746Z" fill="white"/><rect width="1" height="13" fill="white"/><rect x="12" width="1" height="13" fill="white"/></svg>';
const iconTextSubstring     = '<svg width="19" height="11" viewBox="0 -3 19 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.4833 7.1899C1.28079 7.1899 1.10721 7.11869 0.962558 6.97627C0.817908 6.83384 0.746696 6.66026 0.748921 6.45553C0.746696 6.25524 0.817908 6.08389 0.962558 5.94147C1.10721 5.79904 1.28079 5.72783 1.4833 5.72783C1.67913 5.72783 1.84937 5.79904 1.99402 5.94147C2.1409 6.08389 2.21545 6.25524 2.21767 6.45553C2.21545 6.59128 2.17984 6.71478 2.11085 6.82605C2.04409 6.93732 1.95508 7.02634 1.84381 7.0931C1.73476 7.15763 1.61459 7.1899 1.4833 7.1899Z" fill="white"/><path d="M14.5234 7.1899C14.3209 7.1899 14.1474 7.11869 14.0027 6.97627C13.8581 6.83384 13.7868 6.66026 13.7891 6.45553C13.7868 6.25524 13.8581 6.08389 14.0027 5.94147C14.1474 5.79904 14.3209 5.72783 14.5234 5.72783C14.7193 5.72783 14.8895 5.79904 15.0342 5.94147C15.181 6.08389 15.2556 6.25524 15.2578 6.45553C15.2556 6.59128 15.22 6.71478 15.151 6.82605C15.0842 6.93732 14.9952 7.02634 14.884 7.0931C14.7749 7.15763 14.6547 7.1899 14.5234 7.1899Z" fill="white"/><path d="M4.4766 7.1899C4.27409 7.1899 4.10051 7.11869 3.95586 6.97627C3.81121 6.83384 3.74 6.66026 3.74222 6.45553C3.74 6.25524 3.81121 6.08389 3.95586 5.94147C4.10051 5.79904 4.27409 5.72783 4.4766 5.72783C4.67243 5.72783 4.84267 5.79904 4.98732 5.94147C5.1342 6.08389 5.20875 6.25524 5.21097 6.45553C5.20875 6.59128 5.17314 6.71478 5.10415 6.82605C5.03739 6.93732 4.94838 7.02634 4.83711 7.0931C4.72807 7.15763 4.6079 7.1899 4.4766 7.1899Z" fill="white"/><path d="M17.5168 7.1899C17.3142 7.1899 17.1407 7.11869 16.996 6.97627C16.8514 6.83384 16.7802 6.66026 16.7824 6.45553C16.7802 6.25524 16.8514 6.08389 16.996 5.94147C17.1407 5.79904 17.3142 5.72783 17.5168 5.72783C17.7126 5.72783 17.8828 5.79904 18.0275 5.94147C18.1744 6.08389 18.2489 6.25524 18.2511 6.45553C18.2489 6.59128 18.2133 6.71478 18.1443 6.82605C18.0776 6.93732 17.9885 7.02634 17.8773 7.0931C17.7682 7.15763 17.6481 7.1899 17.5168 7.1899Z" fill="white"/><path d="M7.06596 6.91818V0.0818176H9.68301C10.177 0.0818176 10.5876 0.159706 10.9148 0.315482C11.2441 0.469034 11.49 0.679332 11.6525 0.946377C11.8171 1.21342 11.8995 1.51607 11.8995 1.85433C11.8995 2.1325 11.8461 2.37062 11.7393 2.56868C11.6324 2.76451 11.4889 2.92363 11.3086 3.04602C11.1284 3.16842 10.927 3.25632 10.7045 3.30973V3.37649C10.947 3.38984 11.1796 3.46439 11.4021 3.60014C11.6269 3.73366 11.8105 3.92282 11.9529 4.16761C12.0953 4.4124 12.1665 4.70838 12.1665 5.05554C12.1665 5.40937 12.0809 5.7276 11.9095 6.01023C11.7381 6.29062 11.48 6.51205 11.1351 6.6745C10.7901 6.83696 10.3562 6.91818 9.83322 6.91818H7.06596ZM8.30439 5.88338H9.63628C10.0858 5.88338 10.4096 5.7977 10.6077 5.62635C10.8079 5.45277 10.9081 5.23023 10.9081 4.95873C10.9081 4.75623 10.858 4.57374 10.7579 4.41129C10.6577 4.24661 10.5153 4.11754 10.3306 4.02408C10.1459 3.92839 9.92558 3.88054 9.66966 3.88054H8.30439V5.88338ZM8.30439 2.98928H9.52946C9.74309 2.98928 9.93559 2.95033 10.1069 2.87244C10.2783 2.79233 10.4129 2.67995 10.5109 2.5353C10.611 2.38842 10.6611 2.21484 10.6611 2.01456C10.6611 1.74974 10.5676 1.53165 10.3807 1.3603C10.196 1.18894 9.92112 1.10327 9.55616 1.10327H8.30439V2.98928Z" fill="white"/></svg>';
const iconTextContains      = '<svg width="19" height="12" viewBox="0 0 19 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.72997H17.8409C17.8079 6.53972 17.7469 6.37119 17.6581 6.22437C17.5692 6.07548 17.4587 5.94934 17.3265 5.84595C17.1942 5.74255 17.0434 5.66501 16.874 5.61331C16.7066 5.55955 16.5259 5.53266 16.3316 5.53266C15.9866 5.53266 15.6808 5.61952 15.4143 5.79322C15.1478 5.96485 14.9391 6.21713 14.7883 6.55006C14.6375 6.88093 14.562 7.2852 14.562 7.76288C14.562 8.24883 14.6375 8.65827 14.7883 8.9912C14.9412 9.32206 15.1498 9.57228 15.4143 9.74184C15.6808 9.90934 15.9856 9.99309 16.3285 9.99309C16.5186 9.99309 16.6963 9.96828 16.8616 9.91865C17.0289 9.86695 17.1787 9.79147 17.311 9.69222C17.4453 9.59296 17.5579 9.47095 17.6488 9.3262C17.7417 9.18145 17.8058 9.01602 17.8409 8.82991L19 8.83611C18.9566 9.13802 18.8626 9.42132 18.718 9.68601C18.5754 9.9507 18.3884 10.1844 18.157 10.387C17.9256 10.5876 17.655 10.7448 17.3451 10.8585C17.0351 10.9702 16.6911 11.026 16.313 11.026C15.7552 11.026 15.2573 10.8968 14.8193 10.6383C14.3813 10.3798 14.0362 10.0065 13.7842 9.51851C13.5321 9.03049 13.4061 8.44528 13.4061 7.76288C13.4061 7.07841 13.5331 6.4932 13.7873 6.00724C14.0414 5.51922 14.3875 5.14597 14.8255 4.88748C15.2635 4.629 15.7593 4.49976 16.313 4.49976C16.6663 4.49976 16.9949 4.54939 17.2986 4.64864C17.6023 4.7479 17.8729 4.89369 18.1105 5.086C18.3481 5.27625 18.5434 5.50992 18.6963 5.78701C18.8512 6.06204 18.9525 6.37636 19 6.72997Z" fill="white"/><path d="M1.16528 11.026H0L2.12163 4.49976H3.46935L5.59392 11.026H4.42864L2.81903 5.83814H2.77195L1.16528 11.026ZM1.20353 8.46712H4.38156V9.41674H1.20353V8.46712Z" fill="white"/><path d="M8.10511 8.16236V8.10271C8.11174 7.46966 8.17803 6.96587 8.30398 6.59134C8.42992 6.21682 8.6089 5.91355 8.84091 5.68154C9.07292 5.44953 9.35133 5.23575 9.67614 5.04021C9.87169 4.92089 10.0473 4.78003 10.2031 4.61762C10.3589 4.4519 10.4815 4.26132 10.571 4.04589C10.6638 3.83045 10.7102 3.59182 10.7102 3.32998C10.7102 3.00517 10.634 2.72344 10.4815 2.48481C10.3291 2.24617 10.1252 2.06222 9.87003 1.93296C9.61482 1.8037 9.33144 1.73907 9.01989 1.73907C8.74811 1.73907 8.48627 1.79541 8.23438 1.9081C7.98248 2.02079 7.77202 2.19811 7.60298 2.44006C7.43395 2.68201 7.33617 2.99854 7.30966 3.38964H6.05682C6.08333 2.82619 6.22917 2.34395 6.49432 1.9429C6.76278 1.54186 7.11577 1.23528 7.55327 1.02316C7.99408 0.811038 8.48295 0.704978 9.01989 0.704978C9.60322 0.704978 10.1103 0.820982 10.5412 1.05299C10.9754 1.285 11.3101 1.60318 11.5455 2.00753C11.7841 2.41189 11.9034 2.87259 11.9034 3.38964C11.9034 3.75422 11.8471 4.084 11.7344 4.37898C11.625 4.67396 11.4659 4.93746 11.2571 5.16947C11.0516 5.40147 10.803 5.60697 10.5114 5.78594C10.2197 5.96824 9.98603 6.16047 9.81037 6.36265C9.63471 6.56151 9.5071 6.79849 9.42756 7.07359C9.34801 7.34868 9.30492 7.69172 9.2983 8.10271V8.16236H8.10511ZM8.74148 11.1055C8.49621 11.1055 8.28575 11.0177 8.11009 10.8421C7.93442 10.6664 7.84659 10.4559 7.84659 10.2107C7.84659 9.96539 7.93442 9.75493 8.11009 9.57927C8.28575 9.40361 8.49621 9.31577 8.74148 9.31577C8.98674 9.31577 9.19721 9.40361 9.37287 9.57927C9.54853 9.75493 9.63636 9.96539 9.63636 10.2107C9.63636 10.3731 9.59493 10.5222 9.51207 10.6581C9.43253 10.794 9.32481 10.9034 9.18892 10.9862C9.05634 11.0658 8.9072 11.1055 8.74148 11.1055Z" fill="white"/></svg>';
const iconTextReplace       = '<svg width="20" height="16" viewBox="0 0 20 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 9.39211H17.7568C17.7213 9.18805 17.656 9.00729 17.5607 8.84981C17.4654 8.69011 17.3468 8.55482 17.205 8.44392C17.0632 8.33302 16.9014 8.24984 16.7197 8.19439C16.5402 8.13672 16.3463 8.10789 16.138 8.10789C15.7679 8.10789 15.4399 8.20105 15.154 8.38736C14.8681 8.57145 14.6443 8.84205 14.4825 9.19914C14.3208 9.55402 14.2399 9.98764 14.2399 10.5C14.2399 11.0212 14.3208 11.4604 14.4825 11.8175C14.6465 12.1724 14.8704 12.4407 15.154 12.6226C15.4399 12.8023 15.7668 12.8921 16.1346 12.8921C16.3385 12.8921 16.5291 12.8655 16.7064 12.8123C16.8859 12.7568 17.0465 12.6759 17.1884 12.5694C17.3324 12.4629 17.4532 12.3321 17.5507 12.1768C17.6504 12.0215 17.7191 11.8441 17.7568 11.6445L19 11.6511C18.9535 11.975 18.8526 12.2788 18.6975 12.5627C18.5446 12.8466 18.344 13.0973 18.0958 13.3146C17.8476 13.5298 17.5573 13.6984 17.2249 13.8203C16.8925 13.9401 16.5235 14 16.118 14C15.5197 14 14.9856 13.8614 14.5158 13.5841C14.046 13.3069 13.6759 12.9065 13.4055 12.3831C13.1352 11.8596 13 11.2319 13 10.5C13 9.76584 13.1363 9.13815 13.4089 8.61692C13.6814 8.09347 14.0526 7.69312 14.5224 7.41587C14.9922 7.13862 15.5241 7 16.118 7C16.497 7 16.8493 7.05323 17.1751 7.1597C17.5008 7.26616 17.7911 7.42253 18.046 7.6288C18.3008 7.83286 18.5103 8.08349 18.6742 8.3807C18.8404 8.6757 18.949 9.01283 19 9.39211Z" fill="white"/><path d="M1.24987 14H0L2.27564 7H3.7212L6 14H4.75013L3.02367 8.43555H2.97317L1.24987 14ZM1.2909 11.2554H4.69963V12.2739H1.2909V11.2554Z" fill="white"/><path d="M8 16V11H10.0759C10.4574 11 10.7755 11.0545 11.0304 11.1636C11.2852 11.2726 11.4768 11.424 11.6051 11.6177C11.7333 11.8097 11.7975 12.0311 11.7975 12.2817C11.7975 12.4771 11.757 12.6488 11.6759 12.7969C11.5949 12.9434 11.4835 13.0638 11.3418 13.1582C11.2017 13.251 11.0414 13.3169 10.8608 13.356V13.4048C11.0582 13.4129 11.243 13.4666 11.4152 13.5659C11.589 13.6652 11.73 13.8044 11.838 13.9834C11.946 14.1608 12 14.3724 12 14.6182C12 14.8835 11.9316 15.1203 11.7949 15.3286C11.6599 15.5353 11.4599 15.6989 11.1949 15.8193C10.93 15.9398 10.6034 16 10.2152 16H8ZM9.0962 15.1357H9.98987C10.2954 15.1357 10.5181 15.0796 10.6582 14.9673C10.7983 14.8534 10.8684 14.702 10.8684 14.5132C10.8684 14.3748 10.8338 14.2528 10.7646 14.147C10.6954 14.0412 10.5966 13.9582 10.4684 13.8979C10.3418 13.8377 10.1907 13.8076 10.0152 13.8076H9.0962V15.1357ZM9.0962 13.0923H9.90886C10.0591 13.0923 10.1924 13.0671 10.3089 13.0166C10.427 12.9645 10.5198 12.8913 10.5873 12.7969C10.6565 12.7025 10.6911 12.5894 10.6911 12.4575C10.6911 12.2769 10.6245 12.1312 10.4911 12.0205C10.3595 11.9098 10.1722 11.8545 9.92911 11.8545H9.0962V13.0923Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9.05758 8.64355L9.23002 8.76764L9.73959 8.05948L11.0933 6.90017L10.4428 6.14064L9.48886 6.95761C9.48453 5.97188 9.30757 4.81845 8.79688 3.77457C8.18769 2.52934 7.10594 1.45073 5.33322 1.02438L5.09938 1.99666C6.54887 2.34526 7.40452 3.20406 7.89862 4.21402C8.33403 5.10405 8.48993 6.11878 8.48896 7.00242L7.35652 6.18756L6.77245 6.99926L8.22215 8.04242L8.00316 8.22997L8.65362 8.9895L9.05758 8.64355Z" fill="white"/></svg>';
const iconTextJoin          = '<svg width="19" height="8" viewBox="0 -1 19 8" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.9328 6V1H10.0672V6H8.9328ZM7 4.0672V2.9328H12V4.0672H7Z" fill="white"/><path d="M14 7V0H16.5654C17.0497 0 17.4522 0.0797524 17.7729 0.239258C18.0958 0.396484 18.3368 0.611816 18.4961 0.885254C18.6575 1.15869 18.7382 1.46859 18.7382 1.81494C18.7382 2.09977 18.6859 2.34359 18.5812 2.54639C18.4764 2.74691 18.3357 2.90983 18.159 3.03516C17.9823 3.16048 17.7849 3.25049 17.5668 3.30518V3.37354C17.8045 3.38721 18.0325 3.46354 18.2507 3.60254C18.471 3.73926 18.651 3.93294 18.7906 4.18359C18.9302 4.43424 19 4.7373 19 5.09277C19 5.45508 18.916 5.78092 18.748 6.07031C18.5801 6.35742 18.327 6.58415 17.9889 6.75049C17.6507 6.91683 17.2253 7 16.7127 7H14ZM15.214 5.94043H16.5196C16.9603 5.94043 17.2777 5.8527 17.4719 5.67725C17.6682 5.49951 17.7664 5.27165 17.7664 4.99365C17.7664 4.7863 17.7173 4.59945 17.6191 4.43311C17.5209 4.26449 17.3813 4.13232 17.2003 4.03662C17.0192 3.93864 16.8032 3.88965 16.5524 3.88965H15.214V5.94043ZM15.214 2.97705H16.4149C16.6243 2.97705 16.813 2.93717 16.981 2.85742C17.149 2.77539 17.281 2.66032 17.377 2.51221C17.4751 2.36182 17.5242 2.18408 17.5242 1.979C17.5242 1.70784 17.4326 1.48454 17.2493 1.30908C17.0683 1.13363 16.7989 1.0459 16.4411 1.0459H15.214V2.97705Z" fill="white"/><path d="M1.24987 7H0L2.27564 0H3.7212L6 7H4.75013L3.02367 1.43555H2.97317L1.24987 7ZM1.2909 4.25537H4.69963V5.27393H1.2909V4.25537Z" fill="white"/></svg>';
const iconTextPad           = '<svg width="18" height="9" viewBox="0 0 18 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 9V7.79721L2.79721 9L4 9Z" fill="white"/><path d="M-1.44658e-08 4.24534L3.99999 0.24551L3.99997 7.95312e-05L2.83115 0.000131652L-1.18108e-05 2.8313L-1.44658e-08 4.24534Z" fill="white"/><path d="M5.39046e-07 1.22719L1.22734 -1.56162e-05L2.0772e-08 -6.35075e-05L5.39046e-07 1.22719Z" fill="white"/><path d="M1.24541 9.00001L3.99999 6.24534L3.99999 4.83113L-3.55967e-06 8.83107L-4.38033e-10 9.00004L1.24541 9.00001Z" fill="white"/><path d="M-6.4679e-07 7.26337L4 3.26341L4 1.84927L-1.15255e-06 5.84918L-6.4679e-07 7.26337Z" fill="white"/><path d="M7.24987 8H6L8.27564 1H9.7212L12 8H10.7501L9.02367 2.43555H8.97317L7.24987 8ZM7.2909 5.25537H10.6996V6.27393H7.2909V5.25537Z" fill="white"/><path d="M18.0001 9V7.79721L16.7973 9L18.0001 9Z" fill="white"/><path d="M14.0001 4.24534L18.0001 0.24551L18.0001 7.95312e-05L16.8313 0.000131652L14.0001 2.8313L14.0001 4.24534Z" fill="white"/><path d="M14.0001 1.22719L15.2274 -1.56162e-05L14.0001 -6.35075e-05L14.0001 1.22719Z" fill="white"/><path d="M15.2455 9.00001L18.0001 6.24534L18.0001 4.83113L14.0001 8.83107L14.0001 9.00004L15.2455 9.00001Z" fill="white"/><path d="M14.0001 7.26337L18.0001 3.26341L18.0001 1.84927L14.0001 5.84918L14.0001 7.26337Z" fill="white"/></svg>';
const iconTextCase          = '<svg width="14" height="7" viewBox="0 0 14 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.39447 6.89562H0L2.53892 0H4.15171L6.69415 6.89562H5.29968L3.37349 1.41414H3.31714L1.39447 6.89562ZM1.44025 4.19192H5.24334V5.19529H1.44025V4.19192Z" fill="white"/><path d="M11.1442 7C10.8014 7 10.4927 6.94164 10.218 6.82492C9.94571 6.70595 9.72973 6.53086 9.5701 6.29966C9.41281 6.06846 9.33416 5.78339 9.33416 5.44444C9.33416 5.15264 9.39051 4.91134 9.50319 4.72054C9.61588 4.52974 9.76964 4.3771 9.96449 4.26263C10.1593 4.14815 10.3788 4.06173 10.623 4.00337C10.8695 3.94276 11.1242 3.89899 11.3871 3.87205C11.7041 3.84063 11.9611 3.81257 12.1583 3.78788C12.3555 3.76094 12.4987 3.72054 12.5879 3.66667C12.6795 3.61055 12.7253 3.52413 12.7253 3.40741V3.38721C12.7253 3.13356 12.6466 2.93715 12.4893 2.79798C12.332 2.65881 12.1055 2.58923 11.8097 2.58923C11.4975 2.58923 11.2498 2.65432 11.0667 2.78451C10.8859 2.9147 10.7638 3.06846 10.7005 3.24579L9.51023 3.08418C9.60414 2.76992 9.75908 2.5073 9.97506 2.2963C10.191 2.08305 10.4551 1.92368 10.7674 1.81818C11.0796 1.71044 11.4247 1.65657 11.8027 1.65657C12.0632 1.65657 12.3226 1.68575 12.5809 1.74411C12.8391 1.80247 13.075 1.89899 13.2887 2.03367C13.5023 2.16611 13.6737 2.3468 13.8028 2.57576C13.9343 2.80471 14 3.09091 14 3.43434V6.89562H12.7746V6.18519H12.7323C12.6548 6.32884 12.5457 6.46352 12.4048 6.58923C12.2663 6.71268 12.0914 6.81257 11.8801 6.88889C11.6712 6.96296 11.4259 7 11.1442 7ZM11.4752 6.10438C11.7311 6.10438 11.9529 6.05612 12.1407 5.9596C12.3285 5.86083 12.4729 5.73064 12.5738 5.56902C12.6771 5.40741 12.7288 5.2312 12.7288 5.0404V4.43098C12.6889 4.4624 12.6208 4.49158 12.5245 4.51852C12.4306 4.54545 12.325 4.56902 12.2076 4.58923C12.0902 4.60943 11.974 4.62739 11.859 4.6431C11.744 4.65881 11.6442 4.67228 11.5597 4.6835C11.3695 4.70819 11.1993 4.7486 11.0491 4.80471C10.8988 4.86083 10.7803 4.93939 10.6934 5.0404C10.6066 5.13917 10.5631 5.26712 10.5631 5.42424C10.5631 5.64871 10.6488 5.81818 10.8202 5.93266C10.9916 6.04714 11.2099 6.10438 11.4752 6.10438Z" fill="white"/></svg>';
const iconTextCharacter     = '<svg width="19" height="13" viewBox="0 -1 19 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.2499 9H13L15.2756 3H16.7212L19 9H17.7501L16.0237 4.23047H15.9732L14.2499 9ZM14.2909 6.64746H17.6996V7.52051H14.2909V6.64746Z" fill="white"/><path d="M2.44963 8.99997C2.14265 8.99807 1.84298 8.94959 1.55062 8.85453C1.25825 8.75758 0.995126 8.60073 0.761236 8.384C0.527345 8.16537 0.341485 7.87545 0.203657 7.51424C0.0658285 7.15112 -0.00204155 6.7015 4.67531e-05 6.16538C4.67531e-05 5.66539 0.0585194 5.21957 0.175465 4.82794C0.29241 4.4363 0.460519 4.10551 0.679792 3.83555C0.899064 3.56369 1.16324 3.35646 1.47231 3.21388C1.78346 3.07129 2.13117 3 2.51542 3C2.91846 3 3.27556 3.07224 3.58672 3.21673C3.89997 3.36121 4.15265 3.55893 4.34478 3.80988C4.5369 4.05893 4.65593 4.3403 4.70188 4.65398H3.55853C3.50005 4.42965 3.37998 4.25094 3.19829 4.11787C3.0187 3.98288 2.79107 3.91539 2.51542 3.91539C2.07061 3.91539 1.72812 4.09125 1.48797 4.44296C1.2499 4.79467 1.12982 5.27755 1.12773 5.89162H1.17159C1.27392 5.72432 1.40652 5.58079 1.56941 5.46101C1.7323 5.34124 1.91607 5.24904 2.12073 5.1844C2.32747 5.11786 2.5457 5.08459 2.77541 5.08459C3.15131 5.08459 3.48857 5.16634 3.7872 5.32984C4.08791 5.49333 4.32598 5.71862 4.5014 6.00569C4.67682 6.29086 4.76348 6.61785 4.76139 6.98667C4.76348 7.3707 4.66742 7.71576 4.47321 8.02184C4.27899 8.32602 4.00856 8.56556 3.6619 8.74046C3.31524 8.91537 2.91115 9.00187 2.44963 8.99997ZM2.44337 8.14446C2.67099 8.14446 2.8746 8.09408 3.0542 7.99332C3.23379 7.89256 3.3758 7.75663 3.48021 7.58553C3.58463 7.41443 3.63579 7.22241 3.63371 7.00949C3.63579 6.80036 3.58567 6.6112 3.48335 6.442C3.38311 6.2728 3.24424 6.13877 3.06673 6.03991C2.88922 5.94105 2.68666 5.89162 2.45903 5.89162C2.28988 5.89162 2.13221 5.92109 1.98603 5.98002C1.83985 6.03896 1.71246 6.12071 1.60387 6.22527C1.49528 6.32793 1.40966 6.4477 1.34701 6.58458C1.28645 6.71956 1.25512 6.86405 1.25303 7.01804C1.25512 7.22146 1.30733 7.40872 1.40966 7.57982C1.51198 7.75093 1.65294 7.88781 1.83254 7.99047C2.01213 8.09313 2.21574 8.14446 2.44337 8.14446Z" fill="white"/><path d="M7.19764 8.99997C6.77998 8.99997 6.40617 8.92868 6.07622 8.78609C5.74626 8.64161 5.48418 8.44389 5.28997 8.19294C5.09784 7.94199 4.99552 7.65492 4.98299 7.33173H6.11067C6.13156 7.57127 6.24537 7.76709 6.45211 7.91918C6.65886 8.06937 6.90736 8.14446 7.19764 8.14446C7.42526 8.14446 7.62783 8.09693 7.80534 8.00188C7.98284 7.90682 8.12276 7.77469 8.22509 7.60549C8.32741 7.43629 8.37753 7.24332 8.37544 7.0266C8.37753 6.80606 8.32637 6.61025 8.22195 6.43915C8.11754 6.26804 7.97449 6.13401 7.79281 6.03706C7.61112 5.9382 7.40229 5.88877 7.16631 5.88877C6.97419 5.88687 6.7852 5.91919 6.59934 5.98573C6.41348 6.05227 6.26625 6.13972 6.15766 6.24808L5.10829 6.09124L5.44346 3.07985H9.16482V3.96387H6.40513L6.22031 5.51234H6.2579C6.37693 5.38497 6.54504 5.27946 6.76223 5.19581C6.97941 5.11026 7.21748 5.06748 7.47643 5.06748C7.86485 5.06748 8.21151 5.15113 8.51641 5.31843C8.8213 5.48383 9.06145 5.71196 9.23687 6.00284C9.41229 6.29371 9.5 6.62641 9.5 7.00093C9.5 7.38686 9.40185 7.73096 9.20555 8.03324C9.01133 8.33362 8.7409 8.57031 8.39424 8.74332C8.04967 8.91442 7.6508 8.99997 7.19764 8.99997Z" fill="white"/><rect x="11" width="1" height="12" fill="white"/></svg>';
const iconNumberToText      = '<svg width="19" height="12" viewBox="0 0 19 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2849 0V1.14446C16.2849 1.47359 16.224 1.8158 16.1022 2.17111C15.9839 2.52267 15.8208 2.85928 15.6129 3.18093C15.405 3.49883 15.1685 3.77186 14.9032 4L14 3.3885C14.1971 3.07807 14.3692 2.74334 14.5161 2.38429C14.6631 2.0215 14.7366 1.61197 14.7366 1.15568V0H16.2849ZM19 0V1.14446C19 1.47359 18.9391 1.8158 18.8172 2.17111C18.6989 2.52267 18.5358 2.85928 18.328 3.18093C18.1201 3.49883 17.8853 3.77186 17.6237 4L16.7204 3.3885C16.914 3.07807 17.0842 2.74334 17.2312 2.38429C17.3781 2.0215 17.4516 1.61197 17.4516 1.15568V0H19Z" fill="white"/><path d="M0 4V2.85554C0 2.52641 0.0590129 2.1842 0.177039 1.82889C0.298641 1.46985 0.463162 1.13137 0.670601 0.813464C0.881617 0.491819 1.11767 0.220664 1.37876 0L2.28004 0.6115C2.06903 0.944366 1.89199 1.29219 1.74893 1.65498C1.60944 2.01403 1.54149 2.41047 1.54506 2.84432V4H0ZM2.71996 4V2.85554C2.71996 2.52641 2.77897 2.1842 2.897 1.82889C3.0186 1.46985 3.18312 1.13137 3.39056 0.813464C3.60157 0.491819 3.83763 0.220664 4.09871 0L5 0.6115C4.78898 0.944366 4.61195 1.29219 4.46888 1.65498C4.3294 2.01403 4.26144 2.41047 4.26502 2.84432V4H2.71996Z" fill="white"/><path d="M5.42449 6.07985V11.9202H4.381V7.10932H4.34725L3 7.98194V7.01236L4.43163 6.07985H5.42449Z" fill="white"/><path d="M6.88705 11.9202V11.1559L8.88683 9.16825C9.07809 8.97243 9.23748 8.79848 9.36498 8.64639C9.49249 8.4943 9.58812 8.34696 9.65187 8.20437C9.71562 8.06179 9.7475 7.9097 9.7475 7.7481C9.7475 7.56369 9.70625 7.40589 9.62374 7.27471C9.54124 7.14164 9.4278 7.03897 9.28342 6.96673C9.13903 6.89449 8.97496 6.85836 8.7912 6.85836C8.60182 6.85836 8.43588 6.89829 8.29337 6.97814C8.15086 7.05608 8.04023 7.1673 7.96148 7.31179C7.8846 7.45627 7.84616 7.62833 7.84616 7.82795H6.8533C6.8533 7.45722 6.93674 7.13498 7.10363 6.86122C7.27051 6.58745 7.50021 6.37548 7.79272 6.22529C8.08711 6.0751 8.42463 6 8.80527 6C9.19154 6 9.53093 6.07319 9.82344 6.21958C10.116 6.36597 10.3428 6.56654 10.5041 6.82129C10.6672 7.07605 10.7488 7.36692 10.7488 7.69392C10.7488 7.91255 10.7075 8.12738 10.625 8.3384C10.5425 8.54943 10.3972 8.78327 10.1891 9.03992C9.98282 9.29658 9.69312 9.60741 9.31998 9.97243L8.32712 10.9962V11.0361H10.836V11.9202H6.88705Z" fill="white"/><path d="M13.8736 12C13.4686 12 13.1086 11.9297 12.7936 11.789C12.4804 11.6483 12.2329 11.4525 12.051 11.2015C11.8692 10.9506 11.7726 10.6606 11.7613 10.3317H12.8189C12.8283 10.4895 12.8798 10.6274 12.9736 10.7452C13.0673 10.8612 13.192 10.9515 13.3477 11.0162C13.5033 11.0808 13.6777 11.1131 13.8708 11.1131C14.0771 11.1131 14.2599 11.077 14.4193 11.0048C14.5787 10.9306 14.7034 10.8279 14.7934 10.6968C14.8834 10.5656 14.9274 10.4144 14.9256 10.2433C14.9274 10.0665 14.8824 9.91065 14.7905 9.77566C14.6987 9.64068 14.5655 9.53517 14.3912 9.45913C14.2186 9.38308 14.0105 9.34506 13.7667 9.34506H13.2577V8.52947H13.7667C13.9674 8.52947 14.1427 8.4943 14.2927 8.42395C14.4446 8.35361 14.5637 8.25475 14.6499 8.12738C14.7362 7.9981 14.7784 7.84886 14.7765 7.67966C14.7784 7.51426 14.7418 7.37072 14.6668 7.24905C14.5937 7.12548 14.4896 7.02947 14.3546 6.96103C14.2215 6.89259 14.0649 6.85836 13.8849 6.85836C13.7086 6.85836 13.5455 6.89068 13.3955 6.95532C13.2455 7.01996 13.1245 7.11217 13.0327 7.23194C12.9408 7.34981 12.892 7.49049 12.8864 7.65399H11.8823C11.8898 7.327 11.9826 7.03992 12.1607 6.79278C12.3407 6.54373 12.5808 6.34981 12.8808 6.21103C13.1808 6.07034 13.5174 6 13.8905 6C14.2749 6 14.6087 6.07319 14.8918 6.21958C15.1768 6.36407 15.3971 6.55894 15.5528 6.80418C15.7084 7.04943 15.7862 7.32034 15.7862 7.61692C15.7881 7.94582 15.6925 8.22148 15.4993 8.44392C15.3081 8.66635 15.0568 8.81179 14.7455 8.88023V8.92586C15.1506 8.98289 15.4609 9.13498 15.6765 9.38213C15.894 9.62738 16.0019 9.93251 16 10.2975C16 10.6245 15.9081 10.9173 15.7243 11.1759C15.5425 11.4325 15.2912 11.634 14.9706 11.7804C14.6518 11.9268 14.2861 12 13.8736 12Z" fill="white"/></svg>';
const iconTextToNumber      = '<svg width="17" height="14" viewBox="0 0 17 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.79893 12.5956C2.15471 12.2978 0.568527 10.0188 0.568527 6.79778C0.568527 3.57679 2.15471 1.29778 3.79893 1" stroke="white" stroke-width="1.1"/><path d="M12.2697 12.5956C13.9139 12.2978 15.5001 10.0188 15.5001 6.79778C15.5001 3.57679 13.9139 1.29778 12.2697 1" stroke="white" stroke-width="1.1"/><path d="M10.3582 5L10.3582 6.14446C10.3582 6.47359 10.2991 6.8158 10.1811 7.17111C10.0595 7.53015 9.89499 7.86863 9.68755 8.18654C9.47654 8.50818 9.24049 8.77934 8.9794 9L8.07811 8.3885C8.28913 8.05563 8.46617 7.70781 8.60923 7.34502C8.74871 6.98597 8.81667 6.58953 8.81309 6.15568L8.81309 5L10.3582 5ZM7.6382 5L7.6382 6.14446C7.6382 6.47359 7.57918 6.8158 7.46116 7.17111C7.33956 7.53015 7.17504 7.86863 6.9676 8.18654C6.75658 8.50818 6.52053 8.77934 6.25944 9L5.35815 8.3885C5.56917 8.05563 5.74621 7.70781 5.88927 7.34502C6.02876 6.98597 6.09671 6.58953 6.09313 6.15568L6.09313 5L7.6382 5Z" fill="white"/></svg>';
const iconTextToColor       = '<svg width="17" height="14" viewBox="0 0 17 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.79803 12.5956C2.1538 12.2978 0.567627 10.0188 0.567627 6.79778C0.567627 3.57679 2.1538 1.29778 3.79803 1" stroke="white" stroke-width="1.1"/><path d="M12.2684 12.5956C13.9126 12.2978 15.4988 10.0188 15.4988 6.79778C15.4988 3.57679 13.9126 1.29778 12.2684 1" stroke="white" stroke-width="1.1"/><rect x="5.99257" y="3" width="1" height="8" fill="white"/><rect x="3.99257" y="9" width="1" height="8" transform="rotate(-90 3.99257 9)" fill="white"/><rect x="8.99257" y="3" width="1" height="8" fill="white"/><rect x="3.99257" y="6" width="1" height="8" transform="rotate(-90 3.99257 6)" fill="white"/></svg>';
const iconTextSplit         = '<svg width="19" height="14" viewBox="0 0 19 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.9998V3.99976H16.5654C17.0497 3.99976 17.4522 4.07951 17.7729 4.23901C18.0958 4.39624 18.3368 4.61157 18.4961 4.88501C18.6575 5.15845 18.7382 5.46834 18.7382 5.8147C18.7382 6.09953 18.6859 6.34334 18.5812 6.54614C18.4764 6.74666 18.3357 6.90959 18.159 7.03491C17.9823 7.16024 17.7849 7.25024 17.5668 7.30493V7.37329C17.8045 7.38696 18.0325 7.4633 18.2507 7.60229C18.471 7.73901 18.651 7.9327 18.7906 8.18335C18.9302 8.434 19 8.73706 19 9.09253C19 9.45483 18.916 9.78068 18.748 10.0701C18.5801 10.3572 18.327 10.5839 17.9889 10.7502C17.6507 10.9166 17.2253 10.9998 16.7127 10.9998H14ZM15.214 9.94019H16.5196C16.9603 9.94019 17.2777 9.85246 17.4719 9.677C17.6682 9.49927 17.7664 9.2714 17.7664 8.99341C17.7664 8.78605 17.7173 8.5992 17.6191 8.43286C17.5209 8.26424 17.3813 8.13208 17.2003 8.03638C17.0192 7.9384 16.8032 7.8894 16.5524 7.8894H15.214V9.94019ZM15.214 6.97681H16.4149C16.6243 6.97681 16.813 6.93693 16.981 6.85718C17.149 6.77515 17.281 6.66007 17.377 6.51196C17.4751 6.36157 17.5242 6.18384 17.5242 5.97876C17.5242 5.7076 17.4326 5.48429 17.2493 5.30884C17.0683 5.13338 16.7989 5.04565 16.4411 5.04565H15.214V6.97681Z" fill="white"/><path d="M1.24987 10.9998H0L2.27564 3.99976H3.7212L6 10.9998H4.75013L3.02367 5.4353H2.97317L1.24987 10.9998ZM1.2909 8.25513H4.69963V9.27368H1.2909V8.25513Z" fill="white"/><rect x="9" y="12" width="1" height="2" fill="white"/><rect x="9" y="8" width="1" height="2" fill="white"/><rect x="9" y="4" width="1" height="2" fill="white"/><rect x="9" width="1" height="2" fill="white"/></svg>';
const iconTextCompare       = '<svg width="19" height="7" viewBox="0 0 19 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.56871 7H0.232777L2.66513 0.0909089H4.21023L6.64595 7H5.31001L3.46467 1.50781H3.41069L1.56871 7ZM1.61257 4.29102H5.25604V5.29634H1.61257V4.29102ZM10.0356 1.01864H11.1218L9.15505 6.07227H8.07213L10.0356 1.01864ZM7.34344 2.98881V1.94638H11.8337V2.98881H7.34344ZM7.34344 5.1479V4.10547H11.8337V5.1479H7.34344ZM13.4656 7V0.0909089H16.1105C16.6098 0.0909089 17.0248 0.169626 17.3554 0.327059C17.6882 0.482244 17.9368 0.69478 18.1009 0.964666C18.2674 1.23455 18.3506 1.54042 18.3506 1.88228C18.3506 2.16341 18.2966 2.40406 18.1887 2.60423C18.0807 2.80214 17.9356 2.96295 17.7535 3.08665C17.5713 3.21035 17.3677 3.29918 17.1428 3.35316V3.42063C17.388 3.43413 17.623 3.50947 17.8479 3.64666C18.0751 3.7816 18.2606 3.97277 18.4046 4.22017C18.5485 4.46757 18.6205 4.76669 18.6205 5.11754C18.6205 5.47514 18.5339 5.79676 18.3607 6.08239C18.1875 6.36577 17.9266 6.58955 17.578 6.75373C17.2294 6.91791 16.7909 7 16.2623 7H13.4656ZM14.7172 5.95419H16.0633C16.5176 5.95419 16.8448 5.8676 17.045 5.69442C17.2474 5.519 17.3486 5.29409 17.3486 5.01971C17.3486 4.81504 17.298 4.63062 17.1968 4.46644C17.0956 4.30001 16.9517 4.16957 16.765 4.07511C16.5783 3.9784 16.3557 3.93004 16.097 3.93004H14.7172V5.95419ZM14.7172 3.0293H15.9553C16.1713 3.0293 16.3658 2.98994 16.539 2.91122C16.7122 2.83026 16.8482 2.71668 16.9472 2.57049C17.0484 2.42205 17.099 2.24663 17.099 2.04421C17.099 1.77657 17.0045 1.55617 16.8156 1.38299C16.6289 1.20981 16.3512 1.12322 15.9823 1.12322H14.7172V3.0293Z" fill="white"/></svg>';
const iconTextCSV           = '<svg width="14" height="11" viewBox="0 0 14 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.37774 4.99976L2.32234 5.46851C2.28257 5.82646 2.21155 6.1901 2.10928 6.55941C2.00984 6.93157 1.90473 7.2739 1.79393 7.5864C1.68314 7.8989 1.10795 8.32078 1.03977 8.49976H0C0.0397727 8.32646 0.579446 7.91453 0.647628 7.61623C0.718651 7.31794 0.786833 6.98271 0.852173 6.61055C0.647628 6.40057 0.210938 6.55941 0 6.49976V4.99976H2.37774Z" fill="white"/><path d="M7.37774 4.99976L7.32234 5.46851C7.28257 5.82646 7.21155 6.1901 7.10928 6.55941C7.00984 6.93157 6.90473 7.2739 6.79393 7.5864C6.68314 7.8989 6.10795 8.32078 6.03977 8.49976H5C5.03977 8.32646 5.57945 7.91453 5.64763 7.61623C5.71865 7.31794 5.78683 6.98271 5.85217 6.61055C5.64763 6.40057 5.21094 6.55941 5 6.49976V4.99976H7.37774Z" fill="white"/><path d="M12.5 10.9998C11.6716 10.9998 11 10.3282 11 9.49976C11 8.67133 11.6716 7.99976 12.5 7.99976C13.3284 7.99976 14 8.67133 14 9.49976C14 10.3282 13.3284 10.9998 12.5 10.9998Z" fill="white"/><path d="M12.5 6.99976C11.6716 6.99976 11 6.32818 11 5.49976C11 4.67133 11.6716 3.99976 12.5 3.99976C13.3284 3.99976 14 4.67133 14 5.49976C14 6.32818 13.3284 6.99976 12.5 6.99976Z" fill="white"/><path d="M12.5 2.99976C11.6716 2.99976 11 2.32818 11 1.49976C11 0.671329 11.6716 -0.000244141 12.5 -0.000244141C13.3284 -0.000244141 14 0.671329 14 1.49976C14 2.32818 13.3284 2.99976 12.5 2.99976Z" fill="white"/></svg>';
const iconTextJson          = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.5 5.51719V4.98437C1.05152 4.98437 1.93627 4.88411 2.15423 4.68359C2.3755 4.48307 2.48614 4.14792 2.48614 3.67813V2.30313C2.48614 1.90781 2.52907 1.56549 2.61494 1.27617C2.70411 0.986849 2.84777 0.747657 3.04592 0.558594C3.24407 0.369532 3.50827 0.229167 3.83853 0.137501C4.16878 0.0458335 5.51453 0 6 0V0.842188C5.61691 0.842188 4.37684 0.89375 4.15557 0.996875C3.9376 1.1 3.78238 1.26042 3.68991 1.47813C3.60074 1.69297 3.55616 1.96797 3.55616 2.30313V4.02188C3.55616 4.24531 3.52148 4.4487 3.45213 4.63203C3.38608 4.81536 3.26223 4.97292 3.08059 5.10469C2.89896 5.23646 2.63971 5.33815 2.30285 5.40977C1.96929 5.48138 1.03501 5.51719 0.5 5.51719ZM6 11C5.51453 11 4.16878 10.9542 3.83853 10.8625C3.50827 10.7708 3.24407 10.6305 3.04592 10.4414C2.84777 10.2523 2.70411 10.0132 2.61494 9.72383C2.52907 9.4345 2.48614 9.09219 2.48614 8.69687V7.32188C2.48614 6.85208 2.3755 6.51693 2.15423 6.31641C1.93627 6.11589 1.05152 6.01562 0.5 6.01562V5.48281C1.03501 5.48281 1.96929 5.51862 2.30285 5.59023C2.63971 5.66185 2.89896 5.76354 3.08059 5.89531C3.26223 6.02708 3.38608 6.18464 3.45213 6.36797C3.52148 6.5513 3.55616 6.75469 3.55616 6.97813V8.69687C3.55616 9.03203 3.60074 9.30703 3.68991 9.52188C3.78238 9.73672 3.9376 9.8957 4.15557 9.99883C4.37684 10.1048 5.61691 10.1578 6 10.1578V11ZM0.5 6.01562V4.98437H2.1691V6.01562H0.5Z" fill="white"/><path d="M14.5 5.48281V6.01562C13.9485 6.01562 13.0621 6.11589 12.8408 6.31641C12.6228 6.51693 12.5139 6.85208 12.5139 7.32188V8.69687C12.5139 9.09219 12.4693 9.4345 12.3801 9.72383C12.2942 10.0132 12.1522 10.2523 11.9541 10.4414C11.7559 10.6305 11.4917 10.7708 11.1615 10.8625C10.8312 10.9542 9.48547 11 9 11V10.1578C9.38309 10.1578 10.6215 10.1048 10.8395 9.99883C11.0607 9.8957 11.216 9.73672 11.3051 9.52188C11.3976 9.30703 11.4438 9.03203 11.4438 8.69687V6.97813C11.4438 6.75469 11.4769 6.5513 11.5429 6.36797C11.6123 6.18464 11.7378 6.02708 11.9194 5.89531C12.101 5.76354 12.3586 5.66185 12.6922 5.59023C13.0291 5.51862 13.965 5.48281 14.5 5.48281ZM9 0C9.48547 0 10.8312 0.0458335 11.1615 0.137501C11.4917 0.229167 11.7559 0.369532 11.9541 0.558594C12.1522 0.747657 12.2942 0.986849 12.3801 1.27617C12.4693 1.56549 12.5139 1.90781 12.5139 2.30313V3.67813C12.5139 4.14792 12.6228 4.48307 12.8408 4.68359C13.0621 4.88411 13.9485 4.98437 14.5 4.98437V5.51719C13.965 5.51719 13.0291 5.48138 12.6922 5.40977C12.3586 5.33815 12.101 5.23646 11.9194 5.10469C11.7378 4.97292 11.6123 4.81536 11.5429 4.63203C11.4769 4.4487 11.4438 4.24531 11.4438 4.02188V2.30313C11.4438 1.96797 11.3976 1.69297 11.3051 1.47813C11.216 1.26042 11.0607 1.1 10.8395 0.996875C10.6215 0.89375 9.38309 0.842188 9 0.842188V0ZM14.5 4.98437V6.01562H12.8309V4.98437H14.5Z" fill="white"/></svg>';
const iconTextFetch         = '<svg width="16" height="15" viewBox="0 0 16 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.5 7.5C14.5 11.366 11.366 14.5 7.5 14.5C3.63401 14.5 0.5 11.366 0.5 7.5C0.5 3.63401 3.63401 0.5 7.5 0.5C11.366 0.5 14.5 3.63401 14.5 7.5ZM6.89681 1.84719C7.1396 1.58019 7.34416 1.5 7.5 1.5C7.65584 1.5 7.8604 1.58019 8.10319 1.84719C8.34611 2.11433 8.58782 2.52877 8.80109 3.0833C9.18541 4.08253 9.44589 5.45389 9.4925 7L5.5075 7C5.55411 5.45389 5.81459 4.08253 6.19891 3.0833C6.41218 2.52877 6.65389 2.11433 6.89681 1.84719ZM4.50708 7C4.55384 5.35511 4.82979 3.85731 5.26556 2.72432C5.39989 2.37505 5.55249 2.05238 5.72342 1.76738C3.4299 2.47736 1.72465 4.52586 1.52054 7H4.50708ZM1.52054 8H4.50708C4.55384 9.64489 4.82979 11.1427 5.26556 12.2757C5.39989 12.625 5.55249 12.9476 5.72342 13.2326C3.4299 12.5226 1.72465 10.4741 1.52054 8ZM5.5075 8L9.4925 8C9.44589 9.54611 9.18541 10.9175 8.80109 11.9167C8.58782 12.4712 8.34611 12.8857 8.10319 13.1528C7.8604 13.4198 7.65584 13.5 7.5 13.5C7.34416 13.5 7.1396 13.4198 6.89681 13.1528C6.65389 12.8857 6.41218 12.4712 6.19891 11.9167C5.81459 10.9175 5.55411 9.54611 5.5075 8ZM10.4929 8C10.4462 9.64489 10.1702 11.1427 9.73444 12.2757C9.60011 12.625 9.44751 12.9476 9.27658 13.2326C11.5701 12.5226 13.2754 10.4741 13.4795 8H10.4929ZM13.4795 7C13.2753 4.52586 11.5701 2.47736 9.27658 1.76738C9.44751 2.05238 9.60011 2.37505 9.73444 2.72432C10.1702 3.85731 10.4462 5.35511 10.4929 7H13.4795Z" fill="white"/></svg>';
const iconTextFile          = '<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.5 14.5H12.5V0.5H2.20237L0.5 2.2138V14.5Z" stroke="white"/><rect x="3" y="4" width="7" height="1" fill="white"/><rect x="3" y="7" width="7" height="1" fill="white"/><rect x="3" y="10" width="7" height="1" fill="white"/></svg>';

const iconColor             = '<svg width="13" height="15" viewBox="0 0 13 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.8409 3.43385C10.7465 2.2502 9.18038 1.50909 7.44118 1.50909C4.13249 1.50909 1.45027 4.19132 1.45027 7.5C1.45027 10.8087 4.13249 13.4909 7.44118 13.4909C9.18038 13.4909 10.7465 12.7498 11.8409 11.5662" stroke="white" stroke-width="1.2"/><path d="M7.5 8.57512C8.09377 8.57512 8.57511 8.09378 8.57511 7.50001C8.57511 6.90624 8.09377 6.4249 7.5 6.4249C6.90623 6.4249 6.42489 6.90624 6.42489 7.50001C6.42489 8.09378 6.90623 8.57512 7.5 8.57512Z" fill="white"/></svg>';
const iconRandomColor       = '<svg width="13" height="15" viewBox="0 0 13 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.9099 3.43385C10.8155 2.2502 9.24936 1.50909 7.51016 1.50909C4.20148 1.50909 1.51926 4.19132 1.51926 7.5C1.51926 10.8087 4.20148 13.4909 7.51016 13.4909C9.24936 13.4909 10.8155 12.7498 11.9099 11.5662" stroke="white" stroke-width="1.2"/><path d="M6.77317 8.80159V8.71763C6.77533 8.32795 6.81193 8.01793 6.88297 7.78757C6.95617 7.55721 7.05951 7.37206 7.19299 7.23212C7.32647 7.09003 7.48902 6.95978 7.68063 6.84137C7.81195 6.75956 7.92929 6.67021 8.03263 6.57333C8.13812 6.4743 8.22101 6.3645 8.28129 6.24393C8.34157 6.12122 8.37171 5.98451 8.37171 5.8338C8.37171 5.66372 8.33188 5.51625 8.25222 5.39138C8.17257 5.26651 8.06492 5.16963 7.92929 5.10074C7.79581 5.03184 7.64618 4.9974 7.4804 4.9974C7.32755 4.9974 7.18223 5.03077 7.04444 5.09751C6.90881 5.16209 6.79578 5.26113 6.70536 5.39461C6.61709 5.52594 6.56757 5.69279 6.55681 5.89516H5.40715C5.41791 5.48611 5.51695 5.14379 5.70425 4.86822C5.89371 4.59265 6.14345 4.38597 6.45347 4.24818C6.76564 4.1104 7.1101 4.0415 7.48686 4.0415C7.89807 4.0415 8.25976 4.11363 8.57193 4.25787C8.88626 4.40212 9.13061 4.60772 9.305 4.87468C9.48154 5.13949 9.56981 5.45381 9.56981 5.81766C9.56981 6.06309 9.52998 6.28269 9.45032 6.47645C9.37281 6.67021 9.26194 6.84244 9.11769 6.99315C8.97345 7.14385 8.80229 7.27841 8.60423 7.39682C8.42984 7.50446 8.28667 7.61642 8.17472 7.73267C8.06492 7.84893 7.98311 7.98564 7.92929 8.1428C7.87762 8.29781 7.85071 8.48942 7.84855 8.71763V8.80159H6.77317Z" fill="white"/><path d="M6.7784 10.8136C6.94344 10.9761 7.14021 11.0574 7.36872 11.0574C7.52106 11.0574 7.65943 11.0205 7.78384 10.9469C7.91079 10.8707 8.01235 10.7692 8.08852 10.6422C8.16723 10.5153 8.20658 10.3744 8.20658 10.2195C8.20658 9.99099 8.1228 9.79549 7.95522 9.63299C7.79019 9.4705 7.59469 9.38925 7.36872 9.38925C7.14021 9.38925 6.94344 9.4705 6.7784 9.63299C6.61337 9.79549 6.53085 9.99099 6.53085 10.2195C6.53085 10.4531 6.61337 10.6511 6.7784 10.8136Z" fill="white"/></svg>';
const iconValidColor        = '<svg width="17" height="15" viewBox="-1 0 17 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.8409 11.5662C10.7465 12.7498 9.18038 13.4909 7.44118 13.4909C4.13249 13.4909 1.45027 10.8087 1.45027 7.5C1.45027 4.19131 4.13249 1.50909 7.44118 1.50909C8.66322 1.50909 9.80806 2.02212 10.7556 2.65033" stroke="white" stroke-width="1.2"/><path fill-rule="evenodd" clip-rule="evenodd" d="M15.6832 3.62548L9.18921 10.1195L5.38744 6.31769L6.52965 5.17548L9.18921 7.83504L14.5411 2.48326L15.6832 3.62548Z" fill="white"/></svg>';
const iconCorrectColor      = '<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.9123 3.43385C10.8179 2.2502 9.25181 1.50909 7.51261 1.50909C4.20392 1.50909 1.5217 4.19132 1.5217 7.5C1.5217 10.8087 4.20392 13.4909 7.51261 13.4909C9.25181 13.4909 10.8179 12.7498 11.9123 11.5662" stroke="white" stroke-width="1.2"/><path d="M6.97348 10.659L7.06123 8.24587L5.02106 9.54017L4.49457 8.61881L6.64443 7.5L4.49457 6.3812L5.02106 5.45983L7.06123 6.75414L6.97348 4.34103H8.02648L7.93873 6.75414L9.9789 5.45983L10.5054 6.3812L8.35554 7.5L10.5054 8.61881L9.9789 9.54017L7.93873 8.24587L8.02648 10.659H6.97348Z" fill="white"/></svg>';
const iconWebContrast       = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 4H8V12H10V11H9V5H11V6.267H12V4Z" fill="white"/><path d="M12 4H8V12H10V11H9V5H11V6.267H12V4Z" fill="white"/><path d="M12 4H8V12H10V11H9V5H11V6.267H12V4Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M0 1.5C0 0.671573 0.671573 0 1.5 0H14.5C15.3284 0 16 0.671573 16 1.5V14.5C16 15.3284 15.3284 16 14.5 16H1.5C0.671573 16 0 15.3284 0 14.5V1.5ZM8 1H14.5C14.7761 1 15 1.22386 15 1.5V14.5C15 14.7761 14.7761 15 14.5 15H8V12.4H5.47075V11H6.8V5.4H5.22306V6.93713H3.80043V4H8V1Z" fill="white"/></svg>';
const iconConvertP3         = '<svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.12254 14.9986L6.71449 5.49468L12.4836 10.6508L4.12254 14.9986Z" stroke="white" stroke-width="1.1"/><path d="M1.4965 18L5.4965 1L16.9965 11.5L1.4965 18Z" stroke="white" stroke-width="1.1"/></svg>';
const iconColorblind        = '<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 19.5371C15.491 19.5371 19.5371 15.491 19.5371 10.5C19.5371 5.50898 15.491 1.46295 10.5 1.46295C5.50898 1.46295 1.46295 5.50898 1.46295 10.5C1.46295 15.491 5.50898 19.5371 10.5 19.5371Z" stroke="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9.37288 4.83079C9.73798 4.75856 10.1149 4.7208 10.5 4.7208C10.8851 4.7208 11.262 4.75856 11.6271 4.83079L11.3554 6.20417C11.0793 6.14955 10.7934 6.1208 10.5 6.1208C10.2066 6.1208 9.92068 6.14955 9.64458 6.20417L9.37288 4.83079ZM5.69463 7.2885C6.11636 6.65857 6.65856 6.11636 7.28849 5.69464L8.06734 6.85799C7.58948 7.17791 7.17791 7.58948 6.85799 8.06734L5.69463 7.2885ZM13.7115 5.69464C14.3414 6.11636 14.8836 6.65857 15.3054 7.2885L14.142 8.06734C13.8221 7.58948 13.4105 7.17791 12.9327 6.85799L13.7115 5.69464ZM16.1692 9.37289C16.2414 9.73799 16.2792 10.1149 16.2792 10.5C16.2792 10.8851 16.2414 11.262 16.1692 11.6271L14.7958 11.3554C14.8504 11.0793 14.8792 10.7934 14.8792 10.5C14.8792 10.2066 14.8504 9.92068 14.7958 9.64458L16.1692 9.37289ZM4.7208 10.5C4.7208 10.1149 4.75856 9.73799 4.83078 9.37289L6.20417 9.64458C6.14955 9.92068 6.1208 10.2066 6.1208 10.5C6.1208 10.7934 6.14955 11.0793 6.20417 11.3554L4.83078 11.6271C4.75856 11.262 4.7208 10.8851 4.7208 10.5ZM7.28849 15.3054C6.65856 14.8836 6.11636 14.3414 5.69463 13.7115L6.85799 12.9327C7.17791 13.4105 7.58948 13.8221 8.06734 14.142L7.28849 15.3054ZM15.3054 13.7115C14.8836 14.3414 14.3414 14.8836 13.7115 15.3054L12.9327 14.142C13.4105 13.8221 13.8221 13.4105 14.142 12.9327L15.3054 13.7115ZM10.5 16.2792C10.1149 16.2792 9.73798 16.2414 9.37288 16.1692L9.64458 14.7958C9.92068 14.8505 10.2066 14.8792 10.5 14.8792C10.7934 14.8792 11.0793 14.8505 11.3554 14.7958L11.6271 16.1692C11.262 16.2414 10.8851 16.2792 10.5 16.2792Z" fill="white"/><path d="M10.5 11.9909C11.3234 11.9909 11.9909 11.3234 11.9909 10.5C11.9909 9.6766 11.3234 9.0091 10.5 9.0091C9.6766 9.0091 9.0091 9.6766 9.0091 10.5C9.0091 11.3234 9.6766 11.9909 10.5 11.9909Z" fill="white"/></svg>';
const iconColorInterpolate  = '<svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="2.5" r="2.5" fill="white" fill-opacity="0.1"/><circle cx="9.5" cy="2.5" r="2" stroke="white" stroke-opacity="0.4"/><circle cx="2.5" cy="9.5" r="2.5" fill="white" fill-opacity="0.4"/><circle cx="2.5" cy="9.5" r="2" stroke="white" stroke-opacity="0.61"/><circle cx="9.5" cy="16.5" r="2.5" fill="white" fill-opacity="0.8"/><circle cx="9.5" cy="16.5" r="2" stroke="white" stroke-opacity="0.9"/><circle cx="14.5" cy="14.5" r="2" fill="white" stroke="white"/><circle cx="14.5" cy="4.5" r="2" stroke="white" stroke-opacity="0.4"/><circle cx="4.5" cy="14.5" r="2.5" fill="white" fill-opacity="0.6"/><circle cx="4.5" cy="14.5" r="2" stroke="white" stroke-opacity="0.8"/><circle cx="4.5" cy="4.5" r="2.5" fill="white" fill-opacity="0.2"/><circle cx="4.5" cy="4.5" r="2" stroke="white" stroke-opacity="0.55"/></svg>';
const iconColorBlend        = '<svg width="14" height="15" viewBox="-1 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M-4.02642e-07 9C-5.48785e-07 10.5913 0.63214 12.1174 1.75736 13.2426C2.88258 14.3679 4.4087 15 6 15C7.5913 15 9.11742 14.3679 10.2426 13.2426C11.3679 12.1174 12 10.5913 12 9L6 9L-4.02642e-07 9Z" fill="white"/><path d="M0.499999 9.2647C0.499999 7.80555 0.917848 6.69229 1.85417 5.39097C2.66503 4.26403 3.84136 3.02592 5.4562 1.32626C5.64008 1.13273 5.82964 0.933209 6.02499 0.727189C6.22035 0.933214 6.40992 1.13274 6.5938 1.32628C8.20864 3.02593 9.38496 4.26403 10.1958 5.39097C11.1321 6.69229 11.55 7.80555 11.55 9.26471C11.55 12.1331 9.09987 14.5 6.02499 14.5C2.95012 14.5 0.499998 12.1331 0.499999 9.2647Z" stroke="white"/></svg>';

const iconLayer             = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="10" rx="2.5" stroke="white"/><rect x="2" y="2" width="11" height="7" rx="1" fill="white"/></svg>';
const iconFill              = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="15" height="11" rx="3" fill="white"/></svg>';
const iconGradient          = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 6V7H4V6H5Z" fill="white"/><path d="M5 6H6V5H5V6Z" fill="white"/><path d="M9 6V7H8V6H9Z" fill="white"/><path d="M9 6H10V5H9V6Z" fill="white"/><path d="M12 6H13V7H12V6Z" fill="white"/><path d="M7 7H6V8H7V7Z" fill="white"/><path d="M11 7H10V8H11V7Z" fill="white"/><path d="M3 7H2V8H3V7Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M0 3C0 1.34315 1.34315 0 3 0H12C13.6569 0 15 1.34315 15 3V8C15 9.65685 13.6569 11 12 11H3C1.34315 11 0 9.65685 0 8V3ZM1 4V5H2V6H1V8C1 9.10457 1.89543 10 3 10H12C13.1046 10 14 9.10457 14 8V6H13V5H14V4H13V5H12V6H11V5H10V4H9V5H8V6H7V5H6V4H5V5H4V6H3V5H2V4H1ZM11 3V4H12V3H11ZM3 3V4H4V3H3ZM7 4H8V3H7V4Z" fill="white"/></svg>';
const iconColorStop         = '<svg width="17" height="16" viewBox="-1 0 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.36166 4.49573L4.52176 3.33563L5.68186 4.49573L4.52176 5.65583L3.36166 4.49573ZM4.52176 8.48425L0.533234 4.49573L4.52176 0.507202L8.51028 4.49573L7.501 5.50501L8 8L5.50501 7.501L4.52176 8.48425Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M16 2.00005L1.99999 16L1.08075 15.0808L15.0807 1.08081L16 2.00005Z" fill="white"/></svg>';
const iconStroke            = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="10" rx="2.5" stroke="white"/></svg>';
const iconMask              = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 0.80426C1.83597 2.10266 0 4.83704 0 8C0 11.0375 1.69293 13.6797 4.18674 15.0344C4.28983 15.0905 4.39423 15.1443 4.5 15.1958C5.55719 15.7109 6.74484 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58173 12.4183 0 8 0C6.74469 0 5.55728 0.28894 4.5 0.80426ZM15 8C15 11.866 11.866 15 8 15C7.14575 15 6.32724 14.847 5.57037 14.5668C7.64352 13.1213 9 10.7191 9 8C9 5.28094 7.64349 2.87872 5.57031 1.43317C6.32718 1.15302 7.14572 1 8 1C11.866 1 15 4.13403 15 8Z" fill="white"/></svg>';

const iconEffects           = '<svg width="18" height="15" viewBox="0 -1 18 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13 13H4.5V14H13C15.7614 14 18 11.7614 18 9V4.5H17V9C17 11.2091 15.2091 13 13 13Z" fill="white"/><line x1="6.21326" y1="0.433143" x2="0.447288" y2="6.19912" stroke="white"/><line x1="10.2787" y1="0.610389" x2="1.25317" y2="9.63592" stroke="white"/><line x1="13.6388" y1="1.49308" x2="4.56403" y2="10.5678" stroke="white"/><line x1="14.5184" y1="4.85624" x2="8.86875" y2="10.5059" stroke="white"/><path d="M4 0.5H12C13.3807 0.5 14.5 1.61929 14.5 3V7C14.5 8.933 12.933 10.5 11 10.5H3C1.61929 10.5 0.5 9.38071 0.5 8V4C0.5 2.067 2.067 0.5 4 0.5Z" stroke="white"/></svg>';
const iconDropShadow        = '<svg width="19" height="15" viewBox="-1 -1 19 15" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="10" rx="2.5" stroke="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M13 13H4.5V14H13C15.7614 14 18 11.7614 18 9V4.5H17V9C17 11.2091 15.2091 13 13 13Z" fill="white"/></svg>';
const iconInnerShadow       = '<svg width="17" height="13" viewBox="0 0 17 13" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="16" height="12" rx="3.5" stroke="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M5 4H13V3H5C3.89543 3 3 3.89543 3 5V9H4V5C4 4.44772 4.44772 4 5 4Z" fill="white"/></svg>';
const iconLayerBlur         = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M0.00242553 9.06282L8.06639 0.9988L9.48059 0.998779L0.256423 10.2229L0.00242553 9.06282Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M0.452312 4.37771L3.45318 1.37684L5.24118 1.00305L0.00200153 6.24223L0.452312 4.37771Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M1.64012 11.6677L12.2897 1.01819L13.3811 1.34094L2.73919 11.9829L1.64012 11.6677Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M5.55088 11.9998L14.747 2.80362L14.9934 3.97146L6.965 11.9998L5.55088 11.9998Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9.79585 11.9974L15.0001 6.79314L14.6124 8.59506L11.569 11.6384L9.79585 11.9974Z" fill="white"/></svg>';
const iconBackBlur          = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="6.21326" y1="0.433143" x2="0.447288" y2="6.19912" stroke="white"/><line x1="10.2787" y1="0.610389" x2="1.25317" y2="9.63592" stroke="white"/><line x1="13.6388" y1="1.49308" x2="4.56403" y2="10.5678" stroke="white"/><line x1="14.5184" y1="4.85624" x2="8.86875" y2="10.5059" stroke="white"/><path d="M4 0.5H12C13.3807 0.5 14.5 1.61929 14.5 3V7C14.5 8.933 12.933 10.5 11 10.5H3C1.61929 10.5 0.5 9.38071 0.5 8V4C0.5 2.067 2.067 0.5 4 0.5Z" stroke="white"/></svg>';

const iconVarColor          = '<svg width="17" height="17" viewBox="0 0 17 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.4198 7.57435C16.3504 8.02738 16.2074 8.33817 16.0231 8.57091C15.8364 8.80662 15.5835 8.99224 15.2491 9.15882C14.9095 9.32803 14.5097 9.46646 14.0368 9.62193C13.9807 9.64037 13.9237 9.65902 13.8658 9.67795C13.4455 9.81544 12.98 9.9677 12.499 10.1611C11.7091 10.4787 11.4564 11.2283 11.3641 11.9129C11.3168 12.2639 11.3052 12.6417 11.301 13.01C11.2997 13.1308 11.2991 13.2498 11.2985 13.3675C11.2973 13.6191 11.2961 13.8653 11.2873 14.1135C11.2611 14.8514 11.1676 15.4428 10.9004 15.8483C10.6656 16.2044 10.2381 16.5 9.30271 16.5C4.45892 16.5 0.5 12.8747 0.5 8.5C0.5 4.1021 4.23097 0.5 8.87986 0.5C11.2376 0.5 13.2971 1.2157 14.671 2.44456C16.0303 3.66025 16.752 5.4042 16.4198 7.57435Z" stroke="white"/><circle cx="8.50001" cy="4.2746" r="1.27473" fill="white"/><circle cx="12.7744" cy="5.54939" r="1.27473" fill="white"/><circle cx="4.52192" cy="6.82404" r="1.27473" fill="white"/></svg>';
const iconVarNumber         = '<svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="4.43979" y="0.8703" width="1.34691" height="13.1692" transform="rotate(5.12323 4.43979 0.8703)" fill="white"/><rect x="10.4445" y="0.950623" width="1.34691" height="13.147" transform="rotate(5.12323 10.4445 0.950623)" fill="white"/><rect x="14.1184" y="4.19745" width="1.34691" height="13.2367" transform="rotate(90 14.1184 4.19745)" fill="white"/><rect x="14.1184" y="9.67902" width="1.34691" height="13.2367" transform="rotate(90 14.1184 9.67902)" fill="white"/></svg>';
const iconVarText           = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 0H0.5H5.00247H9.50494H10.0049V0.5V3.27642H9.00494V1H5.50247V9.99513L7.00021 9.99512L7.00021 10.9951L5.00247 10.9951L3.00021 10.9951L3.00021 9.99512L4.50247 9.99513V1H1V3.27642H0V0.5V0Z" fill="white"/></svg>';
const iconVarBoolean        = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="11" height="11" stroke="white"/><circle cx="6" cy="6" r="2.5" stroke="white"/></svg>';

const iconStyle             = '<svg width="12" height="9"  viewBox="0 0 12 9"  fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="7.5" cy="1.5" r="1.5" transform="rotate(90 7.5 1.5)" fill="white"/><circle cx="1.5" cy="1.5" r="1.5" transform="rotate(90 1.5 1.5)" fill="white"/><circle cx="7.5" cy="7.5" r="1.5" transform="rotate(90 7.5 7.5)" fill="white"/><circle cx="1.5" cy="7.5" r="1.5" transform="rotate(90 1.5 7.5)" fill="white"/></svg>';
const iconColorStyle        = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.53553 9.53552C8.63071 10.4403 7.38071 11 6 11C3.23858 11 1 8.76141 1 6C1 4.61929 1.55965 3.36929 2.46447 2.46448L6 6L9.53553 9.53552ZM12 6C12 9.31372 9.31371 12 6 12C2.68629 12 0 9.31372 0 6C0 4.34314 0.67157 2.84314 1.75735 1.75735C1.77346 1.74124 1.78965 1.72525 1.80592 1.70935C2.88722 0.652252 4.36652 0.000518799 5.99803 0C5.99869 0 5.99934 0 6 0C9.31305 0 11.9989 2.68521 12 5.99802C12 5.99869 12 5.99933 12 6Z" fill="white"/></svg>';
const iconColorStyleReplace = '<svg width="15" height="19" viewBox="0 0 15 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.18718 13.3189L7.83883 10.6673L8.54594 11.3744L5.89429 14.026C4.62509 15.2952 2.5673 15.2952 1.2981 14.026C0.0288918 12.7568 0.0288916 10.699 1.2981 9.42982L3.94975 6.77817L4.65685 7.48528L2.0052 10.1369C1.12652 11.0156 1.12652 12.4402 2.0052 13.3189C2.88388 14.1976 4.3085 14.1976 5.18718 13.3189ZM11.3744 8.54594L10.6673 7.83883L13.3189 5.18718C14.1976 4.3085 14.1976 2.88388 13.3189 2.0052C12.4402 1.12652 11.0156 1.12652 10.1369 2.0052L7.48528 4.65685L6.77817 3.94975L9.42982 1.2981C10.699 0.0288935 12.7568 0.0288931 14.026 1.2981C15.2952 2.5673 15.2952 4.62509 14.026 5.89429L11.3744 8.54594ZM5.92375 10.1664L10.1664 5.92375L9.40036 5.15772L5.15772 9.40036L5.92375 10.1664Z" fill="white"/></svg>';

const iconShapes            = '<svg width="17" height="19" viewBox="0 -1 17 19" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="1.53844" y="1.49869" width="5" height="5" stroke="white"/><circle cx="12.8668" cy="3.99869" r="3" stroke="white"/><line x1="0.933922" y1="16.7012" x2="7.26322" y2="10.3719" stroke="white"/><path d="M9.61918 15.709L12.8668 10.084L16.1144 15.709H9.61918Z" stroke="white"/></svg>';
const iconTemplate          = '<svg width="17" height="17" viewBox="0 -1 17 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 0.5H14C15.3807 0.5 16.5 1.61929 16.5 3V15.5H0.5V3C0.5 1.61929 1.61929 0.5 3 0.5Z" stroke="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 14 4)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 9 6)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 12 9)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 7 11)" fill="white"/></svg>';
const iconManageTemplates   = '<svg width="14" height="17" viewBox="0 0 14 17" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="5.98706" height="1" transform="matrix(-1 0 0 1 13.0066 2.00244)" fill="white"/><path d="M2.02227 2.95511L3.4823 0.42627L4.34833 0.92627L2.23303 4.58008L0.263306 2.61035L0.970412 1.90324L2.02227 2.95511Z" fill="white"/><path d="M2.02227 6.94436L3.4823 4.41553L4.34833 4.91553L2.23303 8.56934L0.263306 6.59961L0.970412 5.8925L2.02227 6.94436Z" fill="white"/><path d="M2.02227 14.9488L3.4823 12.4199L4.34833 12.9199L2.23303 16.5737L0.263306 14.604L0.970412 13.8969L2.02227 14.9488Z" fill="white"/><rect width="5.98706" height="1" transform="matrix(-1 0 0 1 13.0066 6)" fill="white"/><rect width="5.98706" height="1" transform="matrix(-1 0 0 1 13.0066 10.0046)" fill="white"/><rect width="5.98706" height="1" transform="matrix(-1 0 0 1 13.0066 14.0093)" fill="white"/></svg>';

const iconRectangle         = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="15" height="15" stroke="white"/></svg>';
const iconLine              = '<svg width="17" height="17" viewBox="0 1 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="0.772299" y1="15.9778" x2="15.6598" y2="1.09027" stroke="white" stroke-width="1.3"/></svg>';
const iconEllipse           = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="7.5" stroke="white"/></svg>';
const iconTrapeze           = '<svg width="19" height="11" viewBox="0 0 19 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18.1743 10.5H0.825747C0.921495 10.3156 1.03249 10.101 1.15563 9.86141C1.58638 9.02341 2.16621 7.87943 2.76199 6.6565C3.35739 5.43438 3.97068 4.1294 4.46738 2.97042C4.86993 2.03115 5.20839 1.1597 5.39244 0.500019H13.6076C13.7916 1.1597 14.1301 2.03115 14.5326 2.97041C15.0293 4.12939 15.6426 5.43437 16.238 6.6565C16.8338 7.87942 17.4136 9.0234 17.8444 9.86141C17.9675 10.101 18.0785 10.3156 18.1743 10.5Z" stroke="white"/></svg>';
const iconPolygon           = '<svg width="20" height="16" viewBox="0 0 20 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.82238 15.4885L10.0496 1.23853L18.2769 15.4885H1.82238Z" stroke="white"/></svg>';
const iconStar              = '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.8156 2.24924L10.4021 7.13198L10.5144 7.47747H10.8776H16.0116L11.8581 10.4952L11.5642 10.7087L11.6765 11.0542L13.263 15.9369L9.10949 12.9192L8.8156 12.7057L8.5217 12.9192L4.3682 15.9369L5.9547 11.0542L6.06695 10.7087L5.77306 10.4952L1.61955 7.47747H6.75357H7.11684L7.2291 7.13198L8.8156 2.24924Z" stroke="white"/></svg>';
const iconTextShape         = '<svg width="13" height="16" viewBox="0 0 13 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 4V0H13V4H12V1H7V15H10V16H3V15H6V1H1V4H0Z" fill="white"/></svg>';
const iconSelected          = '<svg width="17" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3.5" y="3.5" width="4" height="4" stroke="white"/><circle cx="11.5" cy="5.5" r="2" stroke="white"/><line x1="3.43646" y1="14.8688" x2="7.93646" y2="10.1019" stroke="white"/><path d="M9.33494 14.4498L11.5 10.6998L13.6651 14.4498H9.33494Z" stroke="white"/><path d="M1.78814e-07 4H1L1 1H4V0H0L1.78814e-07 4Z" fill="white"/><path d="M17 14L16 14L16 17L13 17L13 18L17 18L17 14Z" fill="white"/><path d="M4 18L4 17L1 17L1 14L-1.74846e-07 14L0 18L4 18Z" fill="white"/><path d="M13 3.96837e-09L13 1L16 1L16 4L17 4L17 0L13 3.96837e-09Z" fill="white"/></svg>';
const iconPoint             = '<svg width="5" height="5" viewBox="0 0 5 5" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.5" cy="2.5" r="2.07507" fill="white"/></svg>';
const iconVectorPath        = '<svg width="19" height="15" viewBox="0 0 19 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.47559 10.6612C9.5585 -4.56423 10 20 16.1693 4.0354" stroke="white" stroke-width="1.5"/><circle cx="2.51324" cy="12.4753" r="1.72135" stroke="white" stroke-width="1.2"/><circle cx="16.5057" cy="2.4845" r="1.72135" stroke="white" stroke-width="1.2"/></svg>';
const iconVectorVertex      = '<svg width="7" height="6" viewBox="0 0 7 6" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="3" cy="3" r="1.89968" stroke="white" stroke-width="1.3"/></svg>';
const iconVectorEdge        = '<svg width="18" height="5" viewBox="0 0 18 5" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3.98364" y="2" width="8.9873" height="1" fill="white"/><circle cx="14.4824" cy="2.57507" r="1.72135" stroke="white" stroke-width="1.2"/><circle cx="2.51007" cy="2.57507" r="1.72135" stroke="white" stroke-width="1.2"/></svg>';
const iconVectorRegion      = '<svg width="16" height="12" viewBox="0 0 16 12" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="9" r="1.5" stroke="white"/><circle cx="2" cy="2" r="1.5" stroke="white"/><circle cx="14" cy="2" r="1.5" stroke="white"/><path d="M4.0001 2L3.24939 3.77671L7.0001 8.00003L8.0001 7.50003L9.0001 8.00003L12.7473 3.77671L12.0001 2H4.0001Z" fill="white" stroke="white"/></svg>';
const iconVectorNetwork     = '<svg width="18" height="19" viewBox="0 -1 18 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="9" cy="2" r="1.5" stroke="white"/><circle cx="9" cy="16" r="1.5" stroke="white"/><circle cx="2" cy="9" r="1.5" stroke="white"/><circle cx="16" cy="9" r="1.5" stroke="white"/><path d="M3.50001 9.71348L3.15479 10.1548L8.00001 15L9.00001 14.5L10 15L14.7725 10.2275L14.5 9.71348H3.50001Z" fill="white"/><path d="M3.50001 9.71348H14.5M3.50001 9.71348L3.30592 7.69404L7.78889 3.21112L9.00001 3.54484L10.2111 3.21112L14.6941 7.69404L14.5 9.71348M3.50001 9.71348L3.15479 10.1548L8.00001 15L9.00001 14.5L10 15L14.7725 10.2275L14.5 9.71348" stroke="white"/></svg>';
const iconBoolUnion         = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 0H0V11H5V16H16V5H11V0Z" fill="white"/></svg>';
const iconBoolSubtract      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 11V0H11V5H16V16H5V11H0ZM1 1H10V10H1V1Z" fill="white"/></svg>';
const iconBoolIntersect     = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11 5V0H0V11H5V16H16V5H11ZM10 1H1V10H5V5H10V1ZM6 11H11V6H15V15H6V11Z" fill="white"/></svg>';
const iconBoolExclude       = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11 0H0V11H5V16H16V5H11V0ZM11 5H5V11H11V5Z" fill="white"/></svg>';
const iconShapeGroup        = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2 12.0004L2 11.0004L1 11.0004L1 10L-4.37113e-08 10L0 12.0004L2 12.0004Z" fill="white"/><path d="M10.0002 0.000182931L10.0002 1.00018L11.0002 1.00018L11.0002 2.00055L12.0002 2.00055L12.0002 0.000183105L10.0002 0.000182931Z" fill="white"/><path d="M-0.000183193 2.00018H0.999817L0.999817 1.00018H2.00018V0.000183149L-0.000183105 0.000183105L-0.000183193 2.00018Z" fill="white"/><path d="M12.0004 10.0004L11.0004 10.0004L11.0004 11.0004L10 11.0004L10 12.0004L12.0004 12.0004L12.0004 10.0004Z" fill="white"/><rect y="5" width="1" height="2" fill="white"/><rect x="7" width="1" height="2" transform="rotate(90 7 0)" fill="white"/><rect x="11" y="5" width="1" height="2" fill="white"/><rect x="7" y="11" width="1" height="2" transform="rotate(90 7 11)" fill="white"/></svg>';
const iconFrame             = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 0H3V3H0V4H3V12H0V13H3V16H4V13H12V16H13V13H16V12H13V4H16V3H13V0H12V3H4V0ZM12 12V4H4V12H12Z" fill="white"/></svg>';

const iconMove              = '<svg width="17" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.69662 8.51082L3.70749 10.5217L2.86015 11.373L-1.54856e-05 8.51282L2.86015 5.65259L3.70752 6.49995L1.69662 8.51082Z" fill="white"/><path d="M8.50169 1.70956L6.49078 3.72043L5.63948 2.87309L8.4997 0.0129241L11.3599 2.87309L10.5126 3.72046L8.50169 1.70956Z" fill="white"/><path d="M15.3029 8.51469L13.292 6.50378L14.1394 5.65248L16.9995 8.5127L14.1394 11.3729L13.292 10.5256L15.3029 8.51469Z" fill="white"/><path d="M8.49782 15.3158L10.5087 13.305L11.36 14.1523L8.49981 17.0125L5.63959 14.1523L6.48694 13.3049L8.49782 15.3158Z" fill="white"/><rect x="8" y="0.990723" width="1" height="15.0186" fill="white"/><rect x="1" y="9" width="0.999999" height="15" transform="rotate(-90 1 9)" fill="white"/></svg>'; 
const iconRotate            = '<svg width="14" height="19" viewBox="0 0 14 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.9445 4.22796C5.01044 3.44178 1.99459 5.18299 1.20841 8.11705C0.713397 9.96445 1.21988 11.8445 2.39733 13.1809L1.64699 13.842C0.257648 12.265 -0.342805 10.0425 0.242481 7.85823C1.1716 4.3907 4.73579 2.33291 8.20332 3.26204L7.9445 4.22796Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M5.08235 14.772C8.01642 15.5582 11.0323 13.817 11.8184 10.883C12.3135 9.03555 11.807 7.15553 10.6295 5.81905L11.3799 5.158C12.7692 6.73498 13.3697 8.95745 12.7844 11.1418C11.8553 14.6093 8.29106 16.6671 4.82353 15.738L5.08235 14.772Z" fill="white"/><path d="M7.41666 3.52189L5.40579 1.51099L6.25314 0.659682L9.1133 3.5199L6.25314 6.38012L5.40576 5.53277L7.41666 3.52189Z" fill="white"/><path d="M5.61019 15.4781L7.62106 17.489L6.77372 18.3403L3.91356 15.4801L6.77372 12.6199L7.62109 13.4672L5.61019 15.4781Z" fill="white"/></svg>'; 
const iconScale             = '<svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 0V15H15V9H14V14L1 14V1L6 1V0H0Z" fill="white"/><path d="M10 1V2.38419e-07L15 0V5H14V1.70718L6.70718 9H10V10H5V5H6V8.29297L13.293 1L10 1Z" fill="white"/></svg>';
const iconSkew              = '<svg width="19" height="17" viewBox="0 0 19 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.75185 13.0498L4.85299 15.1509L4.04961 16.0462L0.564758 12.5613L4.02604 9.1001L4.85299 9.96779L2.77106 12.0496H8.03782V13.0498H2.75185Z" fill="white"/><path d="M16.2802 3.02754L14.1492 0.896574L14.9986 0.0472195L18.4673 3.516L15.0221 6.9613L14.1492 6.13945L16.261 4.02766L10.9942 4.02766L10.9942 3.02754L16.2802 3.02754Z" fill="white"/><rect x="8.03784" y="12.0476" width="3.98492" height="1" fill="white"/><rect x="10.9941" y="4.02979" width="3.94812" height="1" transform="rotate(-180 10.9941 4.02979)" fill="white"/><path d="M10.9083 12.532L13.0237 9.01649L14.0898 9.62791L12.0117 13.0475L10.9083 12.532Z" fill="white"/><path d="M8.20062 3.47107L6.03195 7.05296L4.94104 6.43312L7.02151 3.02985L8.20062 3.47107Z" fill="white"/></svg>'; 

const iconCenter            = '<svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="12" y="8" width="1" height="3" transform="rotate(-90 12 8)" fill="white"/><rect x="8" y="3" width="1" height="3" transform="rotate(180 8 3)" fill="white"/><rect y="8" width="1" height="3" transform="rotate(-90 0 8)" fill="white"/><rect x="8" y="15" width="1" height="3" transform="rotate(180 8 15)" fill="white"/><circle cx="7.5" cy="7.5" r="1.99719" fill="white"/></svg>'; 
const iconResetXform        = '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 16.6407C3.05477 16.6394 2.67167 16.5539 2.35069 16.3844C2.03144 16.2148 1.78552 15.9692 1.61296 15.6476C1.44211 15.326 1.35755 14.939 1.35928 14.4869C1.35928 14.0361 1.4447 13.6518 1.61554 13.3342C1.78811 13.0167 2.03402 12.7751 2.35328 12.6096C2.67426 12.4427 3.0565 12.3593 3.5 12.3593C3.9435 12.3593 4.32488 12.4427 4.64413 12.6096C4.96511 12.7764 5.21189 13.0187 5.38446 13.3363C5.55703 13.6525 5.64245 14.0361 5.64072 14.4869C5.64072 14.9404 5.55444 15.328 5.38187 15.6496C5.21102 15.9712 4.96598 16.2168 4.64672 16.3864C4.32747 16.556 3.94523 16.6407 3.5 16.6407ZM3.5 15.9161C3.80372 15.9161 4.04618 15.797 4.22738 15.5588C4.40858 15.3206 4.49831 14.9633 4.49659 14.4869C4.49659 14.1733 4.45517 13.9122 4.37234 13.7037C4.29123 13.4951 4.17561 13.3383 4.02547 13.2333C3.87706 13.1283 3.70191 13.0759 3.5 13.0759C3.198 13.0759 2.95641 13.1936 2.77521 13.4291C2.59401 13.6646 2.50255 14.0172 2.50082 14.4869C2.50082 14.8045 2.54138 15.0696 2.62249 15.2822C2.70532 15.4935 2.8218 15.6523 2.97194 15.7586C3.12207 15.8636 3.29809 15.9161 3.5 15.9161Z" fill="white"/><rect x="9" y="2" width="1" height="1" fill="white"/><rect x="12" y="2" width="1" height="1" fill="white"/><rect x="15" y="2" width="1" height="1" fill="white"/><rect x="15" y="5" width="1" height="1" fill="white"/><rect x="15" y="8" width="1" height="1" fill="white"/><path d="M15 13.9803L12.8691 11.8493L13.7184 11L17.1871 14.4688L13.742 17.9141L12.8691 17.0922L14.9808 14.9804L8 14.9804L8.00005 13.9803L15 13.9803Z" fill="white"/><path d="M3.00483 2.99995L0.873869 5.13092L0.0245147 4.28159L3.4933 0.812866L6.9386 4.25802L6.11675 5.13091L4.00496 3.01917L4.00497 9.99995L3.00483 10L3.00483 2.99995Z" fill="white"/></svg>'; 
const iconPlace             = '<svg width="19" height="17" viewBox="0 0 19 17" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="16.5371" cy="15.5" r="1.5" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M15.711 9.60649L18.1232 6.79155L19.0227 7.56237L16.0318 11.0527L16.0168 11.0398L15.9972 11.0787L11.9998 9.05711L12.5344 8L15.711 9.60649Z" fill="white"/><path d="M4.5 3.60622C6.33275 -0.178262 14.5351 -1.28238 15.8513 10.4285" stroke="white"/><rect x="0.5" y="7.5" width="8" height="8" stroke="white"/></svg>'; 

const iconApply             = '<svg width="18" height="15" viewBox="0 -1 18 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.99634 3.23086C1.99634 1.43758 3.48795 0.00793457 5.2978 0.00793457H13.7022C15.512 0.00793457 17.0037 1.43758 17.0037 3.23086V7.76908C17.0037 9.56236 15.512 10.992 13.7022 10.992H11.5V9.99201H13.7022C14.9868 9.99201 16.0037 8.98346 16.0037 7.76908V3.23086C16.0037 2.01648 14.9868 1.00793 13.7022 1.00793H5.2978C4.01324 1.00793 2.99634 2.01648 2.99634 3.23086V5H1.99634V3.23086Z" fill="white"/><path d="M0 7H9V8H0V7Z" fill="white"/><path d="M0 10H9V11H0V10Z" fill="white"/><path d="M0 13H9V14H0V13Z" fill="white"/></svg>'; 

const iconMeasurePoints     = '<svg width="19" height="11" viewBox="0 0 19 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M17.941 8.97729C17.8494 8.16451 17.652 7.36712 17.353 6.60789C17.2193 6.26837 17.0661 5.93856 16.8945 5.62019L14.9461 6.80328L14.4461 5.89243L16.3502 4.73622C16.096 4.3723 15.8154 4.02833 15.5104 3.70756C15.0432 3.21621 14.5243 2.78499 13.9647 2.42169L12.9331 4.301L12.0671 3.77512L13.084 1.92265C12.9747 1.86923 12.8643 1.8182 12.7528 1.76962C11.8758 1.38756 10.9453 1.16317 10 1.10459V3.19263H9V1.10459C8.05473 1.16317 7.12419 1.38756 6.24719 1.76962C6.13569 1.8182 6.02529 1.86922 5.91606 1.92264L6.93298 3.77516L6.06695 4.30104L5.0353 2.42168C4.4757 2.78498 3.95677 3.2162 3.48959 3.70756C3.1846 4.02834 2.90397 4.37232 2.64977 4.73625L4.55383 5.89246L4.05383 6.80331L2.10552 5.62023C1.93393 5.93859 1.78073 6.26838 1.64702 6.60789C1.34801 7.36712 1.15058 8.16451 1.05903 8.9773H3V8.45145H4V8.9773H6V8.45145H7V8.9773H9V8.45145H10V8.97729H12V8.45145H13V8.97729H15V8.45145H16V8.97729H17.941ZM9.5 1.08911L9.5076 1.08911H9.4924L9.5 1.08911ZM18.9472 8.97729C18.8515 8.0261 18.6262 7.09245 18.2769 6.20539C17.7994 4.99315 17.0997 3.89167 16.2175 2.96385C15.3354 2.03604 14.2881 1.30006 13.1355 0.797926C11.9829 0.295796 10.7476 0.0373535 9.5 0.0373535C8.25244 0.0373535 7.0171 0.295797 5.86451 0.797927C4.71191 1.30006 3.66464 2.03604 2.78249 2.96385C1.90033 3.89167 1.20056 4.99315 0.723144 6.2054C0.373796 7.09245 0.148508 8.02611 0.0527776 8.9773C0.0176828 9.326 0 9.67707 0 10.0291L19 10.0291C19 9.67706 18.9823 9.326 18.9472 8.97729Z" fill="white"/></svg>';
const iconInterpolatePoint  = '<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="9.49994" cy="9.5" r="2.23029" fill="white"/><rect x="7.18933" y="11.1549" width="1" height="6.55226" transform="rotate(45 7.18933 11.1549)" fill="white"/><rect x="15.7516" y="2.59253" width="1" height="6.44359" transform="rotate(45 15.7516 2.59253)" fill="white"/><rect x="4.37927" y="18.3553" width="1" height="5.20878" transform="rotate(135 4.37927 18.3553)" fill="white"/><rect x="19" y="3.72803" width="1" height="5.20878" transform="rotate(135 19 3.72803)" fill="white"/></svg>';
const iconPointOnPath       = '<svg width="19" height="13" viewBox="0 0 19 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1 12C2.76415 6.68092 4.4811 5.02129 6.69323 5.73749M18 1C16.1827 6.33161 14.3236 8.15818 12.2682 7.40999" stroke="white" stroke-width="1.5"/><circle cx="9.5" cy="6.5" r="2.07507" fill="white"/></svg>';

const iconRender            = '<svg width="18" height="17" viewBox="0 0 18 17" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="17" height="16" rx="1.5" stroke="white"/><rect x="3.5" y="3.5" width="4" height="4" stroke="white"/><circle cx="12.5" cy="5.5" r="2" stroke="white"/><line x1="3.43646" y1="14.6568" x2="7.93646" y2="9.88989" stroke="white"/><path d="M10.3349 13.75L12.5 10L14.6651 13.75H10.3349Z" stroke="white"/></svg>';
const iconRenderDown        = '<svg width="18" height="17" viewBox="0 0 18 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.81598 4.18533H4.18663V6.81467H6.81598V4.18533Z" fill="white"/><path d="M13.8147 5.5C13.8147 6.22607 13.2261 6.81467 12.5 6.81467C11.7739 6.81467 11.1853 6.22607 11.1853 5.5C11.1853 4.77393 11.7739 4.18533 12.5 4.18533C13.2261 4.18533 13.8147 4.77393 13.8147 5.5Z" fill="white"/><path d="M11.5401 13.0542L12.5 11.3917L13.4599 13.0542H11.5401Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2 0C0.895431 0 0 1.01482 0 2.26667V14.7333C0 15.9852 0.89543 17 2 17H16C17.1046 17 18 15.9852 18 14.7333V2.26667C18 1.01482 17.1046 0 16 0L2 0ZM2.83663 2.83533V8.16467H8.16598V2.83533H2.83663ZM15.1647 5.5C15.1647 6.97166 13.9717 8.16467 12.5 8.16467C11.0283 8.16467 9.83533 6.97166 9.83533 5.5C9.83533 4.02834 11.0283 2.83533 12.5 2.83533C13.9717 2.83533 15.1647 4.02834 15.1647 5.5ZM8.42428 10.4267L3.92428 15.1936L2.9426 14.2669L7.4426 9.5L8.42428 10.4267ZM12.5 8.69165L15.7981 14.4042H9.20187L12.5 8.69165Z" fill="white"/></svg>';

const iconGroup             = '<svg width="17" height="17" viewBox="0 -1 17 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 0.5H14C15.3807 0.5 16.5 1.61929 16.5 3V15.5H0.5V3C0.5 1.61929 1.61929 0.5 3 0.5Z" stroke="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 14 4)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 9 6)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 12 9)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 7 11)" fill="white"/></svg>';
const iconGroupNode         = '<svg width="15" height="18" viewBox="0 -3 15 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 0.5H12C13.3807 0.5 14.5 1.61929 14.5 3V14.5H0.5V3C0.5 1.61929 1.61929 0.5 3 0.5Z" stroke="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 12 5)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 12 8)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 12 11)" fill="white"/></svg>';
const iconGroupParam        = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="10" height="10" rx="1.5" stroke="white"/><circle cx="5.5" cy="5.5" r="1.5" fill="white"/></svg>';


const iconHand              = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.85653 12.2494L1.8554 12.2484C1.32015 11.771 1.2929 10.8911 1.7976 10.3815C2.3023 9.87193 3.1824 9.89065 3.665 10.4213L3.67129 10.4282L3.67773 10.435L4.27294 11.0653L5.99999 12.8943V10.3788V4C5.99999 3.46423 6.46423 3 6.99999 3C7.16906 3 7.33572 3.04789 7.48718 3.13836L7.99999 3.44469V9H8.99999V4.04203V3V2.27986V2C8.99999 1.46423 9.46423 1 9.99999 1C10.4142 1 10.807 1.27942 10.9437 1.66905L11.0597 2H11V9H12V2.4661L12.4437 2.16905C12.6058 2.06052 12.804 2 13 2C13.5358 2 14 2.46423 14 3V4V4.27549V6.02711V9H15V5.43676L15.5084 5.13662C15.6583 5.04814 15.8261 5 16 5C16.5358 5 17 5.46423 17 6V13.5C17 15.6001 15.7227 17.6052 13.812 18.4904C11.8955 19.3783 9.56768 19.0654 7.95351 17.7039L1.85653 12.2494ZM15 4.27549V4V3.17508V3C15 1.91195 14.088 1 13 1C12.9434 1 12.8868 1.00246 12.8304 1.00733C12.4943 1.03638 12.1668 1.15099 11.8873 1.3381C11.7759 1.02046 11.5846 0.741833 11.341 0.522228C10.9792 0.195965 10.5019 0 9.99999 0C9.18005 0 8.46014 0.517876 8.15511 1.23874C8.05538 1.47446 7.99999 1.73188 7.99999 2V2.27986C7.70403 2.10307 7.36184 2.00018 7.00094 2H6.99999C5.91195 2 4.99999 2.91195 4.99999 4V8.92652V9.18641V9.20713V10.3788L4.40481 9.74846C4.2821 9.61355 4.14593 9.49706 3.99999 9.39906C3.11355 8.80379 1.86654 8.89082 1.08709 9.67785C0.179345 10.5944 0.227074 12.136 1.18978 12.9947L7.2972 18.4585C9.20886 20.0788 11.9586 20.4512 14.2324 19.3978C16.4971 18.3486 18 15.989 18 13.5V6C18 4.91195 17.088 4 16 4C15.6382 4 15.2958 4.10085 15 4.27549Z" fill="white"/></svg>';

const iconComment           = '<svg width="18" height="17" viewBox="0 0 18 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5375L3.6897 11.045C3.24801 10.1283 3 9.09994 3 8.01086C3 4.14487 6.13401 1.01086 10 1.01086C13.866 1.01086 17 4.14487 17 8.01086C17 11.8769 13.866 15.0109 10 15.0109C8.89526 15.0109 7.85296 14.7557 6.92628 14.302L6.65842 14.1708L6.36249 14.2078L1.94388 14.7601L3.64047 12.0032L3.92701 11.5375ZM0.671856 14.9191L0 16.0109L1.27203 15.8519L6.48652 15.2001C7.5471 15.7194 8.73951 16.0109 10 16.0109C14.4183 16.0109 18 12.4292 18 8.01086C18 3.59258 14.4183 0.0108643 10 0.0108643C5.58172 0.0108643 2 3.59258 2 8.01086C2 9.25344 2.28329 10.4299 2.78881 11.4791L0.671856 14.9191Z" fill="white"/></svg>';
const iconPanel             = '<svg width="18" height="17" viewBox="0 0 18 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.85164 16.7724L2.23469 15.8486C2.46912 15.9458 2.72697 16 3 16H3.91667V17H3C2.59323 17 2.20536 16.919 1.85164 16.7724ZM13.0833 17V16H14C14.273 16 14.5309 15.9458 14.7653 15.8486L15.1484 16.7724C14.7946 16.919 14.4068 17 14 17H13.0833ZM17 3.91667H16V3C16 2.72697 15.9458 2.46912 15.8486 2.23469L16.7724 1.85164C16.919 2.20536 17 2.59323 17 3V3.91667ZM3.91667 0H3C2.59323 0 2.20536 0.0809584 1.85164 0.227641L2.23469 1.15137C2.46912 1.05415 2.72697 1 3 1H3.91667V0ZM0 13.0833H1V14C1 14.273 1.05415 14.5309 1.15137 14.7653L0.227641 15.1484C0.0809584 14.7946 0 14.4068 0 14V13.0833ZM0 11.25H1V9.41667H0V11.25ZM0 7.58333H1V5.75H0V7.58333ZM0 3.91667H1V3C1 2.72697 1.05415 2.46912 1.15137 2.23469L0.227642 1.85164C0.0809585 2.20536 0 2.59323 0 3V3.91667ZM5.75 0V1H7.58333V0H5.75ZM9.41667 0V1H11.25V0H9.41667ZM13.0833 0V1H14C14.273 1 14.5309 1.05415 14.7653 1.15137L15.1484 0.227642C14.7946 0.0809585 14.4068 0 14 0H13.0833ZM17 5.75H16V7.58333H17V5.75ZM17 9.41667H16V11.25H17V9.41667ZM17 13.0833H16V14C16 14.273 15.9458 14.5309 15.8486 14.7653L16.7724 15.1484C16.919 14.7946 17 14.4068 17 14V13.0833ZM11.25 17V16H9.41667V17H11.25ZM7.58333 17V16H5.75V17H7.58333Z" fill="white"/></svg>';


const iconWindowNormal      = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect x="4" y="4" width="7" height="4" fill="white"/></svg>';
const iconWindowMaximize    = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="15" height="12" fill="white"/></svg>';
const iconWindowDockLeft    = '<svg width="15" height="12" viewBox="fcop7y0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect width="7" height="12" fill="white"/></svg>';
const iconWindowDockRight   = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect x="8" width="7" height="12" fill="white"/></svg>';
const iconWindowDockTop     = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect width="15" height="5" fill="white"/></svg>';
const iconWindowDockBottom  = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect y="7" width="15" height="5" fill="white"/></svg>';


const iconSolo              = '<svg width="20" height="19" viewBox="0 0 20 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.08057 9.99671L9.99653 4.08074L12.9243 9.63767L18.5816 15.2949C18.9721 15.6854 18.9944 16.2963 18.6313 16.6594L16.6594 18.6313C16.2963 18.9944 15.6854 18.9721 15.2949 18.5816L9.63806 12.9247L4.08057 9.99671ZM9.40454 11.7438L5.69967 9.79182L9.79164 5.69984L11.7436 9.40471L9.40454 11.7438ZM10.2954 12.2674L12.2674 10.2954L17.9242 15.9522L15.9522 17.9242L10.2954 12.2674Z" fill="white"/><rect x="2.08472" y="2.79199" width="1" height="4.01147" transform="rotate(-45 2.08472 2.79199)" fill="white"/><rect y="6.25903" width="1" height="3.71342" transform="rotate(-60 0 6.25903)" fill="white"/><rect width="1" height="3.70373" transform="matrix(-0.866025 0.5 0.5 0.866025 6.26465 0.00756836)" fill="white"/></svg>';


const iconSearch            = '<svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path id="searchIconPath" fill-rule="evenodd" clip-rule="evenodd" d="M11 6C11 8.76147 8.76147 11 6 11C3.23853 11 1 8.76147 1 6C1 3.23853 3.23853 1 6 1C8.76147 1 11 3.23853 11 6ZM9.87439 10.5815C8.8291 11.4663 7.47681 12 6 12C2.68628 12 0 9.31372 0 6C0 2.68628 2.68628 0 6 0C9.31372 0 12 2.68628 12 6C12 7.47681 11.4664 8.8291 10.5815 9.87451L14.364 13.657L13.6569 14.364L9.87439 10.5815Z" fill="white"/></svg>';


var currentMenus      = [];
var currentMenuButton = null;



class Menu
{
    parentMenu = null;
    parentItem = null;

    name;
    button     = null;
    fromButton = false;

    div;
    divArrow;
    divItems;

    showChecks;
    showIcons;

    showOnLeft = false;

    combineChecksAndIcons = false; // conflicts are resolved in favor of icons

    overMenu = false;

    items    = [];
    lastItem = null;

    reverse  = false;
    
    minWidth = 200;

    init     = null; // ()

    visible  = false;


    onHide   = null; // removes itself after firing



    constructor(name, showIcons = true, showChecks = true)
    {
        this.name       = name;

        this.showIcons  = showIcons;
        this.showChecks = showChecks;

        this.div        = createDiv('menu');
        this.divArrow   = createDiv('menuArrow');
        this.divItems   = createDiv('menuItems');

        this.div.appendChild(this.divItems);

        this.div.addEventListener('pointerenter', () => this.overMenu = true );
        this.div.addEventListener('pointerleave', () => this.overMenu = false);
    }



    clearItems()
    {
        while (this.divItems.firstChild)
            this.divItems.removeChild(this.divItems.firstChild);

        this.items    = [];
        this.lastItem = null;
    }



    addItems(items)
    {
        for (let i = 0; i < items.length; i++)
        {
            const item = items[i];

            if (i > 0) 
                item.div.appendChild(document.createElement('br'));

            if (!this.showIcons  && item.divIcon ) item.divIcon .style.display = 'none';
            if (!this.showChecks && item.divCheck) item.divCheck.style.width   = this.showIcons ? 18 : 15;

            item.parentMenu = this;
            item.index      = i;

            this.items.push(item);
            this.divItems.appendChild(item.div);
        }


        if (   !this.lastItem
            && !isEmpty(this.items))
            this.lastItem = this.items[0];


        if (this.button)
            this.button.update();
    }



    initMenu(callInit = true)
    {
        const e = { cancel: false };

        if (   callInit
            && this.init)
            this.init(e);

        if (e.cancel)
            return false;


        utilContext.font = '12px Inter';

        
        let width = 0;

        for (const item of this.items)
        {
            const mesName     = utilContext.measureText(item.name);
            const mesShortcut = utilContext.measureText(item.shortcut);

            let checksAndIcons = 
                  (item.parentMenu.showChecks  ? 32 : 0)
                + (item.parentMenu.showIcons   ? 32 : 0)
                + (item.childMenu != undefined ? 32 : 0);

            if (this.combineChecksAndIcons)
                checksAndIcons = Math.min(checksAndIcons, 32);

            width = Math.max(
                  width, 
                  checksAndIcons
                + mesName.width 
                + 30 
                + mesShortcut.width 
                + (mesShortcut.width > 0 ? 20 : 0));


            if (this.combineChecksAndIcons)
            {
                item.divCheck.style.display = item.icon == NULL ? 'inline-block' : 'none';
                item.divIcon .style.display = item.icon != NULL ? 'inline-block' : 'none';
            }
        }


        for (const item of this.items)
        {
            if (item.updateLegend) 
                item.updateLegend();
        }


        this.divItems.style.width = Math.max(this.minWidth, width) + 'px';

        return true;
    }



    show(srcDiv, subMenu, right = false, callInit = true)
    {
        if (graphView._soloNode);
            graphView.unsoloNode();


        if (!this.initMenu(callInit))
            return;


        this.div.style.display = 'block';
        this.div.style.opacity = '100%';


        if (!right)
        {
            this.divArrow.style.display = 'block';
            this.divArrow.style.opacity = '100%';
        }


        document.body.appendChild(this.div     );
        document.body.appendChild(this.divArrow);


        let srcRect = srcDiv.getBoundingClientRect();

        srcRect.y -= 5;


        const margin = 8;

        const x = Math.min(Math.max(
            margin, 
            right
            ? (this.showOnLeft ? srcRect.x - this.div.offsetWidth : srcRect.x + srcRect.width)
            : srcRect.x + srcRect.width/2 - this.div.offsetWidth/2),
            graphView.div.offsetWidth - this.div.offsetWidth - margin);


        const dy = subMenu ? 4 : -1;

        const y =
            right
            ? srcRect.y - dy - 3
            : srcRect.y - dy + srcRect.height + this.divArrow.offsetHeight;


        this.showAt(x + 6, y, subMenu, false);
        
            
        const menuRect = this.div.getBoundingClientRect();
        
        this.divArrow.style.left = srcRect.x + srcRect.width/2;
        this.divArrow.style.top  = menuRect.y - this.divArrow.offsetHeight + 2;


        if (   this.button
            && this.fromButton)
            this.button.update();
    }



    showAt(x, y, subMenu, hidePrev = true)
    {
        if (graphView._soloNode);
            graphView.unsoloNode();


        if (hidePrev)
            hideAllMenus();

        hideSearchBox();


        this.initMenu();


        this.div.style.display = 'block';
        this.div.style.opacity = '100%';

        document.body.appendChild(this.div);


        this.update(x, y, subMenu);


        currentMenus.push(this);

        
        this.visible = true;
    }



    update(x, y, subMenu)
    {
        const margin = 8;

        const  dy  = subMenu ? 0 : 4;
        const _dy  = subMenu ? 4 : 0;

        let   left = Math.max(margin, x) - 6;
        let   top  = y - dy;


        let height = 0;
        
        for (const item of this.items)
            if (item.div.style.display != 'none')
                height += item.separator ? 17 : 25;


        if (this.parentItem)
        {
            if (left + this.div.offsetWidth + margin >= graphView.div.offsetWidth)
                left = this.parentItem.parentMenu.div.offsetLeft - this.div.offsetWidth;
        }
        else
        {
            if (left + this.div.offsetWidth > graphView.div.offsetWidth - margin)
                left = graphView.div.offsetWidth - this.div.offsetWidth - margin;
        }


        const graphHeight = graphView.div.offsetHeight - getTopHeight();

        if (top + height > graphView.div.offsetHeight - margin)
        {
            height = Math.min(height, graphHeight - margin*2);
            top    = getTopHeight() + Math.max(8, graphHeight - height);
            
            if (!subMenu)
                left += 10; // so it doesn't hit a menu item by accident once the menu appears
        }


        this.div.style.left = left;
        this.div.style.top  = top + _dy;


        this.div.style.overflowY = 
            top + height > graphHeight-8 
            ? 'overlay' 
            : 'hidden';

        
        this.div.style.height = height + 'px';
    }



    hide()
    {
        if (this.onHide)
        {
            this.onHide();
            this.onHide = null;
        }


        this.div     .style.display = 'none';
        this.div     .style.opacity = '0%';

        this.divArrow.style.display = 'none';
        this.divArrow.style.opacity = '0%';


        if (    this.button
            && !this.button.overArrow)
        {
            this.button.divArrow.style.transform  = 'translateY(0)';
            this.button.div     .style.background = 'transparent';
        }


        removeFrom(currentMenus, this);


        this.visible = false;

        if (this.parentItem)
            this.parentItem.update();
    }
}



function hideAllMenus()
{
    for (let i = currentMenus.length-1; i >= 0; i--)
        currentMenus[i].hide();
}



function hideAllMenusAfter(menu)
{
    const index = currentMenus.indexOf(menu);

    for (let i = currentMenus.length-1; i > index; i--)
        currentMenus[i].hide();
}



function disableCurrentMenuButton()
{
    if (currentMenuButton)
    {
        const curMenuButton = currentMenuButton;
        currentMenuButton = null;
        curMenuButton.update();
    }
}


class MenuButton
{
    name;
    menu;

    icon          = NULL;

    callback;
    highlight;
    useMenuName   = true;
    afterLabel;
    noHighlight   = false;

    selectLast;

    
    div;

    divIcon;
    divArrow;
    
    over          = false;
    overArrow     = false;
    

    tooltip       = null;
    customTooltip = false;



    constructor(name, menu, options = {})
    {
        this.name = name;
        this.menu = menu;

        if (this.menu)
            this.menu.button = this;


        this.initOptions(options);
        
        this.createControls();
        this.createTooltip();

        this.update();
    }



    initOptions(options)
    {
        this.callback    ??= options.callback;
        this.highlight   ??= options.highlight;
        this.useMenuName = options.useMenuName != undefined ? options.useMenuName : true;

        this.selectLast  ??= options.selectLast;
        this.afterLabel  ??= options.afterLabel;
        this.noHighlight = options.noHighlight != undefined ? options.noHighlight : false;


        if (!!options.tooltip)
        {
            this.tooltip = options.tooltip;
            this.customTooltip = true;
        }
    }



    createControls()
    {
        this.div      = createDiv('menuButton');

        this.divIcon  = createDiv('menuButtonIcon');
        this.divArrow = createDiv('menuButtonArrow');


        this.div.addEventListener('pointerenter', () => 
        {
            this.over = true;
            this.update();
        });
   

        this.div.addEventListener('pointerleave', () => 
        {
            this.over = false;
            this.update();
        });


        if (this.menu) 
        {
            this.div.addEventListener('pointerdown', e => 
            {
                if (e.button == 0)
                {
                    disableCurrentMenuButton();

                    e.stopPropagation();
                    this.showMenu();
                    
                    this.update();
                }
            });


            if (this.useMenuName) this.createArrowEvents(this.div);
            else                  this.createArrowEvents(this.divArrow);
            

            this.divArrow.addEventListener('pointerdown', e => 
            {
                if (e.button == 0)
                {
                    e.stopPropagation();
                    this.showMenu();
                    this.update();
                }
            });
        }
        
        
        if (this.callback) 
        {
            this.div.addEventListener('click', () =>
            {
                disableCurrentMenuButton();
                this.callback();
            });
        }


        this.div.appendChild(this.divIcon);

        if (this.menu)
            this.div.appendChild(this.divArrow);


        if (this.afterLabel)
            menuBar.appendChild(this.div);
        else
            menuBar.insertBefore(this.div, pageName);
    }



    createTooltip()
    {
        if (!this.tooltip)
        {
            const ttName = 
                this.menu 
                ? this.menu.name 
                : this.name;

            this.tooltip = createDiv('tooltip', 'ttMenuButtonIcon' + ttName);
        }

        
        document.body.appendChild(this.tooltip);
        

        createTooltip(this.tooltip);

        if (this.name != '-')
            createTooltipSrc(this.div, this.div, () => this.tooltip);
    }



    createArrowEvents(div)
    {
        div.addEventListener('pointerenter', e =>
        {
            this.overArrow = true;
            this.moveArrowDown();
        });


        div.addEventListener('pointerleave', e =>
        {
            if (!currentMenus.includes(this.menu))
                this.moveArrowUp();

            this.overArrow = false;
        });
    }



    moveArrowDown()
    {
        this.divArrow.style.transform = 'translateY(3px)';
    }



    moveArrowUp()
    {
        this.divArrow.style.transform = 'translateY(0)';
    }



    setIcon(icon)
    {
        this.icon = icon;
        this.update();
    }



    showMenu()
    {
        const curMenus = [...currentMenus];

        hideAllMenus();
        
        if (!curMenus.includes(this.menu))
            this.menu.show(this.div, null);
    }



    update()
    {
        this.div.style.background =
               currentMenuButton == this
            ||    this.highlight 
               && this.highlight()
            ? 'var(--figma-color-bg-brand)'
            : (this.over && !this.noHighlight)
              ? '#111'
              : 'transparent';


        const icon = 
            this.icon != NULL
            ? this.icon
            :    this.menu
              && this.menu.lastItem
              ? this.menu.lastItem.icon
              : NULL;

        this.divIcon.style.background         = 'url(\'data:image/svg+xml;utf8,' + icon + '\')';
        this.divIcon.style.backgroundPosition = '100% 50%';
        this.divIcon.style.backgroundRepeat   = 'no-repeat';

        this.div.style.width = 
            this.name != '-'
            ? (this.menu ? 50 : 40)
            : 24;


        if (!this.customTooltip)
        {
            if (this.useMenuName)
                this.tooltip.innerHTML = 
                    this.menu 
                    ? this.menu.name 
                    : this.name;
            else
                this.tooltip.innerHTML = 
                    this.menu
                    && this.menu.lastItem
                    ? this.menu.lastItem.name
                    : this.name;        
        }
    }
}


class MenuItem
{
    parentMenu    = null;
    index         = -1;

    enabled       = true;

    checked       = false;
    icon          = ''; // svg
    name          = '';
    searchName    = '';
    shortcut      = '';

    callback      = null;
    checkCallback = null;

    childMenu     = null;

    separator     = false;
    createType    = '';

    selectOnDrag  = false;

    isSetting     = false;
    disambiguate  = false;

    enteredDiv    = false;
    enteredExpand = false;

    arrowWidth    = 48;

    showSubscribe = false;


    div;
    divHighlight;

    divLegend;
    divCheck;
    divIcon;
    divName;
    divExpand;
    divShortcut;
    divSubscribe;


    divSeparator;


    mouseOver = false;



    constructor(name, searchName, options = {})
    {
        this.name       = name;
        this.searchName = searchName ?? name;

        this.initOptions(options);
        this.createControls();

        this.update();
    }



    initOptions(options)
    {
        if (options.icon          != undefined) this.icon          = options.icon;
        if (options.checkCallback != undefined) this.checkCallback = options.checkCallback;
        if (options.callback      != undefined) this.callback      = options.callback;
        if (options.childMenu     != undefined) 
        { 
            this.childMenu = options.childMenu;  

            if (this.childMenu)
                this.childMenu.parentMenu = this.parentMenu; 
        }
        if (options.separator     != undefined) this.separator     = options.separator;
        if (options.selectOnDrag  != undefined) this.selectOnDrag  = options.selectOnDrag;
        if (options.shortcut      != undefined) this.shortcut      = options.shortcut;
        if (options.enabled       != undefined) this.enabled       = options.enabled;
        if (options.setting       != undefined) this.isSetting     = options.setting;
        if (options.disambiguate  != undefined) this.disambiguate  = options.disambiguate;
        if (options.createType    != undefined) this.createType    = options.createType;
    }



    createControls()
    {
        this.div          = createDiv('menuItem' + (this.disambiguate ? ' disambiguate' : ''));
        this.divHighlight = createDiv('menuItemHighlight');

        this.divLegend    = createDiv('menuItemLegend'   );
        this.divCheck     = createDiv('menuItemCheck'    );
        this.divIcon      = createDiv('menuItemIcon'     );
        this.divName      = createDiv('menuItemName'     );
        this.divExpand    = createDiv('menuItemExpand'   );
        this.divShortcut  = createDiv('menuItemShortcut' );
        this.divSubscribe = createDiv('menuItemSubscribe');

        this.divSeparator = createDiv('menuSeparator'    );


        this.div.style.pointerEvents = this.separator ? 'none' : 'all';


        this.setName(this.name, this.searchName);

        
        if (this.childMenu)
            this.divExpand.style.visibility = 'visible';


        this.setIcon(this.icon);

    
        this.divShortcut .innerHTML = this.shortcut;
        this.divSubscribe.innerHTML = 'SUBSCRIBE';

    
        this.divHighlight.style.zIndex = -2;

        
        if (!this.separator)
        {
            this.div.appendChild(this.divHighlight);

            this.div.appendChild(this.divLegend   );
            this.div.appendChild(this.divCheck    );
            this.div.appendChild(this.divIcon     );

            this.div.appendChild(this.divName     );
            this.div.appendChild(this.divExpand   );
            this.div.appendChild(this.divShortcut );
            this.div.appendChild(this.divSubscribe);
        }
        else
            this.div.appendChild(this.divSeparator);


        this.updateLegend();



        this.div.addEventListener('pointerdown', e => 
        {
            e.stopPropagation();
            e.preventDefault();


            if (e.button == 0)
            {
                this.button0 = true;

                try
                {
                    this.div.setPointerCapture(e.pointerId);
                    this.dragStart = point(e.clientX, e.clientY);
                }
                catch {}
            }
        });



        this.div.addEventListener('pointerup', e => 
        {
            e.stopPropagation();
            e.preventDefault();


            if (e.button == 0)
            {
                const rect = boundingRect(this.div);

                if (   this.callback
                    && this.childMenu)
                {
                    if (e.clientX - rect.x < rect.width - this.arrowWidth)
                        this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);
                }
                else if (this.callback)
                    this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);

                    
                this.button0 = false;

                this.div.releasePointerCapture(e.pointerId);
            }
        });



        this.div.addEventListener('pointermove', e =>
        {
            if (this.enabled)
            {
                this.mouseOver = true;
                this.update();


                if (   this.button0
                    && this.callback
                    && distance(this.dragStart, clientPos(e)) > 5)
                {
                    const rect = boundingRect(this.div);

                    if (   this.callback
                        && this.childMenu)
                    {
                        if (e.clientX - rect.x < rect.width - this.arrowWidth)
                            this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);
                    }
                    else if (this.callback)
                        this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);

                    
                    this.button0 = false;

                    if (!e.shiftKey)
                        hideAllMenus();


                    const node = graph.pageNodes.at(-1);

                    node.div.shiftOnPointerDown = false;

                    node.sx  = node.div.offsetLeft;
                    node.sy  = node.div.offsetTop ;

                    node.slx = node.div.offsetLeft - (defNodeWidth    / 2) - (               + graph.currentPage.pan.x) / graph.currentPage.zoom;
                    node.sly = node.div.offsetTop  - (defHeaderHeight / 2) - (getTopHeight() + graph.currentPage.pan.y) / graph.currentPage.zoom;

                    try
                    {
                        if (this.div.hasPointerCapture(e.pointerId))
                            this.div.releasePointerCapture(e.pointerId);

                        node.header.setPointerCapture(e.pointerId);

                        node.div.dragging = true;
                    }
                    catch {}
                }
                else
                {
                    if (   this.callback
                        && this.childMenu)
                    {
                        const rect = boundingRect(this.div);

                        if (    e.clientX - rect.x < rect.width - this.arrowWidth
                            && !this.enteredDiv)
                        {
                            this.divHighlight.style.left  = 0;
                            this.divHighlight.style.width = 'calc(100% - ' + (this.childMenu && this.callback ? this.arrowWidth : 0) + 'px)';

                            hideAllMenusAfter(this.parentMenu);

                            this.enteredDiv    = true;
                            this.enteredExpand = false;
                        }
                        else if ( e.clientX - rect.x >= rect.width - this.arrowWidth
                            && !this.enteredExpand)
                        {
                            this.divHighlight.style.left  = 0;
                            this.divHighlight.style.width = '100%';

                            this.showChildMenu();

                            this.enteredDiv    = false;
                            this.enteredExpand = true;
                        }
                    }
                    else if (!this.enteredDiv)
                    {
                        this.divHighlight.style.left  = 0;
                        this.divHighlight.style.width = '100%';

                        this.showChildMenu();

                        this.enteredDiv    = true;
                        this.enteredExpand = false;
                    }
                }
            }
        });
    

    
        this.div.addEventListener('pointerleave', () =>
        {
            this.mouseOver = false;
            this.update();

            this.enteredDiv    = false;
            this.enteredExpand = false;
        });


        this.update();
    }



    setName(name, searchName = null)
    {
        this.name              = name;
        this.searchName        = searchName ?? name;
        this.divName.innerHTML = name;
    }



    setIcon(icon)
    {
        if (icon != '')
        {
            this.divIcon.style.background         = 'url(\'data:image/svg+xml;utf8,' + icon + '\')';
            this.divIcon.style.backgroundPosition = '50% 50%';
            this.divIcon.style.backgroundRepeat   = 'no-repeat';
        }
        else
            this.divIcon.style.background         = 'transparent';
    }



    updateLegend()
    {
        this.divLegend.style.background = 
               this.createType != ''
            && settings.showColorLegendInMenus
            ?  rgb2style(rgbFromType(this.createType, true))
            : 'transparent';
    }



    showChildMenu()
    {
        if (this.childMenu)
        {
            if (!currentMenus.includes(this.childMenu))
            {
                hideAllMenusAfter(this.parentMenu);

                this.childMenu.parentItem = this;
                this.childMenu.show(this.div, true, true);
            }
        }
        else
            hideAllMenusAfter(this.parentMenu);
    }



    select(shift = false, ctrl = false, alt = false, x = Number.NaN, y = Number.NaN)
    {
        if (!this.enabled)
            return;


        if (!isEmpty(currentMenus)) // this lets the item be selected without its parent menu being involved
        {
            if (this.parentMenu.button)
                this.parentMenu.button.update();
        }

        if (!shift) 
            hideAllMenus();


        const e = 
        {
            shiftKey: shift,
            ctrlKey:  ctrl,
            altKey:   alt
        };


        if (!isNaN(x)) e.clientX = x;
        if (!isNaN(y)) e.clientY = y;

        if (this.callback)
            this.callback(e);
    }



    setChecked(checked)
    {
        this.checked = checked;
        this.update();
    }



    setEnabled(enabled)
    {
        this.enabled = enabled;
        this.update();
    }



    setVisible(visible)
    {
        this.div.style.display = visible ? 'inline-block' : 'none';
    }



    update()
    {
        this.divHighlight.style.background = 
               this.mouseOver
            ||    this.childMenu
               && this.childMenu.visible
            ? 'var(--figma-color-bg-brand)'
            : 'transparent';

        this.divCheck    .style.visibility = this.checked   ? 'visible'      : 'hidden';
        this.div         .style.opacity    = this.enabled   ? '100%'         : '40%';

        this.divShortcut .style.display    = this.subscribe === true ? 'none'         : 'inline-block';
        this.divSubscribe.style.display    = this.subscribe === true ? 'inline-block' : 'none';

        this.updateLegend();
    }
}


var btnMain;
var btnFlow;
var btnData;
var btnSets;
var btnNumber;
var btnText;
var btnColor;
var btnLayer;
//var btnStyle;
var btnShape;
var btnTemplate;
var btnGroup;
var btnHand;
var btnComment;
var btnPanel;
var btnPage;
var btnSolo;
var btnZoom;


var menuBarMenus;


var menuMain;
var menuMainFile;
var menuMainPreferences;
var menuMainDebug;
var menuMainHelp;

var menuShowTooltips;

var menuLogGenerator;
var menuLogStorage;
var menuLogMessages;

var menuDebugDelete;

var menuFlow;
var menuData;
var menuNumber;
var menuSets;
var menuString;
var menuConvert;
var menuColor;
var menuColorStyle;
var menuLayer;
var menuEffects;
var menuStyles;
var menuVariables;
var menuShape;
var menuTemplate;
var menuGroup;

var menuMath;
var menuBoolean;
var menuCondition;
var menuTrig;
var menuFunctions;

var menuVector;
var menuShapes;
var menuTransform;

var menuPage;

var menuZoom;
var menuWindow;


var wholeMenu;
var menuGraph;
var menuNode;
var menuNodeCopyAs;
var menuNodeHighlight;
var menuNodeSelect;


var menuLocalStyles;
var menuSelectParam;

var menuRemoveLicense;

var menuText;
var menuTextbox;

var menuCopy;

var menuPageData;
var menuPageDataPages;
var menuNodeData;
var menuNodeDataNodes;
var menuConnData;
var menuConnDataConns;

var menuItemShowTooltipLongText;
var menuItemShowTooltipColorInterpolation;
var menuItemShowTooltipColorContrast;
var menuItemShowTooltipColorBlindness;


var menuItemEnableZoomedOutParams;
var menuItemMinZoomForParams;
var menuItemShowPages;
var menuPrefSep1;
var menuItemShowAllColorSpaces;
var menuItemShowNodeIcons;
var menuItemShowColorLegendInMenus;
var menuItemShowBoolValues;
var menuItemShowOperationResults;
var menuItemShowClearUndoWarning;
var menuItemShowTooltips;
var menuItemShowDebugMenu;
var menuPrefSep2;

var menuItemShowNodeId;
var menuItemShowTransformPoints;
var menuItemEnableAsserts;

var menuFileSep1;
var menuItemSaveToFile;

var menuItemDebug;
var menuItemDebugLog;

var menuItemHelp;


//var menuItemEnableBetaFeatures;


var menuItemList;  
var menuFlowSep1;
var menuItemItems;
var menuItemSelect;
var menuItemCount;
var menuItemIfElse;
var menuFlowSep2;
var menuFlowSep3;
var menuItemStart;
var menuItemRepeat;
var menuFlowSep4;
var menuItemNull;
var menuItemCache;
var menuItemFreeze;
var menuItemTimer;
var menuFlowSep5;
var menuItemAnimate;  
var menuItemFetch;
var menuItemTextFile;

var menuItemArray;
var menuItemRange;
var menuItemSequence;

var menuItemDateTime;

var menuNumberSep1;
var menuItemSolve;  

var menuItemTextJson;

var menuItemColor;
var menuItemCorrectColor;
var menuItemConvertToP3;
var menuItemColorSep1;
var menuItemColorblind;
var menuItemColorBlend;


var menuItemLayerFill;
var menuItemLayerStroke;
var menuItemLayerSep1;
var menuItemLayerDropShadow;
var menuItemLayerInnerShadow;
var menuItemLayerLayerBlur;
var menuItemLayerBackBlur;
var menuItemStyleSep2;


var menuItemShapeSep1;
var menuItemShapeSelected;
var menuItemShapeRender;

var menuItemManageTemplates;

var menuItemDataMode;

var menuItemLogThreadMessages;
var menuItemLogDataMessages;
var menuItemLogMessages;
var menuItemLogActions;
var menuItemLogLoading;
var menuItemLogRequests;
var menuItemLogValueUpdates;
var menuItemLogObjectUpdates;
var menuItemLogStyleUpdates;
var menuItemLogRawLoadPages;
var menuItemLogRawLoadNodes;
var menuItemLogRawLoadConnections;
var menuItemLogRawSavePages;
var menuItemLogRawSaveNodes;
var menuItemLogRawSaveConnections;
var menuItemLogRawRequests;
var menuItemLogRawValues;

var menuItemZoomTo100;

var menuItemWindowNormal;
var menuItemWindowMaximize;
var menuItemWindowTop;
var menuItemWindowLeft;
var menuItemWindowRight;
var menuItemWindowBottom;

var menuItemGraphPaste;
var menuItemGraphPasteConnected;

var menuItemNodeEditGroup;
var menuItemNodeSepGroup;
var menuItemNodeCopy;
var menuItemNodeCopyAsJsCode;
var menuItemNodeCopyAsJsFunction;
var menuItemNodePaste;
var menuItemNodePasteConnected;
var menuItemNodeRemove;
var menuItemNodeLayout;
var menuItemNodeLayoutSep;
var menuItemNodeSep1;
var menuItemNodeGroupSelected;
var menuItemNodeUngroup;
var menuItemNodeSep2;
var menuItemNodeRename;
//var menuItemNodeEdit;
var menuItemNodeSep3;
var menuItemNodeHighlight;
var menuItemNodeSelect;
// var menuItemNodeBringToFront;
// var menuItemNodeSendToBack;
//var menuItemNodeActivate;
var menuItemNodeSaveAsTemplate;
var menuItemNodeSep4;
var menuItemNodeEnableDisable;


var menuItemLicenseSep1;
var menuItemLicenseRemove;

``

function initGeneratorMenus()
{
    menuShowTooltips = new Menu('Show tooltips', false);
    menuShowTooltips.addItems([
        menuItemShowTooltipLongText           = new MenuItem('Long text',           null, {checkCallback: () => settings.showTooltipLongText,           callback: () => { updateSettingAndMenu('showTooltipLongText',           true, !settings.showTooltipLongText          ); }}),
        menuItemShowTooltipColorContrast      = new MenuItem('Color contrast',      null, {checkCallback: () => settings.showTooltipColorContrast,      callback: () => { updateSettingAndMenu('showTooltipColorContrast',      true, !settings.showTooltipColorContrast     ); }}),
        menuItemShowTooltipColorInterpolation = new MenuItem('Color interpolation', null, {checkCallback: () => settings.showTooltipColorInterpolation, callback: () => { updateSettingAndMenu('showTooltipColorInterpolation', true, !settings.showTooltipColorInterpolation); }}),
        menuItemShowTooltipColorBlindness     = new MenuItem('Color blindness',     null, {checkCallback: () => settings.showTooltipColorBlindness,     callback: () => { updateSettingAndMenu('showTooltipColorBlindness',     true, !settings.showTooltipColorBlindness    ); }})]);


    menuMainFile = new Menu('File', false);
    menuMainFile.addItems([
                             new MenuItem('Import from file...',      null, {callback: () => { hideAllMenus(); uiImportFromLocalFile(); }}),
        menuFileSep1       = new MenuItem('',                         null, {separator: true}),    
        menuItemSaveToFile = new MenuItem('Save selected to file...', null, {shortcut: osCtrlShift() + 'S', callback: () => { hideAllMenus(); uiSaveSelectionToLocalFile(); }})]);


    menuMainPreferences = new Menu('Preferences', false);
    menuMainPreferences.addItems([
        // menuItemShowPages           = new MenuItem('Show pages',                    null, {checkCallback: () => settings.showAllColorSpaces,     callback: () => { updateSettingAndMenu('showPages',              true, !settings.showPages);              updateMenuItemShowPages();              }}),
        // menuPrefSep1                = new MenuItem('',                              null, {separator: true}),    
        menuItemShowAllColorSpaces     = new MenuItem('Show all color spaces',         null, {checkCallback: () => settings.showAllColorSpaces,     callback: () => { updateSettingAndMenu('showAllColorSpaces',     true, !settings.showAllColorSpaces);     updateMenuItemShowAllColorSpaces();     }}),
        menuItemShowOperationResults   = new MenuItem('Show operation results',        null, {checkCallback: () => settings.showOperationResults,   callback: () => { updateSettingAndMenu('showOperationResults',   true, !settings.showOperationResults);   updateMenuItemShowOperationResults();   }}),
        menuItemShowNodeIcons          = new MenuItem('Show node icons',               null, {checkCallback: () => settings.showNodeIcons,          callback: () => { updateSettingAndMenu('showNodeIcons',          true, !settings.showNodeIcons);          updateMenuItemShowNodeIcons();          }}),
        menuItemShowBoolValues         = new MenuItem('Show boolean values as   ✓ ✗', null, {checkCallback: () => settings.showBoolValues,         callback: () => { updateSettingAndMenu('showBoolValues',         true, !settings.showBoolValues);         updateMenuItemShowBoolValues();         }}),
        //menuItemShowColorLegendInMenus = new MenuItem('Show color legend in menus',    null, {checkCallback: () => settings.showColorLegendInMenus, callback: () => { updateSettingAndMenu('showColorLegendInMenus', true, !settings.showColorLegendInMenus); updateMenuItemShowColorLegendInMenus(); }}),
                                         new MenuItem('',                              null, {separator: true}),    
        menuItemShowTooltips           = new MenuItem('Show tooltips',                 null, {childMenu: menuShowTooltips}),
        menuItemShowClearUndoWarning   = new MenuItem('Show clear undo warning',       null, {checkCallback: () => settings.showClearUndoWarning,   callback: () => { updateSettingAndMenu('showClearUndoWarning',   true, !settings.showClearUndoWarning);                                           }}),
        menuItemShowDebugMenu          = new MenuItem('Show debug menu',               null, {checkCallback: () => settings.showDebugMenu,          callback: () => { updateSettingAndMenu('showDebugMenu',          true, !settings.showDebugMenu);          updateMenuItemShowDebugMenu();          }}),
        menuPrefSep2                   = new MenuItem('',                              null, {separator: true}),    
        // menuItemEnableBetaFeatures  = new MenuItem('Enable beta features',          null, {checkCallback: () => settings.enableBetaFeatures,     callback: () => { updateSettingAndMenu('enableBetaFeatures',     true, !settings.enableBetaFeatures);     enableFeatures(true, settings.enableBetaFeatures); }}),
        //                               new MenuItem('',                              null, {separator: true}),    
        menuItemMinZoomForParams       = new MenuItem('Zoom level for values...',      null, {callback: () => showMinZoomDialog()})]);
        

    menuItemShowBoolValues.divName.innerHTML = 'Show boolean values as   <span style="position: relative; top: 1px;">' + TRUE_DISPLAY_MENU + '</span>  <span>' + FALSE_DISPLAY_MENU + '</span>'


    menuLogGenerator = new Menu('Log generator', false);
    menuLogGenerator.addItems([
        menuItemLogRequests       = new MenuItem('Requests',          null, {checkCallback: () => settings.logRequests     ,      callback: () => updateSettingAndMenu('logRequests',           true, !settings.logRequests          ), setting: true}),
        menuItemLogValueUpdates   = new MenuItem('Values',            null, {checkCallback: () => settings.logValueUpdates ,      callback: () => updateSettingAndMenu('logValueUpdates',       true, !settings.logValueUpdates      ), setting: true}),
        menuItemLogObjectUpdates  = new MenuItem('Objects',           null, {checkCallback: () => settings.logObjectUpdates,      callback: () => updateSettingAndMenu('logObjectUpdates',      true, !settings.logObjectUpdates     ), setting: true}),
        menuItemLogStyleUpdates   = new MenuItem('Styles',            null, {checkCallback: () => settings.logStyleUpdates ,      callback: () => updateSettingAndMenu('logStyleUpdates',       true, !settings.logStyleUpdates      ), setting: true}),
                                    new MenuItem('',                  null, {separator: true}),                   
        menuItemLogRawRequests    = new MenuItem('Raw\u2008requests', null, {checkCallback: () => settings.logRawRequests  ,      callback: () => updateSettingAndMenu('logRawRequests',        true, !settings.logRawRequests       ), setting: true}),
        menuItemLogRawValues      = new MenuItem('Raw\u2008values',   null, {checkCallback: () => settings.logRawValues    ,      callback: () => updateSettingAndMenu('logRawValues',          true, !settings.logRawValues         ), setting: true})]);
                     


    menuLogStorage = new Menu('Log storage', false);
    menuLogStorage.addItems([
        menuItemLogLoading            = new MenuItem('Load\u2008at start',  null, {checkCallback: () => settings.logLoading      ,      callback: () => updateSettingAndMenu('logLoading',            true, !settings.logLoading           ), setting: true}),
                                        new MenuItem('',                    null, {separator: true}),                   
        menuItemLogRawLoadPages       = new MenuItem('Load pages',          null, {checkCallback: () => settings.logRawLoadPages ,      callback: () => updateSettingAndMenu('logRawLoadPages',       true, !settings.logRawLoadPages      ), setting: true}),
        menuItemLogRawSavePages       = new MenuItem('Save pages',          null, {checkCallback: () => settings.logRawSavePages ,      callback: () => updateSettingAndMenu('logRawSavePages',       true, !settings.logRawSavePages      ), setting: true}),
                                        new MenuItem('',                    null, {separator: true}),                   
        menuItemLogRawLoadNodes       = new MenuItem('Load nodes',          null, {checkCallback: () => settings.logRawLoadNodes ,      callback: () => updateSettingAndMenu('logRawLoadNodes',       true, !settings.logRawLoadNodes      ), setting: true}),
        menuItemLogRawSaveNodes       = new MenuItem('Save nodes',          null, {checkCallback: () => settings.logRawSaveNodes ,      callback: () => updateSettingAndMenu('logRawSaveNodes',       true, !settings.logRawSaveNodes      ), setting: true}),
                                        new MenuItem('',                    null, {separator: true}),                   
        menuItemLogRawLoadConnections = new MenuItem('Load connections',    null, {checkCallback: () => settings.logRawLoadConnections, callback: () => updateSettingAndMenu('logRawLoadConnections', true, !settings.logRawLoadConnections), setting: true}),
        menuItemLogRawSaveConnections = new MenuItem('Save connections',    null, {checkCallback: () => settings.logRawSaveConnections, callback: () => updateSettingAndMenu('logRawSaveConnections', true, !settings.logRawSaveConnections), setting: true}),
                                        new MenuItem('',                    null, {separator: true}),
                                        new MenuItem('All page keys',       null, {callback:      () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllSavedPageKeys', darkMode: darkMode}); }}),
                                        new MenuItem('All connection keys', null, {callback:      () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllSavedConnKeys', darkMode: darkMode}); }}),
                                        new MenuItem('',                    null, {separator: true}),   
                                        new MenuItem('All pages',           null, {callback:      () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllSavedPages',    darkMode: darkMode}); }}),
                                        new MenuItem('',                    null, {separator: true}),   
                                        new MenuItem('All local data',      null, {callback:      () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllLocalData',     darkMode: darkMode}); }}),
                                        new MenuItem('',                    null, {separator: true}),   
                                        new MenuItem('Undo stack',          null, {callback:      () => { hideAllMenus(); logUndoStack(); }}),
                                        new MenuItem('Redo stack',          null, {callback:      () => { hideAllMenus(); logRedoStack(); }})]);
                     

    menuLogMessages = new Menu('Log messages', false);
    menuLogMessages.addItems([
        menuItemLogThreadMessages = new MenuItem('Thread messages', null, {checkCallback: () => settings.logThreadMessages,     callback: () => updateSettingAndMenu('logThreadMessages',     true, !settings.logThreadMessages    ), setting: true}),
        menuItemLogDataMessages   = new MenuItem('Data messages',   null, {checkCallback: () => settings.logDataMessages  ,     callback: () => updateSettingAndMenu('logDataMessages',       true, !settings.logDataMessages      ), setting: true}),
        menuItemLogMessages       = new MenuItem('Other messages',  null, {checkCallback: () => settings.logMessages     ,      callback: () => updateSettingAndMenu('logMessages',           true, !settings.logMessages          ), setting: true})]);
                     


    menuDebugDelete = new Menu('Debug generator', false);
    menuDebugDelete.addItems([
        new MenuItem('All saved pages',       null, {callback: () => { hideAllMenus(); uiRemoveAllSavedPages(); }}),
        new MenuItem('',                      null, {separator: true}),                   
        new MenuItem('Connections to...',     null, {callback: () => showDeleteConnectionsDialog()}),                        
        new MenuItem('All saved connections', null, {callback: () => { hideAllMenus(); uiRemoveAllSavedConnections(); }}),
        new MenuItem('',                      null, {separator: true}),                   
        new MenuItem('All style links',       null, {callback: () => { hideAllMenus(); uiRemovePluginDataFromAllLocalStyles(); }}),
        new MenuItem('',                      null, {separator: true}),                   
        new MenuItem('All local data',        null, {callback: () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figClearAllLocalData'}); }})]);
                     

    menuMainDebug = new Menu('Debug', false);
    menuMainDebug.addItems([
    menuItemShowNodeId = new MenuItem('Show node IDs', null,
                        {
                            checkCallback: () => settings.showNodeId, 
                            callback:      () => 
                            {
                                updateSettingAndMenu('showNodeId', true, !settings.showNodeId);
                                    
                                graph.nodes.forEach(n => n.updateNode());
                                graph.nodes.forEach(n => n.updateMeasureData());
                                graph.nodes.forEach(n => n.updateHeaderLabelOffsetX());

                                graph.updatePages();

                                pushUpdate(null, graph.nodes.filter(n => n.active));
                            }
                        }),
    // menuItemShowTransformPoints = new MenuItem('Show transforms', null,
    //                     {
    //                         checkCallback: () => settings.showTransformPoints, 
    //                         callback:      () => 
    //                         {
    //                             updateSettingAndMenu('showTransformPoints', true, !settings.showTransformPoints);
    //                             pushUpdate(null, graph.nodes.filter(n => n.active));
    //                         }
    //                     }),
    menuItemEnableAsserts = new MenuItem('Enable asserts', null,
                         {
                             checkCallback: () => settings.enableAsserts, 
                             callback:      () => updateSettingAndMenu('enableAsserts', true, !settings.enableAsserts)
                         }),
                         new MenuItem('',                      null, {separator: true}),
    menuItemLogActions = new MenuItem('Log actions',           null, {checkCallback: () => settings.logActions, callback: () => updateSettingAndMenu('logActions', true, !settings.logActions), setting: true}),
                         new MenuItem('Log messages',          null, {childMenu: menuLogMessages}),
                         new MenuItem('Log storage',           null, {childMenu: menuLogStorage}),
                         new MenuItem('Log generator',         null, {childMenu: menuLogGenerator}),
                         new MenuItem('',                      null, {separator: true}),   
                         new MenuItem('Delete',                null, {childMenu: menuDebugDelete}),
                         new MenuItem('',                      null, {separator: true}),   
    menuItemDataMode   = new MenuItem('Restart in debug mode', null, {checkCallback: () => settings.dataMode, callback: () => uiRestartGenerator(true)})]);
                     

    menuMainHelp = new Menu('Help and subscription', false);
    menuMainHelp.addItems([
        new MenuItem('Keyboard shortcuts', null, {shortcut: osCtrlShift() + '?', callback: () => showKeyboardPanel()}),
        // new MenuItem('Help page',   null, {callback:  () => window.open('http://www.bourt.com/generator/help', '_blank')}),
        new MenuItem('',             null, {separator: true}),
        new MenuItem('Subscription', null, {callback:  () => showSubscriptionDialog()}),
      //new MenuItem('',             null, {separator: true}),
        new MenuItem('About',        null, {callback:  () => showAboutDialog()})]);


    menuMain = new Menu('Main menu', false);
    menuMain.addItems([
                        new MenuItem('File',                  null, {childMenu: menuMainFile}),
                        new MenuItem('',                      null, {separator: true}),
                        new MenuItem('Preferences',           null, {childMenu: menuMainPreferences}),
        menuItemDebug = new MenuItem('Debug',                 null, {childMenu: menuMainDebug}),
                        new MenuItem('',                      null, {separator: true}),
        menuItemHelp  = new MenuItem('Help and subscription', null, {childMenu: menuMainHelp })]);


    menuFlow = new Menu('Flow', true, false);
    menuFlow.addItems([
        menuItemStart    = new MenuItem('Start. . .',        null, {icon: iconStart,     createType: START,            callback: e => actionManager.do(getCreateNodeAction(START,           btnFlow.div, getCreateOptions(e)))}),
        menuItemRepeat   = new MenuItem('. . . Repeat',      null, {icon: iconRepeat,    createType: REPEAT,           callback: e => actionManager.do(getCreateNodeAction(REPEAT,          btnFlow.div, getCreateOptions(e)))}),
                           new MenuItem('',                  null, {separator: true}),
        menuItemNull     = new MenuItem('Null',              null, {icon: iconNull,      createType: NULL_NODE,        callback: e => actionManager.do(getCreateNodeAction(NULL_NODE,       btnFlow.div, getCreateOptions(e)))}),
                           new MenuItem('',                  null, {separator: true}),
        menuItemIfElse   = new MenuItem('I&hairsp;f / else', null, {icon: iconIfElse,    createType: IF_ELSE,          callback: e => actionManager.do(getCreateNodeAction(IF_ELSE,         btnFlow.div, getCreateOptions(e))), disambiguate: true}),
        //menuItemCache    = new MenuItem('Cache',             null, {icon: iconCache,     createType: CACHE,            callback: e => actionManager.do(getCreateNodeAction(CACHE,           btnFlow.div, getCreateOptions(e)))}),
        //menuItemFreeze   = new MenuItem('Freeze. . .',       null, {icon: iconFreeze,    createType: FREEZE,           callback: e => actionManager.do(getCreateNodeAction(FREEZE,          btnFlow.div, getCreateOptions(e)))}),
                           new MenuItem('',                  null, {separator: true}),
        menuItemTimer    = new MenuItem('Timer ',            null, {icon: iconTimer,     createType: TIMER,            callback: e => actionManager.do(getCreateNodeAction(TIMER,           btnFlow.div, getCreateOptions(e)))}),
        menuItemAnimate  = new MenuItem('Animate',           null, {icon: iconAnimate,   createType: NUMBER_ANIMATE,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_ANIMATE,  btnFlow.div, getCreateOptions(e)))}),
        menuFlowSep5     = new MenuItem('',                  null, {separator: true}),
        menuItemFetch    = new MenuItem('Fetch',             null, {icon: iconTextFetch, createType: TEXT_FETCH,       callback: e => actionManager.do(getCreateNodeAction(TEXT_FETCH,      btnFlow.div, getCreateOptions(e)))}),
        menuItemTextFile = new MenuItem('Text file',         null, {icon: iconTextFile,  createType: TEXT_FILE,        callback: e => actionManager.do(getCreateNodeAction(TEXT_FILE,       btnFlow.div, getCreateOptions(e)))})]);
    

    menuData = new Menu('Data', true, false);
    menuData.addItems([
        menuItemList     = new MenuItem('List',         null,            {icon: iconList,        createType: LIST,         callback: e => actionManager.do(getCreateNodeAction(LIST,          btnData.div, getCreateOptions(e)))}),
        menuFlowSep1     = new MenuItem('',             null,            {separator: true}),     
        menuItemItems    = new MenuItem('Items',        null,            {icon: iconItems,       createType: ITEMS,        callback: e => actionManager.do(getCreateNodeAction(ITEMS,         btnData.div, getCreateOptions(e)))}),
        menuItemCount    = new MenuItem('Count',        null,            {icon: iconCount,       createType: LIST_COUNT,   callback: e => actionManager.do(getCreateNodeAction(LIST_COUNT,    btnData.div, getCreateOptions(e)))}),
                           new MenuItem('Contains',     'List contains', {icon: iconContains,    createType: CONTAINS,     callback: e => actionManager.do(getCreateNodeAction(CONTAINS,      btnData.div, getCreateOptions(e))), disambiguate: true}),
                           new MenuItem('',             null,            {separator: true}),     
        menuItemSelect   = new MenuItem('Select',       null,            {icon: iconSelect,      createType: SELECT,       callback: e => actionManager.do(getCreateNodeAction(SELECT,        btnData.div, getCreateOptions(e)))}),
                           new MenuItem('Sublist',      null,            {icon: iconSublist,     createType: SUBLIST,      callback: e => actionManager.do(getCreateNodeAction(SUBLIST,       btnData.div, getCreateOptions(e)))}),
                           new MenuItem('Unique',       null,            {icon: iconUnique,      createType: UNIQUE,       callback: e => actionManager.do(getCreateNodeAction(UNIQUE,        btnData.div, getCreateOptions(e)))}),
                           new MenuItem('',             null,            {separator: true}),     
                           new MenuItem('Reverse',      null,            {icon: iconReverseList, createType: REVERSE_LIST, callback: e => actionManager.do(getCreateNodeAction(REVERSE_LIST,  btnData.div, getCreateOptions(e)))}),
                           new MenuItem('Sort',         null,            {icon: iconSort,        createType: SORT,         callback: e => actionManager.do(getCreateNodeAction(SORT,          btnData.div, getCreateOptions(e)))}),
                           new MenuItem('',             null,            {separator: true}),     
                           new MenuItem('Column',       null,            {icon: iconColumn,      createType: COLUMN,       callback: e => actionManager.do(getCreateNodeAction(COLUMN,        btnData.div, getCreateOptions(e)))}),
                           new MenuItem('Cell',         null,            {icon: iconCell,        createType: CELL,         callback: e => actionManager.do(getCreateNodeAction(CELL,          btnData.div, getCreateOptions(e)))}),
                           new MenuItem('',             null,            {separator: true}),     
                           new MenuItem('List as item', null,            {icon: iconCondense,    createType: CONDENSE,     callback: e => actionManager.do(getCreateNodeAction(CONDENSE,      btnData.div, getCreateOptions(e)))}),
                           new MenuItem('Value name',   null,            {icon: iconValueName,   createType: VALUE_NAME,   callback: e => actionManager.do(getCreateNodeAction(VALUE_NAME,    btnData.div, getCreateOptions(e)))})]);
    

    menuSets = new Menu('Sets...', true, false);
    menuSets.addItems([
        menuItemSequence   = new MenuItem('Sequence . . .',   null, {icon: iconSequence,    createType: NUMBER_SEQUENCE,    callback: e => actionManager.do(getCreateNodeAction(NUMBER_SEQUENCE,    btnSets.div, getCreateOptions(e)))}),
        menuItemRange = new MenuItem('Range . . .',      null, {icon: iconRange,  createType: NUMBER_RANGE,  callback: e => actionManager.do(getCreateNodeAction(NUMBER_RANGE,  btnSets.div, getCreateOptions(e)))}),
        menuItemArray      = new MenuItem('Define . . .',     null, {icon: iconDefine,      createType: DEFINE,             callback: e => actionManager.do(getCreateNodeAction(DEFINE,             btnSets.div, getCreateOptions(e)))}),
                             new MenuItem('',                 null, {separator: true}),
                             new MenuItem('Random . . .',     null, {icon: iconRandom,      createType: NUMBER_RANDOM,      callback: e => actionManager.do(getCreateNodeAction(NUMBER_RANDOM,      btnSets.div, getCreateOptions(e)))}),
                             new MenuItem('Noise . . .',      null, {icon: iconNoise,       createType: NUMBER_NOISE,       callback: e => actionManager.do(getCreateNodeAction(NUMBER_NOISE,       btnSets.div, getCreateOptions(e)))}),
                             new MenuItem('Probability. . .', null, {icon: iconProbability, createType: NUMBER_PROBABILITY, callback: e => actionManager.do(getCreateNodeAction(NUMBER_PROBABILITY, btnSets.div, getCreateOptions(e)))}),
                             new MenuItem('',                 null, {separator: true}),
                             new MenuItem('Accumulate. . .',  null, {icon: iconAccumulate,  createType: NUMBER_ACCUMULATE,  callback: e => actionManager.do(getCreateNodeAction(NUMBER_ACCUMULATE,  btnSets.div, getCreateOptions(e)))})]);
        
    
    menuMath = new Menu('Math', true, false);
    menuMath.addItems([
        // new MenuItem('Power',     null, {icon: iconExponent, callback: e => actionManager.do(getCreateNodeAction(NUMBER_EXPONENT, btnNumber.div, getCreateOptions(e)))}),
        // new MenuItem('Multiply',  null, {icon: iconMultiply, callback: e => actionManager.do(getCreateNodeAction(NUMBER_MULTIPLY, btnNumber.div, getCreateOptions(e)))}),
        // new MenuItem('Divide',    null, {icon: iconDivide,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_DIVIDE,   btnNumber.div, getCreateOptions(e)))}),
        // new MenuItem('Remainder', null, {icon: iconModulo,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_MODULO,   btnNumber.div, getCreateOptions(e)))}),
        // new MenuItem('Add',       null, {icon: iconAdd,      callback: e => actionManager.do(getCreateNodeAction(NUMBER_ADD,      btnNumber.div, getCreateOptions(e)))}),
        // new MenuItem('Subtract',  null, {icon: iconSubtract, callback: e => actionManager.do(getCreateNodeAction(NUMBER_SUBTRACT, btnNumber.div, getCreateOptions(e)))})]);
        new MenuItem('Math',  null, {icon: iconMulti, createType: NUMBER_MATH, callback: e => actionManager.do(getCreateNodeAction(NUMBER_MATH, btnNumber.div, getCreateOptions(e)))})]);
        

    menuBoolean = new Menu('Boolean', true, false);
    menuBoolean.addItems([
        new MenuItem('And', null, {icon: iconAnd, createType: NUMBER_AND, callback: e => actionManager.do(getCreateNodeAction(NUMBER_AND, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Or',  null, {icon: iconOr , createType: NUMBER_OR,  callback: e => actionManager.do(getCreateNodeAction(NUMBER_OR,  btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Xor', null, {icon: iconXor, createType: NUMBER_XOR, callback: e => actionManager.do(getCreateNodeAction(NUMBER_XOR, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Not', null, {icon: iconNot, createType: NUMBER_NOT, callback: e => actionManager.do(getCreateNodeAction(NUMBER_NOT, btnNumber.div, getCreateOptions(e)))})]);
        
    
    menuCondition = new Menu('Conditional', true, false);
    menuCondition.addItems([
        new MenuItem('Greater',          null, {icon: iconGreater,        createType: NUMBER_GREATER,          callback: e => actionManager.do(getCreateNodeAction(NUMBER_GREATER,          btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Greater or equal', null, {icon: iconGreaterOrEqual, createType: NUMBER_GREATER_OR_EQUAL, callback: e => actionManager.do(getCreateNodeAction(NUMBER_GREATER_OR_EQUAL, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Equal',            null, {icon: iconEqual,          createType: NUMBER_EQUAL,            callback: e => actionManager.do(getCreateNodeAction(NUMBER_EQUAL,            btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Not equal',        null, {icon: iconNotEqual,       createType: NUMBER_NOT_EQUAL,        callback: e => actionManager.do(getCreateNodeAction(NUMBER_NOT_EQUAL,        btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Less or equal',    null, {icon: iconLessOrEqual,    createType: NUMBER_LESS_OR_EQUAL,    callback: e => actionManager.do(getCreateNodeAction(NUMBER_LESS_OR_EQUAL,    btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Less',             null, {icon: iconLess,           createType: NUMBER_LESS,             callback: e => actionManager.do(getCreateNodeAction(NUMBER_LESS,             btnNumber.div, getCreateOptions(e)))})]);
        
    
    menuTrig = new Menu('Trigonometric', true, false);
    menuTrig.addItems([
        new MenuItem('Sine',    null, {icon: iconSine,    createType: NUMBER_SIN, callback: e => actionManager.do(getCreateNodeAction(NUMBER_SIN, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Cosine',  null, {icon: iconCosine,  createType: NUMBER_COS, callback: e => actionManager.do(getCreateNodeAction(NUMBER_COS, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Tangent', null, {icon: iconTangent, createType: NUMBER_TAN, callback: e => actionManager.do(getCreateNodeAction(NUMBER_TAN, btnNumber.div, getCreateOptions(e)))})]);
        
    
    menuFunctions = new Menu('Functions', true, false);
    menuFunctions.addItems([
                           new MenuItem('Sign',        null, {icon: iconSign,      createType: NUMBER_SIGN,     callback: e => actionManager.do(getCreateNodeAction(NUMBER_SIGN,     btnNumber.div, getCreateOptions(e)))}),
                           new MenuItem('Absolute',    null, {icon: iconAbsolute,  createType: NUMBER_ABSOLUTE, callback: e => actionManager.do(getCreateNodeAction(NUMBER_ABSOLUTE, btnNumber.div, getCreateOptions(e)))}),
                           new MenuItem('Round',       null, {icon: iconRound,     createType: NUMBER_ROUND,    callback: e => actionManager.do(getCreateNodeAction(NUMBER_ROUND,    btnNumber.div, getCreateOptions(e)))}),
                           new MenuItem('Min / max',   null, {icon: iconMinMax,    createType: NUMBER_MINMAX,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_MINMAX,   btnNumber.div, getCreateOptions(e)))}),
                           new MenuItem('Limits',      null, {icon: iconLimits,    createType: NUMBER_LIMITS,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_LIMITS,   btnNumber.div, getCreateOptions(e)))}),  new MenuItem('', null, {separator: true}),
                           new MenuItem('Constant',    null, {icon: iconConstant,  createType: NUMBER_CONSTANT, callback: e => actionManager.do(getCreateNodeAction(NUMBER_CONSTANT, btnNumber.div, getCreateOptions(e)))}),
                           new MenuItem('',            null, {separator: true}),
        menuItemDateTime = new MenuItem('Date & time', null, {icon: iconDateTime,  createType: NUMBER_DATETIME, callback: e => actionManager.do(getCreateNodeAction(NUMBER_DATETIME, btnNumber.div, getCreateOptions(e)))})]);
        

    menuConvert = new Menu('Text', true, false);
    menuConvert.addItems([
        new MenuItem('Text to number',       null, {icon: iconTextToNumber,  createType: TEXT_TO_NUMBER, callback: e => actionManager.do(getCreateNodeAction(TEXT_TO_NUMBER, btnText.div, getCreateOptions(e)))}),
        new MenuItem('Text to color',        null, {icon: iconTextToColor,   createType: TEXT_TO_COLOR,  callback: e => actionManager.do(getCreateNodeAction(TEXT_TO_COLOR,  btnText.div, getCreateOptions(e)))}),
        new MenuItem('',                     null, {separator: true}),
        new MenuItem('Number to text',       null, {icon: iconNumberToText,  createType: NUMBER_TO_TEXT, callback: e => actionManager.do(getCreateNodeAction(NUMBER_TO_TEXT, btnText.div, getCreateOptions(e)))}),
        new MenuItem('',                     null, {separator: true}),
        new MenuItem('Unicode to character', null, {icon: iconTextCharacter, createType: TEXT_CHAR,      callback: e => actionManager.do(getCreateNodeAction(TEXT_CHAR,      btnText.div, getCreateOptions(e)))})]);
    

    menuNumber = new Menu('Numbers', true, false);
    menuNumber.addItems([
                         new MenuItem('Number',        null,                 {icon: iconNumber,      createType: NUMBER, callback: e => actionManager.do(getCreateNodeAction(NUMBER,             btnNumber.div, getCreateOptions(e)))}),
                         new MenuItem('',              null,                 {separator: true}),
                         new MenuItem('Value',         null,                 {icon: iconRound,       childMenu: menuFunctions}),
                         new MenuItem('',              null,                 {separator: true}),
                         new MenuItem('Math',          null,                 {icon: iconMath,        childMenu: menuMath,          createType: NUMBER_SIMPLE_MATH, callback: e => actionManager.do(getCreateNodeAction(NUMBER_SIMPLE_MATH, btnNumber.div, getCreateOptions(e)))}),
                         new MenuItem('Boolean',       null,                 {icon: iconBoolean,     /*childMenu: menuBoolean,  */ createType: NUMBER_BOOLEAN,     callback: e => actionManager.do(getCreateNodeAction(NUMBER_BOOLEAN,     btnNumber.div, getCreateOptions(e)))}),
                         new MenuItem('Conditional',   null,                 {icon: iconCondition,   /*childMenu: menuCondition,*/ createType: NUMBER_CONDITION,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_CONDITION,   btnNumber.div, getCreateOptions(e)))}),
                         new MenuItem('Trigonometric', null,                 {icon: iconSine,        /*childMenu: menuTrig,     */ createType: NUMBER_TRIG,        callback: e => actionManager.do(getCreateNodeAction(NUMBER_TRIG,        btnNumber.div, getCreateOptions(e)))}),
                         new MenuItem('',              null,                 {separator: true}),
                         new MenuItem('Interpolate',   'Interpolate number', {icon: iconInterpolate, createType: NUMBER_INTERPOLATE, callback: e => actionManager.do(getCreateNodeAction(NUMBER_INTERPOLATE, btnNumber.div, getCreateOptions(e)))}),
        menuNumberSep1 = new MenuItem('',              null,                 {separator: true}),
        menuItemSolve  = new MenuItem('Solve',         null,                 {icon: iconSolve,       createType: NUMBER_SOLVE,       callback: e => actionManager.do(getCreateNodeAction(NUMBER_SOLVE,       btnNumber.div, getCreateOptions(e)))})]);
        
    
    menuString = new Menu('Text', true, false);
    menuString.addItems([
                           new MenuItem('Text',       null,            {icon: iconText,          createType: TEXT,           callback: e => actionManager.do(getCreateNodeAction(TEXT,           btnText.div, getCreateOptions(e)))}),
                           new MenuItem('',           null,            {separator: true}),
                           new MenuItem('Length',     null,            {icon: iconTextLength,    createType: TEXT_LENGTH,    callback: e => actionManager.do(getCreateNodeAction(TEXT_LENGTH,    btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Compare',    null,            {icon: iconTextCompare,   createType: TEXT_COMPARE,   callback: e => actionManager.do(getCreateNodeAction(TEXT_COMPARE,   btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Contains',   'Text contains', {icon: iconTextContains,  createType: TEXT_CONTAINS,  callback: e => actionManager.do(getCreateNodeAction(TEXT_CONTAINS,  btnText.div, getCreateOptions(e)))}),
                           new MenuItem('',           null,            {separator: true}),
                           new MenuItem('Trim',       null,            {icon: iconTextTrim,      createType: TEXT_TRIM,      callback: e => actionManager.do(getCreateNodeAction(TEXT_TRIM,      btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Spl it',     null,            {icon: iconTextSplit,     createType: TEXT_SPLIT,     callback: e => actionManager.do(getCreateNodeAction(TEXT_SPLIT,     btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Join',       null,            {icon: iconTextJoin,      createType: TEXT_JOIN,      callback: e => actionManager.do(getCreateNodeAction(TEXT_JOIN,      btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Substring',  null,            {icon: iconTextSubstring, createType: TEXT_SUBSTRING, callback: e => actionManager.do(getCreateNodeAction(TEXT_SUBSTRING, btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Case',       null,            {icon: iconTextCase,      createType: TEXT_CASE,      callback: e => actionManager.do(getCreateNodeAction(TEXT_CASE,      btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Replace',    null,            {icon: iconTextReplace,   createType: TEXT_REPLACE,   callback: e => actionManager.do(getCreateNodeAction(TEXT_REPLACE,   btnText.div, getCreateOptions(e)))}),
                           new MenuItem('Pad',        null,            {icon: iconTextPad,       createType: TEXT_PAD,       callback: e => actionManager.do(getCreateNodeAction(TEXT_PAD,       btnText.div, getCreateOptions(e)))}),
                           new MenuItem('',           null,            {separator: true}),
                           new MenuItem('Parse CSV',  null,            {icon: iconTextCSV,       createType: TEXT_CSV,       callback: e => actionManager.do(getCreateNodeAction(TEXT_CSV,       btnText.div, getCreateOptions(e)))}),
        menuItemTextJson = new MenuItem('Parse JSON', null,            {icon: iconTextJson,      createType: TEXT_JSON,      callback: e => actionManager.do(getCreateNodeAction(TEXT_JSON,      btnText.div, getCreateOptions(e)))}),
                           new MenuItem('',           null,            {separator: true}),
                           new MenuItem('Convert',    null,            {icon: iconNumberToText, childMenu: menuConvert})]);


    menuColorStyle = new Menu('Color style', true, false);
    menuColorStyle.addItems([
        new MenuItem('Link existing...', null, {icon: iconColorStyleReplace, createType: COLOR_STYLE, callback: e => actionManager.do(getCreateNodeAction(COLOR_STYLE,  btnColor.div, getCreateOptions(e, {existing: true})))})]);

        
    menuColor = new Menu('Colors', true, true);
    menuColor.addItems([
        menuItemColor        = new MenuItem('Color',         null,                {icon: iconColor,            callback: e => actionManager.do(getCreateNodeAction(COLOR,             btnColor.div, getCreateOptions(e,  {random: e.altKey && !getCtrlKey(e)})))}),
                               new MenuItem('',              null,                {separator: true}),
                               new MenuItem('Valid sRGB',    null,                {icon: iconValidColor,       callback: e => actionManager.do(getCreateNodeAction(VALID_COLOR,       btnColor.div, getCreateOptions(e)))}),
        menuItemCorrectColor = new MenuItem('Correct color', null,                {icon: iconCorrectColor,     callback: e => actionManager.do(getCreateNodeAction(CORRECT_COLOR,     btnColor.div, getCreateOptions(e)))}),
        menuItemConvertToP3  = new MenuItem('sRGB ⟷ P3',    null,                {icon: iconConvertP3,        callback: e => actionManager.do(getCreateNodeAction(COLOR_CONVERT_P3,  btnColor.div, getCreateOptions(e)))}),
                               new MenuItem('',              null,                {separator: true}),
                               new MenuItem('Interpolate',   'Interpolate color', {icon: iconColorInterpolate, callback: e => actionManager.do(getCreateNodeAction(COLOR_INTERPOLATE, btnColor.div, getCreateOptions(e)))}),
        menuItemColorBlend   = new MenuItem('Blend',         null,                {icon: iconColorBlend,       callback: e => actionManager.do(getCreateNodeAction(COLOR_BLEND,       btnColor.div, getCreateOptions(e)))}),
        menuItemColorSep1    = new MenuItem('',              null,                {separator: true}),
                               new MenuItem('Web contrast',  null,                {icon: iconWebContrast,      callback: e => actionManager.do(getCreateNodeAction(COLOR_CONTRAST,    btnColor.div, getCreateOptions(e)))}),
                               new MenuItem('',              null,                {separator: true}),
        menuItemColorblind   = new MenuItem('Colorblind',    null,                {icon: iconColorblind,       callback: e => actionManager.do(getCreateNodeAction(COLORBLIND,        btnColor.div, getCreateOptions(e)))})]);

    menuColor.init = () => 
    {
        menuItemColor.setIcon(iconColor);
    };

    
    menuEffects = new Menu('Effects', true, false);
    menuEffects.addItems([
        menuItemLayerDropShadow  = new MenuItem('Drop shadow',     null, {icon: iconDropShadow,  callback: e => actionManager.do(getCreateNodeAction(DROP_SHADOW,  btnLayer.div, getCreateOptions(e)))}),
        menuItemLayerInnerShadow = new MenuItem('Inner shadow',    null, {icon: iconInnerShadow, callback: e => actionManager.do(getCreateNodeAction(INNER_SHADOW, btnLayer.div, getCreateOptions(e)))}),
        menuItemLayerLayerBlur   = new MenuItem('Layer blur',      null, {icon: iconLayerBlur,   callback: e => actionManager.do(getCreateNodeAction(LAYER_BLUR,   btnLayer.div, getCreateOptions(e)))}),
        menuItemLayerBackBlur    = new MenuItem('Background blur', null, {icon: iconBackBlur,    callback: e => actionManager.do(getCreateNodeAction(BACK_BLUR,    btnLayer.div, getCreateOptions(e)))})]);
    
    
    menuStyles = new Menu('Styles', true, false);
    menuStyles.addItems([
        new MenuItem('Color style', null, {icon: iconColorStyle, createType: START, callback: e => actionManager.do(getCreateNodeAction(COLOR_STYLE, btnLayer.div, getCreateOptions(e, {existing: true})))})]);
    
    
    menuVariables = new Menu('Variables', true, false);
    menuVariables.addItems([
        new MenuItem('Number', null, {icon: iconVarNumber, createType: START, callback: e => actionManager.do(getCreateNodeAction(VAR_NUMBER, btnLayer.div, getCreateOptions(e, {existing: true})))})]);
    
    
    menuLayer = new Menu('Style', true, false);
    menuLayer.addItems([
        menuItemLayerFill   = new MenuItem('Fill',        null, {icon: iconFill,        callback: e => actionManager.do(getCreateNodeAction(FILL,       btnLayer.div, getCreateOptions(e)))}),
                              new MenuItem('Gradient',    null, {icon: iconGradient,    callback: e => actionManager.do(getCreateNodeAction(GRADIENT,   btnLayer.div, getCreateOptions(e)))}),
                              new MenuItem('Color stop',  null, {icon: iconColorStop,   callback: e => actionManager.do(getCreateNodeAction(COLOR_STOP, btnLayer.div, getCreateOptions(e)))}),
        menuItemLayerStroke = new MenuItem('Stroke',      null, {icon: iconStroke,      callback: e => actionManager.do(getCreateNodeAction(STROKE,     btnLayer.div, getCreateOptions(e)))}),
        menuItemLayerSep1   = new MenuItem('',            null, {separator: true}),
                              new MenuItem('Apply style', null, {icon: iconApply, createType: SHAPE_APPLY, callback: e => actionManager.do(getCreateNodeAction(SHAPE_APPLY, btnLayer.div, getCreateOptions(e)))}),
                              new MenuItem('',            null, {separator: true}),
                              new MenuItem('Effects',     null, {icon: iconEffects, childMenu: menuEffects}),
                              new MenuItem('Styles',      null, {icon: iconStyle, childMenu: menuStyles}),
                            //new MenuItem('Variables',   null, {childMenu: menuVariables}),
                              new MenuItem('',            null, {separator: true}),
                              new MenuItem('Mask',        null, {icon: iconMask,        callback: e => actionManager.do(getCreateNodeAction(LAYER_MASK, btnLayer.div, getCreateOptions(e)))})]);
    
    
    menuVector = new Menu('Vector', true, false);
    menuVector.addItems([
        new MenuItem('Point',             null,          {icon: iconPoint,            createType: POINT,             callback: e => actionManager.do(getCreateNodeAction(POINT,             btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Path',              'Vector path', {icon: iconVectorPath,       createType: VECTOR_PATH,       callback: e => actionManager.do(getCreateNodeAction(VECTOR_PATH,       btnShape.div, getCreateOptions(e)))}),
        new MenuItem('',                  null,          {separator: true}),
        new MenuItem('Interpolate point', null,          {icon: iconInterpolatePoint, createType: INTERPOLATE_POINT, callback: e => actionManager.do(getCreateNodeAction(INTERPOLATE_POINT, btnShape.div, getCreateOptions(e)))}),
        //new MenuItem('Point on path',   null,          {icon: iconPointOnPath,      createType: POINT_ON_PATH,     callback: e => actionManager.do(getCreateNodeAction(POINT_ON_PATH,     btnShape.div, getCreateOptions(e)))}),
        new MenuItem('',                  null,          {separator: true}),
        new MenuItem('Measure points',    null,          {icon: iconMeasurePoints,    createType: MEASURE_POINTS,    callback: e => actionManager.do(getCreateNodeAction(MEASURE_POINTS,    btnShape.div, getCreateOptions(e)))})]);
        // new MenuItem('',        null, {separator: true}),
        // new MenuItem('Vertex',  null, {icon: iconVectorVertex,  createType: START, callback: e => actionManager.do(getCreateNodeAction(VECTOR_VERTEX,  btnShape.div, getCreateOptions(e)))}),
        // new MenuItem('Edge',    null, {icon: iconVectorEdge,    createType: START, callback: e => actionManager.do(getCreateNodeAction(VECTOR_EDGE,    btnShape.div, getCreateOptions(e)))}),
        // new MenuItem('Region',  null, {icon: iconVectorRegion,  createType: START, callback: e => actionManager.do(getCreateNodeAction(VECTOR_REGION,  btnShape.div, getCreateOptions(e)))}),
        // new MenuItem('Network', null, {icon: iconVectorNetwork, createType: START, callback: e => actionManager.do(getCreateNodeAction(VECTOR_NETWORK, btnShape.div, getCreateOptions(e)))})]);


    menuShapes = new Menu('Shapes', true, false);
    menuShapes.addItems([
        new MenuItem('Rectangle', null,         {icon: iconRectangle,  createType: RECTANGLE,  callback: e => actionManager.do(getCreateNodeAction(RECTANGLE,  btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Line',      null,         {icon: iconLine,       createType: LINE,       callback: e => actionManager.do(getCreateNodeAction(LINE,       btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Ellipse',   null,         {icon: iconEllipse,    createType: ELLIPSE,    callback: e => actionManager.do(getCreateNodeAction(ELLIPSE,    btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Trapeze',   null,         {icon: iconTrapeze,    createType: TRAPEZE,    callback: e => actionManager.do(getCreateNodeAction(TRAPEZE,    btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Polygon',   null,         {icon: iconPolygon,    createType: POLYGON,    callback: e => actionManager.do(getCreateNodeAction(POLYGON,    btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Star',      null,         {icon: iconStar,       createType: STAR,       callback: e => actionManager.do(getCreateNodeAction(STAR,       btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Text',      'Text shape', {icon: iconTextShape,  createType: TEXT_SHAPE, callback: e => actionManager.do(getCreateNodeAction(TEXT_SHAPE, btnShape.div, getCreateOptions(e)))})]);


    menuTransform = new Menu('Transform', true, false);
    menuTransform.addItems([
        new MenuItem('Move',        null, {icon: iconMove,       createType: MOVE,              callback: e => actionManager.do(getCreateNodeAction(MOVE,              btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Rotate',      null, {icon: iconRotate,     createType: ROTATE,            callback: e => actionManager.do(getCreateNodeAction(ROTATE,            btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Scale',       null, {icon: iconScale,      createType: SCALE,             callback: e => actionManager.do(getCreateNodeAction(SCALE,             btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Skew',        null, {icon: iconSkew,       createType: SKEW,              callback: e => actionManager.do(getCreateNodeAction(SKEW,              btnShape.div, getCreateOptions(e)))}),
        new MenuItem('',            null, {separator: true}),
        new MenuItem('Place',       null, {icon: iconPlace,      createType: PLACE,             callback: e => actionManager.do(getCreateNodeAction(PLACE,             btnShape.div, getCreateOptions(e)))}),
        new MenuItem('',            null, {separator: true}),
        new MenuItem('Center',      null, {icon: iconCenter,     createType: CENTER,            callback: e => actionManager.do(getCreateNodeAction(CENTER,            btnShape.div, getCreateOptions(e)))}),
        new MenuItem('Reset space', null, {icon: iconResetXform, createType: RESET_XFORM,       callback: e => actionManager.do(getCreateNodeAction(RESET_XFORM,       btnShape.div, getCreateOptions(e)))})]);


    menuShape = new Menu('Shapes', true, false);
    menuShape.addItems([
        // menuItemShapeSelected = new MenuItem('Selected objects...', null, {icon: iconSelected,   enabled: false}),
                             // new MenuItem('',          null,   {separator: true}),
                                new MenuItem('Shapes',    null,   {icon: iconShapes,        childMenu: menuShapes}),
                                new MenuItem('Vector',    null,   {icon: iconVectorNetwork, childMenu: menuVector}),
                                new MenuItem('',          null,   {separator: true}),
                                new MenuItem('Frame',     null,   {icon: iconFrame,      createType: FRAME,       callback: e => actionManager.do(getCreateNodeAction(FRAME,       btnShape.div, getCreateOptions(e)))}),
                              //new MenuItem('Group',     null,   {icon: iconShapeGroup, createType: SHAPE_GROUP, callback: e => actionManager.do(getCreateNodeAction(SHAPE_GROUP, btnShape.div, getCreateOptions(e)))}),
                             // new MenuItem('Boolean',   null,   {enabled: false, icon: iconBoolUnion,  callback: e => actionManager.do(getCreateNodeAction(BOOLEAN,     btnShape.div, getCreateOptions(e)))}),
        menuItemShapeSep1     = new MenuItem('',          null,   {separator: true}),
                                new MenuItem('Transform', null,   {icon: iconMove, childMenu: menuTransform}),
                                new MenuItem('',          null,   {separator: true}),
        menuItemShapeRender   = new MenuItem('Render',    null,   {icon: iconRenderDown, createType: RENDER, callback: e => actionManager.do(getCreateNodeAction(RENDER,       btnShape.div, getCreateOptions(e)))})]);


    menuTemplate = new Menu('Templates', true, false);
    menuTemplate.init = e => 
    {
        uiQueueMessageToFigma({cmd: 'figGetAllLocalTemplateNames'});
        e.cancel = true;
    };


    menuItemManageTemplates = new MenuItem('Manage templates...', null, {icon: iconManageTemplates});


    menuGroup = new Menu('Groups', true, false);
    menuGroup.addItems([
        new MenuItem('Group',     null, {icon: iconGroupNode,  createType: GROUP_NODE, callback: e => actionManager.do(getCreateNodeAction(GROUP_NODE,  btnGroup.div, getCreateOptions(e)))}),
        new MenuItem('Parameter', null, {icon: iconGroupParam, createType: GROUP_PARAM, callback: e => actionManager.do(getCreateNodeAction(GROUP_PARAM, btnGroup.div, getCreateOptions(e)))})]);
    

    menuWindow = new Menu('Window options', true, false);
    menuWindow.showOnLeft = true;
    menuWindow.addItems([
        menuItemWindowNormal   = new MenuItem('Normal',   null, {icon: iconWindowNormal,     shortcut: osAlt() + '0', callback: () => dockWindowNormal  ()}),
        menuItemWindowMaximize = new MenuItem('Maximize', null, {icon: iconWindowMaximize,   shortcut: osAlt() + '8', callback: () => dockWindowMaximize()}),
        menuItemWindowTop      = new MenuItem('Top',      null, {icon: iconWindowDockTop,    shortcut: osAlt() + '5', callback: () => dockWindowTop     ()}),
        menuItemWindowLeft     = new MenuItem('Left',     null, {icon: iconWindowDockLeft,   shortcut: osAlt() + '1', callback: () => dockWindowLeft    ()}),
        menuItemWindowRight    = new MenuItem('Right',    null, {icon: iconWindowDockRight,  shortcut: osAlt() + '3', callback: () => dockWindowRight   ()}),
        menuItemWindowBottom   = new MenuItem('Bottom',   null, {icon: iconWindowDockBottom, shortcut: osAlt() + '2', callback: () => dockWindowTop     ()})]);


    menuPage = new Menu('Page menu', false, false);
    menuPage.addItems([
        new MenuItem('Duplicate', null, {enabled: false, callback: () => {}}),
        new MenuItem('Rename',    null, {enabled: false, callback: () => {}})]);

        
    menuZoom = new Menu('Zoom/view options');
    menuZoom.combineChecksAndIcons = true;
    menuZoom.addItems([
                            new MenuItem('Zoom in',      null, {shortcut: osCtrl () + '+', callback: () => graph.currentPage.zoom *= Math.pow(2, 1/2)}),
                            new MenuItem('Zoom out',     null, {shortcut: osCtrl () + '-', callback: () => graph.currentPage.zoom /= Math.pow(2, 1/2)}),
                            new MenuItem('Zoom to fit',  null, {shortcut: osShift() + '1', callback: () => graphView.zoomToFit()}),
        menuItemZoomTo100 = new MenuItem('Zoom to 100%', null, {shortcut: osCtrl () + '0', callback: () => graph.currentPage.zoom = 1})]);//,
                        //  new MenuItem('',             {separator: true}),
                        //  new MenuItem('Window',       {childMenu: menuWindow})]);

        
    wholeMenu = new Menu('Create node...', true, false);
    wholeMenu.addItems([
        new MenuItem('Flow',    null, {icon: iconFlow,     childMenu: menuFlow  }),
        new MenuItem('Data',    null, {icon: iconList,     childMenu: menuData  }),
        new MenuItem('Sets...', null, {icon: iconSequence, childMenu: menuSets  }),
        new MenuItem('Number',  null, {icon: iconNumber,   childMenu: menuNumber}),
        new MenuItem('Text',    null, {icon: iconText,     childMenu: menuString}),
        new MenuItem('Color',   null, {icon: iconVarColor, childMenu: menuColor }),
        new MenuItem('Layer',   null, {icon: iconEffects,  childMenu: menuLayer }),
        new MenuItem('Shape',   null, {icon: iconShapes,   childMenu: menuShape }),
        new MenuItem('Panel',   null, {icon: iconPanel,    createType: PANEL, callback: e => actionManager.do(getCreateNodeAction(PANEL, btnPanel.div, getCreateOptions(e)))})]);

                                      
    menuGraph = new Menu('Graph menu', false, false);
    menuGraph.addItems([
        menuItemGraphPaste          = new MenuItem('Paste here',       null, {shortcut: osCtrl()      + 'V', callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(false, e.clientX, e.clientY - getTopHeight()); }}),
        menuItemGraphPasteConnected = new MenuItem('Paste connected',  null, {shortcut: osCtrlShift() + 'V', callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(true,  e.clientX, e.clientY - getTopHeight()); }}),
                                      new MenuItem('',                 null, {separator: true}),
                                      new MenuItem('Create node...',   null, {childMenu: wholeMenu}),
                                      new MenuItem('',                 null, {separator: true}),
                                      new MenuItem('Quick actions...', null, {shortcut: osCtrl() + '/',      callback: () => showSearchBox() })]);

    menuGraph.init = () => 
    {
        menuItemGraphPaste         .setEnabled(copiedNodesJson != '');
        menuItemGraphPasteConnected.setEnabled(copiedNodesJson != '');
    };


    menuNodeHighlight = new Menu('Highlight nodes menu', false, false);
    menuNodeHighlight.addItems([
        new ColorListMenuItem({callback: color => { hideAllMenus(); setNodeHighlight(graphView.selectedNodes, color); }})]);

    menuNodeSelect = new Menu('Select nodes menu', false, false);
    menuNodeSelect.addItems([
        new MenuItem('Select left',   null, {shortcut:  isMac ? osShift() + osAlt ()            : osShift() + osCtrl(false)          , callback: () => graphView.selectedNodes = [graphView.selectedNodes[0], ...getNodesBeforeNode(graphView.selectedNodes[0])] }),
        new MenuItem('Select right',  null, {shortcut:  isMac ? osShift() + osCtrl()            : osShift() + osAlt (false)          , callback: () => graphView.selectedNodes = [graphView.selectedNodes[0], ...getNodesAfterNode (graphView.selectedNodes[0])] }),
        new MenuItem('Select across', null, {shortcut:  isMac ? osAlt  () + osCtrl()            : osCtrl () + osAlt (false)          , callback: () => graphView.selectedNodes = [graphView.selectedNodes[0], ...getNodesAcrossNode(graphView.selectedNodes[0])] }),
        new MenuItem('Select tree',   null, {shortcut:  isMac ? osShift() + osAlt () + osCtrl() : osShift() + osCtrl() + osAlt(false), callback: () => graphView.selectedNodes =                                 getAllNodesFromNode(graphView.selectedNodes[0]) })]);


    menuNodeCopyAs = new Menu('Copy nodes menu', false, false);
    menuNodeCopyAs.addItems([
        //menuItemNodeCopyAsJsCode       = new MenuItem('Copy as JS code',     {shortcut:  osCtrlShift() + 'C',            callback: () => graphView.copySelectedNodesAsJsCode()     }),
        menuItemNodeCopyAsJsFunction   = new MenuItem('Copy as Javascript', {shortcut:  osCtrlShift() /*+ osAlt()*/ + 'C',  callback: () => graphView.copySelectedNodesAsJavascript() })]);


    menuNode = new Menu('Node menu', false, false);
    menuNode.addItems([
        //menuItemNodeEditGroup      = new MenuItem('Edit group...',  null,  {callback: e => { hideAllMenus(); editSelectedGroup(); }}),
        //menuItemNodeSep1           = new MenuItem('',               null,  {separator: true}),
        menuItemNodeCopy           = new MenuItem('Copy',            null, {shortcut:  osCtrl() + 'C',       callback: () => graphView.copySelectedNodes() }),
        menuItemNodePaste          = new MenuItem('Paste here',      null, {shortcut:  osCtrl() + 'V',       callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(false); }}),
        menuItemNodePasteConnected = new MenuItem('Paste connected', null, {shortcut:  osCtrlShift() + 'D',  callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(true ); }}),
        //                                 new MenuItem('Copy/Paste as', null,  {childMenu: menuNodeCopyAs}),
        menuItemNodeLayoutSep      = new MenuItem('',                null, {separator: true}),
        menuItemNodeLayout         = new MenuItem('Layout',          null, {shortcut: osCtrlShift() + 'L', callback: e => { hideAllMenus(); layoutSelectedNodes(); }}),
        // menuItemNodeSepGroup       = new MenuItem('',              null,  {separator: true}),
        //menuItemNodeGroupSelected  = new MenuItem('Group selected', null, {shortcut:  osCtrl() + 'G',       callback: e => { hideAllMenus(); actionManager.do(new   GroupNodesAction(graphView.selectedNodes)); }}),
        //menuItemNodeUngroup        = new MenuItem('Ungroup',        null, {                                 callback: e => { hideAllMenus(); actionManager.do(new UngroupNodesAction(graphView.selectedNodes)); }}),
        menuItemNodeSep2           = new MenuItem('',                 null, {separator: true}),
        menuItemNodeRename         = new MenuItem('Rename',           null, {shortcut:  osCtrl() + 'R',       callback: e => { hideAllMenus(); graphView.renameSelectedNode(); }}),
        menuItemNodeHighlight      = new MenuItem('Highlight',        null, {childMenu: menuNodeHighlight}),
        menuItemNodeSep3           = new MenuItem('',                 null, {separator: true}),
        menuItemNodeEnableDisable  = new MenuItem('Enable/Disable',   null, {shortcut:  osCtrlShift() + 'E',  callback: () => actionManager.do(new ToggleDisableNodesAction(graphView.selectedNodes.map(n => n.id)))}),
        menuItemNodeSelect         = new MenuItem('Select',           null, {childMenu: menuNodeSelect}),
        // menuItemNodeEdit           = new MenuItem('Edit...',       null, {callback: e => { hideAllMenus(); graphView.editSelectedCustomNode(); }}),
                                    //  new MenuItem('',              null, {separator: true}),
        // menuItemNodeSaveAsTemplate = new MenuItem('Save as template', null, {callback: e => { hideAllMenus(); showSaveAsTemplateDialog(); }}),
        //                              new MenuItem('',                 null, {separator: true}),
        // menuItemNodeActivate    = new MenuItem('Activate',         null, {callback: () => makeSelectedNodesActive()}),
        menuItemNodeSep4           = new MenuItem('',                 null, {separator: true}),
        menuItemNodeRemove         = new MenuItem('Remove',           null, {shortcut:  osCtrl() + '⌫',      callback: e => { hideAllMenus(); graphView.removeSelectedNodes(true); }}),
                                     new MenuItem('',                 null, {separator: true}),
                                     new MenuItem('Create node...',   null, {childMenu: wholeMenu})]);



    menuNode.init = () => 
    {
        const single     = graphView.selectedNodes.length == 1;
        const hasObjects = isEmpty(graphView.selectedNodes.filter(n => !SHAPE_TYPES.includes(n.type)));
        const hasGroups  = isEmpty(graphView.selectedNodes.filter(n => n.type != GROUP_NODE));
        

        //const parallel = nodesAreParallel(graphView.selectedNodes);

        const canDisable = !graphView.selectedNodes.find(n => !n.canDisable);


        //updateElementDisplay(menuItemNodeEditGroup    .div, hasGroups && single);
        //updateElementDisplay(menuItemNodeSepGroup     .div, hasGroups && single);
        //updateElementDisplay(menuItemNodeUngroup      .div, hasGroups);
        //updateElementDisplay(menuItemNodeSep2         .div, single);
        updateElementDisplay(menuItemNodeRename       .div, single);
        updateElementDisplay(menuItemNodeLayoutSep    .div, !single);
        updateElementDisplay(menuItemNodeLayout       .div, !single);
        //updateElementDisplay(menuItemNodeEdit       .div, single);
        updateElementDisplay(menuItemNodeSep2         .div, single);
        updateElementDisplay(menuItemNodeSelect       .div, single);
        updateElementDisplay(menuItemNodeSep4         .div, canDisable);
        updateElementDisplay(menuItemNodeEnableDisable.div, canDisable);
    };



    // menuRemoveLicense = new Menu('Remove license', false, false);
    // menuRemoveLicense.addItems([
    //                             new MenuItem('Cut',   {callback: () => { hideAllMenus(); document.execCommand('copy' ); clearSelectedText(subscriptionInput); updateSubscriptionDots(); }}),
    //                             new MenuItem('Copy',  {callback: () => { hideAllMenus(); document.execCommand('copy' ); }}),
    //                             new MenuItem('Paste', {callback: () => { hideAllMenus(); document.execCommand('paste'); }}),
    //     menuItemLicenseSep1   = new MenuItem('', {separator: true}),
    //     menuItemLicenseRemove = new MenuItem('Remove from this computer', {callback: () => { hideAllMenus(); removeLicense(); }})]);


    menuText    = new Menu('Text menu',    false, false);
    menuTextbox = new Menu('Textbox menu', false, true);

    menuCopy    = new Menu('Copy menu',    false, false);


    menuLocalStyles = new Menu('Local styles',   true,  true);
    menuSelectParam = new Menu('Select options', false, true);

    
    btnMain     = new MenuButton('', menuMain,     {useMenuName: true, highlight: () => currentMenus.includes(menuMain  ), callback: () => updatePanMode(false)});
    btnFlow     = new MenuButton('', menuFlow,     {useMenuName: true, highlight: () => currentMenus.includes(menuFlow  ), callback: () => updatePanMode(false)});
    btnData     = new MenuButton('', menuData,     {useMenuName: true, highlight: () => currentMenus.includes(menuData  ), callback: () => updatePanMode(false)});
    btnSets     = new MenuButton('', menuSets,     {useMenuName: true, highlight: () => currentMenus.includes(menuSets  ), callback: () => updatePanMode(false)});
    btnNumber   = new MenuButton('', menuNumber,   {useMenuName: true, highlight: () => currentMenus.includes(menuNumber), callback: () => updatePanMode(false)});
    btnText     = new MenuButton('', menuString,   {useMenuName: true, highlight: () => currentMenus.includes(menuString), callback: () => updatePanMode(false)});
    btnColor    = new MenuButton('', menuColor,    {useMenuName: true, highlight: () => currentMenus.includes(menuColor ), callback: () => updatePanMode(false)});
    btnLayer    = new MenuButton('', menuLayer,    {useMenuName: true, highlight: () => currentMenus.includes(menuLayer ), callback: () => updatePanMode(false)});
    //btnStyle  = new MenuButton('', menuStyle,    {useMenuName: true, highlight: () => currentMenus.includes(menuStyle ), callback: () => updatePanMode(false)});
    btnShape    = new MenuButton('', menuShape,    {useMenuName: true, highlight: () => currentMenus.includes(menuShape ), callback: () => updatePanMode(false)});
   // btnTemplate = new MenuButton('', menuTemplate, {useMenuName: true, highlight: () => currentMenus.includes(menuShape ), callback: () => updatePanMode(false)});
    //btnGroup  = new MenuButton('', menuGroup,  {useMenuName: true, highlight: () => currentMenus.includes(menuShape ), callback: () => updatePanMode(false)});

    // btnGroup  = new MenuButton('Node groups', null, {callback: () => 
    // {
    //     const create = new CreateNodeAction(OUP, btnGroup.div);
    //     actionManager.do(create);

    //     graphView.updateNodes([create.node]);
    //     graphView.updateScrollWithBounds();

    //     updatePanMode(false);
    // }});
    
    btnHand = new MenuButton('Hand tool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #888; font-weight: 500;">H</span>', null, {callback: () => 
    { 
        updatePanMode(!panMode);
    }});

    // btnComment = new MenuButton('Add comment', null, {callback: () => 
    // {
    //     const create = new CreateNodeAction(COMMENT, btnComment.div);
    //     actionManager.do(create);

    //     graphView.updateNodes([create.node]);
    //     graphView.updateScrollWithBounds();

    //     updatePanMode(false);
    // }});

    btnPanel = new MenuButton('Panel', null, {callback: () => 
    {
        const create = new CreateNodeAction(PANEL, btnPanel.div);
        actionManager.do(create);

        graphView.updateNodes([create.node]);
        graphView.updateScrollWithBounds();

        updatePanMode(false);
    }});


    //menuBar.appendChild(createDiv('', 'groupName'));


    btnPage = new MenuButton(
        '-', 
        menuPage, 
        {
            afterLabel:  true,
            useMenuName: false,
            noHighlight: true
        });

    btnPage.divIcon.style.width   = 4;
    
    btnPage.div.style.marginRight = 'auto';
    
    btnPage.div.style.position    = 'relative';
    btnPage.div.style.left        = '-26px';



    btnSolo = new MenuButton('Focus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #888; font-weight: 500;">'+osAlt()+'F</span>', null, {callback: () => 
    {
        updateSoloMode(!graphView.soloMode);
    }});
    
    btnSolo.highlight = () => graphView.soloMode;

    btnSolo.div.style.position               = 'absolute';
    btnSolo.div.style.right                  = '66px';


    btnZoom = new MenuButton(
        '', 
        menuZoom, 
        { 
            useMenuName: true, 
            selectLast:  false, 
            highlight:   () => currentMenus.includes(menuZoom),
            tooltip:     ttMinValueZoom,
            afterLabel:  true
        });

        
    btnZoom.div.appendChild(createDiv('', 'zoomIconOverlay'));

    btnZoom.divIcon.style.textAlign          = 'center';
    btnZoom.divIcon.style.fontVariantNumeric = 'tabular-nums';
    btnZoom.divIcon.style.letterSpacing      = '-0.8px';


    btnMain.div.style.paddingLeft            = '6px';

    btnZoom.div.style.position               = 'absolute';
    btnZoom.div.style.right                  = '0px';
    btnZoom.div.style.paddingRight           = '5px';
    btnZoom.div.style.paddingLeft            = '11px';
    // btnZoom.div.style.boxShadow           = '0 0 0 1px red inset';


    btnFlow   .setIcon(iconFlow);
    btnSets   .setIcon(iconSequence);
    btnMain   .setIcon(iconGenerator);
    btnColor  .setIcon(iconVarColor);
    btnLayer  .setIcon(iconEffects);
    btnShape  .setIcon(iconShapes);
    btnHand   .setIcon(iconHand);
    //btnComment.setIcon(iconComment);
    btnPanel  .setIcon(iconPanel);
    btnSolo   .setIcon(iconSolo);


    menuBarMenus = 
    [
        menuFlow,
        menuData,
        menuSets,
        menuNumber,
        menuFunctions,
        menuMath,
        menuConvert,
        menuString,
        menuColor,
        menuLayer,
        menuEffects,
        menuStyles,
        menuShape,
        menuShapes,
        menuVector,
        menuTransform
    ];
}



function initDataModeMenus()
{
    menuPageData = new Menu('Pages menu', false, false);
    menuPageData.addItems([
        // new MenuItem('Delete all pages',  null, { enabled: false, callback: () => { hideAllMenus(); dataModeDeleteAllPages(); }}),
        // new MenuItem('',                  null, { enabled: false, separator: true }),
        new MenuItem('Delete page',       null, { callback: () => { hideAllMenus(); dataModeDeletePage(menuPageData._div.page); }})]);


    menuPageDataPages = new Menu('Pages menu', false, false);
    menuPageDataPages.addItems([
        new MenuItem('Expand all',       null, { callback: () => { hideAllMenus(); expandAllPageData();   }}),
        new MenuItem('Collapse all',     null, { callback: () => { hideAllMenus(); collapseAllPageData(); }}),
        new MenuItem('',                 null, { separator: true }),
        new MenuItem('Delete all pages', null, { callback: () => { hideAllMenus(); dataModeDeleteAllPages(); }})]);


    menuNodeData = new Menu('Node menu', false, false);
    menuNodeData.addItems([
        new MenuItem('Remove path from ID',     null, { callback: () => { hideAllMenus(); dataModeDeletePathFromNodeId(menuNodeData._div.node); }}),
        new MenuItem('',                        null, { separator: true }),
        new MenuItem('Delete connections from', null, { callback: () => { hideAllMenus(); dataModeDeleteConnectionsFromNode     (menuNodeData._div.node); }}),
        new MenuItem('Delete connections to'  , null, { callback: () => { hideAllMenus(); dataModeDeleteConnectionsToNode       (menuNodeData._div.node); }}),
        new MenuItem('Delete all connections',  null, { callback: () => { hideAllMenus(); dataModeDeleteConnectionsToAndFromNode(menuNodeData._div.node); }}),
        new MenuItem('',                        null, { separator: true }),
        new MenuItem('Delete node',             null, { callback: () => { hideAllMenus(); dataModeDeleteNode(menuNodeData._div.node); }})]);


    menuNodeDataNodes = new Menu('Nodes menu', false, false);
    menuNodeDataNodes.addItems([
        new MenuItem('Expand all',       null, { callback: () => { hideAllMenus(); expandAllNodeData();   }}),
        new MenuItem('Collapse all',     null, { callback: () => { hideAllMenus(); collapseAllNodeData(); }}),
        new MenuItem('',                 null, { separator: true }),
        new MenuItem('Delete all nodes', null, { callback: () => { hideAllMenus(); dataModeDeleteAllNodes(); }})]);


    menuConnData = new Menu('Connection menu', false, false);
    menuConnData.addItems([
        new MenuItem('Delete connection', null, { callback: () => { hideAllMenus(); dataModeDeleteConnection(menuConnData._div.conn); }})]);


    menuConnDataConns = new Menu('Connections menu', false, false);
    menuConnDataConns.addItems([
        new MenuItem('Expand all',               null, { callback: () => { hideAllMenus(); expandAllConnData();   }}),
        new MenuItem('Collapse all',             null, { callback: () => { hideAllMenus(); collapseAllConnData(); }}),
        new MenuItem('',                         null, { separator: true }),
        // new MenuItem('List all connection keys', null, { callback: () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllSavedConnKeys', darkMode: darkMode}); }}),
        // new MenuItem('',                         null, { separator: true }),
        new MenuItem('Delete all connections',   null, { callback: e => { hideAllMenus(); dataModeDeleteAllConnections(); }})]);
}



function initTextMenu(textbox)
{
    menuText.clearItems();

    menuText.addItems([
        new MenuItem('Cut',   null, {enabled: !textbox.control || !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('cut'); }}),
        new MenuItem('Copy',  null, {                                                        callback: () => { hideAllMenus(); document.execCommand('copy'); }}),
        new MenuItem('Paste', null, {enabled: !textbox.control || !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('paste'); }})]);
}



function initCopyMenu()
{
    menuCopy.clearItems();

    menuCopy.addItems([
        new MenuItem('Copy',       null, {enabled: elementHasSelectedText(crashDialogBody), callback: () => { hideAllMenus(); document.execCommand('copy'); }}),
        new MenuItem('',           null, {separator: true }),
        new MenuItem('Select all', null, {callback: () => { hideAllMenus(); selectDivText(crashDetails); }})]);
}



function initTextboxMenu(textbox)
{
    menuTextbox.clearItems();


    let menuItemLeft,
        menuItemCenter,
        menuItemRight,
        menuItemJustify;


    const param = textbox.control.param;

    menuTextbox.addItems([
                          new MenuItem('Cut',          null, { enabled: !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('cut'); }}),
                          new MenuItem('Copy',         null, {                                     callback: () => { hideAllMenus(); document.execCommand('copy'); }}),
                          new MenuItem('Paste',        null, { enabled: !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('paste'); }}),
                          new MenuItem('',             null, { separator: true }),
        menuItemLeft    = new MenuItem('Align left',   null, { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'left'   )); }}),
        menuItemCenter  = new MenuItem('Align center', null, { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'center' )); }}),
        menuItemRight   = new MenuItem('Align right',  null, { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'right'  )); }}),
        menuItemJustify = new MenuItem('Justify',      null, { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'justify')); }})]);


    const align = textbox.control.getTextAlignment();

    menuItemLeft   .setChecked(align == 'left'   );
    menuItemCenter .setChecked(align == 'center' );
    menuItemRight  .setChecked(align == 'right'  );
    menuItemJustify.setChecked(align == 'justify');
}



function updatePanMode(enabled)
{
    panMode = enabled;  
    currentMenuButton = panMode ? btnHand : null;
    btnHand.update();

    setCursor(panMode ? panCursor : 'default');
}



function updateSoloMode(enabled)
{
    graphView.soloMode = enabled;  
    btnSolo.update();

    if (graphView.soloMode) graphView.soloNode(null);
    else                    graphView.unsoloNode();
}



function getCreateOptions(e, options = {})
{
    return {
        insert:      e.ctrlKey,
        autoConnect: e.ctrlKey && e.altKey,
        ...options
    };
}


function createToggleButton(width, height)
{
    const btn = createDiv('toggleButton');
    btn.enabled = false;

    btn.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();

        try
        {
            btn.setPointerCapture(e.pointerId);
            btn.enabled = !btn.enabled;
            btn.updateBackground(true);
        }
        catch {}
    });


    btn.addEventListener('pointerup', e =>
    {
        btn.releasePointerCapture(e.pointerId);
        btn.updateBackground(false);
    });


    btn.updateBackground = (enabled) =>
    {
        const col = darkMode ? 'white' : 'black';

        btn.style.background = 
            btn.enabled 
            ? 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 1C4.10457 1 5 1.89543 5 3V5H6V3C6 1.34315 4.65685 0 3 0C1.34315 0 0 1.34315 0 3V5H1V3C1 1.89543 1.89543 1 3 1Z" fill="'+col+'"/><path d="M5 9H6V11C6 12.6569 4.65685 14 3 14C1.34315 14 0 12.6569 0 11V9H1V11C1 12.1046 1.89543 13 3 13C4.10457 13 5 12.1046 5 11V9Z" fill="'+col+'"/><path d="M2.5 4V10H3.5V4H2.5Z" fill="'+col+'"/></svg>\')'
            : 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="'+col+'"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="'+col+'"/></svg>\')';

        btn.style.backgroundPosition = '50% 50%';
        btn.style.backgroundRepeat   = 'no-repeat';

        btn.style.backgroundColor = 
               btn.enabled 
            && enabled 
            ? (darkMode ? '#444' : '#e6e6e6') 
            : 'transparent';
    };


    return btn;
}


function initMenuSelectMenu(select)
{
    select.menu = createDiv('menuSelectMenu');

    select.menu.hoverIndex   = 0;
    select.menu.tabIndex     = 0;

    select.menu.style.left   = select.offsetLeft;
    select.menu.style.zIndex = MAX_INT32;

    select.menu.addEventListener('focus', function() 
    {
         select.menu.style.outline = 'none'; 
    });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });
    
    

    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = '100%';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = 'var(--figma-color-bg-brand)';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = 0; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();

        const onchange = new CustomEvent('change', { detail: 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        }});

        select.dispatchEvent(onchange);

        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initMenuSelectTextbox(select)
{
    select.textbox = createTextbox('menuSelectText');
    
    
    select.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            select.textbox.finish(true);

        else if (e.code == 'Escape')
            select.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            let tabs  = document.querySelectorAll('.control, .menuSelect, .select, button, .menuButton');
            let index = select.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && select.min < 0))
                e.preventDefault();

            let t = select.textbox;

            let curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            let nextVal = parseFloat(curVal + e.key);

            if (   nextVal < select.min - 0.001
                || nextVal > select.max)
                e.preventDefault();            
        }
    });


    // control.textbox.addEventListener('input', function()
    // {
    //     control.setValue(Number(control.textbox.value));
    // });


    select.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        let val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(select.min, val), select.max);

        select.textbox.value = isNaN(val) ? '' : val;
    });


    select.textbox.addEventListener('focusout', function()
    {
        select.parentNode.removeChild(select.textbox);
        select.clicked = false;
    });
    

    select.textbox.finish = function(success)
    {
        if (success) select.setValue(Number(select.textbox.value     ));
        else         select.setValue(Number(select.textbox.savedValue));

        select.textbox.blur();

        if (select.inFocus)
            select.focus();
    };    
    
    
    select.showTextbox = function()
    {
        select.inFocus = 
               hasFocus(select)
            && !select.clicked;

            
        select.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
        select.textbox.style.outline   = 'none';
    
        select.textbox.style.textAlign = 'center';
    
        select.textbox.value = numToString(select.value, select.decimals);
        select.textbox.savedValue = select.textbox.value;
        
        select.parentNode.appendChild(select.textbox);
        
        select.textbox.focus();
        select.textbox.select();
    }
}


function initMenuSelect(select)
{
    select.className = 'menuSelect';
    select.tabIndex  = 0;    
    
    initMenuSelectMenu   (select);
    initMenuSelectTextbox(select);

    select.holding = false;

    select.enableChangeEvent = true;


    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function(items)
    {
        select.resetMenu();
        
        
        select.items = items;
        select.update(0);


        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            item.style.border      = 'none';
            item.style.height      = 24;

            item.disabled = false;

            sub.innerHTML = select.items[i].text;

            item.appendChild(sub);

            select.menuWrap.appendChild(item);
        }
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();

            const rect = boundingRect(select);

            if (e.clientX > rect.width - 20)
            {
                try
                {
                    select.setPointerCapture(e.pointerId);
                    select.buttonDown0 = true;        
                    
                    select.holding = false;
                    setTimeout(function() { onSelectClickTimer(select); }, 200);
                    
                    select.menu.hoverIndex = select.getSelectedIndex();

                    select.showMenu();
                }
                catch {}
            }
            else
                select.showTextbox();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        // let menuTop =
        //     select.offsetTop; 
        //     - 3 // paddingTop
        //     - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
        //     - iy * 24;
        
        menuTop = select.offsetTop + select.offsetHeight + 11;//Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
            iy = Math.min(Math.max(0, iy), select.items.length-1);

        return iy;
    };        
    

    
    select.getSelectedValue = function()
    {
        return select.items[select.getSelectedIndex()].value;
    };        



    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    };



    select.setSelectedIndex = function(index)
    {
        select.value = select.items[index].value;
        select.update(select.getSelectedIndex());
        
        select.enableChangeEvent = false;
        select.dispatchChangeEvent();
        select.enableChangeEvent = true;
    };



    select.dispatchChangeEvent = function()
    {
        if (!select.enableChangeEvent)
            return;
    
        let index = select.getSelectedIndex();
    
        const onchange = new Event('change', 
        {
            selectedIndex: index,
            selectedValue: select.items[index].value
        });

        select.dispatchEvent(onchange);
    };
}



function initSelectMenu(select)
{
    select.menu = createDiv('selectMenu');

    select.menu.hoverIndex       =  0;
    select.menu.tabIndex         =  0;

    select.menu.style.left       =  select.offsetLeft;
    select.menu.style.height     = 'auto';
    select.menu.style.textAlign  = 'center';
    select.menu.style.background = '#222';
    select.menu.style.zIndex     =  MAX_INT32-3;
    


    select.menu.addEventListener('focus', function() { select.menu.style.outline = 'none'; });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });        
    

    
    select.menu.tabIndex   = 0;
    
    select.menu.hoverIndex = 0;


    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = 'calc(100% + 1px)';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = 'var(--figma-color-bg-brand)';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = -1; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();
        select.dispatchChangeEvent();
        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initSelect(select, items)
{
    select.className = 'menuSelect';
    select.tabIndex = 0;    
    
    initSelectMenu(select);

    select.holding  = false;
    

    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function()
    {
        select.resetMenu();
        
        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            if (select.items[i].value == '-')
            {
                item.style.borderTop = '1px solid white';
                item.style.marginTop = '6px';
                item.style.height    = '4px';
                item.style.position  = 'relative';
                item.style.left      = '6px';
                
                item.disabled = true;
            }
            else
            {
                item.style.border = 'none';
                item.style.height = 24;

                item.disabled = false;

                sub.innerHTML = select.items[i].text;
            }

            item.appendChild(sub);
            select.menuWrap.appendChild(item);
        }


        let options = select.getElementsByTagName('option');

        for (const node of options) 
            node.disabled = node.value == '-';
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();

            try
            {
                select.buttonDown0 = true;        
                select.setPointerCapture(e.pointerId);
                
                select.holding = false;
                setTimeout(function() { onSelectClickTimer(select); }, 200);
                
                select.menu.hoverIndex = select.getSelectedIndex();

                select.showMenu();
            }
            catch {}
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        let menuTop =
            select.offsetTop 
            - 3 // paddingTop
            - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
            - iy * 24;
        
        menuTop = Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
        iy = Math.min(Math.max(0, iy), select.items.length-1);
        return iy;
    };        
    

    
    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    }



    select.dispatchChangeEvent = function()
    {
        const onchange = new Event('change', 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        });

        select.dispatchEvent(onchange);
    };


    //////////////////////////////////////////////////////////////////////////////////

    
    select.items = items;
    
    select.update(0);
    select.updateItems();
}



function onSelectClickTimer(select)
{
    select.holding = true;
}


function initCheckbox(checkbox, name, defaultChecked)
{
    // control is also the div

    checkbox.className     = 'checkbox';
    
    checkbox.checked       = defaultChecked;
    checkbox.name          = name;
    
    checkbox.style.display = 'inline';
             
    checkbox.onchange      = new Event('change');


    checkbox.check         = createDiv('checkboxCheck');
    checkbox.text          = createDiv('checkboxText');

    checkbox.appendChild(checkbox.check);
    checkbox.appendChild(checkbox.text);



    checkbox.addEventListener('pointerup', () =>
    {
        checkbox.setChecked(!checkbox.checked);
    });



    checkbox.setName = function(name)
    {
        checkbox.name = name;
        checkbox.update();
    };



    checkbox.setChecked = function(checked, fireChangeEvent = true)
    {
        const oldChecked = checkbox.checked;

        checkbox.checked = checked;
        checkbox.update();

        if (   fireChangeEvent
            && checked != oldChecked)
            checkbox.dispatchEvent(checkbox.onchange);
    };



    checkbox.update = function()
    {
        if (checkbox.checked)
        {
            checkbox.check.style.backgroundColor    = 'var(--figma-color-bg-brand)';
            checkbox.check.style.backgroundImage    = 'url(\'data:image/svg+xml;utf8,<svg width="8" height="7" viewBox="0 0 8 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.17647 1.88236L3.05882 3.76472L6.82353 0L8 1.17648L3.05882 6.11768L0 3.05884L1.17647 1.88236Z" fill="white"/></svg>\')';
            checkbox.check.style.backgroundPosition = '50% 50%';
            checkbox.check.style.backgroundRepeat   = 'no-repeat';
            checkbox.check.style.boxShadow          = 'none';
        }
        else
        {
            checkbox.check.style.background         = 'transparent';
            checkbox.check.style.boxShadow          = '0 0 0 1px var(--figma-color-text) inset';
        }

        checkbox.text.innerHTML = name;
    };



    checkbox.update();
}


class GraphView
{
    div;

    wireContainer;

    scrollbarX;
    scrollbarY;


    wires          = [];
    

    creatingNodes  = false;
    loadingNodes   = false;
    pastingNodes   = false;
    restoringNodes = false;


    canUpdateNodes = true;


    activeNodes    = [];


    overNode       = null;
    overInput      = null;
    overOutput     = null;
        
    headerInput    = null; // same as overInput, but when snapping from a header
    headerOutput   = null; // same as overOutput, but when snapping from a header
        
    tempConn       = null;
    tempConnSwap   = null;
    savedConn      = null;
    tempConnected  = false;

    connPointerId  = -1;

    soloMode       = false;
    _soloNode      = null;
    
    selecting      = false;
    selectionRect  = Rect.NaN;

    startedInPanel = false;


    btn1down       = false; // this is to help deal with mouse wheels that send X values as
                            // sometimes a MMB press is followed by wheelX as a "deeper" middle-click

    altDown        = false;

    panning        = false;
    
    pViewport; 
    pStart         = point(0, 0);
    zoomStart;


    touches        = [];


    wheelTimer     = null;


    measureData    = {};



    panning = false;
    panStart;
    
    spaceDown = false;
    
    
    
    oldZoom = 1;


    zooming       = false;
    zoomStart     = 1;

    zoomSelecting = false;


    panZoomTimer  = null;



    _selectedNodes     = [];
    _prevSelectedNodes = [];
    lastSelectedNodes  = [];
    
    
    get selectedNodes() { return this._selectedNodes; }
    set selectedNodes(nodes)
    {
        this.deselectAll();

        this._selectedNodes = [...nodes];
    
        for (const node of this._selectedNodes)
            node.setSelected(true);
    }



    constructor(div)
    {
        this.div                     = div;
          
        this.wireContainer           = createDiv('wireContainer');
                  
        this.scrollbarX              = createDiv('scrollbar', 'scrollbarX');
        this.scrollbarY              = createDiv('scrollbar', 'scrollbarY');


        this.scrollbarX.style.zIndex = MAX_INT32-1;
        this.scrollbarY.style.zIndex = MAX_INT32-2;

        this.scrollbarX.moving       = false;
        this.scrollbarY.moving       = false;


        this.div.appendChild(this.wireContainer);
        this.div.appendChild(this.scrollbarX);
        this.div.appendChild(this.scrollbarY);


        this.createEvents();
        this.createScrollbarMethods();
    }



    update()
    {
        graphView.updatePanAndZoom(false);
        graphView.updateScrollWithBounds();
        graphView.div.style.height = 'calc(100% - ' + getTopHeight() + 'px)';
        graphView.updateMeasureData();
    }



    updateMeasureData()
    {
        this.measureData.clientRect = clientRect(this.div);
    }



    getNodeArrayBounds(nodes)
    {
        let bounds = Rect.NaN;

        for (const node of nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        return bounds;
    }



    getAllNodeBounds(onlySelected = false)
    {
        let bounds = Rect.NaN;

        const nodes =
                onlySelected
            && !isEmpty(this.selectedNodes)
            ? this.selectedNodes
            : graph.pageNodes;

        for (const node of nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        return bounds;
    }



    getAllNodeOffsets(nodes = null)
    {
        let bounds = Rect.NaN;

        if (!nodes)
            nodes = graph.pageNodes;

        for (const node of nodes)
            bounds = expandRect(bounds, offsetRect(node.div));

        return bounds;
    }



    // getAllNodeBounds()
    // {
    //     let bounds = Rect.NaN;

    //     for (const node of graph.pageNodes)
    //         bounds = expandRect(bounds, boundingRect(node.div));

    //     return bounds;
    // }



    getNodeBounds(node)
    {
        const bounds = boundingRect(node.div);

        return new Rect(
            parseFloat(node.div.style.left ),
            parseFloat(node.div.style.top  ),
            parseFloat(node.div.style.width),
            bounds.h / graph.currentPage.zoom); // node height isn't defined
    }



    getZoomedNodeBounds(node)
    {
        const bounds = this.getNodeBounds(node);

        bounds.x += graph.currentPage.pan.x / graph.currentPage.zoom;
        bounds.y += graph.currentPage.pan.y / graph.currentPage.zoom;
        bounds.w /= graph.currentPage.zoom;
        bounds.h /= graph.currentPage.zoom;

        return bounds;
    }



    getIntersectingNodes(node)
    {
        const nodeBounds = this.getZoomedNodeBounds(node);

        const intersecting = [];
        
        for (const n of graph.pageNodes)
        {
            const nBounds = this.getZoomedNodeBounds(n);
            
            if (   n != node
                && rectsIntersect(nBounds, nodeBounds))
                intersecting.push(n);
        }

        return intersecting;
    }



    placeNewNode(node)
    {
        if (node.type == PANEL)
        {
            node.div.style.left = (this.div.offsetWidth /2 - graph.currentPage.pan.x) / graph.currentPage.zoom - defPanelWidth /2;
            node.div.style.top  = (this.div.offsetHeight/2 - graph.currentPage.pan.y) / graph.currentPage.zoom - defPanelHeight/2;
        }
        else
        {
            const nodeHeight = defHeaderHeight + node.params.length * defParamHeight;
            
            node.div.style.left = (this.div.offsetWidth /2 - graph.currentPage.pan.x) / graph.currentPage.zoom - defNodeWidth/2;
            node.div.style.top  = (this.div.offsetHeight/2 - graph.currentPage.pan.y) / graph.currentPage.zoom - nodeHeight  /2;
        }
    }



    autoPlaceNewNode(output, input)
    {
        //console.log('GraphView.autoPlaceNewNode()');

        const defaultPlacementGap = 30;

        input.node.div.style.left = output.node.div.offsetLeft + output.node.div.offsetWidth + defaultPlacementGap;
        input.node.div.style.top  = output.node.div.offsetTop;//outputRect.y - graph.currentPage.pan.y/graph.currentPage.zoom - (inputRect.y - inputNodeRect.y);
    }



    putNodeOnTop(node)
    {
        const topIndices = 
               1 
            +  node.inputs.filter(i => i.connected).length 
            + (node.outputs.find(o => o.connected) ? 1 : 0);
            
        for (const n of graph.pageNodes)
            n.div.style.zIndex = Math.max(0, Number(n.div.style.zIndex) - topIndices);
            
        node.div.style.zIndex = MAX_INT32-3; // -3 is for scrollbars;

        this.putWiresOnTop(node);
    }



    putWiresOnTop(node)
    {
        // changing z-index doesn't work so easily with SVG,
        // so reinsert the wires on top instead 🤷‍♂️

        let z = MAX_INT32;

        for (const input of node.inputs.filter(i => i.connected))
        {
            this.wireContainer.removeChild(input.connection.wire.svg);
            this.wireContainer.appendChild(input.connection.wire.svg);
        }
            
        for (const output of node.outputs)
        {
            for (const connInput of output.connectedInputs)
            {
                this.wireContainer.removeChild(connInput.connection.wire.svg);
                this.wireContainer.appendChild(connInput.connection.wire.svg);
            }
        }
    }



    showCompatibleInputs(output = null)
    {
        for (const node of graph.pageNodes)
            for (const input of node.inputs)
                input.div.style.opacity = 
                       !output 
                    || input.canConnectFrom(output)
                    || input.connected
                    ? 1 
                    : 0;
    }
    
    
    
    hideAllInputs(except = null)
    {
        for (const node of graph.pageNodes)
            for (const input of node.inputs)
                if (    input != except
                    && !input.connected)
                    input.div.style.opacity = 0;
    }
    
    
   
    showCompatibleOutputs(input = null)
    {
        for (const node of graph.pageNodes)
            for (const output of node.outputs)
                output.div.style.opacity = 
                       !input 
                    || input.canConnectFrom(output)
                    || !output.connected
                    ? 1 
                    : 0;
    }
    
    
    
    hideAllOutputs(except = null)
    {
        for (const node of graph.pageNodes)
            for (const output of node.outputs)
                if (    output != except
                    && !output.connected)
                    output.div.style.opacity = 0;
    }
    
    
   
    // point2screen(p)
    // {
    //     return point(
    //         (p.x + graph.currentPage.pan.x / graph.currentPage.zoom) * graph.currentPage.zoom,
    //         (p.y + graph.currentPage.pan.y / graph.currentPage.zoom) * graph.currentPage.zoom);
    // }
    
    
    
    // screen2point(p)
    // {
    //     return point(
    //         p.x / graph.currentPage.zoom - graph.currentPage.pan.x / graph.currentPage.zoom,
    //         p.y / graph.currentPage.zoom - graph.currentPage.pan.y / graph.currentPage.zoom);
    // }
    
    
    
    // rect2screen(rect)
    // {
    //     return new Rect(
    //         (rect.x + graph.currentPage.pan.x / graph.currentPage.zoom) * graph.currentPage.zoom,
    //         (rect.y + graph.currentPage.pan.y / graph.currentPage.zoom) * graph.currentPage.zoom,
    //         rect.width  * graph.currentPage.zoom,
    //         rect.height * graph.currentPage.zoom);
    // }
    
    
    
    screen2rect(rect)
    {
        return new Rect(
            rect.x      / graph.currentPage.zoom - graph.currentPage.pan.x / graph.currentPage.zoom,
            rect.y      / graph.currentPage.zoom - graph.currentPage.pan.y / graph.currentPage.zoom,
            rect.width  / graph.currentPage.zoom,
            rect.height / graph.currentPage.zoom);
    }
    
    
    
    // toJson()
    // {
    //     const tab = '\n' + HTAB;

    //     return '{'
    //         + tab + '"zoom": "' + graph.currentPage.zoom  + '",'
    //         + tab + '"panx": "' + graph.currentPage.pan.x + '",'
    //         + tab + '"pany": "' + graph.currentPage.pan.y + '"'
    //         + '\n}';
    // };
}


GraphView.prototype.updateNodes = function(nodes = null, updateNodes = true)
{
    if (!nodes)
        nodes = graph.pageNodes;
        
    
    documentBodyClient = clientRect(document.body);


    this.updateNodeTransforms(nodes, false);
    this.updateNodeTransforms(nodes); // this has to be done twice //because getAllNodeBounds() forces a reflow

    nodes.forEach(n => n.updateMeasureData());

    if (updateNodes)
    {
        nodes.forEach(n =>
        {
            n.updateHeader(); 
            n.updateHeaderLabel();
            n.updateBorder();
            n.updateDisabled();

            if (n.updateSizers)
                n.updateSizers();
        });
    }


    const x = this.measureData.clientRect.left;
    const w = this.measureData.clientRect.width;
    const h = this.measureData.clientRect.height;
    
    const bounds = this.getAllNodeBounds();

    this.updateScroll(x, w, h, bounds, getTopHeight());
};



GraphView.prototype.updateNodeTransforms = function(nodes, _updateWires = true)
{
    const nodeLeft = nodes.map(n => n.div.offsetLeft);
    const nodeTop  = nodes.map(n => n.div.offsetTop);
    const nodeRect = nodes.map(n => n.getOffsetRect());

    for (let i = 0; i < nodes.length; i++)
        nodes[i].setTransform(nodeLeft[i], nodeTop[i], nodeRect[i]);

    if (_updateWires)
        this.updateNodeWireTransforms(nodes);
};



GraphView.prototype.updateNodeWireTransforms = function(nodes)
{
    const wires = [];

    
    for (const node of nodes)
    {
        for (const input of node.inputs)
            if (   input.connected
                && input.connection
                && !wires.includes(input.connection.wire))
                wires.push(input.connection.wire);        

        for (const output of node.outputs)
            for (const connInput of output.connectedInputs)
                if (    connInput.connection
                    && !wires.includes(connInput.connection.wire))
                    wires.push(connInput.connection.wire);
    }


    this.updateWires(wires);
};



GraphView.prototype.soloNode = function(node)
{
    this._soloNode = node;

    graph.pageNodes.forEach(n => 
        n.div.style.opacity = 
                n == this._soloNode
            //|| n.isConnectedTo(this._soloNode)
            ? 1 
            : 0.2);

    graph.connections.forEach(c =>
    { 
        c.wire.svg.style.opacity = 
               c.input  && this._soloNode == c.input .node
            || c.output && this._soloNode == c.output.node
            ? 1 
            : 0.15;
    });


    this.updateWires(graph.connections.map(c => c.wire));
};



GraphView.prototype.unsoloNode = function()
{
    this._soloNode = null;

    graph.pageNodes  .forEach(n => n.div     .style.opacity = 1);
    graph.connections.forEach(c => c.wire.svg.style.opacity = 1);

    this.updateWires(graph.connections.map(c => c.wire));
};



GraphView.prototype.updateShowWires = function(updateNodes = true)
{
    graph.connections.forEach(c => showElement(c.wire.svg, true));

    if (updateNodes) 
        graph.pageNodes.forEach(n => n.updateNode());
};



GraphView.prototype.setNodePositions = function(nodes, dx, dy, updateTransform = true)
{
    //console.log('GraphView.setNodePositions()');

    for (const node of nodes)
    {
        node.div.style.left = node.slx + dx + 'px';
        node.div.style.top  = node.sly + dy + 'px';
    }

    if (updateTransform)
        this.updateNodeTransforms(nodes);
};



GraphView.prototype.selectAllNodes = function(invert)
{
    const lastSelected = [...this.selectedNodes];

    this.selectedNodes = 
        invert
        ? graph.pageNodes.filter(n => !lastSelected.includes(n))
        : graph.pageNodes;
        
    actionManager.do(new SelectNodesAction(
        this.selectedNodes.map(n => n.id), 
        lastSelected      .map(n => n.id)));
};



GraphView.prototype.deselectAllNodes = function()
{
    const lastSelected = [...this.selectedNodes];

    this.selectedNodes = [];
        
    actionManager.do(new SelectNodesAction(
        this.selectedNodes.map(n => n.id), 
        lastSelected      .map(n => n.id)));
};



GraphView.prototype.copySelectedNodes = function()
{
    pasteOffset     = point(0, 0);
    copiedNodesJson = uiCopyNodes(this.selectedNodes.map(n => n.id));

    writeTextToClipboard(copiedNodesJson);
};



class GenJS
{
    nodes;
    terminals;

    nTab = 0;
    
    get tab() { return TAB.repeat(this.nTab); }
    get NL () { return '\n' + this.tab; }


    constructor(nodes, terminals)
    {
        this.nodes     = nodes;
        this.terminals = terminals;
    }


    connectedOut(node)
    {
        return node.inputs.find(i => 
                      i.connected 
                   && !this.nodes.includes(i.connectedOutput.node));
    }
};



GraphView.prototype.copySelectedNodesAsJavascript = function()
{
    const terminals = getTerminalsInNodes(this.selectedNodes);

    const gen = new GenJS(this.selectedNodes, terminals);


    let js = '';

    for (const terminal of terminals)
    {
        js += '\n';
        js += terminal.toJavascript(gen);
    }


    console.log(js);
    writeTextToClipboard(js);
};



GraphView.prototype.pasteCopiedNodes = function(pasteConnected, clientX = Number.NaN, clientY = Number.NaN)
{
    readTextFromClipboard().then(text =>
    {
        if (text == '')
            return;

        const x = (clientX - graph.currentPage.pan.x) / graph.currentPage.zoom;
        const y = (clientY - graph.currentPage.pan.y) / graph.currentPage.zoom;

        
        actionManager.do(new PasteNodesAction(text, pasteConnected, false, false, x, y));
    });
};



GraphView.prototype.duplicateSelectedNodes = function(pasteConnected)
{
    if (!isEmpty(this.selectedNodes))
    {
        pasteOffset = point(0, 0);
        actionManager.do(new PasteNodesAction(uiCopyNodes(this.selectedNodes.map(n => n.id)), pasteConnected, true));
    }
};



GraphView.prototype.deleteSelectedNodes = function(cut = false)
{
    const nodeIds = this.selectedNodes.map(n => n.id);

    if (!isEmpty(nodeIds))
    {
        actionManager.do(new DeleteNodesAction(nodeIds, cut));
        this._selected = [];
    }
};



GraphView.prototype.removeSelectedNodes = function()
{
    const nodeIds = this.selectedNodes.map(n => n.id);

    if (!isEmpty(nodeIds))
    {
        actionManager.do(new RemoveNodesAction(nodeIds));
        this._selected = [];
    }
};



GraphView.prototype.renameSelectedNode = function()
{
    if (this.selectedNodes.length == 1)
        this.selectedNodes[0].showLabelTextbox();
};



GraphView.prototype.editSelectedCustomNode = function()
{
    actionManager.do(new SetCurrentGraphAction(this.selectedNodes[0].graph));
};



GraphView.prototype.getTopNodeIndex = function()
{
    let max = 0;
    
    for (const node of graph.pageNodes)
        max = Math.max(max, node.div.style.zIndex);

    return max;
};



GraphView.prototype.nudgeSelected = function(x, y)
{
    graphView.selectedNodes.forEach(n => 
        n.setPosition(
            n.div.offsetLeft + x / graph.currentPage.zoom,
            n.div.offsetTop  + y / graph.currentPage.zoom,
            true));
};


GraphView.prototype.startConnectionFromOutput = function(pointerId, output, updateTempWire = true, backInit = false)
{
    this.connPointerId = pointerId;

    this.tempConn          = new Connection(output, null);
    this.tempConn.backInit = backInit;

    //this.tempConnected = false;
    this.addConnWires(this.tempConn, false);

    if (updateTempWire)
        this.tempConn.wire.update(this.pStart.x, this.pStart.y);

    this.showCompatibleInputs(output);
    this.hideAllOutputs(this.tempConn.output);

    output.updateControl();


    // if (dragOutTimer) clearInterval(dragOutTimer);
    // dragOutTimer = setInterval(() => checkDragOut(), 200);

    //try { this.div.setPointerCapture(pointerId); } catch {}
};



GraphView.prototype.startConnectionFromInput = function(pointerId, input, backInit = false)
{
    this.connPointerId = pointerId;

    this.tempConn          = new Connection(null, input);
    this.tempConn.backInit = backInit;
    
    this.addConnWires(this.tempConn, false);

    this.tempConn.wire.update(this.pStart.x, this.pStart.y);

    this.showCompatibleOutputs(input);
    this.hideAllInputs(this.tempConn.input);

    input.updateControl();


    // if (dragOutTimer) clearInterval(dragOutTimer);
    // dragOutTimer = setInterval(() => checkDragOut(), 200);

    //try { this.div.setPointerCapture(pointerId); } catch {}
};



GraphView.prototype.cancelConnection = function(pointerId)
{
    const output = this.tempConn.output;
    const input  = this.tempConn.input;

    this.removeConnWires(this.tempConn);    

    if (this.savedConn)
        this.savedConn.wire.update();

    this.savedConn = null;
    this.tempConn  = null;

    if (output) output.updateControl();
    if (input ) input .updateControl();

    if (this.overInput ) this.overInput .updateControl();
    if (this.overOutput) this.overOutput.updateControl();


    if (this.div.hasPointerCapture(pointerId))
        this.div.releasePointerCapture(pointerId);

    this.connPointerId = -1;


    this.showCompatibleInputs();
    this.showCompatibleOutputs();


    newReorderIndex  = Number.NaN;
    prevReorderIndex = Number.NaN;
    oldReorderIndex  = Number.NaN;


    // if (dragOutTimer) 
    // {
    //     clearInterval(dragOutTimer);
    //     dragOutTimer = null;
    // }
};



GraphView.prototype.endConnection = function(pointerId, backInit = false, shiftKey = false)
{
    if (this.tempConn.output) // FROM OUTPUT
    {
        let output = this.tempConn.output;
        let input  = this.overInput;

        let savedConnInput = 
            this.savedConn
            ? this.savedConn.input
            : null;

        output.connecting = false;
        

        if (   input
            && input.canConnectFrom(output))
        {
            if (  !savedConnInput
                || savedConnInput != input) // TO INPUT
            {
                if (input.node.variableInputs) this.endConnectionFromOutputToVariable(output, input, savedConnInput, backInit, shiftKey);
                else                           this.endConnectionFromOutputToFixed   (output, input, savedConnInput, backInit, shiftKey);
            }
            // if (   !isNaN(newReorderIndex)
            //     && !isNaN(oldReorderIndex)
            //     &&  newReorderIndex != oldReorderIndex
            //     &&  newReorderIndex >= 0
            //     &&  input.node.variableInputs
            //     && !input.param
            //     && !isLastInArray(input.node.headerInputs, input))
            // {
            //     console.log('1 reorder');
            //     actionManager.do(new ReorderInputsAction(input.node.id, oldReorderIndex, newReorderIndex));
            // }
            // else if (savedConnInput
            //       && savedConnInput.connectedOutput == this.tempConn.output
            //       && savedConnInput.index != input.index
            //       && savedConnInput.node.headerInputs.includes(savedConnInput) == savedConnInput.node.headerInputs.includes(input)
            //       && (  !input.node.variableInputs &&  input.index < input.node.inputs.length
            //           || input.node.variableInputs && (input.index < input.node.headerInputs.length-1 || input.index >= input.node.headerInputs.length)))
            // {
            //     console.log('2 reorder');
            //     // if (input.node.variableInputs)
            //     // {
            //     //     moveInArray(
            //     //         input.node.inputs,
            //     //         input.node.inputs.indexOf(savedConnInput),
            //     //         input.index);

            //     //     actionManager.do(new ReorderInputsAction(savedConnInput.node.id, oldReorderIndex, savedConnInput.index));
            //     // }
            //     // else
            //     // {
            //         actionManager.do(new ReorderInputConnectionsAction(savedConnInput.node.id, savedConnInput.id, input.id));
            //     // }
            // }
            // else if (input == savedConnInput
            //       && input.connection) // reconnect old
            // {
            //     console.log('3 reconnect');
            //     this.savedConn = null; // done here to redraw the saved wire correctly
            //     input.connection.wire.show(true);
            // }
            // else if (savedConnInput
            //       && input.node.variableInputs
            //       && savedConnInput.index >= input.node.headerInputs.length
            //       && input.index == input.node.headerInputs.length-1
            //       && input.isNew)
            // {
            //     // reconnect from below header to new variable new input
            //     console.log('4 reconnect');
            //     actionManager.do(new ReconnectAction(output, savedConnInput, input));
            // }
            // else if (savedConnInput
            //       && savedConnInput.connectedOutput == output
            //       && (  !input.node.variableInputs
            //           || input.index >= input.node.headerInputs.length
            //           || (   input.node.variableInputs
            //               && (      input.node.headerInputs.length > 1 
            //                      && input.index < input.node.headerInputs.length-1
            //                   ||    input.node.headerInputs.length == 1 
            //                      && input.index == 0))))
            // {
            //     console.log('5 reconnect');
            //     actionManager.do(new ReconnectAction(output, savedConnInput, input));
            // }
            // else if (   !savedConnInput
            //         && (  !input.connected
            //             || input.connectedOutput != this.tempConn.output)) // connect new
            // {
            //     console.log('6 createConnectAction');
            //     actionManager.do(new ConnectAction(output, input, {backInit: backInit}));
            // }
        }
        else if (savedConnInput)
            actionManager.do(new DisconnectAction(savedConnInput));
        

        if (this.savedConn) this.savedConn.wire.show(true);
        this.cancelConnection(pointerId);
    }
    
    else if (this.tempConn.input) // FROM INPUT
    {
        let input  = this.tempConn.input;
        let output = this.overOutput;

        input.connecting = false;

        if (   output
            && output.canConnectTo(input)) //input.canConnectFrom(output)) // TO OUTPUT
            actionManager.do(new ConnectAction(output, input, {backInit: backInit, shiftKey: shiftKey}));

        this.cancelConnection(pointerId);
    }


    // if (dragOutTimer) 
    // {
    //     clearInterval(dragOutTimer);
    //     dragOutTimer = null;
    // }
};



GraphView.prototype.endConnectionFromOutputToFixed = function(output, input, savedConnInput, backInit = false, shiftKey = false)
{
    if (   !savedConnInput
        && (  !input.connected
            || input.connectedOutput != this.tempConn.output))
    {
        //console.log('F1 connect new');
        actionManager.do(new ConnectAction(output, input, {backInit: backInit, shiftKey: shiftKey}));
    }
    else if (savedConnInput
          && savedConnInput.connectedOutput == output)
    {
        //console.log('F2 reconnect');
        actionManager.do(new ReconnectAction(output, savedConnInput, input));
    }
    // else if (savedConnInput
    //       && savedConnInput.connectedOutput == this.tempConn.output
    //       && savedConnInput.index != input.index
    //       && savedConnInput.node.inputs.includes(savedConnInput) == savedConnInput.node.inputs.includes(input))
    // {
    //     console.log('2 reorder');
    //     actionManager.do(new ReorderInputConnectionsAction(savedConnInput.node.id, savedConnInput.id, input.id));
    // }


    // if (dragOutTimer) 
    // {
    //     clearInterval(dragOutTimer);
    //     dragOutTimer = null;
    // }
};



GraphView.prototype.endConnectionFromOutputToVariable = function(output, input, savedConnInput, backInit = false, shiftKey = false)
{
    if (   !savedConnInput
        && (  !input.connected
            || input.connectedOutput != this.tempConn.output))
    {
        //console.log('V1 connect new');
        actionManager.do(new ConnectAction(output, input, {backInit: backInit, shiftKey: shiftKey}));
    }
    else if (savedConnInput
          && savedConnInput.connectedOutput == output
          && (   savedConnInput.node != input.node
              ||    savedConnInput.index < input.node.headerInputs.length-1
                 && input.index >= input.node.headerInputs.length
              ||    savedConnInput.index >= input.node.headerInputs.length 
                 && input.index < input.node.headerInputs.length-1))
    {
        // if (input.index <)
        //console.log('V2 reconnect');
        actionManager.do(new ReconnectAction(output, savedConnInput, input));
    }


    // if (dragOutTimer) 
    // {
    //     clearInterval(dragOutTimer);
    //     dragOutTimer = null;
    // }
};



GraphView.prototype.createTempConnSwap = function(oldInput, newInput)
{
    this.tempConnSwap = new Connection(oldInput.output, newInput);
    this.addConnWires(this.tempConnSwap, false);
    this.tempConnSwap.wire.update();
};



GraphView.prototype.deleteTempConnSwap = function(oldInput, newInput)
{
    this.removeConnWires(this.tempConnSwap);    
    this.tempConnSwap = null;
};


GraphView.prototype.addConnWires = function(conn, updateTransform = true)
{
    this.addWire(conn.wire, updateTransform);
};



GraphView.prototype.addWire = function(wire, updateTransform = true)
{
    this.wires.push(wire);
    this.wireContainer.appendChild(wire.svg);
};



GraphView.prototype.removeConnWires = function(conn)
{
    this.removeWire(conn.wire);
};



GraphView.prototype.removeWire = function(wire)
{
    if (this.wireContainer.contains(wire.svg))
        this.wireContainer.removeChild(wire.svg);    

    if (this.wires.includes(wire))
        removeFromArray(this.wires, wire);
};



GraphView.prototype.updateWires = function(_wires)
{
    //logFunction('GraphView.updateWires()');
    
    const wires = [..._wires];


    const nWires = wires.length;

    for (let i = 0; i < nWires; i++)
    {
        if (wires[i].connection.proxy)
            pushUnique(wires, wires[i].connection.proxy.wire);
    }


    const pOut    = [];
    const pIn     = [];
    
    const cw      = this.measureData.clientRect.width;
    const ch      = this.measureData.clientRect.height;
    
    const yOffset = getTopHeight() + 1;


    wires.forEach(w => 
    {
        const ro = boundingRect(w.connection.output.div);
        const ri = boundingRect(w.connection.input .div);

        pOut.push(point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset));
        pIn .push(point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset));
    });

       
    for (let i = 0; i < wires.length; i++)
    {
        const wire = wires[i];

        // the yOffset is to start wire coords just below the control bar,
        // not at the top of the window

        wire.updateCurve(pOut[i].x, pOut[i].y, pIn[i].x, pIn[i].y);

        if (wire.outBall) wire.updateOutBall(pOut[i].x, pOut[i].y);
        if (wire. inBall) wire.updateInBall (pIn [i].x, pIn [i].y);

        wire.updateStyle();

        wire.svg.setAttribute('width',  cw);
        wire.svg.setAttribute('height', ch);
    
        wire.svg.setAttribute('viewBox',
                    0
            + ' ' + 0
            + ' ' + cw
            + ' ' + ch);
    }
};


GraphView.prototype.createEvents = function()
{
    this.div.addEventListener('pointerenter', e => 
    {
        if (    this.div.hasPointerCapture(e.pointerId)
            && !this.tempConn)
            this.div.releasePointerCapture(e.pointerId);
    });



    this.div.addEventListener('pointerleave', e => 
    {
        if (graphView.soloMode)
            graphView.soloNode(null);

            
        // if (this.tempConn)
        // {
        //     try { this.div.setPointerCapture(e.pointerId); } catch {}
        // }
    });



    // this.div.addEventListener('pointerdown', e =>
    // {
    //     if (   e.button == 0)
    //         // && (   document.canResizeL
    //         //     || document.canResizeR
    //         //     || document.canResizeB))
    //     {
    //         e.stopPropagation();
    //         forwardEvent(e, document);
    //     }
    // }, 
    // true);



    this.div.addEventListener('pointerdown', e =>
    {
        this.pStart = point(e.clientX, e.clientY);

        const sx = e.clientX;
        const sy = e.clientY;


        hideAllMenus();
        hideSearchBox();


        if (   e.button == 0
            && !this.panning
            && !this.tempConn
            && !this.scrollbarX.moving
            && !this.scrollbarY.moving)
            // && !document.canResizeL
            // && !document.canResizeR
            // && !document.canResizeB)
        {
            if (   this.spaceDown
                || panMode)
            {
                if (getCtrlKey(e)) this.startZoomSelection(e.pointerId, e.clientX, e.clientY);
                else               this.startPan(e.pointerId);
            }
            else if (this.overOutput)
            {
                this.overOutput.connecting = true;
                this.startConnectionFromOutput(e.pointerId, this.overOutput, true, getCtrlKey(e));

                this.tempConn.wire.update(sx, sy);
            }
            else if (this.overInput)
            {
                if (this.overInput.connectedOutput) // begin to disconnect
                {
                    oldReorderIndex = this.overInput.index;

                    this.startConnectionFromOutput(e.pointerId, this.overInput.connectedOutput, false, getCtrlKey(e));

                    this.tempConn.wire.update(sx, sy);

                    this.savedConn = this.overInput.connection;
                    this.savedConn.wire.show(false);
                }
                else
                {
                    this.overInput.connecting = true;
                    this.startConnectionFromInput(e.pointerId, this.overInput, getCtrlKey(e));

                    
                    this.tempConn.wire.update(sx, sy);
                }
            }
            else if (document.activeElement.type != 'text') // selection, unless a textbox is in focus
            {
                window.getSelection().removeAllRanges();
                
                this.lastSelectedNodes = [...this.selectedNodes];

                this.startSelection(
                    e.pointerId,
                    e.clientX,
                    e.clientY,
                    e.shiftKey,
                    getCtrlKey(e));
            }
        }

        else if (e.button == 1)
        {
            e.preventDefault();
            
            this.btn1down = true;
            setCursor(panCursor);
            this.startPan(e.pointerId);
        }

        else if (e.button == 2)
        {
            e.stopPropagation();

            if (isEmpty(currentMenus)) menuGraph.showAt(e.clientX, e.clientY, false, false);
            else                       hideAllMenus();
        }
    });



    this.div.addEventListener('pointermove', graphView_onpointermove);



    // this.div.addEventListener('pointermove', e =>
    // {
    //     if (   document.canResizeL
    //         || document.canResizeR
    //         || document.canResizeB)
    //     {
    //         //checkResize(e.clientX, e.clientY);
    //         e.stopImmediatePropagation();
    //     }
    // },
    // true);



    this.div.addEventListener('pointerup', e => 
    {
        if (   e.button == 0
            && (   this.spaceDown
                || panMode))
        {
            if (getCtrlKey(e))
            {
                if (    this.selectionRect.w != 0
                    &&  this.selectionRect.h != 0
                    && !this.altDown)
                {
                    this.oldZoom = graph.currentPage.zoom;
                    this.endZoomSelection(e.pointerId, true);
                }
                else
                {
                    const wndRect = new Rect(
                        1,
                        getTopHeight() + 1,
                        this.measureData.clientRect.width  - 2,
                        this.measureData.clientRect.height - 5);

                    const selection = Rect.fromRect(this.selectionRect);


                    this.oldZoom = graph.currentPage.zoom;
                    this.endZoomSelection(e.pointerId, false);

                    if (!this.altDown) graph.currentPage.zoom *= 2;
                    else               graph.currentPage.zoom /= 2;
                    
                    
                    graph.currentPage.pan.x += wndRect.c - selection.c;
                    graph.currentPage.pan.y += wndRect.m - selection.m;


                    this.updateNodes();
                }
            }

            this.endPan(e.pointerId, false);


            if (this.panZoomTimer)
            {
                clearTimeout(this.panZoomTimer); 
                this.panZoomTimer = null;
            };


            this.p = null;
        }

        else if (e.button == 0
            && !this.selectionRect.isNaN)
            this.endSelection(e.pointerId);

        else if (e.button == 0
            && this.tempConn)
        {
            this.endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);

            // if (this.div.hasPointerCapture(e.pointerId))
            //     this.div.releasePointerCapture(e.pointerId);
        }
        else if (e.button == 1
            && this.panning)
        {
            this.btn1down = false;
            this.endPan(e.pointerId, true);
        }
    });



    this.div.addEventListener('dblclick', e =>
    {
        if (    e.button == 0
            && !e.shiftKey)
        {
            stopRequestId = curRequestId;

            
            const activeNodes = [];

            for (const node of graph.nodes)
            {
                if (node.active)
                {
                    uiMakeNodePassive(node);
                    activeNodes.push(node);

                    if (node.type == ITEMS)
                        pushUpdate(null, [node]);
                }
            }

            uiSaveNodes(activeNodes.map(n => n.id));
            graphView.updateNodes(activeNodes);
            
            uiDeleteObjectsAndStyles(activeNodes.map(n => n.id));
        }
    });



    this.div.addEventListener('wheel', e =>
    {
        if (this.btn1down)
            return;


        // if button is not pressed wheel pans
        // if button is pressed, wheel does nothing if it's a touchpad

        e.preventDefault();


        const dZoom = Math.log(graph.currentPage.zoom) / Math.log(2);


        const touchpad = isTouchpad(e);

        const dWheelX = e.deltaX / (touchpad ? 20 : 100);
        const dWheelY = e.deltaY / (touchpad ? 20 : 100);


        const dragging = graph.currentPage.nodes.find(n => n.div.dragging === true);


        if (   e.ctrlKey //getCtrlKey(e)
            ||     panMode
               && !touchpad)
        {
            if (!dragging)
            {
                let pos = point(
                    e.clientX, 
                    e.clientY - getTopHeight());

                const zoom = Math.max(0.0001, Math.pow(2, dZoom - dWheelY / (touchpad ? 4 : 10)));
                const pan  = subv(graph.currentPage.pan, mulvs(subv(pos, graph.currentPage.pan), zoom / graph.currentPage.zoom - 1));

                graph.currentPage.setPanAndZoom(pan, zoom);
            }


            this.updateWheelTimer();
        }
        else
        {
            const dPanX = (e.shiftKey ? dWheelY : dWheelX) * 20 / Math.pow(graph.currentPage.zoom, 0.1);
            const dPanY = (e.shiftKey ? dWheelX : dWheelY) * 20 / Math.pow(graph.currentPage.zoom, 0.1);

            graph.currentPage.pan = point(
                graph.currentPage.pan.x - dPanX,
                graph.currentPage.pan.y - dPanY);

            
            if (this.selecting)
            {
                this.selectionRect.x -= dPanX;
                this.selectionRect.w += dPanX;

                this.selectionRect.y -= dPanY;
                this.selectionRect.h += dPanY;

                this.updateSelection(
                    e.clientX,
                    e.clientY,
                    e.shiftKey);
            } 


            if (dragging)
            {
                dragging.sx -= dPanX;
                dragging.sy -= dPanY;
                
                dragging.header.dispatchEvent(new MouseEvent('pointermove', 
                {
                    bubbles:    true,
                    cancelable: true,
                    view:       window,
                    detail:     0,
                    screenX:    e.screenX,
                    screenY:    e.screenY,
                    clientX:    e.clientX,
                    clientY:    e.clientY,
                    ctrlKey:    e.ctrlKey,
                    altKey:     e.altKey,
                    shiftKey:   e.shiftKey,
                    metaKey:    e.metaKey,
                    button:     e.button,
                    buttons:    e.buttons
                }));
            }
            

            this.updateWheelTimer();
        }


        if (this.tempConn)
            graphView_onpointermove(e);
    });



    this.div.addEventListener('gesturestart', e => { this.zoomStart = graph.currentPage.zoom; });



    this.div.addEventListener('gesturechange', e => 
    {
        const p = point(
            this.p.x,
            this.p.y - getTopHeight());

        const zoom = this.zoomStart * e.scale;
        const pan  = subv(graph.currentPage.pan, mulvs(subv(p, graph.currentPage.pan), zoom / graph.currentPage.zoom - 1));

        graph.currentPage.setPanAndZoom(pan, zoom);
    });



    this.div.addEventListener('touchstart', e =>
    {
        this.touches.push(e);
        e.preventDefault();
    });



    this.div.addEventListener('touchmove', e =>
    {
        for (let i = 0; i < this.touches.length; i++)
            if (this.touches[i].pointerId == e.pointerId)
            {
                this.touches[i] = e;
                break;
            }

        e.preventDefault();
    });



    this.div.addEventListener('touchend', e =>
    {
        for (let i = 0; i < this.touches.length; i++)
            if (this.touches[i].pointerId == e.pointerId)
            {
                this.touches.splice(i, 1);
                break;
            }

        e.preventDefault();
    });



    this.div.addEventListener('touchcancel', e =>
    {
        for (let i = 0; i < this.touches.length; i++)
            if (this.touches[i].pointerId == e.pointerId)
            {
                this.touches.splice(i, 1);
                break;
            }

        e.preventDefault();
    });
}



GraphView.prototype.updateWheelTimer = function()
{
    if (this.wheelTimer) 
        clearTimeout(this.wheelTimer);

    this.wheelTimer = setTimeout(() => 
    {
        this.wheelTimer = null;

        if (overNumberControl)
            overNumberControl.updateCursor();

        setAutoCursor();

        graph.updateSavedPages();
    }, 
    400);
};



function graphView_onpointermove(e)
{
    graphView.p = point(e.clientX, e.clientY);


    if (   (   graphView.panning
            || panMode)
        && graphView.div.hasPointerCapture(e.pointerId))
    {
        setCursor(panCursor);

        const dp = subv(graphView.p, graphView.pStart);

        graph.currentPage.setPanAndZoom(
            addv(graphView.panStart, dp), 
            graph.currentPage.zoom);
    }

    else if (graphView.selecting)
        graphView.updateSelection(e.clientX, e.clientY, e.shiftKey, getCtrlKey(e));

    else if (graphView.zoomSelecting)
        graphView.updateZoomSelection(e.clientX, e.clientY);

    else if (graphView.tempConn)
        graphView.tempConn.wire.update(e.clientX, e.clientY);
}


//var dragOutTimer = null;



function checkDragOut()
{
    const pan  = graphView.currentPage ? graphView.currentPage.pan  : point(0, 0);
    const zoom = graphView.currentPage ? graphView.currentPage.zoom : 1;

    const offset = 10;
    
    if (graphView.p.x >= graphView.offsetWidth)
        graphView.currentPage.setPanAndZoom(point(pan.x + offset, pan.y), zoom);
}



GraphView.prototype.updatePanAndZoom = function(updateNodes)
{
    this.updateNodes(graph.pageNodes, updateNodes);

    
    setTimeout(() =>
    {
        updateZoomTooltip();
        updateZoomIcon();

        menuItemZoomTo100.setChecked(equal(graph.currentPage.zoom, 1, 0.0001));
    });


    //console.log('pan = %s, zoom = %s', graph.currentPage.pan.x + ', ' + graph.currentPage.pan.y, graph.currentPage.zoom);
};



GraphView.prototype.startPan = function(pointerId)
{
    try 
    {
        this.div.setPointerCapture(pointerId);

        this.panning  = true;
        this.panStart = graph.currentPage.pan;

        setCursor(panCursor);
    }
    catch {}
};



GraphView.prototype.endPan = function(pointerId, changeCursor)
{
    this.panning = false;

    this.div.releasePointerCapture(pointerId);

    if (changeCursor)
        setAutoCursor();

    graph.updateSavedPages();
};



GraphView.prototype.isPanning = function(e)
{
    if (panMode)
    {
        e.preventDefault();
        setCursor(panCursor);
        return true;
    }

    if (this.spaceDown)
    {
        e.preventDefault();
        return true;
    }

    return false;
};



GraphView.prototype.startZoomSelection = function(pointerId, x, y)
{
    try
    {
        this.div.setPointerCapture(pointerId);

        this.zoomSelecting = true;
        this.selectionRect = new Rect(x, y, 0, 0);
        
        selectBox.style.visibility = 'visible';
        
        this.updateZoomSelectBox();
    }
    catch {}
};



GraphView.prototype.updateZoomSelection = function(x, y)
{
    if (!this.zoomSelecting) return;

    this.selectionRect.w = x - this.selectionRect.x;
    this.selectionRect.h = y - this.selectionRect.y;

    this.updateZoomSelectBox();
};



GraphView.prototype.updateZoomSelectBox = function()
{
    const selection = Rect.fromRect(this.selectionRect);

    selectBox.style.left   = selection.x + Math.min(selection.w, 0);
    selectBox.style.top    = selection.y + Math.min(selection.h, 0);
    selectBox.style.width  = Math.abs(selection.w);
    selectBox.style.height = Math.abs(selection.h);

    selectBox.style.zIndex = MAX_INT32-3;
};



GraphView.prototype.endZoomSelection = function(pointerId, zoom)
{
    if (zoom)
    {
        this.oldZoom = graph.currentPage.zoom;


        const wndRect = new Rect(
            1,
            getTopHeight() + 1,
            this.measureData.clientRect.width  - 2,
            this.measureData.clientRect.height - 5);
    
        let selection = validateRect(this.selectionRect);
        selection = clipRect(selection, wndRect);
    
        selection.y -= getTopHeight();

        
        const rect = this.screen2rect(selection);

        for (let i = 0; i < 5; i++)
            this.zoomToRect(rect, 0);
    }


    this.selectionRect = Rect.NaN;


    this.div.releasePointerCapture(pointerId);

    this.zoomSelecting    = false;
    selectBox.style.visibility = 'hidden';


    graph.updateSavedPages();
};



GraphView.prototype.zoomToFit = function()
{
    if (!isEmpty(graph.pageNodes))
        this.zoomToNodes(graph.pageNodes);
    else
        graph.currentPage.setPanAndZoom(point(0, 0), 1);
};



GraphView.prototype.zoomToSelection = function()
{
    if (!isEmpty(this.selectedNodes)) 
        this.zoomToNodes(this.selectedNodes);
};



GraphView.prototype.zoomToNodes = function(nodes, zoom = true, topOffset = 0)
{
    if (!isEmpty(nodes))
    {
        nodes.forEach(n => n.updateMeasureData());
        const offset = this.getAllNodeOffsets(nodes);

        offset.y -= topOffset / graph.currentPage.zoom;
        offset.h += topOffset / graph.currentPage.zoom;

        for (let i = 0; i < 5; i++) // need to do it a few times
            this.zoomToRect(offset, 40, zoom);
    }
};



GraphView.prototype.zoomToRect = function(rect, margin = 40, zoom = true)
{
    const viewRect   = this.measureData.clientRect;

    const viewAspect = viewRect.width / viewRect.height;
    const rectAspect = rect.width     / rect.height;


    if (zoom)
    {
        graph.currentPage.zoom = 
            viewRect.width >= viewRect.height
        
            ? (   rect.width >= rect.height
               && rectAspect > viewAspect
               ? (viewRect.width  - margin*2) / rect.width  
               : (viewRect.height - margin*2) / rect.height)
        
            : (   rect.width <  rect.height
               && rectAspect <= viewAspect
               ? (viewRect.height - margin*2) / rect.height 
               : (viewRect.width  - margin*2) / rect.width );
    }


    graph.currentPage.pan = 
    {
        x: viewRect.width /2 - (rect.x + rect.width /2) * graph.currentPage.zoom,
        y: viewRect.height/2 - (rect.y + rect.height/2) * graph.currentPage.zoom
    };

    
    graph.updateSavedPages();
};



function updateZoomIcon()
{
    if (settings.dataMode)
        return;

    
    const zoom =
        graph.currentPage
        ? graph.currentPage.zoom
        : 1;


    if (btnZoom)
    {
        btnZoom.divIcon.innerHTML       =  Math.round(zoom * 100) + '%';
        btnZoom.divIcon.style.transform = 'translateX(2px) translateY(-15px)';
    }


    const _zoomIconOverlay = document.getElementById('zoomIconOverlay');

    if (_zoomIconOverlay)
    {
        if (   zoom < settings.minZoomForParams
            && zoom < 1)
        {
            _zoomIconOverlay.style.left       = '14px';
            _zoomIconOverlay.style.top        = '11px';
            _zoomIconOverlay.style.width      = '28';
            _zoomIconOverlay.style.background = 'url(\'data:image/svg+xml;utf8,<svg width="28" height="20" viewBox="0 0 28 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 0.5H24C25.933 0.5 27.5 2.067 27.5 4V19.5H0.5V4C0.5 2.067 2.067 0.5 4 0.5Z" stroke="white"/></svg>\')';
        }
        else if (zoom < settings.minZoomForParams
            && zoom < 10)
        {
            _zoomIconOverlay.style.left       = '12px';
            _zoomIconOverlay.style.top        = '11px';
            _zoomIconOverlay.style.width      = '33';
            _zoomIconOverlay.style.background = 'url(\'data:image/svg+xml;utf8,<svg width="33" height="20" viewBox="0 0 33 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 0.5H29C30.933 0.5 32.5 2.067 32.5 4V19.5H0.5V4C0.5 2.067 2.067 0.5 4 0.5Z" stroke="white"/></svg>\')';
        }
        else
            _zoomIconOverlay.style.background = 'none';


        _zoomIconOverlay.style.backgroundPosition = '50% 50%';
        _zoomIconOverlay.style.backgroundRepeat   = 'no-repeat';
        _zoomIconOverlay.style.backgroundColor    = 'transparent';
    }
}


GraphView.prototype.deselectAll = function()
{
    for (const node of this._selectedNodes)            
        node.setSelected(false);

    this._selectedNodes = [];
};



GraphView.prototype.selectByIds = function(nodeIds)
{
    this.selectedNodes = nodeIds.map(id => nodeFromId(id));
};



GraphView.prototype.startSelection = function(pointerId, x, y, shiftKey, ctrlKey)
{
    try
    {
        this.div.setPointerCapture(pointerId);

        this.selecting = true;

        this.selectionRect = new Rect(x, y, 0, 0);
        this._prevSelectedNodes = [];
    
        selectBox.style.visibility = 'visible';

        this.updateSelectBox(shiftKey, ctrlKey);
    }
    catch {}
};



GraphView.prototype.updateSelection = function(x, y, shiftKey, ctrlKey)
{
    if (!this.selecting) return;

    this.selectionRect.w = x - this.selectionRect.x;
    this.selectionRect.h = y - this.selectionRect.y;

    setTimeout(() => this.updateSelectBox(shiftKey, ctrlKey));
};

 

GraphView.prototype.updateSelectBox = function(shiftKey, ctrlKey)
{
    if (   isNaN(this.selectionRect.w)
        || isNaN(this.selectionRect.h))
        return;


    const wndRect = new Rect(
        1,
        getTopHeight() + 1,
        this.measureData.clientRect.width  - 2,
        this.measureData.clientRect.height - 5);


    let selection = clipRect(
        validateRect(this.selectionRect), 
        wndRect);
    

    if (!selection.isNaN)
    {
        selectBox.style.left    = selection.x;
        selectBox.style.top     = selection.y;
        selectBox.style.width   = selection.width;
        selectBox.style.height  = selection.height;

        selectBox.style.display = 'block';
        selectBox.style.zIndex  = MAX_INT32-3;


        const selected = [];

        for (const node of graph.pageNodes)
        {
            if (   (    node.type != PANEL
                    || !graphView.startedInPanel)
                && rectsIntersect(
                       node.measureData.divBounds,
                       selection))
                selected.push(node);
        }


        if (shiftKey)
            this.selectedNodes = this.lastSelectedNodes
                .filter(n => !selected.includes(n))
                .concat(selected.filter(n => !this.lastSelectedNodes.includes(n)));
        else
            this.selectedNodes = selected;
        
            
        selectBox.style.zIndex = MAX_INT32-3;
            
            
        const nodes = [
            ...selected,                    
            ...this._prevSelectedNodes,
            ...this.lastSelectedNodes];

        nodes.forEach(n => n.updateBorder());
        updateComments(nodes.map(n => n.id));

        this._prevSelectedNodes = selected;
    }
    else
    {
        selectBox.style.display = 'none';
    }
};



GraphView.prototype.endSelection = function(pointerId)
{
    if (   !isEmpty(this.selectedNodes    )
        || !isEmpty(this.lastSelectedNodes))
    {
        actionManager.do(new SelectNodesAction(
            this.selectedNodes    .map(n => n.id), 
            this.lastSelectedNodes.map(n => n.id)));
    }


    this.div.releasePointerCapture(pointerId);

    this.selecting     = false;
    this.selectionRect = Rect.NaN;
    this._prevSelectedNodes = [];

    selectBox.style.visibility = 'hidden';


    this.selectionRect.w = Number.NaN;
    this.selectionRect.h = Number.NaN;


    graphView.startedInPanel = false;
};



GraphView.prototype.selectFromClick = function(node, ctrl, shift, alt)
{
    node.div.moved = false;


    //if (   ctrl
    //    && shift
    //    && alt)
    //{
    //    this.selectedNodes = getAllNodesFromNode(node);
    //}
    //else if (shift
    //      && alt)
    //{
    //    if (isMac) this.selectedNodes = [node, ...getNodesBeforeNode(node)];
    //    else       this.selectedNodes = [node, ...getNodesAfterNode (node)];
    //}
    //else if (ctrl
    //      && shift)
    //{
    //    if (isMac) this.selectedNodes = [node, ...getNodesAfterNode (node)];
    //    else       this.selectedNodes = [node, ...getNodesBeforeNode(node)];
    //}
    //else if (ctrl
    //      && alt)
    //    this.selectedNodes = [node, ...getNodesAcrossNode(node)];
//
    //else 
    if (!node.selected)
    {
        if (shift) node.selected      = true;
        else       this.selectedNodes = [node];
    }
    else if (node.selected)
    {
        if (   shift
            && node.deselectTimer < 0) 
        {
            node.deselectTimer = setTimeout(() => 
            {
                node.selected      = false;
                node.deselectTimer = -1;
            }, 300);
        }
    }
}


GraphView.prototype.updateScrollWithBounds = function()
{
    const bounds = this.getAllNodeBounds();

    this.updateScroll(
        this.div.clientLeft,
        this.div.clientWidth,
        this.div.clientHeight,
        bounds,
        getTopHeight());
};



GraphView.prototype.updateScroll = function(x, w, h, bounds, yOffset)
{
    this.updateScrollX(   w, h, bounds);
    this.updateScrollY(x, w, h, bounds, yOffset);

    this.scrollbarX.style.zIndex = MAX_INT32-1;
    this.scrollbarY.style.zIndex = MAX_INT32-2;
};



GraphView.prototype.updateScrollX = function(w, h, bounds)
{
    if (   bounds.l < 0
        && bounds.r >= w)
    {
        const width = sqr(w) / bounds.width - (smallScrollGap + largeScrollGap);

        this.scrollbarX.style.display = 'inline-block';
        this.scrollbarX.style.width   =  width;
        this.scrollbarX.style.left    =  smallScrollGap + (w - smallScrollGap - largeScrollGap - width) * -bounds.l / (-bounds.l + bounds.r - w);
        this.scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else if (bounds.l < 0)
    {
        const width = sqr(w) / (w - bounds.l) - (smallScrollGap + largeScrollGap);

        this.scrollbarX.style.display = 'inline-block';
        this.scrollbarX.style.width   =  width;
        this.scrollbarX.style.left    =  w - largeScrollGap - width;
        this.scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else if (bounds.r >= w)
    {
        const width = sqr(w) / bounds.r - (smallScrollGap + largeScrollGap);

        this.scrollbarX.style.display = 'inline-block';
        this.scrollbarX.style.width   =  width;
        this.scrollbarX.style.left    =  smallScrollGap;
        this.scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else
        this.scrollbarX.style.display = 'none';
};



GraphView.prototype.updateScrollY = function(x, w, h, bounds, yOffset)
{
    if (   bounds.t <  yOffset
        && bounds.b >= h + yOffset)
    {
        const height = sqr(h) / bounds.height - (smallScrollGap + largeScrollGap);

        this.scrollbarY.style.display = 'inline-block';
        this.scrollbarY.style.height  =  height;
        this.scrollbarY.style.top     =  smallScrollGap + (h - height + smallScrollGap) * (yOffset - bounds.t) / (yOffset - bounds.t + bounds.b - h);
        this.scrollbarY.style.left    =  x + w - smallScrollGap - 6;
    }
    else if (bounds.t < yOffset)
    {
        const height = sqr(h) / (h - (bounds.t - yOffset)) - (smallScrollGap + largeScrollGap);

        this.scrollbarY.style.display = 'inline-block';
        this.scrollbarY.style.height  = height;
        this.scrollbarY.style.top     = h - largeScrollGap - height;
        this.scrollbarY.style.left    = x + w - smallScrollGap - 6;
    }
    else if (bounds.b >= h + yOffset)
    {
        const height = sqr(h) / (bounds.b - yOffset) - (smallScrollGap + largeScrollGap);

        this.scrollbarY.style.display = 'inline-block';
        this.scrollbarY.style.height  = height;
        this.scrollbarY.style.top     = smallScrollGap;
        this.scrollbarY.style.left    = x + w - smallScrollGap - 6;
    }
    else
        this.scrollbarY.style.display = 'none';
};



GraphView.prototype.createScrollbarMethods = function()
{
    this.scrollbarX.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            try
            {
                this.scrollbarX.setPointerCapture(e.pointerId);

                this.scrollbarX.moving = true;
                this.scrollbarX.xStart = this.scrollbarX.offsetLeft;
                this.scrollbarX.wStart = this.scrollbarX.offsetWidth;
                this.scrollbarX.pStart = e.clientX;

                this.panStart = graph.currentPage.pan;

                for (const node of graph.pageNodes)
                    node.slx = node.div.offsetLeft;
            }
            catch {}
        }
    });



    this.scrollbarX.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && this.scrollbarX.moving)
        {
            this.scrollbarX.moving = false;
            this.scrollbarX.releasePointerCapture(e.pointerId);

            let bounds = Rect.NaN;

            for (const node of graph.pageNodes)
                bounds = expandRect(bounds, boundingRect(node.div));

            if (bounds.l >= 0 && bounds.r < this.clientWidth)
                this.scrollbarX.style.display = 'none';
        }
    });



    this.scrollbarX.addEventListener('pointermove', e =>
    {
        if (this.scrollbarX.moving)
        {
            const x = this.scrollbarX.xStart + e.clientX - this.scrollbarX.pStart;

            let l = x;
            let r = l + this.scrollbarX.wStart;
 
            l = Math.max(smallScrollGap, l);
            r = Math.min(r, this.div.clientWidth - largeScrollGap);
 
            l = Math.max(smallScrollGap, Math.min(l, r - smallScrollGap));
            r = Math.max(l + smallScrollGap, r);
 
            this.scrollbarX.style.left  = l;
            this.scrollbarX.style.width = r-l;

            graph.currentPage.pan = point(
                this.panStart.x - (e.clientX - this.scrollbarX.pStart) / this.scrollbarX.wStart * this.div.clientWidth,
                this.panStart.y);
        }
    });



    /////////////////////////////////////////////////////////////////////////////////////



    this.scrollbarY.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            try
            {
                this.scrollbarY.setPointerCapture(e.pointerId);

                this.scrollbarY.moving = true;
                this.scrollbarY.yStart = this.scrollbarY.offsetTop;
                this.scrollbarY.hStart = this.scrollbarY.offsetHeight;
                this.scrollbarY.pStart = e.clientY;

                for (const node of graph.pageNodes)
                    node.div.sly = node.div.offsetTop;

                this.panStart = graph.currentPage.pan;
            }
            catch {}
        }
    });



    this.scrollbarY.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && this.scrollbarY.moving)
        {
            this.scrollbarY.moving = false;
            this.scrollbarY.releasePointerCapture(e.pointerId);

            let bounds = Rect.NaN;

            for (const node of graph.pageNodes)
                bounds = expandRect(bounds, boundingRect(node.div));

            if (bounds.t >= 0 && bounds.b < this.div.clientHeight)
                this.scrollbarY.style.display = 'none';
        }
    });



    this.scrollbarY.addEventListener('pointermove', e =>
    {
        if (this.scrollbarY.moving)
        {
            const y = this.scrollbarY.yStart + e.clientY - this.scrollbarY.pStart;

            let   t = y;
            let   b = t + this.scrollbarY.hStart;

            t = Math.max(smallScrollGap, t);
            b = Math.min(b, this.div.clientHeight - largeScrollGap);

            t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
            b = Math.max(t + smallScrollGap, b);

            this.scrollbarY.style.top    = t;
            this.scrollbarY.style.height = b-t;

            graph.currentPage.pan = point(
                this.panStart.x, 
                this.panStart.y - (e.clientY - this.scrollbarY.pStart) / this.scrollbarY.hStart * this.div.clientHeight);
        }
    });
}


const defParamHeight = 22;



class Parameter
extends EventTarget
{
    #type;     get type()    { return this.#type;    }
    _id;       get id()      { return this._id;      }
    #name;     get name()    { return this.#name;    }
    _node;     get node()    { return this._node;    }
    _div;      get div()     { return this._div;     }


    get index() { return this.node.params.indexOf(this); }


    showName;
    divider        = 0.5;

    divName;
    divControls;


    controls       = [];

    // proxy          = null;


    backStyleLight  = 'rgba(255, 255, 255, 0.95)';
    valueStyleLight = '#7772';
    textStyleLight  = '#000';
                
    backStyleDark   = 'rgba(56, 56, 56, 0.95)';
    valueStyleDark  = '#ffffff20';
    textStyleDark   = '#eee';


    input;
    output;

    
    onbeforechange = new Event('beforechange');
    onchange       = new Event('change');
    onconfirm      = new Event('confirm');
    onchangelock   = new Event('changelock');


    isNodeValue    = false; // helps figure out if a wire is unknown


    changing       = false;

    volatile       = false;
    noUpdate       = false;
 
    affectsHeader  = true; // indicates whether the parameter contributes to the header's result data

    isResult       = false;
    //managing       = false; // undoing or redoing


    canShow = () => true;



    constructor(type, id, name, showName)
    {
        super();

        this._id              = id;
        this.#name            = name;
        this.#type            = type;
  
        this.showName         = showName;

        this._div             = createDiv('paramDiv');
        this.divName          = createDiv('paramName');
        this.divControls      = createDiv('paramControls');

        this.div.style.height = defParamHeight;

        this.input            = null;
        this.output           = null;

        this.div.appendChild(this.divName);
        this.div.appendChild(this.divControls);
    }



    setName(name, dispatchEvents = true)
    {
        this.#name = name; 
        this.update(dispatchEvents);
    }



    initInput(types, getNodeInputValuesForUndo = null, getBackInitValue = null)
    {
        this.input = new Input(types, getNodeInputValuesForUndo, getBackInitValue);

        this.input._param              = this;

        this.input.div.style.float     = 'left';
        this.input.div.style.position  = 'absolute';
        this.input.div.style.top       = '50%';
        this.input.div.style.transform = 'translateY(-50%)';

        this.input.colorLight          = [0, 0, 0, 0.12];
        this.input.colorDark           = [1, 1, 1, 0.12];
        this.input.overFactor          = 3;

        this.input.canAutoConnect      = false;
        
        this.div.appendChild(this.input.div);

        this.input.addEventListener('connect',    () => this.enableControlText(false));
        this.input.addEventListener('disconnect', () => this.enableControlText(true ));
    }



    initOutput(types, toString, getNodeOutputValuesForUndo = null, backInit = null)
    {
        this.output = new Output(types, toString, getNodeOutputValuesForUndo, backInit);

        this.output._param              = this;

        this.output.div.style.float     = 'right';
        this.output.div.style.position  = 'absolute';
        this.output.div.style.top       = '50%';
        this.output.div.style.transform = 'translateY(-50%)';
        
        this.output.colorLight          = [0, 0, 0, 0.12];
        this.output.colorDark           = [1, 1, 1, 0.12];
        this.output.overFactor          = 3;

        this.div.appendChild(this.output.div);
    }



    isDefault = () => false;


    
    isVisible()
    {
        return true;
    }



    isFollowedByMultiplier()
    {

    }



    isUnknown()
    {
        return this.input
            && this.input.isUncached()
            && this.node.hasMultipliedOutputs();
    }



    resetControls()
    {
        
    }



    getValueForUndo()
    {
        return {
            paramId: this.id, 
            value:   this.value
        };    
    }    



    update(dispatchEvents)
    {

    }    



    updateControls(updateBack = true)
    {
        if (updateBack)
        {
            this.div.style.background = 
                darkMode 
                ? this.backStyleDark 
                : this.backStyleLight;
        }
        

        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
        
       
        checkParamVisible(this);
        
        
        const left = this.input || this.output ? 12 : 0;

        const dw = 
              (left > 0 ? 12 : 0) 
            + (left > 0 ? 12 : 0);


        if (this.showName)
        {
            const nameSize = this.divider <= 1 ? ((   this.divider *100) + '%') : (this.divider + 'px');
            const  valSize = this.divider <= 1 ? (((1-this.divider)*100) + '%') : ('calc(100% - ' + this.divider + 'px)');

            this.divName    .innerHTML        =  this.name;
   
            this.divName    .style.display    = 'inline-block';
            this.divName    .style.right      =  valSize;
            this.divName    .style.width      = 'calc(' + nameSize + ' - ' + (this.input ? 12 : 0) + 'px)';
            
            this.divControls.style.left       =  nameSize;
            this.divControls.style.marginLeft = '3px';
            this.divControls.style.width      = 'calc(calc(' + valSize + ' - ' + (this.output ? 12 : 0) + 'px) - 3px)';
        }
        else
        {
            this.divName    .style.display    = 'none';
            
            this.divControls.style.marginLeft =  0;
            this.divControls.style.left       =  left+'px';
            this.divControls.style.width      = 'calc(100% - ' + dw + 'px)';
        }


        this.controls.forEach(c => c.update());


        if (this.input)
        {
            this.input.colorLight  = 
            this.input.colorDark   =  
            this.input.wireColor   = rgbFromType(this.type, true);
        }

        if (this.output)
        {
            this.output.colorLight =
            this.output.colorDark  = 
            this.output.wireColor  = rgbFromType(this.output.types[0], true);
        }
    }



    preSetValue(value, createAction, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (!value.equals(this.oldValue))
                this.dispatchEvent(this.onbeforechange);
        }
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (   !this.oldValue
                || !value.equals(this.oldValue))
            {
                this.dispatchEvent(this.onchange);
                
                if (createAction)
                {
                    if (isGenerating)
                        stopRequestId = curRequestId;

                    actionManager.do(
                        new SetParamValueAction(this, value), 
                          !isEmpty(actionManager.actions)
                        && actionManager.actions.at(-1).type == SET_PARAM_VALUE_ACTION
                        && this.changing);

                    this.dispatchEvent(this.onconfirm);
                }
            }
        }


        // if (this.proxy) 
        //     this.proxy.updateControls();
    }



    updateSetting(setting, value)
    {

    }



    formatControlTextbox(control)
    {
        control.textbox.style.left      = this.divControls.offsetLeft;
        control.textbox.style.top       = this.div        .offsetTop;

        control.textbox.style.width     = control.div.offsetWidth;
        control.textbox.style.height    = defParamHeight;
        
        control.textbox.style.textAlign = 'center';
    }



    textboxHasFocus()
    {
        return false;
    }



    enableControlText(enable)
    {

    }
    
    
    
    toString()
    {
        return this.value.toString();
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + this.type  + '", "' + id  + '", "' + this.value.toJson() + '"]';
    }



    loadParam(_param)
    {
        
    }



    toJsCode(gen)
    {
        return '';
    }
}



function setParamValue(param, value, updateParamId = '')
{
    if (param.id != updateParamId)
        param.setValue(value, false, true, false);
}



function checkParamVisible(param)
{
    param.div.style.display = 
          !param.isResult
        || settings.showOperationResults
        ? 'inline-block'
        : 'none';
}



function createParamFromType(type, options = {})
{
    const id        = options.id        != undefined ? options.id        : 'value';
    const name      = options.name      != undefined ? options.name      : '';
    const showName  = options.showName  != undefined ? options.showName  : false;
    const hasInput  = options.hasInput  != undefined ? options.hasInput  : false;
    const hasOutput = options.hasOutput != undefined ? options.hasOutput : false;

         if (NUMBER_TYPES.includes(type)) return new NumberParam(id, name, showName, hasInput, hasOutput);
    else if (  TEXT_TYPES.includes(type)) return new   TextParam(id, name,           hasInput, hasOutput);
    else if ( COLOR_TYPES.includes(type)) return new  ColorParam(id, name, showName, hasInput, hasOutput);
    else if (  FILL_TYPES.includes(type)) return new   FillParam(id, name, showName, hasInput, hasOutput);
    else if (STROKE_TYPES.includes(type)) return new StrokeParam(id, name, showName, hasInput, hasOutput);
    else if (  LIST_TYPES.includes(type)) return new   ListParam(id, name, showName, hasInput, hasOutput);
}


class   NumberParamBase
extends Parameter
{
    showFullPrecision = false;

    
    
    get value() 
    { 
        return new NumberValue(
            this.controls[0].value, 
            this.controls[0].displayDec); 
    }

    oldValue = null;


    defaultValue;
    alwaysSaveValue = false;


    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        consoleAssert(
            value instanceof NumberValue,
            'value must be a NumberValue');


        if (  !isNaN(value.value)
            && isNaN(value.decimals))
            value.decimals = 0;

            
        this.preSetValue(value, createAction, dispatchEvents);

        
        if (updateControl)
        {
            this.controls[0].setDecimals(value.decimals, value.decimals);
            this.controls[0].setValue(value.value, false, false); 
        }


        super.setValue(value, createAction, updateControl, dispatchEvents);

        
        this.oldValue = this.value.copy();
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    resetControls()
    {
        this.controls[0].valueText = '';
    }



    getValueForUndo()
    {
        return {
            paramId:    this.id, 
            value:      this.value,
            min:        this.controls[0].min,
            max:        this.controls[0].max,
            displayMin: this.controls[0].displayMin,
            displayMax: this.controls[0].displayMax
        };
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;

            
        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else if (this.output
              && this.output.paramNode
              && this.output.paramNode.inputs[0].connected)
            request.push(...pushInputOrParam(this.output.paramNode.inputs[0], gen));

        else request.push(
            NUMBER_VALUE, 
            new NumberValue(
                this.controls[0].value, 
                this.controls[0].displayDec).toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    textboxHasFocus()
    {
        return hasFocus(this.controls[0].textbox);
    }



    enableControlText(enable, unknown = false)
    {
        enable &= 
               !this.input 
            || !this.input.connected;
            
        enableElementText(this.divName, enable, false);
        enableElementText(this.controls[0].div, enable);

        this.controls[0].readOnly = !enable;

        this.updateValueText();


        this.controls[0].valueText = 
               unknown
            ||    this.input  
               && this.input.isUncached()
               && this.node.hasMultipliedOutputs()
               //&& this.output && this.output.isMultiplied()
            ? UNKNOWN_DISPLAY
            : '';
    }
    
    
    
    // updateControls()
    // {
    //     this.controls[0].div.style.width = '100%';
        
    //     // this.div.style.background = 
    //     //     darkMode 
    //     //     ? this.backStyleDark 
    //     //     : this.backStyleLight;

    //     super.updateControls();
    // }


    updateValueText()
    {
        let unknown = false;

        if (   this.input
            && this.input.connected)
        {
            if (   this.input.isUncached()
                && this.node.hasMultipliedOutputs())
                unknown = true;
        }


        if (unknown)
            this.controls[0].valueText = UNKNOWN_DISPLAY;

        this.controls[0].showBar = !unknown;
    }



    isDefault = () => 
           !this.alwaysSaveValue
         && this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseNumberValue(_param[2])[0], true, true, false);
    }



    toJsCode(gen)
    {
        return this.input.connected
             ? '(' + this.input.connectedOutput.toJsCode(gen) + ')'
             : this.value.toJsCode(gen);
    }
}


class   NumberParam
extends NumberParamBase
{
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = 0, 
                min          = Number.MIN_SAFE_INTEGER, 
                max          = Number.MAX_SAFE_INTEGER,
                decimals     = 0,
                dragScale    = 0.05)
    {
        super(NUMBER_VALUE, id, name, showName);

        
        this.controls.push(new NumberControl(
            this,
            this.id,
            this.name, 
            defaultValue,
            min,
            max,
            decimals,   
            dragScale)); 

            
        this.defaultValue = new NumberValue(defaultValue, decimals);
        
        
        this.controls[0].successOnFocusOut = true;
        
        this.controls[0].div.zIndex = 0;
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([NUMBER_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([NUMBER_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('change', () => 
        { 
            this.setValue(this.value, true, false);
            this.changing = true;
        });


        this.controls[0].addEventListener('confirm', () => 
        { 
            this.changing = false;
        });


        this.controls[0].addEventListener('finishedit', e =>
        { 
            let dec = decCount(e.detail.valueString); 
            
            if (!e.detail.success)
                return;


            if (this.controls[0].allowEditDecimals)
            {
                this.setValue(new NumberValue(e.detail.value, dec), true);
                e.preventSetValue = true;
            }
        });



        createTooltipSrc(this.controls[0].div, this.controls[0].div, () => 
        {
            this.controls[0].addEventListener('change', () => 
            {
                const tooltip = this.getTooltip();
                if (tooltip) hideTooltip(tooltip);
            });
            
            return this.getTooltip();
        });
    }



    getTooltip = () => null;


    
    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == NUMBER_VALUE, 'expected NUMBER_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }


    // updateControls()
    // {
    //     this.controls[0].div.style.width = '100%';
        
    //     this.div.style.background = 
    //         darkMode 
    //         ? this. backStyleDark 
    //         : this. backStyleLight;

    //     super.updateControls();
    // }
}


class   SelectParam
extends NumberParamBase
{
    options           = [];
    excludeFromMenu   = []; // indices
    separatorsBefore  = [];
    
    saveAsText        = false;
    
    reverseMenu       = false;

    

    constructor(id,
                name,
                showName,
                hasInput,
                hasOutput,
                options,
                defaultValue = 0)
    {
        super(NUMBER_VALUE, id, name, showName);

        this.controls[0] = new NumberControl(
            this,
            this.id,
            this.name, 
            defaultValue,
            0,
            options.length-1,
            0,   // decimals
            0.02);


        this.controls[0].div.zIndex = 0;

        // this.controls[0].div.style.display = 'inline-block';
        // this.controls[0].div.style.width   = '100%';

       
        this.defaultValue = new NumberValue(defaultValue);


        this.controls[0].successOnFocusOut = true;

        this.controls[0].div.zIndex = 0;
        this.divControls.appendChild(this.controls[0].div);


        this.setOptions(options);

        this.controls[0].allowEditDecimals = false;
        this.controls[0].barTop            = 0.8;


        if (hasInput)  this.initInput([NUMBER_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([NUMBER_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('change', () => 
        { 
            this.setValue(this.value, true, false, true);
            this.changing = true;
        });
            
        this.controls[0].addEventListener('confirm', () => 
        { 
            this.setValue(this.value, true, true); 
            this.changing = false;
        });


        // this.tooltip = createDiv('tooltip');
        // document.body.appendChild(this.tooltip);

        //createTooltip(this.tooltip);

        createTooltipSrc(this.controls[0].div, this.controls[0].div, () => 
        {
            const tooltip = this.getTooltip();

            if (tooltip)
                this.initTooltip(tooltip, this.options);

            this.controls[0].addEventListener('change', () => 
            {
                if (tooltip) hideTooltip(tooltip);
            });

            return this.getTooltip();
        });
    }



    initTooltip = (tooltip, options) =>
    {
        // let strOptions = '';

        // for (const option of options)
        // {
        //     if (strOptions != '') strOptions += ', ';
        //     strOptions += option;
        // }

        // tooltip.innerHTML = strOptions;
    };


    
    getTooltip = () => null;//this.tooltip;



    setOptions(options)
    {
        this            .options = [...options];
        this.controls[0].options = [...options];
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == NUMBER_VALUE, 'expected NUMBER_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    toString()
    {
        return this.input
            && this.input.connected 

            ? [ ...pushInputOrParam(this.input, createGenObject()) ]

            : [ NUMBER_VALUE, 
                this.value.toString(), 
                this.controls[0].displayDec.toString() ];
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        const type =
            this.saveAsText
            ? TEXT_VALUE
            : NUMBER_VALUE;

        const value = 
            this.saveAsText
            ? new TextValue(this.options[this.value.value]).toJson()
            : this.value.toJson();

        return pos + '["' + type  + '", "' + id  + '", "' + value + '"]';
    }



    loadParam(_param)
    {
        const str   = parseTextValue(_param[2])[0].toString();
        const index = this.options.indexOf(str);

        if (this.saveAsText) this.setValue(new NumberValue(index), true, true, false);
        else                 this.setValue(parseNumberValue(_param[2])[0], true, true, false);
    }
}



function initSelectParamMenu(param)
{
    menuSelectParam.clearItems();


    const s = !param.reverseMenu ? 0 : param.controls[0].displayMax;
    const c = !param.reverseMenu ? i => i <= param.controls[0].displayMax : i => i >= 0;
    const d = !param.reverseMenu ? 1 : -1;


    for (let i = s; c(i); i += d)
    {
        const option = param.options[i];
        
        if (param.excludeFromMenu.includes(i))
            continue;


        if (param.separatorsBefore.includes(i))
            menuSelectParam.addItems([new MenuItem(option, null, {separator: true})]);
        

        const options = { callback: () => param.setValue(new NumberValue(i), true) };

        if (param.controls[0].readOnly)
            options.enabled = false;

            
        const item = new MenuItem(
            option.replaceAll('/', ' / '), 
            null,
            options);

        item.setChecked(i == param.value.toNumber());

        menuSelectParam.addItems([item]);
    }


    menuSelectParam.minWidth = 120;
}



class TextParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }

    
    get value() 
    { 
        return new TextValue(this.controls[0].value); 
    }
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = '')
    {
        super(TEXT_VALUE, id, name, showName);

        this.defaultValue = defaultValue;


        this.controls[0] = new TextControl(
            this,
            this.id,
            this.name,
            defaultValue);

            
        this.controls[0].successOnFocusOut = true;
        this.controls[0].div.zIndex        = 0;


        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput ) this.initInput ([TEXT_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([TEXT_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('change', () => 
        { 
            this.setValue(this.value, true, false);
        });
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == TEXT_VALUE, 'expected TEXT_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    isDefault = () => this.value == this.defaultValue;



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        // console.log('TextParam.setValue value =', value);

        if (   !value.type 
            || !value.type == TEXT_VALUE)
        { 
            consoleError('value.type must be TEXT_VALUE');
            console.trace();
        }


        if (   value.value === null
            || (typeof value.value) !== 'string')
        {
            consoleError('value.value (' + value.value + ') has type \'' + (typeof value.value) + '\', must be string');
            console.trace();
        }


        this.preSetValue(value, createAction, dispatchEvents);


        this.controls[0].value = value.value;

        if (updateControl)
            this.controls[0].setValue(value.value, false);


        super.setValue(value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    updateSetting(setting, value)
    {
        if (setting == 'align')
            this.controls[0].textbox.style.textAlign = value;
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else request.push( 
            TEXT_VALUE, 
            encodeURIComponent(this.controls[0].value.toString()));


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    // updateControls()
    // {

    //     super.updateControls();
    // }



    enableControlText(enable, unknown = false)
    {
        enable &= 
               !this.input 
            || !this.input.connected;

        enableElementText(this.controls[0].textbox, enable);
        
        this.controls[0].textbox.disabled = !enable;
        this.controls[0].readOnly         = !enable;


        this.controls[0].valueText = 
               unknown
            ||    this.input  && this.input .isUncached()
               && this.output && this.output.isMultiplied()
            ? UNKNOWN_DISPLAY
            : '';
    }
    
    
    
    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        const value = encodeURIComponent(this.value.toString());


        return pos 
            + '["' 
                + this.type + '", "' 
                + id        + '", "' 
                + value     + '", "' 
                + this.controls[0].getTextAlignment()
            + '"]';
    }



    loadParam(_param)
    {
        const val = _param[2];

        this.setValue(parseTextValue(val)[0], true, false, false);

        if (_param.length >= 4) // legacy
        {
            switch (_param[3])
            {
            case '':
            case 'start':
            case 'left':    this.controls[0].textbox.style.textAlign = 'left';    break;
            case 'center':  this.controls[0].textbox.style.textAlign = 'center';  break;
            case 'right':   this.controls[0].textbox.style.textAlign = 'right';   break; 
            case 'justify': this.controls[0].textbox.style.textAlign = 'justify'; break;
            }
        }
    }
}


class   ColorParam
extends Parameter
{
    defaultValue;

    oldValue = null;

    
    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;


    showColorBack = true;


    checkers;
    

    
    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }

    
    get value() { return this.controls[0].value; }
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = ColorValue.fromRgb([0x80, 0x80, 0x80]),
                dragScale    = 0.05)
    {
        super(COLOR_VALUE, id, name, showName);

        this.defaultValue = defaultValue;


        this.controls.push(new ColorControl(
            this,
            this.id,
            this.name, 
            defaultValue,   
            dragScale)); 

        this.controls[0].successOnFocusOut = true;
        //this.controls[0].div.style.position        = '100';
        //this.controls[0].div.style.zIndex        = 100;

        this.controls[0].div.style.display = 'inline-block';
        this.controls[0].div.style.width   = '100%';

        
        this._warningOverlay = createDiv('colorValueWarningOverlay');
        this._warningOverlay.style.zIndex  = 21;

        
        this.controls[0].backStyleLight    = 
        this.controls[0].backStyleDark     = 'transparent';
        
        
        this.checkers                      = createDiv();
        
        this.checkers.style.position       = 'absolute';
        this.checkers.style.width          = '100%';
        this.checkers.style.height         = '20px';
        this.checkers.style.display        = 'none';
        this.checkers.style.pointerEvents  = 'none';
        
        
        this.div.appendChild(this._warningOverlay);
        this.div.appendChild(this.checkers);

        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([COLOR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([COLOR_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('confirm', () => 
        {
            this.setValue(this.controls[0].value, true, false); 
        });


        this.controls[0].addEventListener('finishedit', e =>
        { 
            if (!e.detail.success)
                return;

            
            let rgb;

            if (   e.detail.value.trim() != ''
                && e.detail.value != e.detail.oldValue)
            {
                const colorName = e.detail.value.toLowerCase();

                if (   colorName == 'rnd'
                    || colorName == 'random'
                    || getEditDistance(colorName, 'random') <= 2)
                {
                    skipRandom(Date.now() % 10);  const r = Math.random();
                    skipRandom(Date.now() % 10);  const g = Math.random();
                    skipRandom(Date.now() % 10);  const b = Math.random();

                    rgb = [r, g, b];
                }
                else
                {
                               let webColor = webColors.find(wc => wc.name.toLowerCase() == colorName);
                    if (!webColor) webColor = webColors.find(wc => getEditDistance(wc.name.toLowerCase(), colorName) <= 2);
                    
                    if (webColor) e.detail.value = webColor.color;

                    rgb = validHex2rgb(e.detail.value);
                }


                const val = ColorValue.fromRgb(scaleRgb(rgb));

                this.setValue(val, true);
                e.preventSetValue = true;
            }
        });
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        if (value.type == FILL_VALUE)
            value = value.color;

        this.param.setValue(value, false, true, false);
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    isDefault = () => this.value.equals(this.defaultValue);



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    resetControls()
    {
        this.controls[0].valueText = '';
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        consoleAssert(
               value.type 
            && value.type == COLOR_VALUE, 
            'value.type must be COLOR_VALUE');
            
        this.preSetValue(value, createAction, dispatchEvents);

        this.controls[0].value = value.copy();

        if (updateControl)
            this.controls[0].setValue(this.controls[0].value, true, false); 


        super.setValue(value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value.copy();
    }    



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else request.push( 
            COLOR_VALUE, 
            this.value.toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        this.updateWarningOverlay();


        const showColorBack = 
                this.showColorBack
            && !this.isUnknown() 
            && !this.node.isUnknown();


        const noColor = 
            darkMode
            ? rgbNoColorDark
            : rgbNoColorLight;


        const rgb       = this.value.toRgb();

        const rgbStripe = getStripeBackColor(rgb);
        const rgbBack   = rgbStripe;
        const rgbText   = getTextColorFromBackColor(rgbStripe);


        this.controls[0].textStyleLight = 
        this.controls[0].textStyleDark  = 
            showColorBack
            ? rgba2style(rgbText)
            : darkMode
              ? this.textStyleDark
              : this.textStyleLight;


        super.updateControls(false);


        if (this.input)
        {
            this.input.colorLight  = 
            this.input.colorDark   =  rgb_a(rgbText, 0.2);
            this.input.wireColor   = !rgbIsNaN(rgbStripe) ? rgbStripe : noColor;
        }

        if (this.output)
        {
            this.output.colorLight =
            this.output.colorDark  =  rgb_a(rgbText, 0.2);
            this.output.wireColor  = !rgbIsNaN(rgbStripe) ? rgbStripe : noColor;
        }


        this.div.style.background = 
            showColorBack
            ? (!rgbIsNaN(rgbBack)
               ? rgb2style(rgbBack)
               : rgb2style(rgbDocumentBody))
            : darkMode
              ? this.backStyleDark
              : this.backStyleLight;
    }



    textboxHasFocus()
    {
        return hasFocus(this.controls[0].textbox);
    }



    enableControlText(enable, unknown = false)
    {
        enable &= 
               !this.input 
            || !this.input.connected;

        //enableElementText(this.divName, enable, false);
        enableElementText(this.controls[0].div, enable);
        
        this.controls[0].readOnly = !enable;

        this.updateValueText();


        this.controls[0].valueText = 
               unknown
            ||    this.input 
               && this.input.isUncached()
               && this.node.hasMultipliedOutputs()
               //&& this.output && this.output.isMultiplied()
            ? UNKNOWN_DISPLAY
            : '';
    }
    
    
    
    updateValueText()
    {
        let unknown = false;

        if (   this.input
            && this.input.connected)
        {
            if (   this.input.isUncached()
                && this.node.hasMultipliedOutputs())
                unknown = true;
        }


        if (unknown)
            this.controls[0].valueText = UNKNOWN_DISPLAY;

        this.controls[0].showBar = !unknown;
    }



    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgb = this.value.toRgb();

        if (!rgbIsNaN(rgb))
        {
            if (  !rgbIsValid(rgb)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgb);

                this.updateWarningOverlayStyle(rgb);
            }
            else
                this._warningOverlay.style.display = 'none';

            }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgb);
            this.updateWarningOverlayStyle(rgb);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? defParamHeight //this.div.offsetHeight
            : height;


        const [warnStyle1, warnStyle2] = getWarningStyles(colBack);

        this._warningOverlay.style.background =
                rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : getWarningGradient(7.8, warnStyle1, warnStyle2);


        this._warningOverlay.style.backgroundPosition = '-3px 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 8px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
    
    
    
    loadParam(_param)
    {
        this.setValue(parseColorValue(_param[2])[0], true, false, false);
    }
}


class   FillParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;


    checkersHolder;
    checkers;


        
    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }

    
    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = FillValue.NaN,
                dragScale    = 0.05)
    {
        super(FILL_VALUE, id, name, showName);

        this.checkersHolder = createDiv();
        this.checkers       = createDiv();


        this.controls.push(new ColorControl(
            this,
            this.id,
            'color', 
            defaultValue.color,   
            dragScale)); 


        this.controls.push(new NumberControl(
            this,
            this.id,
            'opacity', 
            defaultValue.opacity.value,
            0,
            100,
            0));
        
        this.controls[1].setSuffix('%', true);


        this.defaultValue                  = defaultValue;
        this.value                         = defaultValue;

        
        this._warningOverlay               = createDiv('colorValueWarningOverlay');
        this._warningOverlay.style.zIndex  = 11;

        this.checkersHolder.style.position = 'absolute';
        this.checkersHolder.style.width    = '100%';
        this.checkersHolder.style.height   = defParamHeight;
        this.checkersHolder.style.overflow = 'hidden';

        this.checkers.style.position       = 'absolute';
        this.checkers.style.width          = '100%';
        this.checkers.style.height         = defParamHeight;


        this.controls[1].showBar                    = false;


        this.divControls   .appendChild(this.controls[0].div);
        this.divControls   .appendChild(this.controls[1].div);
        
        this.checkersHolder.appendChild(this.checkers);

        this.div           .insertBefore(this.checkersHolder,  this.divName);
        this.div           .insertBefore(this._warningOverlay, this.divName);

       
        if (hasInput)  this.initInput ([FILL_VALUE, COLOR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([FILL_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);



        this.controls[0].addEventListener('change', () =>
        { 
            this.setValue(new FillValue(
                this.controls[0].value, 
                new NumberValue(this.controls[1].value, this.controls[1].decimals)), 
                true, false);

            this.changing = true;
        });



        this.controls[0].addEventListener('confirm', () =>
        { 
            this.changing = false;
        });



        this.controls[0].addEventListener('finishedit', e =>
        { 
            if (!e.detail.success)
                return;


            let rgb;

            if (   e.detail.value.trim() != ''
                && e.detail.value != e.detail.oldValue)
            {
                const colorName = e.detail.value.toLowerCase();

                if (   colorName == 'rnd'
                    || colorName == 'rndo'
                    || colorName == 'rndom'
                    || colorName == 'rand'
                    || colorName == 'rando'
                    || colorName == 'random')
                {
                    rgb = [
                        Math.random(), 
                        Math.random(), 
                        Math.random()];
                }
                else
                {
                    const webColor = webColors.find(wc => wc.name.toLowerCase() == e.detail.value.toLowerCase());
                    if (webColor) e.detail.value = webColor.color;

                    rgb = validHex2rgb(e.detail.value);
                }


                const _rgb = scaleRgb(rgb);

                this.setValue(FillValue.fromRgb(_rgb, this.controls[1].value), true);
                
                e.preventSetValue = true;
            }
        });



        this.controls[1].addEventListener('change', () =>
        {
            this.setValue(new FillValue(
                this.controls[0].value, 
                new NumberValue(this.controls[1].value, this.controls[1].decimals)), 
                true, false);

            this.changing = true;
        });



        this.controls[1].addEventListener('confirm', () =>
        { 
            this.changing = false;
        });
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == FILL_VALUE, 'expected FILL_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        //console.log('FillParam.setValue value =', value);
        if (!(value instanceof FillValue))
            consoleError('FillParam.setValue(value) is ' + typeof value + ', must be a FillValue');

        consoleAssert(
               value.type 
            && value.type == FILL_VALUE, 
            'FillParam value.type must be FILL_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        if (updateControl)
        {
            this.controls[0].setValue(this.value.color,         false, false); 
            this.controls[1].setValue(this.value.opacity.value, false, false, false); 
        }


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none'
            || this.controls[1].div.style.display != 'none';
    }



    resetControls()
    {
        this.controls[0].valueText = '';
        this.controls[1].valueText = '';
    }



    genRequest(gen)
    {
        super.updateControls(false);


        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([FILL_VALUE, COLOR_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for FillParam (' + this.node.id + ')');
        }

        else request.push( 
            FILL_VALUE, 
            this.value.toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        this.updateWarningOverlay();


        checkParamVisible(this);


        const noColor = 
            darkMode
            ? rgbNoColorDark
            : rgbNoColorLight;


        const rgba       = this.value.toRgba();

        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);
        const rgbaBack   = rgbaStripe;
        const rgbaText   = getTextColorFromBackColor(rgbaStripe, rgba[3]);


        this.controls[0].backStyleLight = 
        this.controls[0].backStyleDark  = 'transparent';
               
        this.controls[0].textStyleLight = 
        this.controls[0].textStyleDark  = rgba2style(rgbaText);
      
      
        this.controls[1].backStyleLight = 
        this.controls[1].backStyleDark  = 'transparent';
   
   
        this.controls[1].textStyleLight = 
        this.controls[1].textStyleDark  = rgba2style(rgbaText);


        super.updateControls();


        if (this.input)
        {
            this.input.colorLight  = 
            this.input.colorDark   = rgb_a(rgbaText, 0.2);
            this.input.wireColor   = !rgbaIsNaN(rgbaStripe) ? rgbaStripe : noColor;
        }

        if (this.output)
        {
            this.output.colorLight =
            this.output.colorDark  = rgb_a(rgbaText, 0.2);
            this.output.wireColor  = !rgbaIsNaN(rgbaStripe) ? rgbaStripe : noColor;
        }


        this.checkers.style.background =
            darkMode
            ?   'linear-gradient(-45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(-45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(-45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(-45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';


        this.checkers.style.display               = this.value.isValid() ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor       = darkMode ? '#444' : '#fff';
         
        this.checkers.style.backgroundSize        = '22px 22px';
        this.checkers.style.backgroundPosition    = '0 0, 11px 11px';
         
        this.checkers.style.left                  = '-3.5px';
        this.checkers.style.width                 = 'calc(100% + 3.5px)';
              
              
        this.controls[0].div.style.position       = 'absolute';
        this.controls[1].div.style.position       = 'absolute';
   
        this.controls[0].div.style.left           = '0';
        this.controls[1].div.style.left           = '55%';
   
        this.controls[0].div.style.width          = '55%';
        this.controls[1].div.style.width          = '45%';

        this.controls[0].textbox.style.background = 'transparent';
        this.controls[1].textbox.style.background = 'transparent';


        this.div.style.background                 = rgb2style(rgbaBack);
        this.checkers.style.opacity               = 1 - rgbaBack[3];
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    isDefault = () => 
    {
        this.value.equals(this.defaultValue);
    };



    // textboxHasFocus()
    // {
    //     return hasFocus(this.controls[0].textbox)
    //         || hasFocus(this.controls[1].textbox);
    // }



    enableControlText(enable)
    {
        enable &= !this.input || !this.input.connected;

        // const opEnable = 
        //         enable 
        //     || !this.input 
        //     || !this.input.connected;
            //||  this.input.connectedOutput.supportsTypes(COLOR_TYPES);

        enableElementText(this.controls[0].div, enable);
        enableElementText(this.controls[1].div, enable);//opEnable);
        
        this.controls[0].readOnly = !enable;
        this.controls[1].readOnly = !enable;//opEnable;
    }
    
    
    
    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgba = this.value.toRgba();

        if (!rgbaIsNaN(rgba))
        {
            if (  !rgbaIsValid(rgba)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgba);

                this.updateWarningOverlayStyle(rgba);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgba);
            this.updateWarningOverlayStyle(rgba);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? this.div.offsetHeight
            : height;


        const [warnStyle1, warnStyle2] = getWarningStyles(colBack);

        this._warningOverlay.style.background =
                rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : getWarningGradient(7.8, warnStyle2, warnStyle1);

               
        this._warningOverlay.style.backgroundPosition = '0 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 27.6px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
    
    
    
    formatControlTextbox(control)
    {
        control.textbox.style.left = 
            control == this.controls[0]
            ? this.divControls.offsetLeft
            : this.divControls.offsetLeft + this.controls[0].div.offsetWidth;
     
        
        control.textbox.style.top       = this.div        .offsetTop;

        control.textbox.style.width     = control.div.offsetWidth;
        control.textbox.style.height    = defParamHeight;
        
        control.textbox.style.textAlign = 'center';
    }



    loadParam(_param)
    {
        this.setValue(parseFillValue(_param[2])[0], true, true, false);
    }
}


class   ColorStopParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    
    value;


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new ColorStopValue())
    {
        super(COLOR_STOP_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign  = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([COLOR_STOP_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([COLOR_STOP_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(COLOR_STOP_VALUES.includes(value.type), 'expected COLOR_STOP_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof ColorStopValue))
        {
            //console.log('value =', value);
            consoleError('ColorStopParam.setValue(): value is ' + typeof value + ', must be a ColorStopValue');
        }

        consoleAssert(
               value.type 
            && value.type == COLOR_STOP_VALUE, 
            'ColorStopParam value.type must be COLOR_STOP_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.supportsTypes(this.input.connectedOutput.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for ColorStopParam (' + this.node.id + ')');
        }

        else request.push( 
            COLOR_STOP_VALUE, 
            (new ColorStopValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        super.updateControls();


        checkParamVisible(this);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

 
        this.controls[0].textbox.value =
                    rgb2hex(this.value.fill.color.toRgb())
            + ' ' + this.value.fill.opacity.toNumber() + '%'
            + ' ' + this.value.position.toNumber() + '%';


        const rgba       = this.value.fill.toRgba();

        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);
        const rgbaBack   = rgbaStripe;
        const rgbaText   = getTextColorFromBackColor(rgbaStripe, rgba[3]);


        //this.updateWarningOverlay();


        if (this.input)
        {
            this.input.colorLight  = 
            this.input.colorDark   = rgb_a(rgbaText, 0.2);
            this.input.wireColor   = !rgbaIsNaN(rgbaBack) ? rgbaBack : noColor;
        }

        if (this.output)
        {
            this.output.colorLight =
            this.output.colorDark  = rgb_a(rgbaText, 0.2);
            this.output.wireColor  = !rgbaIsNaN(rgbaBack) ? rgbaBack : noColor;
        }
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseColorStopValue(_param[2])[0], true, true, false);
    }
}


class   GradientParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    
    value;


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new GradientValue())
    {
        super(GRADIENT_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign  = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([GRADIENT_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([GRADIENT_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(GRADIENT_VALUES.includes(value.type), 'expected GRADIENT_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof GradientValue))
        {
            //console.log('value =', value);
            consoleError('GradientParam.setValue(): value is ' + typeof value + ', must be a GradientValue');
        }

        consoleAssert(
               value.type 
            && value.type == GRADIENT_VALUE, 
            'GradientParam value.type must be GRADIENT_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.supportsTypes(this.input.connectedOutput.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for GradientParam (' + this.node.id + ')');
        }

        else request.push( 
            GRADIENT_VALUE, 
            (new GradientValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value = this.value.stops.items.length + ' ' + countString(this.value.stops.items.length, 'stop');


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseGradientValue(_param[2])[0], true, true, false);
    }
}


class   StrokeParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    
    value;


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new StrokeValue())
    {
        super(STROKE_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign  = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([STROKE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([STROKE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(STROKE_VALUES.includes(value.type), 'expected STROKE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof StrokeValue))
        {
            //console.log('value =', value);
            consoleError('StrokeParam.setValue(): value is ' + typeof value + ', must be a StrokeValue');
        }

        consoleAssert(
               value.type 
            && value.type == STROKE_VALUE, 
            'StrokeParam value.type must be STROKE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.supportsTypes(this.input.connectedOutput.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for StrokeParam (' + this.node.id + ')');
        }

        else request.push( 
            STROKE_VALUE, 
            (new StrokeValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        super.updateControls();


        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

 
        this.controls[0].textbox.value =
                    rgb2hex(this.value.fill.color.toRgb())
            + ' ' + this.value.fill.opacity.toNumber() + '%'
            + ' ' + this.value.weight.toNumber() + 'px';


        // if (this.input)
        // {
        //     this.input.colorLight  = 
        //     this.input.colorDark   =  rgb_a(rgbText, 0.2);
        //     this.input.wireColor   = !rgbIsNaN(rgbStripe) ? rgbStripe : noColor;
        // }

        // if (this.output)
        // {
        //     this.output.colorLight =
        //     this.output.colorDark  =  rgb_a(rgbText, 0.2);
        //     this.output.wireColor  = !rgbIsNaN(rgbStripe) ? rgbStripe : noColor;
        // }
     }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseStrokeValue(_param[2])[0], true, true, false);
    }
}


class   ListParam
extends Parameter
{
    defaultValue;

    oldValue     = null;
    

    itemName;
    showZero     = false;
    showCount    = false;

    getItemCount = null;

    
    value;


    listTypes = []; // the only types to consider, unless it's empty, then it's all types
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new ListValue())
    {
        super(LIST_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;

        this.itemName     = 'item';


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
        this.controls[0].readOnly                =  true;
   
        
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([LIST_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([LIST_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(LIST_VALUES.includes(value.type), 'expected LIST_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof ListValue))
        {
            //console.log('value =', value);
            consoleError('ListParam.setValue(): value is ' + typeof value + ', must be a ListValue');
        }

        consoleAssert(
               value.type 
            && LIST_VALUES.includes(value.type), 
            'ListParam value.type must be LIST_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);

        if (this.output)
            this.output.types = [finalListTypeFromItems(this.value.items)];


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            // if (this.input.supportsTypes(this.input.connectedOutput.types))
            // {
                request.push(...pushInputOrParam(this.input, gen));
            // }
            // else
            //     consoleError('invalid input for ListParam (' + this.node.id + ')');
        }

        else request.push( 
            LIST_VALUE, 
            (new ListValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        enableElementText(this.controls[0].div, false);


        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        
        const nItems = 
            this.getItemCount
            ? this.getItemCount()
            : this.value.items
                  .filter(i => 
                         isEmpty(this.listTypes) 
                      || this.listTypes.includes(i.type))
                  .length;

        let value =
            this.itemName != ''
            ?   (this.node.isUnknown() ? '? ' : ((nItems != 0 || this.showZero) ? (nItems + ' ') : ''))
              +  countString(nItems, this.itemName)
            : this.name;

        if (this.showCount)
            value += '  [ ' + nItems + ' ]';


        this.controls[0].textbox.value = value;

        if (this.output)
            this.output.types = [finalListTypeFromItems(this.value.items)];


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseListValue(_param[2])[0], true, true, false);
    }
}


class   RectangleParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new RectangleValue())
    {
        super(RECTANGLE_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([RECTANGLE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([RECTANGLE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == RECTANGLE_VALUE, 'expected ' + RECTANGLE_VALUE + 'in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof RectangleValue))
            consoleError('RectangleParam.setValue(value) is ' + typeof value + ', must be a RectangleValue');

        consoleAssert(
               value.type 
            && value.type == RECTANGLE_VALUE, 
            'RectangleParam value.type must be RECTANGLE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([RECTANGLE_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for RectangleParam (' + this.node.id + ')');
        }

        else request.push( 
            RECTANGLE_VALUE, 
            (new RectangleValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.innerHTML        = 'rectangle';


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseRectangleValue(_param[2])[0], true, true, false);
    }
}


class   LineParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new LineValue())
    {
        super(LINE_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([LINE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([LINE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == LINE_VALUE, 'expected LINE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof LineValue))
            consoleError('LineParam.setValue(value) is ' + typeof value + ', must be a LineValue');

        consoleAssert(
               value.type 
            && value.type == LINE_VALUE, 
            'LineParam value.type must be LINE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([LINE_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for LineParam (' + this.node.id + ')');
        }

        else request.push( 
            LINE_VALUE, 
            (new LineValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'line';


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseLineValue(_param[2])[0], true, true, false);
    }
}


class   EllipseParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new EllipseValue())
    {
        super(ELLIPSE_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([ELLIPSE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([ELLIPSE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == ELLIPSE_VALUE, 'expected ELLIPSE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof EllipseValue))
            consoleError('EllipseParam.setValue(value) is ' + typeof value + ', must be a EllipseValue');

        consoleAssert(
               value.type 
            && value.type == ELLIPSE_VALUE, 
            'EllipseParam value.type must be ELLIPSE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([ELLIPSE_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for EllipseParam (' + this.node.id + ')');
        }

        else request.push( 
            ELLIPSE_VALUE, 
            (new EllipseValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'ellipse';


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseEllipseValue(_param[2])[0], true, true, false);
    }
}


class   PolygonParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new PolygonValue())
    {
        super(POLYGON_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([POLYGON_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([POLYGON_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == POLYGON_VALUE, 'expected POLYGON_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof PolygonValue))
            consoleError('PolygonParam.setValue(value) is ' + typeof value + ', must be a PolygonValue');

        consoleAssert(
               value.type 
            && value.type == POLYGON_VALUE, 
            'PolygonParam value.type must be POLYGON_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([POLYGON_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for PolygonParam (' + this.node.id + ')');
        }

        else request.push( 
            POLYGON_VALUE, 
            (new PolygonValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'polygon';


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parsePolygonValue(_param[2])[0], true, true, false);
    }
}


class   StarParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new StarValue())
    {
        super(STAR_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([STAR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([STAR_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == STAR_VALUE, 'expected STAR_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof StarValue))
            consoleError('StarParam.setValue(value) is ' + typeof value + ', must be a StarValue');

        consoleAssert(
               value.type 
            && value.type == STAR_VALUE, 
            'StarParam value.type must be STAR_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([STAR_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for StarParam (' + this.node.id + ')');
        }

        else request.push( 
            STAR_VALUE, 
            (new StarValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'star';


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseStarValue(_param[2])[0], true, true, false);
    }
}


class   TextShapeParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new TextShapeValue())
    {
        super(TEXT_SHAPE_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([TEXT_SHAPE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([TEXT_SHAPE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == TEXT_SHAPE_VALUE, 'expected TEXT_SHAPE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof TextShapeValue))
            consoleError('TextShapeParam.setValue(value) is ' + typeof value + ', must be a TextShapeValue');

        consoleAssert(
               value.type 
            && value.type == TEXT_SHAPE_VALUE, 
            'TextShapeParam value.type must be TEXT_SHAPE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([TEXT_SHAPE_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for TextShapeParam (' + this.node.id + ')');
        }

        else request.push( 
            TEXT_SHAPE_VALUE, 
            (new TextShapeValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'text';


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseTextShapeValue(_param[2])[0], true, true, false);
    }
}


class   PointParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new PointValue())
    {
        super(POINT_VALUE, id, name, showName);

        defaultValue = defaultValue.copy();
        defaultValue.nodeId = this.nodeId;

        this.defaultValue = defaultValue.copy();
        this.value        = defaultValue.copy();


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
       
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([POINT_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([POINT_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == POINT_VALUE, 'expected POINT_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof PointValue))
            consoleError('PointParam.setValue(value) is ' + typeof value + ', must be a PointValue');

        consoleAssert(
               value.type 
            && value.type == POINT_VALUE, 
            'PointParam value.type must be POINT_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value.copy();
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes(this.input.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                request.push(POINT_VALUE, '?,? ?,?');
        }

        else request.push( 
            POINT_VALUE, 
            PointValue.create(this.nodeId, this.value.x.value, this.value.y.value).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        
        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value = 
                this.value.isValid()
            && !this.node.isUnknown()
            ?          printNum(this.value.x.value)  
              + ', ' + printNum(this.value.y.value)
            : NAN_DISPLAY;


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parsePointValue(_param[2])[0], true, true, false);
    }
}


class   VectorPathParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new VectorPathValue())
    {
        super(VECTOR_PATH_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([VECTOR_PATH_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([VECTOR_PATH_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == VECTOR_PATH_VALUE, 'expected VECTOR_PATH_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof VectorPathValue))
            consoleError('VectorPathParam.setValue(value) is ' + typeof value + ', must be a VectorPathValue');

        consoleAssert(
               value.type 
            && value.type == VECTOR_PATH_VALUE, 
            'VectorPathParam value.type must be VECTOR_PATH_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([VECTOR_PATH_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for VectorPathParam (' + this.node.id + ')');
        }

        else request.push( 
            VECTOR_PATH_VALUE, 
            (new VectorPathValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'vector path';


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseVectorPathValue(_param[2])[0], true, true, false);
    }
}


class   ShapeGroupParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new VectorPathValue())
    {
        super(SHAPE_GROUP_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([SHAPE_GROUP_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([SHAPE_GROUP_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == SHAPE_GROUP_VALUE, 'expected SHAPE_GROUP_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof ShapeGroupValue))
            consoleError('ShapeGroupParam.setValue(value) is ' + typeof value + ', must be a ShapeGroupValue');

        consoleAssert(
               value.type 
            && value.type == SHAPE_GROUP_VALUE, 
            'ShapeGroupParam value.type must be SHAPE_GROUP_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([SHAPE_GROUP_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for ShapeGroupParam (' + this.node.id + ')');
        }

        else request.push( 
            SHAPE_GROUP_VALUE, 
            (new ShapeGroupValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'rectangle';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseVectorPathValue(_param[2])[0], true, true, false);
    }
}


class   FrameParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new VectorPathValue())
    {
        super(FRAME_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([FRAME_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([FRAME_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == FRAME_VALUE, 'expected FRAME_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        //if (!(value instanceof FrameValue))
            consoleError('FrameParam.setValue(value) is ' + typeof value + ', must be a FrameValue');

        consoleAssert(value.type && value.type == FRAME_VALUE, 'FrameParam value.type must be FRAME_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([FRAME_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            //else
                consoleError('invalid input for FrameParam (' + this.node.id + ')');
        }

        else request.push( 
            FRAME_VALUE, 
            (new FrameValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkParamVisible(this);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'rectangle';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseVectorPathValue(_param[2])[0], true, true, false);
    }
}


class   DropShadowParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    
    value;


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new DropShadowValue())
    {
        super(DROP_SHADOW_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign  = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([DROP_SHADOW_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([DROP_SHADOW_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(DROP_SHADOW_VALUES.includes(value.type), 'expected DROP_SHADOW_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof DropShadowValue))
        {
            //console.log('value =', value);
            consoleError('DropShadowParam.setValue(): value is ' + typeof value + ', must be a DropShadowValue');
        }

        consoleAssert(
               value.type 
            && value.type == DROP_SHADOW_VALUE, 
            'DropShadowParam value.type must be DROP_SHADOW_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.supportsTypes(this.input.connectedOutput.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for DropShadowParam (' + this.node.id + ')');
        }

        else request.push( 
            DROP_SHADOW_VALUE, 
            (new DropShadowValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkParamVisible(this);
        

        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

 
        this.controls[0].textbox.value = 'drop shadow';
            //   'drop ' 
            // +  printNum(this.value.x.value)  
            // + ', ' 
            // +  printNum(this.value.y.value)
            // + 'B: ' + printNum(this.value.blur.value)
            // + 'S: ' + printNum(this.value.spread.value);


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseDropShadowValue(_param[2])[0], true, true, false);
    }
}


class   InnerShadowParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    
    value;


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new InnerShadowValue())
    {
        super(INNER_SHADOW_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign  = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([INNER_SHADOW_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([INNER_SHADOW_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(INNER_SHADOW_VALUES.includes(value.type), 'expected INNER_SHADOW_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof InnerShadowValue))
        {
            //console.log('value =', value);
            consoleError('InnerShadowParam.setValue(): value is ' + typeof value + ', must be a InnerShadowValue');
        }

        consoleAssert(
               value.type 
            && value.type == INNER_SHADOW_VALUE, 
            'InnerShadowParam value.type must be INNER_SHADOW_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.supportsTypes(this.input.connectedOutput.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for InnerShadowParam (' + this.node.id + ')');
        }

        else request.push( 
            INNER_SHADOW_VALUE, 
            (new InnerShadowValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

 
        this.controls[0].textbox.value = 'inner shadow';
            //   'drop ' 
            // +  printNum(this.value.x.value)  
            // + ', ' 
            // +  printNum(this.value.y.value)
            // + 'B: ' + printNum(this.value.blur.value)
            // + 'S: ' + printNum(this.value.spread.value);


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseInnerShadowValue(_param[2])[0], true, true, false);
    }
}


class   LayerBlurParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    
    value;


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new LayerBlurValue())
    {
        super(LAYER_BLUR_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign  = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([LAYER_BLUR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([LAYER_BLUR_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(LAYER_BLUR_VALUES.includes(value.type), 'expected LAYER_BLUR_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof LayerBlurValue))
        {
            //console.log('value =', value);
            consoleError('LayerBlurParam.setValue(): value is ' + typeof value + ', must be a LayerBlurValue');
        }

        consoleAssert(
               value.type 
            && value.type == LAYER_BLUR_VALUE, 
            'LayerBlurParam value.type must be LAYER_BLUR_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.supportsTypes(this.input.connectedOutput.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for LayerBlurParam (' + this.node.id + ')');
        }

        else request.push( 
            LAYER_BLUR_VALUE, 
            (new LayerBlurValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

 
        this.controls[0].textbox.value = 'layer blur';
            //   'drop ' 
            // +  printNum(this.value.x.value)  
            // + ', ' 
            // +  printNum(this.value.y.value)
            // + 'B: ' + printNum(this.value.blur.value)
            // + 'S: ' + printNum(this.value.spread.value);


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseLayerBlurValue(_param[2])[0], true, true, false);
    }
}


class   BackBlurParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    
    value;


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new BackBlurValue())
    {
        super(BACK_BLUR_VALUE, id, name, showName);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign  = 'center';
   
        this.divControls.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput ([BACK_BLUR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([BACK_BLUR_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(BACK_BLUR_VALUES.includes(value.type), 'expected BACK_BLUR_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof BackBlurValue))
        {
            //console.log('value =', value);
            consoleError('BackBlurParam.setValue(): value is ' + typeof value + ', must be a BackBlurValue');
        }

        consoleAssert(
               value.type 
            && value.type == BACK_BLUR_VALUE, 
            'BackBlurParam value.type must be BACK_BLUR_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.supportsTypes(this.input.connectedOutput.types))
                request.push(...pushInputOrParam(this.input, gen));
            else
                consoleError('invalid input for BackBlurParam (' + this.node.id + ')');
        }

        else request.push( 
            BACK_BLUR_VALUE, 
            (new BackBlurValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkParamVisible(this);
        

        // this.div.style.background = 
        //     darkMode 
        //     ? this.backStyleDark 
        //     : this.backStyleLight;


        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

 
        this.controls[0].textbox.value = 'back blur';
            //   'drop ' 
            // +  printNum(this.value.x.value)  
            // + ', ' 
            // +  printNum(this.value.y.value)
            // + 'B: ' + printNum(this.value.blur.value)
            // + 'S: ' + printNum(this.value.spread.value);


        super.updateControls();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseBackBlurValue(_param[2])[0], true, true, false);
    }
}


class   Input
extends EventTarget
{
    types = []; // an input can accept multiple types


    _node  = null; get node () { return this._param ? this._param.node : this._node; }
    _param = null; get param() { return this._param; }


    get id()   
    { 
        return this.node
             ? this.node.getInputId(this)
             : this.param
               ? this.param.id
               : '';     
    }
    
    get index() { return this.node.inputs.indexOf(this); }

    
    colorLight;
    colorDark;

    wireColor;

    
    div;
    hitbox;
    wireBall;


    measureData = { divBounds: new Rect(0, 0, 0, 0) };


    _connectedOutput = null;
    
    
    get connectedOutput() { return this._connectedOutput; }

    set connectedOutput(output)
    {
        if (this._connectedOutput)
        {
            this                 .dispatchEvent(new CustomEvent('disconnect', { detail: { input:  this   }}));
            this._connectedOutput.dispatchEvent(new CustomEvent('disconnect', { detail: { output: output }}));
        }

        this._connectedOutput = output;

        if (this._connectedOutput)
        {
            this  .dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this }}));
            output.dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this }}));
        }
    }


    get connected() { return this.connectedOutput != null; }


    canConnect         = true; // all connections master switch for minimum zoom
    canAutoConnect     = true;
    outputMustBeCached = false;


    connection         = null;
           
    connecting         = false;
    mouseOver          = false;

    overFactor         = 1.7;
           
    
    initialSeed        = 0;
    currentSeed        = 0;
       
       
    isNew              = false; // this indicates that the input is the empty "new" input of a variable node


    getValuesForUndo; // function pointer, return array of [index,value] tuples

    getBackInitValue   = null;
    
    feedback           = false; // sends data back to the output



    constructor(types, getValuesForUndo = null, getBackInitValue = null)
    {
        super();
        

        this.types            = [...types];
        this.getValuesForUndo = getValuesForUndo;
        this.getBackInitValue = getBackInitValue;


        this.div              = createDiv('input');
        this.hitbox           = createDiv('inputHitbox');
        this.wireBall         = createDiv('inputBall');
        
        this.div.input        = this;
        
        
        this.colorLight       = [0, 0, 0, 1];
        this.colorDark        = [1, 1, 1, 1];

        this.wireColor        = rgbFromType(this.types[0], true);

        
        this.div.appendChild(this.hitbox);
        this.div.appendChild(this.wireBall);


                
        this.hitbox.addEventListener('pointerenter', e => 
        {
            if (!this.canReact(e))
                return;


            if (graphView.headerInput)
            {
                graphView.headerInput.updateControl();
                graphView.headerInput = null;
                //console.log('headerInput = ', graphView.headerInput);
            }

            
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

                
            this.mouseOver = true;
            this.updateControl();


            const tc = graphView.tempConn;

            if (   tc
                && tc.output
                && this.canConnectFrom(tc.output)
                && (  !this.connected
                    || this.connectedOutput != tc.output
                    || this == savedInput))
            {
                const rect = boundingRect(this.div);
                const loop = tc.output.node.isOrFollows(this.node);

                if (!loop)
                {
                    tc.wire.inputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - getTopHeight());
                }

                graphView.overInput = !loop ? this : null;
                this.node.inputs.forEach(i => i.updateControl());
            }
            else if (!tc
                   ||    tc.output
                      && this.canConnectFrom(tc.output))
                graphView.overInput = this;
        });

        

        this.hitbox.addEventListener('pointerdown', e => 
        { 
            if (!this.canReact(e)) 
                return false; 
        });



        this.hitbox.addEventListener('pointerleave', e => 
        {
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overInput = null;

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.output)
            graphView.tempConn.wire.inputPos = point_NaN;
    }



    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.node ? this.node.header : this.param.node.header);

        return false;
    }



    updateMeasureData()
    {
        this.measureData = 
        {
            divBounds: boundingRect(this.div)
        };
    }


    
    // updateColor()
    // {
    //     this.colorDark = rgbFromTypeMode(
    //         !isEmpty(this.types) 
    //         ? this.types[0] 
    //         : NUMBER_VALUE, 
    //         true);

    //     this.colorLight = rgbFromTypeMode(
    //         !isEmpty(this.types) 
    //         ? this.types[0] 
    //         : NUMBER_VALUE, 
    //         false);
    // }



    updateControl()
    {
        const tc = graphView.tempConn;

        const mouseOver =
               this.mouseOver
            && !(   tc 
                 && tc.input)
            && !(   tc
                 && tc.output
                 && (  !this.canConnectFrom(tc.output)
                     || tc.output.node.isOrFollows(this.node)));

        const color = 
               this.param
            && this.param.type != COLOR_VALUE
            && this.param.type !=  FILL_VALUE
            ? rgb_a(rgbFromType(this.param.type, true), 0.5)
            : (darkMode
               ? this.colorDark
               : this.colorLight);

        const colorStyle = 
            rgba2style(rgb_a(
                color,
                mouseOver 
                ? (tc ? tc.wire.color : Math.min(color[3] * this.overFactor, 1))
                : color[3]));


        const isConnected =
               this.connected
            ||     tc
               && (   tc.input == this
                   ||    graphView.overInput == this
                      && !tc.input)
               && !(    tc.output
                    && !this.canConnectFrom(tc.output));

        this.div.style.transform = 
              'translateX(' + (isConnected ? -1 : 0) + 'px)'
            + 'translateY(-50%)';
        
        this.div.style.width                = (isConnected ? 8 : 6) + 'px';
        this.div.style.height               = (isConnected ? 8 : 6) + 'px';
        this.div.style.borderRadius         = (isConnected ? 4 : 4) + 'px';
        this.div.style.marginBottom         = (isConnected ? 4 : 6) + 'px';
        this.div.style.boxShadow            = '0 0 0 1px ' + colorStyle;
        this.div.style.pointerEvents        = 'auto';

        this.hitbox.style.left              = isConnected ? -2 : -3;
        this.hitbox.style.top               = isConnected ? -2 : -3;


        const zoom = graph.currentPage.zoom;

        this.hitbox.style.left              = isConnected ? -2 : -3;
        this.hitbox.style.width             = 12 + Math.max(0, (1 - 1*zoom) * 10);

        this.hitbox.style.top               = (isConnected ? -2 : -3) - Math.max(0, (1 - 1*zoom) * 10);
        this.hitbox.style.height            = 12 + Math.max(0, (1 - 1*zoom) * 20);


        this.wireBall.style.left            = '1px';
        this.wireBall.style.top             = 'calc(50% - 3px)';

        this.wireBall.style.backgroundColor = [255, 0, 255];

        this.wireBall.style.zIndex          = MAX_INT32;


        showElement(this.wireBall, isConnected); 
    }



    supportsTypes(types)
    {
        return this.types.includes(ANY_VALUE)
             ? true
             : arraysIntersect(this.types, types);
    }



    canConnectFrom(output)
    {
        if (   output.supportsTypes([ANY_VALUE])
            && this.types[0] != ANY_VALUE)
            return false;

        if (   !this.canConnect
            || !this.supportsTypes(output.types))
            return false;

        if (    this.outputMustBeCached 
            && !output.node.isCached())
            return false;

        if (output.node.isOrFollows(this.node))
        if (output.node.follows(this.node))
            return false;


        return true;
    }



    // isConnectedUncached()
    // {
    //     return  this.connected 
    //         && !this.connectedOutput.node.isCached()
    //         && !this.connectedOutput.node.isOrPrecededByMultiplier();
    // }




    isUncached()
    {
        if (this.connectedOutput)
            return this.connectedOutput.node.isOrPrecededByUncached();
        // if (    this.connectedOutput
        //     && !this.connectedOutput.node.cached)
        //     return true;

        // else if (   this.connectedOutput
        //          && this.connectedOutput.node.hasUncachedInputs())
        //     return true;

        return false;
    }



    toJsDef(gen)
    {
        let js = '';


        js += gen.NL + 'const ' + this.name + ' = ';

        js += 
            this.connected
            ? this.connectedOutput.toJsCode(gen)
            : this.param
                ? this.param.toJsCode(gen)
                : 'Number.NaN';
                
        js += ';';


        return js;
    }
}


// class   InputProxy
// extends EventTarget
// {
//     input = null;


//     types = []; // an input can accept multiple types


//     _node  = null; get node () { return this._param ? this._param.node : this._node; }
//     _param = null; get param() { return this._param; }


//     get id()   
//     { 
//         return this.node
//              ? this.node.getInputId(this)
//              : this.param
//                ? this.param.id
//                : '';     
//     }
    
//     get index() { return this.node.inputs.indexOf(this); }

    
//     colorLight;
//     colorDark;

//     wireColor;

    
//     div;
//     hitbox;
//     wireBall;


//     measureData = { divBounds: new Rect(0, 0, 0, 0) };


//     _connectedOutput = null;
    
//     get connectedOutput() { return this.input._connectedOutput; }
//     set connectedOutput(output)
//     {
//         if (this.input._connectedOutput)
//         {
//             this.input                 .dispatchEvent(new CustomEvent('disconnect', { detail: { input:  this.input   }}));
//             this.input._connectedOutput.dispatchEvent(new CustomEvent('disconnect', { detail: { output: output }}));
//         }

//         this.input._connectedOutput = output;

//         if (this.input._connectedOutput)
//         {
//             this.input.dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this.input }}));
//             output.dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this.input }}));
//         }
//     }


//     get connected() { return this.input.connectedOutput != null; }


//     canConnect         = true; // all connections master switch for minimum zoom
//     canAutoConnect     = true;
//     outputMustBeCached = false;


//     connection         = null;
           
//     connecting         = false;
//     mouseOver          = false;

//     overFactor         = 1.7;
           
    
//     initialSeed        = 0;
//     currentSeed        = 0;
       
       
//     isNew              = false; // this indicates that the input is the empty "new" input of a variable node


//     getValuesForUndo; // function pointer, return array of [index,value] tuples

//     getBackInitValue   = null;
    
//     feedback           = false; // sends data back to the output



//     constructor(input)//types, getValuesForUndo = null, getBackInitValue = null)
//     {
//         super();
        

//         this.types            = [...input.types];
//         this.getValuesForUndo = input.getValuesForUndo;
//         this.getBackInitValue = input.getBackInitValue;


//         this.div              = createDiv('input');
//         this.hitbox           = createDiv('inputHitbox');
//         this.wireBall         = createDiv('inputBall');
        
//         this.div.input        = this;
        
        
//         this.colorLight       = [0, 0, 0, 1];
//         this.colorDark        = [1, 1, 1, 1];

//         this.wireColor        = rgbFromType(this.types[0], true);

        
//         this.div.appendChild(this.hitbox);
//         this.div.appendChild(this.wireBall);


                
//         this.hitbox.addEventListener('pointerenter', e => 
//         {
//             if (!this.canReact(e))
//                 return;


//             if (graphView.headerInput)
//             {
//                 graphView.headerInput.updateControl();
//                 graphView.headerInput = null;
//                 //console.log('headerInput = ', graphView.headerInput);
//             }

            
//             let savedInput = 
//                 graphView.savedConn
//                 ? graphView.savedConn.input
//                 : null;

                
//             this.mouseOver = true;
//             this.updateControl();


//             const tc = graphView.tempConn;

//             if (   tc
//                 && tc.output
//                 && this.canConnectFrom(tc.output)
//                 && (  !this.connected
//                     || this.connectedOutput != tc.output
//                     || this == savedInput))
//             {
//                 const rect = boundingRect(this.div);
//                 const loop = tc.output.node.isOrFollows(this.node);

//                 if (!loop)
//                 {
//                     tc.wire.inputPos = point(
//                         rect.x + rect.w/2,
//                         rect.y + rect.h/2 - getTopHeight());
//                 }

//                 graphView.overInput = !loop ? this : null;
//                 this.node.inputs.forEach(i => i.updateControl());
//             }
//             else if (!tc
//                    ||    tc.output
//                       && this.canConnectFrom(tc.output))
//                 graphView.overInput = this;
//         });

        

//         this.hitbox.addEventListener('pointerdown', e => 
//         { 
//             if (!this.canReact(e)) 
//                 return false; 
//         });



//         this.hitbox.addEventListener('pointerleave', e => 
//         {
//             this.endConnection();
//         });
//     }



//     endConnection()
//     {
//         graphView.overInput = null;

//         this.mouseOver = false;
//         this.updateControl();

//         if (   graphView.tempConn
//             && graphView.tempConn.output)
//             graphView.tempConn.wire.inputPos = point_NaN;
//     }



//     canReact(e)
//     {
//         if (   settings.enableZoomedOutParams
//             || graph.currentPage.zoom > settings.minZoomForParams)
//             return true;

//         e.preventDefault();
//         e.stopPropagation();

//         forwardEvent(e, this.node ? this.node.header : this.param.node.header);

//         return false;
//     }



//     updateMeasureData()
//     {
//         this.measureData = 
//         {
//             divBounds: boundingRect(this.div)
//         };
//     }


    
//     // updateColor()
//     // {
//     //     this.colorDark = rgbFromTypeMode(
//     //         !isEmpty(this.types) 
//     //         ? this.types[0] 
//     //         : NUMBER_VALUE, 
//     //         true);

//     //     this.colorLight = rgbFromTypeMode(
//     //         !isEmpty(this.types) 
//     //         ? this.types[0] 
//     //         : NUMBER_VALUE, 
//     //         false);
//     // }



//     updateControl()
//     {
//         const tc = graphView.tempConn;

//         const mouseOver =
//                this.mouseOver
//             && !(   tc 
//                  && tc.input)
//             && !(   tc
//                  && tc.output
//                  && (  !this.canConnectFrom(tc.output)
//                      || tc.output.node.isOrFollows(this.node)));

//         const color = 
//                this.param
//             && this.param.type != COLOR_VALUE
//             && this.param.type !=  FILL_VALUE
//             ? rgb_a(rgbFromType(this.param.type, true), 0.5)
//             : (darkMode
//                ? this.colorDark
//                : this.colorLight);

//         const colorStyle = 
//             rgba2style(rgb_a(
//                 color,
//                 mouseOver 
//                 ? (tc ? tc.wire.color : Math.min(color[3] * this.overFactor, 1))
//                 : color[3]));


//         const isConnected =
//                this.connected
//             ||     tc
//                && (   tc.input == this
//                    ||    graphView.overInput == this
//                       && !tc.input)
//                && !(    tc.output
//                     && !this.canConnectFrom(tc.output));

//         this.div.style.transform = 
//               'translateX(' + (isConnected ? -1 : 0) + 'px)'
//             + 'translateY(-50%)';
        
//         this.div.style.width                = (isConnected ? 8 : 6) + 'px';
//         this.div.style.height               = (isConnected ? 8 : 6) + 'px';
//         this.div.style.borderRadius         = (isConnected ? 4 : 4) + 'px';
//         this.div.style.marginBottom         = (isConnected ? 4 : 6) + 'px';
//         this.div.style.boxShadow            = '0 0 0 1px ' + colorStyle;
//         this.div.style.pointerEvents        = 'auto';

//         this.hitbox.style.left              = isConnected ? -2 : -3;
//         this.hitbox.style.top               = isConnected ? -2 : -3;

//         this.wireBall.style.left            = '1px';
//         this.wireBall.style.top             = 'calc(50% - 3px)';

//         this.wireBall.style.backgroundColor = [255, 0, 255];

//         this.wireBall.style.zIndex          = MAX_INT32;


//         showElement(this.wireBall, isConnected); 
//     }



//     supportsTypes(types)
//     {
//         return this.types.includes(ANY_VALUE)
//              ? true
//              : arraysIntersect(this.types, types);
//     }



//     canConnectFrom(output)
//     {
//         if (   output.supportsTypes([ANY_VALUE])
//             && this.types[0] != ANY_VALUE)
//             return false;

//         if (   !this.canConnect
//             || !this.supportsTypes(output.types))
//             return false;

//         if (    this.outputMustBeCached 
//             && !output.node.isCached())
//             return false;

//         if (output.node.isOrFollows(this.node))
//             return false;


//         return true;
//     }



//     isConnectedUncached()
//     {
//         return  this.connected 
//             && !this.connectedOutput.node.isCached();
//     }



//     toJsDef(gen)
//     {
//         let js = '';


//         js += gen.NL + 'const ' + this.name + ' = ';

//         js += 
//             this.connected
//             ? this.connectedOutput.toJsCode(gen)
//             : this.param
//                 ? this.param.toJsCode(gen)
//                 : 'Number.NaN';
                
//         js += ';';


//         return js;
//     }
// }


class Output
extends EventTarget
{
    types = []; // an output can have multiple types

    
    _node  = null; get node () { return this._param && this._param.node ? this._param.node : this._node; }
    _param = null; get param() { return this._param; }
    
    
    get id()    
    { 
        return this.node 
             ? this.node.getOutputId(this) 
             : this.param
               ? this.param.id
               : ''; 
    }

    get index() { return this.node ? this.node.outputs.indexOf(this) : ''; }


    colorLight;
    colorDark;

    wireColor;


    div;
    hitbox;
    wireBall;


    measureData = { divBounds: new Rect(0, 0, 0, 0) };


    connectedInputs = [];

    get connectedHeaderInputs() { return this.connectedInputs.filter(i => !i.param); }
    get connected() { return !isEmpty(this.connectedInputs); }

    
    get connections() { return this.connectedInputs.map(i => i.connection); }


    mouseOver  = false;
    connecting = false;
 
    overFactor = 1.7;
 
 
    genRequest = null; // function pointer, must be implemented
    cache      = [];


    getValuesForUndo; // function pointer, return array of [index,value] tuples

    backInit   = null;




    constructor(types, genRequest, getValuesForUndo = null, backInit = null)
    {
        super();

        
        this.types            = [...types];
        this.genRequest       = genRequest;
        this.getValuesForUndo = getValuesForUndo;
        this.backInit         = backInit;

        
        this.div              = createDiv('output');
        this.hitbox           = createDiv('outputHitbox');
        this.wireBall         = createDiv('outputBall');
              
        this.div.output       = this;
              
              
        this.colorLight       = [0, 0, 0, 1];
        this.colorDark        = [1, 1, 1, 1];
      
        this.wireColor        = rgb_NaN;
        

        this.div.appendChild(this.hitbox);
        this.div.appendChild(this.wireBall);



        this.hitbox.addEventListener('pointerenter', e => 
        { 
            if (!this.canReact(e))
                return false;


            if (graphView.headerOutput)
            {
                graphView.headerOutput.updateControl();
                graphView.headerOutput = null;
                //console.log('headerOutput = ', graphView.headerOutput);
            }


            this.mouseOver = true;
            this.updateControl();


            if (   graphView.tempConn
                && graphView.tempConn.input
                && this.supportsTypes(graphView.tempConn.input.types))//.includes(this.type))
            {
                const rect = boundingRect(this.div);
                const loop = this.node.isOrFollows(graphView.tempConn.input.node);

                if (!loop)
                {
                    graphView.tempConn.wire.outputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - getTopHeight());
                }

                graphView.overOutput = !loop ? this : null;
                this.node.outputs.forEach(o => o.updateControl());
            }
            else
                graphView.overOutput = this; 
        });



        this.hitbox.addEventListener('pointerdown', e => 
        { 
            if (!this.canReact(e)) 
                return false; 
        });



        this.hitbox.addEventListener('pointerleave', e => 
        { 
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overOutput = null; 

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.input)
            graphView.tempConn.wire.outputPos = point_NaN;
    }



    updateSavedConnectionOrder(orderAfter, delta)
    {
        // update output order on existing connections created after this one
        
        const afterConns = this.connectedInputs
            .map   (i => i.connection)
            .filter(c => delta < 1 
                         ? (c.outputOrder >  orderAfter) 
                         : (c.outputOrder >= orderAfter));

        const oldKeys = afterConns.map(c => getConnKey(c));
        afterConns.forEach(c => c.outputOrder += delta);
        
        const newKeys = afterConns.map(c => getConnKey(c));

        uiUpdateSavedConnections(oldKeys, newKeys, afterConns);
    }



    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.node ? this.node.header : this.param.node.header);

        return false;
    }



    updateMeasureData()
    {
        this.measureData = 
        {
            divBounds: clientRect(this.div)
        };
    }


    
    updateControl()
    {
        const mouseOver =
               this.mouseOver
            && !(   graphView.tempConn
                 && graphView.tempConn.output)
            && !(   graphView.tempConn
                 && graphView.tempConn.input
                 && (  !graphView.tempConn.input.types.includes(this.type)
                     || this.node.isOrFollows(graphView.tempConn.input.node)));


        const color = 
               this.param
            && this.param.type != COLOR_VALUE
            && this.param.type !=  FILL_VALUE
            ? rgb_a(rgbFromType(this.types[0], true), 0.38)
            : (darkMode
               ? this.colorDark
               : this.colorLight);

        const colorStyle = 
            rgba2style(rgb_a(
                color, 
                mouseOver 
                ? Math.min(color[3] * this.overFactor, 1) 
                : color[3]));


        const isConnected =
               !isEmpty(this.connectedInputs)
            ||     graphView.tempConn
               && (   graphView.tempConn.output == this
                   ||     graphView.overOutput == this
                      && !graphView.tempConn.output)
               && !(    graphView.tempConn.input
                    && !graphView.tempConn.input.types.includes(this.type));

        this.div.style.transform = 
            //  'translateX(' + (isConnected ? -1 : 0) + 'px)'
            //+ 
            'translateY(-50%)';

        this.div.style.pointerEvents   = 'auto';
        this.div.style.backgroundColor = colorStyle;

        this.div.style.boxShadow = 
               !isEmpty(this.connectedInputs)
            ||    graphView.tempConn
               && (   graphView.tempConn.output == this
                   || graphView.overOutput == this)
            ? '0 0 0 1px ' + colorStyle
            : 'none';


        const zoom = graph.currentPage.zoom;

        this.hitbox.style.left  = -3 - Math.max(0, (1 - 1*zoom) * 10);
        this.hitbox.style.width = 12 + Math.max(0, (1 - 1*zoom) * 10);

        this.hitbox.style.top    = -3 - Math.max(0, (1 - 1*zoom) * 10);
        this.hitbox.style.height = 12 + Math.max(0, (1 - 1*zoom) * 20);
        

        this.wireBall.style.top    = '50%';
        this.wireBall.style.zIndex =  MAX_INT32;


        showElement(this.wireBall, isConnected);
    }



    supportsTypes(types)
    {
        return this.types.includes(ANY_VALUE)
             ? true
             : arraysIntersect(this.types, types);
    }



    canConnectTo(input)
    {
        // console.log('this.supportsTypes([ANY_VALUE] =', this.supportsTypes([ANY_VALUE]));

        if (this.supportsTypes([ANY_VALUE]))
            return true;

        return arraysIntersect(this.types, input.types);
    }



    isMultiplied()
    {
        if (this.connectedInputs.length > 1)
            return true;

        for (const input of this.connectedInputs)
        {
            if (input.node.isMultiplier)
                return true;

            else if (input.node.hasMultipliedOutputs())
                return true;
        }

        return false
    }



    toJsCode(gen)
    {
        return this.param
             ? this.param.toJsCode(gen)
             : this.node .toJsCode(gen);
    }
}





class Connection
{
    static nextId = 0;

    id;

    output;
    outputOrder; // in which connections FROM THIS OUTPUT were made
    
    input;

    list           = false;

    wire;
    
    backInit       = false; // if true, on connection the value is possibly copied from the input to the output

    // proxy          = null;

    
    stripIdForCopy = false;



    constructor(output, input)
    {
        this.id          = Connection.nextId++;

        this.output      = output;
        this.outputOrder = -1;
                 
        this.input       = input;

        this.wire        = new Wire(this);
    }



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        const json = formatConnJson(
            pos, 
            tab,
            (this.stripIdForCopy ? this.output.node.nodeId : this.output.node.id),
            (this.output.param ? this.output.param.id : this.output.index),
            this.outputOrder,
            (this.stripIdForCopy ? this.input.node.nodeId : this.input.node.id),
            (this.input.param ? this.input.param.id : this.input.index),
            boolToString(arraysIntersect(this.output.types, LIST_TYPES))); // not supportsTypes() here, because that allows LIST in case of ANY_VALUE

        this.stripIdForCopy = false;

        return json;
    }



    toDataObject()
    {
        return {
            id:           this.id,
            outputNodeId: this.output.node.id,
            outputId:     this.output.id,
            outputOrder:  this.outputOrder,
            inputNodeId:  this.input.node.id,
            inputId:      this.input.id,
            list:         this.list
        };
    }
}



function parseConnectionJsonAndConnect(_conn, pasteConnected)
{
    const outputNode  = nodeFromId(pageIdFromPath(_conn.outputNodeId) == NULL ? makeNodePath(nodeFromId(_conn.outputNodeId)) : _conn.outputNodeId);
    const outputId    = _conn.outputId;
    const outputOrder = parseInt(_conn.outputOrder);

    const inputNode   = nodeFromId(pageIdFromPath(_conn.inputNodeId) == NULL ? makeNodePath(nodeFromId(_conn.inputNodeId)) : _conn.inputNodeId);
    const inputId     = _conn.inputId;


    if (   !outputNode 
        ||  isDigit(outputId[0]) && parseInt(outputId) >= outputNode.outputs.length
        || !isDigit(outputId[0]) && !outputNode.params.find(p => p.id == outputId && p.output)
        || !inputNode  
        ||  isDigit(inputId[0]) && parseInt(inputId) >= inputNode.inputs.length
        || !isDigit(inputId[0]) && !inputNode.params.find(p => p.id == inputId && p.input))
    {
        // console.log('outputNode  =', outputNode );
        // console.log('outputId    =', outputId   );
        // console.log('outputOrder =', outputOrder);
        // console.log('inputNode   =', inputNode  );
        // console.log('inputNode.inputs =', [...inputNode.inputs]);
        // console.log('inputId     =', inputId    );
        
        uiError(
           'Cannot connect ' + connToString(_conn),
            {
                buttonText:   'Remove connection',
                buttonAction: 'removeConnection,' + getStorageConnKey(_conn)
            });

        return null;
    }
    else
    {
        const conn = uiVariableConnect(
            outputNode, isDigit(outputId[0]) ? parseInt(outputId) : outputNode.params.find(p => p.id == outputId).output.id,
             inputNode, isDigit( inputId[0]) ? parseInt( inputId) :  inputNode.params.find(p => p.id ==  inputId). input.id,
            pasteConnected ? -1 : outputOrder);

        _conn.outputOrder = conn.outputOrder;

        return conn;
    }
}



function connDataObject(output, input)
{
    return {
        connection:   input.connection,
        id:           -1,
        outputNodeId: output.node.id,
        outputId:     output.id,
        outputOrder:  input.connection.outputOrder,
        inputNodeId:  input.node.id,
        inputId:      input.id
    };
}



function formatConnJson(pos, tab, outputNodeId, outputId, outputOrder, inputNodeId, inputId, list)
{
    return pos
         + '{'
         +       NL + pos + tab + '"outputNodeId": "' + outputNodeId + '"'
         + ',' + NL + pos + tab + '"outputId": "'     + outputId     + '"'
         + ',' + NL + pos + tab + '"outputOrder": "'  + outputOrder  + '"'
         + ',' + NL + pos + tab + '"inputNodeId": "'  + inputNodeId  + '"'
         + ',' + NL + pos + tab + '"inputId": "'      + inputId      + '"'
         + ',' + NL + pos + tab + '"list": "'         + list         + '"'
         +       NL + pos
         + '}';
}


class Wire
{
    connection;

    outputPos = point_NaN;
    inputPos  = point_NaN;


    clientX;
    clientY;


    elbowCircle0;
    elbowCircle1;
    elbowCircle2;
    elbowCircle3;

    midLine;


    svg;
    
    curve;
    curve2;
    
    xp1;
    xp2;

    outBall;
    inBall;

    arrow1;
    arrow2;


    // subdivision cache
    sp0        = null;
    sp1        = null;
    sp2        = null;
    sp3        = null;
    sArcLength = null;
   


    constructor(connection)
    {
        this.connection                  = connection;
      
        this.svg                         = createSvg('svg');
        this.svg.style.position          = 'absolute';
        this.svg.style.left              = 0;
        this.svg.style.top               = 0;
        this.svg.style.overflow          = 'hidden';
          
        this.curve                       = createSvg('path');
        this.curve.style.position        = 'absolute';
        this.curve.style.fill            = 'none';
      
        this.curve2                      = createSvg('path');
        this.curve2.style.position       = 'absolute';
        this.curve2.style.fill           = 'none';
      
        this.xp1                         = createSvg('path');
        this.xp1.style.position          = 'absolute';
        this.xp1.style.fill              = 'none';
          
        this.xp2                         = createSvg('path');
        this.xp2.style.position          = 'absolute';
        this.xp2.style.fill              = 'none';


        this.outBall                     = createSvg('circle');
        this.outBall.style.position      = 'absolute';
         
        this.inBall                      = createSvg('circle');
        this.inBall.style.position       = 'absolute';
         
        this.arrow1                      = createSvg('polygon');
        this.arrow1.style.position       = 'absolute';
     
        this.arrow2                      = createSvg('polygon');
        this.arrow2.style.position       = 'absolute';


        this.elbowCircle0                = createSvg('circle');
        this.elbowCircle0.style.position = 'absolute';

        this.elbowCircle1                = createSvg('circle');
        this.elbowCircle1.style.position = 'absolute';

        this.elbowCircle2                = createSvg('circle');
        this.elbowCircle2.style.position = 'absolute';

        this.elbowCircle3                = createSvg('circle');
        this.elbowCircle3.style.position = 'absolute';

        this.midLine                     = createSvg('line');
        this.midLine.style.position      = 'absolute';


        this.svg.appendChild(this.curve       );
        this.svg.appendChild(this.curve2      );
        this.svg.appendChild(this.xp1         );
        this.svg.appendChild(this.xp2         );
        this.svg.appendChild(this.arrow1      );
        this.svg.appendChild(this.arrow2      );
        this.svg.appendChild(this.outBall     );
        this.svg.appendChild(this.inBall      );
        // this.svg.appendChild(this.elbowCircle0);
        // this.svg.appendChild(this.elbowCircle1);
        // this.svg.appendChild(this.elbowCircle2);
        // this.svg.appendChild(this.elbowCircle3);
        // this.svg.appendChild(this.midLine     );
    }



    getColor()
    {
        const conn   = this.connection;

        const types  = [];

        const output = conn.output;
        const input  = conn.input;
        

        if (output)
        {
            if (!isEmpty(output.types)) types.push(...output.types);
            else if (output)            types.push(output.node.type);
        }
        else if (input)
        {
            if (   graphView.overOutput
                && input.canConnectFrom(graphView.overOutput)) 
                types.push(...graphView.overOutput.types);
            else
            {
                if (!isEmpty(input.types)) types.push(...input.types);
                else if (input)            types.push(input.node.type);
            }
        }


        if (output)
            return output.wireColor;

        else if (input)
            return input.wireColor;

        else if (!isEmpty(types))
            return rgb_a(rgbFromType(types[0], true));

        else 
            return rgbaInvalid;
    }



    update(x = 0, y = 0)
    {
        //logFunction('Wire.update()');
        
        this.clientX = x;
        this.clientY = y;
    
    
        const yOffset = getTopHeight() + 1;
    
        let pOut = point(0, 0),
            pIn  = point(0, 0);
    
    
        if (this.connection.output)
        {
            const ro = boundingRect(this.connection.output.div);
            pOut = point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset);
        }
        else
            pOut = point(x, y - yOffset);
    
    
        if (this.connection.input)
        {
            const ri = boundingRect(this.connection.input.div);
            pIn = point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset);
        }
        else
            pIn = point(x, y - yOffset);
    

        this.updateSvg(pOut.x, pOut.y, pIn.x, pIn.y);        
    }

    
    
    updateSvg(x1, y1, x2, y2)
    {
        this.updateCurve  (x1, y1, x2, y2);
        this.updateOutBall(x1, y1        );
        this.updateInBall (        x2, y2);
        this.updateStyle  ();


        this.svg.setAttribute('width',  graphView.div.clientWidth);
        this.svg.setAttribute('height', graphView.div.clientHeight);

        this.svg.style.zIndex = 1;
    }



    updateCurve(x1, y1, x2, y2)
    {
        if (!pointIsNaN(this.outputPos))
        {
            x1 = this.outputPos.x;
            y1 = this.outputPos.y;
        }
    
        if (!pointIsNaN(this.inputPos))
        {
            x2 = this.inputPos.x;
            y2 = this.inputPos.y;
        }
    
        
        const senseElbow0 = 100;
        const maxElbow0   = 40;
        const nd          = Math.min(Math.max(-1, (x2 - x1) / senseElbow0), 0);
        const diag        = 1 + Math.min((x2 - x1) / nozero(y2 - y1), 0.5);
        const r0          = Math.min(Math.max(Math.abs(nd), diag) * maxElbow0, Math.abs(y2 - y1) / 6);
        
        const mx = (x1 + x2)/2;
        const my = (y1 + y2)/2;

        //const 


        // this.elbowCircle0.setAttribute('cx',      x1);
        // this.elbowCircle0.setAttribute('cy',      y1 + (y1 < y2 ? r0 : -r0));
        // this.elbowCircle0.setAttribute('r',       r0);
        // this.elbowCircle0.setAttribute('fill',   'none');
        // this.elbowCircle0.setAttribute('stroke', '#FF6000');

        // this.elbowCircle3.setAttribute('cx',      x2);
        // this.elbowCircle3.setAttribute('cy',      y2 - (y1 < y2 ? r0 : -r0));
        // this.elbowCircle3.setAttribute('r',       r0);
        // this.elbowCircle3.setAttribute('fill',   'none');
        // this.elbowCircle3.setAttribute('stroke', '#FF6000');

        // this.midLine     .setAttribute('x1',      x1);
        // this.midLine     .setAttribute('y1',      y1);
        // this.midLine     .setAttribute('x2',      x2);
        // this.midLine     .setAttribute('y2',      y2);
        // this.midLine     .setAttribute('stroke', '#FF6000');


        const _x0 = x1;
        const _y0 = y1;
    
        const _x3 = x2;
        const _y3 = y2;
    
    
        const tx  = 600 * graph.currentPage.zoom;
        const ty  = 300 * graph.currentPage.zoom;
        const ecc = 100 * graph.currentPage.zoom;
    
        const yf  = (0.3 + Math.min(Math.abs(y2 - y1) / ty, 0.8));
    
        const df  = Math.pow((1 - Math.min(Math.abs(_x3 - _x0) / tx, 0.65)), 0.5)
                  * yf;
    
        const dx = 
              (_x3 - _x0) * df 
            * (_x3 < _x0 ? -1 : 1);
    
    
        let _x1 = Math.max(_x0 + ecc * Math.pow(0.1 + yf*0.9, 1.5), _x0 + dx);
        let _y1 = _y0;
    
        let _x2 = Math.min(_x3 - ecc * Math.pow(0.1 + yf*0.9, 1.5), _x3 - dx);
        let _y2 = _y3;
    
    
        if (   this.tempConn        == this.connection
            && this.tempConn.output == this.overOutput)
        {
            _x1 += (_x0 - _x1) * 5/8;
            _y1 += (_y0 - _y1) * 5/8;
        }
    
        if (   this.tempConn       == this.connection
            && this.tempConn.input == this.overInput)
        {
            _x2 += (_x3 - _x2) * 5/8;
            _y2 += (_y3 - _y2) * 5/8;
        }
    
        
        const points =
               'M ' + _x0 + ',' + _y0
            + ' C ' + _x1 + ',' + _y1
            + ' '   + _x2 + ',' + _y2
            + ' '   + _x3 + ',' + _y3;
    
        this.xp1   .setAttribute('d', points);
        this.xp2   .setAttribute('d', points);
        this.curve .setAttribute('d', points);
        this.curve2.setAttribute('d', points);
    
    
        this.updateArrows(
            _x0, _y0, 
            _x1, _y1, 
            _x2, _y2, 
            _x3, _y3);

        
        const fb = 
               this.connection.input
            && this.connection.input.feedback;

        const back = _x0 - _x3 > defNodeWidth * 1.5;

        const display1 = 
               fb 
            || this.connection.backInit
            ||    this.connection.input
               && this.connection.input.id == 'loop';

        const display2 = fb || back;

        this.arrow1.setAttribute('display', display1 ? 'inline' : 'none');
        this.arrow2.setAttribute('display', display2 ? 'inline' : 'none');
    }
    
    
    
    updateOutBall(x, y)
    {
        this.outBall.setAttribute('cx', x);
        this.outBall.setAttribute('cy', y);
    }
    
    
    
    updateInBall(x, y)
    {
        this.inBall.setAttribute('cx', x);
        this.inBall.setAttribute('cy', y);
    }
    
    
    
    updateArrows(x0, y0, x1, y1, x2, y2, x3, y3)
    {
        if (!pointIsNaN(this.outputPos))
        {
            x0 = this.outputPos.x;
            y0 = this.outputPos.y;
        }
    
        if (!pointIsNaN(this.inputPos))
        {
            x3 = this.inputPos.x;
            y3 = this.inputPos.y;
        }
    
    
        const p0 = point(x0, y0);
        const p1 = point(x1, y1);
        const p2 = point(x2, y2);
        const p3 = point(x3, y3); 
    
    
        const feedback = 
               this.connection.input
            && this.connection.input.feedback;

        const repeat =
               this.connection.input
            && this.connection.input.id == 'loop';


        let fb;

             if (feedback) fb = -25;
        else if (repeat  ) fb = -45;
        else               fb =  25;


        const back = x0 - x3 > defNodeWidth * 1.5;


        this.updateArrow(p0, p1, p2, p3, this.arrow1,  fb, 9, 0, feedback, back);
        this.updateArrow(p0, p1, p2, p3, this.arrow2, -35, 9, 1, feedback, back);
    }
    
    

    updateArrow(p0, p1, p2, p3, arrow, dist, size, index, feedback, back)
    {
        if (   !this.sp0 
            || !this.sp1 
            || !this.sp2 
            || !this.sp3
            || !equal(p1.x - p0.x, this.sp1.x - this.sp0.x, 0.005)
            || !equal(p2.x - p1.x, this.sp2.x - this.sp1.x, 0.005)
            || !equal(p3.x - p2.x, this.sp3.x - this.sp2.x, 0.005)
            || !equal(p1.y - p0.y, this.sp1.y - this.sp0.y, 0.005)
            || !equal(p2.y - p1.y, this.sp2.y - this.sp1.y, 0.005)
            || !equal(p3.y - p2.y, this.sp3.y - this.sp2.y, 0.005))
        {
            this.sArcLength = arcLength(p0, p1, p2, p3);

            this.sp0 = clone(p0);
            this.sp1 = clone(p1);
            this.sp2 = clone(p2);
            this.sp3 = clone(p3);
        }


        let al = 
            dist >= 0
            ? this.sArcLength - dist * graph.currentPage.zoom
            : -dist * graph.currentPage.zoom;
    
        if (al <= 0)
        {
            arrow.setAttribute('display', 'none');
            return;
        }
        
    
        let t = positionOnSegment(p0, p1, p2, p3, al);
        
        if (isNaN(t))
        {
            arrow.setAttribute('display', 'none');
            return;
        }
        

        if (  !back
            || feedback)
        {
            if (dist >= 0) t = Math.max(this.connection.backInit ? 0 : 0.5, t);
            else           t = Math.min(t, 0.5 - (index == 0 ? 0.15 : 0));
        }
        else
            t = 0.55;
           
    
        const pt = lerpv3(p0, p1, p2, p3, t);
    
        const tx = pt.x;
        const ty = pt.y;
    
        const tw = size * graph.currentPage.zoom;
        const th = size * graph.currentPage.zoom;
    
        const points =
                     (tx - tw/2) + ',' + (ty + th/2)
            + ' '  + (tx + tw/2) + ',' + (ty + th/2)
            + ' '  + (tx       ) + ',' + (ty - th/2);
    
        arrow.setAttribute('points', points);
        arrow.setAttribute('display', 'inline');
    
    
        const ct = bezierTangent(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, t);
    
        arrow.style.transformBox    = 'fill-box';
        arrow.style.transformOrigin = 'center';
        arrow.style.transform       = 'rotate(' + (angle(ct) - Tau/4 + (!back || feedback ? 0 : Tau/2)) + 'rad)';
    }




    updateStyle()
    {
        const conn  = this.connection;
        let   color = rgb_a(this.getColor());


        const l = rgb2hclok(color)[2];
        
        let bright = Math.min(Math.max(0, (l-0.6) / 0.4), 1);
        if (darkMode) bright = 1-bright;
    
        
        // const innerOpacity = Math.round(bright * (darkMode ? 88 : 66) * Math.min(graph.currentPage.zoom, 5)).toString(16).padStart(2, '0');
        //'+(Math.min(Math.max(1, 1/graph.currentPage.zoom), 5))+'
        
        // this.curve.style.filter = 
        //     this.needsFilter
        //     ? darkMode
        //         ? (isDark(color, 0.65)
        //             ?    'drop-shadow(0px 0px 1px #ffffff' + innerOpacity + ')'
        //             :   ' drop-shadow(0px 0px 1px #000000' + innerOpacity + ')')
        //         : (!isDark(color)
        //             ?    'drop-shadow(0px 0px 1px #000000' + innerOpacity + ')'
        //             :   ' drop-shadow(0px 0px 1px #ffffff' + innerOpacity + ')')
        //     : 'none';
    
         
        //let showCurve = true;
    

        if (   conn.output && color[3] < 1
            || conn. input && color[3] < 1)
        {
            // const showCurve = 
            //        conn.output && color[3] > 0
            //     || conn. input && color[3] > 0;
    
            this.xp1.style.display          = 'inline';
            this.xp1.style.stroke           = rgba2style(rgb_a(darkMode ? [0.067, 0.067, 0.067] : [0.784, 0.784, 0.784], 1 - color[3]));
            this.xp1.style.strokeDasharray  = 9 * Math.max(1, graph.currentPage.zoom);
    
            this.xp2.style.display          = 'inline';
            this.xp2.style.stroke           = rgba2style(rgb_a(darkMode ? [0.302, 0.302, 0.302] : [1, 1, 1], 1 - color[3]));//darkMode ? '#4d4d4d' : '#fff';
            this.xp2.style.strokeDasharray  = 9 * Math.max(1, graph.currentPage.zoom);
            this.xp2.style.strokeDashoffset = 9 * Math.max(1, graph.currentPage.zoom);
        }
        else
        {
            this.xp1.style.display = 'none';
            this.xp2.style.display = 'none';
        }
    
    
        if (darkMode)
        {
            const hcl = rgb2hclok(color);
    
            const th  = 0.27;
            let   dl  = 0.05;
    
            dl /= Math.min(1 - (1 - graph.currentPage.zoom) / 1.75, 1);
    
            if (hcl[2] > th - dl && hcl[2] <= th)
                color = invalid2validRgb(hclok2rgb([hcl[0], hcl[1], th - dl]));
            if (hcl[2] > th && hcl[2] < th + dl)
                color = invalid2validRgb(hclok2rgb([hcl[0], hcl[1], th + dl]));
        }
        else
        {
            const hcl = rgb2hclok(color);
    
            const th  = 0.96;
            let   dl  = 0.05;
    
            dl /= Math.min(1 - (1 - graph.currentPage.zoom) / 1.75, 1);
    
            if (hcl[2] > th - dl)// && hcl[2] >= th)
                color = invalid2validRgb(hclok2rgb([hcl[0], hcl[1], th - dl]));
            // if (hcl[2] > th && hcl[2] < th - dl)
            //     color = invalid2validRgb(hclok2rgb([hcl[0], hcl[1], th - dl]));
         }
    
    
        const wireStyle = rgba2style(color);

        const arrowStyle = rgba2style(
            rgbaLerp(
                darkMode 
                ? [0.5, 0.5, 0.5, 0.65] 
                : [0.5, 0.5, 0.5, 0.5 ], 
                color, 
                color[3]));

                
        // const isNotCached = 
        //            conn.output
        //        &&  conn.output.node
        //        && !conn.output.node.isCached()
        //     ||     conn.output
        //        &&  conn.output.param
        //        &&  conn.output.param._nodeId != undefined
        //     &&  nodeFromId(conn.output.param._nodeId)
        //        && !nodeFromId(conn.output.param._nodeId).isCached();
        
        // const unknown = 
        //         isNotCached
        //     &&  conn.output
        //     && (  !conn.output.node.isOrPrecededByMultiplier()
        //         ||   (   !conn.output.node.isMultiplier
        //               || !conn.output.node.paramLoop.input.connected)
        //            && conn.output.node.inputs.find(i => i.isConnectedUncached()))
        //     &&  conn.input
        //     &&  conn.input.node.isOrFollowedByMultiplier()
        //     && (  !conn.input.param 
        //         || conn.input.param.affectsHeader);


        const unknown = 
               conn.output 
            && (      conn.output.param
                   && conn.output.param.isNodeValue
                   && conn.output.param.node.isOrPrecededByUncached()
                ||     conn.output.param
                   && !conn.output.param.isNodeValue
                   &&  conn.output.param.input
                   &&  conn.output.param.input.isUncached()
                ||   !conn.output.param
                   && conn.output.node.isOrPrecededByUncached())
            && conn.input  
            && (      conn.input.param 
                   && conn.input.node.hasMultipliedOutputs()
                ||   !conn.input.param
                   && conn.input.node.isOrFollowedByMultiplier());

                
        this.curve .style.stroke = wireStyle;
        this.curve2.style.stroke = rgb2style(rgbDocumentBody);
    

        const dash = Math.max(1.5, 2.7 * graph.currentPage.zoom);

        this.curve.style.strokeDasharray = 
            unknown 
            ? dash + ' ' + dash 
            : '0';
    

        this. inBall.style.fill   = wireStyle;
        this.outBall.style.fill   = wireStyle;

        this.arrow1 .style.fill   = arrowStyle;
        this.arrow2 .style.fill   = arrowStyle;
    
    
        if (conn.output) conn.output.wireBall.style.background = wireStyle;
        if (conn. input) conn. input.wireBall.style.background = wireStyle;
    
    
        const listType = 
               conn.output
            && arraysIntersect(conn.output.types, LIST_TYPES);//supportsTypes(LIST_TYPES);

        // if (this.connection.input.node.nodeId == 'text')
        // {
        //     console.log('listType =', listType);
        //     console.log('conn.output.types =', conn.output.types);
        // }
    
    
        let width = 
            graph.currentPage.zoom < 1
            ? graph.currentPage.zoom + (Math.pow(2, graph.currentPage.zoom - 1) - graph.currentPage.zoom) * 0.333
            : graph.currentPage.zoom;
    
        width *= 1.6;
    
    
        //      if (graph.currentPage.zoom < 1/7) width += 1 * (1 - graph.currentPage.zoom) * (7 * graph.currentPage.zoom);
        // else if (graph.currentPage.zoom < 1  ) width += 1 * (1 - graph.currentPage.zoom);
    
    
        this.curve .setAttribute('stroke-width', width * (listType ? (unknown ? 3.6 : 3.2) : (unknown ? 1.3 : 1)));
        this.curve2.setAttribute('stroke-width', width * 1.4);

        this.xp1   .setAttribute('stroke-width', width * (listType ? (unknown ? 3.6 : 3.2) : (unknown ? 1.3 : 1)));
        this.xp2   .setAttribute('stroke-width', width * 1.4);
    
        this.curve2.setAttribute('display', listType ? 'inline' : 'none');
    
    
        this. inBall.style.r = 3 * graph.currentPage.zoom;
        this.outBall.style.r = 3 * graph.currentPage.zoom;
    }
    
    
    
    show(show, update = true)
    {
        // const isReordering =   
        //        isNaN(newReorderIndex)
        //     || isNaN(oldReorderIndex);
    
        showElement(this.svg, show);//(this != this.savedConn || isReordering));
        //showElement(this.curve,   show);//show && (this != this.savedConn || isReordering));
        //showElement(this.xp1,     show);//(this != this.savedConn || isReordering));
        //showElement(this.xp2,     show);//(this != this.savedConn || isReordering));
        //showElement(this.outBall, show);//(!this.tempConn || this.tempConn.output));
        //showElement(this. inBall, show);//(!this.tempConn || this.tempConn. input));
    
    
        if (update)
            this.update();
            // updateWire(wire);
    }
}


const connectionSize = 9;
const connectionGap  = 4;

const defHeaderHeight = 32;



class Operator
{
    subscription = false;


    #type; // used in the code, not for generation
    get type() { return this.#type; }
    

    id;

    get pageId() 
    { 
        return pageIdFromPath(this.id);
    }

    get nodeId() { return this.id.split('/').at(-1); }


    group = null; // to which the node belongs


    _name;
    get name()     { return this._name;  }
    set name(name) { this.setName(name); }


    defId;
    defName;


    icon;
    iconOffsetY = 0;

    
    enabled            = true;
    cached             = true;
    isMultiplier       = false;
    
    inert; // doesn't eval inputs if values exist
    slow;  // takes a while to finish operation, shows a progress bar

    renamed            = false;     


    inputs             = [];
    outputs            = [];
  
    params             = [];
    hiddenParams       = [];
  
      
    variableInputs     = false;

    alwaysLoadParams   = false;
    alwaysSaveParams   = false;

    alwaysShowIcon     = false;

    saveParams         = true;  // master switch to not save any params

    canDisable         = false;


    scrollName         = true;

    showActiveArrow    = false;

    highlight          = 0;

    layoutIndex        = -1;
    newX               = Number.NaN;

    sharpBottomCorners = false;

    stripIdForCopy     = false; // one-time flag
    
    allowEmptyName     = false;
    

    showHeaderTooltip  = false;
    preview            = null;


    defaultWidth;
    labelOffsetFactor;

    deselectTimer      = -1;


    _creatingButton    = null; // this is used to place the node under its creating button

    
    requestCache       = [];   // for nodes without an output


    // node UI

    div;
    inner;
    header;

    divIcon;
    divDisabled;
    
    progressWrapper    = null;
    progressBar        = null;
   
    hasProgressBar     = false;


    labelWrapper;
    label;
    labelText;
    textbox;
    inputControls;
    outputControls;

    paramHolder;

    subscribeCover;
    subscribeLabel;

    reorderArrows;
    showReorderArrows  = false;


    suffix = '';


    valid;

    
    measureData = { divBounds: new Rect(0, 0, 0, 0) };



    _selected;
    get selected() { return this._selected; }
    set selected(sel) 
    {
        if (this._selected)
            removeFromArray(graphView.selectedNodes, this);

        this.setSelected(sel);     

        if (this._selected)
            graphView.selectedNodes.push(this);
    }        



    _active = false;
    get active() { return this._active; }


    get headerConnected       () { return !isEmpty(this.headerInputs.filter(i => i.connected)); }

    get headerInputs          () { return this.inputs .filter(i => !i.param);                   }
    get headerOutputs         () { return this.outputs.filter(o => !o.param);                   }
   
    get connectedInputs       () { return this.inputs .filter(i => i.connected);                }
    get connectedOutputs      () { return this.outputs.filter(o => o.connected);                }

    get connectedHeaderInputs () { return this.inputs .filter(i => !i.param && i.connected);    }
    get connectedHeaderOutputs() { return this.outputs.filter(o => !o.param && o.connected);    }


    get connections() 
    { 
        const conns = [];

        conns.push(...this.connectedInputs.map(i => i.connection));

        for (const output of this.connectedOutputs)
            conns.push(...output.connectedInputs.map(i => i.connection));

        return conns;
    }

    

    constructor(type, id, name, icon, defWidth = defNodeWidth, progressBar = false)
    {
        this.#type             = type;

        this.id                = id;
        this.id                = makeNodePath(this);
        
        this.defId             = id;
        this.defName           = name;

        this.icon              = icon;

        this.defaultWidth      = defWidth;
        this.labelOffsetFactor = 0;

        this.inert             = false;
        this.slow              = false;

        this.valid             = false;


        this.createNode();


        if (progressBar)
            this.createProgressBar();

        createHeaderTooltip(this);


        this.setName(name);
    }    



    getInputId(input)
    {
        return input.param
             ? input.param.id
             : input.index.toString();
    }



    inputFromId(id)
    {
        return this.inputs.find(i => i.id == id);
    }



    addInput(input, assign = true)
    {
        if (assign)
            input._node = this;

        const index = this.headerInputs.length;

        this.inputs.splice(index, 0, input);
        this.inputControls.insertBefore(input.div, this.inputControls.children[index]);
    }



    removeInput(input)
    {
        input._node = null;

        removeFromArray(this.inputs, input);
        this.inputControls.removeChild(input.div);

        return input;
    }



    createInputForObjects(types, getValuesForUndo)
    {
        return new Input(types, getValuesForUndo);
    }



    getAutoInput(output)
    {
        const inputs = this.headerInputs.filter(i => 
               i.canAutoConnect
            && i.canConnectFrom(output));

        
        if (   graphView.overInput
            && inputs.includes(graphView.overInput))
            return graphView.overInput;


        if (   graphView.savedConn
            && graphView.savedConn.input
            && graphView.savedConn.input.node == this)
            return graphView.savedConn.input;
        
        else if (!graphView.tempConn.output.node.isOrFollows(this))
        {
            if (this.variableInputs)
                return inputs.filter(i => !i.param).at(-1);

            else if (!isEmpty(inputs))
            {
                for (const input of inputs)
                {
                    if (!input.connected)
                        return input;
                }

                // at this point no empty inputs were found, so connect to the first one
                return inputs[0];
            }
        }


        return null;
    }



    getOutputId(output)
    {
        return output.param
             ? output.param.id
             : output.index.toString();
    }



    outputFromId(id)
    {
        return this.outputs.find(o => o.id == id);
    }



    addOutput(output, assign = true)
    {
        if (assign)
            output._node = this;

        this.outputs.push(output);
        this.outputControls.appendChild(output.div);
    }



    removeOutput(output)
    {
        output._node = null;

        removeFromArray(this.outputs, output);
        this.outputControls.removeChild(output.div);

        return output;
    }



    getUncachedInputNodes()
    {
        const uncachedNodes = [];

        for (const input of this.inputs)
        {
            if (input.connected)
            {
                const node = input.connectedOutput.node;

                if (!node.cached) pushUnique(uncachedNodes, node);
                pushUnique(uncachedNodes, node.getUncachedInputNodes());
            }
        }
        
        return uncachedNodes;
    }
 
 
 
    getAutoOutput(inputTypes)
    {
        const outputs = this.headerOutputs.filter(o => 
               o.types.includes(ANY_VALUE)
            || arraysIntersect(o.types, inputTypes));

        return  outputs.length == 1
            && !this.isOrFollows(graphView.tempConn.input.node)
            ? outputs[0]
            : null;
    }



    addBaseParams()
    {

    }



    paramFromId(id)
    {
        return this.params.find(p => p.id == id);
    }



    addParam(param, volatile = false)
    {
        param._node    = this;
        param.volatile = volatile;

        this.params.push(param);
        this.paramHolder.appendChild(param.div);

        if (param. input) this. inputs.push(param. input);
        if (param.output) this.outputs.push(param.output);

        return param;
    }
 
    

    insertParam(index, param, volatile = false)
    {
        param._node    = this;
        param.volatile = volatile;

        this.params.splice(index, 0, param);
        this.paramHolder.insertBefore(param.div, this.paramHolder.children[index]);

        if (param. input) this. inputs.splice(index, 0, param. input);
        if (param.output) this.outputs.splice(index, 0, param.output);

        return param;
    }
 
    

    createAndAddParamByType(type, id, showName, hasInput, hasOutput, volatile = false)
    {
             if (type ==       NUMBER_VALUE) return this.addParam(new      NumberParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         TEXT_VALUE) return this.addParam(new        TextParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==        COLOR_VALUE) return this.addParam(new       ColorParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         FILL_VALUE) return this.addParam(new        FillParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   COLOR_STOP_VALUE) return this.addParam(new   ColorStopParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==     GRADIENT_VALUE) return this.addParam(new    GradientParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==       STROKE_VALUE) return this.addParam(new      StrokeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         LIST_VALUE) return this.addParam(new        ListParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==    RECTANGLE_VALUE) return this.addParam(new   RectangleParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         LINE_VALUE) return this.addParam(new        LineParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      ELLIPSE_VALUE) return this.addParam(new     EllipseParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      TRAPEZE_VALUE) return this.addParam(new     TrapezeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      POLYGON_VALUE) return this.addParam(new     PolygonParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         STAR_VALUE) return this.addParam(new        StarParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   TEXT_SHAPE_VALUE) return this.addParam(new   TextShapeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==        POINT_VALUE) return this.addParam(new       PointParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==  VECTOR_PATH_VALUE) return this.addParam(new  VectorPathParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==  DROP_SHADOW_VALUE) return this.addParam(new  DropShadowParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type == INNER_SHADOW_VALUE) return this.addParam(new InnerShadowParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   LAYER_BLUR_VALUE) return this.addParam(new   LayerBlurParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==    BACK_BLUR_VALUE) return this.addParam(new    BackBlurParam(id, id, showName, hasInput, hasOutput), volatile);

        else consoleError('cannot add parameter of type \'' + type + '\'');

        return null;
    }



    createAndInsertParamByType(index, type, id, showName, hasInput, hasOutput, volatile = false)
    {
             if (type ==       NUMBER_VALUE) return this.insertParam(index, new      NumberParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         TEXT_VALUE) return this.insertParam(index, new        TextParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==        COLOR_VALUE) return this.insertParam(index, new       ColorParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         FILL_VALUE) return this.insertParam(index, new        FillParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   COLOR_STOP_VALUE) return this.insertParam(index, new   ColorStopParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==     GRADIENT_VALUE) return this.insertParam(index, new    GradientParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==       STROKE_VALUE) return this.insertParam(index, new      StrokeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         LIST_VALUE) return this.insertParam(index, new        ListParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==    RECTANGLE_VALUE) return this.insertParam(index, new   RectangleParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         LINE_VALUE) return this.insertParam(index, new        LineParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      ELLIPSE_VALUE) return this.insertParam(index, new     EllipseParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      TRAPEZE_VALUE) return this.insertParam(index, new     TrapezeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      POLYGON_VALUE) return this.insertParam(index, new     PolygonParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==         STAR_VALUE) return this.insertParam(index, new        StarParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   TEXT_SHAPE_VALUE) return this.insertParam(index, new   TextShapeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==        POINT_VALUE) return this.insertParam(index, new       PointParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==  VECTOR_PATH_VALUE) return this.insertParam(index, new  VectorPathParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==  DROP_SHADOW_VALUE) return this.insertParam(index, new  DropShadowParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type == INNER_SHADOW_VALUE) return this.insertParam(index, new InnerShadowParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   LAYER_BLUR_VALUE) return this.insertParam(index, new   LayerBlurParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==    BACK_BLUR_VALUE) return this.insertParam(index, new    BackBlurParam(id, id, showName, hasInput, hasOutput), volatile);

        else consoleError('cannot insert parameter of type \'' + type + '\'');

        return null;
    }



    removeParam(param)
    {
        if (param.input)
        {
            if (param.input.connected)
                uiDisconnect(param.input);

            param.input._node = null;
            removeFromArray(this.inputs, param.input);
        }

        if (param.output)
        {
            for (const input of param.output.connectedInputs)
                uiDisconnect(input);

            param.output._node = null;
            removeFromArray(this.outputs, param.output);
        }


        if (this.paramHolder.contains(param.div))
            this.paramHolder.removeChild(param.div);
    
        removeFromArray(this.params, param);

        param._node = null;
    }



    getAllParamConnections()
    {
        const conns = [];

        for (let i = 0; i < this.params.length; i++)
        {
            const param = this.params[i];

            if (   param.input 
                && param.input.connected)
                conns.push(param.input.connection.toDataObject());

            if (param.output)
            {
                for (const input of param.output.connectedInputs)
                    conns.push(input.connection.toDataObject());
            }
        }

        return conns;
    }



    disconnectAllParams(deleteSavedConnections = false)
    {
        for (let i = this.params.length-1; i >= 0; i--)
        {
            const param = this.params[i];

            if (param.input && param.input.connected)
            {
                if (deleteSavedConnections)
                    uiDeleteSavedConn(param.input.connection);

                uiDisconnect(param.input);
            }

            if (param.output)
            {
                for (const input of param.output.connectedInputs)
                {
                    if (deleteSavedConnections)
                        uiDeleteSavedConn(input.connection);

                    uiDisconnect(input);
                }
            }
        }
    }



    removeAllParams()
    {
        for (let i = this.params.length-1; i >= 0; i--)
            this.removeParam(this.params[i]);
    }



    disconnectParamsNotInList(list, deleteSavedConnections = false)
    {
        for (let i = this.params.length-1; i >= 0; i--)
        {
            if (list.includes(this.params[i].id))
                continue;


            const param = this.params[i];

            if (param.input && param.input.connected)
            {
                if (deleteSavedConnections)
                    uiDeleteSavedConn(param.input.connection);

                uiDisconnect(param.input);
            }


            if (param.output)
            {
                for (const input of param.output.connectedInputs)
                {
                    if (deleteSavedConnections)
                        uiDeleteSavedConn(input.connection);

                    uiDisconnect(input);
                }
            }
        }
    }



    removeParamsNotInList(list)
    {
        for (let i = this.params.length-1; i >= 0; i--)
            if (!list.includes(this.params[i].id))
                this.removeParam(this.params[i]);
    }



    updateParamDisplay() // must be called at the end of each final Op constructor
    {
        for (const param of this.params)
            param.div.style.display = param.canShow() ? 'inline-block' : 'none';
    }



    getTabParams()
    {
        return this.params.filter(p => p.canShow());
    }



    setSelected(sel)
    {
        this._selected = sel;

        this.updateBorder();

        //if (deleteConnectionsDialogVisible)
        //if (minZoomDialogVisible)
        //    hideMinZoomDialog();
    }
    


    makeActive()
    {
        this._active = true;

        if (    graphView
            &&  graphView.activeNodes
            && !graphView.activeNodes.includes(this))
            graphView.activeNodes.push(this);
    }



    makePassive()
    {
        if (!this._active) 
            return;
            
        if (graphView.activeNodes.includes(this))
            removeFromArray(graphView.activeNodes, this);

        this._active = false;
    }



    setName(newName, options = {})
    {
        this._name = newName;

        this.updateMeasureData();
        this.updateHeaderLabelOffsetX();

        return true;
    }



    setPosition(x, y, updateTransform = true)
    {
        //console.log('Operator.setPosition()');
   
        this.div.style.left = x + 'px';
        this.div.style.top  = y + 'px';

        if (updateTransform)
        {
            this.div.style.display = 'block';
            this.updateTransform();
        }

        this.updateMeasureData();
    }



    // setSize(w, h, updateTransform = true)
    // {
    //     this.div.style.width  = w + 'px';
    //     this.div.style.height = h + 'px';

    //     if (updateTransform)
    //     {
    //         this.div.style.display = 'block';
    //         this.updateTransform();
    //     }
    // }



    setRect(x, y, w, h, updateTransform = true)
    {
        this.div.style.left   = x + 'px';
        this.div.style.top    = y + 'px';
        this.div.style.width  = w + 'px';
        this.div.style.height = h + 'px';

        if (updateTransform)
        {
            this.div.style.display = 'block';
            this.updateTransform();
        }
    }



    setHeight(h, updateTransform = true)
    {
        this.div.style.height = h + 'px';

        if (updateTransform)
        {
            this.div.style.display = 'block';
            this.updateTransform();
        }
    }



    showParamMenu(e, param, menu)
    {
        if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            param.controls[0].buttonDown2 = true;

            menu.showAt(e.clientX, e.clientY, false);
        }
    }



    canAutoConnectFrom(output)
    {
        return false;
    }



    isCached()
    {
        for (const input of this.inputs)
        {
            if (    input.connected
                && !input.connectedOutput.node.isCached())
                return false;
        }

        return this.cached;
    }



    // isUncached()
    // {
    //     return this.inputs.find(i => i.isUncached());
    // }



    isConnectedTo(node)
    {
        return this. inputs.find(i => i.connected && i.connectedOutput.node == node)
            || this.outputs.find(o => o.connected && o.connectedInputs.find(i => i.node == node));
    }



    isParallelTo(node)
    {
        return !this.follows(node)
            && !node.follows(this);
    }



    follows(node) 
    { 
        return this.isOrFollows(node, false); 
    }



    isOrFollows(node, considerIs = true)
    {
        if (   this == node
            && considerIs)
            return true;

        for (const input of this.inputs)
        {
            if (   input.connected
                && input.connectedOutput.node.isOrFollows(node))
                return true;
        }

        return false;
    }



    immediatelyFollows(node, headerOnly = false)
    {
        const inputs = 
            headerOnly 
            ? this.headerInputs 
            : this.inputs;

        for (const input of inputs)
        {
            if (   input.connected
                && input.connectedOutput.node == node)
                return true;
        }

        return false;
    }



    isOrPrecededByUncached()
    {
        return !this.cached
             ? true
             : this.hasUncachedInputs();
    }



    isOrFollowedByMultiplier()
    {
        return this.isMultiplier
             ? true
             : this.hasMultipliedOutputs();
    }



    hasUncachedInputs()
    {
        for (const input of this.inputs)
            if (input.isUncached())
                return true;

        return false;
    }



    hasMultipliedOutputs()
    {
        for (const output of this.outputs)
            for (const input of output.connectedInputs)
                if (input.node.isOrFollowedByMultiplier())
                    return true;
            // if (output.isMultiplied())
            //     return true;

        return false;
    }



    isUnknown()
    {
        return this.hasUncachedInputs()
            && this.hasMultipliedOutputs();
    }



    paramCanBeUnknown(param)
    {
        return false;
    }



    paramIsConsideredDefault(param) // this has to be an op virtual method, not a param method
    {
        return param.isDefault()
            && (   !param.input 
                || !param.input.connected);
    }



    restoreParamUndoValue(value)
    {
        const param = this.params.find(p => p.id == value.paramId);

        if (value.type == NUMBER_VALUE)
        {
            param.controls[0].setMin(value.displayMin, value.min);
            param.controls[0].setMax(value.displayMax, value.max);
        }
            
        param.setValue(value.value, true, true, false);
    }
    
    

    setAllParamDividers(divider)
    {
        for (const param of this.params)
            if (param instanceof NumberParamBase)
                param.divider = divider;
    }



    reset() // for the entire generation run
    {
        for (const input of this.inputs)
        {
            input.currentSeed = input.initialSeed;
            
            if (input.connected)
                input.connectedOutput.node.reset();
        }
    }



    invalidate()
    {
        this.valid        = false;
        this.requestCache = [];

        for (const output of this.outputs)
        {
            output.cache = [];
            
            for (const input of output.connectedInputs)
                input.node.invalidate();
        }
    }



    genRequest(gen)
    {
        // this function exists because a node without outputs
        // should still be able to generate a request
        
        return [];
    }



    genRequestStart(gen, nodeOptions = 0)
    {
        const request = [
            this.type, 
            this.id,
            this.name ];


        const ignore = gen.passedNodes.includes(this);

        if (!ignore)
        {
            const nextActive   = getActiveAfterNode(this, true);
            const beforeActive = nextActive && nextActive.follows(this);

            const options =
                  ((this.active      ? 1 : 0) << 0)
                | ((beforeActive     ? 1 : 0) << 1)
                | ((this.enabled     ? 1 : 0) << 2)
                | ((this.cached      ? 1 : 0) << 3)
                | ((this.isUnknown() ? 1 : 0) << 4)
                | nodeOptions;

            request.push(options);
        }


        return [request, ignore];
    }



    setTransform(nodeLeft, nodeTop, nodeRect)
    {
        this.div.style.transform =
              'translate(' 
            +     (graph.currentPage.pan.x * graph.currentPage.zoom) + 'px, '
            +     (graph.currentPage.pan.y * graph.currentPage.zoom) + 'px) '
            + 'scale(' + graph.currentPage.zoom + ')';

        this.div.style.transformOrigin = 
              ((graph.currentPage.pan.x - nodeLeft) / nodeRect.width  * 100) + '% ' 
            + ((graph.currentPage.pan.y - nodeTop ) / nodeRect.height * 100) + '%';  
    }



    getOffsetRect()
    {
        const ox   = -graph.currentPage.pan.x / graph.currentPage.zoom;
        const oy   = -graph.currentPage.pan.y / graph.currentPage.zoom;

        const rect = boundingRect(this.div);

        return new DOMRect(
            ox + (rect.left / graph.currentPage.zoom),
            oy + (rect.top  / graph.currentPage.zoom),
            rect.width      / graph.currentPage.zoom, 
            rect.height     / graph.currentPage.zoom);
    }



    getHeaderColors(options = {})
    {
        const rgbaBack = 
            this.inert
            ? rgb_a(rgbDocumentBody, 0.95)
            : rgb_a(rgbFromType(this.type, this.active), 0.95);

            
        const rgbaBorder = rgb_a(rgbFromType(this.type, this.active), 0.95);

        const rgbaText   = isDark(rgbaBack) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const colInput   = this.active ? rgb_a(rgbaText, 0.4 ) : rgb_a(rgbSaturateHsv(rgbFromType(this.type, true), 0.5), 0.8);
        const colOutput  = this.active ? rgb_a(rgbaText, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(this.type, true), 0.5), 0.7);
        
        const colWire    = rgbFromType(this.type, true);

        
        return {
            back:   rgbaBack, 
            border: rgbaBorder,
            text:   rgbaText,
            input:  colInput,
            output: colOutput,
            wire:   colWire };
    }



    getActiveOffset()
    {
        return 4;
    }



    getDefaultOffset()
    {
        return 0;
    }



    connectToSelected(selected)
    {
        consoleAssert(!isEmpty(selected));

        const node   = selected[0];
        const inputs = this.inputs.filter(i => i.types.includes(node.type));
    
        if (   node
            && !isEmpty(node.outputs)
            && !isEmpty(inputs))
            actionManager.do(new ConnectAction(node.outputs[0], inputs[0]), true);
    }



    updateConnectedInputValueText() {}



    toJson(nTab = 0) 
    {
        let pos = ' '.repeat(nTab);
        

        let json = 
              pos + '{\n'
            + this.toJsonBase(nTab);

        const nonDefaultParams = this.params.filter(p => !this.paramIsConsideredDefault(p));

        if (    (  !isEmpty(nonDefaultParams) // don't include empty param section
                 || this.alwaysSaveParams)
             && this.saveParams)
            json += this.paramsToJson(nTab);

        json += '\n' + pos + '}';


        return json;
    }



    toJsonBase(nTab)
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let json =
              pos + tab + '"type": "'      + this.type                                     + '",\n'
            + pos + tab + '"id": "'        + (this.stripIdForCopy ? this.nodeId : this.id) + '",\n'
            + pos + tab + '"name": "'      + this.name.replace('"', '\\\"')                + '",\n'
            + pos + tab + '"renamed": "'   + boolToString(this.renamed)                    + '",\n'
            + pos + tab + '"enabled": "'   + boolToString(this.enabled)                    + '",\n'
            + pos + tab + '"highlight": "' + this.highlight                                + '",\n'
            + pos + tab + '"x": "'         + parseFloat(this.div.style.left)               + '",\n'
            + pos + tab + '"y": "'         + parseFloat(this.div.style.top )               + '",\n'
            + pos + tab + '"z": "'         + graph.nodes.indexOf(this)                     + '"';

        if (this.active)
            json += ',\n' + pos + tab + '"active": "' + this.active + '"';

        this.stripIdForCopy = false;

        return json;
    }



    paramsToJson(nTab = 0)
    {
        //console.log(this.nodeId + '.paramsToJson()');

        let   pos = ' '.repeat(nTab);
        const tab = HTAB;


        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
        
            
        let first = true;
        for (const param of this.params)
        {
            if (  !param.isDefault()
                || this.alwaysSaveParams)
            {
                if (!first) json += ',\n'; first = false;
                json += pos + tab + tab + param.toJson(nTab);
            }
        }


        if (!first)
            json += '\n';

        json += pos + tab + ']';

        
        return json;
    }



    loadFromParsedJson(_node, pasting)
    {
        this.id   = _node.id;
        this.name = _node.name;
    
        if (_node.renamed  ) this.renamed   = parseBool(_node.renamed);
        if (_node.enabled  ) this.enabled   = parseBool(_node.enabled);
        if (_node.highlight) this.highlight = parseInt(_node.highlight);
    
        if (   _node.params
            || this.alwaysLoadParams)
            this.loadParams(_node, pasting);
    }



    loadParams(_node, pasting)
    {
        if (!_node.params)
            return;
     
        for (const _param of _node.params)
        {
            let index = this.params.findIndex(p => p.id == _param[1]);

            if (index < 0)
            {
                this.createAndAddParamByType(_param[0], _param[1], true, false, true, true);
                index = this.params.length-1;
            }

            this.params[index].loadParam(_param);
        }
    }



    toString() 
    { 
        // create the generator string here

        return '';
    }



    toJavascript(gen)
    {
        return '';
    }



    toJsDefs(gen)
    {
        return '';
    }



    toJsCode(gen)
    {
        return '';
    }
}



function getHeaderConnY(conns)//, padding, offset)
{
    const y      = [];
    let   height = 0;
    
    for (let i = 0; i < conns.length; i++)
    {
        if (i > 0) height += connectionGap;
        y.push(/*offset + padding*/ + height);
        height += connectionSize;
    }

    return [y, height];
}



function createGenObject(paramNode, terminals)
{
    return {
        terminals:    terminals,
        scope:        paramNode ? [{nodeId: paramNode.id, paramId: NULL}] : [],
        passedNodes:  [],
        paramNodes:   [],
        markParams:   true
    };    
}



function areConnected(node1, node2)
{
    return node1.isOrFollows(node2)
        || node2.isOrFollows(node1);
}



function onVariableConnectInput(input)
{
    input.node.addNewInput();
}



function onVariableDisconnectInput(input)
{
    removeFromArray(input.node.inputs, input);

    input.node.inputControls.removeChild(input.div);
}



function onVariableListConnectInput(input)
{
    onVariableConnectInput(input);
    updateOutputListTypeFromConnectedInputs(input.node);
}



function onVariableListDisconnectInput(input)
{
    onVariableDisconnectInput(input);
    updateOutputListTypeFromConnectedInputs(input.node);
}




function updateOutputListTypeFromConnectedInputs(node)
{
    const types = [];

    for (const input of node.connectedInputs)
        pushUnique(types, input.connectedOutput.types);

    node.outputs[0].types = [finalListTypeFromTypes(types)];
}



function getNodeInputValuesForUndo(input)
{
    const values = []; 

    for (const param of input.node.params)
        values.push(param.getValueForUndo());

    return values;
}



function getNodeOutputValuesForUndo(output)
{
    const values = []; 

    for (const param of output.node.params)
        values.push(param.getValueForUndo());

    return values;
}



function getParamInputValuesForUndo(input)
{
    return [input.param.getValueForUndo()];
}



function getParamOutputValuesForUndo(output)
{
    return [output.param.getValueForUndo()];
}



function nodesAreParallel(nodes)
{
    for (let i = 0; i < nodes.length-1; i++)
        for (let j = i + 1; j < nodes.length; j++)
            if (!nodes[i].isParallelTo(nodes[j]))
                return false;

    return true;
}



// function restoreNodeUndoValues(node, values)
// {
//     for (const value of values)
//     {
//         const param = node.params.find(p => p.id == value.paramId);

//         if (param)
//         {
//             if (   value.min != undefined
//                 && value.max != undefined)
//             {
//                 param.controls[0].setMin(value.min);
//                 param.controls[0].setMax(value.max);
//             }
                
//             param.setValue(value.value, true, true, false);
//         }
//     }
// }



function makeNodePath(node)
{
    let path = idFromNodePath(node.id);

    let group = node;
    //console.log('group =', group);
    //console.log('group.group =', group.group);
    while (isValid(group = group.group))
        path = group.id + '/' + path;

    if (graph.currentPage.id != NULL)
        path = graph.currentPage.id + '/' + path;

    return path;
}



function idFromNodePath(path)
{
    return path.split('/').at(-1);
}



function createHeaderTooltip(node)
{
    createTooltipSrc(node.header, node.header, () => ttText, () => node.showHeaderTooltip);


    node.header.addEventListener('pointerenter', e =>
    {
        if (  !currentTooltip
            && node.preview)
        {
            let strTooltip = 
                node.isUnknown()
                ? NAN_DISPLAY
                : node.preview.toPreviewString();

            if (   node.showHeaderTooltip === true
                && strTooltip != '')
                initTextTooltip(strTooltip);
        }
    });


    node.header.addEventListener('pointerdown', () =>
    {
        if (tooltipTimer)
            clearTimeout(tooltipTimer);

        if (currentTooltip) 
            hideTooltip(currentTooltip);
    });
}


var  newReorderIndex = Number.NaN;
var prevReorderIndex = Number.NaN;
var  oldReorderIndex = Number.NaN;

var nodesAltCopied   = false;



Operator.prototype.createNode = function()
{
    this.div                    = createDiv('node');
    this.div.node               = this;
       
    this.div.style.width        = this.defaultWidth + 'px';
           
    this.div.over               = false;
    this.div.dragging           = false;
    this.div.shiftOnPointerDown = false;
    this.div.moved              = false;
    
    this.enterTimer             = null;


    this.inner = createDiv('nodeInner');
    this.div.appendChild(this.inner);



    this.div.addEventListener('pointerenter', e =>
    {
        this.div.over      = true;
        graphView.overNode = this;
        
        if (   graphView.soloMode
            && graphView._soloNode != this
            && this.type != PANEL) 
            graphView.soloNode(this);
        
        this.updateNode();
    });

    

    this.div.addEventListener('pointerleave', e =>
    {
        this.div.over      = false;
        graphView.overNode = null;
        
        // if (graphView._soloNode == this)
        //     graphView.unsoloNode();

        this.updateNode();
    });

    
    
    this.paramHolder = createDiv('nodeParamBack');


    this.createHeader();
    this.createInfo();


    this.inner.appendChild(this.paramHolder);


    this.subscribeCover = createDiv('subscribeCover');

    this.subscribeCover.addEventListener('pointerenter', e => { e.preventDefault(); e.stopImmediatePropagation(); });
    this.subscribeCover.addEventListener('pointermove',  e => { e.preventDefault(); e.stopImmediatePropagation(); });
    this.subscribeCover.addEventListener('pointermove',  e => { e.preventDefault(); e.stopImmediatePropagation(); });

    this.subscribeLabel = createDiv('subscribeLabel');
    this.subscribeLabel.innerHTML = 'SUBSCRIBE';

    this.div.appendChild(this.subscribeCover);
    this.div.appendChild(this.subscribeLabel);
}     



Operator.prototype.createHeader = function()
{
    this.header = createDiv('nodeHeader');
    
    this.header.connectionPadding = 8;


    this.createLabel();
    this.initLabelTextbox();

    
    this. inputControls = createDiv('inputControls' );
    this.outputControls = createDiv('outputControls');
    this.reorderArrows  = createDiv('reorderArrows' );

    this.header.appendChild(this. inputControls);
    this.header.appendChild(this.outputControls);
    this.header.appendChild(this. reorderArrows);

    
    this.inner.appendChild(this.header);



    this.header.addEventListener('pointerdown', e =>
    {
        if (graphView.isPanning(e))
            return;


        window.focus();


        e.preventDefault();


        // I don't want to focus here, but I do want to take focus away from elsewhere
        document.activeElement.blur();


        graphView.lastSelectedNodes = [...graphView.selectedNodes];
        
        graphView.putNodeOnTop(this);


        for (const param of this.params)
        {
            if (param.textboxHasFocus())
                param.controls[0].textbox.finish(true);
        }


        if (e.button == 0)
        {
            hideAllMenus();
            window.getSelection().removeAllRanges();
        }


        if (   e.button == 0
            || e.button == 2)
        {
            this.div.shiftOnPointerDown = 
                    e.shiftKey
                && !getCtrlKey(e)
                && !e.altKey;
        }


        if (    e.button == 0
            && !graphView.overOutput
            && !graphView.overInput)
        {
            e.stopPropagation();

            graphView.selectFromClick(this, getCtrlKey(e), e.shiftKey, e.altKey);
                        

            try
            {
                this.header.setPointerCapture(e.pointerId);

                this.sx = e.clientX;
                this.sy = e.clientY;

                for (const n of graphView.selectedNodes)
                {
                    n.slx = n.div.offsetLeft;
                    n.sly = n.div.offsetTop;
                }


                nodesAltCopied = false;

                this.div.dragging = true;
            }
            catch {}
        }

        else if (e.button == 2)
        {
            e.stopPropagation();

            graphView.selectFromClick(this, getCtrlKey(e), e.shiftKey, e.altKey);

            menuNode.showAt(e.clientX, e.clientY, false);
        }

        
        updateGraphNodes();
    });



    this.header.addEventListener('pointermove', e =>
    {
        if (graphView.isPanning(e))
            return;


        const headerRect = boundingRect(this.header);

        const rightOfInputs = e.clientX - headerRect.x > 12 * graph.currentPage.zoom;
        const leftOfOutputs = e.clientX - headerRect.x < headerRect.width - 12 * graph.currentPage.zoom;

        const tempConn  = graphView. tempConn;
        let   savedConn = graphView.savedConn;


        if (this.div.dragging)
        {
            const x       = graphView.div.clientLeft;
            const w       = graphView.div.clientWidth;
            const h       = graphView.div.clientHeight;
            const bounds  = graphView.getAllNodeBounds();

            const yOffset = getTopHeight();


            if (altPressedInMenu)
                nodesAltCopied = true;
                
            if (   !nodesAltCopied
                &&  e.altKey
                && !e.shiftKey)
                altCopyNodes(this, e);


            graphView.setNodePositions(
                graphView.selectedNodes,
                (e.clientX - this.sx) / graph.currentPage.zoom,
                (e.clientY - this.sy) / graph.currentPage.zoom);
            
            this.div.moved = true;

            graphView.updateScroll(x, w, h, bounds, yOffset);
        }
        else if (   tempConn
                 && rightOfInputs
                 && leftOfOutputs)
        {
            if (    tempConn.output
                && !tempConn.output.node.isOrFollows(this))
            {
                if (   this.variableInputs
                    && savedConn
                    && this == savedConn.input.node)
                {
                    const rect    = boundingRect(this.div);
                    const padding = this.header.connectionPadding;


                    const index = Math.min(Math.max(0, Math.round(
                          ((e.clientY - rect.y) / graph.currentPage.zoom - padding - (connectionSize + connectionGap)/2) 
                        / (connectionSize + connectionGap))),
                        this.headerInputs.length-(this.headerInputs.length > 1 ? 2 : 1));

                    if (index != prevReorderIndex)
                    {
                        newReorderIndex = index;

                        moveInArray(
                            this.inputs, 
                            this.inputs.indexOf(savedConn.input),
                            newReorderIndex);

                        this.updateNode();
                         
                        prevReorderIndex = newReorderIndex;
                    }

                    
                    graphView.overInput   = savedConn.input;
                    graphView.headerInput = savedConn.input;

                    graphView.overInput.updateControl();

                    
                    const inputRect = boundingRect(savedConn.input.div);

                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - getTopHeight());
                }
                else
                {
                    const input = this.getAutoInput(tempConn.output);
                    if (!input) return;

                    graphView.overInput   = input;
                    graphView.headerInput = input;
                    //console.log('headerInput = ', graphView.headerInput);
                        
                    input.mouseOver = true;
                    input.updateControl();

                    const inputRect = boundingRect(input.div);
                    
                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - getTopHeight());
                }
            }
            else if ( tempConn.input
                  && !this.isOrFollows(tempConn.input.node))
            {
                const output = this.getAutoOutput(tempConn.input.types);
                if (!output) return;

                graphView.overOutput   = output;
                graphView.headerOutput = output;
                //console.log('headerOutput = ', graphView.headerOutput);
                    
                output.mouseOver = true;
                output.updateControl();


                const rect = boundingRect(output.div);

                tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());


                tempConn.input.updateControl();
            }
        }
    });



    this.header.addEventListener('pointerup', e =>
    {
        if (graphView.isPanning(e))
            return;


        if (   e.button == 0
            && this.div.dragging)
        {
            if (this.div.moved)
            {
                actionManager.do(new SelectMoveNodesAction(
                    graphView.lastSelectedNodes.map(n => n.id), 
                    graphView.selectedNodes.map(n => n.id), 
                    point(this.slx, this.sly),
                    point(this.div.offsetLeft, this.div.offsetTop),
                    this.div.shiftOnPointerDown));
            }
            else if (!arraysAreEqual(graphView.selectedNodes, graphView.lastSelectedNodes))
            {
                actionManager.do(new SelectNodesAction(
                    graphView.selectedNodes    .map(n => n.id), 
                    graphView.lastSelectedNodes.map(n => n.id)));
            }

            this.div.dragging = false;
            this.header.releasePointerCapture(e.pointerId);
        }

        else if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(this)
                &&  graphView.overInput)
            {
                const overInput = graphView.overInput;

                graphView          .endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overInput.endConnection();

                if (!graphView.headerInput)
                    graphView.overInput = overInput; // to be able to use the input again immediately
            }
            else if ( graphView.tempConn.input
                  && !this.isOrFollows(graphView.tempConn.input.node)
                  &&  graphView.overOutput)
            {
                const overOutput = graphView.overOutput;

                graphView           .endConnection(e.pointerId, getCtrlKey(e), e.shiftKey);
                graphView.overOutput.endConnection();

                if (!graphView.headerOutput)
                    graphView.overOutput = overOutput; // to be able to use the output again immediately
            }
        }


        this.div.shiftOnPointerDown = false;
    });
    
    

    this.header.addEventListener('pointerleave', e => 
    { 
        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != this)
            {
                const input = graphView.headerInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
                graphView.tempConn.output.updateControl();
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node !=  this)
            {
                const output = graphView.headerOutput;
                
                graphView.overOutput   = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }

           graphView.headerInput  = null;
           graphView.headerOutput = null;
        }
    });



    this.header.addEventListener('dblclick', e =>
    {
        e.stopPropagation();


        if (this.type == PANEL)
            return;

            
        if (getCtrlKey(e))
            this.showLabelTextbox();

        else
        {
            actionManager.do(new MakeActiveNodesAction([this.id], e.shiftKey));
            
            if (this.deselectTimer > -1)
            {
                clearTimeout(this.deselectTimer);
                this.deselectTimer = -1;
            }
        }
    });



    this.labelText.addEventListener('pointerdown', e =>
    {
        if (this.labelText.clickTimer >= 0)
            e.stopPropagation();

        this.labelText.clickTimer = setTimeout(
            () => this.labelText.clickTimer = -1, 
            300);
    });



    // this.labelText.addEventListener('dblclick', e =>
    // {
    //     e.stopPropagation();
    //     this.showLabelTextbox();
    // });
};



Operator.prototype.createInfo = function()
{
    this.divDisabled = createDiv();
    this.div.appendChild(this.divDisabled);

    this.divDisabled.style.display       = 'none';
    this.divDisabled.style.position      = 'absolute';
    this.divDisabled.style.width         =  5;
    this.divDisabled.style.height        =  100;
    this.divDisabled.style.background    = '#e88b';
    this.divDisabled.style.pointerEvents = 'none';
    //this.divDisabled.style.zIndex        = 100;
};



Operator.prototype.createProgressBar = function()
{
    this.hasProgressBar  = true;

    this.progressWrapper = createDiv('progressWrapper');
    this.progressBar     = createDiv('progressBar');

    this.progressWrapper.appendChild(this.progressBar);
    this.header         .appendChild(this.progressWrapper);
};



Operator.prototype.initProgress = function()
{
    this.progressWrapper.style.display = 'block';

    this.progressBar    .style.left    = '0%';
    this.progressBar    .style.width   = '100%';
};



Operator.prototype.updateProgress = function(msg)
{
    const progress = msg.progress;

    this.progressBar.style.left  = (   progress  * 100) + '%';
    this.progressBar.style.width = ((1-progress) * 100) + '%';

    uiUpdateGlobalProgress(msg.globalProgress);
};



Operator.prototype.endProgress = function()
{
    this.progressBar    .style.width   = 0;
    this.progressWrapper.style.display = 'none';
};



Operator.prototype.setPosition = function(x, y, updateTransform = true)
{
    this.div.style.left = x + 'px';
    this.div.style.top  = y + 'px';

    if (updateTransform)
        graphView.updateNodeTransforms([this]);
}



function altCopyNodes(_this, e)
{
    const prevSelected = [...graphView.selectedNodes];
    const thisIndex    = graphView.selectedNodes.indexOf(_this);

    pasteOffset = point(0, 0);
    actionManager.do(new PasteNodesAction(uiCopyNodes(graphView.selectedNodes.map(n => n.id)), getCtrlKey(e), true), false, true);

    consoleAssert(
        graphView.selectedNodes.length == prevSelected.length,
        'different quantities of source and copied nodes');

    graphView.selectedNodes[thisIndex].sx = prevSelected[thisIndex].sx;
    graphView.selectedNodes[thisIndex].sy = prevSelected[thisIndex].sy;

    prevSelected           [thisIndex].div.dragging = false;
    graphView.selectedNodes[thisIndex].div.dragging = true;

    prevSelected           [thisIndex].header.releasePointerCapture(e.pointerId);

    try
    {
        graphView.selectedNodes[thisIndex].header.setPointerCapture(e.pointerId);

        for (let i = 0; i < prevSelected.length; i++)
        {
            graphView.selectedNodes[i].slx = prevSelected[i].div.offsetLeft;
            graphView.selectedNodes[i].sly = prevSelected[i].div.offsetTop;
        }

        nodesAltCopied = true;
    }
    catch {}
}


Operator.prototype.createLabel = function()
{
    this.labelWrapper         = createDiv('nodeLabelWrapper');
  
    this.label                = createDiv('nodeLabel');
    this.label.node           = this;
    
    this.divIcon              = createDiv('nodeIcon');
    this.divIcon.innerHTML    = this.icon;
    
    this.labelText            = createDiv('nodeLabelText');
    this.labelText.node       = this;
    this.labelText.clickTimer = -1; 
    
    this.label       .appendChild(this.divIcon);
    this.label       .appendChild(this.labelText);

    this.labelWrapper.appendChild(this.label);
    this.header      .appendChild(this.labelWrapper);

    


    this.labelWrapper.addEventListener('pointerdown', e =>
    {
        //e.preventDefault();
    });

    
    this.labelWrapper.addEventListener('pointermove', e =>
    {
        if (!this.scrollName)
            return;

        const wrect      = boundingRect(this.labelWrapper);
        const margin     = 14;
        const viewMargin = margin * graph.currentPage.zoom;
        
        const x          = e.clientX - wrect.x;

             if (x <  viewMargin)               this.updateHeaderLabelOffsetX(0);
        else if (x >= wrect.width - viewMargin) this.updateHeaderLabelOffsetX(1);
        else if (x >= viewMargin
              && x <  wrect.width - viewMargin) this.updateHeaderLabelOffsetX((x - viewMargin) / (wrect.width - viewMargin*2));
        else                                    this.updateHeaderLabelOffsetX();
    });
};



Operator.prototype.updateHeaderLabelOffsetX = function(f = this.labelOffsetFactor)
{
    //console.log('updateHeaderLabelOffsetX()');

    this.labelOffsetFactor = Math.min(Math.max(0, f), 1);


    const margin     = 15;
    const viewMargin = margin * graph.currentPage.zoom;

    const wrect      = this.measureData.labelWrapperBounds;
    const rect       = this.measureData.labelBounds;

    const rw         = wrect.width - viewMargin*2;
    const sf         = rw / nozero(rect.width);
    const df         = viewMargin / rect.width / 2;
        
    const s1         = this.labelOffsetFactor * (rect.width - rw) / rect.width;
    const s0         = s1 - df;
    const s2         = s1 + sf;
    const s3         = s2 + df;


    const activeOffset = this.getActiveOffset();
    const defOffset    = this.getDefaultOffset();


    if (rect.width > rw)
    {
        this.label.style.left = 
            11 
            - this.labelOffsetFactor * (rect.width - rw - 1) / graph.currentPage.zoom
            + (this.active ? activeOffset : 0);
            
        this.label.style.transform = 'none';
    }
    else
    {
        this.label.style.left = 
              'calc(50%' 
            + (this.active && this.showActiveArrow ? (' + ' + activeOffset + 'px') : (' + ' + defOffset + 'px')) 
            + ')';

        this.label.style.transform = 'translateX(-50%)';
    }


    const color = 
        this.label.style.color.trim() != ''
        ?  this.label.style.color
        : 'black';

    this.label.style.background = 
          'linear-gradient(90deg, '
        + '#0000 '     + (s0 * 100) + '%, '
        +  color + ' ' + (s1 * 100) + '%, '
        +  color + ' ' + (s2 * 100) + '%, '
        + '#0000 '     + (s3 * 100) + '%)';

    this.label.style.WebkitBackgroundClip = 'text';
    this.label.style.WebkitTextFillColor  = 'transparent';
};


Operator.prototype.initLabelTextbox = function()
{
    this.textbox = createTextbox('nodeLabelTextbox');
    
    this.textbox.spellcheck     = false;
    this.textbox.keyboardFinish = false;
    


    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
        {
            this.textbox.keyboardFinish = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyboardFinish = true;
            this.textbox.finish(false);
        }

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            const tabs  = document.querySelectorAll('.node, .figmaSelect, .menuSelect #hexValue, button');
            const index = this.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'node')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else if (e.key == 'Alt')
            e.preventDefault();
    });


    
    // this.textbox.addEventListener('input', function()
    // {
    //     this.setValue(parseFloat(this.textbox.value));
    // });



    this.textbox.addEventListener('pointerdown', e => e.stopPropagation());
    this.textbox.addEventListener('pointermove', e => this.textbox.style.cursor = 'default');



    this.textbox.addEventListener('pointerup', e =>
    {
        e.stopPropagation();

        if (e.button == 2)
        {
            initTextMenu(this.textbox);
            menuText.showAt(e.clientX, e.clientY, false, false);
        }
    });



    // this.textbox.addEventListener('paste', e =>
    // {
    //     e.preventDefault();
    //     this.textbox.value = e.clipboardData.getData('text/plain');
    // });

    
    
    this.textbox.addEventListener('focus', () => this.textbox.keyboardFinish = false);

    
    
    this.textbox.addEventListener('focusout', () =>
    {
        if (    this.textbox.value != ''
            && !this.textbox.keyboardFinish)
            this.textbox.finish(true);

            this.label.style.display = 'block';

        this.header.removeChild(this.textbox);
        this.clicked = false;
    });
    


    this.textbox.finish = success =>
    {
        const enteredValue = this.textbox.value     .trim();
        const   savedValue = this.textbox.savedValue.trim();

        if (success) 
        {
            if (   (   enteredValue != ''
                    || this.allowEmptyName) 
                && enteredValue != savedValue)
            {
                const newName = this.textbox.value;
                setTimeout(() => this.setName(newName));
                actionManager.do(new RenameNodeAction(this.id, newName));
            }
        }
        else
            this.textbox.value = this.textbox.savedValue;


        this.textbox.dispatchEvent(new CustomEvent('finishedit', { 'detail': {
            'success':  success,
            'value':    enteredValue,
            'oldValue': savedValue }}));
    

        this.textbox.blur();
        
        this.label.style.display = 'block';

        setTimeout(() => 
        {
            this.updateHeaderLabel();
            
            if (this.inFocus)
                this.div.focus();
        });
    };    
}



Operator.prototype.showLabelTextbox = function()
{
    this.inFocus = 
            hasFocus(this.div)
        && !this.clicked;

    this.textbox.style.width                = this.header.offsetWidth  - 4;
    this.textbox.style.height               = this.header.offsetHeight - 4;
    this.textbox.style.position             = 'absolute';
    this.textbox.style.left                 = '50%';
    this.textbox.style.top                  = '50%';
    this.textbox.style.transform            = 'translateX(-50%) translateY(-50%)';
    this.textbox.style.textAlign            = 'center';
    this.textbox.style.margin               = '0 1px 0 0px';
    this.textbox.style.borderRadius         = '2px 2px 0 0';
  //this.textbox.style.boxShadow       = '0 0 0 1px #a0a inset';

    this.textbox.style.backgroundColor = this.header.style.backgroundColor;
    this.textbox.style.color           = this.label.style.color;

    this.textbox.value                 = this.name;
    this.textbox.savedValue            = this.textbox.value;
    
    this.header.appendChild(this.textbox);

    this.label.style.display           = 'none';
    
    this.updateNode();
    
    this.textbox.focus();
    this.textbox.select();
}



Operator.prototype.updateTransform = function()
{
    const nodeLeft = this.div.offsetLeft;
    const nodeTop  = this.div.offsetTop;
    const nodeRect = this.getOffsetRect();
    
    this.setTransform(nodeLeft, nodeTop, nodeRect);
    this.updateWireTransform();
}



Operator.prototype.updateWireTransform = function()
{
    const wires = [];

    for (const input of this.inputs)
        if (   input.connected
            && input.connection)
            wires.push(input.connection.wire);        

    for (const output of this.outputs)
        for (const connInput of output.connectedInputs)
            if (connInput.connection)
                wires.push(connInput.connection.wire);

    graphView.updateWires(wires);
}



Operator.prototype.updateNode = function() 
{
    this.updateHeader();
    this.updateHeaderLabel();
    this.updateBorder();
    this.updateParams();
    this.updateDisabled();
    this.updateSubscribe();


    const visibleParams = this.params.filter(p => 
           p.isVisible()
        && (  !p.isResult
            || settings.showOperationResults));

    
    if (  !isEmpty(visibleParams)
        || this.sharpBottomCorners)
    {
        this.div   .style.borderBottomLeftRadius  = '0px';        
        this.inner .style.borderBottomLeftRadius  = '0px';        
        this.header.style.borderBottomLeftRadius  = '0px';        

        this.div   .style.borderBottomRightRadius = '0px';        
        this.inner .style.borderBottomRightRadius = '0px';        
        this.header.style.borderBottomRightRadius = '0px';        
    }
    else
    {
        this.div   .style.borderRadius = '4px';        
        this.inner .style.borderRadius = '4px';        
        this.header.style.borderRadius = '4px';        
    }
}



Operator.prototype.updateBorder = function()
{
    const scale = 
        graph.currentPage.zoom >= 1
        ? 3
        : 3 * (((1 / graph.currentPage.zoom - 1) / 2) + 1);

    const highlightScale = 
        graph.currentPage.zoom >= 1
        ? 7
        : 7 * (((1 / graph.currentPage.zoom - 1) / 3.5) + 1);


    let highlight = 'transparent';

    if (this.type != PANEL)
    {
        switch (this.highlight)
        {
            case 1: highlight = darkMode ? '#f33a' : '#f006'; break;
            case 2: highlight = darkMode ? '#f809' : '#f808'; break;
            case 3: highlight = darkMode ? '#ff08' : '#dd0f'; break;
            case 4: highlight = darkMode ? '#1e18' : '#0d09'; break;
            case 5: highlight = darkMode ? '#27fd' : '#03f7'; break;
            case 6: highlight = darkMode ? '#f2f9' : '#f0f7'; break;
            case 7: highlight = darkMode ? '#fff8' : '#0007'; break;
        }
    }


    this.div.style.boxShadow = 
          (this._selected
           ? '0 0 0 ' + scale + 'px var(--figma-color-bg-brand), '
           : '')
        + '0 0 0 ' + highlightScale + 'px ' + highlight;
}



Operator.prototype.updateHeader = function()
{
    const height = this.updateHeaderInputsAndOutputs();

    this.header.style.height = height;

    
    this.updateHeaderLabel();
    this.updateReorderArrows();


    const colors = this.getHeaderColors();


    if (this.progressBar)
    {
        this.progressBar.style.background = 
            !rgbIsNaN(colors.back) 
            ? rgb2style_a(colors.text, 0.5) 
            : 'var(--figma-color-bg-brand)';
    }
}



Operator.prototype.updateParams = function()
{
    for (const param of this.params)
        param.enableControlText(true, param.isUnknown());

    this.updateParamControls();
}



Operator.prototype.updateParamControls = function()
{
    for (const param of this.params)
        param.updateControls();
}



Operator.prototype.updateDisabled = function()
{
    if (!this.measureData)
        return;

    const height = Math.min(this.measureData.divOffset.width, this.measureData.divOffset.height) + 70;

    this.divDisabled.style.display   =  this.enabled ? 'none' : 'inline-block';
    this.divDisabled.style.zIndex    =  10000;
    this.divDisabled.style.height    =  height;
    this.divDisabled.style.transform = 'rotate(45deg)';
    this.divDisabled.style.left      =  (this.measureData.divOffset.width  - this.measureData.disabledOffset.width ) / 2;
    this.divDisabled.style.top       =  (this.measureData.divOffset.height - height) / 2;
}



Operator.prototype.updateSubscribe = function()
{
    if (!this.measureData)
        return;

    this.subscribeCover.style.top    = this.measureData.headerOffset.height;
    this.subscribeCover.style.height = this.measureData.divOffset.height - this.measureData.headerOffset.height;
}



Operator.prototype.updateSubscribeStatus = function(subscribed)
{
    const showSub = 
            this.subscription
        && !subscribed;


    this.subscribeCover.style.display = showSub ? 'block' : 'none';
    this.subscribeLabel.style.display = showSub ? 'block' : 'none';

    this.inner.style.opacity = showSub ? '50%' : '100%';


    if (!showSub)
        this.updateSubscribe();
}



Operator.prototype.updateMeasureData = function()
{
    this.measureData = 
    {
        divBounds:          boundingRect(this.div),
        divOffset:          offsetRect  (this.div),
        innerOffset:        offsetRect  (this.inner),
        paramOffset:        offsetRect  (this.paramHolder),
        headerOffset:       offsetRect  (this.header),
        labelWrapperBounds: boundingRect(this.labelWrapper),
        labelWrapperOffset: offsetRect  (this.labelWrapper),
        labelBounds:        boundingRect(this.label),
        labelOffset:        offsetRect  (this.label),
        disabledOffset:     offsetRect  (this.divDisabled),
        subscribeOffset:    offsetRect  (this.subscribeLabel)
    };

    this.params
        .forEach(p =>
        {
            for (const control of p.controls)
                control.updateMeasureData();

            if (p. input) p. input.updateMeasureData();
            if (p.output) p.output.updateMeasureData();
        });
}



Operator.prototype.updateHeaderLabel = function()
{
    this.updateHeaderLabelText();

    
    this.label.style.top = 
          (  Math.floor(this.measureData.labelWrapperOffset.height/2 - this.measureData.labelOffset.height/2)
           + Math.min(Math.max(1, 1/graph.currentPage.zoom), 2)
           - (settings.showNodeId ? 1 : 0))
        + 'px';


    this.updateHeaderLabelOffsetX();


    const colors = this.getHeaderColors();

    
    let fontSize = 11;

    // compensate for bold active header names look THINNER when zoomed out
         if (graph.currentPage.zoom < 0.5 ) fontSize = 17;
    else if (graph.currentPage.zoom < 0.75) fontSize = 15;
    else if (graph.currentPage.zoom < 1   ) fontSize = 13;
    else if (graph.currentPage.zoom < 1.5 ) fontSize = 12;

    this.label.style.color      = rgba2style(colors.text);
    this.label.style.fontSize   = this.active ? fontSize : 11;
    this.label.style.height     = this.active ? fontSize * 15 / 11 : 15;
    this.label.style.fontWeight = graph.currentPage.zoom < 1.2 ? '600' : 'normal';


    this.updateIcon();
}



Operator.prototype.updateIcon = function()
{
    const colors = this.getHeaderColors();

    this.divIcon.innerHTML     = this.icon.replaceAll('white', rgba2style(colors.text));
    this.divIcon.style.top     = (this.iconOffsetY * Math.min(graph.currentPage.zoom, 1)).toString() + 'px';
    this.divIcon.style.display = 
           this.icon != '' 
        && (   settings.showNodeIcons
            || this.alwaysShowIcon)
        ? 'inline' 
        : 'none';
}



Operator.prototype.updateHeaderLabelText = function()
{
    const prefix = '';
        // this.type == REPEAT 
        // ? '...' 
        // : '';
    
    let suffix;

    const sep = settings.showNodeId ? ' ' : '  ';

         if (this.type == LIST        ) suffix = sep + '[ ' + this.length        + ' ]';
    else if (this.type == SUBLIST     ) suffix = sep + '[ ' + this.length        + ' ]';
    else if (this.type == COLUMN      ) suffix = sep + '[ ' + this.columnLength  + ' ]';
    else if (this.type == REVERSE_LIST) suffix = sep + '[ ' + this.tableLength   + ' ]';
    else if (this.type == SORT        ) suffix = sep + '[ ' + this.tableLength   + ' ]';
    else if (this.type == UNIQUE      ) suffix = sep + '[ ' + this.length        + ' ]';
    else if (this.type == ITEMS       ) suffix = sep + '[ ' + this.params.length + ' ]';
    else                                suffix = this.cached ? '' : '...';


    suffix += this.suffix;


    this.labelText.innerHTML = 
          (settings.showNodeId ? this.id + suffix : prefix + this.name + suffix)
        + (this.active && this.showActiveArrow ? (settings.showNodeId ? ' ' : '  ') + '‣' : '');

    this.labelText.style.fontFamily = 
        settings.showNodeId 
        ? 'Roboto Mono' 
        : 'Inter';
}



Operator.prototype.updateReorderArrows = function()
{
    if (this.showReorderArrows)
    {
        const colors     = this.getHeaderColors();
        const arrowStyle = rgba2style(rgb_a(isDark(colors.back) ? [1, 1, 1] : [0, 0, 0], 0.5));

        this.reorderArrows.style.display            = 'inline-block';
        this.reorderArrows.style.background         = 'url(\'data:image/svg+xml;utf8,<svg width="5" height="8" viewBox="0 0 5 8" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 8L5 5H0L2.5 8Z" fill="'+arrowStyle+'"/><path d="M2.5 0L5 3H0L2.5 0Z" fill="'+arrowStyle+'"/></svg>\')';
        this.reorderArrows.style.backgroundPosition = '50% 50%';
        this.reorderArrows.style.backgroundRepeat   = 'no-repeat';
    }
    else
        this.reorderArrows.style.display            = 'none';    
};



Operator.prototype.updateHeaderInputsAndOutputs = function()
{
    let height = defHeaderHeight;


    const inputs  = this.headerInputs;
    const outputs = this.headerOutputs;

    let [ inputY,  inputHeight] = getHeaderConnY(inputs);
    let [outputY, outputHeight] = getHeaderConnY(outputs);


     inputHeight += this.header.connectionPadding * 2;
    outputHeight += this.header.connectionPadding * 2;


         if ( inputHeight > outputHeight) for (let i = 0; i < outputs.length; i++) outputY[i] += (inputHeight - outputHeight)/2;
    else if (outputHeight >  inputHeight) for (let i = 0; i < inputs .length; i++)  inputY[i] += (outputHeight - inputHeight)/2;     


    const maxHeight = Math.max(inputHeight, outputHeight);

    if (maxHeight > height) 
        height = maxHeight;
    else
    {
        for (let i = 0; i < inputs .length; i++)  inputY[i] += (height - maxHeight)/2;
        for (let i = 0; i < outputs.length; i++) outputY[i] += (height - maxHeight)/2;
    }


    for (let i = 0; i < inputs .length; i++)  inputY[i] += connectionSize/2 + this.header.connectionPadding;
    for (let i = 0; i < outputs.length; i++) outputY[i] += connectionSize/2 + this.header.connectionPadding;


    for (let i = 0; i < inputs.length; i++)
    {
        inputs[i].div.style.top = inputY[i];
        inputs[i].updateControl();
    }

    for (let i = 0; i < outputs.length; i++) 
    {
        outputs[i].div.style.top = outputY[i];
        outputs[i].updateControl();
    }


    return height;
};



Operator.prototype.updateValues = function(requestId, actionId, updateParamId, paramIds, values) // virtual
{
    for (let i = 0; i < paramIds.length; i++)
    {
        const index = this.params.findIndex(p => p.id == paramIds[i]);

        if (   paramIds[index] != updateParamId
            && index > -1
            && this.params[index].type == values[i].type)
        {
            this.params[index].setValue(values[i], false, true, false);
        }
    }


    this.preview = values[paramIds.findIndex(id => id == 'preview')];
};



Operator.prototype.setLayoutIndex = function()
{
    this.layoutIndex++;

    for (const output of this.connectedOutputs)
        for (const input of output.connectedInputs)
            input.node.setLayoutIndex();
};


class OperatorBase
extends Operator
{
    canAutoConnectFrom(output)
    {
        return this.inputs[0].canConnectFrom(output);
    }



    updateHeader()
    {
        //console.log(this.id + '.OperatorBase.updateHeader()');

        super.updateHeader();

        
        const colors = this.getHeaderColors();


        this.header.style.backgroundColor = rgba2style(colors.back);
        this.label .style.color           = rgba2style(colors.text);


        for (const input of this.headerInputs)
        {
            input.colorLight = 
            input.colorDark  = colors.input;
            input.wireColor  = colors.wire;
        }

        
        for (const output of this.headerOutputs) 
        {
            output.colorLight =
            output.colorDark  = colors.output;
            output.wireColor  = colors.wire;
        }
    }
}



function createBoolMenu(param)
{
    const menu = new Menu('L', true, false);

    menu.minWidth = 130;
    
    menu.addItems([
        new MenuItem('true',  null, {icon:  TRUE_DISPLAY_MENU, callback: () => { hideAllMenus(); param.setValue(new NumberValue(1), true); }}),
        new MenuItem('false', null, {icon: FALSE_DISPLAY_MENU, callback: () => { hideAllMenus(); param.setValue(new NumberValue(0), true); }})]);

    param.controls[0].div.addEventListener('pointerdown', e => param.node.showParamMenu(e, param, menu));

    return menu;
}


class   OperatorWithValue
extends OperatorBase
{
    paramValue;
    


    constructor(type, id, name, icon, defWidth = defNodeWidth, progressBar = false)
    {
        super(type, id, name, icon, defWidth, progressBar);

        this.paramValue = createParamFromType(type);

        this.paramValue.isResult    = true;
        this.paramValue.isNodeValue = true;
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        super.setRect(
            x,
            y,
            w, 
            h + (this.params.length - (settings.showOperationResults ? 0 : 1)) * defParamHeight, //settings.showOperationResults ? h : h - defParamHeight, 
            updateTransform);
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramValue.setValue(value, false, true, false);

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


const windowBorderWidth = 8;
const sizeBorderWidth   = 4;



class   ResizableBase
extends OperatorBase
{
    width;
    height;


    sizerL;
    sizerR;
    sizerT;
    sizerB;

    sizerTL;
    sizerTR;
    sizerBL;
    sizerBR;



    constructor(type, id, name, icon, defWidth = defNodeWidth, progressBar = false)
    {
        super(type, id, name, icon, defWidth, progressBar);

        this.width  = defWidth;
        this.height = defHeaderHeight;

        this.initSizers();
    }



    initSizers()
    {
        this.sizerL  = createDiv('sizerEdge sizerH sizerL');
        this.sizerR  = createDiv('sizerEdge sizerH sizerR');
        this.sizerT  = createDiv('sizerEdge sizerV sizerT');
        this.sizerB  = createDiv('sizerEdge sizerV sizerB');

        this.sizerTL = createDiv('sizerCorner sizerTL');
        this.sizerTR = createDiv('sizerCorner sizerTR');
        this.sizerBL = createDiv('sizerCorner sizerBL');
        this.sizerBR = createDiv('sizerCorner sizerBR');


        this.div.appendChild(this.sizerL);
        this.div.appendChild(this.sizerR);
        //this.div.appendChild(this.sizerT);
        this.div.appendChild(this.sizerB);

        //this.div.appendChild(this.sizerTL);
        //this.div.appendChild(this.sizerTR);
        this.div.appendChild(this.sizerBL);
        this.div.appendChild(this.sizerBR);


        this.initSizerEvents(this.sizerL,  this.setRectL );
        this.initSizerEvents(this.sizerR,  this.setRectR );
        //this.initSizerEvents(this.sizerT,  this.setRectT );
        this.initSizerEvents(this.sizerB,  this.setRectB );

        //this.initSizerEvents(this.sizerTL, this.setRectTL);
        //this.initSizerEvents(this.sizerTR, this.setRectTR);
        this.initSizerEvents(this.sizerBL, this.setRectBL);
        this.initSizerEvents(this.sizerBR, this.setRectBR);
   }



    initSizerEvents(sizer, setRect)
    {
        sizer.resizing = false;


        sizer.addEventListener('pointerdown', e =>
        {
            if (e.button == 0)
            {
                if (document.activeElement)
                    document.activeElement.blur();

                hideAllMenus();
                
                    
                e.stopImmediatePropagation();


                if (   graph.currentPage.zoom < settings.minZoomForParams
                    && this.type != PANEL)
                {
                    forwardEvent(e, this.header);
                    return;
                }

                   
                e.preventDefault();


                try
                {
                    sizer.setPointerCapture(e.pointerId);

                    sizer.startRect = offsetRect(this.div);
                    sizer.resizing  = true;

                
                    sizer.sx = e.clientX;
                    sizer.sy = e.clientY;
                }
                catch {}
            }        
        });



        sizer.addEventListener('pointermove', e =>
        {
            if (!sizer.resizing)
                return;


            const dx = (e.clientX - sizer.sx) / graph.currentPage.zoom;
            const dy = (e.clientY - sizer.sy) / graph.currentPage.zoom;
        
            setRect(sizer, dx, dy);
                

            e.preventDefault();
            e.stopImmediatePropagation();

            this.updateMeasureData();
        });
        

        
        sizer.addEventListener('pointerup', e =>
        {
            if (e.button == 0)
            {
                if (sizer.resizing)
                {
                    actionManager.do(new SetNodeRectAction(
                        this.id, 
                        sizer.startRect, 
                        offsetRect(this.div)));

                    sizer.resizing = false;
                }


                if (sizer.hasPointerCapture(e.pointerId))
                    sizer.releasePointerCapture(e.pointerId);
            }
        });
    }



    setRectL = (sizer, dx, dy) => // these have to be lambdas for 'this'
    {
        this.setRect(
            sizer.startRect.x + dx,
            sizer.startRect.y, 
            sizer.startRect.w - dx, 
            sizer.startRect.h);
    };



    setRectR = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y, 
            sizer.startRect.w + dx, 
            sizer.startRect.h);
    }



    setRectT = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y + dy, 
            sizer.startRect.w, 
            sizer.startRect.h - dy);
    };



    setRectB = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y, 
            sizer.startRect.w, 
            sizer.startRect.h + dy);
    }



    setRectTL = (sizer, dx, dy) => // these have to be lambdas for 'this'
    {
        this.setRect(
            sizer.startRect.x + dx,
            sizer.startRect.y + dy, 
            sizer.startRect.w - dx, 
            sizer.startRect.h - dy);
    };



    setRectTR = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y + dy, 
            sizer.startRect.w + dx, 
            sizer.startRect.h - dy);
    }



    setRectBL = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x + dx, 
            sizer.startRect.y, 
            sizer.startRect.w - dx, 
            sizer.startRect.h + dy);
    };



    setRectBR = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y, 
            sizer.startRect.w + dx, 
            sizer.startRect.h + dy);
    }


    // setSize(w, h, updateTransform = true)
    // {
    //     let headerHeight = getStyleValue(this.header, 'offset-height');
    //     if (typeof headerHeight == 'string') headerHeight = defHeaderHeight;

    //     const paramHeight = 
    //            this instanceof ResizableOperatorWithValue
    //         && settings.showOperationResults
    //         ? defParamHeight 
    //         : 0;


    //     const _w = Math.max(60, w);
    //     const _h = Math.max(parseFloat(headerHeight) + paramHeight, h);

    //     super.setSize(_w, _h, updateTransform);

    //     this.updateSizers();

    //     this.inner.style.height = _h;
    // }



    setRect(x, y, w, h, updateTransform = true)
    {
        const headerHeight = this.header.offsetHeight;//getStyleValue(this.header, 'height');

        const paramHeight = 
               this instanceof ResizableOperatorWithValue
            && settings.showOperationResults 
            ? defParamHeight 
            : 0;

        const _w = Math.max(60, w);
        const _h = Math.max(parseFloat(headerHeight) + paramHeight, h);

        super.setRect(x, y, _w, _h, updateTransform);
        
        this.width  = _w;
        this.height = _h;

        this.updateSizers();
    
        this.inner.style.height = _h;
    }



    setHeight(h, updateTransform = true)
    {
        const headerHeight = this.header.offsetHeight;//getStyleValue(this.header, 'height');

        const paramHeight = 
               this instanceof ResizableOperatorWithValue
            && settings.showOperationResults 
            ? defParamHeight 
            : 0;

        const _h = Math.max(parseFloat(headerHeight) + paramHeight, h);

        super.setHeight(_h, updateTransform);
        
        this.height = _h;
        
        this.updateSizers();

        this.inner.style.height = _h;
    }



    updateSizers()
    {
        const edge   = Math.max(Math.ceil(sizeBorderWidth / graph.currentPage.zoom), 2);
        const corner = Math.max(sizeBorderWidth, edge);

        this.sizerL .style.width  = edge; 
        this.sizerR .style.width  = edge; 

        this.sizerT .style.height = edge; 
        this.sizerB .style.height = edge; 

        this.sizerTL.style.width  = corner; 
        this.sizerTL.style.height = corner; 

        this.sizerTR.style.width  = corner; 
        this.sizerTR.style.height = corner; 

        this.sizerBL.style.width  = corner; 
        this.sizerBL.style.height = corner; 

        this.sizerBR.style.width  = corner; 
        this.sizerBR.style.height = corner; 


        const canReact = 
               graph.currentPage.zoom >= settings.minZoomForParams
            || this.type == PANEL;

        this.sizerL.style.cursor  = canReact ? 'ew-resize'   : 'default';
        this.sizerR.style.cursor  = canReact ? 'ew-resize'   : 'default';
        this.sizerT.style.cursor  = canReact ? 'ns-resize'   : 'default';
        this.sizerB.style.cursor  = canReact ? 'ns-resize'   : 'default';
        
        this.sizerTL.style.cursor = canReact ? 'nwse-resize' : 'default';
        this.sizerTR.style.cursor = canReact ? 'nesw-resize' : 'default';
        this.sizerBL.style.cursor = canReact ? 'nesw-resize' : 'default';
        this.sizerBR.style.cursor = canReact ? 'nwse-resize' : 'default';
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let json = super.toJsonBase(nTab);

        json += 
              ',\n' + pos + tab + '"width": "'  + this.width  + '"'
            + ',\n' + pos + tab + '"height": "' + this.height + '"';

        return json;
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);

        if (   _node.width
            && _node.height)
        {
            this.width  = parseFloat(_node.width );
            this.height = parseFloat(_node.height);

            this.setRect(
                parseFloat(_node.x     ), 
                parseFloat(_node.y     ), 
                parseFloat(_node.width ), 
                parseFloat(_node.height),
                false);
        }
    }
}



class   ResizableOperatorWithValue
extends ResizableBase
{
    paramValue;
    


    constructor(type, id, name, icon, defWidth = defNodeWidth, progressBar = false)
    {
        super(type, id, name, icon, defWidth, progressBar);

        this.paramValue = createParamFromType(type);

        this.paramValue.isResult    = true;
        this.paramValue.isNodeValue = true;
    }



    // setSize(w, h, updateTransform = true)
    // {
    //     super.setSize(
    //         w, 
    //         settings.showOperationResults ? h : h - defParamHeight, 
    //         updateTransform);
    // }



    setRect(x, y, w, h, updateTransform = true)
    {
        super.setRect(
            x,
            y,
            w, 
            settings.showOperationResults ? h : h - defParamHeight, 
            updateTransform);
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramValue.setValue(value, false, true, false);

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


class   OpStart
extends OperatorBase
{
    paramFeedback;
    paramFrom;



    constructor()
    {
        super(START, 'start', 'start', iconStart);

        this.cached     = false;
        this.canDisable = true;


        this.addInput (new Input(ALL_VALUES));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));


        this.addParam(this.paramFeedback = new NumberParam('feedback', 'feedback', true,  true,  true, 0, 0, 1));
        this.addParam(this.paramFrom     = new NumberParam('from',     '',         false, false, true));

        
        this.paramFeedback.divider = 0.64;


        this.inputs[0].addEventListener('connect',    () => OpStart_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpStart_onDisconnectInput(this));
    }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramFeedback.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        const type = 
            this.inputs[0].connected 
            ? this.inputs[0].connectedOutput.node.type 
            : this.type;

        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = this.active ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }



    updateParams()
    {
        this.paramFeedback.enableControlText(true);
        this.paramFrom.enableControlText(false);

        updateParamConditionText(this.paramFeedback, this.paramFeedback.isUnknown(), true, 0);


        const arrowStyle = darkMode ? 'white' : 'black';

        this.paramFrom.controls[0].valueText = '<svg width="14" height="9" viewBox="0 0 14 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.53553 0L0 3.53553L0.707107 4.24264L3.00001 1.94974V4C3.00001 6.76142 5.23859 9 8.00001 9H14V8H8.00001C5.79087 8 4.00001 6.20914 4.00001 4L4.00001 1.85242L6.37717 4.22958L7.08428 3.52247L3.56735 0.00553989L3.55421 0.0186768L3.53553 0Z" fill="' + arrowStyle + '"/></svg>';

        this.updateParamControls();
    }
}



function OpStart_onConnectInput(node)
{
    node. inputs[0].types = [...node.inputs[0].connectedOutput.types];
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
}



function OpStart_onDisconnectInput(node)
{
    node. inputs[0].types = ALL_VALUES;
    node.outputs[0].types = [ANY_VALUE];
}


class   OpRepeat
extends OperatorBase
{
    paramCount;
    paramWhile;
    paramLoop;



    constructor()
    {
        super(REPEAT, 'repeat', 'repeat', iconRepeat, defNodeWidth, true);

        this.isMultiplier = true;
        this.canDisable   = true;

        
        this.addInput (new Input([ANY_VALUE]));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));


        this.addParam(this.paramCount = new NumberParam('count', 'count', true,  true, true, 10, 0, 1000, 0));
        this.addParam(this.paramWhile = new NumberParam('while', 'while', true,  true, true, 1, 0, 1));
        this.addParam(this.paramLoop  = new NumberParam('loop',  '',      false, true, false));


        this.paramCount.controls[0].allowEditDecimals = false;
        this.paramCount.divider                       = 0.52;
        this.paramCount.affectsHeader                 = false;

        this.paramWhile.divider                       = 0.6;

        this.paramLoop.input.types.push(NUMBER_LIST_VALUE, START);
    }
    
    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCount.genRequest(gen));
        request.push(...this.node.paramWhile.genRequest(gen));
        request.push(...this.node.paramLoop .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const type  = values[paramIds.findIndex(id => id == 'type' )];
        const count = values[paramIds.findIndex(id => id == 'count')];

        if (count) this.paramCount.setValue( count, false, true, false);

        this.outputs[0].types = 
               type
            && type.isValid()
            ? [type.value]
            : [LIST_VALUE];

        this.endProgress();
    }



    updateParams()
    {
        this.paramCount.enableControlText(true);
        this.paramWhile.enableControlText(false);
        this.paramLoop .enableControlText(false);

        this.paramWhile.controls[0].valueText = '﻿';


        const arrowStyle = darkMode ? 'white' : 'black';
        this.paramLoop.controls[0].valueText = '<svg width="24" height="11" viewBox="0 0 24 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M22.991 0H23.991L23.991 2C23.991 4.76142 21.7524 7 18.991 7H10.991V6H18.991C21.2001 6 22.991 4.20914 22.991 2L22.991 0Z" fill="'+arrowStyle+'"/><rect width="4.97369" height="1" transform="matrix(0.707107 -0.707107 -0.707107 -0.707107 10.7036 7.224)" fill="'+arrowStyle+'"/><rect width="5" height="1" transform="matrix(0.707107 0.707107 0.707107 -0.707107 9.99097 6.54858)" fill="'+arrowStyle+'"/><circle cx="0.5" cy="6.5" r="0.5" fill="'+arrowStyle+'"/><circle cx="3.5" cy="6.5" r="0.5" fill="'+arrowStyle+'"/><circle cx="6.5" cy="6.5" r="0.5" fill="'+arrowStyle+'"/></svg>';
        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        const type = this.outputs[0].types[0];

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = this.active ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}


class   OpNull
extends OperatorBase
{
    constructor()
    {
        super(NULL_NODE, 'null', 'null', iconNull);

        //this.cached = false;


        this.addInput (new Input(ALL_VALUES));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));


        this.inputs[0].addEventListener('connect',    () => OpNull_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpNull_onDisconnectInput(this));
    }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        const type = values[paramIds.findIndex(id => id == 'type')];

        if (type)
            this.outputs[0].types = [type.value];
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
                this.active
            && !this.inputs[0].connected;

        colors.input  = gray ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = gray ? rgbFromType(ANY_VALUE, true) : rgbFromType(type, true);

        return colors;
    }
}



function OpNull_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
}



function OpNull_onDisconnectInput(node)
{
    node.outputs[0].types = [ANY_VALUE];
}


class   OpCache
extends OperatorBase
{
    constructor()
    {
        super(CACHE, 'cache', 'cache', iconCache);

        this.canDisable  = true;
        this.iconOffsetY = 1;


        this.addInput (new Input(ALL_VALUES));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));


        this.inputs[0].addEventListener('connect',    () => OpCache_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpCache_onDisconnectInput(this));
    }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        const type = values[paramIds.findIndex(id => id == 'type')];

        if (type)
            this.outputs[0].types = [type.value];
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
                this.active
            && !this.inputs[0].connected;

        colors.input  = gray ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = gray ? rgbFromType(ANY_VALUE, true) : rgbFromType(type, true);

        return colors;
    }
}



function OpCache_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
}



function OpCache_onDisconnectInput(node)
{
    node.outputs[0].types = [ANY_VALUE];
}


class   OpFreeze
extends OperatorBase
{
    constructor()
    {
        super(FREEZE, 'freeze', 'freeze', iconFreeze);

        this.cached      = false;
        this.canDisable  = true;
        this.iconOffsetY = 1;


        this.addInput (new Input(ALL_VALUES));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));


        this.inputs[0].addEventListener('connect',    () => OpFreeze_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpFreeze_onDisconnectInput(this));
    }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    isOrPrecededByUncached()
    {
        return false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        const type = values[paramIds.findIndex(id => id == 'type')];

        if (type)
            this.outputs[0].types = [type.value];
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
                this.active
            && !this.inputs[0].connected;

        colors.input  = gray ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = gray ? rgbFromType(ANY_VALUE, true) : rgbFromType(type, true);

        return colors;
    }
}



function OpFreeze_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
}



function OpFreeze_onDisconnectInput(node)
{
    node.outputs[0].types = [ANY_VALUE];
}


class   OpTimer
extends OperatorBase
{
    paramDelay;

    updateTimer = -1;
    updateDelay =  0;



    constructor()
    {
        super(TIMER, 'timer', 'timer', iconTimer);

        this.subscription = true;
        this.canDisable   = true;
        this.iconOffsetY  = -2;
        

        this.addInput (new Input(ALL_VALUES));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));


        this.inputs[0].addEventListener('connect',    () => OpCopy_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpCopy_onDisconnectInput(this));


        this.addParam(this.paramDelay = new NumberParam('delay', 'delay', true, true, true, 5, 0));

        this.paramDelay.controls[0].suffix = ' sec';
        this.paramDelay.divider            = 0.45;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramDelay.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    
    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        const delay = values[paramIds.findIndex(id => id == 'delay')].toNumber();

        if (delay > 0)
        {
            if (   this.updateTimer < 0
                || this.updateDelay != delay)
            {
                if (this.updateTimer >= 0)
                    clearTimeout(this.updateTimer);

                this.updateTimer = setTimeout(() => pushUpdate(null, [this]), delay * 1000);
            } 
        }
        else if (this.updateTimer >= 0)
        {
            clearTimeout(this.updateTimer);
            this.updateTimer = -1;
        }
    }


    
    updateParams()
    {
        this.paramDelay.enableControlText(true);
    
        this.updateParamControls();
    }



    toJsCode(gen)
    {
        return '';
    }
}



function OpTimer_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
}



function OpTimer_onDisconnectInput(node)
{
    node.outputs[0].types = [ANY_VALUE];
}


class   OpValueName
extends OperatorBase
{
    paramName;



    constructor()
    {
        super(VALUE_NAME, 'valueName', 'value name', '');

        //this.cached = false;


        this.addInput (new Input(ALL_VALUES));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));

        this.addParam(this.paramName = new TextParam('name', 'name', false, true, true));


        this.inputs[0].addEventListener('connect',    () => OpNull_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpNull_onDisconnectInput(this));
    }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramName.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        const type = values[paramIds.findIndex(id => id == 'type')];

        if (type)
            this.outputs[0].types = [type.value];
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
                this.active
            && !this.inputs[0].connected;

        colors.input  = gray ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = gray ? rgbFromType(ANY_VALUE, true) : rgbFromType(type, true);

        return colors;
    }
}



function OpNull_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
}



function OpNull_onDisconnectInput(node)
{
    node.outputs[0].types = [ANY_VALUE];
}


class   OpList
extends OperatorBase
{
    length;



    constructor()
    {
        super(LIST, 'list', 'list', iconList);

        this.canDisable        = true;
        this.variableInputs    = true;
        this.showHeaderTooltip = true;


        this.addNewInput();
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input(ALL_VALUES);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableListConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableListDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        const length = values[paramIds.findIndex(id => id == 'length')];
        const type   = values[paramIds.findIndex(id => id == 'type'  )];

        if (length)
            this.length = length.value;
    
        if (type)
        {
            consoleAssert(LIST_VALUES.includes(type.value));
            this.outputs[0].types = [type.value];
        }
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text  = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && this.outputs[0].types[0] == LIST_VALUE;

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}



class   OpCondense
extends OperatorBase
{
    constructor()
    {
        super(CONDENSE, 'asItem', 'as item', iconCondense);

        this.canDisable  = true;
        // this.iconOffsetY = 1;
        

        this.addInput (new Input (LIST_VALUES));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const type = values[paramIds.findIndex(id => id == 'type')];
        consoleAssert(LIST_VALUES.includes(type.value));

        this.outputs[0].types = [type.value];
    }






    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        
        const type = this.outputs[0].types[0];


        // const back = rgb_a(rgbFromType(type, this.active), 0.95);

        // colors.back = back;


        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && this.outputs[0].types[0] == LIST_VALUE;

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}


class   OpSublist
extends OperatorBase
{
    paramStart;
    paramEnd;

    length;



    constructor()
    {
        super(SUBLIST, 'sublist', 'sublist', iconSublist);

        this.canDisable        = true;
        this.showHeaderTooltip = true;
        

        this.addInput (new Input (LIST_VALUES));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));

        this.addParam(this.paramStart = new NumberParam('start', '[ start', true, true, true, 0, 0));
        this.addParam(this.paramEnd   = new NumberParam('end',   '] end',   true, true, true, 0, 0));


        this.paramStart.controls[0].allowEditDecimals = false;
        this.paramEnd  .controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramStart.genRequest(gen));
        request.push(...this.node.paramEnd  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const fullLength = values[paramIds.findIndex(id => id == 'fullLength')];
        
        if (fullLength.value > 0)
        {
            this.paramStart.controls[0].setMax(fullLength.value);
            this.paramEnd  .controls[0].setMax(fullLength.value);
        }
        else
        {
            this.paramStart.controls[0].setMax();
            this.paramEnd  .controls[0].setMax();
        }


        const length = values[paramIds.findIndex(id => id == 'length')];

        this.length = length.value;

        
        const type = values[paramIds.findIndex(id => id == 'type')];

        if (type)
            this.outputs[0].types = [type.value];


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateParams()
    {
        this.paramStart.enableControlText(true);
        this.paramEnd  .enableControlText(true);

        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text  = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && this.outputs[0].types[0] == LIST_VALUE;

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}


class   OpUnique
extends OperatorBase
{
    paramCounts;

    length;



    constructor()
    {
        super(UNIQUE, 'unique', 'unique', iconUnique);

        this.canDisable        = true;
        this.showHeaderTooltip = true;
        

        this.addInput (new Input (LIST_VALUES));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));

        this.addParam(this.paramCounts = new ListParam('counts', 'counts', false, false, true));

        this.paramCounts.itemName  = '';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const length = values[paramIds.findIndex(id => id == 'length')];

        this.length = length.value;

        const sep = settings.showNodeId ? ' ' : '  ';
        this.paramCounts.setName('counts' + sep + '[ ' + this.length + ' ]');


        const type  = values[paramIds.findIndex(id => id == 'type'  )];

        if (type)
            this.outputs[0].types = [type.value];
    }



    updateParams()
    {
        this.paramCounts.enableControlText(false);

        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text  = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && this.outputs[0].types[0] == LIST_VALUE;

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}


class   OpReverseList
extends OperatorBase
{
    tableLength;



    constructor()
    {
        super(REVERSE_LIST, 'reverse', 'reverse', iconReverseList);

        this.canDisable        = true;
        this.showHeaderTooltip = true;
        

        this.addInput (new Input (LIST_VALUES));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        
        const length = values[paramIds.findIndex(id => id == 'length' )];

        this.tableLength = length.value;


        const type  = values[paramIds.findIndex(id => id == 'type'  )];

        if (type)
            this.outputs[0].types = [type.value];
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text  = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && this.outputs[0].types[0] == LIST_VALUE;

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}


class   OpSort
extends OperatorBase
{
    paramColumn;
    paramReverse;

    tableLength;

    menuBoolReverse;



    constructor()
    {
        super(SORT, 'sort', 'sort', iconSort);

        this.showHeaderTooltip = true;
        

        this.addInput (new Input (LIST_VALUES));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));

        this.addParam(this.paramColumn  = new NumberParam('column',  'column',  true, true, true, 0, 0));
        this.addParam(this.paramReverse = new NumberParam('reverse', 'reverse', true, true, true, 0, 0, 1));

        this.paramColumn.controls[0].allowEditDecimals = false;
        
        this.paramColumn.divider  = 0.59;
        this.paramReverse.divider = 0.59;

        this.menuBoolReverse = createBoolMenu(this.paramReverse);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramColumn .genRequest(gen));
        request.push(...this.node.paramReverse.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        //const column  = values[paramIds.findIndex(id => id == 'column')];

        const length  = values[paramIds.findIndex(id => id == 'length' )];
        const columns = values[paramIds.findIndex(id => id == 'columns')];

        this.tableLength = length.value;

        if (columns.value > 0)
            this.paramColumn.controls[0].setMax(columns.value-1);
        else
            this.paramColumn.controls[0].setMax();


        const type = values[paramIds.findIndex(id => id == 'type')];

        if (type)
            this.outputs[0].types = [type.value];
    }



    updateParams()
    {
        this.paramColumn .enableControlText(true);
        this.paramReverse.enableControlText(true);

        updateParamConditionText(this.paramReverse, this.paramReverse.isUnknown(), false, 1);

        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text  = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && this.outputs[0].types[0] == LIST_VALUE;

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}


class   OpColumn
extends OperatorBase
{
    paramIndex;

    columnLength;



    constructor()
    {
        super(COLUMN, 'column', 'column', iconColumn);

        this.iconOffsetY       = 1;
        this.showHeaderTooltip = true;
        

        this.addInput (new Input (LIST_VALUES));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));

        this.addParam(this.paramIndex = new NumberParam('index', 'index', true, true, true, 0, 0));

        this.paramIndex.divider                       = 0.54;
        this.paramIndex.controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramIndex.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        const type = values[paramIds.findIndex(id => id == 'type')];

        if (type)
            this.outputs[0].types = [type.value];

            
        const length  = values[paramIds.findIndex(id => id == 'length' )];
        const columns = values[paramIds.findIndex(id => id == 'columns')];


        this.columnLength = length ? length.value : 0;

        if (columns.value > 0)
            this.paramIndex.controls[0].setMax(columns.value-1);
        else
            this.paramIndex.controls[0].setMax();
    }



    updateParams()
    {
        this.paramIndex.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpCell
extends OperatorBase
{
    paramColumn;
    paramRow;

    columns;
    rows;



    constructor()
    {
        super(CELL, 'cell', 'cell', iconCell);

        //this.cached           = false;
        this.alwaysSaveParams  = true;
        this.iconOffsetY       = 1;
        this.showHeaderTooltip = true;


        this.addInput(new Input(LIST_VALUES, getNodeInputValuesForUndo));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));

        this.addParam(this.paramColumn = new NumberParam('column', 'column', true, true, false, 0, 0));
        this.addParam(this.paramRow    = new NumberParam('row',    'row',    true, true, false, 0, 0));

        this.paramColumn.controls[0].allowEditDecimals = false;
        this.paramRow   .controls[0].allowEditDecimals = false;
        
        this.paramColumn.divider                       = 0.55;
        this.paramRow   .divider                       = 0.55;


        this.columns = new NumberValue(0);
        this.rows    = new NumberValue(0);
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        return this.node.genRequest(gen);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramColumn.genRequest(gen));
        request.push(...this.paramRow   .genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        
        const type   = values[paramIds.findIndex(id => id == 'type'   )];
        this.columns = values[paramIds.findIndex(id => id == 'columns')];
        this.rows    = values[paramIds.findIndex(id => id == 'rows'   )];

        if (type)
            this.outputs[0].types = [type.value];
    }



    updateParams()
    {
        // super.updateParams();
        
        this.paramColumn.enableControlText(true);
        this.paramColumn.controls[0].setMax(Math.max(0, this.columns.value-1));

        this.paramRow.enableControlText(true);
        this.paramRow.controls[0].setMax(Math.max(0, this.rows.value-1));

        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
                this.active
            && !this.inputs[0].connected;

        colors.input  = gray ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = gray ? rgbFromType(ANY_VALUE, true) : rgbFromType(type, true);

        return colors;
    }
}


class   OpItems
extends ResizableBase
{
    scrollbar;
    scroll = 0;



    constructor()
    {
        super(ITEMS, 'items', 'items', iconItems);

        this.iconOffsetY = 1;


        this.addInput(new Input(LIST_VALUES));

        this.alwaysLoadParams = true;
        this.alwaysSaveParams = true;


        this.createScrollbar();

        
        // this.setRect(
        //     this.div.offsetLeft, 
        //     this.div.offsetTop, 
        //     this.div.offsetWidth, 
        //     this.div.offsetHeight, 
        //     false);
    }



    createScrollbar()
    {
        this.scrollbar = createDiv('itemsScroll');

        this.scrollbar.down = false;
        this.scrollbar.sy   = Number.NaN;
        this.scrollbar.spy  = Number.NaN;
        this.scrollbar.style.height = 0;

        this.div.appendChild(this.scrollbar);



        this.scrollbar.addEventListener('pointerdown', e =>
        {
            if (e.button == 0)
            {
                e.stopPropagation();

                try
                {
                    this.scrollbar.setPointerCapture(e.pointerId);

                    this.scrollbar.down = true;

                    this.scrollbar.sy  =  e.clientY;
                    this.scrollbar.spy = -this.scroll;
                }
                catch {}
            }
        });



        this.scrollbar.addEventListener('pointermove', e =>
        {
            if (this.scrollbar.down)
            {
                const totalHeight = this.measureData.divOffset.height - defHeaderHeight;

                const scrollHeight = 
                          (totalHeight - 10)
                        *  totalHeight / this.measureData.paramOffset.height;
        
                const max = 
                      this.measureData.innerOffset.height
                    - scrollHeight
                    - defHeaderHeight;

                this.scroll = -Math.min(Math.max(
                    0, 
                    this.scrollbar.spy + (e.clientY - this.scrollbar.sy)),
                    max);

                    
                this.updateScrollbar();


                const wires = [];

                for (const output of this.outputs.filter(o => o.param))
                {
                    for (const input of output.connectedInputs)
                        wires.push(input.connection.wire);
                }

                graphView.updateWires(wires);
            }
        });



        this.scrollbar.addEventListener('pointerup', e =>
        {
            if (e.button == 0)
            {
                e.stopPropagation();

                this.scrollbar.down = false;
                this.scrollbar.releasePointerCapture(e.pointerId);
            }
        });
    }



    // setSize(w, h, updateTransform = true)
    // {
    //     super.setSize(
    //         w, 
    //         Math.min(h, defHeaderHeight + this.params.length * defParamHeight), 
    //         updateTransform);

    //     this.updateScrollbar();
    //     this.updateNode();
    // }



    setRect(x, y, w, h, updateTransform = true)
    {
        super.setRect(
            x, 
            y, 
            Math.max(defNodeWidth, w), 
            Math.min(
                Math.max(defHeaderHeight, defHeaderHeight + this.params.length * defParamHeight),
                Math.max(h, defHeaderHeight)),
            updateTransform);

        this.updateScrollbar();
        this.updateNode();
    }



    // output_genRequest(gen)
    // {
        // 'this' is the output        

    //     return this.node.genRequest(gen);
    // }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const oldParams = [...this.params];

        const action = actionFromId(actionId);

        if (action)
            pushUnique(oldParams, action.oldOutputParams);


        this.disconnectParamsNotInList(paramIds, true);
        this.removeParamsNotInList(paramIds);


        if (   paramIds.length > 1
            ||    paramIds.length == 1 
               && paramIds[0] != '')
        {
            for (let i = 0; i < values.length; i++) 
            {
                const value   = values[i];
                const valueId = paramIds[i];
    
                if (valueId == 'value')
                    continue;

                    
                let param = oldParams.find(p => p.id == valueId);

                if (   param
                    && param.type != value.type)
                {
                    this.removeParam(param);
                    param = null;
                }

                if (!param)
                    this.createAndAddParamByType(value.type, valueId, true, false, true, true);
            }
        }

        else if (paramIds.length <= 1)
            this.removeAllParams();
    
        
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        this.setHeight(defHeaderHeight + this.params.length * defParamHeight, false);


        for (const param of this.params)
            param.divider = Math.min(120 / this.measureData.divOffset.width, 0.25);
    }



    updateParams()
    {
        for (const param of this.params)
            param.enableControlText(false);

        this.updateParamControls();
    }



    updateScrollbar()
    {
        const totalHeight = this.measureData.divOffset.height - defHeaderHeight;

        
        if (   isEmpty(this.params)
            || this.measureData.paramOffset.height <= totalHeight)
        {
            this.scrollbar.style.display = 'none';
        }
        else
        {
            this.scrollbar.style.display = 'block';
            
            this.scrollbar.style.left = this.measureData.divOffset.width - 20;
            this.scrollbar.style.top  = defHeaderHeight + 5 - this.scroll;

            this.scrollbar.style.height = Math.max(0,
                  (totalHeight - 10)
                *  totalHeight / this.measureData.paramOffset.height
                - 10);

            this.paramHolder.style.top = this.scroll;
        }
    }
}


class   OpSelect
extends OperatorBase
{
    paramIndex;

    length;



    constructor()
    {
        super(SELECT, 'select', 'select', iconSelect);

        this.alwaysSaveParams  = true;
        this.showHeaderTooltip = true;


        this.addInput(new Input(LIST_VALUES, getNodeInputValuesForUndo));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));

        this.addParam(this.paramIndex = new NumberParam('index', 'index', true, true, false, 0, 0));

        this.paramIndex.divider                       = 0.55;
        this.paramIndex.controls[0].allowEditDecimals = false;


        this.length = new NumberValue(0);
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        return this.node.genRequest(gen);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramIndex.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        
        this.length = values[paramIds.findIndex(id => id == 'length')];
        const type  = values[paramIds.findIndex(id => id == 'type'  )];

        if (type)
            this.outputs[0].types = [type.value];
    }



    updateParams()
    {
        // super.updateParams();
        
        this.paramIndex.enableControlText(true);
        this.paramIndex.controls[0].setMax(Math.max(0, this.length.value-1));

        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);
        const type   = this.outputs[0].types[0];

        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
                this.active
            && !this.inputs[0].connected;

        colors.input  = gray ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = gray ? rgbFromType(ANY_VALUE, true) : rgbFromType(type, true);

        return colors;
    }
}


class   OpListCount
extends OperatorBase
{
    paramValue;
    paramStart;


    
    constructor()
    {
        super(LIST_COUNT, 'count', 'count', iconCount);

        this.iconOffsetY = 1;


        this.addInput (new Input(LIST_VALUES));

        this.addParam(this.paramValue = new NumberParam('value', 'value', false, false, true, 0, 0));
        this.addParam(this.paramStart = new NumberParam('start', 'start', true,  true,  true, 1, 0, 1));


        this.paramStart.divider = 0.54;
        this.paramStart.controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        return this.node.genRequest(gen);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramStart.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());
        this.paramStart.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpContains
extends OperatorBase
{
    paramValue;
    paramFirst;
    paramLast;
    paramAll;



    constructor()
    {
        super(CONTAINS, 'contains', 'contains', iconContains);

        this.canDisable  = true;
        this.iconOffsetY = 1;
        

        this.addInput (new Input(LIST_VALUES));
        this.addInput (new Input([ANY_VALUE]));

        this.addParam(this.paramValue = new NumberParam('value', '',            false, false, true));
        this.addParam(this.paramFirst = new NumberParam('first', 'first index', true,  false, true));
        this.addParam(this.paramLast  = new NumberParam('last',  'last index',  true,  false, true));
        this.addParam(this.paramAll   = new   ListParam('all',   'all',         false, false, true));

        this.paramValue.isNodeValue = true;

        this.paramAll.itemName = '';

        this.paramFirst.divider = 0.62;
        this.paramLast .divider = 0.62;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.inputs[0];
        const input1 = this.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramAll.showCount = value.isValid();
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());
        this.paramFirst.enableControlText(false, this.isUnknown());
        this.paramLast .enableControlText(false, this.isUnknown());
        this.paramAll  .enableControlText(false, this.isUnknown());

        updateParamConditionText(this.paramValue, this.isUnknown(), true);

        this.updateParamControls();
    }
}


class   OpIfElse
extends OperatorBase
{
    paramCondition;


    menuBool;



    constructor()
    {
        super(IF_ELSE, 'ifElse', 'if/else', iconIfElse);

        this.iconOffsetY = -1;
        //this.cached = false;


        this.addInput (new Input ([ANY_VALUE]));
        this.addInput (new Input ([ANY_VALUE]));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));


        this.addParam(this.paramCondition = new NumberParam('condition', 'condition', true, true, true, 1, 0, 1));

        this.paramCondition.divider = 0.62;


        this.inputs[0].addEventListener('connect',    () => OpIfElse_onConnectInput(this, 0));
        this.inputs[0].addEventListener('disconnect', () => OpIfElse_onDisconnectInput(this, 0));

        this.inputs[1].addEventListener('connect',    () => OpIfElse_onConnectInput(this, 1));
        this.inputs[1].addEventListener('disconnect', () => OpIfElse_onDisconnectInput(this, 1));


        this.menuBool = createBoolMenu(this.paramCondition);
    }
    
    

    canAutoConnectFrom(output)
    {
        return true; //!getTerminalsAfterNode(this.node).find(n => n.inputs.canConnectFrom(output));
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
          if (   input0.connected
              && input1.connected) request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, 0, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, 1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);

        
        request.push(...this.node.paramCondition.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const type = values[paramIds.findIndex(id => id == 'type')];

        this.outputs[0].types = [type.value];
    }



    updateParams()
    {
        this.paramCondition.enableControlText(true);

        updateParamConditionText(this.paramCondition, this.paramCondition.isUnknown(), true, 1);


        if (this.outputs[0].supportsTypes([COLOR_VALUE]))
        {
            if (   this.inputs[0].connected
                && this.paramCondition.value.value > 0)
                this.outputs[0].wireColor = this.inputs[0].wireColor;
            else if (this.inputs[1].connected
                  && this.paramCondition.value.value == 0)
                this.outputs[0].wireColor = this.inputs[1].wireColor;
            else
                this.outputs[0].wireColor = rgbFromType(ANY_VALUE, true);
        }

        else if (this.outputs[0].supportsTypes([FILL_VALUE]))
        {
            const colors = this.getHeaderColors();

            if (   this.inputs[0].connected
                && this.paramCondition.value.value > 0)
                this.outputs[0].wireColor = colors.outputWire;
            else if (this.inputs[1].connected
                  && this.paramCondition.value.value == 0)
                this.outputs[0].wireColor = colors.outputWire;
            else
                this.outputs[0].wireColor = rgbFromType(ANY_VALUE, true);
        }
        
        else
            this.outputs[0].wireColor = rgbFromType(this.outputs[0].types[0], true);


        this.updateParamControls();
    }



    // updateHeader()
    // {
    //     super.updateHeader();


    //     const colors = super.getHeaderColors();

    //     const type =
    //         this.inputs[0].connected
    //         ? this.inputs[0].types[0]
    //         : this.inputs[1].connected
    //           ? this.inputs[1].types[0]
    //           : ANY_VALUE;


    //     if (COLOR_TYPES.includes(type))
    //     {
    //         colors.output =
    //             this.inputs[0].connected
    //             ? this.inputs[0].connectedOutput.wireColor
    //             : this.inputs[1].connected
    //               ? this.inputs[1].connectedOutput.wireColor
    //               : rgbFromType(IF_ELSE, true);

    //         colors.wire = colors.output;
    //     }
    // }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        const type =
            this.inputs[0].connected
            ? this.inputs[0].types[0]
            : this.inputs[1].connected
              ? this.inputs[1].types[0]
              : ANY_VALUE;


        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && (  !this.inputs[0].connected
                || arraysIntersect(this.inputs[0].connectedOutput.types, [ANY_VALUE, LIST_VALUE])
                || this.paramCondition.value.value == 0)
            && (  !this.inputs[1].connected
                || arraysIntersect(this.inputs[1].connectedOutput.types, [ANY_VALUE, LIST_VALUE])
                || this.paramCondition.value.value == 1);

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(ANY_VALUE, true);


        // let colorActive  = rgbFromType(type, true);
        // let colorPassive = rgbFromType(type, false);


        // if (NUMBER_TYPES.includes(type))
        // {
        //     colors.input  = this.active ? rgb_a(colorPassive, 0.55) : rgb_a(colorActive, darkMode ? 0.65 : 0.5);
        //     colors.output = this.active ? rgb_a(colorPassive, 0.5 ) : rgb_a(colorActive, darkMode ? 0.6  : 0.4);
        //     colors.wire   = colorActive;
        // }
        // else if (TEXT_TYPES.includes(type))
        // {
        //     colors.input  = this.active ? rgb_a(colorActive, 0.55) : rgb_a(darkMode ? colorActive : colorPassive, darkMode ? 0.55 : 1);
        //     colors.output = this.active ? rgb_a(colorActive, 0.45) : rgb_a(darkMode ? colorActive : colorPassive, darkMode ? 0.45 : 0.9);
        //     colors.wire   = colorActive;
        // }
        // else if (SHAPE_TYPES.includes(type))
        // {
        //     colors.input  = this.active ? rgb_a(colorPassive, 0.65) : rgb_a(colorActive, darkMode ? 0.6 : 0.5 );
        //     colors.output = this.active ? rgb_a(colorPassive, 0.65) : rgb_a(colorActive, darkMode ? 0.5 : 0.45);
        //     colors.wire   = colorActive;
        // }
        // else if (COLOR_TYPES.includes(type))
        // {
        //     if (   this.inputs[0].connected
        //         && this.inputs[1].connected)
        //     {
        //         colors.output = 
        //             this.paramCondition.value.value > 0
        //             ? this.inputs[0].connectedOutput.wireColor
        //             : this.inputs[1].connectedOutput.wireColor;
        //     }

        //     else if (this.inputs[0].connected
        //           && this.paramCondition.value.value > 0)
        //         colors.output = this.inputs[0].connectedOutput.wireColor;

        //     else if (this.inputs[1].connected
        //           && this.paramCondition.value.value == 0)
        //         colors.output = this.inputs[1].connectedOutput.wireColor;


        //     colors.wire = colors.output;
        // }
        // else if (FILL_TYPES.includes(type))
        // {
        //     if (   this.inputs[0].connected
        //         && this.inputs[1].connected)
        //     {
        //         const wireColor =
        //             this.paramCondition.value.value > 0
        //             ? this.inputs[0].connectedOutput.wireColor
        //             : this.inputs[1].connectedOutput.wireColor;

        //         colors.outputWire = wireColor;
        //         colors.output = rgbaLerp(
        //             rgb_a(getTextColorFromBackColor(rgbFromType(ANY_VALUE, true)), 0.3),
        //             wireColor,
        //             wireColor[3]);
        //     }

        //     else if (this.inputs[0].connected
        //           && this.paramCondition.value.value > 0)
        //     {
        //         const wireColor = this.inputs[0].connectedOutput.wireColor;

        //         colors.outputWire = wireColor;
        //         colors.output = rgbaLerp(
        //             rgb_a(getTextColorFromBackColor(rgbFromType(ANY_VALUE, true)), 0.3),
        //             wireColor,
        //             wireColor[3]);
        //     }
        //     else if (this.inputs[1].connected
        //           && this.paramCondition.value.value == 0)
        //     {
        //         const wireColor = this.inputs[1].connectedOutput.wireColor;

        //         colors.outputWire = wireColor;
        //         colors.output = rgbaLerp(
        //             rgb_a(getTextColorFromBackColor(rgbFromType(ANY_VALUE, true)), 0.3),
        //             wireColor,
        //             wireColor[3]);
        //     }


        //     colors.wire = colors.output;
        // }

        
        
        return colors;
    }
}



function OpIfElse_onConnectInput(node, inputIndex)
{
    const otherIndex = inputIndex == 0 ? 1 : 0;

    const firstInput = node.inputs[inputIndex];
    const otherInput = node.inputs[otherIndex];

    const firstOut   = firstInput.connectedOutput;
    const firstTypes = [...firstOut.types];
    

    firstInput.types     = [...firstTypes];
    firstInput.wireColor = [...firstOut.wireColor];

    
    if (!node.inputs[otherIndex].connected)
    {
        otherInput.types      = [...firstTypes];
        //otherInput.wireColor  = [...firstOut.wireColor];

        node.outputs[0].types = 
            firstTypes.includes(ANY_VALUE)
            ? [ANY_VALUE]
            : [...firstTypes];
    }

    
    for (const output of node.outputs)
        for (const input of output.connectedInputs)
            if (input.node.type == IF_ELSE)
                OpIfElse_onConnectInput(input.node, input.index);


    // if there is an outgoing connection from the node of a different type than
    // the incoming connection, delete the outgoing connection

    if (    node.outputs[0].connected
        && !node.outputs[0].connectedInputs[0].canConnectFrom(firstOut))
        node.outputs[0].connectedInputs.forEach(i => uiDisconnect(i));
}



function OpIfElse_onDisconnectInput(node, inputIndex)
{
    const otherIndex = inputIndex == 0 ? 1 : 0;
    
    const firstInput = node.inputs[inputIndex];
    //const firstOut   = firstInput.connectedOutput;

    const otherInput = node.inputs[otherIndex];
    const otherOut   = otherInput.connectedOutput;
    const otherTypes = otherOut ? otherOut.types : [];


    if (!node.inputs[otherIndex].connected)
        node.inputs[inputIndex].types = [ANY_VALUE];

    node.inputs[otherIndex].types = 
        otherInput.connected 
        ? [...otherTypes]
        : [ANY_VALUE];

    node.outputs[0].types = 
        otherInput.connected
        ? [...otherTypes]
        : [ANY_VALUE];


    // const connectedInputs = node.headerInputs.filter(i => i.connected);

    // if (connectedInputs.length == 1)
    // {
    //     const input = connectedInputs[0];

    //     uiDisconnect(input);

    //     // if (input.node.type == IF_ELSE)
    //     //     OpIfElse_onDisconnectInput(input.node, input.index);
    // }
    {
        for (const output of node.outputs)
            for (const input of output.connectedInputs)
                if (input.node.type == IF_ELSE)
                    OpIfElse_onConnectInput(input.node, input.index);
    }
}


class   OpNumber
extends OperatorBase
{
    paramValue;



    constructor()
    {
        super(NUMBER, 'num', 'number', '');

        this.addInput (new Input ([NUMBER_VALUE], getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));

        this.addParam(this.paramValue = new NumberParam('value', 'value', false, false, false));

        this.alwaysLoadParams = true;
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.node.paramValue.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == NUMBER_VALUE, 'expected NUMBER_VALUE in backInit()');
        
        this.node.paramValue.setValue(value, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });
        
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        if (input.connected) request.push(...pushInputOrParam(input, gen));
        else                 request.push(...this.node.paramValue.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        const input = this.inputs[0];
        
        this.paramValue.enableControlText(!input.connected);

        this.paramValue.controls[0].valueText =  this.isUnknown() ? UNKNOWN_DISPLAY : '';
        this.paramValue.controls[0].showBar   = !this.isUnknown();


        this.updateParamControls();
    }



    paramIsConsideredDefault(param)
    {
        return  param.isDefault()
            && !this.inputs[0].connected;
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';
        
        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;


        js += gen.NL + 'return ';
        js += conn ? 'input' : this.toJsCode(gen);
        js += ';'


        gen.nTab--;
        js += gen.NL + '}';


        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';


        return js;
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
             ? this.inputs[0].connectedOutput.toJsCode(gen)
             : this.paramValue.value.toJsCode(gen);
    }
}


class   OpSign
extends OperatorWithValue
{
    constructor()
    {
        super(NUMBER_SIGN, 'sign', 'sign', iconSign);

        this.canDisable  = true;
        this.iconOffsetY = 1;

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());

        this.updateParamControls();
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';

        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;
        
        
        js += gen.NL + 'return ';
        js += conn ? 'Math.sign(input)' : this.toJsCode();
        js += ';'


        gen.nTab--;
        js += gen.NL + '}';


        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';


        return js;
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
            ? 'Math.sign(' + this.inputs[0].connectedOutput.toJsCode(gen) + ')'
            : 'Number.NaN';
    }
}


class   OpAbsolute
extends OperatorWithValue
{
    constructor()
    {
        super(NUMBER_ABSOLUTE, 'abs', 'absolute', iconAbsolute);

        this.canDisable = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());

        this.updateParamControls();
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';

        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;
        
        
        js += gen.NL + 'return ';
        js += conn ? 'Math.abs(input)' : this.toJsCode();
        js += ';'


        gen.nTab--;
        js += gen.NL + '}';


        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';


        return js;
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
            ? 'Math.abs(' + this.inputs[0].connectedOutput.toJsCode(gen) + ')'
            : 'Number.NaN';
    }
}


class   OpRound
extends OperatorWithValue
{
    paramType;
    paramDecimals;



    constructor()
    {
        super(NUMBER_ROUND, 'round', 'round', iconRound);

        this.canDisable = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramType     = new SelectParam('type',     'type',     false, true,  true, ['floor', 'round', 'ceiling'], 1));
        this.addParam(this.paramDecimals = new NumberParam('decimals', 'decimals', true,  true,  true, 0, 0, 10));


        this.paramDecimals.divider = 0.61;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramType    .genRequest(gen));
        request.push(...this.node.paramDecimals.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue   .enableControlText(false, this.isUnknown());
        this.paramType    .enableControlText(true);
        this.paramDecimals.enableControlText(true);

        this.updateParamControls();
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';

        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;
        
        
        if (this.inputs[0].connected)
        {
            js += gen.NL + 'const input = ' + this.inputs[0].connectedOutput.toJsCode(gen) + ';';
            js += '\n';
            js += gen.NL + 'switch (' + this.paramType.toJsCode(gen) + ')';
            js += gen.NL + '{ ';
            js += gen.NL + TAB + 'case 0: return Math.floor(input);';
            js += gen.NL + TAB + 'case 1: return Math.round(input);';
            js += gen.NL + TAB + 'case 2: return Math.ceil (input);';
            js += gen.NL + '}';
        }
        else
            js += gen.NL + 'return Number.NaN;';


        gen.nTab--;
        js += gen.NL + '}';

        
        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input    = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';

        js += this.paramType    .input.toJsDef(gen);
        js += this.paramDecimals.input.toJsDef(gen);


        return js;
    }



    toJsCode(gen)
    {
        let js = '';


        if (this.inputs[0].connected)
        {
            js += '() => { ';

            js += 'const input = ' + this.inputs[0].connectedOutput.toJsCode(gen) + ';';
            js += ' ';

            js += 'switch (' + this.paramType.toJsCode(gen) + ')';
            js += ' {';
            js += ' case 0: return Math.floor(input);';
            js += ' case 1: return Math.round(input);';
            js += ' case 2: return Math.ceil(input);';
            js += ' }';


            js += ' }';
        }
        else
            js += 'Number.NaN';

      
        return js;
    }
}


class   OpMinMax
extends OperatorWithValue
{
    paramOperation;



    constructor()
    {
        super(NUMBER_MINMAX, 'minmax', 'min/max', iconMinMax);

        //this.iconOffsetY      = -1;

        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true, true, ['min', 'max'], 0));

        this.paramOperation.reverseMenu = true;
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input([NUMBER_VALUE, NUMBER_LIST_VALUE, LIST_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramOperation.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false, this.isUnknown());
        this.paramOperation.enableControlText(true);

        
        // switch (this.paramOperation.value.value)
        // {
        //     case 0: this.icon = iconSubtract; this.iconOffsetY = -2; break;
        //     case 1: this.icon = iconAdd;      this.iconOffsetY =  1; break;
        //     case 2: this.icon = iconModulo;   this.iconOffsetY =  1; break;
        //     case 3: this.icon = iconDivide;   this.iconOffsetY =  0; break;
        //     case 4: this.icon = iconMultiply; this.iconOffsetY =  2; break;
        //     case 5: this.icon = iconExponent; this.iconOffsetY = -2; break;
        // }

        // this.updateIcon();


        this.updateParamControls();
    }
}



class   OpLimits
extends OperatorWithValue
{
    paramMin;
    paramMax;



    constructor()
    {
        super(NUMBER_LIMITS, 'limits', 'limits', iconLimits);

        this.canDisable  = true;
        this.iconOffsetY = 1;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramMin = new NumberParam('min', 'min', true,  true,  true,    0));
        this.addParam(this.paramMax = new NumberParam('max', 'max', true,  true,  true, 1000));

        this.paramMin.divider = 0.42;
        this.paramMax.divider = 0.42;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramMin.genRequest(gen));
        request.push(...this.node.paramMax.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());
        this.paramMin  .enableControlText(true);
        this.paramMax  .enableControlText(true);

        this.updateParamControls();
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
             ? 'Math.min(Math.max(' 
                    + this.paramMin.toJsCode(gen) + ', ' + this.inputs[0].connectedOutput.toJsCode(gen) + '), ' 
                    + this.paramMax.toJsCode(gen) + ')'
             : 'Number.NaN';
    }
}


class   OpConstant
extends OperatorWithValue
{
    paramConstant;
    


    constructor()
    {
        super(NUMBER_CONSTANT, 'constant', 'constant', iconConstant);

        this.iconOffsetY = -3;


        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramConstant = new SelectParam('constant', 'constant', false, true, true, ['√2', 'e', 'φ', 'Φ', 'π', 'τ'], 4));

        this.paramConstant.reverseMenu = true;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramConstant.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue   .enableControlText(false, this.isUnknown());
        this.paramConstant.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpDateTime
extends OperatorBase
{
    paramSeconds;
    paramMinutes;
    paramHours;
    paramDayOfWeek;
    paramDate;
    paramMonth;
    paramYear;

    updateTimer = -1;



    constructor()
    {
        super(NUMBER_DATETIME, 'dateTime', 'date & time', iconDateTime);

        this.canDisable  = true;
        this.iconOffsetY = -4;
        

        this.addParam(this.paramHours     = new NumberParam('hours',     'hours',    true,  true,  true, 0, 0,  23));
        this.addParam(this.paramMinutes   = new NumberParam('minutes',   'minutes',  true,  true,  true, 0, 0,  59));
        this.addParam(this.paramSeconds   = new NumberParam('seconds',   'seconds',  true,  true,  true, 0, 0,  59));
        this.addParam(this.paramDayOfWeek = new NumberParam('dayOfWeek', 'week day', true,  true,  true, 1, 1,   7));
        this.addParam(this.paramDate      = new NumberParam('date',      'date',     true,  true,  true, 1, 1,  31));
        this.addParam(this.paramMonth     = new NumberParam('month',     'month',    true,  true,  true, 1, 1,  12));
        this.addParam(this.paramYear      = new NumberParam('year',      'year',     true,  true,  true));


        this.setAllParamDividers(0.56);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.paramSeconds  .genRequest(gen));
        request.push(...this.paramMinutes  .genRequest(gen));
        request.push(...this.paramHours    .genRequest(gen));
        request.push(...this.paramDayOfWeek.genRequest(gen));
        request.push(...this.paramDate     .genRequest(gen));
        request.push(...this.paramMonth    .genRequest(gen));
        request.push(...this.paramYear     .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    
    updateParams()
    {
        this.paramSeconds  .enableControlText(false);
        this.paramMinutes  .enableControlText(false);
        this.paramHours    .enableControlText(false);
        this.paramDayOfWeek.enableControlText(false);
        this.paramDate     .enableControlText(false);
        this.paramMonth    .enableControlText(false);
        this.paramYear     .enableControlText(false);

        this.paramDate.controls[0].setMax(daysInMonth(
            this.paramMonth.value.value,
            this.paramYear .value.value));

        this.updateParamControls();
    }



    updateNode()
    {
        super.updateNode();


        if (this.updateTimer >= 0) 
            clearTimeout(this.updateTimer);


        if (this.enabled)
        {
            const dateTime = new Date();

            const seconds   = dateTime.getSeconds();
            const minutes   = dateTime.getMinutes();
            const hours     = dateTime.getHours();
            const dayOfWeek = dateTime.getDay();
            const date      = dateTime.getDate();
            const month     = dateTime.getMonth()+1;
            const year      = dateTime.getFullYear();

            this.paramSeconds  .setValue(new NumberValue(seconds),   false, true, false);
            this.paramMinutes  .setValue(new NumberValue(minutes),   false, true, false);
            this.paramHours    .setValue(new NumberValue(hours),     false, true, false);
            this.paramDayOfWeek.setValue(new NumberValue(dayOfWeek), false, true, false);
            this.paramDate     .setValue(new NumberValue(date),      false, true, false);
            this.paramMonth    .setValue(new NumberValue(month),     false, true, false);
            this.paramYear     .setValue(new NumberValue(year),      false, true, false);
            
            this.updateTimer = setTimeout(() => this.updateNode(), 100);
        }
    }



    toJsCode(gen)
    {
        return '';
    }
}


class   OpDefine
extends OperatorBase
{
    paramValues;



    constructor()
    {
        super(DEFINE, 'define', 'define', iconDefine);

        this.cached         = false;
        //this.iconOffsetY    = 1;
        this.variableInputs = true;

        
        this.addNewInput();
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));
    }



    addNewInput()
    {
        const newInput = new Input(ALL_VALUES);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const type = values[paramIds.findIndex(id => id == 'type')];

        this.outputs[0].types = [type.value];
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        
        const type = this.outputs[0].types[0];


        // const back = rgb_a(rgbFromType(type, this.active), 0.95);

        // colors.back = back;


        colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const gray =
               this.active
            && this.outputs[0].types[0] == ANY_VALUE;

        colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output = gray        ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire   = rgbFromType(type, true);

        return colors;
    }
}



class   OpRange
extends OperatorBase
{
    paramFrom;
    paramStart;
    paramEnd;
    paramSpread;
    paramBias;



    constructor()
    {
        super(NUMBER_RANGE, 'range', 'range', iconRange);

        this.cached     = false;
        this.canDisable = true;
        

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));


        this.addParam(this.paramFrom   = new SelectParam('from',   'from',   true, true, true, ['start', 'middle', 'end'], 1));
        this.addParam(this.paramStart  = new NumberParam('start',  'start',  true, true, true, 0));
        this.addParam(this.paramEnd    = new NumberParam('end',    'end',    true, true, true, 100));
        this.addParam(this.paramSpread = new SelectParam('spread', 'spread', true, true, true, ['even', 'curve', 'spread']));
        this.addParam(this.paramBias   = new NumberParam('bias',   'bias',   true, true, true, 0, -100, 100));


        this.paramBias.controls[0].suffix = '%';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramFrom  .genRequest(gen));
        request.push(...this.node.paramStart .genRequest(gen));
        request.push(...this.node.paramEnd   .genRequest(gen));
        request.push(...this.node.paramSpread.genRequest(gen));
        request.push(...this.node.paramBias  .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpSequence
extends OperatorBase
{
    paramStart;
    paramStep;
    paramEnd;



    constructor()
    {
        super(NUMBER_SEQUENCE, 'sequence', 'sequence', iconSequence);

        this.cached      =  false;
        this.iconOffsetY = -1;
        this.canDisable  =  true;
        

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramStart = new NumberParam('start', '[ start', true, true, true,  0));
        this.addParam(this.paramStep  = new NumberParam('step',  'step',    true, true, true, 10));
        this.addParam(this.paramEnd   = new NumberParam('end',   '] end',   true, true, true, Number.NaN));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramStart.genRequest(gen));
        request.push(...this.node.paramStep .genRequest(gen));
        request.push(...this.node.paramEnd  .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramStart.enableControlText(true, this.paramStart.isUnknown());
        this.paramStep .enableControlText(true, this.paramStep .isUnknown());
        this.paramEnd  .enableControlText(true, this.paramEnd  .isUnknown());

        this.updateParamControls();
    }
}


class   OpRandom
extends OperatorBase
{
    paramSeed;
    paramMin;
    paramMax;
    paramUnique;



    constructor()
    {
        super(NUMBER_RANDOM, 'random', 'random', iconRandom);

        this.cached      = false;
        this.iconOffsetY = 1;
        this.canDisable  = true;

        
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramSeed   = new NumberParam('seed',   'seed',   true, true, true, Math.floor(Math.random() * 10000), 0, 0x7fffffff));
        this.addParam(this.paramMin    = new NumberParam('min',    'min',    true, true, true,   0));
        this.addParam(this.paramMax    = new NumberParam('max',    'max',    true, true, true, 255));
        this.addParam(this.paramUnique = new NumberParam('unique', 'unique', true, true, true, 0, 0, 100));

        this.paramSeed.controls[0].allowEditDecimals = false;
        this.paramSeed.isDefault = () => false;

        this.paramUnique.controls[0].suffix = '%';
        this.paramUnique.controls[0].max    = 200;
    }



    isSet()
    {
        return true;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramSeed  .genRequest(gen));
        request.push(...this.node.paramMin   .genRequest(gen));
        request.push(...this.node.paramMax   .genRequest(gen));
        request.push(...this.node.paramUnique.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpNoise
extends OperatorBase
{
    paramSeed;
    paramMin;
    paramMax;
    paramScale;
    paramOffset;
    paramInterpolate;
    paramDetail;



    constructor()
    {
        super(NUMBER_NOISE, 'noise', 'noise', iconNoise);

        this.cached      = false;
        //this.iconOffsetY = 1;
        this.canDisable  = true;

        
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramSeed        = new NumberParam('seed',        'seed',    true,  true, true, Math.floor(Math.random() * 10000), 0, 0x7fffffff));
        this.addParam(this.paramMin         = new NumberParam('min',         'min',     true,  true, true,   0));
        this.addParam(this.paramMax         = new NumberParam('max',         'max',     true,  true, true, 255));
        this.addParam(this.paramScale       = new NumberParam('scale',       'scale',   true,  true, true, 1, 1));
        this.addParam(this.paramOffset      = new NumberParam('offset',      'offset',  true,  true, true, 0, 0));
        this.addParam(this.paramInterpolate = new SelectParam('interpolate', 'blend',   true,  true, true, ['step', 'linear', 'cosine'], 2));
        this.addParam(this.paramDetail      = new NumberParam('detail',      'detail',  true,  true, true, 1, 1));

        this.paramSeed.controls[0].allowEditDecimals = false;
        this.paramSeed.isDefault = () => false;

        this.paramScale .controls[0].setDecimals(1);
        this.paramOffset.controls[0].setDecimals(1);
        this.paramDetail.controls[0].allowEditDecimals = false;

        this.setAllParamDividers(0.45);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramSeed       .genRequest(gen));
        request.push(...this.node.paramMin        .genRequest(gen));
        request.push(...this.node.paramMax        .genRequest(gen));
        request.push(...this.node.paramScale      .genRequest(gen));
        request.push(...this.node.paramOffset     .genRequest(gen));
        request.push(...this.node.paramInterpolate.genRequest(gen));
        request.push(...this.node.paramDetail     .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpProbability
extends OperatorBase
{
    paramSeed;
    paramChance;



    constructor()
    {
        super(NUMBER_PROBABILITY, 'prob', 'probability', iconProbability);

        this.cached      = false;
        this.iconOffsetY = -2;
        this.canDisable  = true;

        
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramSeed   = new NumberParam('seed',   'seed',   true,  true, true, Math.floor(Math.random() * 10000), 0, 0x7fffffff));
        this.addParam(this.paramChance = new NumberParam('chance', 'chance', true,  true, true, 50, 0, 100));

        this.paramSeed.controls[0].allowEditDecimals = false;
        this.paramSeed.isDefault = () => false;

        this.paramChance.controls[0].suffix = '%';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramSeed  .genRequest(gen));
        request.push(...this.node.paramChance.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpAccumulate
extends OperatorBase
{
    paramWhen;



    constructor()
    {
        super(NUMBER_ACCUMULATE, 'accum', 'accumulate', iconAccumulate);

        this.cached      = false;
        this.iconOffsetY = 1;
        this.canDisable  = true;
        

        this.addInput (new Input ([NUMBER_VALUE]));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramWhen = new SelectParam('when', 'when', false, true, true, ['before', 'after'], 0));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramWhen.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpInterpolate
extends OperatorWithValue
{
    paramAmount;
    


    constructor()
    {
        super(NUMBER_INTERPOLATE, 'inter', 'interpolate', iconInterpolate);

        this.iconOffsetY = -2;


        this.addInput(new Input(NUMBER_TYPES));
        this.addInput(new Input(NUMBER_TYPES));

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramAmount = new NumberParam('amount', 'amount', false, true, true, 50, 0, 100, 0));

        
        this.paramAmount.controls[0].min = Number.MIN_SAFE_INTEGER; // allow
        this.paramAmount.controls[0].max = Number.MAX_SAFE_INTEGER; // extrapolation
        
        this.paramAmount.controls[0].setSuffix('%', true);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramAmount.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue .enableControlText(false, this.isUnknown());
        this.paramAmount.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpNumberToText
extends OperatorBase
{
    paramValue;
    paramFormat;



    constructor()
    {
        super(NUMBER_TO_TEXT, 'numToText', 'to text', iconNumberToText);


        this.addInput(new Input([NUMBER_VALUE]));

        this.addParam(this.paramValue   = new TextParam ('value',  'value',  false, false, true));
        this.addParam(this.paramFormat = new SelectParam('format', 'format', false, true,  true, ['decimal', 'hexadecimal']));

        this.paramValue.isNodeValue = true;

        setControlFont(this.paramValue.controls[0].textbox, 'Roboto Mono', 10, 'center');
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramFormat.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());
        //this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramFormat.enableControlText(true, this.paramFormat.isUnknown());

        this.updateParamControls();
    }
}


class   OpSolve
extends OperatorBase
{
    paramCurrent;
    paramTarget;



    constructor()
    {
        super(NUMBER_SOLVE, 'solve', 'solve', iconSolve, defNodeWidth, true);

        this.subscription = true;
        this.canDisable   = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.inputs[0].feedback = true;


        this.addParam(this.paramCurrent = new NumberParam('current', 'current', true,  true,  true, Number.NaN));
        this.addParam(this.paramTarget  = new NumberParam('target',  'target',  true,  true,  true));


        this.paramCurrent.divider = 0.5;
        this.paramTarget .divider = 0.5;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCurrent.genRequest(gen));
        request.push(...this.node.paramTarget .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        this.endProgress();
    }



    updateParams()
    {
        if (!this.paramCurrent.input.connected)
            this.paramCurrent.setValue(NumberValue.NaN, null, true, false);

        this.paramCurrent.enableControlText(false, this.isUnknown());
        this.paramTarget .enableControlText(true);

        this.updateParamControls();
    }



    toJsCode(gen)
    {
        return '';//this.inputs[0].connected
            //  ? 'Math.min(Math.max(' 
            //         + this.paramCurrent.toJsCode(gen) + ', ' + this.inputs[0].connectedOutput.toJsCode(gen) + '), ' 
            //         + this.paramTarget.toJsCode(gen) + ')'
            //  : 'Number.NaN';
    }
}


class   OpAnimate
extends OperatorBase //WithValue
{
    paramFrom;
    paramTo
    paramCurve;
    paramRepeat;
    paramLength;
    paramTime;


    btnPlay;

    playing = false;

    startTime;
    paramTimeStart = 0;
    //prevTime;



    constructor()
    {
        super(NUMBER_ANIMATE, 'anim', 'animate', '');


        this.subscription = true;
        this.iconOffsetY  = -1;
        //this.cached = false;
        

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        //this.addParam(this.paramValue);
        this.addParam(this.paramFrom   = new NumberParam('from',   'from',   true,  true, true, 0, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 0));
        this.addParam(this.paramTo     = new NumberParam('to',     'to',     true,  true, true, 1, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 0));
        this.addParam(this.paramRepeat = new SelectParam('repeat', 'repeat', false, true, true, ['once', 'repeat', 'ping-pong']));
        this.addParam(this.paramCurve  = new SelectParam('curve',  'curve',  true,  true, true, ['step', 'linear', 'ease in', 'ease out', 'smooth'], 1));
        this.addParam(this.paramLength = new NumberParam('length', 'length', true,  true, true, 5, 0, Number.MAX_SAFE_INTEGER, 0));
        this.addParam(this.paramTime   = new NumberParam('time',   'time',   true,  true, true, 0, 0, Number.MAX_SAFE_INTEGER, 1));


        this.paramLength.controls[0].suffix = ' sec';
        this.paramTime  .controls[0].suffix = ' sec';


        this.btnPlay      = createDiv('btnAnimatePlay');
        this.btnPlay.over = false;
        this.btnPlay.down = false;


        this.btnPlay.addEventListener('pointerenter', e => 
        { 
            this.btnPlay.over = true;  
            this.updateHeader(); 
        });


        this.btnPlay.addEventListener('pointerleave', e => 
        { 
            this.btnPlay.over = false; 
            this.updateHeader(); 
        });


        this.btnPlay.addEventListener('pointerdown',  e => 
        { 
            e.stopPropagation();

            if (e.button == 0)
            {
                hideAllMenus();

                this.playing = !this.playing;
                this.updateHeader();


                if (this.playing) // start playback
                {
                    this.startTime      = Date.now();
                    this.paramTimeStart = this.paramTime.value.value;

                    let   time   = this.paramTimeStart + (Date.now() - this.startTime) / 1000;
                    const length = this.paramLength.value.value;

                    if (time >= length)
                    {
                        this.paramTime.setValue(new NumberValue(0), false, false, false);
                        this.paramTimeStart = 0;
                    }
                        
                    this.updatePlayback();
                }
            }
            else
                e.preventDefault();
        });


        this.label.insertBefore(this.btnPlay, this.labelText);


        this.paramFrom  .divider = 0.48;
        this.paramTo    .divider = 0.48;
        this.paramRepeat.divider = 0.48;
        this.paramCurve .divider = 0.48;
        this.paramLength.divider = 0.48;
        this.paramTime  .divider = 0.48;


        this.paramTime.controls[0].addEventListener('change', e =>
        {
            if (this.playing)
            {
                this.startTime      = Date.now();
                this.paramTimeStart = this.paramTime.value.value;
            }
        });
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramFrom  .genRequest(gen));
        request.push(...this.node.paramTo    .genRequest(gen));
        request.push(...this.node.paramCurve .genRequest(gen));
        request.push(...this.node.paramRepeat.genRequest(gen));
        request.push(...this.node.paramLength.genRequest(gen));
        request.push(...this.node.paramTime  .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    // updateValues(requestId, actionId, updateParamId, paramIds, values)
    // {
    //     super.updateValues(requestId, actionId, updateParamId, paramIds, values);

    //     // if (this.playing)
    //     //     this.updatePlayback();
    // }



    updateParams()
    {
        //this.paramValue .enableControlText(false);
        this.paramFrom  .enableControlText(true, this.paramFrom  .isUnknown());
        this.paramTo    .enableControlText(true, this.paramTo    .isUnknown());
        this.paramCurve .enableControlText(true, this.paramCurve .isUnknown());
        this.paramRepeat.enableControlText(true, this.paramRepeat.isUnknown());
        this.paramLength.enableControlText(true, this.paramLength.isUnknown());
        this.paramTime  .enableControlText(true, this.paramTime  .isUnknown());

        this.paramTime.controls[0].setMax(this.paramLength.value.value);
        //this.paramTime.controls[0].setDecimals(this.paramLength.controls[0].decimals);

        this.updateParamControls();
    }



    updateHeader()
    {
        super.updateHeader();

        this.updatePlayIcon();
    }



    updatePlayIcon()
    {
        const colors = this.getHeaderColors();

        const headerStyle = rgba2style(
            rgb_a(
                colors.text, 
                this.btnPlay.down 
                ? 1 
                : this.btnPlay.over
                  ? 1 
                  : 0.5));

        this.btnPlay.style.display            = 'inline-block';
        this.btnPlay.style.background         = !this.playing
                                                ? 'url(\'data:image/svg+xml;utf8,<svg width="9" height="13" viewBox="0 0 9 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 6.5L1.47008e-07 13L7.15256e-07 -3.93402e-07L9 6.5Z" fill="'+headerStyle+'"/></svg>\')'
                                                : 'url(\'data:image/svg+xml;utf8,<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="9" fill="'+headerStyle+'"/></svg>\')';

        this.btnPlay.style.backgroundPosition = '50% 50%';
        this.btnPlay.style.backgroundRepeat   = 'no-repeat';
    }



    updatePlayback(update = true)
    {
        let   time   = this.paramTimeStart + (Date.now() - this.startTime) / 1000;
        const length = this.paramLength.value.value;


        switch (this.paramRepeat.value.value)
        {
            case 0:
                if (time >= length)
                {
                    time = length;
                    this.playing = false;
                    this.updatePlayIcon();
                }
                
                break;

            case 1:
                if (time > length)
                    time %= length;

                break;

            case 2:
                if (Math.floor(time / length) % 2 > 0)
                    time = length - (time % length);
                if (time > length)
                    time %= length;

                break;
        }


        this.paramTime.setValue(
            new NumberValue(
                time, 
                this.paramTime.controls[0].decimals),
            false);

        
        if (update)
            pushUpdate(null, [this], false);
    }
}


class   OpMath
extends OperatorWithValue
{
    paramOperation;



    constructor()
    {
        super(NUMBER_MATH, 'math', 'math', '');

        this.iconOffsetY      = -1;

        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true, true, MATH_OPS.map(s => s[1]), 1));

        this.paramOperation.reverseMenu = true;
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input([NUMBER_VALUE, NUMBER_LIST_VALUE, LIST_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramOperation.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false, this.isUnknown());
        this.paramOperation.enableControlText(true);

        
        switch (this.paramOperation.value.value)
        {
            case 0: this.icon = iconSubtract; this.iconOffsetY = -2; break;
            case 1: this.icon = iconAdd;      this.iconOffsetY =  1; break;
            case 2: this.icon = iconModulo;   this.iconOffsetY =  1; break;
            case 3: this.icon = iconDivide;   this.iconOffsetY =  0; break;
            case 4: this.icon = iconMultiply; this.iconOffsetY =  2; break;
            case 5: this.icon = iconExponent; this.iconOffsetY = -2; break;
        }

        this.updateIcon();


        this.updateParamControls();
    }
}



class   OpSimpleMath
extends OperatorWithValue
{
    paramOperation;
    paramOperand;



    constructor()
    {
        super(NUMBER_SIMPLE_MATH, 'math', 'math', '');

        this.iconOffsetY      = -1;
        this.alwaysLoadParams = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '',        false, true, true, MATH_OPS.map(s => s[1]), 1));
        this.addParam(this.paramOperand   = new NumberParam('operand',   'operand', false, true, true, 0));


        this.paramOperation.reverseMenu = true;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramOperation.genRequest(gen));
        request.push(...this.node.paramOperand  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false, this.isUnknown());
        this.paramOperation.enableControlText(true);
        this.paramOperand  .enableControlText(true);

        
        switch (this.paramOperation.value.value)
        {
            case 0: this.icon = iconSubtract; this.iconOffsetY = -2; break;
            case 1: this.icon = iconAdd;      this.iconOffsetY =  1; break;
            case 2: this.icon = iconModulo;   this.iconOffsetY =  1; break;
            case 3: this.icon = iconDivide;   this.iconOffsetY =  0; break;
            case 4: this.icon = iconMultiply; this.iconOffsetY =  2; break;
            case 5: this.icon = iconExponent; this.iconOffsetY = -2; break;
        }

        this.updateIcon();


        this.updateParamControls();
    }
}


class   OpArithmetic
extends OperatorWithValue
{
    constructor(type, id, name, icon)
    {
        super(type, id, name, icon);
        
        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input([NUMBER_VALUE, NUMBER_LIST_VALUE, LIST_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            

        const connectedInputs = this.node.inputs.filter(i => i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
                
        this.paramValue.controls[0].valueText =  this.isUnknown() ? UNKNOWN_DISPLAY : '';
        this.paramValue.controls[0].showBar   = !this.isUnknown();

        this.updateParamControls();
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}


class   OpAdd
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_ADD, 'add', 'add', iconAdd);

        this.iconOffsetY = 1;
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' + ');
        
        js += ')';


        return js;
    }
}


class   OpSubtract
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_SUBTRACT, 'sub', 'subtract', iconSubtract);

        this.iconOffsetY = -2;
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' - ');
        
        js += ')';

        
        return js;
    }
}


class   OpMultiply
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_MULTIPLY, 'mul', 'multiply', iconMultiply);

        this.iconOffsetY = 2;
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' * ');
        
        js += ')';

        
        return js;
    }
}


class   OpDivide
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_DIVIDE, 'div', 'divide', iconDivide);

        this.iconOffsetY = 0;
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' / ');
        
        js += ')';

        
        return js;
    }
}


class   OpModulo
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_MODULO, 'rem', 'remainder', iconModulo);

        this.iconOffsetY = 1;
    }
    
    
    
    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' % ');
        
        js += ')';

        
        return js;
    }
}


class   OpExponent
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_EXPONENT, 'pow', 'power', iconExponent);

        this.iconOffsetY = -2;
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';


        this.connectedHeaderInputs
            .forEach(i => 
            {
                js += 'Math.pow(';
                js += i.connectedOutput.toJsCode(gen);
                js += ', ';
            });

        this.connectedHeaderInputs
            .forEach(i => ')');

        
        return js;
    }
}


class   OpBoolean
extends OperatorWithValue
{
    paramOperation;



    constructor()
    {
        super(NUMBER_BOOLEAN, 'bool', 'boolean', '');

        this.iconOffsetY      = -1;

        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true, true, BOOLEAN_OPS.map(s => s[1]), 3));


        this.paramOperation.reverseMenu = true;
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input([NUMBER_VALUE, NUMBER_LIST_VALUE, LIST_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramOperation.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false, this.isUnknown());
        this.paramOperation.enableControlText(true);

        updateParamConditionText(this.paramValue, this.paramValue.isUnknown(), true, 1);


        switch (this.paramOperation.value.value)
        {
            case 0: this.icon = iconNot; this.iconOffsetY = -1; break;
            case 1: this.icon = iconXor; this.iconOffsetY =  2; break;
            case 2: this.icon = iconOr;  this.iconOffsetY =  1; break;
            case 3: this.icon = iconAnd; this.iconOffsetY =  1; break;
        }

        this.updateIcon();


        this.updateParamControls();
    }
}


class   OpBooleanBase
extends OperatorWithValue
{
    constructor(type, id, name, icon)
    {
        super(type, id, name, icon);

        
        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input([NUMBER_VALUE, NUMBER_LIST_VALUE, LIST_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            

        const connectedInputs = this.node.inputs.filter(i => i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        

        const v = Math.round(this.paramValue.value.value);

             if (this.isUnknown())        this.paramValue.controls[0].valueText = UNKNOWN_DISPLAY;
        else if (settings.showBoolValues
              && !isNaN(v))               this.paramValue.controls[0].valueText = v != 0 ? getTrueDisplay() : getFalseDisplay();
        else                              this.paramValue.controls[0].valueText = '';


        this.paramValue.controls[0].text.style.fontStyle = 
               settings.showBoolValues 
            && this.paramValue.value.isValid()
            ? 'normal' 
            : 'italic';


        //this.paramValue.controls[0].text.style.letterSpacing = settings.showBoolValues ? '0.1em' : 0; // this is if "true" and "false" are used
        
        this.paramValue.controls[0].showBar = !this.isUnknown();


        this.updateParamControls();
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}



class   OpNot
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_NOT, 'not', 'not', iconNot);

        this.iconOffsetY = -1;
    }
}


class   OpAnd
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_AND, 'and', 'and', iconAnd);

        this.iconOffsetY = 1;
    }
}


class   OpOr
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_OR, 'or', 'or', iconOr);

        this.iconOffsetY = 1;
    }
}


class   OpXor
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_XOR, 'xor', 'xor', iconXor);

        this.iconOffsetY = 2;
    }
}


class   OpCondition
extends OperatorWithValue
{
    paramOperation;
    paramOperand;



    constructor()
    {
        super(NUMBER_CONDITION, 'cond', 'condition', '');
        
        this.iconOffsetY = -1;


        this.addInput(new Input([NUMBER_VALUE]));

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true, true, CONDITION_OPS.map(s => s[1]), 3));
        this.addParam(this.paramOperand   = new NumberParam('operand',   'operand', false, true, true, 0));

        this.paramOperation.reverseMenu = true;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];

        
        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramOperation.genRequest(gen));
        request.push(...this.node.paramOperand  .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramOperation.enableControlText(true);
        this.paramOperand  .enableControlText(true);

        updateParamConditionText(this.paramValue, this.paramValue.isUnknown(), true);


        switch (this.paramOperation.value.value)
        {
            case 0: this.icon = iconLess;           this.iconOffsetY = 1; break;
            case 1: this.icon = iconLessOrEqual;    this.iconOffsetY = 0; break;
            case 2: this.icon = iconNotEqual;       this.iconOffsetY = 2; break;
            case 3: this.icon = iconEqual;          this.iconOffsetY = 0; break;
            case 4: this.icon = iconGreaterOrEqual; this.iconOffsetY = 0; break;
            case 5: this.icon = iconGreater;        this.iconOffsetY = 1; break;
        }

        this.updateIcon();


        this.updateParamControls();
    }
}



function updateParamConditionText(param, unknown, color = true, offsetY = 0)
{
    const v = Math.round(param.value.value);

         if (unknown)        param.controls[0].valueText = UNKNOWN_DISPLAY;
    else if (settings.showBoolValues
          && !isNaN(v))      param.controls[0].valueText = '<span style="position: relative; top: ' + offsetY + 'px">' + (v != 0 ? getTrueDisplay(color) : getFalseDisplay(color)) + '</span>';
    else                     param.controls[0].valueText = '';

    param.controls[0].showBar = !settings.showBoolValues;//unknown;
}


class   OpConditionBase
extends OperatorWithValue
{
    constructor(type, id, name, icon)
    {
        super(type, id, name, icon)

        this.alwaysLoadParams = true;

        
        this.addInput(new Input([NUMBER_VALUE]));
        this.addInput(new Input([NUMBER_VALUE]));

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);


        const v = Math.round(this.paramValue.value.value);

             if (this.isUnknown())       this.paramValue.controls[0].valueText = UNKNOWN_DISPLAY;
        else if (settings.showBoolValues
              && !isNaN(v))              this.paramValue.controls[0].valueText = v != 0 ? getTrueDisplay() : getFalseDisplay();
        else                             this.paramValue.controls[0].valueText = '';


        this.paramValue.controls[0].text.style.fontStyle = 
               settings.showBoolValues 
            && this.paramValue.controls[0].valueText != UNKNOWN_DISPLAY
            ? 'normal' 
            : 'italic';


        this.paramValue.controls[0].showBar = !this.isUnknown();


        this.updateParamControls();
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}


class   OpEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_EQUAL, 'equal', 'equal', iconEqual);
    }
}


class   OpNotEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_NOT_EQUAL, 'notEqual', 'not equal', iconNotEqual);

        this.iconOffsetY = 2;
    }
}


class   OpLess
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_LESS, 'less', 'less', iconLess);

        this.iconOffsetY = 1;
    }
}


class   OpLessOrEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_LESS_OR_EQUAL, 'lessOrEqual', 'less or equal', iconLessOrEqual);
    }
}


class   OpGreater
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_GREATER, 'greater', 'greater', iconGreater);

        this.iconOffsetY = 2;
    }
}


class   OpGreaterOrEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_GREATER_OR_EQUAL, 'greaterOrEqual', 'greater or equal', iconGreaterOrEqual);

        this.iconOffsetY = 1;
    }
}


class   OpTrig
extends OperatorWithValue
{
    paramFunction;



    constructor()
    {
        super(NUMBER_TRIG, 'trig', 'trigonometric', iconSine);

        this.canDisable       = true;
        this.alwaysLoadParams = true;

        
        this.addInput(new Input([NUMBER_VALUE]));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramFunction = new SelectParam('function', '', false, true, true, TRIG_OPS.map(s => s[1]), 0));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramFunction.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue   .enableControlText(false, this.isUnknown());
        this.paramFunction.enableControlText(true);


        switch (this.paramFunction.value.value)
        {
            case 0: this.icon = iconSine;    break;
            case 1: this.icon = iconCosine;  break;
            case 2: this.icon = iconTangent; break;
        }

        this.updateIcon();


        this.updateParamControls();
    }
}


class   OpTrigBase
extends OperatorWithValue
{
    constructor(type, id, name, icon)
    {
        super(type, id, name, icon)

        this.canDisable       = true;
        this.alwaysLoadParams = true;

        
        this.addInput(new Input([NUMBER_VALUE]));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class OpSine
extends OpTrigBase
{
    constructor()
    {
        super(NUMBER_SIN, 'sin', 'sin', iconSine);
    }
}


class OpCosine
extends OpTrigBase
{
    constructor()
    {
        super(NUMBER_COS, 'cos', 'cos', iconCosine);
    }
}


class OpTangent
extends OpTrigBase
{
    constructor()
    {
        super(NUMBER_TAN, 'tan', 'tan', iconTangent);
    }
}


class   OpText
extends ResizableBase
{
    paramValue;



    constructor()
    {
        super(TEXT, 'text', 'text', '');


        this.addInput (new Input (TEXT_TYPES, getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));

        this.addParam(this.paramValue = new TextParam('value', 'value', false, false, false));

        this.paramValue.controls[0].textbox.defPlaceholder = '...';
        setControlFont(this.paramValue.controls[0].textbox, 'Roboto Mono', 10, 'center');
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        super.setRect(x, y, w, h, updateTransform);
        this.updateValueParam();
    }

    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return this.node.paramValue.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == TEXT_VALUE, 'expected TEXT_VALUE in backInit()');
        
        this.node.paramValue.setValue(value, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });
        
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        if (input.connected) request.push(...pushInputOrParam(input, gen));
        else                 request.push(...this.node.paramValue.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(true, this.isUnknown());

        this.updateParamControls();
        
        this.updateValueParam();
    }



    updateValueParam()
    {
        this.paramValue.div.style.width  = this.div.offsetWidth;
        this.paramValue.div.style.height = this.div.offsetHeight - Math.max(defHeaderHeight, this.header.offsetHeight);    
    }



    paramIsConsideredDefault(param)
    {
        return  param.isDefault()
            && !this.inputs[0].connected;
    }
}


class   OpTextLength
extends OperatorBase
{
    paramLength;



    constructor()
    {
        super(TEXT_LENGTH, 'length', 'length', iconTextLength);


        this.addInput(new Input([TEXT_VALUE]));

        this.addParam(this.paramLength = new NumberParam('length', 'length', false, false, true));

        this.paramLength.isNodeValue = true;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        this.paramLength.enableControlText(false, this.isUnknown());

        this.updateParamControls();
    }
}


class   OpTextTrim
extends OperatorWithValue
{
    paramStart;
    paramEnd;



    constructor()
    {
        super(TEXT_TRIM, 'trim', 'trim', iconTextTrim);

        this.canDisable = true;
        

        this.addInput (new Input ([TEXT_VALUE]));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramStart = new TextParam('start', 'start', false, true, true, ''));
        this.addParam(this.paramEnd   = new TextParam('end',   'end',   false, true, true, ''));


        setControlFont(this.paramValue.controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramStart.controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramEnd  .controls[0].textbox, 'Roboto Mono', 10, 'center');

        this.paramStart.controls[0].textbox.defPlaceholder = 'start';
        this.paramEnd  .controls[0].textbox.defPlaceholder = 'end';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramStart.genRequest(gen));
        request.push(...this.node.paramEnd  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(true);
        this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramStart.enableControlText(true);
        this.paramEnd  .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextSubstring
extends OperatorWithValue
{
    paramStart;
    paramEnd;



    constructor()
    {
        super(TEXT_SUBSTRING, 'substring', 'substring', iconTextSubstring);

        this.canDisable  = true;
        this.iconOffsetY = 1;
        

        this.addInput (new Input ([TEXT_VALUE]));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramStart = new NumberParam('start', '[ start', true, true, true, 0, 0));
        this.addParam(this.paramEnd   = new NumberParam('end',   '] end',   true, true, true, 0, 0));


        ///this.paramValue.controls[0].textbox.defPlaceholder = '';

        setControlFont(this.paramValue.controls[0].textbox, 'Roboto Mono', 10, 'center');

        this.paramStart.controls[0].allowEditDecimals = false;
        this.paramEnd  .controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramStart.genRequest(gen));
        request.push(...this.node.paramEnd  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        const length = values[paramIds.findIndex(id => id == 'length')];

        if (length.value > 0)
        {
            this.paramStart.controls[0].setMax(length.value);
            this.paramEnd  .controls[0].setMax(length.value);
        }
        else
        {
            this.paramStart.controls[0].setMax();
            this.paramEnd  .controls[0].setMax();
        }
    }



    updateParams()
    {
        this.paramValue.enableControlText(true, this.isUnknown());
        // this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramStart.enableControlText(true);
        this.paramEnd  .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextContains
extends OperatorBase
{
    paramValue;
    paramFirst;
    paramLast;
    paramAll;



    constructor()
    {
        super(TEXT_CONTAINS, 'contains', 'contains', iconTextContains);

        this.canDisable  = true;
        this.iconOffsetY = 0;
        

        this.addInput (new Input([TEXT_VALUE]));
        this.addInput (new Input([TEXT_VALUE]));

        this.addParam(this.paramValue = new NumberParam('value', '',            false, false, true));
        this.addParam(this.paramFirst = new NumberParam('first', 'first index', true,  false, true));
        this.addParam(this.paramLast  = new NumberParam('last',  'last index',  true,  false, true));
        this.addParam(this.paramAll   = new   ListParam('all',   'all',        false, false, true));

        this.paramValue.isNodeValue = true;

        this.paramAll.itemName = '';

        this.paramFirst.divider = 0.62;
        this.paramLast .divider = 0.62;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.inputs[0];
        const input1 = this.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramAll.showCount = value.isValid();
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        this.paramFirst.enableControlText(false);
        this.paramLast .enableControlText(false);
        this.paramAll  .enableControlText(false);

        updateParamConditionText(this.paramValue, this.paramValue.isUnknown(), true);

        this.updateParamControls();
    }
}


class   OpTextCase
extends OperatorWithValue
{
    paramCase;



    constructor()
    {
        super(TEXT_CASE, 'case', 'case', '');

        this.canDisable = true;
        

        this.addInput (new Input ([TEXT_VALUE]));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramCase = new SelectParam('case', 'case', false, true, true, ['lower', 'First capital', 'All Capitals', 'UPPER'], 1));

        setControlFont(this.paramValue.controls[0].textbox, 'Roboto Mono', 10, 'center');
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCase.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(true, this.isUnknown());
        // this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramCase.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextCharacter
extends OperatorWithValue
{
    paramCode;



    constructor()
    {
        super(TEXT_CHAR, 'codeToChar', 'to char', '');

        this.iconOffsetY = 2;


        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramCode = new NumberParam('code', 'unicode', true,  true,  true, 65, 0, 0xFFFF));


        this.paramCode.controls[0].showHex           = true;
        this.paramCode.controls[0].allowEditDecimals = false;
        
        this.paramCode.divider = 0.56;

        setControlFont(this.paramCode.controls[0].divValue, 'Roboto Mono', 10, 'center');
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCode.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramCode .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextReplace
extends OperatorWithValue
{
    paramWhat;
    paramWith;



    constructor()
    {
        super(TEXT_REPLACE, 'replace', 'replace', iconTextReplace);

        this.canDisable       = true;
        this.iconOffsetY      = -2;
        
        this.alwaysLoadParams = true;
        this.alwaysSaveParams = true;
        

        this.addInput (new Input (TEXT_TYPES));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramWhat = new TextParam('what', 'what', false, true, true));
        this.addParam(this.paramWith = new TextParam('with', 'with', false, true, true));

        this.paramWhat.controls[0].textbox.defPlaceholder = 'what';
        this.paramWith.controls[0].textbox.defPlaceholder = 'with';

        setControlFont(this.paramValue.controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramWhat .controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramWith .controls[0].textbox, 'Roboto Mono', 10, 'center');
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramWhat.genRequest(gen));
        request.push(...this.node.paramWith.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(true, this.isUnknown());
        // this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramWhat.enableControlText(true);
        this.paramWith.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextJoin
extends ResizableOperatorWithValue
{
    paramWith;



    constructor()
    {
        super(TEXT_JOIN, 'join', 'join', iconTextJoin);

        this.variableInputs   = true;
        this.alwaysLoadParams = true;

        this.addNewInput();
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramWith = new TextParam('with', 'with', false, true, true));

        this.paramWith.controls[0].textbox.defPlaceholder = 'with';


        setControlFont(this.paramValue.controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramWith .controls[0].textbox, 'Roboto Mono', 10, 'center');
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input([TEXT_VALUE, TEXT_LIST_VALUE, LIST_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    // setSize(w, h, updateTransform = true)
    // {
    //     const headerHeight = boundingRect(this.header).height / graph.currentPage.zoom;

    //     const height =
    //         settings.showOperationResults
    //         ? Math.max(headerHeight + 2 * defParamHeight, h)
    //         : headerHeight + defParamHeight;

    //     super.setSize(
    //         w, 
    //         height,
    //         updateTransform);

    //     this.updateValueParam();
    // }



    setRect(x, y, w, h, updateTransform = true)
    {
        const headerHeight = boundingRect(this.header).height / graph.currentPage.zoom;

        const height =
            settings.showOperationResults
            ? Math.max(headerHeight + 2 * defParamHeight, h)
            : headerHeight + 2 * defParamHeight;

        super.setRect(
            x, 
            y, 
            w, 
            height, 
            updateTransform);

        this.updateValueParam();
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

            
        request.push(...this.node.paramWith.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(true, this.isUnknown());
        this.updateValueParam();

        this.updateParamControls();
    }



    updateValueParam()
    {
        const headerHeight = boundingRect(this.header).height / graph.currentPage.zoom;

        const totalParamHeight = 
              this.div.offsetHeight 
            - Math.max(defHeaderHeight, headerHeight);

        const hWith  = defParamHeight;
        const hValue = Math.max(defParamHeight, totalParamHeight - hWith);

        this.paramValue.div.style.width  = this.div.offsetWidth;
        this.paramValue.div.style.height = hValue;    

        this.paramWith.div.style.width  = this.div.offsetWidth;
        this.paramWith.div.style.height = hWith;    
    }
}



class   OpTextPad
extends OperatorWithValue
{
    paramStartPad;
    paramStartCount;
    paramEndPad;
    paramEndCount;



    constructor()
    {
        super(TEXT_PAD, 'pad', 'pad', iconTextPad);

        this.canDisable = true;
        

        this.addInput (new Input ([TEXT_VALUE]));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramStartPad   = new   TextParam('startPad',   'start', false, true, true));
        this.addParam(this.paramStartCount = new NumberParam('startCount', 'start', true,  true, true, 0, 0));
        this.addParam(this.paramEndPad     = new   TextParam('endPad',     'end',   false, true, true));
        this.addParam(this.paramEndCount   = new NumberParam('endCount',   'end',   true,  true, true, 0, 0));


        setControlFont(this.paramValue   .controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramStartPad.controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramEndPad  .controls[0].textbox, 'Roboto Mono', 10, 'center');
        
        this.paramStartPad.controls[0].textbox.defPlaceholder = 'start';
        this.paramEndPad  .controls[0].textbox.defPlaceholder = 'end';

        this.paramStartCount.controls[0].allowEditDecimals = false;
        this.paramEndCount  .controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramStartPad  .genRequest(gen));
        request.push(...this.node.paramStartCount.genRequest(gen));
        request.push(...this.node.paramEndPad    .genRequest(gen));
        request.push(...this.node.paramEndCount  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(true, this.isUnknown());
        // this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramStartPad  .enableControlText(true);
        this.paramStartCount.enableControlText(true);
        this.paramEndPad    .enableControlText(true);
        this.paramEndCount  .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextSplit
extends OperatorBase
{
    paramValue;
    paramSeparator;



    constructor()
    {
        super(TEXT_SPLIT, 'split', 'split', iconTextSplit);


        this.addInput(new Input([TEXT_VALUE]));

        this.addParam(this.paramValue     = new ListParam('value',     '',          false, false, true));
        this.addParam(this.paramSeparator = new TextParam('separator', 'separator', false, true,  true, ''));


        this.paramValue.itemName    = 'value';
        this.paramValue.isNodeValue =  true;

        setControlFont(this.paramSeparator.controls[0].textbox, 'Roboto Mono', 10, 'center');

        this.paramSeparator.controls[0].textbox.defPlaceholder = 'with';
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramSeparator.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());
        this.paramSeparator.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextCompare
extends OperatorBase
{
    paramResult;
    paramOperation;



    constructor()
    {
        super(TEXT_COMPARE, 'compare', 'compare', iconTextCompare);

        this.canDisable  = true;
        this.iconOffsetY = 1;
        

        this.addInput (new Input([TEXT_VALUE]));
        this.addInput (new Input([TEXT_VALUE]));

        this.addParam(this.paramResult    = new NumberParam('result',    '', false, false, true));
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true,  true, CONDITION_OPS.map(s => s[1]), 3));

        this.paramResult   .isNodeValue = true;
        this.paramOperation.reverseMenu = true;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.inputs[0];
        const input1 = this.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.paramOperation.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        switch (this.paramOperation.value.value)
        {
            case 0: this.icon = iconLess;           this.iconOffsetY = 1; break;
            case 1: this.icon = iconLessOrEqual;    this.iconOffsetY = 0; break;
            case 2: this.icon = iconNotEqual;       this.iconOffsetY = 2; break;
            case 3: this.icon = iconEqual;          this.iconOffsetY = 0; break;
            case 4: this.icon = iconGreaterOrEqual; this.iconOffsetY = 0; break;
            case 5: this.icon = iconGreater;        this.iconOffsetY = 1; break;
        }

        this.updateIcon();


        this.paramResult   .enableControlText(false);
        this.paramOperation.enableControlText(true );

        updateParamConditionText(this.paramResult, this.paramResult.isUnknown(), true);

        
        this.updateParamControls();
    }
}


class   OpTextCSV
extends OperatorBase
{
    paramValue;
    paramRowSeparator;
    paramColumnSeparator;



    constructor()
    {
        super(TEXT_CSV, 'csv', 'csv', iconTextCSV);

        this.iconOffsetY       = 1;
        this.showHeaderTooltip = true;


        this.addInput(new Input([TEXT_VALUE]));

        this.addParam(this.paramValue           = new ListParam  ('value',           'table',     false, false, true));
        this.addParam(this.paramRowSeparator    = new TextParam  ('rowSeparator',    'rows', true , true,  true, '\\n'));
        this.addParam(this.paramColumnSeparator = new TextParam  ('columnSeparator', 'columns', true , true,  true, ','));

        this.paramValue.itemName = '';

        this.paramRowSeparator   .divider = 0.6;
        this.paramColumnSeparator.divider = 0.6;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramRowSeparator   .genRequest(gen));
        request.push(...this.paramColumnSeparator.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const rows    = values[paramIds.findIndex(id => id == 'rows'   )];
        const columns = values[paramIds.findIndex(id => id == 'columns')];

        this.paramValue.setName('[ ' + columns.value + ' × ' + rows.value + ' ]');
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());
        
        this.paramRowSeparator   .enableControlText(true );
        this.paramColumnSeparator.enableControlText(true );

        this.updateParamControls();
    }
}


class   OpTextJson
extends OperatorBase
{
    paramValue;

    length;



    constructor()
    {
        super(TEXT_JSON, 'json', 'json', iconTextJson);

        this.subscription      = true;
        this.iconOffsetY       = 1;
        this.showHeaderTooltip = true;


        this.addInput(new Input([TEXT_VALUE]));

        this.addParam(this.paramValue = new ListParam('value', 'values', false, false, true));

        this.paramValue.itemName = '';
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const length = values[paramIds.findIndex(id => id == 'length')];

        this.paramValue.setName('values [ ' + length.value + ' ]');
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);

        this.updateParamControls();
    }
}


class   OpTextFetch
extends ResizableOperatorWithValue
{
    paramRequest;

    cachedValue = '';



    constructor()
    {
        super(TEXT_FETCH, 'fetch', 'fetch', iconTextFetch, defNodeWidth, true);

        this.subscription      = true;
        this.canDisable        = true;
        this.iconOffsetY       = -1;
        this.alwaysLoadParams  = true;
        this.alwaysSaveParams  = true;
        this.showHeaderTooltip = true;


        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramRequest = new TextParam('request', 'request', false, true, true));


        setControlFont(this.paramValue  .controls[0].textbox, 'Roboto Mono', 10, 'center');
        setControlFont(this.paramRequest.controls[0].textbox, 'Roboto Mono', 10, 'center');

        this.paramRequest.controls[0].textbox.defPlaceholder = 'request';
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        const headerHeight = Math.max(defHeaderHeight, boundingRect(this.header).height / graph.currentPage.zoom);

        const height =
            settings.showOperationResults
            ? Math.max(headerHeight + 2 * defParamHeight, h)
            : headerHeight + 2 * defParamHeight;

        super.setRect(
            x, 
            y, 
            w, 
            height, 
            updateTransform);

        this.updateValueParam();
    }

    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramRequest.genRequest(gen));
        request.push(TEXT_VALUE, encodeURIComponent(this.node.cachedValue));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.cachedValue = value.value;
        
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        this.endProgress();
    }



    updateParams()
    {
        this.paramValue.enableControlText(true, this.isUnknown());
        // this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramRequest.enableControlText(true);

        this.updateValueParam();

        this.updateParamControls();
    }



    updateValueParam()
    {
        const totalHeight = 
              this.div.offsetHeight 
            - Math.max(defHeaderHeight, this.header.offsetHeight);

        const hRequest = defParamHeight;
        const hValue   = totalHeight - hRequest;

        this.paramValue.div.style.width    = this.div.offsetWidth;
        this.paramValue.div.style.height   = hValue;    

        this.paramRequest.div.style.width  = this.div.offsetWidth;
        this.paramRequest.div.style.height = hRequest;    
    }



    invalidate()
    {
        this.cachedValue = '';

        super.invalidate();
    }
}


class   OpTextFile
extends ResizableBase
{
    file        = null;
    cachedValue = '';
 
    paramPath;




    constructor()
    {
        super(TEXT_FILE, 'file', 'file', iconTextFile, defNodeWidth, true);

        this.subscription      = true;
        this.canDisable        = true;
        this.iconOffsetY       = -1;
        this.alwaysLoadParams  = true;
        this.alwaysSaveParams  = true;
        this.showHeaderTooltip = true;
        this.alwaysShowIcon    = true;


        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramPath = new TextParam('path', 'path', false, false, true));

        setControlFont(this.paramPath.controls[0].textbox, 'Roboto Mono', 10, 'center');

        this.paramPath.controls[0].textbox.defPlaceholder = 'path';


        this.divIcon.style.opacity       = 0.5;
        this.divIcon.style.pointerEvents = 'all';


        this.divIcon.addEventListener('pointerenter', e => 
        { 
            this.divIcon.style.opacity = 1;  
        });


        this.divIcon.addEventListener('pointerleave', e => 
        { 
            this.divIcon.style.opacity = 0.5;  
        });


        this.divIcon.addEventListener('pointerdown',  e => 
        { 
            this.divIcon.style.opacity = 0.5;  
            e.stopPropagation();


            getLocalFile(file => 
            {
                const filePath = new TextValue(
                    file.path != '' 
                    ? file.path 
                    : file.name);

                this.file = file;
                this.paramPath.setValue(filePath, false, true);
                this.updateCachedValue(true);
            });
            

            setTimeout(() => 
            {
                this.divIcon.style.opacity = 1;  
                this.updateHeader(); 
            },
            200);
        });
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        const height = defHeaderHeight + defParamHeight;

        super.setRect(
            x, 
            y, 
            w, 
            height, 
            updateTransform);
    }

    
    
    updateCachedValue(update)
    {
        if (this.file)
        {
            const reader = new FileReader();
            reader.readAsText(this.file,'UTF-8');

            reader.onload = e => 
            {
                this.cachedValue = e.target.result;

                if (update)
                    pushUpdate(null, [this]);
            };
        }
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        // if (this.node.cachedValue == '')
        //     this.node.updateCachedValue(true);


        request.push(TEXT_VALUE, encodeURIComponent(this.node.cachedValue));
        request.push(...this.node.paramPath.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        //const value = values[paramIds.findIndex(id => id == 'value')];

        //this.cachedValue = value.value;
        
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        this.endProgress();
    }



    updateParams()
    {
        this.paramPath.enableControlText(false);

        this.updateParamControls();
    }



    // invalidate()
    // {
    //     //this.cachedValue = '';

    //     super.invalidate();
    // }



    // loadParams(_node, pasting)
    // {
    //     if (_node.path != undefined)
    //         this.paramPath.setValue(parseTextValue(_node.path)[0], false, true);

    //     super.loadParams(_node, pasting);
    // }
}


class   OpTextToNumber
extends OperatorBase
{
    paramValue;
    paramFormat;



    constructor()
    {
        super(TEXT_TO_NUMBER, 'textToNum', 'to number', iconTextToNumber);


        this.addInput(new Input([TEXT_VALUE]));

        this.addParam(this.paramValue  = new NumberParam('value',  'value',  false, false, true));
        this.addParam(this.paramFormat = new SelectParam('format', 'format', false, true,  true, ['decimal', 'hexadecimal']));

        this.paramValue.isNodeValue = true;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramFormat.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        this.paramValue .enableControlText(false, this.isUnknown());
        this.paramFormat.enableControlText(true);

        this.paramValue.controls[0].showHex = this.paramFormat.value.value > 0;

        this.updateParamControls();
    }
}


class   OpTextToColor
extends OperatorBase
{
    paramValue;



    constructor()
    {
        super(TEXT_TO_COLOR, 'textToColor', 'to color', iconTextToColor);


        this.addInput(new Input([TEXT_VALUE]));

        this.addParam(this.paramValue = new ColorParam('value', 'value', false, false, true));

        this.paramValue.isNodeValue = true;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false, this.isUnknown());

        this.updateParamControls();
    }
}


class OpColorBase
extends Operator
{
    _color = dataColor_NaN;

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;
    


    constructor(type, id, name, icon, progressBar = false, defWidth = defNodeWidth)
    {
        super(type, id, name, icon, defWidth, progressBar);

        this.showActiveArrow = true;
        

        this._warningOverlay = createDiv('colorWarningOverlay');
        //this._warningOverlay.style.zIndex = 1;
        
        this.inner.appendChild(this._warningOverlay);


        this.header.addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.header.addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });
    }



    // invalidate()
    // {
    //     super.invalidate();

    //     //this._color = dataColor_NaN;
    // }



    // updateValues(requestId, actionId, updateParamId, paramIds, values)
    // {
    //     //logFunction('OpColorBase.updateValues()');

    //     super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
    //     //this.updateHeader();
    // }



    canAutoConnectFrom(output)
    {
        return this.inputs[0].canConnectFrom(output);
    }



    updateHeader()
    {
        //console.log(this.id + '.OpColorBase.updateHeader()');

        super.updateHeader();


        const colors = this.getHeaderColors();

        this.header.style.background = 
            !rgbIsNaN(colors.stripeBack) //  rgbIsOk(colors.back)
            ? rgb2style(colors.stripeBack)
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));
            //: 'transparent';

        // this.colorBack.style.backgroundImage = 
        //     this.isUnknown()
        //     ? 'url(\'data:image/svg+xml;utf8,<svg width="8" height="13" viewBox="0 0 8 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.65341V8.54545C3.00758 7.84091 3.07765 7.2803 3.21023 6.86364C3.34659 6.44697 3.53977 6.10985 3.78977 5.85227C4.03977 5.5947 4.34091 5.35985 4.69318 5.14773C4.92045 5.00379 5.125 4.8428 5.30682 4.66477C5.48864 4.48674 5.63258 4.2822 5.73864 4.05114C5.8447 3.82008 5.89773 3.56439 5.89773 3.28409C5.89773 2.94697 5.81818 2.6553 5.65909 2.40909C5.5 2.16288 5.28788 1.97348 5.02273 1.84091C4.76136 1.70455 4.4697 1.63636 4.14773 1.63636C3.85606 1.63636 3.57765 1.69697 3.3125 1.81818C3.04735 1.93939 2.82765 2.12879 2.65341 2.38636C2.47917 2.64015 2.37879 2.9678 2.35227 3.36932H0.625C0.651515 2.6875 0.823864 2.11174 1.14205 1.64205C1.46023 1.16856 1.88068 0.810606 2.40341 0.568181C2.92992 0.325757 3.51136 0.204545 4.14773 0.204545C4.8447 0.204545 5.45455 0.335227 5.97727 0.596591C6.5 0.854166 6.9053 1.21591 7.19318 1.68182C7.48485 2.14394 7.63068 2.68371 7.63068 3.30114C7.63068 3.72538 7.56439 4.10795 7.43182 4.44886C7.29924 4.78598 7.10985 5.08712 6.86364 5.35227C6.62121 5.61742 6.32955 5.85227 5.98864 6.05682C5.66667 6.25758 5.4053 6.46591 5.20455 6.68182C5.00758 6.89773 4.86364 7.15341 4.77273 7.44886C4.68182 7.74432 4.63258 8.10985 4.625 8.54545V8.65341H3ZM3.85795 12.108C3.54735 12.108 3.2803 11.9981 3.05682 11.7784C2.83333 11.5549 2.72159 11.286 2.72159 10.9716C2.72159 10.661 2.83333 10.3958 3.05682 10.1761C3.2803 9.95265 3.54735 9.84091 3.85795 9.84091C4.16477 9.84091 4.42992 9.95265 4.65341 10.1761C4.88068 10.3958 4.99432 10.661 4.99432 10.9716C4.99432 11.1799 4.94129 11.3712 4.83523 11.5455C4.73295 11.7159 4.59659 11.8523 4.42614 11.9545C4.25568 12.0568 4.06629 12.108 3.85795 12.108Z" fill="white"/></svg>\')'
        //     : 'none';


        // this.colorBack.style.boxShadow =
        //     this.isUnknown()
        //     ? '0 0 0 1px ' + rgb2style(colors.border) + ' inset'
        //     : 'none';


        for (const input of this.headerInputs)
        {
            input.colorLight =
            input.colorDark  = colors.input;

            input.wireColor  = colors.wire;
        }


        for (const output of this.headerOutputs)
        {
            output.colorLight = 
            output.colorDark  = colors.output;

            output.wireColor  = colors.wire;
        }


        this.updateWarningOverlay();
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        const colors = this.getHeaderColors();
        this.label.style.color = rgba2style(colors.text);
    }



    getHeaderColors(options = {})
    {
        const noColor = 
            darkMode
            ? rgbNoColorDark
            : rgbNoColorLight;


        const rgbBack = 
            dataColorIsNaN(this._color)
            ? rgb_NaN
            : dataColor2rgb(this._color);
            

        let rgbStripeBack = getStripeBackColor(rgbBack);
        

        const rgbaBorder = rgb_a(rgbFromType(this.type, this.active), 0.95);

        const rgbText  = getTextColorFromBackColor(rgbStripeBack);

        const rgbaWire = 
            !rgbIsNaN(rgbStripeBack)   
            ? rgbStripeBack 
            : noColor;

        return {
            back:       rgb_a(rgbBack), 
            stripeBack: rgb_a(rgbStripeBack),
            border:     rgbaBorder,
            text:       rgb_a(rgbText, 0.9),
            input:      rgb_a(rgbText, 0.2),
            output:     rgb_a(rgbText, 0.2),
            wire:       rgbaWire };
    }



    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const colors = this.getHeaderColors();
        

        if (!rgbaIsNaN(colors.back))
        {
            if (  !rgbIsValid(colors.back)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(colors.back);

                this.updateWarningOverlayStyle(colors.back);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(colors.back);
            this.updateWarningOverlayStyle(colors.back);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        this._warningOverlay.style.height = 
            height < 0
            ? this.measureData.headerOffset.height
            : height;

            
        const [warnStyle1, warnStyle2] = getWarningStyles(colBack);

        this._warningOverlay.style.background =
                rgbaIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : getWarningGradient(7.8, warnStyle1, warnStyle2);

            this._warningOverlay.style.backgroundPosition = '-6px 0';
            this._warningOverlay.style.backgroundSize     = 'calc(100% + 11px) 100%';
            this._warningOverlay.style.display            = 'block';
    }
}


class   OpColor
extends OpColorBase
{
    paramSpace;
    param1;
    param2;
    param3;
    paramColor;

    colorBack;


    prevSpace;
    prevSpaceConnections = [];


    _colorBeforeNaN = dataColor_NaN;



    constructor(options = {})
    {
        super(COLOR, 'color', 'color', iconColor);

        this.canDisable = true;

        
        const defColor = ['hex', 0.85, 0.85, 0.85];

        this._color = 
            !!options.random
            ? ['hex', Math.random(), Math.random(), Math.random()]
            : [...defColor];
        
        this.prevSpace = 'hex';


        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES, getColorInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest, getColorOutputValuesForUndo, this.output_backInit));

        
        this.addParam(this.paramSpace = new SelectParam('space', 'space', false, true,  true,  ColorSpaces.map(s => s[1]), 0));
        this.addParam(this.param1     = new NumberParam('c1',    '',      true,  true,  true));
        this.addParam(this.param2     = new NumberParam('c2',    '',      true,  true,  true));
        this.addParam(this.param3     = new NumberParam('c3',    '',      true,  true,  true));
        
        this.addParam(this.paramColor = new ColorParam ('color', '',      false, false, false, ColorValue.fromRgb(scaleRgb(dataColor2rgb(this._color)))));


        this.paramSpace.alwaysSaveValue = true;
        this.param1    .alwaysSaveValue = true;
        this.param2    .alwaysSaveValue = true;
        this.param3    .alwaysSaveValue = true;

        this.param1.controls[0].epsilon = ColorEpsilon;
        this.param2.controls[0].epsilon = ColorEpsilon;
        this.param3.controls[0].epsilon = ColorEpsilon;

        this.paramSpace.backStyleDark  =
        this.paramSpace.backStyleLight = 'transparent';

        
        this.paramColor.showColorBack  = false;


        this.paramSpace.controls[0].delayUse = 100; // so that you carelessly drag it by grabbing the space param
                                                    // while already moving the mouse with an aim to drag
        this.paramSpace.input.outputMustBeCached = true;

        this.paramSpace.addEventListener('change', () => 
        {
            if (this.paramSpace.value.toNumber() == 0)
            {
                if (this.param1.output.connected) this.param1.output.connectedInputs.forEach(i => uiDisconnect(i));
                if (this.param2.output.connected) this.param2.output.connectedInputs.forEach(i => uiDisconnect(i));
                if (this.param3.output.connected) this.param3.output.connectedInputs.forEach(i => uiDisconnect(i));

                if (this.param1.input.connected) uiDisconnect(this.param1.input);
                if (this.param2.input.connected) uiDisconnect(this.param2.input);
                if (this.param3.input.connected) uiDisconnect(this.param3.input);
            }
        });


        this.param1.setValue(new NumberValue(roundTo(this._color[1] * rgbFactor[0], this.param1.controls[0].decimals)), false, true, false);
        this.param2.setValue(new NumberValue(roundTo(this._color[2] * rgbFactor[1], this.param2.controls[0].decimals)), false, true, false);
        this.param3.setValue(new NumberValue(roundTo(this._color[3] * rgbFactor[2], this.param3.controls[0].decimals)), false, true, false);


        this.paramSpace.controls[0].barTop = 0.8;

        this.paramSpace.controls[0].addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.paramSpace.controls[0].addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });


        this.paramSpace.controls[0].wheelScale = 1;
        this.param1    .controls[0].wheelScale = 1;
        this.param2    .controls[0].wheelScale = 1;
        this.param3    .controls[0].wheelScale = 1;


        this.param1.isNodeValue = true;
        this.param2.isNodeValue = true;
        this.param3.isNodeValue = true;


        // hex is default, remove default sliders
        this.paramHolder.removeChild(this.param1.div);
        this.paramHolder.removeChild(this.param2.div);
        this.paramHolder.removeChild(this.param3.div);

        
        this.paramColor.addEventListener('change', () => 
        {
            this._color = this.paramColor.value.toDataColor();

            this.param1.setValue(new NumberValue(this._color[1] * rgbFactor[0]), false, true, false);
            this.param2.setValue(new NumberValue(this._color[2] * rgbFactor[1]), false, true, false);
            this.param3.setValue(new NumberValue(this._color[3] * rgbFactor[2]), false, true, false);
        });


        this.setAllParamDividers(0.45);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.node.paramColor.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        if (value.type == FILL_VALUE)
            value = value.color;


        consoleAssert(value.type == COLOR_VALUE, 'expected COLOR_VALUE in backInit()');

        const _color = convertDataColorToSpace(
            value.toDataColor(), 
            colorSpace(this.node.paramSpace.value.value));

        const _value = ColorValue.fromDataColor(_color);

        //this.node.paramSpace.setValue(value.space, false, true, false);
        this.node.param1.setValue(_value.c1, false, true, false);
        this.node.param2.setValue(_value.c2, false, true, false);
        this.node.param3.setValue(_value.c3, false, true, false);
    }



    getDataColorFromParams()
    {
        const col = getNormalColor_(
            colorSpace(this.paramSpace.value),
            this.param1.value,
            this.param2.value,
            this.param3.value);
    
        return [
            colorSpace(this.paramSpace.value),
            col[0],
            col[1],
            col[2] ];
    }
    
    
    
    setColorParams(color, fireChangeEvent = false)
    {
        const col = getScaledDataColor(color);

        this.param1.setValue(new NumberValue(col[1]), fireChangeEvent);
        this.param2.setValue(new NumberValue(col[2]), fireChangeEvent);
        this.param3.setValue(new NumberValue(col[3]), fireChangeEvent);
    }



    getTabParams()
    {
        return this.paramSpace.value.value == 0
            ? [this.paramSpace, this.paramColor]
            : this.params;
    }



    isConnected()
    {
        return this.inputs[0].connected
            //   skipping [1]
            || this.inputs[2].connected
            || this.inputs[3].connected
            || this.inputs[4].connected;
    }



    paramCanBeUnknown(param)
    {
        return param.id != this.paramSpace.id;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.param1.input.connected
            || this.node.param2.input.connected
            || this.node.param3.input.connected;

        const options = (hasInputs ? 1 : 0) << 20;

                
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));
            

            const paramIds = [];

            paramIds.push(this.node.paramSpace.id);

            for (const param of this.node.params.filter(p => p.id != this.node.paramSpace.id))
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));
            
                                                  request.push(...this.node.paramSpace.genRequest(gen));
            if (this.node.param1.input.connected) request.push(...this.node.param1    .genRequest(gen));
            if (this.node.param2.input.connected) request.push(...this.node.param2    .genRequest(gen));
            if (this.node.param3.input.connected) request.push(...this.node.param3    .genRequest(gen));
        }
        else
        {
            if (this.node.paramSpace.value == 0) // hex
            {
                request.push(
                    ...this.node.paramSpace.genRequest(gen),
                    NUMBER_VALUE, this.node.prevSpace.isValid() ? numToString(colorSpaceIndex(this.node.prevSpace)) : NAN_DISPLAY,
                    NUMBER_VALUE, numToString(this.node._color[1] * rgbScale[0]),
                    NUMBER_VALUE, numToString(this.node._color[2] * rgbScale[1]),
                    NUMBER_VALUE, numToString(this.node._color[3] * rgbScale[2]));
            }
            else
            {
                request.push(
                    ...this.node.paramSpace.genRequest(gen),
                    NUMBER_VALUE, this.node.prevSpace != NAN_DISPLAY ? numToString(colorSpaceIndex(this.node.prevSpace)) : NAN_DISPLAY,
                    ...this.node.param1.genRequest(gen),
                    ...this.node.param2.genRequest(gen),
                    ...this.node.param3.genRequest(gen));
            }
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const convert = values[paramIds.findIndex(id => id == 'convert')];
        const space   = values[paramIds.findIndex(id => id == 'space'  )];
        const c1      = values[paramIds.findIndex(id => id == 'c1'     )];
        const c2      = values[paramIds.findIndex(id => id == 'c2'     )];
        const c3      = values[paramIds.findIndex(id => id == 'c3'     )];


        if (   space 
            && space.isValid())
        {
            this.paramSpace.setValue(space, false, true, false);


            if (   convert.value != space.value
                || graphView.pastingNodes
                || graphView.loadingNodes
                || graphView.restoringNodes)
                switchToSpace(this, colorSpace(space.value));
            

            if (c1) this.param1.setValue(c1, false, true, false);
            if (c2) this.param2.setValue(c2, false, true, false);
            if (c3) this.param3.setValue(c3, false, true, false);


            const _space = this.paramSpace.value;
            const _c1    = this.param1    .value;
            const _c2    = this.param2    .value;
            const _c3    = this.param3    .value;

            const valid =
                   _space && _space.isValid()
                && _c1    && _c1   .isValid()
                && _c2    && _c2   .isValid()
                && _c3    && _c3   .isValid();


            if (valid)
            {
                this._color =
                    this.isUnknown()
                    ? dataColor_NaN
                    : makeDataColor(_space, _c1, _c2, _c3);

                this.outputs[0].wireColor = 
                    this.isUnknown()
                    ? rgbFromType(CACHE, true)
                    : dataColor2rgb(this._color);

                this.prevSpace = colorSpace(_space.value);
            }
            else
            {
                this.paramColor.setValue(ColorValue.NaN, false, true, false);

                this._color    = dataColor_NaN;
                this.prevSpace = NAN_DISPLAY;

                this.outputs[0].wireColor = rgb_NaN;
            }
        }
        else if (space)
        {
            this.paramSpace.setValue(NumberValue.NaN, false, true, false);
            removeParamDivs(this);

            this._color    = dataColor_NaN;
            this.prevSpace = NAN_DISPLAY;
        }
    }



    updateNode()
    {
        if (!hasFocus(this.paramColor.controls[0]))
            this.paramColor.setValue(ColorValue.fromRgb(scaleRgb(dataColor2rgb(this._color))), false, true, false);// = 
        

        const colors = this.getHeaderColors();

        const colSpaceBar = 
              !rgbIsNaN(colors.back)
            && isDark(colors.back)
            ? [1, 1, 1, 0.12]
            : [0, 0, 0, 0.09]; 


        this.paramSpace.controls[0].setMax(colorSpaceCount()-1);


        this.paramSpace.controls[0].backStyleLight  =
        this.paramSpace.controls[0].backStyleDark   = 'transparent';

        this.paramSpace.controls[0].valueStyleLight =
        this.paramSpace.controls[0].valueStyleDark  = rgba2style(colSpaceBar);

        this.paramSpace.controls[0].textStyleLight  =
        this.paramSpace.controls[0].textStyleDark   = rgba2style(colors.text);


        this.paramSpace. input.colorLight           =
        this.paramSpace. input.colorDark            = colors.input;

        this.paramSpace.output.colorLight           =
        this.paramSpace.output.colorDark            = colors.output;


        super.updateNode();
    }



    updateHeader()
    {
        super.updateHeader();

        const colors = this.getHeaderColors();
        
        updateColorHeader(this, colors);

        this.colorBack.style.height = defHeaderHeight + defParamHeight;
    }



    updateParams()
    {
        this.updateAllControlRanges();


        const enable = !this.inputs[0].connected;

        this.paramSpace.enableControlText(!this.paramSpace.input.connected);
        this.param1    .enableControlText(enable, this.param1.isUnknown());
        this.param2    .enableControlText(enable, this.param2.isUnknown());
        this.param3    .enableControlText(enable, this.param3.isUnknown());


        enableElementText(this.paramColor.controls[0].div, !this.isConnected());


        const colors = this.getHeaderColors();

        this.paramSpace.controls[0].textbox.style.color      = rgba2style(colors.text);
        this.paramSpace.controls[0].textbox.style.background = 'transparent';


        this.updateParamControls();


        this.paramColor._warningOverlay.style.display = 'none';
    }



    resetAllControlRanges()
    {
        this.param1.controls[0].resetRanges();
        this.param2.controls[0].resetRanges();
        this.param3.controls[0].resetRanges();
    }



    updateAllControlRanges()
    {
        //const warnLineStyle = getWarningRangeStyle();

        const space = this.paramSpace.value.value;

        if (    (   space == 1  // RGB
                 || space == 2  // HSV
                 || space == 3) // HSL
             && !dataColorIsNaN  (this._color)
             && !dataColorIsValid(this._color))
        {
            this.showExtRanges(true);
        }
        else if ( space > 3 // HCL
              && !dataColorIsNaN(this._color))
        {
            this.showExtRanges(false);

            this.updateControlRanges(this.param1.controls[0], f =>
                dataColor2rgb([
                    this._color[0],
                    (this.param1.controls[0].displayMin + f * (this.param1.controls[0].displayMax - this.param1.controls[0].displayMin)) / colorSpaceFactor(this._color[0])[0],
                    this._color[2],
                    this._color[3]]));

            this.updateControlRanges(this.param2.controls[0], f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    (this.param2.controls[0].displayMin + f * (this.param2.controls[0].displayMax - this.param2.controls[0].displayMin)) / colorSpaceFactor(this._color[0])[1],
                    this._color[3]]));

            this.updateControlRanges(this.param3.controls[0], f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    this._color[2],
                    (this.param3.controls[0].displayMin + f * (this.param3.controls[0].displayMax - this.param3.controls[0].displayMin)) / colorSpaceFactor(this._color[0])[2]]));
        }
        else // no warning ranges
        {
            this.resetAllControlRanges();
            this.showExtRanges(false);
        }
    }



    showExtRanges(show)
    {
        this.param1.controls[0].showExtRanges = show;
        this.param2.controls[0].showExtRanges = show;
        this.param3.controls[0].showExtRanges = show;
    }



    updateControlRanges(control, getRgb)
    {
        const warnLineStyle = getWarningRangeStyle();


        const ranges    = [];
 
        
        const precision = 0.01;
        let   open      = false;

        for (let f = 0; f <= 1; f += precision)
        {
            const rgb = getRgb(f);

            if (!open && !rgbIsValid(rgb))
            {
                ranges.push(new NumberControlRange(f, f, warnLineStyle, 0.8));
                open = true;
            }
            else if (open && rgbIsValid(rgb)) 
            {
                ranges.at(-1).end = f;
                open = false;
            }
        }

        
        if (open)
            ranges.at(-1).end = 1;
        else if (!open
              && isEmpty(ranges))
            control.resetRanges();


        control.ranges = ranges;
    }



    paramIsConsideredDefault(param)
    {
        return super.paramIsConsideredDefault(param)
            && !this.inputs[0].connected
            && (  !this.paramSpace.input.connected
                || this.paramSpace.value == 0);
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let json = super.toJsonBase(nTab);

        json += ',\n' + pos + tab + '"prevSpace": "' + this.prevSpace + '"';

        if (!dataColorIsNaN(this._colorBeforeNaN))
            json += ',\n' + pos + tab + '"colorBeforeNaN":\n' + dataColorToJson(this._colorBeforeNaN, 4);

        return json;
    }



    paramsToJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;


        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
        

        let first = true;
        for (let i = 0; i < this.params.length-1; i++) // -1 is for paramColor
        {
            const param = this.params[i];

            if (!this.paramIsConsideredDefault(param))
            {
                if (!first) json += ',\n'; first = false;

                json += 
                      pos + tab + tab 
                    + param.toJson(nTab, i > 0 ? 'c' + i : '');
            }
        }


        if (!first)
            json += '\n';

        json += pos + tab + ']';


        return json;
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);


        if (_node.colorBeforeNaN)
            this._colorBeforeNaN = _node.colorBeforeNaN;

        this.prevSpace = _node.prevSpace;    


        if (this.paramSpace.value.isValid())
        {
            const space  = colorSpace(Math.max(1, this.paramSpace.value.value));
            const factor = colorFactor(space);

            this._color = [
                space,
                this.param1.value.value / factor[0],
                this.param2.value.value / factor[1],
                this.param3.value.value / factor[2]];
        }
        else
            this._color = dataColor_NaN;
    }



    restoreParamUndoValue(value)
    {
        if (value.paramId == 'color')
        {
            super.restoreParamUndoValue({paramId: 'space', value: value.value.space});
            super.restoreParamUndoValue({paramId: 'c1',    value: value.value.c1   });
            super.restoreParamUndoValue({paramId: 'c2',    value: value.value.c2   });
            super.restoreParamUndoValue({paramId: 'c3',    value: value.value.c3   });
        }
        else
            super.restoreParamUndoValue(value);
    }
}



function getColorInputValuesForUndo(input)
{
    return [{
        paramId: 'color', 
        value:    ColorValue.fromDataColor(input.node._color)
    }];
}



function getColorOutputValuesForUndo(output)
{
    return [{
        paramId: 'color', 
        value:   ColorValue.fromDataColor(output.node._color)
    }];
}



function updateColorHeader(node, colors)
{
    node.header.style.background = 'transparent';

    
    const unknownBackStyle = darkMode ? '#444' : '#ccc';


    node.colorBack.style.background = 
        node.isUnknown()
        ? unknownBackStyle
        : !rgbIsNaN(colors.stripeBack)
          ? rgba2style(colors.stripeBack)
          : rgba2style(rgb_a(rgbDocumentBody, 0.95));

    node.colorBack.style.backgroundImage = 
        node.isUnknown()
        ? 'url(\'data:image/svg+xml;utf8,<svg width="45" height="65" viewBox="0 0 9 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path opacity="0.1" d="M3.04545 8.51136V8.31818C3.04924 7.6553 3.10795 7.12689 3.22159 6.73295C3.33902 6.33902 3.50947 6.02083 3.73295 5.77841C3.95644 5.53598 4.22538 5.31629 4.53977 5.11932C4.77462 4.9678 4.98485 4.81061 5.17045 4.64773C5.35606 4.48485 5.50379 4.30492 5.61364 4.10795C5.72349 3.9072 5.77841 3.68371 5.77841 3.4375C5.77841 3.17614 5.71591 2.94697 5.59091 2.75C5.46591 2.55303 5.29735 2.40151 5.08523 2.29545C4.87689 2.18939 4.64583 2.13636 4.39205 2.13636C4.14583 2.13636 3.91288 2.19129 3.69318 2.30114C3.47348 2.4072 3.29356 2.56629 3.15341 2.77841C3.01326 2.98674 2.9375 3.24621 2.92614 3.55682H0.607955C0.626894 2.79924 0.808712 2.17424 1.15341 1.68182C1.49811 1.18561 1.95455 0.816288 2.52273 0.573863C3.09091 0.327651 3.7178 0.204545 4.40341 0.204545C5.1572 0.204545 5.82386 0.329545 6.40341 0.579545C6.98295 0.825757 7.4375 1.18371 7.76705 1.65341C8.09659 2.12311 8.26136 2.68939 8.26136 3.35227C8.26136 3.79545 8.1875 4.18939 8.03977 4.53409C7.89583 4.875 7.69318 5.17803 7.43182 5.44318C7.17045 5.70455 6.86174 5.94129 6.50568 6.15341C6.20644 6.33144 5.96023 6.51705 5.76705 6.71023C5.57765 6.90341 5.43561 7.12689 5.34091 7.38068C5.25 7.63447 5.20265 7.94697 5.19886 8.31818V8.51136H3.04545ZM4.17045 12.1477C3.79167 12.1477 3.4678 12.0152 3.19886 11.75C2.93371 11.4811 2.80303 11.1591 2.80682 10.7841C2.80303 10.4129 2.93371 10.0947 3.19886 9.82955C3.4678 9.56439 3.79167 9.43182 4.17045 9.43182C4.5303 9.43182 4.84659 9.56439 5.11932 9.82955C5.39205 10.0947 5.5303 10.4129 5.53409 10.7841C5.5303 11.0341 5.46402 11.2633 5.33523 11.4716C5.21023 11.6761 5.04545 11.8409 4.84091 11.9659C4.63636 12.0871 4.41288 12.1477 4.17045 12.1477Z" fill="' + (darkMode ? 'white' : 'black') + '"/></svg>\')'
        : 'none';

    node.colorBack.style.height = node.measureData.headerOffset.height;

    node.colorBack.style.backgroundPosition = '50% 50%';
    node.colorBack.style.backgroundRepeat   = 'no-repeat';


    node.label.style.color = rgba2style(colors.text);

     
    node. inputs[0].colorLight =
    node. inputs[0].colorDark  = colors.input;
    node. inputs[0].wireColor  = rgb_a(colors.wire);

    node.outputs[0].colorLight =
    node.outputs[0].colorDark  = colors.output; 
    node.outputs[0].wireColor  = rgb_a(colors.wire);


    if (node.isUnknown())
        node._warningOverlay.style.display = 'none';

    else
    {
        const colWarning = 
            isDark(colors.back)
            ? [1, 1, 1, 0.2 ]
            : [0, 0, 0, 0.12];

        node.warningStyle = 
            rgbIsValid(colors.back) 
            ? 'transparent' 
            :  rgba2style(colWarning);

            
        node.updateWarningOverlay();
        node.updateWarningOverlayStyle(colors.back, defHeaderHeight + defParamHeight);
    }
}


function colorSpace     (index) { return ColorSpaces[index][0]; }
function colorSpaceIndex(space) { return ColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.showAllColorSpaces 
           ? ColorSpaces.length
        : ColorSpaces.length - 5; 
}



const rgbFactor  = [255, 255, 255];
const hs_Factor  = [360, 100, 100];
const hclFactor  = [360, 100, 100];
const oppFactor  = [100, 100, 100];
  
 
const rgbScale   = [255, 255, 255];
  
const hs_Scale   = [360, 100, 100];
 
const hclokScale = [360, 50,  100];
const hclabScale = [360, 400, 100];
const hcluvScale = [360, 330, 100];
 
 
const oklabScale = [100,  30,  30];
const labScale   = [100, 100, 100];
const luvScale   = [100, 150, 150];
 


function colorFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':
        case 'hsl':   return hs_Factor;

        case 'hclok':
        case 'hclab':
        case 'hcluv': return hclFactor;

        case 'oklab':  
        case 'lab':      
        case 'luv':   return oppFactor;   
        
        default:      consoleError('invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    
        case 'rgb':   scale = rgbScale;   break;

        case 'hsv':    
        case 'hsl':   scale = hs_Scale;   break;

        case 'hclok': scale = hclokScale; break;
        case 'hclab': scale = hclabScale; break;
        case 'hcluv': scale = hcluvScale; break;

        case 'oklab': scale = oklabScale; break;
        case 'lab':   scale = labScale;   break;
        case 'luv':   scale = luvScale;   break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function normalizeRgb(rgb)
{
    return [ rgb[0] / 255,
             rgb[1] / 255,
             rgb[2] / 255 ];
}



function scaleRgb(rgb)
{
    return [ Math.round(rgb[0] * 255),
             Math.round(rgb[1] * 255),
             Math.round(rgb[2] * 255) ];
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':   switchToHex   (node); break;
        case 'rgb':   switchToRgb   (node); break;

        case 'hsv':   switchToHsv   (node); break;
        case 'hsl':   switchToHsl   (node); break;

        case 'hclok': switchToHclok (node); break;
        case 'hclab': switchToHclab (node); break;
        case 'hcluv': switchToHcluv (node); break;

        case 'oklab': switchToOklab (node); break;
        case 'lab':   switchToLab   (node); break;
        case 'luv':   switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex  (node) { switchToRgbControls   (node); switchToTextbox(node); }
function switchToRgb  (node) { switchToRgbControls   (node);                        }

function switchToHsv  (node) { switchToHs_Controls   (node, 'V');                   }
function switchToHsl  (node) { switchToHs_Controls   (node, 'L');                   }
             
function switchToHclok(node) { switchToHclOklControls(node);                        }
function switchToHclab(node) { switchToHclLabControls(node);                        }
function switchToHcluv(node) { switchToHclLuvControls(node);                        }
             
function switchToOklab(node) { switchToOklabControls (node, 'a', 'b');              }
function switchToLab  (node) { switchToLabControls   (node, 'a', 'b');              }
function switchToLuv  (node) { switchToLuvControls   (node, 'u', 'v');              }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.controls[0].min = 
    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.controls[0].max = 
    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    node.param1.controls[0].suffixOffsetY = -4;

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hclokScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hclabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hcluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.controls[0].showHex = show;
    node.param2.controls[0].showHex = show;
    node.param3.controls[0].showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.controls[0].wrapValue = c1wrap;
    node.param1.controls[0].setSuffix(c1suffix, c1suffix != '');

    node.param1.controls[0].setMin(c1min); 
    node.param2.controls[0].setMin(c2min);
    node.param3.controls[0].setMin(c3min);
    
    node.param1.controls[0].setMax(c1max); 
    node.param2.controls[0].setMax(c2max); 
    node.param3.controls[0].setMax(c3max); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();

    node.param1.controls[0].suffixOffsetY = 0;
}



function switchToTextbox(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div, node.paramHolder);
    removeDivFrom(node.param2.div, node.paramHolder);
    removeDivFrom(node.param3.div, node.paramHolder);
        
    appendDivTo(node.paramColor.div, node.paramHolder);
}



function removeParamDivs(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div,     node.paramHolder);
    removeDivFrom(node.param2.div,     node.paramHolder);
    removeDivFrom(node.param3.div,     node.paramHolder);
    
    removeDivFrom(node.paramColor.div, node.paramHolder);
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    removeDivFrom(node.paramColor.div, node.paramHolder);

    appendDivTo(node.param1.div, node.paramHolder);
    appendDivTo(node.param2.div, node.paramHolder);
    appendDivTo(node.param3.div, node.paramHolder);
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':   return getNormalValueHs_ (value, chan);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':   return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':   return getNormalColorHs_(c1, c2, c3);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':   return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return getScaledDataColorRgb(         color[1], color[2], color[3]);

        case 'hsv':   return getScaledDataColorHs_('hsv',   color[1], color[2], color[3]);
        case 'hsl':   return getScaledDataColorHs_('hsl',   color[1], color[2], color[3]);

        case 'hclok': return getScaledDataColorHcl('hclok', color[1], color[2], color[3]);
        case 'hclab': return getScaledDataColorHcl('hclab', color[1], color[2], color[3]);
        case 'hcluv': return getScaledDataColorHcl('hcluv', color[1], color[2], color[3]);

        case 'oklab': return getScaledDataColorOpp('oklab', color[1], color[2], color[3]);
        case 'lab':   return getScaledDataColorOpp('lab',   color[1], color[2], color[3]);
        case 'luv':   return getScaledDataColorOpp('luv',   color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function colorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':   
        case 'hsl':   return hs_Factor;

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':   return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbScale;

        case 'hsv':   
        case 'hsl':   return hs_Scale;

        case 'hclok': return hclokScale;
        case 'hclab': return hclabScale;
        case 'hcluv': return hcluvScale;

        case 'oklab': return oklabScale;
        case 'lab':   return labScale;
        case 'luv':   return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return           col;

        case 'hsv':   return hsv2rgb  (col);
        case 'hsl':   return hsl2rgb  (col);

        case 'hclok': return hclok2rgb(col);
        case 'hclab': return hclab2rgb(col);
        case 'hcluv': return hcluv2rgb(col);

        case 'oklab': return oklab2rgb(col);
        case 'lab':   return lab2rgb  (col);
        case 'luv':   return luv2rgb  (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':   return convert2rgb    (color);

        case 'hsv':   return convert2hsv    (color);
        case 'hsl':   return convert2hsl    (color);

        case 'hclok': return convert2hclok  (color);
        case 'hclab': return convert2hclab  (color);
        case 'hcluv': return convert2hcluv  (color);

        case 'oklab': return dataColor2oklab(color);
        case 'lab':   return convert2lab    (color);
        case 'luv':   return convert2luv    (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   rgb =           col;  break;

        case 'hsv':   rgb = hsv2rgb  (col); break;
        case 'hsl':   rgb = hsl2rgb  (col); break;

        case 'hclok': rgb = hclok2rgb(col); break;
        case 'hclab': rgb = hclab2rgb(col); break;
        case 'hcluv': rgb = hcluv2rgb(col); break;

        case 'oklab': rgb = oklab2rgb(col); break;
        case 'lab':   rgb = lab2rgb  (col); break;
        case 'luv':   rgb = luv2rgb  (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsv = rgb2hsv(          col ); break;

        case 'hsv':   hsv =                   col;   break;
        case 'hsl':   hsv = rgb2hsv(hsl2rgb  (col)); break;

        case 'hclok': hsv = rgb2hsv(hclok2rgb(col)); break;
        case 'hclab': hsv = rgb2hsv(hclab2rgb(col)); break;
        case 'hcluv': hsv = rgb2hsv(hcluv2rgb(col)); break;

        case 'oklab': hsv = rgb2hsv(oklab2rgb(col)); break;
        case 'lab':   hsv = rgb2hsv(lab2rgb  (col)); break;
        case 'luv':   hsv = rgb2hsv(luv2rgb  (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsl = rgb2hsl(          col ); break;

        case 'hsv':   hsl = rgb2hsl(hsv2rgb  (col)); break;
        case 'hsl':   hsl =                   col;   break;

        case 'hclok': hsl = rgb2hsl(hclok2rgb(col)); break;
        case 'hclab': hsl = rgb2hsl(hclab2rgb(col)); break;
        case 'hcluv': hsl = rgb2hsl(hcluv2rgb(col)); break;

        case 'oklab': hsl = rgb2hsl(oklab2rgb(col)); break;
        case 'lab':   hsl = rgb2hsl(lab2rgb  (col)); break;
        case 'luv':   hsl = rgb2hsl(luv2rgb  (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function dataColor2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2oklab(          col ); break;

        case 'hsv':   lab = rgb2oklab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2oklab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2oklab(hclok2rgb(col)); break;
        case 'hclab': lab = rgb2oklab(hclab2rgb(col)); break;
        case 'hcluv': lab = rgb2oklab(hcluv2rgb(col)); break;

        case 'oklab': lab =                     col;   break;
        case 'lab':   lab = rgb2oklab(lab2rgb  (col)); break;
        case 'luv':   lab = rgb2oklab(luv2rgb  (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2lab(          col ); break;

        case 'hsv':   lab = rgb2lab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2lab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2lab(hclok2rgb(col)); break;
        case 'hclab': lab =         hclab2lab(col);  break;
        case 'hcluv': lab = rgb2lab(hcluv2rgb(col)); break;

        case 'oklab': lab = rgb2lab(oklab2rgb(col)); break;
        case 'lab':   lab =                   col;   break;
        case 'luv':   lab = rgb2lab(luv2rgb  (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   luv = rgb2luv(          col ); break;

        case 'hsv':   luv = rgb2luv(hsv2rgb  (col)); break;
        case 'hsl':   luv = rgb2luv(hsl2rgb  (col)); break;

        case 'hclok': luv = rgb2luv(hclok2rgb(col)); break;
        case 'hclab': luv = rgb2luv(hclab2rgb(col)); break;
        case 'hcluv': luv =         hcluv2luv(col);  break;

        case 'oklab': luv = rgb2luv(oklab2rgb(col)); break;
        case 'lab':   luv = rgb2luv(lab2rgb  (col)); break;
        case 'luv':   luv =                   col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclok(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclok(          col);  break;

        case 'hsv':   hcl = rgb2hclok(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclok(hsl2rgb  (col)); break;

        case 'hclok': hcl =                     col;   break;
        case 'hclab': hcl = rgb2hclok(hclab2rgb(col)); break;
        case 'hcluv': hcl = rgb2hclok(hcluv2rgb(col)); break;

        case 'oklab': hcl = rgb2hclok(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hclok(lab2rgb  (col)); break;
        case 'luv':   hcl = rgb2hclok(luv2rgb  (col)); break;
    }

    return [
       'hclok',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclab(          col) ; break;
        
        case 'hsv':   hcl = rgb2hclab(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclab(hsl2rgb  (col)); break;
        
        case 'hclok': hcl = rgb2hclab(hclok2rgb(col)); break;
        case 'hclab': hcl =                     col;   break;
        case 'hcluv': hcl = rgb2hclab(hcluv2rgb(col)); break;
        
        case 'oklab': hcl = rgb2hclab(oklab2rgb(col)); break;
        case 'lab':   hcl = lab2hclab(          col ); break;
        case 'luv':   hcl = rgb2hclab(luv2rgb  (col)); break;
    }

    return [
       'hclab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hcluv(          col ); break;

        case 'hsv':   hcl = rgb2hcluv(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hcluv(hsl2rgb  (col)); break;

        case 'hclab': hcl = rgb2hcluv(hclab2rgb(col)); break;
        case 'hcluv': hcl =                     col;   break;
        case 'hclok': hcl = rgb2hcluv(hclok2rgb(col)); break;

        case 'oklab': hcl = rgb2hcluv(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hcluv(lab2rgb  (col)); break;
        case 'luv':   hcl = luv2hcluv(          col ); break;
    }

    return [
       'hcluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


class   OpValidColor
extends OpColorBase
{
    paramQuality;

    corrections = [];


    colorBack;



    constructor()
    {
        super(VALID_COLOR, 'valid', 'valid', iconValidColor, true);

        this.canDisable  = true;
        this.slow        = true;
        this.iconOffsetY = -1;

        
        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));

        this.alwaysSaveParams = true;

        
        this.addParam(this.paramQuality = new SelectParam('quality', '', false, true, true, ['clip sRGB', 'clip chroma', 'find closest'], 1));


        this.initCorrections('');
        this.updateCorrections();


        this.header.connectionPadding = 18;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen, 0);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramQuality.genRequest(gen));


        const cached = 
            (input.connected
             ?  input.node.valid
             : !dataColorIsNaN(this.node._color))
            || !this.node.enabled;

        request.push(COLOR_VALUE, (
            cached
            ? ColorValue.fromDataColor(this.node._color)
            : ColorValue.NaN).toString()); // value


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;


        this.initCorrections(this._color[0]);
        this.endProgress();


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        super.updateHeader();

        const colors = this.getHeaderColors();
        updateColorHeader(this, colors);
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        if (this.isUnknown())
        {
            colors.text = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire = darkMode ? hex2rgb('888f') : hex2rgb('aaaf');
        }
                
        return colors;
    }



    initCorrections(colorSpace)
    {
        if (colorSpace == '')
            return;

        this.corrections = getColorCorrections(colorSpace);
    }



    updateCorrections()
    {
        this.updateColorSpace();
    }



    updateColorSpace()
    {
        if (dataColorIsValid(this._color))
            this.initCorrections(this._color[0]);
    }



    isConnected()
    {
        return this.inputs[0].connected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"_color": "' + ColorValue.fromDataColor(this._color).toString() + '"';
    }



    loadParams(_node, pasting)
    {
        if (_node._color != undefined)
        {
            this._color = parseColorValue(_node._color)[0].toDataColor();
            this.valid = true;
        }

        if (!dataColorIsValid(this._color))
            this.initProgress();

        super.loadParams(_node, pasting);
    }
}


class   OpCorrectColor
extends OpColorBase
{
    paramOrder;

    param1;
    param2;
    param3;

    corrections = [];


    colorBack;


    
    constructor()
    {
        super(CORRECT_COLOR, 'correct', 'correct', iconCorrectColor, true);

        this.subscription     = true;
        this.slow             = true;
        this.canDisable       = true;
        this.subscription     = true;
        this.iconOffsetY      = -1;
        this.alwaysSaveParams = true;

        
        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input([COLOR_VALUE]));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramOrder = new SelectParam('order', '', false, true, true, [0, 1, 2, 3, 4, 5], 2));
        
        this.paramOrder.addEventListener('change', () => this.updateCorrections());
        
        
        this.addParam(this.param1 = new NumberParam('margin1', '', true, true, true, 0));
        this.addParam(this.param2 = new NumberParam('margin2', '', true, true, true, 0));
        this.addParam(this.param3 = new NumberParam('margin3', '', true, true, true, 0));


        this.initCorrections('');
        this.updateCorrections();


        this.header.connectionPadding = 18;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramOrder.input.connected
            || this.node.param1    .input.connected
            || this.node.param2    .input.connected
            || this.node.param3    .input.connected;

        const options = (hasInputs ? 1 : 0) << 20;


        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];

        request.push(input.connected ? 1 : 0);


        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        const cached = 
               (input.connected
                ?    input.node.valid
                  //|| !dataColorIsNaN(this.node._color)
                : !dataColorIsNaN(this.node._color))
            || !this.node.enabled;


        const paramIds = [];

        for (const param of this.node.params)
            if (      param.input 
                   && param.input.connected
                || cached)
                paramIds.push(param.id);

        paramIds.push('value');

        request.push(paramIds.join(','));

        
        if (this.node.paramOrder.input.connected || cached) request.push(...this.node.paramOrder.genRequest(gen));
        if (this.node.param1    .input.connected || cached) request.push(...this.node.param1    .genRequest(gen));
        if (this.node.param2    .input.connected || cached) request.push(...this.node.param2    .genRequest(gen));
        if (this.node.param3    .input.connected || cached) request.push(...this.node.param3    .genRequest(gen));

 
        request.push(COLOR_VALUE, (
            cached
            ? ColorValue.fromDataColor(this.node._color)
            : ColorValue.NaN).toString()); // value


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;


        this.initCorrections(this._color[0]);
        this.endProgress();


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        //this.updateCorrectionNames();
    }



    updateParams()
    {
        this.paramOrder.enableControlText(false, this.isUnknown());
        this.param1    .enableControlText(false, this.isUnknown());
        this.param2    .enableControlText(false, this.isUnknown());
        this.param3    .enableControlText(false, this.isUnknown());

        this.updateCorrections();

        this.updateParamControls();
    }



    updateHeader()
    {
        super.updateHeader();

        const colors = this.getHeaderColors();

        this.progressBar.style.background = 
            !rgbIsNaN(colors.back) 
            ? rgb2style_a(colors.text, 0.5) 
            : 'var(--figma-color-bg-brand)';


        updateColorHeader(this, colors);
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        if (this.isUnknown())
        {
            colors.text = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire = darkMode ? hex2rgb('888f') : hex2rgb('aaaf');
        }

        return colors;
    }



    initCorrections(colorSpace)
    {
        if (colorSpace == '')
        {
            this.paramOrder.setValue(NumberValue.NaN);
            this.param1    .setValue(NumberValue.NaN);
            this.param2    .setValue(NumberValue.NaN);
            this.param3    .setValue(NumberValue.NaN);

            return;
        }


        switch (colorSpace)
        {
        case 'hex':
        case 'rgb':    this.paramOrder.setOptions(makeOptions('RGB')); break;
        case 'hsv':    this.paramOrder.setOptions(makeOptions('HSV')); break;
        case 'hsl':    this.paramOrder.setOptions(makeOptions('HSL')); break;
        case 'hclok':
        case 'hclab':
        case 'hcluv':  this.paramOrder.setOptions(makeOptions('HCL')); break;
        case 'oklab':  
        case 'lab':    this.paramOrder.setOptions(makeOptions('Lab')); break;
        case 'luv':    this.paramOrder.setOptions(makeOptions('Luv')); break;
        }


        this.corrections = getColorCorrections(colorSpace);
    }



    updateCorrections()
    {
        this.updateColorSpace();

        
        if (this.paramOrder.value.isValid())
        {
            const [i1, i2, i3] = getCorrectionsInOrder(this.paramOrder.value.value);

            this.updateMargin(this.param1, this.corrections[i1]);
            this.updateMargin(this.param2, this.corrections[i2]);
            this.updateMargin(this.param3, this.corrections[i3]);

            this.param1.showName = true;
            this.param2.showName = true;
            this.param3.showName = true;
        }
        else
        {
            this.resetMargin(this.param1);
            this.resetMargin(this.param2);
            this.resetMargin(this.param3);

            this.param1.showName = false;
            this.param2.showName = false;
            this.param3.showName = false;
        }
    }



    updateCorrectionNames()
    {
        this.param1.controls[0].showName = this.param1.value.isValid();
        this.param2.controls[0].showName = this.param2.value.isValid();
        this.param3.controls[0].showName = this.param3.value.isValid();
    }



    updateColorSpace()
    {
        if (dataColorIsValid(this._color))
            this.initCorrections(this._color[0]);
    }



    updateMargin(margin, correction)
    {
        const correctionName = '<span style="position: relative; top: -1px; font-weight: 200;">±</span>&thinsp;' + correction.name;

        margin.setName(correctionName, false);
        margin.controls[0].name = correctionName;

        margin.controls[0].setMin(0);
        margin.controls[0].setMax(correction.max);
    }



    resetMargin(margin)
    {
        margin.setName('', false);
        margin.controls[0].name = '<span style="position: relative; top: -1px; font-weight: 200;">±</span>';
        margin.controls[0].setMin(0);
        margin.controls[0].setMax(Number.MAX_SAFE_INTEGER);
    }



    isConnected()
    {
        return this.inputs[0].connected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"_color": "' + ColorValue.fromDataColor(this._color).toString() + '"';
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);

        if (_node._color != undefined)
        {
            this._color = parseColorValue(_node._color)[0].toDataColor();
            this.valid = true;
        }

        if (!dataColorIsValid(this._color))
            this.initProgress();
    }
}



function makeOptions(c)
{
    return ([
        c[0]+', '+c[1]+', '+c[2], 
        c[1]+', '+c[0]+', '+c[2], 
        c[1]+', '+c[2]+', '+c[0], 
        c[0]+', '+c[2]+', '+c[1], 
        c[2]+', '+c[0]+', '+c[1], 
        c[2]+', '+c[1]+', '+c[0]]);
}



class   OpConvertP3
extends OpColorBase
{
    paramFrom;

    colorBack;



    constructor()
    {
        super(COLOR_CONVERT_P3, 'convert', 'convert', iconConvertP3, true);

        this.subscription = true;
        this.canDisable   = true;
        this.slow         = true;
        this.iconOffsetY  = -1;

        
        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));

        this.alwaysSaveParams = true;

        
        this.addParam(this.paramFrom = new SelectParam('from', '', false, true, true, ['sRGB ⟶ P3', 'P3 ⟶ sRGB'], 0));


        this.header.connectionPadding = 18;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen, 0);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramFrom.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        super.updateHeader();

        const colors = this.getHeaderColors();
        updateColorHeader(this, colors);
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        if (this.isUnknown())
        {
            colors.text = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire = darkMode ? hex2rgb('888f') : hex2rgb('aaaf');
        }
                
        return colors;
    }



    isConnected()
    {
        return this.inputs[0].connected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"_color": "' + ColorValue.fromDataColor(this._color).toString() + '"';
    }



    loadParams(_node, pasting)
    {
        if (_node._color != undefined)
        {
            this._color = parseColorValue(_node._color)[0].toDataColor();
            this.valid = true;
        }

        super.loadParams(_node, pasting);
    }
}


const rgb2dark1  = [255/255,  64/255,  96/255];
const rgb2dark2  = [255/255, 255/255,  0/255];
const rgb2dark3  = [ 64/255, 220/255, 64/255];

const rgb2light1 = [255/255,  50/255, 50/255];
const rgb2light2 = [200/255, 195/255,  0/255];
const rgb2light3 = [ 64/255, 220/255, 64/255];


const rgb3dark1  = [255/255,  64/255,  96/255];
const rgb3dark2  = [255/255, 128/255,  24/255];
const rgb3dark3  = [255/255, 185/255,   0/255];
const rgb3dark4  = [255/255, 255/255,   0/255];
const rgb3dark5  = [ 64/255, 255/255,  64/255];
const rgb3dark6  = [  0/255, 164/255, 255/255];
const rgb3dark7  = [230/255, 230/255, 230/255];

const rgb3light1 = [255/255,   0/255,  64/255];
const rgb3light2 = [255/255, 112/255,   0/255];
const rgb3light3 = [220/255, 150/255,   0/255];
const rgb3light4 = [210/255, 205/255,   0/255];
const rgb3light5 = [ 30/255, 220/255,  30/255];
const rgb3light6 = [128/255, 128/255, 255/255];
const rgb3light7 = [255/255, 255/255, 255/255];



class   OpColorContrast
extends OpColorBase
{
    paramStandard;
    paramContrast;

    colorBack;


    labelColor = [0, 0, 0];


    _rgbText   = [0, 0, 0];
    _rgbBack   = [0, 0, 0];


    constructor()
    {
        super(COLOR_CONTRAST, 'contrast', 'contrast', '');


        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));

        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));
        //this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramContrast = new NumberParam('contrast', '', false, false, true, 0));
        this.addParam(this.paramStandard = new SelectParam('standard', '', false, true,  true, ['WCAG 2', 'APCA'], 1));
      
        this.paramContrast.isNodeValue = true;
        
        this.paramContrast.controls[0].thinMinus     = true;
        this.paramContrast.controls[0].showExtRanges = false;


        this.paramStandard.getTooltip = () => null;

        this.paramContrast.getTooltip = () => 
            settings.showTooltipColorContrast ? 
            (this.paramStandard.value.value == 1 ? ttWcag3 : ttWcag2) 
            : null;


        this.header.connectionPadding = 12.5;
    }



    output_genRequest(gen)
    {
        // 'this' is the output


        // console.trace();
        if (gen.passedNodes.includes(this.node))
        {
            return [
                this.node.type, 
                this.node.id, 
                this.node.name];
        }


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, 0, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, 1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramStandard.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        consoleAssert(
            paramIds.length == values.length,
            'paramIds.length must equal values.length');

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        const colText  = values[paramIds.findIndex(id => id == 'text'    )];
        const colBack  = values[paramIds.findIndex(id => id == 'back'    )];
        const standard = values[paramIds.findIndex(id => id == 'standard')];
        const contrast = values[paramIds.findIndex(id => id == 'contrast')];

        consoleAssert(isValid(colText), 'colText is not valid');
        consoleAssert(isValid(colBack), 'colBack is not valid');

        consoleAssert(colText.type == COLOR_VALUE, 'colText.type = ' + colText.type);
        consoleAssert(colBack.type == COLOR_VALUE, 'colBack.type = ' + colBack.type);


        this.labelColor = 
            colText.isValid()
            ? colText.toRgb()
            : getTextColorFromBackColor(colBack);

        this._color = colBack.toDataColor();


        this._rgbText = colText.toRgb();
        this._rgbBack = colBack.toRgb();


        if (   standard
            && contrast)
        {
            if (standard.value == 0)
            {
                let rating = getContrastRating2(contrast.value);

                if (rating != '')
                    rating = '&nbsp;&nbsp;' + rating;

                this.paramContrast.controls[0].min        = 
                this.paramContrast.controls[0].displayMin = 0;

                this.paramContrast.controls[0].max        = 
                this.paramContrast.controls[0].displayMax = 21;

                this.paramContrast.controls[0].setDecimals(2);
                this.paramContrast.controls[0].setSuffix(rating);

                this.paramContrast.controls[0].displayAbsolute = false;
            }
            else
            {
                this.paramContrast.controls[0].min        = -108;
                this.paramContrast.controls[0].max        =  106;
                
                this.paramContrast.controls[0].displayMin = -105;
                this.paramContrast.controls[0].displayMax =  105;

                this.paramContrast.controls[0].displayAbsolute = true;

                this.paramContrast.controls[0].setDecimals(1);
                this.paramContrast.controls[0].setSuffix('<span style="font-size: 5; position: relative; top: -7px; left: 2px;">L</span><span style="font-size: 3; font-weight: bold; position: relative; top: -9px; left: 2px;">c</span>');

                this.paramContrast.controls[0].setValue(contrast.value, false, false);
            }


            if (   this.inputs[0].connected
                && this.inputs[1].connected)
            {
                const rgb0 = colText.toRgb();
                const rgb1 = colBack.toRgb();

                if (  !rgbIsOk(rgb0)
                    && rgbIsOk(rgb1))
                {
                    this.warningStyle     = rgb2style_a(invalid2validRgb(rgb0), 0.3);
                    this.forceShowWarning = true;
                }
                else if (rgbIsOk(rgb0)
                     && !rgbIsOk(rgb1))
                {
                    this.warningStyle     = getDefaultWarningStyle(rgb1);
                    this.forceShowWarning = true;
                }
                else
                    this.forceShowWarning = false;
            }
            else
            {
                this.forceShowWarning = false;
            }
        }
    }



    updateParams()
    {
        this.paramContrast.enableControlText(false, this.isUnknown());
        this.paramStandard.enableControlText(true);

        this.setRanges(this.paramStandard.value);

        this.updateParamControls();
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        colors.text = this._rgbText;
        colors.wire = this._rgbText;

        return colors;
    }



    updateHeader()
    {
        super.updateHeader();

        
        const colors = this.getHeaderColors();
        
        if (this.isUnknown())
        {
            colors.text = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire = darkMode ? hex2rgb('888f') : hex2rgb('aaaf');
        }


        updateColorHeader(this, colors);
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();

        const colors = this.getHeaderColors();

          if (   this.inputs[0].connected 
              && this.inputs[1].connected) this.label.style.color = rgb2style(this.labelColor);
        else if (this.inputs[1].connected) this.label.style.color = rgba2style(colors.text);
        else                               this.label.style.color = darkMode ? 'white' : 'black';
    }



    setRanges(standard)
    {
        if (standard.value == 0)
        {
            const contrast = Math.abs(this.paramContrast.value.value) / 21;

            const is1 = contrast > 0  /21 && contrast <=  3  /21;
            const is2 = contrast > 3  /21 && contrast <=  4.5/21;
            const is3 = contrast > 4.5/21 && contrast <=  7  /21;
           
            if (darkMode)
            {
                this.paramContrast.controls[0].ranges = [ 
                    new NumberControlRange(0  /21,  3  /21, rgb2style_a(rgb2dark1, is1 ? 1 : 0.2 ), 0.8),
                    new NumberControlRange(3  /21,  4.5/21, rgb2style_a(rgb2dark2, is2 ? 1 : 0.27), 0.8),
                    new NumberControlRange(4.5/21,  7  /21, rgb2style_a(rgb2dark3, is3 ? 1 : 0.27), 0.8),
                    new NumberControlRange(7  /21, 21  /21, 'transparent') ];
            }
            else
            {
                this.paramContrast.controls[0].ranges = [ 
                    new NumberControlRange(0  /21,  3  /21, rgb2style_a(rgb2light1, is1 ? 1 : 0.2 ), 0.8),
                    new NumberControlRange(3  /21,  4.5/21, rgb2style_a(rgb2light2, is2 ? 1 : 0.27), 0.8),
                    new NumberControlRange(4.5/21,  7  /21, rgb2style_a(rgb2light3, is3 ? 1 : 0.27), 0.8),
                    new NumberControlRange(7  /21, 21  /21, 'transparent') ];
            }
        }
        else
        {
            const contrast = Math.abs(this.paramContrast.value.value) / 100;

            const is1 = contrast >=  0/100 && contrast <=  15/100;
            const is2 = contrast >  15/100 && contrast <=  30/100;
            const is3 = contrast >  30/100 && contrast <=  45/100;
            const is4 = contrast >  45/100 && contrast <=  60/100;
            const is5 = contrast >  60/100 && contrast <=  75/100;
            const is6 = contrast >  75/100 && contrast <=  90/100;
            const is7 = contrast >  90/100;

            if (darkMode)
            {
                this.paramContrast.controls[0].ranges = [ 
                    new NumberControlRange( 0/105,  15/105, rgb2style_a(rgb3dark1, is1 ? 1 : 0.2), 0.8),
                    new NumberControlRange(15/105,  30/105, rgb2style_a(rgb3dark2, is2 ? 1 : 0.2), 0.8),
                    new NumberControlRange(30/105,  45/105, rgb2style_a(rgb3dark3, is3 ? 1 : 0.2), 0.8),
                    new NumberControlRange(45/105,  60/105, rgb2style_a(rgb3dark4, is4 ? 1 : 0.2), 0.8),
                    new NumberControlRange(60/105,  75/105, rgb2style_a(rgb3dark5, is5 ? 1 : 0.2), 0.8),
                    new NumberControlRange(75/105,  90/105, rgb2style_a(rgb3dark6, is6 ? 1 : 0.4), 0.8),
                    new NumberControlRange(90/105, 105/105, rgb2style_a(rgb3dark7, is7 ? 1 : 0  ), 0.8) ];
            }
            else
            {
                this.paramContrast.controls[0].ranges = [
                    new NumberControlRange( 0/105,  15/105, rgb2style_a(rgb3light1, is1 ? 1 : 0.2), 0.8),
                    new NumberControlRange(15/105,  30/105, rgb2style_a(rgb3light2, is2 ? 1 : 0.2), 0.8),
                    new NumberControlRange(30/105,  45/105, rgb2style_a(rgb3light3, is3 ? 1 : 0.2), 0.8),
                    new NumberControlRange(45/105,  60/105, rgb2style_a(rgb3light4, is4 ? 1 : 0.2), 0.8),
                    new NumberControlRange(60/105,  75/105, rgb2style_a(rgb3light5, is5 ? 1 : 0.2), 0.8),
                    new NumberControlRange(75/105,  90/105, rgb2style_a(rgb3light6, is6 ? 1 : 0.1), 0.8),
                    new NumberControlRange(90/105, 105/105, 'transparent') ];
            }
        }
    }
}


class   OpColorBlind
extends OpColorBase
{
    paramL;
    paramM;
    paramS;


    symbol;

    ringL;
    ringM;
    ringS;

    menuL;
    menuM;
    menuS;


    colorBack;


    
    constructor()
    {
        super(COLORBLIND, 'colorblind', 'colorblind', '');

        this.canDisable = true;
        

        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramL = new NumberParam('l', 'L', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.paramM = new NumberParam('m', 'M', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.paramS = new NumberParam('s', 'S', false, true, true, 2, 0, 2, 0, 0.02));

        this.paramL.addEventListener('change', () => this.paramL.controls[0].dragScale = decCount(numToString(this.paramL.value, this.paramL.controls[0].displayDec)) == 0 ? 0.02 : 0.05);
        this.paramM.addEventListener('change', () => this.paramM.controls[0].dragScale = decCount(numToString(this.paramM.value, this.paramM.controls[0].displayDec)) == 0 ? 0.02 : 0.05);
        this.paramS.addEventListener('change', () => this.paramS.controls[0].dragScale = decCount(numToString(this.paramS.value, this.paramS.controls[0].displayDec)) == 0 ? 0.02 : 0.05);


        this.header.connectionPadding = 18;


        this.symbol = createDiv('colorblindSymbol');
        
        this.ringL  = createDiv('colorblindRing');
        this.ringM  = createDiv('colorblindRing');
        this.ringS  = createDiv('colorblindRing');
        
        this.symbol.appendChild(this.ringS);
        this.symbol.appendChild(this.ringM);
        this.symbol.appendChild(this.ringL);

        this.header.appendChild(this.symbol);


        createTooltipSrc(
            this.symbol, 
            this.symbol, 
            () => settings.showTooltipColorBlindness 
            ? ttColorblind 
            : null);


        this.menuL = new Menu('L', false, true);
        this.menuL.addItems([
            new MenuItem('L',       null, {callback: () => { hideAllMenus(); this.paramL.setValue(new NumberValue(2), true); }}),
            new MenuItem('L weak',  null, {callback: () => { hideAllMenus(); this.paramL.setValue(new NumberValue(1), true); }}),
            new MenuItem('L blind', null, {callback: () => { hideAllMenus(); this.paramL.setValue(new NumberValue(0), true); }})]);

        this.menuM = new Menu('M', false, true);
        this.menuM.addItems([
            new MenuItem('M',       null, {callback: () => { hideAllMenus(); this.paramM.setValue(new NumberValue(2), true); }}),
            new MenuItem('M weak',  null, {callback: () => { hideAllMenus(); this.paramM.setValue(new NumberValue(1), true); }}),
            new MenuItem('M blind', null, {callback: () => { hideAllMenus(); this.paramM.setValue(new NumberValue(0), true); }})]);

        this.menuS = new Menu('S', false, true);
        this.menuS.addItems([
            new MenuItem('S',       null, {callback: () => { hideAllMenus(); this.paramS.setValue(new NumberValue(2), true); }}),
            new MenuItem('S weak',  null, {callback: () => { hideAllMenus(); this.paramS.setValue(new NumberValue(1), true); }}),
            new MenuItem('S blind', null, {callback: () => { hideAllMenus(); this.paramS.setValue(new NumberValue(0), true); }})]);


        this.menuL.minWidth = 120;
        this.menuM.minWidth = 120;
        this.menuS.minWidth = 120;


        this.paramL.controls[0].div.addEventListener('pointerdown', e => this.showParamMenu(e, this.paramL, this.menuL));
        this.paramM.controls[0].div.addEventListener('pointerdown', e => this.showParamMenu(e, this.paramM, this.menuM));
        this.paramS.controls[0].div.addEventListener('pointerdown', e => this.showParamMenu(e, this.paramS, this.menuS));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

            
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];

        request.push(input.connected ? 1 : 0);


        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramL.genRequest(gen));
        request.push(...this.node.paramM.genRequest(gen));
        request.push(...this.node.paramS.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            value
            ? value.toDataColor()
            : dataColor_NaN;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        super.updateHeader();

        const colors = this.getHeaderColors();

        const ringStyle = 
            !this.isUnknown()
            ? rgba2style(colors.text)
            : darkMode 
            ? '#fffc' 
            : '#000c';

        const valL = Math.round(this.paramL.value.value);
        const valM = Math.round(this.paramM.value.value);
        const valS = Math.round(this.paramS.value.value);


        if (   valL == 0
            && valM == 0
            && valS == 0)
        {
            this.ringL.style.display      = 'none';
            this.ringS.style.display      = 'none';

            this.ringM.style.display      = 'block';
            this.ringM.style.width        = '14px';
            this.ringM.style.height       = '14px';
            this.ringM.style.borderRadius = '14px';
            this.ringM.style.background   = ringStyle;
            this.ringM.style.border       = 'none';
        }
        else
        {
            const lDisplay     = valL >= 1 ? 'block' : 'none';
            const lBorderStyle = valL == 2 ? 'solid' : 'dashed';

            this.ringL.style.width        = '16px';
            this.ringL.style.height       = '16px';
            this.ringL.style.borderRadius = '16px';
            this.ringL.style.border       = '1.5px solid ' + ringStyle;
            this.ringL.style.display      = lDisplay;
            this.ringL.style.borderStyle  = lBorderStyle;


            const mDisplay     = valM >= 1 ? 'block' : 'none';
            const mBorderStyle = valM == 2 ? 'solid' : 'dashed';

            this.ringM.style.width        = '8px';
            this.ringM.style.height       = '8px';
            this.ringM.style.borderRadius = '8px';
            this.ringM.style.border       = '1.5px solid ' + ringStyle;
            this.ringM.style.background   = 'none';
            this.ringM.style.display      = mDisplay;
            this.ringM.style.borderStyle  = mBorderStyle;
            

            const sDisplay      = valS >= 1 ? 'block' : 'none';
            const sBorderRadius = valS == 2 ? 3 : 1;

            this.ringS.style.width        = sBorderRadius + 'px';
            this.ringS.style.height       = sBorderRadius + 'px';
            this.ringS.style.background   = ringStyle;
            this.ringS.style.display      = sDisplay;
            this.ringS.style.borderRadius = sBorderRadius + 'px';
        }


        updateColorHeader(this, colors);
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        if (this.isUnknown())
        {
            colors.text = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire = darkMode ? hex2rgb('888f') : hex2rgb('aaaf');
        }

        return colors;
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        this.label.style.top = '59%';
    }



    updateParams()
    {
        this.updateParamText(this.paramL, 'L');
        this.updateParamText(this.paramM, 'M');
        this.updateParamText(this.paramS, 'S');

        this.updateParamControls();
    }



    updateParamText(param, cone)
    {
        const v = Math.round(param.value.value);

             if (v == 2) param.controls[0].valueText = cone;
        else if (v == 1) param.controls[0].valueText = cone + ' weak';
        else             param.controls[0].valueText = cone + ' blind';
    }
}


class   OpColorInterpolate
extends OpColorBase
{
    paramSpace;
    paramAmount;
    paramGamma;


    colorBack;



    constructor()
    {
        super(COLOR_INTERPOLATE, 'inter', 'interpolate', iconColorInterpolate);

        this.iconOffsetY = -3;

        
        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));

        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramSpace  = new SelectParam('space',  '',  false, true, true, ColorSpaces.map(s => s[1]), 1));
        this.addParam(this.paramAmount = new NumberParam('amount', '',  false,  true, true, 50, 0,  100, 0));
        this.addParam(this.paramGamma  = new NumberParam('gamma',  'gamma', true,  true, true, 1,  0.01, 4, 2));
      
        
        this.paramSpace.controls[0].setMin(1);
        this.paramSpace.excludeFromMenu.push(0);
        this.paramSpace.input.outputMustBeCached = true;

        
        this.paramAmount.controls[0].min = Number.MIN_SAFE_INTEGER; // allow
        this.paramAmount.controls[0].max = Number.MAX_SAFE_INTEGER; // extrapolation

        this.paramAmount.controls[0].setSuffix('%', true);

        this.paramGamma.divider = 0.54;
        

        this.header.connectionPadding = 12.5;

        
        this.paramSpace.getTooltip = () => 
            settings.showTooltipColorInterpolation 
            ? ttInterpolationSpace 
            : null;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramSpace .genRequest(gen));
        request.push(...this.node.paramAmount.genRequest(gen));
        request.push(...this.node.paramGamma .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        super.updateHeader();
        
        const colors = this.getHeaderColors();
        updateColorHeader(this, colors);
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        if (this.isUnknown())
        {
            colors.text = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire = darkMode ? hex2rgb('888f') : hex2rgb('aaaf');
        }

        return colors;
    }
}


class   OpColorBlend
extends OpColorBase
{
    paramMode;
    paramOpacity;


    colorBack;



    constructor()
    {
        super(COLOR_BLEND, 'blend', 'blend', iconColorBlend);

        this.iconOffsetY = -1;

        
        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));

        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramMode    = new SelectParam('mode',    '',        false, true, true, BlendModes.map(bm => bm[1]), 0));
        this.addParam(this.paramOpacity = new NumberParam('opacity', 'opacity', true,  true, true, 100, 0,  100, 0));
      
        
        this.paramMode.separatorsBefore.push(1, 4, 7, 10, 12);
        this.paramMode.input.outputMustBeCached = true;

        
        this.paramOpacity.controls[0].min = Number.MIN_SAFE_INTEGER; // allow
        this.paramOpacity.controls[0].max = Number.MAX_SAFE_INTEGER; // extrapolation

        this.paramOpacity.controls[0].setSuffix('%', true);
        

        this.header.connectionPadding = 12.5;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramMode   .genRequest(gen));
        request.push(...this.node.paramOpacity.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        super.updateHeader();

        const colors = this.getHeaderColors();
        updateColorHeader(this, colors);
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        if (this.isUnknown())
        {
            colors.text = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire = darkMode ? hex2rgb('888f') : hex2rgb('aaaf');
        }

        return colors;
    }
}


class   OpColorStyle
extends OperatorBase
{
    paramValue;

    styleCircle;

    circleBack;
    circleCheckers;
    circle;
    link;

    existing        = true;

    linkedStyleId   = NULL;
    linkedStyleName = NULL;




    constructor(options = {})
    {
        super(COLOR_STYLE, 'style', 'style', '');

        this.inert = true;


        this.addParam(this.paramValue = new FillParam('value', '', false, true, true, FillValue.NaN));

        this.paramValue.input.getValuesForUndo = getNodeInputValuesForUndo;
        this.paramValue.input.addEventListener('disconnect', e => OpColorStyle_value_onDisconnectInput(this, e.detail.input));

        
        if (!!options.existing)
        {
            this.existing = true;
            this.paramValue.setValue(FillValue.NaN, false, false, false);
        }


        this.circleBack       = createDiv('styleCircleBack');
        this.circleCheckers   = createDiv('styleCircleCheckers');
        this.circle           = createDiv('styleCircle');

        this.styleCircle      = createDiv('styleCircleWrapper');;
        this.styleCircle.over = false;

        this.styleCircle.addEventListener('pointerenter', e => { this.styleCircle.over = true;  this.updateLinkIcon(); });
        this.styleCircle.addEventListener('pointerleave', e => { this.styleCircle.over = false; this.updateLinkIcon(); });

        this.styleCircle.addEventListener('pointerdown',  e => 
        { 
            e.stopPropagation();

            if (   (  e.button == 0 
                   || e.button == 2)
                && this.existing)
            {
                hideAllMenus(); 

                uiQueueMessageToFigma({
                    cmd:   'figGetAllLocalColorStyles',
                    nodeId: this.id,
                    px:     e.clientX,
                    py:     e.clientY }); 
            }
            else
                e.preventDefault();
        });


        this.link = createDiv('styleLink');


        this.styleCircle.appendChild(this.circleBack);
        this.styleCircle.appendChild(this.circleCheckers);
        this.styleCircle.appendChild(this.circle);
        this.styleCircle.appendChild(this.link);
        
        this.label.insertBefore(this.styleCircle, this.labelText);


        this.updateParams();
    }



    setName(newName, options = {})
    {
        super.setName(newName, options);

        if (isValid(options.updateNodes))
            pushUnique(options.updateNodes, this);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const options = (this.existing ? 1 : 0) << 21;


        const [request, ignore] = this.genRequestStart(gen, options);
        if (ignore) return request;

                
        request.push(this.linkedStyleId);
        request.push(...this.paramValue.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        const enabled = this.linkedStyleId != NULL;
            //   !this.existing 
            // || this.linkedStyleId != NULL;

        this.paramValue.enableControlText(enabled, this.isUnknown());

        // // this.paramValue.controls[0].valueText =  this.isUnknown() ? UNKNOWN_DISPLAY : '';
        // this.paramValue.controls[0].showBar   = false;//!this.isUnknown();


        //const colors   = this.getHeaderColors();
        //const rgbaBack = rgb_a(colors.stripeBack, colors.back[3]);

        //this.paramValue.controlWrapper.style.background = rgba2style(rgbaBack);
            //   !rgbaIsNaN(rgbaBack) 
            // && this.paramValue.value.opacity.isValid()
            // ?  rgba2style(rgbaBack)
            // : 'transparent'; 

        this.updateParamControls();
    }



    updateHeader()
    {
        super.updateHeader();


        if (this.paramValue.value.isValid()
            && (  !this.existing
                || this.linkedStyleId != NULL))
        {
            const rgba       = this.paramValue.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);
            
            this.circleBack    .style.visibility = 'visible';
            this.circleCheckers.style.visibility = 'visible';
            this.circle        .style.background = rgba2style(rgbaStripe);

            this.styleCircle.style.boxShadow = 
                    darkMode &&  isDark(rgbaStripe, 0.4)
                || !darkMode && !isDark(rgbaStripe, 0.9)
                ? '0 0 0 1px var(--figma-color-bg-tertiary) inset'
                : 'none';
        }
        else
        {
            this.circleBack    .style.visibility = 'hidden';
            this.circleCheckers.style.visibility = 'hidden';
            this.circle        .style.background = 'transparent';
            this.styleCircle   .style.boxShadow  = '0 0 0 1px var(--figma-color-bg-tertiary) inset';
        }


        this.updateLinkIcon();
    }

    

    updateLinkIcon()
    {
        if (this.existing)
        {
            const colors = this.getHeaderColors();

            const rgba       = this.paramValue.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            const linkStyle = rgba2style(
                rgb_a(
                       this.paramValue.value.isValid()
                    && this.linkedStyleId != NULL
                    ? (isDark(rgbaStripe) ? [1, 1, 1] : [0, 0, 0])
                    : colors.text, 
                    this.linkedStyleId != NULL
                    ? (this.styleCircle.over ? 0.5 : 0)
                    : (this.styleCircle.over ? 1 : 0.5)));

            this.circleBack.style.background             = darkMode ? '#2c2c2c' : '#ffffff';

            const rgb0 = hex2rgb('d9d9d9');
            const rgb1 = hex2rgb('f6f6f6');

            this.circleCheckers.style.display            = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';
            this.circleCheckers.style.background         =
                  'linear-gradient(45deg, #'+rgb2hex(rgb0)+' 25%, transparent 25%, transparent 75%, #'+rgb2hex(rgb0)+' 75%), '
                + 'linear-gradient(45deg, #'+rgb2hex(rgb0)+' 25%, transparent 25%, transparent 75%, #'+rgb2hex(rgb0)+' 75%)';

            this.circleCheckers.style.backgroundColor    = '#'+rgb2hex(rgb1);
            this.circleCheckers.style.opacity            = 1 - this.paramValue.value.opacity.value / 100;
            this.circleCheckers.style.backgroundSize     = '6px 6px';
            this.circleCheckers.style.backgroundPosition = '0 0, 3px 3px';

            this.link.style.display                      = 'inline-block';
            this.link.style.background                   = 'url(\'data:image/svg+xml;utf8,<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.5962 8.54594C3.01041 9.13173 2.06066 9.13173 1.47488 8.54594C0.889091 7.96015 0.889091 7.01041 1.47488 6.42462L2.88909 5.01041L2.18198 4.3033L0.767771 5.71751C-0.20854 6.69382 -0.20854 8.27674 0.767771 9.25305C1.74408 10.2294 3.32699 10.2294 4.3033 9.25305L5.71752 7.83883L5.01041 7.13173L3.5962 8.54594ZM6.77818 3.94975L3.94975 6.77817L3.24264 6.07107L6.07107 3.24264L6.77818 3.94975ZM9.25305 4.3033L7.83884 5.71751L7.13173 5.01041L8.54595 3.59619C9.13173 3.01041 9.13173 2.06066 8.54595 1.47487C7.96016 0.889085 7.01041 0.889085 6.42462 1.47487L5.01041 2.88909L4.3033 2.18198L5.71752 0.767765C6.69383 -0.208546 8.27674 -0.208546 9.25305 0.767765C10.2294 1.74408 10.2294 3.32699 9.25305 4.3033Z" fill="' + linkStyle + '"/></svg>\')';
            this.link.style.backgroundPosition           = '50% 50%';
            this.link.style.backgroundRepeat             = 'no-repeat';
        }
        else
        {
            this.circleBack.style.display = 'none';    
            this.link      .style.display = 'none';    
        }
    }



    getActiveOffset()
    {
        return -2;
    }



    // getHeaderColors(options = {})
    // {
    //     const colors = super.getHeaderColors();

    //     colors.stripeBack = getStripeBackColor(colors.back);

    //     return colors;
    // }



    paramIsConsideredDefault(param)
    {
        return  param.isDefault()
            && !this.inputs[0].connected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"existing": "'      + boolToString(this.existing) + '"'
             + ',\n' + pos + tab + '"linkedStyleId": "' + this.linkedStyleId          + '"';
    }



    loadParams(_node, pasting)
    {
        if (!pasting)
        {
            if (_node.existing != undefined) 
               this.existing = isTrue(_node.existing);
            
            this.linkedStyleId = _node.linkedStyleId;
     
            super.loadParams(_node, pasting);
        }
        else
        {
            this.name            = this.defName;
            this.existing        = true;
            this.linkedStyleId   = NULL;
            this.linkedStyleName = '';
        }
    }
}



function OpColorStyle_value_onDisconnectInput(node, input)
{
    if (   node.existing
        && node.linkedStyleId == NULL)
        node.paramValue.setValue(FillValue.NaN, false, false, false);
}


class OpFill
extends OpColorBase
{
    paramColor;
    paramOpacity;
    paramBlend;


    checkersHolder;
    checkers;
    colorBack;



    constructor()
    {
        super(FILL, 'fill', 'fill', iconFill);

        this.canDisable  = true;
        this.iconOffsetY = 1;
        

        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.checkersHolder = createDiv('nodeHeaderCheckersHolder');
        this.checkers       = createDiv('nodeHeaderCheckers'      );
        
        this.checkersHolder.appendChild(this.checkers);
        this.inner.insertBefore(this.checkersHolder, this.header);



        this.addInput (new Input ([FILL_VALUE], getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([FILL_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));


        this.addParam(this.paramColor   = new ColorParam ('color',   'color',   false, true, true, ColorValue.fromRgb(rgbDefaultFill)));
        this.addParam(this.paramOpacity = new NumberParam('opacity', 'opacity', true,  true, true, 100, 0, 100));
        this.addParam(this.paramBlend   = new SelectParam('blend',   'blend',   false, true, true, BlendModes.map(bm => bm[1]), 0));


        this.paramColor.isNodeValue = true;
        this.paramColor.controls[0].textbox.style.background = 'transparent';
        
        this.paramOpacity.controls[0].suffix = '%';

        this.paramOpacity.divider = 0.54;
    }
    
    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return new FillValue(
            node.paramColor  .value,
            node.paramOpacity.value,
            node.paramBlend  .value);
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == FILL_VALUE, 'expected FILL_VALUE in backInit()');

        this.node.paramColor  .setValue(value.color,   false, true, false);
        this.node.paramOpacity.setValue(value.opacity, false, true, false);
        this.node.paramBlend  .setValue(value.blend,   false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramColor  .input.connected
            || this.node.paramOpacity.input.connected;

        const options = (hasInputs ? 1 : 0) << 20;
    
    
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        const value = values[paramIds.findIndex(id => id == 'value')];

        // this.paramColor  .setValue(value.color,   false, true, false);
        // this.paramOpacity.setValue(value.opacity, false, true, false);
        // this.paramBlend  .setValue(value.blend,   false, true, false);
 
        this._color = 
            value.color.isValid()
            ? value.color.toDataColor()
            : dataColor_NaN;

        this.outputs[0].types =
               this.inputs[0].connected
            && this.inputs[0].connectedOutput.supportsTypes(SHAPE_TYPES)
            ? [...this.inputs[0].connectedOutput.types, FILL_VALUE]
            : [FILL_VALUE];
    }



    updateColorControl()
    {
        const colors = this.getHeaderColors({color: true});

        colors.text = getTextColorFromBackColor(colors.stripeBack, 1);

        colors.input  = rgb_a(colors.text, 0.2);
        colors.output = rgb_a(colors.text, 0.2);


        this.paramColor.checkers.style.display = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';

        if (this.paramOpacity.value.isValid())
            this.checkersHolder.style.opacity = (100 - this.paramOpacity.value.toNumber()) + '%';


        // this.paramColor.controls[0]. backStyleLight = 
        // this.paramColor.controls[0]. backStyleDark  = 
        //     !rgbIsNaN(colors.stripeBack)
        //     ? rgb2style(colors.stripeBack, 1)
        //     : noColorStyle(colors.stripeBack);

              
        // this.paramColor.controls[0].valueStyleLight = 
        // this.paramColor.controls[0].valueStyleDark  = 'transparent';//rgba2style(rgb_a(colors.back));

        // this.paramColor.controls[0].textStyleLight  = 
        // this.paramColor.controls[0].textStyleDark   = rgba2style(colors.text);

        // this.paramColor. input.colorLight           =
        // this.paramColor. input.colorDark            = colors.input;
        
        // this.paramColor.output.colorLight           =
        // this.paramColor.output.colorDark            = colors.output;

        // this.paramColor.output.wireColor            = colors.stripeBack;
    }



    updateNode()
    {
        this.updateColorControl();

        super.updateNode();
    }



    updateHeader()
    {
        //console.log(this.id + '.OpFill.updateHeader()');
        
        Operator.prototype.updateHeader.call(this);


        const colors = this.getHeaderColors();


        updateFillHeader(this, colors);
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        const colors = this.getHeaderColors();
        this.label.style.color = rgb2style(colors.text);
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors();

        const opacity = 
            this.paramOpacity.value.isValid() 
            ? this.paramOpacity.value.value/100 
            : Number.NaN;


        colors.input  = rgb_a(colors.text, 0.2);
        colors.output = rgb_a(colors.text, 0.2);
        

        if (this.isUnknown())
        {
            colors.back       = darkMode ? hex2rgb('444' ) : hex2rgb('ccc' );
            colors.stripeBack = darkMode ? hex2rgb('444' ) : hex2rgb('ccc' );
            colors.text       = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
            colors.wire       = darkMode ? hex2rgb('888' ) : hex2rgb('aaa' );
        }
        else
        {
            colors.back       = !rgbIsNaN(colors.back      ) && !isNaN(opacity) ? rgb_a(colors.back,       opacity) : rgb_NaN;//rgbDocumentBody;
            colors.stripeBack = !rgbIsNaN(colors.stripeBack) && !isNaN(opacity) ? rgb_a(colors.stripeBack, opacity) : rgbDocumentBody;
            colors.text       = getTextColorFromBackColor(colors.stripeBack, colors.back[3]);
            colors.wire       = 
                !rgbaIsNaN(colors.stripeBack)
                ? colors.stripeBack
                : rgb_a(rgbFromType(ANY_VALUE, false));
        }
        

        return colors;
    }



    updateParams()
    {
        const enable = 
              !this.inputs[0].connected
            || this.inputs[0].connectedOutput.supportsTypes(SHAPE_TYPES);

        this.paramColor  .enableControlText(enable, this.paramColor  .isUnknown());
        this.paramOpacity.enableControlText(enable, this.paramOpacity.isUnknown());
        this.paramBlend  .enableControlText(enable, this.paramBlend  .isUnknown());

        this.updateParamControls();
    }



    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const colors = this.getHeaderColors();
        
            
        if (   !rgbIsNaN(colors.back)
            && this.paramOpacity.value.isValid())
        {
            if (  !this.paramOpacity.value.isValid()
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(colors.back);

                this.updateWarningOverlayStyle(colors.back);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(colors.back);
            this.updateWarningOverlayStyle(colors.back);
        }
    }
}



function updateFillHeader(node, colors)
{
    const unknownBackStyle = darkMode ? '#444' : '#ccc';

    
    node.header.style.background = 'transparent';

    node.colorBack.style.background = 
        node.isUnknown()
        ? unknownBackStyle
        : (  !rgbIsNaN(colors.stripeBack)
           && node.paramOpacity.value.isValid()
           ? rgba2style(colors.stripeBack)
           : rgba2style(rgb_a(rgbDocumentBody, 0.95)));

    node.colorBack.style.backgroundImage = 
        node.isUnknown()
        ? 'url(\'data:image/svg+xml;utf8,<svg width="35" height="51" viewBox="0 0 35 51" fill="none" xmlns="http://www.w3.org/2000/svg"><path opacity="0.1" d="M11.8434 33.3907V32.6328C11.8581 30.0323 12.0865 27.9593 12.5284 26.4139C12.9851 24.8684 13.6479 23.6202 14.517 22.6691C15.3861 21.7181 16.432 20.8562 17.6546 20.0835C18.568 19.489 19.3855 18.8724 20.1073 18.2334C20.8291 17.5944 21.4036 16.8885 21.8308 16.1158C22.258 15.3282 22.4716 14.4515 22.4716 13.4856C22.4716 12.4602 22.2285 11.5612 21.7424 10.7884C21.2563 10.0157 20.6008 9.42129 19.7759 9.00521C18.9657 8.58913 18.0671 8.38109 17.0802 8.38109C16.1227 8.38109 15.2167 8.59658 14.3624 9.02753C13.508 9.44361 12.8083 10.0677 12.2632 10.8999C11.7182 11.7172 11.4236 12.7351 11.3794 13.9537H2.36426C2.43791 10.9816 3.14498 8.52969 4.48547 6.59789C5.82597 4.65122 7.60102 3.20234 9.8106 2.25129C12.0202 1.28538 14.4581 0.802429 17.1244 0.802429C20.0558 0.802429 22.6483 1.29281 24.9021 2.27358C27.1559 3.23949 28.9236 4.64377 30.2052 6.48644C31.4867 8.32911 32.1275 10.5507 32.1275 13.1512C32.1275 14.8898 31.8403 16.4353 31.2658 17.7876C30.706 19.125 29.9179 20.3138 28.9015 21.354C27.8851 22.3794 26.6845 23.3081 25.2999 24.1403C24.1361 24.8387 23.1787 25.5669 22.4274 26.3247C21.6908 27.0826 21.1385 27.9593 20.7702 28.955C20.4167 29.9506 20.2325 31.1766 20.2178 32.6328V33.3907H11.8434ZM16.2184 47.6563C14.7454 47.6563 13.4859 47.1365 12.44 46.0961C11.4089 45.0412 10.9007 43.778 10.9154 42.3068C10.9007 40.8506 11.4089 39.6023 12.44 38.5621C13.4859 37.5218 14.7454 37.0017 16.2184 37.0017C17.6178 37.0017 18.8478 37.5218 19.9085 38.5621C20.9691 39.6023 21.5067 40.8506 21.5214 42.3068C21.5067 43.2876 21.249 44.1868 20.7481 45.004C20.262 45.8062 19.6212 46.4527 18.8257 46.9431C18.0303 47.4186 17.1612 47.6563 16.2184 47.6563Z" fill="' + (darkMode ? 'white' : 'black') + '"/></svg>\')'
        : 'none';

    node.colorBack.style.height = node.measureData.headerOffset.height;

    node.colorBack.style.backgroundPosition = '50% 50%';
    node.colorBack.style.backgroundRepeat   = 'no-repeat';


    if (    node.isUnknown()
        || !node.paramOpacity.value.isValid())
        node.checkers.style.display = 'none';

    else
    {
        node.checkers.style.height = node.header.offsetHeight;

        node.checkers.style.background =
            darkMode
            ?     'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
                + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :     'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
                + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        node.checkers.style.display            = !rgbIsNaN(colors.stripeBack) ? 'inline-block' : 'none';
        node.checkers.style.backgroundColor    =  darkMode ? '#444' : '#fff';

        node.checkers.style.backgroundSize     = '22px 22px';
        node.checkers.style.backgroundPosition = '0 0, 11px 11px';

        node.checkers.style.left               = '-3px';
        node.checkers.style.width              = 'calc(100% + 3px)';
    }
                        

    node.inputs[0] .colorLight = 
    node.inputs[0] .colorDark  = colors.input;
    node.inputs[0] .wireColor  = colors.wire;

    node.outputs[0].colorLight =
    node.outputs[0].colorDark  = colors.output;
    node.outputs[0].wireColor  = colors.wire;


    if (node.isUnknown())
        node._warningOverlay.style.display = 'none';

    else
    {
        const colWarning = 
            isDark(colors.back)
            ? [1, 1, 1, 0.2 ]
            : [0, 0, 0, 0.12];

        node.warningStyle = 
               rgbIsValid(colors.back) 
            && node.paramOpacity.value.isValid()
            ? 'transparent' 
            :  rgba2style(colWarning);

            
        node.updateWarningOverlay();
        node.updateWarningOverlayStyle(colors.back, defHeaderHeight + defParamHeight);
    }
}


class OpColorStop
extends OpColorBase
{
    paramFill;
    paramPosition;

    checkers;
    colorBack;


    
    constructor()
    {
        super(COLOR_STOP, 'colorStop', 'color stop', iconColorStop);

        this.canDisable  = true;
        this.iconOffsetY = -1;
        

        this.colorBack = createDiv('colorBack');
        this.inner.appendChild(this.colorBack, this.paramHolder);


        this.checkersHolder = createDiv('nodeHeaderCheckersHolder');
        this.checkers       = createDiv('nodeHeaderCheckers');
        
        this.checkersHolder.appendChild(this.checkers);
        this.inner.insertBefore(this.checkersHolder, this.header);


        this.addInput (new Input([COLOR_STOP_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([COLOR_STOP_VALUE], this.output_genRequest));//, getNodeOutputValuesForUndo));


        this.addParam(this.paramFill     = new FillParam  ('fill',     'fill',     false, true, true, FillValue.create(0, 0, 0, 100)));
        this.addParam(this.paramPosition = new NumberParam('position', 'position', true,  true, true, 0, 0, 100));


        this.paramPosition.controls[0].suffix = '%';

        this.paramPosition.divider = 0.55;
    }
    
    
    
    // canAutoConnectFrom(output)
    // {
    //     return output.supportsTypes(FILL_TYPES)
    //         || output.supportsTypes(COLOR_TYPES);
    // }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramFill    .input.connected
            || this.node.paramPosition.input.connected;

        const options = (hasInputs ? 1 : 0) << 20;


        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramFill    .setValue(value.fill,     false, true, false);
        this.paramPosition.setValue(value.position, false, true, false);


        this._color = 
               value.fill
            && value.fill.isValid()
            ? value.fill.color.toDataColor()
            : dataColor_NaN;

            
        // this.outputs[0].types =
        //        this.inputs[0].connected
        //     && this.inputs[0].connectedOutput.supportsTypes(SHAPE_TYPES)
        //     ? [...this.inputs[0].connectedOutput.types, COLOR_STOP_VALUE]
        //     : [COLOR_STOP_VALUE];


        // super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        //console.log(this.id + '.OpStroke.updateHeader()');

        Operator.prototype.updateHeader.call(this);


        const colors = this.getHeaderColors();


        const unknownBackStyle = darkMode ? '#444' : '#ccc';


        this.header.style.background = 'transparent';

        this.colorBack.style.background = 
            this.isUnknown()
            ? unknownBackStyle
            : !rgbIsNaN(colors.stripeBack)
            ? rgba2style(colors.stripeBack)
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));


        this.colorBack.style.height = this.measureData.headerOffset.height;

            
        this.checkers.style.height = this.header.offsetHeight;

        this.checkers.style.background =
            darkMode
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = darkMode ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '22px 22px';
        this.checkers.style.backgroundPosition = '0 0, 11px 11px';
                        
        this.checkers.style.left               = '-3px';
        this.checkers.style.width              = 'calc(100% + 3px)';


        if (this.paramFill.value.opacity.isValid())
            this.checkersHolder.style.opacity = (100 - this.paramFill.value.opacity.toNumber()) + '%';


        this.header.style.background = 'transparent';
            // !rgbIsNaN(colors.stripeBack)
            // ? rgba2style(colors.stripeBack) 
            // : 'transparent';


        this.inputs[0] .colorLight = 
        this.inputs[0] .colorDark  = colors.input;
        this.inputs[0] .wireColor  = colors.wire;

        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = colors.output;
        this.outputs[0].wireColor  = colors.wire;


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colors.back, 45);
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        const colors = this.getHeaderColors();
        this.label.style.color = rgba2style(colors.text);
    }



    updateParams()
    {
        const enableFill = !this.paramFill.input.connected;
 
        const enable = 
               !this.inputs[0].connected
            || !this.inputs[0].connectedOutput.supportsTypes(COLOR_STOP_TYPES);

        this.paramFill    .enableControlText(enableFill);
        this.paramPosition.enableControlText(enable);

        this.updateParamControls();
    }

    

    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors();

        colors.input      = rgb_a(colors.text, 0.2);
        colors.output     = rgb_a(colors.text, 0.2);


            
        // if (this.isUnknown())
        // {
        //     colors.back       = darkMode ? hex2rgb('444')  : hex2rgb('ccc');
        //     colors.stripeBack = darkMode ? hex2rgb('444')  : hex2rgb('ccc');
        //     colors.text       = darkMode ? hex2rgb('fff8') : hex2rgb('0008');
        //     colors.wire       = darkMode ? hex2rgb('888')  : hex2rgb('aaa');
        // }
        // else
        // {
            const opacity = this.paramFill.value.opacity.value/100;

            colors.back       = rgb_a(colors.back,       opacity);
            colors.stripeBack = rgb_a(colors.stripeBack, opacity);
            colors.text       = getTextColorFromBackColor(colors.stripeBack, opacity);
            colors.wire       = 
                !rgbaIsNaN(colors.stripeBack)
                ? colors.stripeBack
                : rgbFromType(ANY_VALUE, false);
        // }


        return colors;
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        super.updateWarningOverlayStyle(colBack, height);
        
        this._warningOverlay.style.backgroundPosition = '-1.5px 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 16px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
}


class   OpGradient
extends OpColorBase
{
    paramType;
    paramX;
    paramY;
    paramSize;
    paramAngle;
    paramAspect;
    paramSkew;
    paramBlend;


    checkersHolder;
    checkers;
    colorBack;



    constructor()
    {
        super(GRADIENT, 'grad', 'gradient', iconGradient);

        this.iconOffsetY    = 1;
        this.canDisable     = true;
        this.variableInputs = true;


        this.colorBack      = createDiv('colorBack');
        this.checkersHolder = createDiv('nodeHeaderCheckersHolder');
        this.checkers       = createDiv('nodeHeaderCheckers');

        this.inner.appendChild(this.colorBack);
        this.inner.insertBefore(this.checkersHolder, this.header);

        this.checkersHolder.appendChild(this.checkers);


        this.addNewInput();
        this.addOutput(new Output([GRADIENT_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));
        

        this.addParam(this.paramType   = new SelectParam('type',   '',       false, true, true,  ['linear', 'radial', 'angular', 'diamond'], 0));
        this.addParam(this.paramX      = new NumberParam('x',      'x',      true,  true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true,  true, true,  50));
        this.addParam(this.paramSize   = new NumberParam('size',   'size',   true,  true, true, 100));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true,  true, true,   0));
        this.addParam(this.paramAspect = new NumberParam('aspect', 'aspect', true,  true, true,  50));
        this.addParam(this.paramSkew   = new NumberParam('skew',   'skew',   true,  true, true,   0));
        this.addParam(this.paramBlend  = new SelectParam('blend',  'blend',  false, true, true, BlendModes.map(bm => bm[1]), 0));


        this.paramX     .controls[0].suffix        = '%';
        this.paramY     .controls[0].suffix        = '%';
        this.paramSize  .controls[0].suffix        = '%';
        this.paramAngle .controls[0].suffix        = '°';
        this.paramAngle .controls[0].suffixOffsetY = -4;
        this.paramAspect.controls[0].suffix        = '%';
        this.paramSkew  .controls[0].suffix        = '%';
    }
    
    
    
    addNewInput()
    {
        const input = new Input([COLOR_VALUE, FILL_VALUE, COLOR_STOP_VALUE, GRADIENT_VALUE, LIST_VALUE]);
        input.isNew = true;

        input.addEventListener('connect',    e => { onVariableListConnectInput(e.detail.input); input.isNew = false; });
        input.addEventListener('disconnect', e => onVariableListDisconnectInput(e.detail.input));

        this.addInput(input);

        return input;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramType  .genRequest(gen));
        request.push(...this.node.paramX     .genRequest(gen));
        request.push(...this.node.paramY     .genRequest(gen));
        request.push(...this.node.paramSize  .genRequest(gen));
        request.push(...this.node.paramAngle .genRequest(gen));
        request.push(...this.node.paramAspect.genRequest(gen));
        request.push(...this.node.paramSkew  .genRequest(gen));
        request.push(...this.node.paramBlend .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramType  .setValue(value.gradType, false, true, false);
        this.paramX     .setValue(value.x,        false, true, false);
        this.paramY     .setValue(value.y,        false, true, false);
        this.paramSize  .setValue(value.size,     false, true, false);
        this.paramAngle .setValue(value.angle,    false, true, false);
        this.paramAspect.setValue(value.aspect,   false, true, false);
        this.paramSkew  .setValue(value.skew,     false, true, false);
        this.paramBlend .setValue(value.blend,    false, true, false);
    }
}



class OpStroke
extends OpColorBase
{
    paramFills;
    paramWeight;
    paramFit;
    paramJoin;
    paramMiter;
    paramCap;
    paramDashes;

    checkers;
    colorBack;


    
    constructor()
    {
        super(STROKE, 'stroke', 'stroke', iconStroke);

        this.canDisable  = true;
        this.iconOffsetY = 1;
        

        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);
        
        this.checkersHolder = createDiv('nodeHeaderCheckersHolder');
        this.checkers       = createDiv('nodeHeaderCheckers');
        
        this.checkersHolder.appendChild(this.checkers);
        this.inner.insertBefore(this.checkersHolder, this.header);



        this.addInput (new Input ([STROKE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([STROKE_VALUE], this.output_genRequest, getNodeOutputValuesForUndo));


        this.addParam(this.paramFills  = new   ListParam('fills',  'fills',  false, true, true));
        this.addParam(this.paramWeight = new NumberParam('weight', 'weight', true,  true, true, 1, 0));
        this.addParam(this.paramFit    = new SelectParam('fit',    'align',  true,  true, true, ['inside', 'center', 'outside'], 1));
        this.addParam(this.paramJoin   = new SelectParam('join',   'join',   true,  true, true, ['miter', 'bevel', 'round'], 0));
        this.addParam(this.paramMiter  = new NumberParam('miter',  'miter',  true,  true, true, 28.96, 0, 180, 2));
        this.addParam(this.paramCap    = new SelectParam('cap',    'cap',    true,  true, true, ['none', 'square', 'round'], 0));
        this.addParam(this.paramDashes = new   TextParam('dashes', 'dashes', false, true, true));

        this.paramFills.itemName  = 'fill';
        this.paramFills.showZero  = false;
        this.paramFills.listTypes = [COLOR_VALUE, FILL_VALUE, GRADIENT_VALUE];
        this.paramFills.input.types.push(...this.paramFills.listTypes);


        this.setAllParamDividers(0.45);

        this.paramMiter.controls[0].setSuffix('°', true);
        this.paramMiter.controls[0].suffixOffsetY = -4;
        this.paramMiter.canShow = () => this.paramJoin.value == 0;

        this.paramDashes.controls[0].textbox.defPlaceholder = 'no dashes';
    }
    
    
    
    // canAutoConnectFrom(output)
    // {
    //     return output.supportsTypes(FILL_TYPES)
    //         || output.supportsTypes(COLOR_TYPES);
    // }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramFills .input.connected
            || this.node.paramWeight.input.connected
            || this.node.paramFit   .input.connected
            || this.node.paramJoin  .input.connected
            || this.node.paramMiter .input.connected
            || this.node.paramCap   .input.connected
            || this.node.paramDashes.input.connected;

        const options = (hasInputs ? 1 : 0) << 20;


        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        this.outputs[0].types =
               this.inputs[0].connected
            && this.inputs[0].connectedOutput.supportsTypes(SHAPE_TYPES)
            ? [...this.inputs[0].connectedOutput.types, STROKE_VALUE]
            : [STROKE_VALUE];
    }



    updateHeader()
    {
        //console.log(this.id + '.OpStroke.updateHeader()');

        Operator.prototype.updateHeader.call(this);


        const colors           = this.getHeaderColors();

        const unknownBackStyle = darkMode ? '#444' : '#ccc';


        this.header.style.background = 'transparent';

        this.colorBack.style.background = 
            this.isUnknown()
            ? unknownBackStyle
            : (!rgbIsNaN(colors.stripeBack) //!rgbIsNaN(colors.back)
               ? rgba2style(colors.stripeBack)
               : rgba2style(rgb_a(rgbDocumentBody, 0.95)));


        this.colorBack.style.height = this.measureData.headerOffset.height;

        
        const fills = this.paramFills.value.items;
            
        if (    this.isUnknown()
            ||  fills.length == 0
            || !fills[0].isValid())
            this.checkers.style.display = 'none';

        else
        {
            this.checkers.style.height = this.header.offsetHeight;

            this.checkers.style.background =
                darkMode
                ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
                  + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
                :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
                  + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

            this.checkers.style.display            = !rgbIsNaN(colors.stripeBack) ? 'inline-block' : 'none';
            this.checkers.style.backgroundColor    = darkMode ? '#444' : '#fff';

            this.checkers.style.backgroundSize     = '22px 22px';
            this.checkers.style.backgroundPosition = '0 0, 11px 11px';
                            
            this.checkers.style.left               = '-3px';
            this.checkers.style.width              = 'calc(100% + 3px)';
        }


        // this.header.style.background = 
        //     !rgbIsNaN(colors.stripeBack)
        //     ? rgba2style(colors.stripeBack) 
        //     : 'transparent';


        this.inputs[0] .colorLight = 
        this.inputs[0] .colorDark  = colors.input;
        this.inputs[0] .wireColor  = colors.wire;

        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = colors.output;
        this.outputs[0].wireColor  = colors.wire;


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colors.back, 45);
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        const colors = this.getHeaderColors();
        this.label.style.color = rgba2style(colors.text);
    }



    updateParams()
    {
        const enableFills = !this.paramFills.input.connected;
 
        const enable = 
               !this.inputs[0].connected
            || !this.inputs[0].connectedOutput.supportsTypes(STROKE_TYPES);

        this.paramFills .enableControlText(enableFills, this.paramFills .isUnknown());
        this.paramWeight.enableControlText(enable,      this.paramWeight.isUnknown());
        this.paramFit   .enableControlText(enable,      this.paramFit   .isUnknown());
        this.paramJoin  .enableControlText(enable,      this.paramJoin  .isUnknown());
        this.paramMiter .enableControlText(enable,      this.paramMiter .isUnknown());


        const fills = this.paramFills.value.items;

        if (   fills.length > 0
            && fills[0].isValid())
            this.checkersHolder.style.opacity = (100 - fills[0].opacity.toNumber()) + '%';


        this.updateParamControls();
    }

    

    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors();
        const fills  = this.paramFills.value.items;


        if (   fills.length > 0
            && fills[0].isValid())
        {
            colors.back       = fills[0].isValid() ? fills[0].toRgba() : rgba_NaN;
            colors.stripeBack = fills[0].isValid() ? fills[0].toRgba() : rgba_NaN;
            colors.text       = getTextColorFromBackColor(colors.stripeBack, fills[0].opacity.value/100);
            colors.input      = rgb_a(colors.text, 0.2);
            colors.output     = rgb_a(colors.text, 0.2);

            colors.wire = 
                !rgbaIsNaN(colors.stripeBack)
                ? colors.stripeBack
                : rgbFromType(ANY_VALUE, true);
        }
        else
        {
            colors.stripeBack = rgbDocumentBody;
        }

        

        return colors;
    }



    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const colors = this.getHeaderColors();
        
            
        if (  !rgbIsNaN(colors.back)
            && this.paramFills.value.isValid())
        {
            if (  !this.paramFills.value.isValid()
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(colors.back);

                this.updateWarningOverlayStyle(colors.back);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(colors.back);
            this.updateWarningOverlayStyle(colors.back);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        super.updateWarningOverlayStyle(colBack, height);
        
        this._warningOverlay.style.backgroundPosition = '-1.5px 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 16px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
}


class OpDropShadow
extends OperatorBase
{
    paramX;
    paramY;
    paramBlur;
    paramSpread;
    paramFill;
    paramBlend;
    paramBehind;


    
    constructor()
    {
        super(DROP_SHADOW, 'dropShadow', 'drop shadow', iconDropShadow);

        this.canDisable = true;
        

        this.addInput (new Input([DROP_SHADOW_VALUE], getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([DROP_SHADOW_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));


        this.addParam(this.paramX      = new NumberParam('x',      'X',           true,  true, true, 0));
        this.addParam(this.paramY      = new NumberParam('y',      'Y',           true,  true, true, 4));
        this.addParam(this.paramBlur   = new NumberParam('blur',   'blur',        true,  true, true, 4, 0));
        this.addParam(this.paramSpread = new NumberParam('spread', 'spread',      true,  true, true, 0));
        this.addParam(this.paramFill   = new FillParam  ('fill',   'fill',        false, true, true, new FillValue(ColorValue.fromRgb([0, 0, 0]), new NumberValue(25))));
        this.addParam(this.paramBlend  = new SelectParam('blend',  'blend',       false,  true, true, BlendModes.map(bm => bm[1]), 0));
        this.addParam(this.paramBehind = new NumberParam('behind', 'show behind', true,  true, true, 0, 0, 1));


        this.setAllParamDividers(0.55);

        this.paramBehind.divider = 0.71;
        //this.paramBlend .divider = 0.42;
    }
    
    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return new DropShadowValue(
            node.paramX     .value,
            node.paramY     .value,
            node.paramBlur  .value,
            node.paramSpread.value,
            node.paramFill  .value,
            node.paramBlend .value,
            node.paramBehind.value);
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == DROP_SHADOW_VALUE, 'expected DROP_SHADOW_VALUE in backInit()');

        this.node.paramX     .setValue(value.x,      false, true, false);
        this.node.paramY     .setValue(value.y,      false, true, false);
        this.node.paramBlur  .setValue(value.blur,   false, true, false);
        this.node.paramSpread.setValue(value.spread, false, true, false);
        this.node.paramFill  .setValue(value.fill,   false, true, false);
        this.node.paramBlend .setValue(value.blend,  false, true, false);
        this.node.paramBehind.setValue(value.behind, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramX     .input.connected
            || this.node.paramY     .input.connected
            || this.node.paramBlur  .input.connected
            || this.node.paramSpread.input.connected
            || this.node.paramFill  .input.connected
            || this.node.paramBlend .input.connected
            || this.node.paramBehind.input.connected;

        const options = (hasInputs ? 1 : 0) << 20;
    
    
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramX     .enableControlText(true);
        this.paramY     .enableControlText(true);
        this.paramBlur  .enableControlText(true);
        this.paramSpread.enableControlText(true);
        this.paramFill  .enableControlText(true);
        this.paramBlend .enableControlText(true);
        this.paramBehind.enableControlText(true);

        updateParamConditionText(this.paramBehind, this.paramBehind.isUnknown(), false, 1);

        this.updateParamControls();
    }
}



class OpInnerShadow
extends OperatorBase
{
    paramX;
    paramY;
    paramBlur;
    paramSpread;
    paramFill;
    paramBlend;


    
    constructor()
    {
        super(INNER_SHADOW, 'innerShadow', 'inner shadow', iconInnerShadow);

        this.canDisable = true;
        

        this.addInput (new Input([INNER_SHADOW_VALUE], getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([INNER_SHADOW_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));


        this.addParam(this.paramX      = new NumberParam('x',      'X',      true,  true, true, 0));
        this.addParam(this.paramY      = new NumberParam('y',      'Y',      true,  true, true, 4));
        this.addParam(this.paramBlur   = new NumberParam('blur',   'blur',   true,  true, true, 4, 0));
        this.addParam(this.paramSpread = new NumberParam('spread', 'spread', true,  true, true, 0));
        this.addParam(this.paramFill   = new FillParam  ('fill',   'fill',   false, true, true, new FillValue(ColorValue.fromRgb([0, 0, 0]), new NumberValue(25))));
        this.addParam(this.paramBlend  = new SelectParam('blend',  'blend',  false, true, true, BlendModes.map(bm => bm[1]), 0));


        this.setAllParamDividers(0.55);
    }
    
    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return new InnerShadowValue(
            node.paramX     .value,
            node.paramY     .value,
            node.paramBlur  .value,
            node.paramSpread.value,
            node.paramFill  .value,
            node.paramBlend .value);
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == INNER_SHADOW_VALUE, 'expected INNER_SHADOW_VALUE in backInit()');

        this.node.paramX     .setValue(value.x,      false, true, false);
        this.node.paramY     .setValue(value.y,      false, true, false);
        this.node.paramBlur  .setValue(value.blur,   false, true, false);
        this.node.paramSpread.setValue(value.spread, false, true, false);
        this.node.paramFill  .setValue(value.fill,   false, true, false);
        this.node.paramBlend .setValue(value.blend,  false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramX     .input.connected
            || this.node.paramY     .input.connected
            || this.node.paramBlur  .input.connected
            || this.node.paramSpread.input.connected
            || this.node.paramFill  .input.connected
            || this.node.paramBlend .input.connected;

        const options = (hasInputs ? 1 : 0) << 20;
    
    
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class OpLayerBlur
extends OperatorBase
{
    paramRadius;


    
    constructor()
    {
        super(LAYER_BLUR, 'layerBlur', 'layer blur', iconLayerBlur);

        this.canDisable = true;
        

        this.addInput (new Input([LAYER_BLUR_VALUE], getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([LAYER_BLUR_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));


        this.addParam(this.paramRadius = new NumberParam('radius', 'radius', true, true, true, 4, 0));


        this.paramRadius.divider = 0.58;
    }
    
    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return new LayerBlurValue(
            node.paramRadius.value);
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == LAYER_BLUR_VALUE, 'expected LAYER_BLUR_VALUE in backInit()');

        this.node.paramRadius.setValue(value.radius, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs = this.node.paramRadius.input.connected;

        const options   = (hasInputs ? 1 : 0) << 20;
    
    
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class OpBackBlur
extends OperatorBase
{
    paramRadius;


    
    constructor()
    {
        super(BACK_BLUR, 'backBlur', 'back blur', iconBackBlur);

        this.canDisable  = true;
        this.iconOffsetY = 1;
        

        this.addInput (new Input([BACK_BLUR_VALUE], getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([BACK_BLUR_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));


        this.addParam(this.paramRadius = new NumberParam('radius', 'radius', true, true, true, 4, 0));


        this.paramRadius.divider = 0.58;
    }
    
    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return new BackBlurValue(
            node.paramRadius.value);
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == BACK_BLUR_VALUE, 'expected BACK_BLUR_VALUE in backInit()');

        this.node.paramRadius.setValue(value.radius, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs = this.node.paramRadius.input.connected;

        const options   = (hasInputs ? 1 : 0) << 20;
    
    
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class OpLayerMask
extends OperatorBase
{
    constructor()
    {
        super(LAYER_MASK, 'mask', 'mask', iconMask);

        this.canDisable  = true;
        this.iconOffsetY = -1;
        

        this.addOutput(new Output([LAYER_MASK_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));
    }
    
    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpShapeBase
extends OperatorBase
{
    constructor(type, id, name, icon, defWidth = defNodeWidth)
    {
        super(type, id, name, icon, defWidth);
    }



    setName(newName, options = {})
    {
        super.setName(newName, options);

        if (isValid(options.updateNodes))
            pushUnique(options.updateNodes, this);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
                
        
        const paramIds = [];
        
        
        const input = this.node.inputs[0];


        if (input)
            request.push(input.connected ? 1 : 0);


        if (   input
            && input.connected)
        {
            request.push(...pushInputOrParam(input, gen));

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected
                    && param.canShow())
                    paramIds.push(param.id);
        }
        else
        {
            for (const param of this.node.params)
                if (param.canShow())
                    paramIds.push(param.id);
        }


        request.push(paramIds.length);

        for (const paramId of paramIds)
            request.push(paramId, ...this.node.params.find(p => p.id == paramId).genRequest(gen));            


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        const enable = !this.inputs[0].connected;
        
        for (const param of this.params)
            param.enableControlText(enable);

        this.updateParamControls();
    }
}



class   OpShape
extends OpShapeBase
{
    paramProps;


    constructor(type, id, name, icon, defWidth = defNodeWidth)
    {
        super(type, id, name, icon, defWidth);
    }



    addBaseParams()
    {
        this.addParam(this.paramProps = new ListParam('props', 'styles', false, true, true));

        this.paramProps.controls[0].valueText = 'style';
        
        this.paramProps.itemName  = 'style';
        this.paramProps.showZero  = false;
        this.paramProps.listTypes = [...STYLE_VALUES];
        this.paramProps.input.types.push(...this.paramProps.listTypes);
    }
}



class   OpRectangle
extends OpShape
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramRound;


    
    constructor()
    {
        super(RECTANGLE, 'rect', 'rectangle', iconRectangle);

        this.iconOffsetY = -1;
        this.canDisable  = true;
        

        this.addInput (this.createInputForObjects([RECTANGLE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([RECTANGLE_VALUE], this.output_genRequest));


        this.addParam(this.paramX      = new NumberParam('x',      'X',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'Y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100));
        this.addParam(this.paramRound  = new NumberParam('round',  'round',  true, true, true,   0, 0));


        this.paramWidth .addEventListener('change', () => this.updateRound());
        this.paramHeight.addEventListener('change', () => this.updateRound());


        this.addBaseParams();
        this.setAllParamDividers(0.5);
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX     .setValue(value.x,      false, true, false);
        this.paramY     .setValue(value.y,      false, true, false);
        this.paramWidth .setValue(value.width,  false, true, false);
        this.paramHeight.setValue(value.height, false, true, false);
        this.paramRound .setValue(value.round,  false, true, false);
    }



    updateRound()
    {
        const min = Math.min(this.paramWidth.value.value, this.paramHeight.value.value);

        this.paramRound.controls[0].displayMin = 0;
        this.paramRound.controls[0].displayMax = Math.abs(min/2);

        this.paramRound.controls[0].update();
    }
}


class   OpLine
extends OpShape
{
    paramX;
    paramY;
    paramWidth;

    
    constructor()
    {
        super(LINE, 'line', 'line', iconLine);

        this.canDisable = true;

        
        this.addInput (this.createInputForObjects([LINE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([LINE_VALUE], this.output_genRequest));

        this.addParam(this.paramX      = new NumberParam('x',      'X',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'Y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100));
        

        this.addBaseParams();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX    .setValue(value.x,     false, true, false);
        this.paramY    .setValue(value.y,     false, true, false);
        this.paramWidth.setValue(value.width, false, true, false);
    }
}


class   OpEllipse
extends OpShape
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramFrom;
    paramTo;
    paramInner;


    
    constructor()
    {
        super(ELLIPSE, 'ellipse', 'ellipse', iconEllipse);

        this.canDisable  = true;
        this.iconOffsetY = -1;
        

        this.addInput (this.createInputForObjects([ELLIPSE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([ELLIPSE_VALUE], this.output_genRequest));


        this.addParam(this.paramX      = new NumberParam('x',      'X',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'Y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100));
        this.addParam(this.paramInner  = new NumberParam('inner',  'inner',  true, true, true,   0, 0, 100));
        this.addParam(this.paramFrom   = new NumberParam('from',   'from',   true, true, true,   0));
        this.addParam(this.paramTo     = new NumberParam('to',     'to',     true, true, true, 360));
        

        this.paramFrom .controls[0].setSuffix('°', true);
        this.paramTo   .controls[0].setSuffix('°', true);
        this.paramInner.controls[0].setSuffix('%', true);

        this.paramFrom .controls[0].wrapValue     = true;
        this.paramTo   .controls[0].wrapValue     = true;

        this.paramFrom .controls[0].suffixOffsetY = -4;
        this.paramTo   .controls[0].suffixOffsetY = -4;


        this.addBaseParams();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX     .setValue(value.x,      false, true, false);
        this.paramY     .setValue(value.y,      false, true, false);
        this.paramWidth .setValue(value.width,  false, true, false);
        this.paramHeight.setValue(value.height, false, true, false);
        this.paramFrom  .setValue(value.from,   false, true, false);
        this.paramTo    .setValue(value.to,     false, true, false);
        this.paramInner .setValue(value.inner,  false, true, false);
    }
}


class   OpTrapeze
extends OpShape
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramRound;
    paramBias;


    
    constructor()
    {
        super(TRAPEZE, 'trapeze', 'trapeze', iconTrapeze);

        this.iconOffsetY = 1;
        this.canDisable  = true;
        

        this.addInput (this.createInputForObjects([TRAPEZE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([TRAPEZE_VALUE], this.output_genRequest));


        this.addParam(this.paramX      = new NumberParam('x',      'X',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'Y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100));
        this.addParam(this.paramRound  = new NumberParam('round',  'round',  true, true, true,   0, 0));
        this.addParam(this.paramBias   = new NumberParam('bias',   'bias',   true, true, true, -50, -100, 100));

        this.paramWidth .addEventListener('change', () => this.updateRound());
        this.paramHeight.addEventListener('change', () => this.updateRound());

        this.paramBias.controls[0].suffix = '%';


        this.addBaseParams();
        this.setAllParamDividers(0.5);
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX     .setValue(value.x,      false, true, false);
        this.paramY     .setValue(value.y,      false, true, false);
        this.paramWidth .setValue(value.width,  false, true, false);
        this.paramHeight.setValue(value.height, false, true, false);
        this.paramRound .setValue(value.round,  false, true, false);
        this.paramBias  .setValue(value.bias,   false, true, false);
    }



    updateRound()
    {
        const min = Math.min(this.paramWidth.value.value, this.paramHeight.value.value);

        this.paramRound.controls[0].displayMin = 0;
        this.paramRound.controls[0].displayMax = Math.abs(min/2);

        this.paramRound.controls[0].update();
    }
}


class   OpPolygon
extends OpShape
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramRound;
    paramCorners;


    
    constructor()
    {
        super(POLYGON, 'poly', 'polygon', iconPolygon);

        this.canDisable  = true;
        this.iconOffsetY = -2;

        
        this.addInput (this.createInputForObjects([POLYGON_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([POLYGON_VALUE], this.output_genRequest));

        this.addParam(this.paramX       = new NumberParam('x',       'X',       true, true, true,   0));
        this.addParam(this.paramY       = new NumberParam('y',       'Y',       true, true, true,   0));
        this.addParam(this.paramWidth   = new NumberParam('width',   'width',   true, true, true, 100,    0.01));
        this.addParam(this.paramHeight  = new NumberParam('height',  'height',  true, true, true, 100,    0.01));
        this.addParam(this.paramRound   = new NumberParam('round',   'round',   true, true, true,   0,    0));
        this.addParam(this.paramCorners = new NumberParam('corners', 'corners', true, true, true,   3,    3));
        

        this.addBaseParams();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX      .setValue(value.x,       false, true, false);
        this.paramY      .setValue(value.y,       false, true, false);
        this.paramWidth  .setValue(value.width,   false, true, false);
        this.paramHeight .setValue(value.height,  false, true, false);
        this.paramRound  .setValue(value.round,   false, true, false);
        this.paramCorners.setValue(value.corners, false, true, false);
    }



    updateRound()
    {
        const control = this.paramRound.controls[0];
        const min     = Math.min(this.paramWidth.value, this.paramHeight.value);

        control.setMin(0);
        control.setMax(min/2);

        control.update();
    }
}


class   OpStar
extends OpShape
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramRound;
    paramPoints;
    paramConvex;


    
    constructor()
    {
        super(STAR, 'star', 'star', iconStar);

        this.canDisable  = true;
        this.iconOffsetY = -3;

        
        this.addInput (this.createInputForObjects([STAR_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([STAR_VALUE], this.output_genRequest));

        this.addParam(this.paramX      = new NumberParam('x',      'X',      true, true, true, 0));
        this.addParam(this.paramY      = new NumberParam('y',      'Y',      true, true, true, 0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100, 0.01));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100, 0.01));
        this.addParam(this.paramRound  = new NumberParam('round',  'round',  true, true, true, 0, 0));
        this.addParam(this.paramPoints = new NumberParam('points', 'points', true, true, true, 5, 3));
        this.addParam(this.paramConvex = new NumberParam('convex', 'convex', true, true, true, 38.2, 0, 100));
        

        this.paramConvex.controls[0].setSuffix('%', true);


        this.addBaseParams();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX     .setValue(value.x,      false, true, false);
        this.paramY     .setValue(value.y,      false, true, false);
        this.paramWidth .setValue(value.width,  false, true, false);
        this.paramHeight.setValue(value.height, false, true, false);
        this.paramRound .setValue(value.round,  false, true, false);
        this.paramPoints.setValue(value.points, false, true, false);
        this.paramConvex.setValue(value.convex, false, true, false);
    }



    updateRound()
    {
        const control = this.paramRound.controls[0];
        const min     = Math.min(this.paramWidth.value, this.paramHeight.value);

        control.setMin(0);
        control.setMax(min/2);

        this.paramRound.controls[0].update();
    }
}


class   OpTextShape
extends OpShape
{
    paramText;
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramFont;
    paramSize;
    paramStyle;
    paramAlignH;
    paramAlignV;
    paramLineHeight;
    paramLetterSpacing;


    
    constructor()
    {
        super(TEXT_SHAPE, 'text', 'text', iconTextShape);

        this.canDisable  = true;
        this.iconOffsetY = -1;

        this.addInput (this.createInputForObjects([TEXT_SHAPE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([TEXT_SHAPE_VALUE], this.output_genRequest));


        const interIndex = figUniqueFontNames.findIndex(f => f == 'Inter');

      
        this.addParam(this.paramText          = new   TextParam('text',          '',         false, true, true));
        this.addParam(this.paramX             = new NumberParam('x',             'X',        true,  true, true, 0));
        this.addParam(this.paramY             = new NumberParam('y',             'Y',        true,  true, true, 0));
        this.addParam(this.paramWidth         = new NumberParam('width',         'width',    true,  true, true, 0));
        this.addParam(this.paramHeight        = new NumberParam('height',        'height',   true,  true, true, 0));
        this.addParam(this.paramFont          = new SelectParam('font',          'font',     true,  true, true, figUniqueFontNames, interIndex));
        this.addParam(this.paramSize          = new NumberParam('size',          'size',     true,  true, true,  12, 1));
        this.addParam(this.paramStyle         = new SelectParam('style',         'style',    false, true, true, [''], 0));
        this.addParam(this.paramAlignH        = new SelectParam('alignH',        'align H',  true,  true, true, ['left', 'center', 'right', 'justify'], 0));
        this.addParam(this.paramAlignV        = new SelectParam('alignV',        'align V',  true,  true, true, ['bottom', 'middle', 'top'], 1));
        this.addParam(this.paramLineHeight    = new NumberParam('lineHeight',    'line ↕',   true,  true, true, 100));
        this.addParam(this.paramLetterSpacing = new NumberParam('letterSpacing', 'letter ↔', true,  true, true, 0));


        this.paramText.controls[0].textbox.style.textAlign = 'center';

        this.paramLineHeight   .controls[0].setSuffix('%', true);
        this.paramLetterSpacing.controls[0].setSuffix('%', true);
     
        this.paramFont .saveAsText = true;
        this.paramStyle.saveAsText = true;

        
        this.addBaseParams();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramText         .setValue(value.text,          false, true, false);
        this.paramX            .setValue(value.x,             false, true, false);
        this.paramY            .setValue(value.y,             false, true, false);
        this.paramWidth        .setValue(value.width,         false, true, false);
        this.paramHeight       .setValue(value.height,        false, true, false);
        this.paramFont         .setValue(value.font,          false, true, false);
        this.paramSize         .setValue(value.size,          false, true, false);
        this.paramStyle        .setValue(value.style,         false, true, false);
        this.paramAlignH       .setValue(value.alignH,        false, true, false);
        this.paramAlignV       .setValue(value.alignV,        false, true, false);
        this.paramLineHeight   .setValue(value.lineHeight,    false, true, false);
        this.paramLetterSpacing.setValue(value.letterSpacing, false, true, false);
    }



    updateParams()
    {
        super.updateParams();


        this.paramText         .enableControlText(true, this.paramText         .isUnknown());
        this.paramX            .enableControlText(true, this.paramX            .isUnknown());
        this.paramY            .enableControlText(true, this.paramY            .isUnknown());
        this.paramWidth        .enableControlText(false, this.paramWidth        .isUnknown());
        this.paramHeight       .enableControlText(false, this.paramHeight       .isUnknown());
        this.paramFont         .enableControlText(true, this.paramFont         .isUnknown());
        this.paramSize         .enableControlText(true, this.paramSize         .isUnknown());
        this.paramStyle        .enableControlText(true, this.paramStyle        .isUnknown());
        this.paramAlignH       .enableControlText(true, this.paramAlignH       .isUnknown());
        this.paramAlignV       .enableControlText(true, this.paramAlignV       .isUnknown());
        this.paramLineHeight   .enableControlText(true, this.paramLineHeight   .isUnknown());
        this.paramLetterSpacing.enableControlText(true, this.paramLetterSpacing.isUnknown());


        this.updateStyleParam();

        this.updateParamControls();
    }



    updateStyleParam()
    {
        const fontName   = figUniqueFontNames[this.paramFont.value.toNumber()];
        const fontStyles = getFontStyles(fontName);
        
        this.paramStyle.setOptions(fontStyles);
        this.paramStyle.controls[0].setMax(this.paramStyle.options.length-1);
    }



    loadParams(_node, pasting)
    {
        if (!_node.params)
            return;
        
            
        //console.log('_node.params =', _node.params);
        for (const _param of _node.params)
        {
            let index = this.params.findIndex(p => p.id == _param[1]);

            if (index < 0)
            {
                this.createAndAddParamByType(_param[0], _param[1], true, false, true, true);
                index = this.params.length-1;
            }
        }


        const _fontParam = _node.params.find(p => p[1] == 'font');

        if (_fontParam)
            this.paramFont.loadParam(_fontParam);


        this.updateStyleParam();


        for (const _param of _node.params)
        {
            let index = this.params.findIndex(p => p.id == _param[1]);

            if (_param.id != 'font')
                this.params[index].loadParam(_param);
        }
    }
}


class   OpPoint
extends OpShapeBase
{
    paramX;
    paramY;

    zoom = 1;



    constructor()
    {
        super(POINT, 'point', 'point', iconPoint);

        this.canDisable  = true;
        this.iconOffsetY = -1;


        this.addInput (new Input ([POINT_VALUE], getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([POINT_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));

        this.addParam(this.paramX = new NumberParam('x', 'X', true, true, true, 0));
        this.addParam(this.paramY = new NumberParam('y', 'Y', true, true, true, 0));


        this.setAllParamDividers(0.45);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return new PointValue(
            this.nodeId,
            this.node.paramX.value,
            this.node.paramY.value);
    }



    output_backInit(value)
    {
        // 'this' is the output

        consoleAssert(value.type == POINT_VALUE, 'expected POINT_VALUE in backInit()');
        
        this.node.paramX.setValue(value.x, false, true, false);
        this.node.paramY.setValue(value.y, false, true, false);
    }



//     paramIsConsideredDefault(param)
//     {
//         return  param.isDefault()
//             && !this.inputs[0].connected;
//     }



//     toJavascript(gen)
//     {
//         const conn = this.inputs[0].connected;


//         gen.nTab++;
//         const defs = this.toJsDefs(gen);
//         gen.nTab--;


//         let js = gen.NL + 'function ' + this.name + '(';
        
//         if (   conn 
//             && defs == NULL)
//             js += 'input';

//         js += ')';


//         js += gen.NL + '{';
//         gen.nTab++;


//         js += defs;


//         js += gen.NL + 'return ';
//         js += conn ? 'input' : this.toJsCode(gen);
//         js += ';'


//         gen.nTab--;
//         js += gen.NL + '}';


//         return js;
//     }



//     toJsDefs(gen)
//     {
//         if (  !this.inputs[0].connected
//             || gen.connectedOut(this))
//             return '';

        
//         let js = '';


//         js += gen.NL + 'const input = ';
//         js += this.inputs[0].connectedOutput.toJsCode(gen);
//         js += ';';


//         return js;
//     }



//     toJsCode(gen)
//     {
//         return this.inputs[0].connected
//              ? this.inputs[0].connectedOutput.toJsCode(gen)
//              : this.paramValue.value.toJsCode(gen);
//     }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX.setValue(value.x, false, true, false);
        this.paramY.setValue(value.y, false, true, false);
    }
}


class   OpVectorPath
extends OpShape
{
    paramPoints;
    paramClosed;
    paramDegree;
    paramWinding;
    paramRound;


    
    constructor()
    {
        super(VECTOR_PATH, 'path', 'path', iconVectorPath);

        this.canDisable  = true;
        this.iconOffsetY = -1;


        this.addInput(this.createInputForObjects([VECTOR_PATH_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([VECTOR_PATH_VALUE], this.output_genRequest));


        this.addParam(this.paramPoints  = new ListParam  ('points',  'points',  false, true, true));
        this.addParam(this.paramClosed  = new SelectParam('closed',  'closed',  false, true, true, ['open', 'closed'], 0));
        this.addParam(this.paramDegree  = new SelectParam('degree',  'degree',  false, true, true, ['linear', 'quadratic', 'cubic', 'smooth', 'sine X', 'sine Y'], 3));
        this.addParam(this.paramWinding = new SelectParam('winding', 'wind',    true,  true, true, ['even-odd', 'non-zero']));
        this.addParam(this.paramRound   = new NumberParam('round',   'round',   true,  true, true, 0, 0));

        
        this.paramPoints.input.types.push(SHAPE_LIST_VALUE);
        this.paramPoints.listTypes   = [POINT_VALUE];

        this.paramPoints.itemName    = 'point';
        this.paramPoints.showZero    =  false;

        this.paramDegree.reverseMenu =  true;

        
        this.paramWinding.divider = 0.38;
        this.paramRound  .divider = 0.565;


        this.addBaseParams();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramPoints .setValue(value.points,  false, true, false);
        this.paramClosed .setValue(value.closed,  false, true, false);
        this.paramDegree .setValue(value.degree,  false, true, false);
        this.paramWinding.setValue(value.winding, false, true, false);
        this.paramRound  .setValue(value.round,   false, true, false);
    }



    updateParams()
    {
        this.paramPoints .enableControlText(true);
        this.paramClosed .enableControlText(true);
        this.paramDegree .enableControlText(true);
        this.paramWinding.enableControlText(true);
        this.paramRound  .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpVectorVertex
extends OpShapeBase
{
    paramX;
    paramY;
    paramJoin;
    paramCap;
    paramRound;

    zoom = 1;



    constructor()
    {
        super(VECTOR_VERTEX, 'vertex', 'vertex', iconVectorVertex);

        //this.canDisable  = true;
        this.iconOffsetY = -1;


        this.addInput (new Input ([VECTOR_VERTEX_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addOutput(new Output([VECTOR_VERTEX_VALUE], this.output_genRequest, getNodeOutputValuesForUndo));//, this.output_backInit));

        this.addParam(this.paramX     = new NumberParam('x',     'X',     true, true, true, 0));
        this.addParam(this.paramY     = new NumberParam('y',     'Y',     true, true, true, 0));
        this.addParam(this.paramJoin  = new SelectParam('join',  'join',  true, true, true, ['miter', 'bevel', 'round'], 0));
        this.addParam(this.paramCap   = new SelectParam('cap',   'cap',   true, true, true, ['none', 'square', 'round'], 0));
        this.addParam(this.paramRound = new NumberParam('round', 'round', true, true, true, 0, 0));


        this.paramX    .divider = 0.45;
        this.paramY    .divider = 0.45;
        this.paramRound.divider = 0.55;
    }



    // input_getBackInitValue()
    // {
    //     // 'this' is the input

    //     return new PointValue(
    //         this.nodeId,
    //         this.node.paramX.value,
    //         this.node.paramY.value);
    // }



    // output_backInit(value)
    // {
    //     // 'this' is the output

    //     consoleAssert(value.type == POINT_VALUE, 'expected POINT_VALUE in backInit()');
        
    //     this.node.paramX.setValue(value.x, false, true, false);
    //     this.node.paramY.setValue(value.y, false, true, false);
    // }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX    .setValue(value.x,     false, true, false);
        this.paramY    .setValue(value.y,     false, true, false);
        this.paramJoin .setValue(value.join,  false, true, false);
        this.paramCap  .setValue(value.cap,   false, true, false);
        this.paramRound.setValue(value.round, false, true, false);
    }
}


class   OpVectorEdge
extends OpShapeBase
{
    paramStartTangent;
    paramEndTangent;



    constructor()
    {
        super(VECTOR_EDGE, 'edge', 'edge', iconVectorEdge);

        //this.canDisable  = true;
        this.iconOffsetY = -1;


        this.addInput (new Input ([POINT_VALUE, VECTOR_VERTEX_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addInput (new Input ([POINT_VALUE, VECTOR_VERTEX_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addOutput(new Output([VECTOR_EDGE_VALUE], this.output_genRequest, getNodeOutputValuesForUndo));//, this.output_backInit));

        this.addParam(this.paramStartTangent = new PointParam('startTangent', 'start', true, true, true, PointValue.NaN));
        this.addParam(this.paramEndTangent   = new PointParam('endTangent',   'end',   true, true, true, PointValue.NaN));

        this.paramStartTangent.divider = 0.45;
        this.paramEndTangent  .divider = 0.45;

        this.paramStartTangent.input.types.push(VECTOR_VERTEX_VALUE);
        this.paramEndTangent  .input.types.push(VECTOR_VERTEX_VALUE);
    }



    // input_getBackInitValue()
    // {
    //     // 'this' is the input

    //     return new PointValue(
    //         this.nodeId,
    //         this.node.paramX.value,
    //         this.node.paramY.value);
    // }



    // output_backInit(value)
    // {
    //     // 'this' is the output

    //     consoleAssert(value.type == POINT_VALUE, 'expected POINT_VALUE in backInit()');
        
    //     this.node.paramX.setValue(value.x, false, true, false);
    //     this.node.paramY.setValue(value.y, false, true, false);
    // }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        if (this.node.paramStartTangent.input.connected) request.push(...this.node.paramStartTangent.genRequest(gen));
        else                                             request.push(POINT_VALUE, PointValue.NaN.toString());

        if (this.node.paramEndTangent  .input.connected) request.push(...this.node.paramEndTangent  .genRequest(gen));
        else                                             request.push(POINT_VALUE, PointValue.NaN.toString());


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramStartTangent.setValue(value.startTangent, false, true, false);
        this.paramEndTangent  .setValue(value.endTangent,   false, true, false);

        
        if (   this.paramStartTangent.value.isValid()
            || this.paramEndTangent  .value.isValid())
        {
            this.paramStartTangent.divider = 0.45;
            this.paramEndTangent  .divider = 0.45;
        }
        else
        {
            this.paramStartTangent.divider = 0.53;
            this.paramEndTangent  .divider = 0.53;
        }
    }
}


class   OpVectorRegion
extends OpShape
{
    paramWinding;



    constructor()
    {
        super(VECTOR_REGION, 'region', 'region', iconVectorRegion);

        //this.canDisable = true;
        this.iconOffsetY = 2;


        this.addNewInput();
        this.addOutput(new Output([VECTOR_REGION_VALUE], this.output_genRequest, getNodeOutputValuesForUndo));//, this.output_backInit));

        this.addParam(this.paramWinding = new SelectParam('winding', 'winding', false, true, true, ['even-odd', 'non-zero']));

        this.addBaseParams();


        this.setAllParamDividers(0.45);
    }



    addNewInput()
    {
        const newInput = new Input([VECTOR_EDGE_VALUE, LIST_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    // input_getBackInitValue()
    // {
    //     // 'this' is the input

    //     return new PointValue(
    //         this.nodeId,
    //         this.node.paramX.value,
    //         this.node.paramY.value);
    // }



    // output_backInit(value)
    // {
    //     // 'this' is the output

    //     consoleAssert(value.type == POINT_VALUE, 'expected POINT_VALUE in backInit()');
        
    //     this.node.paramX.setValue(value.x, false, true, false);
    //     this.node.paramY.setValue(value.y, false, true, false);
    // }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id,
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            

        const connectedInputs = this.node.inputs.filter(i => !i.param && i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));

        
        request.push(...this.node.paramWinding.genRequest(gen));
        request.push(...this.node.paramProps  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        //const value   = values[paramIds.findIndex(id => id == 'value'  )];
        const winding = values[paramIds.findIndex(id => id == 'winding')];
        //const props   = values[paramIds.findIndex(id => id == 'props'  )];

        this.paramWinding.setValue(winding, false, true, false);
        //this.paramProps  .setValue(props,   false, true, false);
    }



    updateParams()
    {
        this.paramWinding.enableControlText(true);
        this.paramProps  .enableControlText(false);
    
        super.updateParamControls();
    }
}


class   OpVectorNetwork
extends OpShape
{
    constructor()
    {
        super(VECTOR_NETWORK, 'network', 'network', iconVectorNetwork);

        //this.canDisable  = true;
        this.iconOffsetY = -3;


        this.addNewInput();
        this.addOutput(new Output([VECTOR_NETWORK_VALUE], this.output_genRequest));


        this.addBaseParams();
    }



    addNewInput()
    {
        const newInput = new Input([VECTOR_REGION_VALUE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id,
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            

        const connectedInputs = this.node.inputs.filter(i => i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));


        request.push(...this.node.paramProps.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }
}


class OpShapeGroup
extends OpShapeBase
{
    constructor()
    {
        super(SHAPE_GROUP, 'group', 'group', iconShapeGroup);

        this.variableInputs = true;
        this.canDisable     = true;
        this.iconOffsetY    = 1;


        this.addNewInput();
        this.addOutput(new Output([SHAPE_GROUP_VALUE], this.output_genRequest));


        this.addBaseParams();
    }



    addNewInput()
    {
        const newInput = new Input([SHAPE_LIST_VALUE, ...SHAPE_VALUES]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpFrame
extends OpShape
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramRound;
    paramChildren;



    constructor()
    {
        super(FRAME, 'frame', 'frame', iconFrame);

        this.canDisable     = true;
        this.variableInputs = true;
        this.iconOffsetY    = -1;


        this.addInput(this.createInputForObjects([FRAME_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([FRAME_VALUE], this.output_genRequest));


        this.addParam(this.paramX        = new NumberParam('x',        'X',       true,  true, true, 0));
        this.addParam(this.paramY        = new NumberParam('y',        'Y',       true,  true, true, 0));
        this.addParam(this.paramWidth    = new NumberParam('width',    'width',   true,  true, true, 100, 0.01));
        this.addParam(this.paramHeight   = new NumberParam('height',   'height',  true,  true, true, 100, 0.01));
        this.addParam(this.paramRound    = new NumberParam('round',    'round',   true,  true, true, 0, 0));
        this.addParam(this.paramChildren = new ListParam  ('children', 'objects', false, true, true));


        this.paramWidth .addEventListener('change', () => this.updateRound());
        this.paramHeight.addEventListener('change', () => this.updateRound());


        this.paramChildren.input.types.push(SHAPE_LIST_VALUE, ...SHAPE_VALUES);
        this.paramChildren.listTypes    = SHAPE_VALUES;
        this.paramChildren.itemName     = 'object';
        this.paramChildren.showZero     = false;
        this.paramChildren.getItemCount = () => 0;


        this.addBaseParams();
    }
    
    
    
    updateRound()
    {
        const min = Math.min(
            this.paramWidth .value.value, 
            this.paramHeight.value.value);

        this.paramRound.controls[0].displayMin = 0;
        this.paramRound.controls[0].displayMax = min/2;

        this.paramRound.controls[0].update();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramX     .setValue(value.x,      false, true, false);
        this.paramY     .setValue(value.y,      false, true, false);
        this.paramWidth .setValue(value.width,  false, true, false);
        this.paramHeight.setValue(value.height, false, true, false);
        this.paramRound .setValue(value.round,  false, true, false);


        const nChildren = values[paramIds.findIndex(id => id == 'nChildren')];

        this.paramChildren.getItemCount = () => nChildren.value;
        this.paramChildren.output.types = [finalListTypeFromItems(value.children.items)];
    }
}



class   OpApply
extends OpShape
{
    constructor()
    {
        super(SHAPE_APPLY, 'apply', 'apply', iconApply);

        this.canDisable = true;

        
        this.addInput (this.createInputForObjects(SHAPE_VALUES, getNodeInputValuesForUndo));
        this.addOutput(new Output([SHAPE_VALUE], this.output_genRequest));


        this.addBaseParams();
        this.setAllParamDividers(0.5);
    }
}


class   OpMove
extends OperatorBase
{
    paramX;
    paramY;
    paramMoveType;
    paramAffectSpace;
    paramShowCenter;


    menuBoolAffectSpace;
    menuBoolShowCenter;



    constructor()
    {
        super(MOVE, 'move', 'move', iconMove);

        this.canDisable  = true;
        this.iconOffsetY = -2;

        
        this.addInput (new Input ([...SHAPE_VALUES, SHAPE_LIST_VALUE, LIST_VALUE]));
        this.addOutput(new Output([SHAPE_VALUE], this.output_genRequest));


        this.addParam(this.paramX           = new NumberParam('x',           'X',           true,  true, true));
        this.addParam(this.paramY           = new NumberParam('y',           'Y',           true,  true, true));
        this.addParam(this.paramMoveType    = new SelectParam('moveType',    'type',        false, true, true, ['position', 'vector'], 0));
        this.addParam(this.paramAffectSpace = new NumberParam('affectSpace', 'move space',  true,  true, true, 1, 0, 1));
        this.addParam(this.paramShowCenter  = new NumberParam('showCenter',  'show center', true,  true, true, 0, 0, 1));


        this.paramShowCenter .controls[0].allowEditDecimals = false;
        this.paramAffectSpace.controls[0].allowEditDecimals = false;
        
        this.paramShowCenter .divider = 0.68;
        this.paramAffectSpace.divider = 0.68;
        this.paramMoveType   .divider = 0.4;


        this.menuBoolShowCenter  = createBoolMenu(this.paramShowCenter );
        this.menuBoolAffectSpace = createBoolMenu(this.paramAffectSpace);


        this.inputs[0].addEventListener('connect',    e => this.outputs[0].types = [...this.inputs[0].connectedOutput.types]);
        this.inputs[0].addEventListener('disconnect', e => this.outputs[0].types = [SHAPE_VALUE]);
    }
    
    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramX          .genRequest(gen));
        request.push(...this.node.paramY          .genRequest(gen));
        request.push(...this.node.paramMoveType   .genRequest(gen));
        request.push(...this.node.paramAffectSpace.genRequest(gen));
        request.push(...this.node.paramShowCenter .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateParams()
    {
        super.updateParams();

        updateParamConditionText(this.paramShowCenter,  this.paramShowCenter .isUnknown(), false, 1);
        updateParamConditionText(this.paramAffectSpace, this.paramAffectSpace.isUnknown(), true,  1);


        const vector = this.paramMoveType.value.value == 1;
       
        this.paramX.setName(vector ? 'distance' : 'X');
        this.paramX.divider = vector ? 0.55 : 0.45;

        this.paramY.setName(vector ? 'angle' : 'Y');
        this.paramY.divider = vector ? 0.55 : 0.45;

        this.paramY.controls[0].suffix        = vector ? '°' : '';
        this.paramY.controls[0].suffixOffsetY = vector ? -4  : 0;
        this.paramY.controls[0].wrapValue     = vector;

        this.paramY.controls[0].setMin(vector ?   0 : Number.MIN_SAFE_INTEGER);
        this.paramY.controls[0].setMax(vector ? 360 : Number.MAX_SAFE_INTEGER);


        this.updateParamControls();
    }
}



class   OpAffine
extends OperatorBase
{
    paramShowCenter;
    paramAffectSpace;


    menuBoolShowCenter;
    menuBoolAffectSpace;



    constructor(type, id, name, icon)
    {
        super(type, id, name, icon);

        this.canDisable  = true;
        this.iconOffsetY = -1;

        
        this.addInput (new Input ([...SHAPE_VALUES, SHAPE_LIST_VALUE, LIST_VALUE]));
        this.addOutput(new Output([SHAPE_VALUE], this.output_genRequest));

        this.inputs[0].addEventListener('connect',    () => OpAffine_onConnectInput   (this));
        this.inputs[0].addEventListener('disconnect', () => OpAffine_onDisconnectInput(this));
    }
    
    

    addBaseParams(affect)
    {
        this.addParam(this.paramAffectSpace = new NumberParam('affectSpace', affect + ' space', true, true, true, 1, 0, 1));
        this.addParam(this.paramShowCenter  = new NumberParam('showCenter',       'show center', true, true, true, 0, 0, 1));


        this.paramShowCenter .controls[0].allowEditDecimals = false;
        this.paramAffectSpace.controls[0].allowEditDecimals = false;

        this.paramShowCenter .divider = 0.68;
        this.paramAffectSpace.divider = 0.68;

        this.menuBoolShowCenter  = createBoolMenu(this.paramShowCenter );
        this.menuBoolAffectSpace = createBoolMenu(this.paramAffectSpace);
    }
}



function OpAffine_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];    
}



function OpAffine_onDisconnectInput(node)
{
    node.outputs[0].types = [SHAPE_VALUE];
}



class   OpRotate
extends OpAffine
{
    paramAngle;



    constructor()
    {
        super(ROTATE, 'rotate', 'rotate', iconRotate);

        this.iconOffsetY = -3;


        this.addParam(this.paramAngle = new NumberParam('angle', 'angle', true, true, true, 0));

        this.paramAngle.controls[0].suffix        = '°';
        this.paramAngle.controls[0].suffixOffsetY = -4;
        this.paramAngle.controls[0].dragReverse   = true;
        this.paramAngle.divider                   = 0.55;


        this.addBaseParams('rotate');
    }
    
    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramAngle      .genRequest(gen));
        request.push(...this.node.paramShowCenter .genRequest(gen));
        request.push(...this.node.paramAffectSpace.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateParams()
    {
        super.updateParams();

        updateParamConditionText(this.paramShowCenter,  this.paramShowCenter .isUnknown(), false, 1);
        updateParamConditionText(this.paramAffectSpace, this.paramAffectSpace.isUnknown(), true,  1);

        this.updateParamControls();
    }
}


class   OpScale
extends OpAffine
{
    paramScaleX;
    paramScaleY;

    paramAffectCorners;
    paramAffectStyle;

    menuBoolAffectCorners;
    menuBoolAffectStyle;



    constructor()
    {
        super(SCALE, 'scale', 'scale', iconScale);


        this.addParam(this.paramScaleX = new NumberParam('scaleX', 'width',  true, true, true, 100));
        this.addParam(this.paramScaleY = new NumberParam('scaleY', 'height', true, true, true, 100));


        this.paramScaleX.controls[0].suffix = '%';
        this.paramScaleY.controls[0].suffix = '%';

        this.paramScaleX.divider            = 0.55;
        this.paramScaleY.divider            = 0.55;

        this.paramScaleX.controls[0].setMin(0);
        this.paramScaleY.controls[0].setMin(0);


    
        this.addParam(this.paramAffectCorners = new NumberParam('affectCorners', 'corners', true, true, true, 1, 0, 1));
        this.addParam(this.paramAffectStyle   = new NumberParam('affectStyle',   'style',   true, true, true, 1, 0, 1));

        this.addBaseParams('scale');


        this.paramAffectCorners.divider = 0.55;
        this.paramAffectStyle  .divider = 0.55;
    
        this.menuBoolAffectCorners = createBoolMenu(this.paramAffectCorners);
        this.menuBoolAffectStyle   = createBoolMenu(this.paramAffectStyle  );
    }
    
    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramScaleX       .genRequest(gen));
        request.push(...this.node.paramScaleY       .genRequest(gen));
        request.push(...this.node.paramAffectCorners.genRequest(gen));
        request.push(...this.node.paramAffectStyle  .genRequest(gen));
        request.push(...this.node.paramShowCenter   .genRequest(gen));
        request.push(...this.node.paramAffectSpace  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateParams()
    {
        super.updateParams();

        updateParamConditionText(this.paramAffectCorners, this.paramAffectCorners.isUnknown(), false, 1);
        updateParamConditionText(this.paramAffectStyle,   this.paramAffectStyle  .isUnknown(), false, 1);
        updateParamConditionText(this.paramShowCenter,    this.paramShowCenter   .isUnknown(), false, 1);
        updateParamConditionText(this.paramAffectSpace,   this.paramAffectSpace  .isUnknown(), true,  1);

        this.updateParamControls();
    }
}



class   OpSkew
extends OpAffine
{
    paramSkewX;
    paramSkewY;



    constructor()
    {
        super(SKEW, 'skew', 'skew', iconSkew);


        this.addParam(this.paramSkewX = new NumberParam('skewX', 'skew X', true, true, true));
        this.addParam(this.paramSkewY = new NumberParam('skewY', 'skew Y', true, true, true));
    
    
        this.paramSkewX.divider = 0.55;
        this.paramSkewY.divider = 0.55;


        this.addBaseParams('skew');
    }
    
    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramSkewX      .genRequest(gen));
        request.push(...this.node.paramSkewY      .genRequest(gen));
        request.push(...this.node.paramShowCenter .genRequest(gen));
        request.push(...this.node.paramAffectSpace.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateParams()
    {
        super.updateParams();

        updateParamConditionText(this.paramShowCenter,  this.paramShowCenter .isUnknown(), false, 1);
        updateParamConditionText(this.paramAffectSpace, this.paramAffectSpace.isUnknown(), true,  1);

        this.updateParamControls();
    }
}



class   OpCenter
extends OperatorBase
{
    paramCenterX;
    paramCenterY;
    paramShowCenter;


    menuBoolShowCenter;



    constructor()
    {
        super(CENTER, 'center', 'center', iconCenter);

        this.canDisable  = true;
        // this.iconOffsetY = -2;

        
        this.addInput (new Input ([LIST_VALUE, SHAPE_LIST_VALUE, ...SHAPE_VALUES]));
        this.addOutput(new Output([SHAPE_VALUE], this.output_genRequest));


        this.addParam(this.paramCenterX    = new NumberParam('centerX',    'center X',    true, true, true, 50, 0, 100));
        this.addParam(this.paramCenterY    = new NumberParam('centerY',    'center Y',    true, true, true, 50, 0, 100));
        this.addParam(this.paramShowCenter = new NumberParam('showCenter', 'show center', true, true, true, 0,  0,   1));


        this.paramCenterX.controls[0].suffix = '%';
        this.paramCenterY.controls[0].suffix = '%';

        this.paramCenterX.controls[0].min = Number.MIN_SAFE_INTEGER;
        this.paramCenterX.controls[0].max = Number.MAX_SAFE_INTEGER;

        this.paramCenterY.controls[0].min = Number.MIN_SAFE_INTEGER;
        this.paramCenterY.controls[0].max = Number.MAX_SAFE_INTEGER;


        this.paramShowCenter.controls[0].allowEditDecimals = false;
        this.paramShowCenter.divider = 0.68;

        this.menuBoolShowCenter  = createBoolMenu(this.paramShowCenter );


        this.inputs[0].addEventListener('connect',    () => OpCenter_onConnectInput   (this));
        this.inputs[0].addEventListener('disconnect', () => OpCenter_onDisconnectInput(this));    
    }
    
    

    setPointOffset()
    {
        this.paramCenterX.controls[0].suffix = '';
        this.paramCenterY.controls[0].suffix = '';
    }



    setOtherOffset()
    {
        this.paramCenterX.controls[0].suffix = '%';
        this.paramCenterY.controls[0].suffix = '%';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCenterX   .genRequest(gen));
        request.push(...this.node.paramCenterY   .genRequest(gen));
        request.push(...this.node.paramShowCenter.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateParams()
    {
        super.updateParams();

        updateParamConditionText(this.paramShowCenter,  this.paramShowCenter.isUnknown(), false, 1);

        this.updateParamControls();
    }
}



function setCenterOffset(node, 
                         x, 
                         y, 
                         minX = Number.MIN_SAFE_INTEGER, 
                         minY = Number.MIN_SAFE_INTEGER, 
                         maxX = Number.MAX_SAFE_INTEGER, 
                         maxY = Number.MAX_SAFE_INTEGER) 
{
    node.paramCenterX.controls[0].setMin(minX);
    node.paramCenterX.controls[0].setMax(maxX);

    node.paramCenterY.controls[0].setMin(minY);
    node.paramCenterY.controls[0].setMax(maxY);
}



function OpCenter_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];    


    if (   node.inputs[0].connectedOutput.types.length == 1
        && node.inputs[0].connectedOutput.types[0] == POINT_VALUE)
    {
        node.setPointOffset();
        setCenterOffset(node, 0, 0);
    }
    else
    {
        node.setOtherOffset();
        setCenterOffset(node, 50, 50, 0, 0, 100, 100);
    }
}



function OpCenter_onDisconnectInput(node)
{
    node.outputs[0].types = [SHAPE_VALUE];

    node.setOtherOffset();
    setCenterOffset(node, 50, 50, 0, 0, 100, 100);
}



class   OpResetTransform
extends OperatorBase
{
    paramShowCenter;


    menuBoolShowCenter;



    constructor()
    {
        super(RESET_XFORM, 'reset', 'reset space', iconResetXform);

        this.canDisable  = true;
        this.iconOffsetY = -1;


        this.addInput (new Input([...SHAPE_VALUES, LIST_VALUE]));
        this.addOutput(new Output([SHAPE_VALUE], this.output_genRequest));

        this.addParam(this.paramShowCenter = new NumberParam('showCenter', 'show center', true, true, true, 0, 0, 1));


        this.paramShowCenter.controls[0].allowEditDecimals = false;
        this.paramShowCenter.divider = 0.68;

        this.menuBoolShowCenter = createBoolMenu(this.paramShowCenter);


        this.inputs[0].addEventListener('connect',    e => this.outputs[0].types = [...this.inputs[0].connectedOutput.types]);
        this.inputs[0].addEventListener('disconnect', e => this.outputs[0].types = [SHAPE_VALUE]);
    }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramShowCenter.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        updateParamConditionText(this.paramShowCenter,  this.paramShowCenter.isUnknown(), false, 1);

        this.updateParamControls();
    }



    // getHeaderColors(options = {})
    // {
    //     const colors = super.getHeaderColors(options);

    //     const type = 
    //         this.inputs[0].connected 
    //         ? this.inputs[0].connectedOutput.node.type 
    //         : this.type;

    //     // colors.back = 
    //     //     this.headerColor
    //     //     ? this.headerColor
    //     //     : this.inert
    //     //     ? rgb_a(rgbDocumentBody, 0.95)
    //     //     : rgb_a(rgbFromType(type, this.active), 0.95);


    //     colors.text   = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

    //     colors.input  = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
    //     colors.output = this.active ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
    //     colors.wire   = rgbFromType(type, true);

    //     return colors;
    // }
}



// function OpCopy_onConnectInput(node)
// {
//     node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
// }



// function OpCopy_onDisconnectInput(node)
// {
//     node.outputs[0].types = [ANY_VALUE];
// }


class   OpMeasurePoints
extends OpShapeBase
{
    paramDistance;
    paramAngle;



    constructor()
    {
        super(MEASURE_POINTS, 'measure', 'measure', iconMeasurePoints);

        this.iconOffsetY = 1;


        this.addInput (new Input ([POINT_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addInput (new Input ([POINT_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));

        this.addParam(this.paramDistance = new NumberParam('distance', 'distance', true, false, true, 0));
        this.addParam(this.paramAngle    = new NumberParam('angle',    'angle',    true, false, true, 0, -180, 180));


        this.paramAngle.controls[0].setSuffix('°', true);
        this.paramAngle.controls[0].suffixOffsetY = -4;

        this.paramDistance.controls[0].setDecimals(10, 0);
        this.paramAngle   .controls[0].setDecimals(10, 0);

        this.setAllParamDividers(0.5);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.inputs[0];
        const input1 = this.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const distance = values[paramIds.findIndex(id => id == 'distance')];
        const angle    = values[paramIds.findIndex(id => id == 'angle'   )];

        this.paramDistance.setValue(distance, false, true, false);
        this.paramAngle   .setValue(angle,    false, true, false);
    }
}


class   OpInterpolatePoint
extends OpShapeBase
{
    paramAmount;
    paramTransform;
    paramShowCenter;


    menuTransform;
    menuShowCenter;



    constructor()
    {
        super(INTERPOLATE_POINT, 'interpolate', 'interpolate', iconInterpolatePoint);

        this.iconOffsetY = -2;


        this.addInput (new Input ([POINT_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addInput (new Input ([POINT_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addOutput(new Output([POINT_VALUE], this.output_genRequest));

        this.addParam(this.paramAmount     = new NumberParam('amount',     'amount',      true, true, true, 50, 0, 100));
        this.addParam(this.paramTransform  = new NumberParam('transform',  'transform',   true, true, true, 1, 0, 1));
        this.addParam(this.paramShowCenter = new NumberParam('showCenter', 'show center', true, true, true, 0, 0, 1));

        this.paramAmount.controls[0].min = Number.MIN_SAFE_INTEGER; // allow
        this.paramAmount.controls[0].max = Number.MAX_SAFE_INTEGER; // extrapolation
        
        this.paramAmount.controls[0].setSuffix('%', true);

        this.paramTransform .divider = 0.68;
        this.paramShowCenter.divider = 0.68;

        this.menuTransform  = createBoolMenu(this.paramTransform );
        this.menuShowCenter = createBoolMenu(this.paramShowCenter);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);

            
        request.push(...this.node.paramAmount    .genRequest(gen));
        request.push(...this.node.paramTransform .genRequest(gen));
        request.push(...this.node.paramShowCenter.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramAmount    .enableControlText(true);
        this.paramTransform .enableControlText(true);
        this.paramShowCenter.enableControlText(true);

        updateParamConditionText(this.paramTransform,  this.paramTransform.isUnknown(),  true,  1);
        updateParamConditionText(this.paramShowCenter, this.paramShowCenter.isUnknown(), false, 1);

        this.updateParamControls();
    }
}


class   OpPointOnPath
extends OpShapeBase
{
    paramMeasure;
    paramAmount;
    paramTransform;
    paramShowCenter;


    menuTransform;
    menuShowCenter;



    constructor()
    {
        super(POINT_ON_PATH, 'pointOnPath', 'point on path', iconPointOnPath);

        
        this.addInput (new Input ([VECTOR_PATH_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addInput (new Input ([POINT_VALUE], getNodeInputValuesForUndo));//, this.input_getBackInitValue));
        this.addOutput(new Output([POINT_VALUE], this.output_genRequest));

        this.addParam(this.paramMeasure    = new SelectParam('measure',    'measure',     true, true, true, ['distance', 'total'], 0));
        this.addParam(this.paramAmount     = new NumberParam('amount',     'amount',      true, true, true, 0, 0));
        this.addParam(this.paramTransform  = new NumberParam('transform',  'transform',   true, true, true, 1, 0, 1));
        this.addParam(this.paramShowCenter = new NumberParam('showCenter', 'show center', true, true, true, 0, 0, 1));

        this.paramAmount    .divider = 0.53;
        this.paramTransform .divider = 0.68;
        this.paramShowCenter.divider = 0.68;

        this.menuTransform  = createBoolMenu(this.paramTransform );
        this.menuShowCenter = createBoolMenu(this.paramShowCenter);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);

            
        request.push(...this.node.paramMeasure   .genRequest(gen));
        request.push(...this.node.paramAmount    .genRequest(gen));
        request.push(...this.node.paramTransform .genRequest(gen));
        request.push(...this.node.paramShowCenter.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramMeasure   .enableControlText(true);
        this.paramAmount    .enableControlText(true);
        this.paramTransform .enableControlText(true);
        this.paramShowCenter.enableControlText(true);


        if (this.paramMeasure.value.value > 0)
        {
            this.paramAmount.controls[0].setSuffix('%', true);
            this.paramAmount.controls[0].setMin(  0);
            this.paramAmount.controls[0].setMax(100);
        }
        else
        {
            this.paramAmount.controls[0].setSuffix('', true);
            this.paramAmount.controls[0].setMin(0);
            this.paramAmount.controls[0].setMax(Number.MAX_SAFE_INTEGER);
        }

        
        updateParamConditionText(this.paramTransform,  this.paramTransform.isUnknown(),  true,  1);
        updateParamConditionText(this.paramShowCenter, this.paramShowCenter.isUnknown(), false, 1);


        this.updateParamControls();
    }
}


class OpShapeBooleanBase
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramChildren;


    
    constructor(type, id, name)
    {
        super(type, id, name);

        this.canDisable = true;


        this.addInput (this.createInputForObjects([BOOLEAN_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([BOOLEAN_VALUE], this.output_genRequest));


        this.addParam(this.paramX        = new NumberParam('x',        'x',       true, false, false,   0));
        this.addParam(this.paramY        = new NumberParam('y',        'y',       true, false, false,   0));
        this.addParam(this.paramWidth    = new NumberParam('width',    'width',   true, false, false, 100, 0.01));
        this.addParam(this.paramHeight   = new NumberParam('height',   'height',  true, false, false, 100, 0.01));
        this.addParam(this.paramChildren = new ListParam  ('children', 'objects', true, true,  true));

        
        this.paramChildren.input.types.push(SHAPE_LIST_VALUE, ...SHAPE_VALUES);
        this.paramChildren.listTypes    = SHAPE_VALUES;
        this.paramChildren.itemName     = 'object';
        this.paramChildren.showZero     = false;
        this.paramChildren.getItemCount = () => 0;


        this.addBaseParams();
    }



    updateParams()
    {
        super.updateParams();

        this.paramX     .enableControlText(false);
        this.paramY     .enableControlText(false);
        this.paramWidth .enableControlText(false);
        this.paramHeight.enableControlText(false);

        this.updateParamControls();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const nObjects = values[paramIds.findIndex(id => id == 'nObjects')];

        this.paramChildren.getItemCount = () => nObjects.value;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


class OpShapeBoolean
extends OpShapeBase
{
    paramOperation;
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramChildren;


    
    constructor()
    {
        super(BOOLEAN, 'boolean', 'boolean', iconBoolUnion);

        this.canDisable = true;


        this.addInput (this.createInputForObjects([BOOLEAN_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([BOOLEAN_VALUE], this.output_genRequest));


        this.addParam(this.paramOperation = new SelectParam('operation', '',        false, true,  true,  ['union', 'subtract', 'intersect', 'exclude'], 0));
        this.addParam(this.paramX         = new NumberParam('x',         'x',       true,  false, false,   0));
        this.addParam(this.paramY         = new NumberParam('y',         'y',       true,  false, false,   0));
        this.addParam(this.paramWidth     = new NumberParam('width',     'width',   true,  false, false, 100, 0.01));
        this.addParam(this.paramHeight    = new NumberParam('height',    'height',  true,  false, false, 100, 0.01));
        this.addParam(this.paramChildren  = new ListParam  ('children',  'objects', true,  true,  true));

        
        this.paramChildren.input.types.push(SHAPE_LIST_VALUE, ...SHAPE_VALUES);
        this.paramChildren.listTypes    = SHAPE_VALUES;
        this.paramChildren.itemName     = 'object';
        this.paramChildren.showZero     = false;
        this.paramChildren.getItemCount = () => 0;


        this.addBaseParams();
    }



    updateParams()
    {
        super.updateParams();

        this.paramOperation.enableControlText(true);
        this.paramX        .enableControlText(false);
        this.paramY        .enableControlText(false);
        this.paramWidth    .enableControlText(false);
        this.paramHeight   .enableControlText(false);

        this.updateParamControls();
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const nObjects = values[paramIds.findIndex(id => id == 'nObjects')];

        this.paramChildren.getItemCount = () => nObjects.value;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


class   OpShapeUnion
extends OpShapeBooleanBase
{
    constructor()
    {
        super(BOOL_UNION, 'union', 'union');
    }
}


class   OpShapeSubtract
extends OpShapeBooleanBase
{
    constructor()
    {
        super(BOOL_SUBTRACT, 'subtract', 'subtract');
    }
}


class   OpShapeIntersect
extends OpShapeBooleanBase
{
    constructor()
    {
        super(BOOL_INTERSECT, 'intersect', 'intersect');
    }
}


class   OpShapeExclude
extends OpShapeBooleanBase
{
    constructor()
    {
        super(BOOL_EXCLUDE, 'exclude', 'exclude');
    }
}


class   OpPlace
extends OperatorBase
{
    paramPosition;
    paramTransform;
    paramShowCenter;


    menuTransform;
    menuShowCenter;



    constructor()
    {
        super(PLACE, 'place', 'place', iconPlace, defNodeWidth);

        this.canDisable   = true;
        this.iconOffsetY  = -2;

        
        this.addInput (new Input (SHAPE_VALUES));
        this.addOutput(new Output([SHAPE_VALUE], this.output_genRequest));


        this.addParam(this.paramPosition   = new  PointParam('position',   'position',    false, true, true));
        this.addParam(this.paramTransform  = new NumberParam('transform',  'transform',   true,  true, true, 1, 0, 1));
        this.addParam(this.paramShowCenter = new NumberParam('showCenter', 'show center', true,  true, true, 0, 0, 1));

        this.paramTransform .divider = 0.68;
        this.paramShowCenter.divider = 0.68;

        this.menuTransform  = createBoolMenu(this.paramTransform );
        this.menuShowCenter = createBoolMenu(this.paramShowCenter);


        this.inputs[0].addEventListener('connect',    e => this.outputs[0].types = [...this.inputs[0].connectedOutput.types]);
        this.inputs[0].addEventListener('disconnect', e => this.outputs[0].types = [SHAPE_VALUE]);
    }
    
    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramPosition  .genRequest(gen));
        request.push(...this.node.paramTransform .genRequest(gen));
        request.push(...this.node.paramShowCenter.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    // updateValues(requestId, actionId, updateParamId, paramIds, values)
    // {
    //     const position = values[paramIds.findIndex(id => id == 'position')];

    //     if (position) this.paramPosition.setValue(position, false, true, false);
    // }



    updateParams()
    {
        this.paramPosition  .enableControlText(true);
        this.paramTransform .enableControlText(true);
        this.paramShowCenter.enableControlText(true);

        updateParamConditionText(this.paramTransform,  this.paramTransform.isUnknown(),  true,  1);
        updateParamConditionText(this.paramShowCenter, this.paramShowCenter.isUnknown(), false, 1);

        this.updateParamControls();
    }
}



class OpRender
extends OpShapeBase
{
    btnFinal;
    
    finalize = false;
    

    paramRetain;



    constructor()
    {
        super(RENDER, 'render', 'render', '');

        this.subscription   = true;
        this.variableInputs = true;
        this.canDisable     = true;
        this.iconOffsetY    = -1;


        this.addNewInput();


        this.addParam(this.paramRetain = new NumberParam('retain', 'keep', true, true, true, 1, 0, 1));

        this.paramRetain.divider = 0.53;


        this.addBaseParams();


        this.btnFinal = createDiv('btnRenderFinal');
        this.btnFinal.over = false;
        this.btnFinal.down = false;


        this.btnFinal.addEventListener('pointerenter', e => 
        { 
            this.btnFinal.over = true;  
            this.updateHeader(); 
        });


        this.btnFinal.addEventListener('pointerleave', e => 
        { 
            this.btnFinal.over = false; 
            this.updateHeader(); 
        });


        this.btnFinal.addEventListener('pointerdown',  e => 
        { 
            this.btnFinal.down = true; 
            this.updateHeader(); 


            e.stopPropagation();


            uiMakeNodeActive(this, true);


            this.finalize = true;
            pushUpdate(null, [this]);


            setTimeout(() => 
            {
                this.btnFinal.down = false; 
                this.updateHeader(); 
            },
            200);


            // if (this.enabled)
            // {

            // }
        });


        // this.divIcon.addEventListener('pointerup',  e => 
        // { 
        //     console.log('up');
        //     e.stopPropagation();
        // });


        this.label.insertBefore(this.btnFinal, this.labelText);
    }



    addNewInput()
    {
        const newInput = new Input([LIST_VALUE, SHAPE_LIST_VALUE, ...SHAPE_VALUES]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(e.detail.input); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramRetain.genRequest(gen));

        
        request.push(
            NUMBER_VALUE,
            new NumberValue(this.finalize ? 1 : 0).toString());
            
        this.finalize = false;


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateHeader()
    {
        super.updateHeader();

        this.updateFinalIcon();
    }



    updateParams()
    {
        this.paramRetain.enableControlText(true);

        updateParamConditionText(this.paramRetain, this.paramRetain.isUnknown(), true, 1);
        

        this.updateParamControls();
    }



    updateFinalIcon()
    {
        const colors     = this.getHeaderColors();

        const rgba       = rgb_a(rgbFromType(ANY_VALUE));
        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

        const headerStyle = rgba2style(
            rgb_a(
                //rgbFromType(ANY_VALUE)
                //? (isDark(rgbaStripe) ? [1, 1, 1] : [0, 0, 0])
                //: 
                colors.text, 
                this.btnFinal.down 
                ? 1 
                : this.btnFinal.over
                  ? 1 
                  : 0.5));

        this.btnFinal.style.position           = 'relative';
        this.btnFinal.style.top                = '-1px';
        this.btnFinal.style.display            = 'inline-block';
        this.btnFinal.style.background         =  this.btnFinal.down
                                                  ? 'url(\'data:image/svg+xml;utf8,' + iconRender    .replaceAll('white', headerStyle) + '\')'
                                                  : 'url(\'data:image/svg+xml;utf8,' + iconRenderDown.replaceAll('white', headerStyle) + '\')';

        this.btnFinal.style.backgroundPosition = '50% 50%';
        this.btnFinal.style.backgroundRepeat   = 'no-repeat';
    }
}


class   OpGroupNode
extends OperatorBase
{
    constructor()
    {
        super(GROUP_NODE, 'group', 'group', iconGroup);


        this.saveParams = false;


        graph.currentPage.groupId = this.id;
        graph.updateSavedPages();
    }



    output_genRequest(gen)
    {
        // 'this' is the output        
        if (   this.paramNode
            && this.paramNode.inputs[0].connected)
            return this.paramNode.inputs[0].connectedOutput.genRequest(gen);

            
        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL }); 


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        request.push(this.params.length);

        for (const param of this.params)
            request.push(param.name, ...param.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    genRequest(gen) // for when there are no header outputs
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: null });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        request.push(this.params.length);

        for (const param of this.params)
            request.push(param.name, ...param.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        for (const param of this.params)
        {
            param.enableControlText(param.input ? true : false);
            param.controls[0].showName = param.paramNode.name[0] != '.';
        }

            
        const paramNodes = this.params.map(p => p.paramNode);

        paramNodes.sort((a, b) => 
        {
            // if (a.inputs[0].connected && b.outputs[0].connected) return -1;
            // if (b.inputs[0].connected && a.outputs[0].connected) return  1;
            return a.div.offsetTop - b.div.offsetTop;
        });

        paramNodes.sort((a, b) => 
                a.div.offsetTop - b.div.offsetTop
            && !a.inputs[0].connected 
            &&  b.inputs[0].connected);


        for (let i = 0; i < paramNodes.length; i++)
            paramNodes[i].groupParam.div.style.order = i;


        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        if (!isEmpty(this.headerInputs))
        {
            colors.input  = 
            colors.output =
            colors.wire   = rgbFromType(this.headerInputs[0].types[0], true);
        }
        else if (!isEmpty(this.headerOutputs))
        {
            colors.input  = 
            colors.output =
            colors.wire   = rgbFromType(this.headerOutputs[0].types[0], true);
        }

        return colors;
    }
}


class   OpGroupParam
extends OperatorBase
{
    headerCircle;

    circleBack;
    circle;
    icon;

    paramType = 0; // 0 = param
                   // 1 = header
                   // 2 = variable header


    groupParam  = null;
    groupInput  = null;
    groupOutput = null;


    get groupNode() 
    { 
        return graph.currentPage.groupId != NULL
             ? nodeFromId(graph.currentPage.groupId)
             : null;
    }



    constructor()
    {
        super(GROUP_PARAM, 'param', 'parameter', '');

        this.alwaysLoadParams = true;


        this.addInput (new Input ([ANY_VALUE]));
        this.addOutput(new Output([ANY_VALUE], this.output_genRequest));


        this. inputs[0].addEventListener('connect',    e =>  input_onconnect   (this));
        this. inputs[0].addEventListener('disconnect', e =>  input_ondisconnect(this));

        this.outputs[0].addEventListener('connect',    e => output_onconnect   (this));
        this.outputs[0].addEventListener('disconnect', e => output_ondisconnect(this));


        this.circleBack        = createDiv('headerCircleBack');
        this.circle            = createDiv('headerCircle');

        this.headerCircle      = createDiv('headerCircleWrapper');
        this.headerCircle.over = false;
        this.headerCircle.down = false;


        this.headerCircle.addEventListener('pointerenter', e => 
        { 
            if (   this. inputs[0].connected
                || this.outputs[0].connected)
                return;

            this.headerCircle.over = true;  
            this.updateHeader(); 
        });


        this.headerCircle.addEventListener('pointerleave', e => 
        { 
            this.headerCircle.over = false; 
            this.updateHeader(); 
        });


        this.headerCircle.addEventListener('pointerdown',  e => 
        { 
            e.stopPropagation();
``
            if (e.button == 0)
            {
                hideAllMenus();

                if (   !this. inputs[0].connected
                    && !this.outputs[0].connected)
                {
                    let paramType = this.paramType + 1;
                    if (paramType == 2 /*3*/) paramType = 0;

                    actionManager.do(new ToggleParamHeaderAction(this.id, paramType));
                }
            }
            else
                e.preventDefault();
        });


        this.icon = createDiv('headerIcon');


        this.headerCircle.appendChild(this.circleBack);
        this.headerCircle.appendChild(this.circle);
        this.headerCircle.appendChild(this.icon);
        
        this.label.insertBefore(this.headerCircle, this.labelText);
    }



    getDefaultOffset()
    {
        return -1.5;
    }



    output_genRequest(gen)
    {
        const request = [];


        if (this.node.groupInput)
        {
            if (this.node.groupParam)
            {
                //if (!gen.passedNodes.includes(this.node.groupParam.input.connectedOutput.node))
                    return this.node.groupParam.genRequest(gen);
                // else
                //     return [];
            }

            else if (this.node.groupInput.connected
                 && !gen.passedNodes.includes(this.node.groupInput.connectedOutput.node))
            {
                const _request = this.node.groupInput.connectedOutput.genRequest(gen);
                return _request;
            }
        }


        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [_request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return _request;


        request.push(..._request);


        const groupInput = this.node.groupInput;

        const output = 
            !isEmpty(this.node.outputs)
            ? this.node.outputs[0]
            : null;


        request.push(groupInput && groupInput.connected ? 1 : 0);
        request.push(output && output.connected ? 1 : 0);


        if (groupInput && groupInput.connected)
        {
            request.push(...pushInputOrParam(groupInput, gen));
            request.push(groupInput.connectedOutput.types[0]);
        }

        else if (output && output.connected)
            request.push(output.connectedInputs[0].types[0]);


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }


    
    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        if (   graphView.creatingNodes
            || graphView.pastingNodes
            || graphView.loadingNodes
            || graphView.restoringNodes)
            this.setName(this.name);
    }



    updateHeader()
    {
        super.updateHeader();


        if (true) //this.paramValue.value.isValid()
        {
            const colors = this.getHeaderColors();

            //const rgb        = rgbFromType(ANY_VALUE);//this.paramValue.value.toRgba();
            //const rgbaStripe = rgb_a(getStripeBackColor(rgb));
            
            this.circleBack.style.visibility = 'hidden';//'visible';
            //this.circle    .style.background = rgba2style(rgbaStripe);

            // this.headerCircle.style.boxShadow = 
            //     //     darkMode &&  isDark(rgbaStripe, 0.4)
            //     // || !darkMode && !isDark(rgbaStripe, 0.9)
            //     //? 
            //     '0 0 0 1px ' + rgba2style(rgb_a(colors.text, this.headerCircle.over ? 0.7 : 0.35)) +' inset'
                // : 'none';
        }
        else
        {
            this.circleBack  .style.visibility = 'hidden';
            this.circle      .style.background = 'transparent';
            this.headerCircle.style.boxShadow  = '0 0 0 1px var(--figma-color-bg-tertiary) inset';
        }


        this.updateHeaderIcon();
    }

    

    updateHeaderIcon()
    {
        const colors = this.getHeaderColors();

        const rgba       = rgb_a(rgbFromType(ANY_VALUE));
        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

        const headerStyle = rgba2style(
            rgb_a(
                rgbFromType(ANY_VALUE) //this.paramValue.value.isValid()
                ? (isDark(rgbaStripe) ? [1, 1, 1] : [0, 0, 0])
                : colors.text, 
                this.headerCircle.down 
                ? 1 
                : this.headerCircle.over
                  ? 0.7 
                  : 0.5));

        this.icon.style.display            = 'inline-block';
        this.icon.style.background         = this.paramType == 2
                                             ? 'url(\'data:image/svg+xml;utf8,<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 3C0 1.34314 1.34314 0 3 0H9C10.6569 0 12 1.34314 12 3V9C12 10.6569 10.6569 12 9 12H3C1.34314 12 0 10.6569 0 9V3ZM5 2.5H7V5H9.5V7H7V9.5H5V7H2.5V5H5V2.5Z" fill="'+headerStyle+'"/></svg>\')'
                                             : this.paramType == 1
                                               ? 'url(\'data:image/svg+xml;utf8,<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 3C0 1.34314 1.34314 0 3 0H9C10.6569 0 12 1.34314 12 3V6H0V3Z" fill="'+headerStyle+'"/></svg>\')'
                                               : 'url(\'data:image/svg+xml;utf8,<svg width="12" height="12" viewBox="0 -5 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="11" height="6" stroke="'+headerStyle+'"/></svg>\')';

        this.icon.style.backgroundPosition = '50% calc(50% + 1px)';
        this.icon.style.backgroundRepeat   = 'no-repeat';
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);


        if (this.inputs[0].connected)
        {
            if (   this.inputs[0].supportsTypes([COLOR_VALUE])
                || this.inputs[0].supportsTypes([ FILL_VALUE]))
                colors.input  =
                colors.output =
                colors.wire   = this.inputs[0].connectedOutput.wireColor;
            else
                colors.input  =
                colors.output =
                colors.wire   = rgbFromType(this.inputs[0].types[0], true);
        }
        else if (this.outputs[0].connected)
        {
            if (   this.outputs[0].supportsTypes([COLOR_VALUE])
                || this.outputs[0].supportsTypes([ FILL_VALUE]))
                colors.input  =
                colors.output =
                colors.wire   = this.outputs[0].connectedInputs[0].wireColor;
            else
                colors.input  =
                colors.output =
                colors.wire   = rgbFromType(this.outputs[0].types[0], true);
        }


        return colors;
    }



    setName(newName, options = {})
    {
        if (this.paramType == 0)
        {
            const paramNodes = graph.pageNodes.filter(n => 
                   n.type == GROUP_PARAM
                && n != this);

            newName = getNewNumberId(
                paramNodes, 
                name => paramNodes.find(n => n.name == name), 
                newName, 
                newName, 
                '');


            if (this.groupParam)
            {
                //const param = this.groupNode.paramFromId(this.name);

                // if (param)
                // {
                    this.groupParam._id = newName;
                    this.groupParam.setName(newName);
                // }
            }

        
            if (this.groupNode)
            {
                const id = makeNodePath(this);
                //const groupId = makeNodePath(this.groupNode.id));


                uiSaveNodes([id]);
                uiSaveNodes([groupId]);
                
                uiUpdateSavedConnectionsToNodeId  ([id], true);
                uiUpdateSavedConnectionsFromNodeId([id], true);
                
                uiUpdateSavedConnectionsToNodeId  ([groupId], true);
                uiUpdateSavedConnectionsFromNodeId([groupId], true);


                nodeFromId(groupId).updateParams();
            }
        }


        super.setName(newName, options);
    }



    setPosition(x, y, updateTransform = true)
    {
        super.setPosition(x, y, updateTransform);

        if (this.groupNode)
        {
            this.groupNode.updateNode();
            graphView.updateNodeWireTransforms([this.groupNode]);
        }
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let  json = super.toJsonBase(nTab);

        json += ',\n' + pos + tab + '"paramType": "' +  this.paramType                                 + '"';

        return json;
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);

        if (_node.paramType != undefined) 
            this.paramType = parseInt(_node.paramType);
    }
}



function input_onconnect(node)
{
    // if (   !node.inputs [0].connected
    //     && !node.outputs[0].connected)
        node.inputs[0].types = [...node.inputs[0].connectedOutput.types];
    
        
    node. inputs[0].types =
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
    
    node.outputs[0].div.style.display = 'none';


    if (node.paramType == 0)
    {
        node.groupParam = createParamFromType(
            node.inputs[0].types[0], 
            {
                hasOutput: true,
                id:        node.name,
                name:      node.name,
                showName:  node.name[0] != '.'
            });

        node.groupParam.paramNode = node;

        node.groupOutput = node.groupParam.output;
        node.groupNode.addParam(node.groupParam);
    }
    else if (node.paramType == 1)
    {
        node.groupOutput = new Output([...node.inputs[0].types], node.groupNode.output_genRequest);
        node.groupNode.addOutput(node.groupOutput);
    }
    

    node.groupOutput.paramNode = node;
    node.groupNode.updateNode();
}



function input_ondisconnect(node)
{
    // if (!graph.pageNodes.find(n => 
    //            n.type      == GROUP_PARAM
    //         && n.paramType == 1
    //         && (   !isEmpty(n. inputs) && n. inputs[0].connected 
    //             || !isEmpty(n.outputs) && n.outputs[0].connected)))
    //     node.inputs[0].types = [ANY_VALUE];


    node.outputs[0].types = [ANY_VALUE];
    node. inputs[0].types = [ANY_VALUE];

    node.outputs[0].div.style.display = 'inline-block';


    if (node.groupOutput.connected)
        node.groupOutput.connectedInputs.forEach(i => uiDisconnect(i));


    if (node.paramType == 0)
    {
        node.groupNode.removeParam(node.groupParam);
        node.groupOutput.paramNode = null;
    }
    else if (node.paramType == 1)
    {
        node.groupNode.removeOutput(node.groupOutput);
        node.groupOutput.paramNode = null;
    }


    node.groupNode.updateNode();
}



function output_onconnect(node)
{
    // console.log('XXX =', node.outputs[0].connectedInputs[0]);
    // if (   !node.inputs [0].connected
    //     && !node.outputs[0].connected)
        node.outputs[0].types = [...node.outputs[0].connectedInputs[0].types];

    node.inputs[0].div.style.display = 'none';


    if (node.paramType == 0)
    {
        node.groupParam = createParamFromType(
            node.outputs[0].types[0], 
            {
                hasInput: true,
                id:       node.name,
                name:     node.name,
                showName: node.name[0] != '.'
            });

        node.groupParam.paramNode = node;

        node.groupInput = node.groupParam.input;
        node.groupNode.addParam(node.groupParam);
    }
    else if (node.paramType == 1)
    {
        node.groupInput = new Input([...node.outputs[0].types]);
        node.groupNode.addInput(node.groupInput);
    }
    
    
    node.groupInput.paramNode = node;
    node.groupNode.updateNode();
}



function output_ondisconnect(node)
{
    // if (!graph.pageNodes.find(n => 
    //            n.type      == GROUP_PARAM
    //         && n.paramType == 1
    //         && (   !isEmpty(n. inputs) && n. inputs[0].connected 
    //             || !isEmpty(n.outputs) && n.outputs[0].connected)))
    //     node.outputs[0].types = [ANY_VALUE];

    node.outputs[0].types = [ANY_VALUE];
    node. inputs[0].types = [ANY_VALUE];

    node.inputs[0].div.style.display = 'inline-block';

    
    if (node.groupInput.connected)
        uiDisconnect(node.groupInput);


    if (node.paramType == 0) 
    {
        node.groupParam.paramNode = null;

        node.groupNode.removeParam(node.groupParam);
        node.groupParam = null;
    }
    else if (node.paramType == 1) 
        node.groupNode.removeInput(node.groupInput);


    node.groupInput.types     = [ANY_VALUE];
    node.groupInput.paramNode = null;
    node.groupInput           = null;


    node.groupNode.updateNode();
}


class   OpComment
extends OperatorBase
{
    constructor()
    {
        super(COMMENT, 'comment', 'comment', 0);

        this.scrollName = false;


        this.textbox.addEventListener('input', e =>
        {
            this.updateNode();
            this.updateTransform();
        });


        this.textbox.addEventListener('change', e =>
        {
            if (this.textbox.value.trim() == '')
                actionManager.do(new DeleteNodesAction([this.id]), true);
        });
    }



    setSelected(sel)
    {
        this._selected = sel;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: null });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateNode()
    {
        super.updateNode();


        this.inner.style.boxShadow = 'none';


        utilContext.font = '11px Inter';
        
        const mes = utilContext.measureText(
            hasFocus(this.textbox) 
            ? this.textbox.value 
            : this.name);


        const width = Math.max(1, mes.width + 2);

        this.div    .style.width   = 
        this.textbox.style.width   = width + 'px';

        this.textbox.style.height  =  this.div.offsetHeight;
        this.textbox.style.padding = '0';
        this.textbox.style.margin  = '0';
    }



    updateHeader()
    {
        this.header.style.overflow   = 'visible';
        this.header.style.background = 'transparent';
       
        this.updateHeaderLabel();
    }



    updateHeaderLabel()
    {
        this.labelText.innerHTML = this.name;


        if (this.selected)
        {
            this.label.style.color        = 'var(--figma-color-bg-brand)';
            this.label.style.textShadow   = '0 0 0 var(--figma-color-bg-brand)';

            this.textbox.style.color      =  rgb2style_a(hex2rgb(colFigmaBlue), 0.7);
            this.textbox.style.textShadow = '0 0 0 ' + colFigmaBlue;
        }
        else
        {
            this.label.style.color        = 'var(--figma-color-bg-disabled-secondary)';
            this.label.style.textShadow   = 'none';

            this.textbox.style.color      = 'var(--figma-color-bg-disabled-secondary)';
            this.textbox.style.textShadow = 'none';
        }
    

        this.labelWrapper.style.overflow      = 'visible';

        this.label.style.background           = 'transparent';
        this.label.style.textAlign            = 'left';

        this.label.style.left                 = '0';
        this.label.style.top                  = '0';

        this.label.style.transform            = 'none';

        this.label.style.WebkitBackgroundClip = 'inherit';
        this.label.style.WebkitTextFillColor  = 'inherit';
    }



    updateBorder()
    {
        this.div.style.boxShadow = 'none';
    }
}


const defPanelWidth  = 400;
const defPanelHeight = 400;



class   OpPanel
extends ResizableBase
{
    constructor()
    {
        super(PANEL, 'panel', '', '');

        this.alwaysLoadParams = true;
        this.alwaysSaveParams = true;
        this.allowEmptyName   = true;


        this.inner.addEventListener('pointerdown', e => 
        {
            e.stopPropagation();
            graphView.startedInPanel = true;
            forwardEvent(e, graphView.div);
        });



        this.div         .style.width    = 400;
        this.div         .style.height   = 400;

        this.width                       = 400;
        this.height                      = 400;

        this.header      .style.overflow = 'visible';
        this.labelWrapper.style.overflow = 'visible';
        this.label       .style.overflow = 'visible';
        this.labelText   .style.overflow = 'visible';



        this.header.addEventListener('dblclick', e =>
        {
            e.preventDefault();
            e.stopImmediatePropagation();


            if (e.button != 0)
                return;

            if (getCtrlKey(e))
                this.showLabelTextbox();
    
            else
            {
                const nodes = [];

                for (const node of graph.currentPage.nodes)
                {
                    if (rectInside(
                            node.measureData.divOffset,
                            this.measureData.divOffset))
                        nodes.push(node);
                }

                graphView.selectedNodes = [
                    ...graphView.selectedNodes,
                    ...nodes ];
            }
        });
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: null });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }


    updateHeader()
    {
        super.updateHeader();

        this.div.style.zIndex = 0;


        let background;

        switch (this.highlight)
        {
            case 0: background = darkMode ? '#ffffff08' : '#00000008'; break;
            case 1: background = darkMode ? '#ff33332d' : '#ff000028'; break;
            case 2: background = darkMode ? '#ff880028' : '#f803';     break;
            case 3: background = darkMode ? '#ffff0020' : '#cc04';     break;
            case 4: background = darkMode ? '#1e12'     : '#0d04';     break;
            case 5: background = darkMode ? '#2277ff33' : '#0066ff28'; break;
            case 6: background = darkMode ? '#ff22ff26' : '#ff00ff28'; break;
            case 7: background = darkMode ? '#fff3'     : '#0003';     break;
        }

        this.div.style.background = background;

        this.header.style.height     = defHeaderHeight / Math.min(1, graph.currentPage.zoom * 2.5);
        this.header.style.background = darkMode ? '#ffffff04' : '#00000004';
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();

        const fontHeight = 11 / Math.min(1, graph.currentPage.zoom);

        this.labelText   .style.fontSize   = fontHeight; 
        this.textbox     .style.fontSize   = fontHeight;
        
        this.label       .style.lineHeight = fontHeight + 'px';
        this.label       .style.height     = fontHeight + 'px';

        this.labelText   .style.lineHeight = fontHeight + 'px'; 
        this.labelText   .style.height     = fontHeight + 'px'; 
    }



    updateRect(x, y, w, h, transform)
    {
        this.header.style.height = h;

        super.updateRect(x, y, w, h, transform);
    }



    getHeaderColors()
    {
        const colors = super.getHeaderColors();

        colors.text = darkMode ? hex2rgba('#fff6') : hex2rgba('#0006');

        return colors;
    }



    // toJsonBase(nTab = 0) 
    // {
    //     let   pos = ' '.repeat(nTab);
    //     const tab = HTAB;

    //     let json = Operator.prototype.toJsonBase.call(this, nTab);

    //     json += 
    //           ',\n' + pos + tab + '"width": "'  + this.width  + '"'
    //         + ',\n' + pos + tab + '"height": "' + this.height + '"';

    //     return json;
    // }



    // loadParams(_node, pasting)
    // {
    //     super.loadParams(_node, pasting);

    //     if (   _node.width
    //         && _node.height)
    //     {
    //         this.width  = parseFloat(_node.width );
    //         this.height = parseFloat(_node.height);
    //     }
    // }
}


class GraphPage
{
    id;
    name;


    parent;

    get path() 
    {
        let path = '';
        let page = this;
        
        while (page)
        {
            path = page.id + '/' + path;
            page = page.parent;
        }

        return path;
    }


    button;

    btnIcon;
    btnName;
    btnClose;


    groups = [];



    get nodes() { return graph.nodes.filter(n => n.pageId == this.id); }



    _pan = point(0, 0);
        
    get pan() { return this._pan; }
    set pan(pan)
    {
        if (this._pan == pan) return;

        this._pan = pan;
        
        graphView.updatePanAndZoom(false);//true);
    }
    

    _zoom = 1;
    
    get zoom() { return this._zoom; }
    set zoom(zoom)
    {
        if (this._zoom == zoom) return;

        let pos = point(
            window.innerWidth /2,
            window.innerHeight/2);

        pos.y -= getTopHeight();

        const _pan = subv(this.pan, mulvs(subv(pos, this.pan), zoom / this.zoom - 1));

        this.setPanAndZoom(_pan, zoom);
    }


    setPanAndZoom(pan, zoom)
    {
        if (  (   pan  != this._pan
               || zoom != this._zoom)
            && zoom >= 0.02
            && zoom <= 50)
        {
            graphView.oldZoom = this.zoom;
    
            this._zoom = zoom;
            this._pan  = pan;
    
            
            graphView.panZoomTimer = setTimeout(() => 
            {
                graphView.updatePanAndZoom(this.zoom != graphView.oldZoom);
                graphView.panZoomTimer = null;
            });
        }
    };
    
    
    
    constructor(id, name)
    {
        this.id       = id;
        this.name     = name;
    

        this.button   = createDiv('page');

        this.btnIcon  = createDiv('pageIcon');
        this.btnName  = createDiv('pageName');
        this.btnClose = createDiv('pageClose');


        this.button.appendChild(this.btnIcon);
        this.button.appendChild(this.btnName);
        this.button.appendChild(this.btnClose);



        this.button.addEventListener('pointerenter', e => 
        { 
            graph.overIndex = graph.pages.indexOf(this); 
            graph.updatePages(); 
        });
        
        
        this.button.addEventListener('pointerleave', e => 
        { 
            graph.overIndex = -1;
            graph.updatePages(); 
        });
        
        
        this.button.addEventListener('pointerdown' , e => 
        { 
            if (e.button == 0)
            {
                graph.pageIndex = graph.pages.indexOf(this); 
                graph.updatePages(); 
                
                graph.updateSavedPages();
            }
        });



        this.btnClose.addEventListener('pointerenter', e => 
        { 
            this.btnClose.style.opacity = 1;    
        });
        
        
        this.btnClose.addEventListener('pointerleave', e => 
        { 
            this.btnClose.style.opacity = 0.65; 
        });
        
        
        this.btnClose.addEventListener('pointerdown', e =>
        {
            e.stopPropagation();
        });


        this.btnClose.addEventListener('pointerup', e => 
        { 
            if (e.button == 0)
                actionManager.do(new DeletePageAction(this.id));
        });
    }



    update()
    {
        const index = graph.pages.indexOf(this);

        const isCurrent = 
               index == graph.pageIndex
            || index == graph.overIndex;

        this.btnIcon .innerHTML        = iconPage;
        this.btnName .innerHTML        = settings.showNodeId ? this.id : this.name;
        this.btnClose.innerHTML        = iconPageClose;
        
        this.button  .style.background = isCurrent ? '#2c2c2c' : (document.hasFocus() ? '#202020' : '#383838');
        
        this.btnIcon .style.display    = this.button.offsetWidth >= 75 ? 'inline-block' : 'none';
        this.btnIcon .style.opacity    = isCurrent ? 1 : 0.35;
        
        this.btnName .style.color      = isCurrent ? '#fffffff0' : '#fff6';
    }



    toJson(_tab = '')
    {
        const tab = '\n' + _tab;// + HTAB;


        let json =
              tab + '{'
            + tab + HTAB + '"id": "'   + this.id    + '",'
            + tab + HTAB + '"name": "' + this.name  + '",'
            + tab + HTAB + '"zoom": "' + this.zoom  + '",'
            + tab + HTAB + '"panx": "' + this.pan.x + '",'
            + tab + HTAB + '"pany": "' + this.pan.y + '",'
            + tab + HTAB + '"groups":'
            + tab + HTAB + '[';

        for (let i = 0; i < this.groups.length; i++)
        {
            const group = this.groups[i];

            json += group.toJson(_tab + HTAB + HTAB);

            if (i < this.groups.length-1)
                json += ',';
        }

        json += 
              tab + HTAB + ']'
            + tab + '}';


        return json;
    }


    
    load(json)
    {
        this._pan  = point(0, 0);
        this._zoom = 1;
    
        
        if (json)
        {
            const data = JSON.parse(json);

            this.id   = data.id;
            this.name = data.name;


            this._pan = point( 
                parseFloat(data.panx), 
                parseFloat(data.pany));
    
            if (isNaN(this.pan.x)) this._pan.x = 0;
            if (isNaN(this.pan.y)) this._pan.y = 0;
    
            
            this._zoom = parseFloat(data.zoom);
            if (isNaN(this.zoom)) this._zoom = 1;


            if (isValid(data.groups))
            {
                for (const _group of data.groups)
                {
                    const group = new GraphPage(_group.id, _group.name);
                    group._pan  = point(_group.panx, _group.pany);
                    group._zoom = _group.zoom;

                    this.groups.push(group);
                }
            }
        }
    }
}


class Graph
{
    parentNodeGroup = null;


    pages           = [];

    pageIndex       = -1;
    overIndex       = -1;
    
    
    
    nodes           = [];
    deferNodeIds    = [];
    
    connections     = [];
    
    
    get currentPage() { return this.pages[this.pageIndex]; }
    get pageNodes  () { return this.nodes.filter(n => n.pageId == this.currentPage.id); }



    clear()
    {
        this.deleteNodes(this.nodes.map(n => n.id));
        this.connections = [];
    }



    addNodes(nodes, placeNode = true)
    {
        for (const node of nodes)
            this.addNode(node, placeNode);
    }



    addNode(node, placeNode = true, updateLabel = true)
    {
        node.graph = this;

        node.id = getNewNumberId(
            this.nodes, 
            id => this.nodes.find(n => n.id == id), 
            node.id);

        this.nodes.push(node);
        graphView.div.appendChild(node.div);
        
        if (placeNode)
            graphView.placeNewNode(node);

        node.div.style.zIndex = graph.nodes.length-1;
        graphView.putNodeOnTop(node);


        graphView.updateScrollWithBounds();
    }
    


    deleteNodes(nodeIds)
    {
        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            for (let i = node.inputs.length-1; i >= 0; i--) // backwards for the sake of variable inputs
            {
                const input = node.inputs[i];
                if (!input.connected) continue;

                uiMakeNodeActive(input.connectedOutput.node);
                this.disconnect(input, true);
            }
            
            for (let i = node.outputs.length-1; i >= 0; i--)
            {
                const output = node.outputs[i];
                
                for (const connInput of output.connectedInputs)
                    this.disconnect(connInput, true);
            }
        }


        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            node.selected    = false;
            node.graph = null;

            node.div.style.display = 'none';

            removeFromArray(this.nodes, node);  
            graphView.div.removeChild(node.div);
        }


        graphView.updateScrollWithBounds();
    }



    connect(output, input, inputId = '', outputOrder = -1)
    {
        //console.log('graph.connect()');

        if (input.connectedOutput == output)
            return input.connection;//null;
            

        if (input.connectedOutput)
        {
            const output = input.connectedOutput;
            this.disconnect(input);
            output.updateControl();
        }


        if (    input.node.variableInputs
            && !input.param
            &&  inputId != '')
        {
            input = input.node.headerInputs.at(-1);
            
            const inputIndex = 
                   inputId != ''
                && isDigit(inputId[0])
                ? parseInt(inputId)
                : input.index;

            // move new input back to correct index
            moveInArray(
                input.node.inputs, 
                input.node.headerInputs.length-1, 
                inputIndex);

            input.node.inputControls.insertBefore(
                lastOf(input.node.inputControls.childNodes), 
                input.node.inputControls.childNodes[inputIndex]);
        }


        const conn = new Connection(output, input);

        conn.outputOrder = 
            outputOrder > -1
            ?  outputOrder
            : !isEmpty(output.connectedInputs)
            ? Math.max(...output.connectedInputs.map(i => i.connection.outputOrder)) + 1
            : 0;

        output.connection = conn;

        if (outputOrder > -1) output.connectedInputs.splice(outputOrder, 0, input);
        else                  output.connectedInputs.push(input);
        
        input.connection      = conn;
        input.connectedOutput = output;

        
        graphView.addConnWires(conn);

        this.connections.push(conn);

        
        output.updateControl();


        return conn;
    }



    disconnect(input)
    {
        const output = input.connectedOutput;
        if (!output) return false;


        graphView.removeConnWires(input.connection);

        removeFromArray(this.connections, input.connection);
        removeFromArray(output.connectedInputs, input);


        input.connectedOutput = null;
        input.connection      = null;


        if (input.param)
            input.param.resetControls();


        return true;
    }
}



function nodeFromId(id)
{
    return graph.nodes.find(n => n.id == id);
}



function nodesFromIds(ids)
{
    return ids.map(id => nodeFromId(id));
}



function setNodeId(nodeId, newId)
{
    const node = nodeFromId(nodeId);
    node.id = newId;
}



function getActiveFromNodeId(nodeId, alreadyChecked = [])
{
    return getActiveFromNode(nodeFromId(nodeId), alreadyChecked);
}



function getActiveNodesAfterNodeId(nodeId, alreadyChecked = [])
{
    const rightActive = [];
    
   
    const node = nodeFromId(nodeId);
    
    if (node.active) 
        rightActive.push(node);


    for (const output of node.headerOutputs)
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                rightActive.push(...getActiveNodesAfterNodeId(
                    input.node.id, 
                    [...alreadyChecked, node]));
            }
        }
    }


    return rightActive;
}



function getActiveNodesFromNodeId(nodeId, alreadyChecked = [])
{
    return getActiveNodesFromNode(nodeFromId(nodeId), alreadyChecked);
}



function pageIdFromPath(_path)
{
   const path = _path.split('/');
    return path.length > 1 ? path[0] : '';
}



function stripPathFromId(path)
{
    return path.split('/').at(-1);
}


// function activeNode(node) 
// { 
//     const left  = activeNodeLeft(node);  if (!!left ) return left;
//     const right = activeNodeRight(node); if (!!right) return right;

//     return null;
// }



// function activeNodeLeft(node)
// {
//     if (node.active) return node;

//     for (const input of node.inputs)
//     {
//         if (input.connected)
//         {
//             const left = activeNodeLeft(input.connectedOutput.node);
//             if (left) return left;
//         }
//     }

//     return null;
// }



// function activeNodeRight(node)
// {
//     if (node.active) return node;

//     for (const output of node.outputs)
//     {
//         for (const connInput of output.connectedInputs)
//         {
//             const right = activeNodeRight(connInput.node);
//             if (right) return right;
//         }
//     }

//     return null;
// }



function getAllNodesFromNode(node, ignore = [])
{
    const nodes = [node];

    if (!ignore.includes(node)) 
        ignore.push(node);


    for (const input of node.inputs.filter(i => i.connected))
    {
        const _node = input.connectedOutput.node;
        if (ignore.includes(_node)) continue;

        nodes.push(...getAllNodesFromNode(_node, ignore));
    }


    for (const output of node.outputs)
    {
        for (const _input of output.connectedInputs)
        {
            const _node = _input.node;
            if (ignore.includes(_node)) continue;

            nodes.push(...getAllNodesFromNode(_node, ignore));
        }
    }


    return nodes;
}



function getNodesAcrossNode(node)
{
    return [...getNodesBeforeNode(node),
            ...getNodesAfterNode (node)];
}



function getNodesBeforeNode(node)
{
    let before = [];

    for (const input of node.inputs.filter(i => i.connected))
    {
        if (!before.includes(input.connectedOutput.node)) // avoid including diamond tips twice
            before.push(input.connectedOutput.node);
    
        before.push(...getNodesBeforeNode(input.connectedOutput.node));
    }

    return before;
}



function getNodesAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
    {
        for (const input of output.connectedInputs)
        {
            if (!after.includes(input.node)) // avoid including diamond tips twice
                after.push(input.node);

            after.push(...getNodesAfterNode(input.node));
        }
    }

    return after;
}



function getProgressNodesAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
    {
        for (const input of output.connectedInputs)
        {
            if (input.node.hasProgressBar)
                pushUnique(after, input.node);

            pushUnique(after, getProgressNodesAfterNode(input.node));
        }
    }

    return after;
}



function getTerminalsInNodes(nodes)
{
    return nodes.filter(n => 
           !n.outputs.find(o => o.connected)
        || !n.outputs.find(o => arraysIntersect(
               o.connectedInputs.map(i => i.node),
               nodes)));
}



function getTerminalsAfterNode(node)
{
    let after = [];


    if (node.type == GROUP_NODE)
    {
        for (const input of node.inputs)
            pushUnique(after, getTerminalsAfterNode(input.paramNode));
            
        for (const output of node.outputs) 
            for (const input of output.connectedInputs) 
                pushUnique(after, getTerminalsAfterNode(input.node));//input.node);
    }

    else if (node.type == GROUP_PARAM)
    {
        // if (   !isEmpty(node.inputs)
        //     && !isEmpty(node.outputs))
        // {
        //     pushUnique(after, node);
        // }

        //else 
        if (!isEmpty(node.outputs))
        {
            const afterNode = [];

            for (const output of node.outputs)
            {
                for (const input of output.connectedInputs)
                    pushUnique(afterNode, getTerminalsAfterNode(input.node));
            }

            if (isEmpty(afterNode))
               pushUnique(afterNode, node);

            pushUnique(after, afterNode);
        }

        
        if (!isEmpty(node.inputs))
        {
            const afterGroupNode = [];

            for (const output of node.groupNode.outputs)
            {
                for (const input of output.connectedInputs)
                    pushUnique(afterGroupNode, getTerminalsAfterNode(input.node));
            }

            if (isEmpty(afterGroupNode))
                pushUnique(afterGroupNode, node.groupNode);

            pushUnique(after, afterGroupNode);
        }
    }
    
    else
    {
        for (const output of node.outputs)
        {
            for (const input of output.connectedInputs)
                pushUnique(after, getTerminalsAfterNode(input.node));
        }
    }


    return !isEmpty(after) ? after : [node];
}



function getTerminalsAfterParam(param)
{
    if (!param.output)
        return getTerminalsAfterNode(param.node);


    let after = [];

    for (const input of param.output.connectedInputs)
        pushUnique(after, getTerminalsAfterNode(input.node));


    return !isEmpty(after) ? after : [];
}



function updateTerminalsAfterNodes(nodes, updateNodes)
{
    for (const node of nodes)
        pushUnique(updateNodes, getTerminalsAfterNode(node));
}



function getActiveInBranchFromNode(node, alreadyChecked = [])
{
    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    const nodeInputs = [...node.inputs.filter(i => i.connected)];

    if (    nodeInputs.length == 1
        && !nodeInputs[0].connectedOutput.param
        && !alreadyChecked.includes(nodeInputs[0].connectedOutput.node))
    {
        const leftActive = getActiveInBranchFromNode(
            nodeInputs[0].connectedOutput.node, 
            [...alreadyChecked, node]);

        if (leftActive) return leftActive;
    }


    const nodeOutputs = node.outputs//headerOutputs
        .filter(o => o.connectedInputs.length == 1);

    if (    nodeOutputs.length == 1
        && !nodeOutputs[0].connectedInputs[0].param
        && !alreadyChecked.includes(nodeOutputs[0].connectedInputs[0].node))
    {
        const rightActive = getActiveInBranchFromNode(
            nodeOutputs[0].connectedInputs[0].node, 
            [...alreadyChecked, node]);

        if (rightActive) return rightActive;
    }


    return null;
}



function getActiveFromNode(node, alreadyChecked = [])
{
    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    const leftActive = getActiveBeforeNode(node, [...alreadyChecked]);
    if (leftActive) return leftActive;


    for (const output of node.outputs)//headerOutputs)
    {
        for (const input of output.connectedInputs)//.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                const rightActive = getActiveFromNode(
                    input.node, 
                    [...alreadyChecked, node]);

                if (rightActive) return rightActive;
            }
        }
    }


    return null;
}



function getActiveBeforeNode(node, alreadyChecked = [])
{
    //  this is different from LeftOnly in that it will check the left node, 
    //  but then it will also check the right nodes of that left node

    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    for (const input of node.inputs)//headerInputs)
    {
        if (    input.connected
            //&& !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
        {
            const leftActive = getActiveFromNode(
                input.connectedOutput.node, 
                [...alreadyChecked, node]);

            if (leftActive) return leftActive;
        }
    }


    return null;
}



function getActiveOnlyBeforeNode(node, alreadyChecked = [])
{
    // this is different from Left in that it will only check left nodes

    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    for (const input of node.inputs)//headerInputs)
    {
        if (    input.connected
            //&& !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
        {
            const leftActive = getActiveOnlyBeforeNode(
                input.connectedOutput.node, 
                [...alreadyChecked, node]);

            if (leftActive) return leftActive;
        }
    }


    return null;
}



function getActiveAfterNode(node, includeParams = false, alreadyChecked = [])
{
    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    const outputs = 
        includeParams 
        ? node.outputs 
        : node.headerOutputs;

    for (const output of outputs)
    {
        const connectedInputs = 
            includeParams 
            ? output.connectedInputs
            : output.connectedHeaderInputs;

        for (const input of connectedInputs)//.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                const rightActive = getActiveAfterNode(
                    input.node, 
                    includeParams,
                    [...alreadyChecked, node]);

                if (rightActive) return rightActive;
            }
        }
    }


    return null;
}



function getActiveNodesFromNode(node, alreadyChecked = [])
{
    const activeNodes = [];


    if (node.active)
        activeNodes.push(node);


    for (const input of node.inputs)//headerInputs)
    {
        if (    input.connected
            //&& !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
            pushUnique(activeNodes, getActiveNodesFromNode(input.connectedOutput.node, [...alreadyChecked, node]));
    }


    for (const output of node.outputs)//headerOutputs)
    {
        for (const input of output.connectedInputs)//.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
                pushUnique(activeNodes, getActiveNodesFromNode(input.node, [...alreadyChecked, node]));
        }
    }


    return activeNodes;
}


Graph.prototype.createPage = function(name, add = true)
{
    const page = new GraphPage(
        name.substring(0, 1).toLowerCase() + name.substring(1),
        name);

    if (add)
        this.addPage(page);

    return page;
};



Graph.prototype.addPage = function(page)
{
    page.id = getNewNumberId(
        graph.pages, 
        id => graph.pages.find(p => p.id == id), 
        page.id);

    page.name = getNewNumberId(
        graph.pages, 
        name => graph.pages.find(p => p.name == name), 
        page.name, 
        page.name, 
        ' ');

    this.pages.push(page);

    pagesBar.insertBefore(page.button, btnAddPage);

    this.pageIndex = this.pages.length-1;

    // console.log('add this.pageIndex =', this.pageIndex);        
};



Graph.prototype.removePage = function(page)
{
    removeFromArray(this.pages, page);

    pagesBar.removeChild(page.button);

    if (this.pageIndex >= this.pages.length)
        this.pageIndex--;

    // console.log('remove this.pageIndex =', this.pageIndex);        
    // console.log('this.currentPage.id =', this.currentPage.id);
};



Graph.prototype.updatePages = function()
{
    // console.log('1 update this.pageIndex =', this.pageIndex);        

    pagesBar.style.background = document.hasFocus() ? '#202020' : '#383838';
    pagesBar.style.display    = settings.showPages ? 'inline-block' : 'none';
    
    this.pages.forEach(p => p.update());

    if (this.pages.length > 0)
        this.pages[0].button.style.display = 'none';    

    
    updateAddButton(false);

    
    for (const node of graph.nodes)
    {
        const current = node.pageId == graph.currentPage.id;

        node.div.style.display = current ? 'block' : 'none';

        node.inputs .filter (i => i.connected)     .forEach(i => i.connection.wire.svg.style.display = current ? 'block' : 'none');
        node.outputs.forEach(o => o.connectedInputs.forEach(i => i.connection.wire.svg.style.display = current ? 'block' : 'none'));
    }


    graphView.updateNodeTransforms(graph.nodes.filter(n => n.pageId == graph.currentPage.id));
    graphView.updateNodes();


    pageName.innerHTML = 
        this.currentPage 
        ? (settings.showNodeId 
           ? this.currentPage.id
           : this.currentPage.name)
        : '';


    btnAddPage.style.top = graph.pages.length == 1 ? '0px' : '-2px';


    this.updatePageName();

    // console.log('2 update this.pageIndex =', this.pageIndex);        
    updateZoomIcon();
};



Graph.prototype.updatePageName = function()
{
    const display =
           this.pages.length > 1
        && window.innerWidth > 590 
        ? 'inline-block' 
        : 'none';

    pageName.style.display = display;

    if (btnPage)
        btnPage.div.style.display = display;
};



Graph.prototype.updateSavedPages = function()
{
    // console.log('graph.currentPage.id =', graph.currentPage.id);
    uiSavePages(
        this.pages.map(p => p.id), 
        this.pages.map(p => p.toJson()),
        graph.currentPage.id);
};



function updateAddButton(over)
{
    btnAddPage.style.background = over ? '#2c2c2c' : (document.hasFocus() ? '#202020' : '#383838');
    btnAddPlus.style.fill       = over ? '#ffffffe0' : 'rgba(255, 255, 255, 0.35)';
}    



btnAddPage.addEventListener('pointerenter', e => updateAddButton(true ));
btnAddPage.addEventListener('pointerleave', e => updateAddButton(false));

btnAddPage.addEventListener('pointerup', e => 
{
    actionManager.do(new CreatePageAction());
});



function pageFromId(pageId)
{
    return graph.pages.find(p => p.id == pageId);
}


class Action
{
    manager;
 
    id;
    type;
    name;

    
    prevAction = null; // these are used to link actions into sequences
    nextAction = null; 
  
    data;
  
    onBefore;
    onAfter;

    onBeforeUndo;
    onAfterUndo;

    
    selfUpdate         = false;
    affectsConnections = true;

    _linkWithNext      = false;

    
    oldConnectionData  = []; // [{outputNodeId, outputId, outputOrder, inputNodeId, inputId}]
    newConnectionData  = []; // [{outputNodeId, outputId, outputOrder, inputNodeId, inputId}]
    
    oldOutputParams    = []; // actual Parameter objects
    newOutputParams    = []; // copies of old params for paste/duplicate



    constructor(type, name)
    {
        this.type  = type;
        this.name  = name;

        consoleAssert(
               this.name != undefined
            && this.name != null
            && this.name != '',
            'cannot create user action');
    }



    do  (updateNodes) {}
    undo(updateNodes) {}
    redo(updateNodes) { this.do(updateNodes); }



    initSaveArrays()
    {
        this.oldConnectionData = [];
        this.newConnectionData = [];

        this.oldOutputParams   = [];
        this.newOutputParams   = [];
    }



    saveOldConnections()
    {
        for (const conn of graph.connections)
        {
            this.oldConnectionData.push(conn.toDataObject());
 
            if (conn.output.param)
            {
                conn.output.param._nodeId = conn.output.param.node.id;
                this.oldOutputParams.push(conn.output.param);
            }
        }
    }



    updateOldConnections()
    {
        this.oldConnectionData = this.oldConnectionData
            .filter(c => 
                  !graph.connections.find(gc => 
                         gc.id == c.id
                      && (   !gc.output.param
                          || !gc.output.param.volatile)));

        const oldOutputParams = this.oldOutputParams.filter(p => 
            this.oldConnectionData.find(c =>
                       p._nodeId   == c.outputNodeId
                    && p.output.id == c.outputId));

        this.oldOutputParams = oldOutputParams;
    }



    deleteNewConnections()
    {
        for (const _conn of this.newConnectionData)
        {
            uiDeleteSavedConnection(
                getConnectionKey(
                    _conn.outputNodeId, _conn.outputId, _conn.outputOrder,
                    _conn.inputNodeId,  _conn.inputId),
                _conn.outputNodeId,
                _conn.outputId,
                _conn.outputOrder,
                _conn.inputNodeId,
                _conn.inputId,
                _conn.list);
  
            uiDisconnect(nodeFromId(_conn.inputNodeId).inputFromId(_conn.inputId));
        }

        this.newConnectionData = [];
    }



    restoreOldConnections()
    {
        for (const _conn of this.oldConnectionData)
        {
            const outputNode = nodeFromId(_conn.outputNodeId);
            let   output     = outputNode.outputFromId(_conn.outputId);

            if (!isValid(output))
            {
                const param = this.oldOutputParams.find(p => 
                       p._nodeId == _conn.outputNodeId
                    && p.id      == _conn.outputId); 

                output = param.output;

                const node = nodeFromId(_conn.outputNodeId);
                
                param ._node = node;
                output._node = node; 
            }

            consoleAssert(isValid(output), 'output should be found at this point');


            output.updateSavedConnectionOrder(_conn.outputOrder, +1);


            const oldConn = uiVariableConnectFromOutput(
                output,
                nodeFromId(_conn.inputNodeId), _conn.inputId,
                _conn.outputOrder);

 
            uiSaveConn(oldConn);
        }


        // at this point a request should be sent 
        // and the update received with some flag to indicate that this is that kind of an update
        // at the end of the update reconnect the connections to the real connections and save them


        this.oldConnectionData = [];
    }



    deactivateNewActiveNodes()
    {
        for (const id of this.newActiveNodeIds)
            uiMakeNodePassive(nodeFromId(id));
    
        uiDeleteObjectsAndStyles(this.newActiveNodeIds, false); 
    }



    getPrevLinkString()
    {
        return this.prevAction ? '← ' : '';
    }

    

    getNextLinkString()
    {
        return this.nextAction ? ' →' : '';
    }
}



function linkActions(prevAction, nextAction)
{
    prevAction.nextAction = nextAction;
    nextAction.prevAction = prevAction;
}


/*
    when deleting parameters, store them in a parameter trash bin
    when looking for nodes and params during undo, check that bin also
    but also when just changing values or connecting etc params could come back,
        maybe the actions themselves should store deleted params along with
        deleted connections
    this will also come into play with copy/paste/duplicating
    when performing an action, clear that bin
*/



class ActionManager
{
    actions       = [];
    redoActions   = [];
    updateActions = [];
    
    nextActionId  = 0;



    undoing       = false;
    redoing       = false;
   
    
    
    do(act, linkWithPrevious = false, linkWithNext = false, putBeforeLast = false)
    {
        // this is a fresh new action so any 
        // old redo queue is no longer relevant
        this.redoActions = [];


        act.id            = this.nextActionId++;
        act.manager       = this;
        act._linkWithNext = linkWithNext;


        this.actions.push(act);

        
        if (this.actions.length > 1)
        {
            const before = this.actions.at(-2);
            const last   = this.actions.at(-1);

            if (   linkWithPrevious
                || before._linkWithNext)
            {
                linkActions(before, last);
                before._linkWithNext = false;
            }
        }


        this.doAction(act, false);
    }



    undo()
    {
        if (isEmpty(this.actions))
            return;

            
        this.undoing = true;


        for (;;)
        {
            let last = removeLast(this.actions);
            this.redoActions.push(last);


            this.undoAction(last);


            if (   isEmpty(this.actions)
                || last.prevAction != this.actions.at(-1))
                break;
        }
    }



    redo()
    {
        if (isEmpty(this.redoActions))
            return;

            
        this.redoing = true;


        for (;;)
        {
            let last = removeLast(this.redoActions);
            this.actions.push(last);


            this.doAction(last, true);


            if (   isEmpty(this.redoActions)
                || last.nextAction != this.redoActions.at(-1))
                break;
        }
    }



    clear()
    {
        this.actions       = [];
        this.redoActions   = [];
        this.updateActions = [];
    }



    doAction(act, redo)
    {
        if (settings.logActions)
        {
            const prevLink = act.getPrevLinkString();
            const nextLink = act.getNextLinkString();

            if (redo) console.log("%cREDO %s", 'background: #ffd;    color: #b80;', prevLink + act.name + nextLink);
            else      console.log("%c%s",      'background: #e8ffe8; color: #282;', prevLink + act.name + nextLink);
        }


        const updateNodes = [];


        if (act.affectsConnections)
        {
            act.initSaveArrays();
            act.saveOldConnections();
        }


        if (!redo) 
            act.do  (updateNodes);

        else
        {
            act.redo(updateNodes);

            if (isEmpty(updateNodes))
                this.redoing = false;
        }


        if (act.affectsConnections)
            act.updateOldConnections();


        if (!act.selfUpdate)
            pushUpdate(act, updateNodes);
    }



    undoAction(act)
    {
        if (settings.logActions)
        {
            const prevLink = act.getPrevLinkString();
            const nextLink = act.getNextLinkString();

            console.log("%cUNDO %s", 'background: #fff4e8; color: #c64;', prevLink + act.name + nextLink);
        }

            
        if (act.affectsConnections)
            act.deleteNewConnections();
            
            
        const updateNodes = [];

        act.undo(updateNodes); 


        if (isEmpty(updateNodes))
            this.undoing = false;


         if (act.affectsConnections)
            act.restoreOldConnections();


        if (!act.selfUpdate)
            pushUpdate(act, updateNodes);
    }
}



const actionManager = new ActionManager();



function actionFromId(actionId)
{
    let action = actionManager.actions.find(a => a.id == actionId);

    if (!isValid(action))
        action = actionManager.redoActions.find(a => a.id == actionId);

    return action;
}


class ConnectAction
extends Action
{
    outputNodeId;
    outputId;
    outputOrder           = -1;
    outputValues          = []; // in id,value pairs, to be restored on undo
    
    inputNodeId;
    inputId;
    inputActiveNodeIds    = [];
    inputValues           = []; // in id,value pairs, to be restored on undo

    newActiveNodeIds      = [];
    
    oldOutputNodeId       = NULL;
    oldOutputId;
    oldOutputOrder        = -1;
    oldOutputActiveNodeId = NULL;
    
    backInit              = false;
    shiftKey              = false;
   

    get outputNode()    { return nodeFromId(this.outputNodeId); }
    get output()        { return this.outputNode.outputFromId(this.outputId); }
    
    get inputNode()     { return nodeFromId(this.inputNodeId); }
    get input()         { return this.inputNode.inputFromId(this.inputId); }
    

    get oldOutputNode() { return nodeFromId(this.oldOutputNodeId); }
    get oldOutput()     { return this.oldOutputNode.outputFromId(this.oldOutputId); }



    constructor(output, input, options = {})
    {
        super(
            CONNECT_ACTION,
             'CONNECT '
            + output.node.id + '.' + output.id
            + ' ' + rightArrowChar(output.supportsTypes(LIST_TYPES)) + ' '
            + input.node.id + '.' + input.id);


        this.outputNodeId    = output.node.id;
        this.outputId        = output.id;
   
        this.inputNodeId     = input.node.id;
        this.inputId         = input.id;


        this.oldOutputNodeId = input.connected ? input.connectedOutput.node.id : NULL;
        this.oldOutputId     = input.connected ? input.connectedOutput.id      : NULL;
        this.oldOutputOrder  = input.connected ? input.connection.outputOrder  : -1;


        if (isValid(options.backInit)) this.backInit = options.backInit;
        if (isValid(options.shiftKey)) this.shiftKey = options.shiftKey;
    }


    
    do(updateNodes)
    {
        this.oldOutputActiveNodeId = NULL;
        this.inputActiveNodeIds    = [];


        // connectAction_saveOutputActiveNodes(this);
        // connectAction_saveInputActiveNodes(this);

        connectAction_saveOutputValues(this);
        connectAction_saveInputValues(this);
        
        if (this.backInit)
            connectAction_backInitOutputValue(this);

        connectAction_removeOldOutputConnection(this);
        
        connectAction_makeNewConnection(this);

        connectAction_updateOldOutput(this, updateNodes);
        //connectAction_updateInputActiveNodes(this, updateNodes);

        connectAction_updateNodes(this, updateNodes);
        connectAction_cleanup(this);
    }



    undo(updateNodes)
    {
        connectAction_restoreInputValues(this);
        connectAction_restoreOutputValues(this);

        //this.deactivateNewActiveNodes();
        //connectAction_activateOldActiveNodes(this, updateNodes); 

        connectAction_restoreCleanup(this);
    }
}



function connectAction_backInitOutputValue(act)
{
    if (    act.output.backInit
        &&  act.input.getBackInitValue)
        act.output.backInit(act.input.getBackInitValue());
}



function connectAction_saveOutputActiveNodes(act)
{
    act.oldOutputActiveNodeId = [];//idFromNode(getActiveFromNodeId(act.outputNodeId));
}



function connectAction_saveInputActiveNodes(act)
{
    act.inputActiveNodeIds = [];//getActiveNodesAfterNodeId(act.inputNodeId).map(n => n.id);
}



function connectAction_saveOutputValues(act)
{
    act.outputValues = act.output.getValuesForUndo ? act.output.getValuesForUndo(act.output) : [];
}



function connectAction_saveInputValues(act)
{
    act.inputValues = act.input.getValuesForUndo ? act.input.getValuesForUndo(act.input) : [];
}



function connectAction_makeNewConnection(act)
{
    const conn = uiConnect(act.output, act.input, act.inputId);
            
    pushUnique(act.newConnectionData, conn.toDataObject());
    act.outputOrder = conn.outputOrder;

    uiSaveConn(conn);
}



function connectAction_removeOldOutputConnection(act)
{
    if (act.oldOutputNode)
        uiDeleteSavedConn(act.input.connection);
}



function connectAction_updateOldOutput(act, updateNodes)
{
    if (!act.oldOutputNode)
        return;

        
    act.oldOutput.updateSavedConnectionOrder(act.oldOutputOrder, -1);

    pushUnique(updateNodes, act.oldOutputNode);

    
    if (!getActiveFromNode(act.oldOutputNode))
    {
        uiMakeNodeActive(act.oldOutputNode, !act.shiftKey);

        act.newActiveNodeIds.push(act.oldOutputNodeId);

        if (act.oldOutputActiveNodeId != NULL)
            pushUnique(updateNodes, nodeFromId(act.oldOutputActiveNodeId));
    }
}



function connectAction_updateInputActiveNodes(act, updateNodes)
{
    const inputActiveNodeIds = [...act.inputActiveNodeIds].sort((x, y) => 
        (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

    for (const id of inputActiveNodeIds)
    {
        act.newActiveNodeIds.push(id);

        const node = nodeFromId(id);

        uiMakeNodeActive(node, !act.shiftKey);
        pushUnique(updateNodes, node);
    }
}



function connectAction_updateNodes(act, updateNodes)
{
    pushUnique(updateNodes, act.outputNode);
    pushUnique(updateNodes, act. inputNode);

    if (!act.outputNode.cached) 
        pushUnique(updateNodes, act.outputNode.getUncachedInputNodes());

    if (    act.oldOutputNode
        && !act.oldOutputNode.cached) 
        pushUnique(updateNodes, act.oldOutputNode.getUncachedInputNodes());
}



function connectAction_cleanup(act)
{
    const nodeIds = 
        act.oldOutputActiveNodeId != ''
        ? [act.oldOutputActiveNodeId]
        : [];

    nodeIds.push(...act.inputActiveNodeIds.filter(id => 
        !act.newActiveNodeIds.includes(id)));

    uiDeleteObjectsAndStyles(nodeIds, false);
}



// function connectAction_removeNewConnection(act)
// {
//     const input = act.inputNode.inputFromId(act.inputId);

//     uiDeleteSavedConn(input.connection);
//     uiDisconnect(input);
// }



// function connectAction_restoreOldConnection(act)
// {
//     if (act.oldOutputNodeId != NULL)
//     {
//         act.oldOutput.updateSavedConnectionOrder(act.oldOutputOrder, +1);

//         const oldConn = uiVariableConnect(
//             act.oldOutputNode, act.oldOutputId, 
//             act.inputNode,     act.inputId,
//             act.oldOutputOrder);

//         uiSaveConn(oldConn);
//     }
// }



function connectAction_restoreInputValues(act)
{
    for (const undoValue of act.inputValues)
    {
        const param = act.inputNode.params.find(p => p.id == undoValue.paramId);
        if (param) param.node.restoreParamUndoValue(undoValue);
    }
}



function connectAction_restoreOutputValues(act)
{
    for (const undoValue of act.outputValues)
    {
        const param = act.outputNode.params.find(p => p.id == undoValue.paramId);
        if (param) param.node.restoreParamUndoValue(undoValue);
    }
}



function connectAction_activateOldActiveNodes(act, updateNodes)
{
    pushUnique(updateNodes, act.outputNode);


    for (const id of act.inputActiveNodeIds)
    {
        const oldInputActiveNode = nodeFromId(id);
        
        uiMakeNodeActive(oldInputActiveNode);
        pushUnique(updateNodes, oldInputActiveNode);
    }

    
    if (    act.oldOutputActiveNodeId != NULL
        && !act.inputActiveNodeIds.includes(act.oldOutputActiveNodeId))
    {
        consoleAssert(act.oldOutputActiveNodeId != NULL, 'there should be an old output active node ID at this point')

        const oldOutputActiveNode = nodeFromId(act.oldOutputActiveNodeId);

        uiMakeNodeActive(oldOutputActiveNode);
        pushUnique(updateNodes, oldOutputActiveNode);
    }
}



function connectAction_restoreCleanup(act)
{
    act.oldOutputActiveNodeId = NULL;
    act.inputActiveNodeIds    = [];
}


class CreateInsertNodeAction
extends Action
{
    nodeType;
    createdNodeId;

    options;


    prevSelectedIds      = []; // currently selected nodes that are deselected as a result of creation

    oldInputActiveNodeId = NULL;


    prevConnections      = []; // [{outputNodeId, outputId, outputOrder, inputNodeId, inputId}]


    creatingButton;
    


    constructor(nodeType, creatingButton, options)
    {
        super(
            CREATE_INSERT_ACTION, 
            'CREATE / INSERT \'' + nodeType + '\'');
        
        this.nodeType       = nodeType;
        this.creatingButton = creatingButton;

        this.options        = options;
    }



    do(updateNodes)
    {
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);

        createInsertNodeAction_savePrevConnections(this);


        graphView.creatingNodes = true;

        const node = createNode(this.nodeType, this.creatingButton, this.createdId, this.options);


        const insert = 
               this.prevSelectedIds.length == 1
            && canAutoConnectNode(node);
   
            
        graph.addNode(node, !insert);
        
        this.createdNodeId = node.id;


        if (insert)
        {
            const selNode   = nodeFromId(this.prevSelectedIds[0]);
            const selOutput = selNode.headerOutputs[0];


            for (let i = selOutput.connectedInputs.length-1; i >= 0; i--)
            {
                const input = selOutput.connectedInputs[i];

                uiDeleteSavedConn(input.connection);
                uiDisconnect(input);
            }


            const inputs = node.headerInputs.filter(i => i.canConnectFrom(selNode.headerOutputs[0]));

            if (!isEmpty(inputs))
            {
                const newConn = createNodeAction_connect(this, selNode.outputs[0], node, inputs[0].id);
                graphView.autoPlaceNewNode(newConn.output, newConn.input);


                for (const _conn of this.prevConnections)
                {
                    const _output    = node.headerOutputs[0];
                    const _inputNode = nodeFromId(_conn.inputNodeId);
                    const _input     = _inputNode.inputFromId(_conn.inputId);

                    if (   _output
                        && _input.canConnectFrom(_output))
                        createNodeAction_connect(this, _output, _inputNode, _conn.inputId, _conn.outputOrder);
                }
            }
        }

            
        graphView.lastSelectedNodes = graphView.selectedNodes;
        graphView.selectedNodes     = [node];


        if (!getActiveAfterNode(node, true))
            uiMakeNodeActive(node);


        pushUnique(updateNodes, node);
    }



    undo(updateNodes)
    {
        uiDeleteNodes([this.createdNodeId]);

        createNodeAction_activateOldInput(this, updateNodes);

        this.prevConnections = [];
            
        graphView.selectByIds(this.prevSelectedIds);
    }
}



function createInsertNodeAction_savePrevConnections(act)
{
    if (act.prevSelectedIds.length == 0)
        return;
        
    act.oldInputActiveNodeId = idFromNode(getActiveFromNodeId(act.prevSelectedIds[0]));

    const selNode = nodeFromId(act.prevSelectedIds[0]);
    const output  = selNode.outputs[0];

    for (const input of output.connectedInputs)
        act.prevConnections.push(input.connection.toDataObject());
}


class CreateNodeAction
extends Action
{
    nodeType;
    createdNodeId;

    options;

    node;

    prevSelectedIds      = []; // currently selected nodes that are deselected as a result of creation
    oldInputActiveNodeId = NULL;

    autoConnect;

    creatingButton;
    


    constructor(nodeType, creatingButton, options, autoConnect)
    {
        super(
            CREATE_ACTION, 
            'CREATE \'' + nodeType + '\'');

        this.nodeType       = nodeType;
        this.creatingButton = creatingButton;

        this.options        = options;

        this.autoConnect    = autoConnect;
    }



    do(updateNodes)
    {
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);


        graphView.creatingNodes = true;

        this.node = createNode(this.nodeType, this.creatingButton, this.createdId, this.options);
        

        const autoConnect = 
                this.autoConnect
            && !isEmpty(this.prevSelectedIds)
            &&  canAutoConnectNode(this.node)
            && this.options.autoConnect != undefined
            && this.options.autoConnect;

            
        graph.addNode(this.node, !autoConnect);

        this.createdNodeId = this.node.id;
        

        if (autoConnect)
        {
            this.oldInputActiveNodeId = idFromNode(getActiveFromNodeId(this.prevSelectedIds[0]));

            const selNode = nodeFromId(this.prevSelectedIds[0]);
            const inputs  = this.node.headerInputs.filter(i => i.canConnectFrom(selNode.headerOutputs[0]));
            
            if (!isEmpty(inputs))
            {
                const conn = createNodeAction_connect(this, selNode.outputs[0], this.node, inputs[0].id);
                graphView.autoPlaceNewNode(conn.output, conn.input);
            }
        }


        graphView.lastSelectedNodes = graphView.selectedNodes;
        graphView.selectedNodes     = [this.node];

        uiMakeNodeActive(this.node);
        pushUnique(updateNodes, this.node);
    }



    undo(updateNodes)
    {
        uiDeleteNodes([this.createdNodeId]);

        createNodeAction_activateOldInput(this, updateNodes);
        
        graphView.selectByIds(this.prevSelectedIds);
    }
}



function createNodeAction_connect(act, output, inputNode, inputId, outputOrder = -1)
{
    const conn = uiVariableConnect(
        output.node, output.id,
        inputNode,   inputId,
        outputOrder);
        
    uiSaveConn(conn);

    pushUnique(act.newConnectionData, conn.toDataObject());

    return conn;
}



function createNodeAction_activateOldInput(act, updateNodes)
{
    if (act.oldInputActiveNodeId == NULL)
        return;

    const oldInputActiveNode = nodeFromId(act.oldInputActiveNodeId);
    
    uiMakeNodeActive(oldInputActiveNode);
    pushUnique(updateNodes, oldInputActiveNode);

    act.oldInputActiveNodeId = NULL;
}


class CreatePageAction
extends Action
{
    page;



    constructor(options)
    {
        super(CREATE_PAGE_ACTION, 'CREATE PAGE');
    }



    do(updateNodes)
    {
        this.page = graph.createPage('Graph');


        if (graph.pages.length == 2)
        {
            uiRemoveSavedNodesAndConns(graph.pages[0].nodes.map(n => n.id));


            this.page.groups = graph.pages[0].groups;
            graph.pages[0].groups = [];


            for (const node of graph.pages[0].nodes) node.id = makeNodePath(node);
            //for (const node of this.page.nodes     ) node.id = makeNodePath(node);

                
            graphView.updateNodes(this.page.nodes);


            uiSaveNodes(this.page.nodes.map(n => n.id));
            uiSaveConnections(getConnsFromNodes(this.page.nodes));


            this.page._zoom = graph.pages[0]._zoom;
            this.page._pan  = graph.pages[0]._pan;
        }


        graph.updatePages();
        graph.updateSavedPages();
    }



    undo(updateNodes)
    {
        graph.removePage(this.page);
        uiRemoveSavedPage(this.page.id);


        if (graph.pages.length == 1)
        {
            uiRemoveSavedNodesAndConns(this.page.nodes.map(n => n.id));


            for (const node of this.page.nodes)
                node.id = makeNodePath(node);

            graphView.updateNodes(graph.pages[0].nodes);
            
            
            uiSaveNodes(graph.pages[0].nodes.map(n => n.id));
            uiSaveConnections(getConnsFromNodes(graph.pages[0].nodes));


            graph.pages[0].groups = this.page.groups;
            this.page.groups = [];
            
            graph.pages[0]._zoom = this.page._zoom;
            graph.pages[0]._pan  = this.page._pan;
        }


        graph.updatePages();
        graph.updateSavedPages();
    }
}



class DeleteNodesAction
extends Action
{
    nodeIds          = [];
    nodes            = [];
    nodePos          = [];
    
    prevSelectedIds  = [];

    oldActiveNodeIds = [];
    newActiveNodeIds = [];
   


    constructor(nodeIds, cut = false)
    {
        super(
            DELETE_ACTION, 
            (cut ? 'CUT ' : 'DELETE ') + nodeIds.length + ' ' + countString(nodeIds.length, 'node'));

        this.nodeIds         = [...nodeIds];
        this.nodes           = nodeIds.map(id => nodeFromId(id));
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);
    }



    do(updateNodes)
    {
        this.oldActiveNodeIds = [];
        this.newActiveNodeIds = [];

        deleteNodesAction_saveNodePositions(this);
        deleteNodesAction_saveOldActiveNodes(this);
        
        deleteNodesAction_getUpdateNodes(this, updateNodes);
        deleteNodesAction_deleteNodes(this);

        //DisconnectAction_activateNewNodes(this);

        uiSaveNodes(this.newActiveNodeIds);
    }



    undo(updateNodes)
    {
        deleteNodesAction_restoreNodes(this, updateNodes);
        
        //this.deactivateNewActiveNodes();
        deleteNodesAction_activateOldActiveNodes(this, updateNodes);

        uiSaveNodes(
            [...this.nodeIds,
             ...this.newActiveNodeIds]);
    }
}



function deleteNodesAction_saveOldActiveNodes(act)
{
    for (const nodeId of act.nodeIds)
    {
        if (nodeFromId(nodeId).active)
            pushUnique(act.oldActiveNodeIds, nodeId);
    }
}



function deleteNodesAction_saveNodePositions(act)
{
    act.nodePos = [];

    for (const nodeId of act.nodeIds)
    {
        const node = nodeFromId(nodeId);

        act.nodePos.push(point(
            node.div.offsetLeft, 
            node.div.offsetTop));
    }
}



function deleteNodesAction_getUpdateNodes(act, updateNodes)
{
    for (const node of act.nodes)
    {
        const nodeInputs = node.inputs.filter(i => i.connected);
        
        for (let i = nodeInputs.length-1; i >= 0; i--)
        {
            const input       = nodeInputs[i];
            const output      = input.connectedOutput;
            const outputOrder = input.connection.outputOrder;
            
            uiDeleteSavedConn(input.connection);
            pushUnique(updateNodes, deleteNodesAction_disconnect(act, input, act.nodeIds));

            output.updateSavedConnectionOrder(outputOrder, -1);
        }


        for (const output of node.outputs)
        {
            const connectedInputs = [...output.connectedInputs];
            removeFromArrayWhere(connectedInputs, i => i.node == node);

            // connected inputs need to be sorted by input index
            connectedInputs.sort((i1, i2) => 
            {
                const node1  = i1.node;
                const node2  = i2.node;
                    
                const index1 = node1.inputs.indexOf(i1);
                const index2 = node2.inputs.indexOf(i2);
                
                if (node1.id != node2.id) return node1.id - node2.id;
                if (index1   != index2)   return index1   - index2;

                return 0;
            });


            for (const input of connectedInputs)
            {
                uiDeleteSavedConn(input.connection);
                pushUnique(updateNodes, deleteNodesAction_disconnect(act, input, act.nodeIds));
                // don't need to update order as the output is deleted
            }
        }
    }
}



function deleteNodesAction_disconnect(act, input, ignoreNodeIds = [])
{
    // console.log('deleteNodesAction_disconnect');

    const output            = input.connectedOutput;

    const updateNodes       = [];        


    // const activeLeft        = getActiveBeforeNode    (input.node, [input.node]);
    // const activeLeftOnly    = getActiveOnlyBeforeNode(input.node, [input.node]);
    // const activeRightHeader = getActiveAfterNode     (output.node, false, [output.node]);
    const terminalsRight    = getTerminalsAfterNode  (input.node);


    uiDisconnect(input);
    
    
    // if (   !activeLeftOnly
    //     && !activeLeft)
    // {
    //     if (!ignoreNodeIds.includes(output.node.id))
    //     {
    //         pushUnique(act.newActiveNodeIds, output.node.id);
    //         pushUnique(updateNodes, output.node);
    //     }
    // }


    // if (!activeRightHeader)
    // {
    //     const _activeLeft = getActiveBeforeNode(input.node, [input.node]);

    //     if (   !ignoreNodeIds.includes(input.node.id)
    //         && !_activeLeft)
    //     {
    //         uiMakeNodeActive(input.node);
    //         pushUnique(act.newActiveNodeIds, input.node.id);
    //         pushUnique(updateNodes, input.node);
    //     }
    // }


    pushUnique(updateNodes, terminalsRight);

    
    return updateNodes;
}



function deleteNodesAction_deleteNodes(act)
{
    uiDeleteNodes(act.nodeIds);
    uiDeleteObjectsAndStyles(act.nodeIds); // clean up now irrelevant objects
}



function deleteNodesAction_restoreNodes(act, updateNodes)
{
    // console.log('act.nodes', act.nodes);

    graphView.restoringNodes = true;

    graph.addNodes(act.nodes);

    graphView.putNodeOnTop(act.nodes.at(-1));
    graphView.selected = act.nodes;


    for (let i = 0; i < act.nodes.length; i++)
    {
        const node = act.nodes[i];
        node.id = act.nodeIds[i];

        node.setPosition(
            act.nodePos[i].x, 
            act.nodePos[i].y);

        node.updateMeasureData();
    }

    pushUnique(updateNodes, act.nodes);
}



function deleteNodesAction_activateOldActiveNodes(act, updateNodes)
{
    let oldActiveNodeIds = [...act.oldActiveNodeIds].sort((x, y) => 
        (nodeFromId(x) === nodeFromId(y)) 
        ? 0 
        : nodeFromId(y).isOrFollows(nodeFromId(x)) 
          ? -1 
          :  1);
    
    
    const oldActiveNodes = oldActiveNodeIds.map(id => nodeFromId(id));
    
    graphView.selectByIds(act.prevSelectedIds);
    uiMakeNodesActive(oldActiveNodes);

    pushUnique(updateNodes, oldActiveNodes);
}


class DeletePageAction
extends Action
{
    pageId;

    oldPage = null;



    constructor(pageId)
    {
        super(DELETE_PAGE_ACTION, 'DELETE PAGE');

        this.pageId = pageId;
    }



    do(updateNodes)
    {
        this.oldPage = pageFromId(this.pageId);


        graph.removePage(this.oldPage);
        uiRemoveSavedPage(this.pageId);


        if (graph.pages.length == 1)
        {
            uiRemoveSavedNodesAndConns(this.oldPage.nodes.map(n => n.id));

            for (const node of this.oldPage.nodes)
                node.id = makeNodePath(node);

            graphView.updateNodes(graph.pages[0].nodes);
            uiSaveNodes(graph.pages[0].nodes.map(n => n.id));

            uiSaveConnections(getConnsFromNodes(graph.pages[0].nodes));

            graph.pages[0]._zoom = this.oldPage._zoom;
            graph.pages[0]._pan  = this.oldPage._pan;
        }


        graph.updatePages();
        graph.updateSavedPages();
    }



    undo(updateNodes)
    {
        graph.addPage(this.oldPage);


        if (graph.pages.length == 2)
        {
            uiRemoveSavedNodesAndConns(graph.pages[0].nodes.map(n => n.id));

            for (const node of graph.pages[0].nodes)
                node.id = makeNodePath(node);

            graphView.updateNodes(this.oldPage.nodes);
            uiSaveNodes(this.oldPage.nodes.map(n => n.id));

            uiSaveConnections(getConnsFromNodes(this.oldPage.nodes));

            this.oldPage._zoom = graph.pages[0]._zoom;
            this.oldPage._pan  = graph.pages[0]._pan;
        }


        graph.updatePages();
        graph.updateSavedPages();
    }
}


class DisconnectAction
extends Action
{
    outputNodeId;
    outputId;
    outputOrder      = -1;
    
    inputNodeId;
    inputId;

    
    get outputNode() { return nodeFromId(this.outputNodeId); }
    get output()     { return this.outputNode.outputFromId(this.outputId); }
    
    get inputNode()  { return nodeFromId(this.inputNodeId); }
    get input()      { return this.inputNode.inputFromId(this.inputId); }
    
    
    oldActiveNodeIds = [];
    newActiveNodeIds = [];



    constructor(input)
    {
        super(
            DISCONNECT_ACTION,
             'DISCONNECT '
            + input.connectedOutput.node.id + '.' + input.connectedOutput.id
            + ' ' + rightArrowChar(input.connectedOutput.supportsTypes(LIST_TYPES)) 
            + ' ' + input.node.id + '.' + input.id);


        this.outputNodeId = input.connectedOutput.node.id;
        this.outputId     = input.connectedOutput.id;
        this.outputOrder  = input.connection.outputOrder;

        this.inputNodeId  = input.node.id;
        this.inputId      = input.id;
    }



    do(updateNodes)
    {
        this.newActiveNodeIds = [];

        //this.saveOldActiveNodes();
        this.removeConnection();        

        //DisconnectAction_activateNewNodes(this);
        this.updateNodes(updateNodes);

        this.cleanup();
    }
    
    
    
    undo(updateNodes)
    {
        this.deactivateNewActiveNodes();

        //this.activateOldActiveNodes(updateNodes);
        pushUnique(updateNodes, this.outputNode);

        this.oldActiveNodeIds = [];
    }



    // saveOldActiveNodes()
    // {
    //     this.oldActiveNodeIds = [...getActiveNodesFromNodeId(this.inputNodeId).map(n => n.id)];

    //     if (!getActiveFromNode(this.outputNode, [this.inputNode]))
    //         this.newActiveNodeIds.push(this.outputNodeId);

    //     if (   !getActiveOnlyBeforeNode(this.inputNode)
    //         && !getActiveAfterNode     (this.inputNode))
    //         this.newActiveNodeIds.push(this.inputNodeId);
    // }



    removeConnection()
    {
        uiDeleteSavedConn(this.input.connection);
        uiDisconnect(this.input);


        this.output.updateSavedConnectionOrder(this.outputOrder, -1);
    }



    updateNodes(updateNodes)
    {
        pushUnique(updateNodes, [this.inputNode, this.outputNode]);

        if (!this.outputNode.cached)
            pushUnique(updateNodes, this.outputNode.getUncachedInputNodes());
    }



    cleanup()
    {
        const nodeIds = [];

        nodeIds.push(this.oldActiveNodeIds.filter(id => 
            !this.newActiveNodeIds.includes(id)));

        uiDeleteObjectsAndStyles(nodeIds, false);
    }



    deactivateNewActiveNodes()
    {
        for (const id of this.newActiveNodeIds)
            uiMakeNodePassive(nodeFromId(id));

        uiDeleteObjectsAndStyles(this.newActiveNodeIds, false);
    }



    // activateOldActiveNodes(updateNodes)
    // {
    //     const oldActiveNodeIds = [...this.oldActiveNodeIds].sort((x, y) => 
    //         (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

    //     pushUnique(updateNodes, oldActiveNodeIds.map(id => nodeFromId(id)));

    //     for (const id of oldActiveNodeIds)
    //         uiMakeNodeActive(nodeFromId(id));
    // }
}



function DisconnectAction_activateNewNodes(act)
{
    for (const id of act.newActiveNodeIds)
        uiMakeNodeActive(nodeFromId(id));
}


class EmptyAction
extends Action
{
    constructor()
    {
        super(EMPTY_ACTION, 'DO NOTHING');

        this.affectsConnections = false;
    }
}



class GroupNodesAction
extends Action
{
    group;
    groupNode = null;

    nodes;



    constructor(nodes)
    {
        super(GROUP_NODES_ACTION, 'GROUP NODES');

        this.nodes = [...nodes];
    }



    do(updateNodes)
    {
        // get node bounds
        let bounds = graphView.getNodeArrayBounds(this.nodes);


        // create group page
        this.group = new GraphPage('group', 'group');
        graph.currentPage.groups.push(this.group);
        
        
        // delete old nodes and connections
        uiRemoveSavedNodesAndConns(this.nodes.map(n => n.id));

        
        // move selected nodes to group page
        this.nodes.forEach(n => n.group = this.group);
        this.nodes.forEach(n => n.id = makeNodePath(n));


        // create group node
        this.groupNode = createNode(GROUP_NODE);

        graph.addNode(this.groupNode);
        

        // in group page create param nodes for all in and out connections
        GroupNodesAction_createInputNodes(this);
        GroupNodesAction_createOutputNodes(this);


        // move group node to center of bounds
        this.groupNode.setPosition(
            bounds.x + bounds.width /2 - defNodeWidth,
            bounds.y + bounds.height/2 - 100); // TODO: change this 100 to the group node's actual height


        // save new nodes and connections
        uiSaveNodes([this.groupNode.id]);
        uiSaveNodes(this.nodes.map(n => n.id));
        uiSaveConnections(getConnsFromNodes(this.nodes));


        this.group.nodes.forEach(n => n.div.style.display = 'none');
        this.groupNode.div.style.display = 'block';

        
        uiMakeNodeActive(this.groupNode);
        pushUnique(updateNodes, this.groupNode);
    }



    undo(updateNodes)
    {

    }
}



function GroupNodesAction_createInputNodes(action)
{
    // get all outside inputs

    const inConns = [];

    for (const node of action.nodes)
        for (const input of node.connectedInputs)
            if (!action.nodes.includes(input.connectedOutput.node))
                pushUnique(inConns, input.connection);


    // insert param node into connection

    for (const conn of inConns)
    {
        const output = conn.output;
        const input  = conn.input;

        
        // unsave connection
        uiDeleteSavedConn(conn);

        // disconnect
        uiDisconnect(input);


        // create param node 
        // set it to the left of the input node
        const paramNode = createNode(GROUP_PARAM);
        paramNode.group = action.group;
        graph.addNode(paramNode);

        paramNode.setPosition(
            input.node.div.offsetX - defNodeWidth - 100,
            input.node.div.offsetY);


        // reconnect through param nodes
        const connOut = uiConnect(output, paramNode.inputs[0]);
        const connIn  = uiConnect(paramNode.outputs[0], input);

        // save new connections
        uiSaveConn(connOut);
        uiSaveConn(connIn);
    }
}



function GroupNodesAction_createOutputNodes(action)
{
    // get all outside outputs

    const outConns = [];

    for (const node of action.nodes)
        for (const output of node.connectedOutputs)
            for (const input of output.connectedInputs)
                if (!action.nodes.includes(input.node))
                    pushUnique(outConns, input.connection);


    // insert param node into connection

    for (const conn of outConns)
    {
        const output = conn.output;
        const input  = conn.input;

        
        // unsave connection
        uiDeleteSavedConn(conn);

        // disconnect
        uiDisconnect(input);


        // create param node 
        // set it to the left of the input node
        const paramNode = createNode(GROUP_PARAM);
        paramNode.group = action.group;
        graph.addNode(paramNode);

        paramNode.setPosition(
            input.node.div.offsetX + defNodeWidth + 100,
            input.node.div.offsetY);


        // reconnect through param nodes
        const connIn  = uiConnect(output, paramNode.inputs[0]);
        const connOut = uiConnect(paramNode.outputs[0], input);

        // save new connections
        uiSaveConn(connOut);
        uiSaveConn(connIn);
    }
}


class HighlightNodesAction
extends Action
{
    nodeIds          = [];

    prevColorIndices = [];
    newColorIndex;



    constructor(nodeIds, colorIndex)
    {
        super(
            HIGHLIGHT_NODES_ACTION,
              'HIGHLIGHT ' + nodeIds.length 
            + ' ' + countString(nodeIds.length, 'node')
            + ' as \'' + colorIndex + '\'');

        this.affectsConnections = false;
        this.selfUpdate         = true;

        this.nodeIds            = [...nodeIds];
        this.newColorIndex      = colorIndex;
    }



    do(updateNodes)
    {
        const nodes = this.nodeIds.map(id => nodeFromId(id));

        this.prevColorIndices = [];

        for (const node of nodes)
        {
            this.prevColorIndices.push(node.highlight);
            node.highlight = this.newColorIndex;
            
            if (node.type == PANEL) node.updateNode()
            else                    node.updateBorder();
        }

        uiSaveNodes(this.nodeIds);
    }



    undo(updateNodes)
    {
        const nodes = this.nodeIds.map(id => nodeFromId(id));

        for (let i = 0; i < nodes.length; i++)
        {
            nodes[i].highlight = this.prevColorIndices[i];

            if (nodes[i].type == PANEL) nodes[i].updateNode()
            else                        nodes[i].updateBorder();
        }

        uiSaveNodes(this.nodeIds);
    }
}


class LinkExistingStyleAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    get  inputNode() { return this.node; } // dummy for ConnectAction_...
    get outputNode() { return this.node; } // dummy for ConnectAction_...

    get  input() { return this.node.paramValue. input; } // dummy for ConnectAction_...
    get output() { return this.node.paramValue.output; } // dummy for ConnectAction_...

    styleId;
    styleName;
    paints;

    prevStyleId;
    prevStyleName;
    prevPaints;

    outputValues = []; // in id,value pairs, to be restored on undo
    inputValues  = []; // in id,value pairs, to be restored on undo


    constructor(nodeId, styleId, styleName, paints)
    {
        super(
            LINK_STYLE_ACTION, 
            'LINK STYLE \'' + nodeId + ' ⟶ ' + styleName + ')');
        
        this.affectsConnections = false;

        this.nodeId    = nodeId;
        this.styleId   = styleId;
        this.styleName = styleName;

        this.paints    = [...paints];
    }



    do(updateNodes)
    {
        this.prevStyleId   = this.node.linkedStyleId;
        this.prevStyleName = this.node.linkedStyleName;
        this.prevPaints    = [this.node.paramValue.value.toRgba()];
        
        connectAction_saveOutputValues(this);
        connectAction_saveInputValues(this);

        uiLinkNodeToExistingColorStyle(
            this.node,
            this.styleId,
            this.styleName,
            [...this.paints]);

        pushUnique(updateNodes, this.node);

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        connectAction_restoreInputValues(this);
        connectAction_restoreOutputValues(this);

        uiLinkNodeToExistingColorStyle(
            this.node,
            this.prevStyleId,
            this.prevStyleName,
            [...this.prevPaints]);

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);

        if (this.node.paramValue.input.connected)
            uiTriggerUndo();
    }    
}


class MakeActiveNodesAction
extends Action
{
    shiftKey;


    newActiveNodeIds = [];
    oldActiveNodeIds = [];



    constructor(activeNodeIds, shiftKey)
    {
        super(
            MAKE_ACTIVE_ACTION, 
            'MAKE ACTIVE ' + nodeIdArrayToString(activeNodeIds));

        this.shiftKey           = shiftKey;
        
        this.newActiveNodeIds   = [...activeNodeIds];
        this.affectsConnections = false;
    }



    do(updateNodes)
    {
        this.oldActiveNodeIds = 
            graph.currentPage.nodes
                .filter(n => n.active)
                .map(n => n.nodeId);
            
        // this.newActiveNodeIds.forEach(id =>
        //     pushUnique(
        //         this.oldActiveNodeIds, 
        //         getActiveNodesFromNodeId(id).map(n => n.id))); 

        //uiDeleteObjectsAndStyles(this.oldActiveNodeIds, false);

        const newActiveNodes = this.newActiveNodeIds.map(id => nodeFromId(id));

        uiMakeNodesActive(newActiveNodes, this.shiftKey);
        pushUnique(updateNodes, newActiveNodes);

        uiSaveNodes(filterUnique([...this.newActiveNodeIds, ...this.oldActiveNodeIds]));
    }



    undo(updateNodes)
    {
        for (const id of this.newActiveNodeIds)
            if (!this.oldActiveNodeIds.includes(id))
                uiMakeNodePassive(nodeFromId(id));

        for (const id of this.oldActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));

        pushUnique(updateNodes, this.oldActiveNodeIds.map(id => nodeFromId(id)));

        uiSaveNodes(filterUnique([...this.newActiveNodeIds, ...this.oldActiveNodeIds]));
    }
}


class MoveNodesAction
extends Action
{
    nodeIds;

    newPositions = [];
    oldPositions = [];



    constructor(nodeIds, newPositions)
    {
        super(
            MOVE_NODES_ACTION,
              'MOVE ' + nodeIds.length 
            + ' ' + countString(nodeIds.length, 'node'));

        this.selfUpdate   = true;
        this.nodeIds      = [...nodeIds];
        this.newPositions = [...newPositions];
    }



    do(updateNodes)
    {
        const movedNodes = this.nodeIds.map(id => nodeFromId(id));

        this.oldPositions = [];


        for (const node of movedNodes)
            this.oldPositions.push(point(node.div.offsetLeft, node.div.offsetTop));


        for (let i = 0; i < movedNodes.length; i++)
            movedNodes[i].setPosition(this.newPositions[i].x, this.newPositions[i].y);

            
        for (const node of movedNodes)
        {
            node.updateMeasureData();
            node.updateNode();
        }


        uiSaveNodes(this.nodeIds);
    }



    undo(updateNodes)
    {
        const movedNodes = this.nodeIds.map(id => nodeFromId(id));


        for (let i = 0; i < movedNodes.length; i++)
            movedNodes[i].setPosition(this.oldPositions[i].x, this.newPositions[i].y);

            
        for (const node of movedNodes)
        {
            node.updateMeasureData();
            node.updateNode();
        }


        uiSaveNodes(this.nodeIds);
    }
}



class PasteNodesAction
extends Action
{
    copiedNodesJson;

    pasteConnected;

    isDuplicate;
    isLoading;

    pastedNodeIds = [];
    pastedNodePos = [];

    x;
    y;

    prevSelectedNodeIds = [];

    oldActiveNodeIds    = [];



    constructor(copiedNodesJson, pasteConnected, isDuplicate = false, isLoading = false, x = Number.NaN, y = Number.NaN)
    {
        let nNodes = 0;

        try
        {
            const data = JSON.parse(copiedNodesJson);
            nNodes = data.nodes.length;
        }
        catch {}


        super(
            PASTE_ACTION,
            'PASTE ' + nNodes + ' ' + countString(nNodes, 'node'));

        this.copiedNodesJson = copiedNodesJson;
        this.pasteConnected  = pasteConnected;

        this.isDuplicate     = isDuplicate;
        this.isLoading       = isLoading;

        this.x               = x;
        this.y               = y;
    }



    do(updateNodes)
    {
        this.prevSelectedNodeIds = graphView.selectedNodes.map(n => n.id);


        const [nodes, _conns] = uiPasteNodes(this.copiedNodesJson, true, this.pasteConnected, this.x, this.y, updateNodes);

        pushUnique(this.newConnectionData, _conns);


        const terminals = getTerminalsInNodes(nodes);

        for (const terminal of terminals)
            if (terminal.active) uiMakeNodeActive(terminal);


        for (const conn of _conns)
        {
            if (   this.pasteConnected
                ||    nodes.find(n => n.id == conn.outputNodeId)
                   && nodes.find(n => n.id == conn.inputNodeId ))
            {
                uiSaveConnection(
                    conn.outputNodeId, conn.outputId, conn.outputOrder,
                    conn.inputNodeId,  conn.inputId,
                    formatConnJson(
                        '', 
                        HTAB,
                        conn.outputNodeId,
                        conn.outputId,
                        conn.outputOrder,
                        conn.inputNodeId,
                        conn.inputId,
                        boolToString(
                            nodeFromId(conn.outputNodeId)
                            .outputFromId(conn.outputId)
                            .supportsTypes(LIST_TYPES))));
            }
        }


        this.pastedNodeIds = nodes.map(n => n.id);
        this.pastedNodePos = nodes.map(n => point(n.div.offsetLeft, n.div.offsetTop));


        this.notify(
            nodes,
               this.pasteConnected 
            && !isEmpty(_conns), 
            this.isDuplicate, 
            this.isLoading)
    }



    undo(updateNodes)
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        pasteOffset.x -= pasteOffsetDelta.x;
        pasteOffset.y -= pasteOffsetDelta.y;

        graphView.selectedNodes = graph.nodes.filter(n => this.prevSelectedNodeIds.includes(n.id));
    }



    notify(nodes, pasteConnected, isDuplicate, isLoading)
    {
        let action = 
            isDuplicate 
            ? 'Duplicated' 
            : isLoading
            ? 'Loaded'
            : 'Pasted';

        if (pasteConnected)
            action += ' & connected';

        uiNotify(
            action + ' ' + nodes.length + ' ' + countString(nodes.length, 'node'), 
            {delay: 2500});
    }
}


class ReconnectAction
extends Action
{
    outputNodeId;
    outputId;
    outputOrder            = -1;
    outputValues           = [];
    
    prevInputNodeId        = NULL;
    prevInputId;
    prevInputOutputOrder   = -1; // output order of previous connection
    prevInputActiveNodeIds = [];
    prevInputValues        = []; // in id,value pairs, to be restored on undo

    inputNodeId;
    inputId;
    inputActiveNodeIds     = [];
    inputValues            = []; // in id,value pairs, to be restored on undo
    
    inputIsNew             = false;

    newActiveNodeIds       = [];
        
    oldOutputNodeId        = NULL;
    oldOutputId;
    oldOutputOrder;
    oldOutputActiveNodeId  = NULL;

    backInit               = false;

    

    
    get outputNode()    { return nodeFromId(this.outputNodeId); }
    get output()        { return this.outputNode.outputs.find(o => o.id == this.outputId); }

    get prevInputNode() { return nodeFromId(this.prevInputNodeId); }
    get prevInput()     { return this.prevInputNode.inputFromId(this.prevInputId); }
    
    get inputNode()     { return nodeFromId(this.inputNodeId); }
    get input()         { return this.inputNode.inputFromId(this.inputId); }


    get oldOutputNode() { return nodeFromId(this.oldOutputNodeId); }
    get oldOutput()     { return this.oldOutputNode.outputFromId(this.oldOutputId); }
    


    constructor(output, prevInput, input, options = {})
    {
        super(
            RECONNECT_ACTION,
             'RECONNECT '
            + output.node.id + '.' + output.id
            + ' (' + leftArrowChar(prevInput.supportsTypes(LIST_TYPES)) + ' '
            + prevInput.node.id + '.' + prevInput.id
            + ') ' + rightArrowChar(output.supportsTypes(LIST_TYPES)) + ' '
            + input.node.id + '.' + input.id);


        this.outputNodeId         = output.node.id;
        this.outputId             = output.id;
        
        this.prevInputNodeId      = prevInput.node.id;
        this.prevInputId          = prevInput.id;
        this.prevInputOutputOrder = this.prevInput.connection.outputOrder;

        this.inputNodeId          = input.node.id;
        this.inputId              = input.id;
        
        this.oldOutputNodeId      = input.connected ? input.connectedOutput.node.id : NULL;
        this.oldOutputId          = input.connected ? input.connectedOutput.id      : NULL;
        this.oldOutputOrder       = input.connected ? input.connection.outputOrder  : -1;

        this.inputIsNew           = input.isNew;
        

        if (   options 
            && isValid(options.backInit))
            this.backInit = options.backInit;
    }



    do(updateNodes)
    {
        this.newActiveNodeIds = [];

        // connectAction_saveOutputActiveNodes(this);
        // connectAction_saveInputActiveNodes(this);

        connectAction_saveOutputValues(this);
        connectAction_saveInputValues(this);

        this.savePrevInputActiveNodes();

        if (this.backInit)
            connectAction_backInitOutputValue(this);

        this.removePrevInputConnection(updateNodes);
        connectAction_removeOldOutputConnection(this);

        connectAction_makeNewConnection(this);

        connectAction_updateOldOutput(this, updateNodes);
        connectAction_updateInputActiveNodes(this, updateNodes);

        connectAction_updateNodes(this, updateNodes);
        connectAction_cleanup(this);
    }



    undo(updateNodes)
    {
        connectAction_restoreInputValues(this);
        this.restorePrevInputValues();

        connectAction_restoreOutputValues(this);
        
        // this.deactivateNewActiveNodes();
        // connectAction_activateOldActiveNodes(this, updateNodes); 

        connectAction_restoreCleanup(this);
    }



    savePrevInputActiveNodes()
    {
        this.prevInputActiveNodeIds = getActiveNodesAfterNodeId(this.prevInputNodeId).map(n => n.id);
    }
    
    
    
    removePrevInputConnection(updateNodes)
    {
        uiDeleteSavedConn(this.prevInput.connection);
        uiDisconnect(this.prevInput);//, this.inputIsNew);

        pushUnique(updateNodes, this.prevInput.node);
    }
    
    
    
    restorePrevInputValues()
    {
        for (const param of this.prevInputValues)
        {
            this.prevInputNode.params[this.prevInputNode.params.findIndex(p => p.id == param[0])]
                .setValue(param[1], true, true, false);
        }
    }
    
    
    
    restorePrevConnection()
    {
        this.output.updateSavedConnectionOrder(this.prevInputOutputOrder, +1);
    
        const prevConn = uiVariableConnect(
            this.outputNode,    this.outputId, 
            this.prevInputNode, this.prevInputId,
            this.prevInputOutputOrder);
    
        uiSaveConn(prevConn);
    }}


class RemoveNodesAction
extends Action
{
    nodeIds            = [];
    nodes              = [];
    nodePos            = [];
    
    prevSelectedIds    = [];
    
    oldActiveNodeIds   = [];
    newActiveNodeIds   = [];
    
    clusterActiveLeft  = [];
    clusterActiveRight = [];
    


    constructor(nodeIds)
    {
        super(
            REMOVE_ACTION,
            'REMOVE ' + nodeIds.length + ' ' + countString(nodeIds.length, 'node'));

        this.nodeIds         = [...nodeIds];
        this.nodes           = nodeIds.map(id => nodeFromId(id));
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);
    }



    do(updateNodes)
    {
        this.oldActiveNodeIds = [];
        this.newActiveNodeIds = [];

        deleteNodesAction_saveNodePositions(this);
        deleteNodesAction_saveOldActiveNodes(this);

        this.prepareNewReconnections();

        deleteNodesAction_getUpdateNodes(this, updateNodes);
        deleteNodesAction_deleteNodes(this);

        removeNodesAction_makeNewConnections(this);

        uiSaveNodes(this.newActiveNodeIds);
    }



    undo(updateNodes)
    {
        deleteNodesAction_restoreNodes(this, updateNodes);
        
        this.deactivateNewActiveNodes();
        deleteNodesAction_activateOldActiveNodes(this, updateNodes);

        uiSaveNodes([...this.nodeIds, ...this.newActiveNodeIds]);
    }



    addOldConnection(conn)
    {
        if (!this.oldConnectionData.find(c => 
                   c.outputNodeId == conn.output.node.id
                && c.outputId     == conn.output.id
                && c.outputOrder  == conn.outputOrder
                && c. inputNodeId == conn. input.node.id
                && c. inputId     == conn. input.id))
            this.oldConnectionData.push(conn.toDataObject());
    }



    prepareNewReconnections()
    {
        const clusters = findConnectedClusters(this.nodeIds.map(n => nodeFromId(n)));

        
        for (const cluster of clusters)
        {
            const first = cluster.at(0);
            const last  = cluster.at(-1);

            if (   first.headerInputs .length == 1
                &&  last.headerOutputs.length == 1
                && first.inputs [0].connected
                &&  last.outputs[0].connected)
            {
                const input  = first.inputs [0];
                const output =  last.outputs[0];

                for (const connectedInput of output.connectedInputs)
                {
                    if (input.connectedOutput.canConnectTo(connectedInput))
                        this.newConnectionData.push(connDataObject(input.connectedOutput, connectedInput));
                }
            }
        }


        this.clusterActiveLeft  = [];
        this.clusterActiveRight = [];

        for (const cluster of clusters)
        {
            this.clusterActiveLeft .push(getActiveBeforeNode(cluster.at( 0),        [cluster.at( 0)]));
            this.clusterActiveRight.push(getActiveAfterNode (cluster.at(-1), false, [cluster.at(-1)]));
        }
    }



    disconnect(input, ignoreNodeIds = [])
    {
        uiDisconnect(input);
        return [input.node];
    }
}



function removeNodesAction_makeNewConnections(act)
{
    for (let i = 0; i < act.newConnectionData.length; i++)
    {
        const _conn = act.newConnectionData[i];
        
        const conn = uiVariableConnect(
             nodeFromId(_conn.outputNodeId), _conn.outputId, 
             nodeFromId(_conn. inputNodeId), _conn. inputId,
            _conn.outputOrder);

        uiSaveConn(conn);


             if (act.clusterActiveLeft [i]) pushUpdate(act, [act.clusterActiveLeft [i]]);
        else if (act.clusterActiveRight[i]) pushUpdate(act, [act.clusterActiveRight[i]]);
        else                                uiMakeNodeActive(nodeFromId(_conn.inputNodeId));
    }
}


class RenameNodeAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    oldName;
    newName;



    constructor(nodeId, newName)
    {
        super(
             RENAME_ACTION,
            'RENAME \'' + nodeId + '\' to \'' + newName + '\'');

        this.affectsConnections = false;

        this.nodeId  = nodeId;
        this.newName = newName;
    }



    do(updateNodes)
    {
        this.oldName = this.node.name;

        this.node.setName(this.newName, {updateNodes: updateNodes});
        this.node.renamed = true;

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        this.node.setName(this.oldName, {updateNodes: updateNodes});
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    redo(updateNodes)
    {
        this.node.setName(this.newName, {updateNodes: updateNodes});
        this.node.updateNode();
        
        uiSaveNodes([this.nodeId]);
    }
}


class ReorderInputConnectionsAction
extends Action
{
    nodeId;

    oldInputId;
    newInputId;
 


    constructor(nodeId, oldInputId, newInputId)
    {
        super(
            REORDER_CONNECTIONS_ACTION,
              'REORDER CONNECTIONS ' + nodeFromId(nodeId).id 
            + '.' + oldInputId
            + ' to .' + newInputId);

        this.nodeId     = nodeId;

        this.oldInputId = oldInputId;
        this.newInputId = newInputId;
    }



    do(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        this.swapConnections();
        
        uiSaveNodes([this.nodeId]);

        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    undo(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        this.swapConnections();

        uiSaveNodes([this.nodeId]);
        
        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    swapConnections()
    {
        const node = nodeFromId(this.nodeId);

        const oldInput = node.inputFromId(this.oldInputId);
        const newInput = node.inputFromId(this.newInputId);

        const oldConn  = oldInput.connection;
        const newConn  = newInput.connection;

        const oldOutputInputIndex = oldConn.output.connectedInputs.indexOf(oldInput);
        const newOutputInputIndex = newConn.output.connectedInputs.indexOf(newInput);


        const tempInput = newConn.input;
        newConn.input = oldConn.input;
        oldConn.input = tempInput;

        const tempOrder = newConn.outputOrder;
        newConn.outputOrder = oldConn.outputOrder;
        oldConn.outputOrder = tempOrder;
        
        
        oldConn.input._connectedOutput = oldConn.output;
        newConn.input._connectedOutput = newConn.output;

        oldConn.input.connection = oldConn;
        newConn.input.connection = newConn;

        oldConn.output.connectedInputs.splice(oldOutputInputIndex, 1, oldConn.input);
        newConn.output.connectedInputs.splice(newOutputInputIndex, 1, newConn.input);
    }



    saveInputConnections()
    {
        uiDeleteSavedConnectionsToNodeId(this.nodeId);
        
        const node = nodeFromId(this.nodeId);

        for (const input of node.inputs.filter(i => i.connected))
            uiSaveConn(input.connection);
    }
}


class ReorderInputsAction
extends Action
{
    nodeId;

    oldIndex;
    newIndex;
 


    constructor(nodeId, oldIndex, newIndex)
    {
        super(
            REORDER_INPUTS_ACTION,
              'REORDER INPUTS ' + nodeFromId(nodeId).id 
            + '.' + oldIndex
            + ' to .' + newIndex);

        this.nodeId   = nodeId;
        this.oldIndex = oldIndex;
        this.newIndex = newIndex;
    }



    do(updateNodes)
    {
        // .. already done

        this.saveInputConnections();
        
        pushUnique(updateNodes, nodeFromId(this.nodeId));
    }



    undo(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        moveInArray(node.inputs, this.newIndex, this.oldIndex);
        uiSaveNodes([this.nodeId]);
        
        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    redo(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        moveInArray(node.inputs, this.oldIndex, this.newIndex);
        uiSaveNodes([this.nodeId]);

        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    saveInputConnections()
    {
        uiDeleteSavedConnectionsToNodeId(this.nodeId);
        
        const node = nodeFromId(this.nodeId);

        for (const input of node.inputs.filter(i => i.connected))
            uiSaveConn(input.connection);
    }
}


class SelectMoveNodesAction
extends Action
{
    newSelectedIds  = [];
    prevSelectedIds = [];

    shiftPressed;

    fromPos;
    toPos;

    from;
    to;



    constructor(prevSelectedIds, newSelectedIds, fromPos, toPos, shiftPressed)
    {
        super(
            SELECT_MOVE_ACTION,
              'SELECT MOVE ' + newSelectedIds.length 
            + ' ' + countString(newSelectedIds.length, 'node'));

        this.affectsConnections = false;
        this.selfUpdate         = true;

        this.prevSelectedIds    = [...prevSelectedIds];
        this.newSelectedIds     = [...newSelectedIds];
             
        this.shiftPressed       = shiftPressed;
   
        this.fromPos            = fromPos;
        this.toPos              = toPos;

                
        const dx = this.toPos.x - this.fromPos.x;
        const dy = this.toPos.y - this.fromPos.y;


        this.from = []; // these hold tuples
        this.to   = []; // [id, pos]

        for (const id of this.getMovedIds())
        {
            const node = nodeFromId(id);

            this.from.push([id, point(node.slx,      node.sly     )]);
            this.to  .push([id, point(node.slx + dx, node.sly + dy)]);
        }
    }



    getMovedIds()
    {
        const movedIds = [];

        if (this.shiftPressed)
            movedIds.push(...this.prevSelectedIds);
        
        movedIds.push(...this.newSelectedIds);

        return movedIds;
    }


    
    do(updateNodes)
    {
        const movedIds   = [...this.getMovedIds()];
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (let i = 0; i < movedNodes.length; i++)
        {
            const p = this.to.find(t => t[0] == movedNodes[i].id)[1];
            movedNodes[i].setPosition(p.x, p.y);
        }

        for (const node of movedNodes)
        {
            node.updateMeasureData();
            node.updateNode();
        }


        uiSaveNodes(movedIds);
    }



    undo(updateNodes)
    {
        const movedIds   = [...this.getMovedIds()];
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (let i = 0; i < movedNodes.length; i++)
        {
            const p = this.from.find(t => t[0] == movedNodes[i].id)[1];
            movedNodes[i].setPosition(p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateNode();
            
        graphView.selectByIds(this.prevSelectedIds);

        uiSaveNodes(movedIds);
    }



    redo(updateNodes)
    {
        this.do(updateNodes);

        graphView.selectByIds(this.getMovedIds());
    }
}



class SelectNodesAction
extends Action
{
    selectedIds     = [];
    prevSelectedIds = [];



    constructor(selectedIds, prevSelectedIds)
    {
        super(
            SELECT_ACTION,
              'SELECT ' + selectedIds.length 
            + ' ' + countString(selectedIds.length, 'node'));

        this.affectsConnections = false;
        this.selfUpdate         = true;

        this.selectedIds        = [...selectedIds];
        this.prevSelectedIds    = [...prevSelectedIds];
    }



    do(updateNodes)
    {
        // this happens in the UI
        updateComments(this.prevSelectedIds);
    }



    undo(updateNodes)
    {
        graphView.selectByIds(this.prevSelectedIds);
        updateComments(this.selectedIds);
    }



    redo(updateNodes)
    {
        graphView.selectByIds(this.selectedIds);

        updateComments(this.selectedIds);
        updateComments(this.prevSelectedIds);
    }
}



function updateComments(nodeIds)
{
    nodeIds
        .map(id => nodeFromId(id))
        .filter(n => n.type == COMMENT)
        .forEach(n => n.updateNode());
}


class SetCurrentGraphAction
extends Action
{
    graph;
    oldGraph;



    constructor()
    {
        const graphName =
            graph.parentNodeGroup
            ? (settings.showNodeId ? graph.parentNodeGroup.id : graph.parentNodeGroup.name)
            : '';

        super(
            SET_CURRENT_GRAPH_ACTION,
            'SET CURRENT GRAPH TO \'' + graphName + '\'');

        this.affectsConnections = false;

        this.oldGraph = currentGraph;
    }



    do(updateNodes)
    {
        setCurrentGraph(this.graph);
    }



    undo(updateNodes)
    {
        setCurrentGraph(this.oldGraph);
    }
}


class SetNodeRectAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    oldRect;
    newRect;



    constructor(nodeId, oldRect, newRect)
    {
        super(
            SET_NODE_RECT_ACTION,
           'SET NODE ' + nodeId + ' RECT to \'' + newRect.toString() + '\'');

        this.affectsConnections = false;

        this.nodeId  = nodeId;

        this.oldRect = Rect.fromRect(oldRect);
        this.newRect = Rect.fromRect(newRect);
    }



    do(updateNodes)
    {
        // this.node.setRect( // already done
        //     this.newRect.x,
        //     this.newRect.y,
        //     this.newRect.w,
        //     this.newRect.h);

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        this.node.setRect(
            this.oldRect.x,
            this.oldRect.y,
            this.oldRect.w,
            this.oldRect.h);

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    redo(updateNodes)
    {
        this.node.setRect(
            this.newRect.x,
            this.newRect.y,
            this.newRect.w,
            this.newRect.h);

        this.node.updateNode();
        
        uiSaveNodes([this.nodeId]);
    }
}


class SetParamSettingAction
extends Action
{
    nodeId;
    paramId;


    get param() 
    { 
        return nodeFromId(this.nodeId).params
               .find(p => p.id == this.paramId); 
    } 

    get node() { return this.param.node; } 


    setting;

    oldValue;
    newValue;



    constructor(param, setting, value)
    {
        super(
            SET_PARAM_SETTING_ACTION,
            'SET PARAM SETTING ' + param.node.id + '.' + param.id + '[' + setting + '] = ' + value);

        this.nodeId     = param.node.id;
        this.paramId    = param.id;
  
        this.setting    = setting;
        this.newValue   = value;

        this.selfUpdate = true;
    }



    do(updateNodes)
    {
        switch (this.setting)
        {
            case 'align': 
                this.oldValue = this.param.controls[0].getTextAlignment();
                break;
        }


        this.name = 
             'SET PARAM SETTING ' 
            + this.param.node.id 
            + '.' + this.param.id 
            + '[' + this.setting + ']'
            + ' = ' + this.newValue
            + ' (old value = ' + this.oldValue + ')';


        this.param.updateSetting(this.setting, this.newValue);
        this.node.updateNode();
        
        uiSaveNodes([this.nodeId]);

        //pushUpdateFromParam(this, [this.param.node], this.param);
    }



    undo(updateNodes)
    {
        this.param.updateSetting(this.setting, this.oldValue);
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    redo(updateNodes)
    {
        this.param.updateSetting(this.setting, this.newValue);
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
   }
}


class SetParamValueAction
extends Action
{
    nodeId;
    paramId;


    get param() 
    { 
        return nodeFromId(this.nodeId).params
               .find(p => p.id == this.paramId); 
    } 


    oldValue; // decimal
    newValue; // decimal



    constructor(param, value)
    {
        super(
            SET_PARAM_VALUE_ACTION,
            'SET PARAM VALUE ' + param.node.id + '.' + param.id + ' = ' + value.toDisplayString());

        this.nodeId     = param.node.id;
        this.paramId    = param.id;
  
        this.newValue   = value;

        this.selfUpdate = true;
    }



    do(updateNodes)
    {
        this.oldValue = this.param.oldValue;

        this.name = 
              'SET PARAM VALUE ' 
            + this.param.node.id 
            + '.' + this.param.id 
            + ' = ' + this.newValue.toDisplayString() 
            + ' (old value = ' + (this.oldValue ? this.oldValue.toDisplayString() : '') + ')';

        pushUpdateFromParam(this, [this.param.node], this.param);
    }



    undo(updateNodes)
    {
        // if (this.oldValue.type == TEXT_VALUE)
        // {
        //     console.log('this.param.controls[0] =', this.param.controls[0]);
        //     this.param.controls[0].textbox.managing = true;
        // }

        this.param.setValue(this.oldValue, false, true);
        pushUpdateFromParam(this, [this.param.node], this.param);
    }



    redo(updateNodes)
    {
        this.param.setValue(this.newValue);
        pushUpdateFromParam(this, [this.param.node], this.param);
    }
}


class ToggleDisableNodesAction
extends Action
{
    selectedIds = [];



    constructor(selectedIds)
    {
        super(
            TOGGLE_DISABLE_ACTION,
              'TOGGLE DISABLE ' + selectedIds.length 
            + ' ' + countString(selectedIds.length, 'node'));

        this.selectedIds = [...selectedIds];
    }



    do(updateNodes)
    {
        const nodes = this.selectedIds.map(id => nodeFromId(id));

        uiToggleDisableNodes(nodes);
        uiSaveNodes(nodes.map(n => n.id));

        pushUnique(updateNodes, nodes);
    }



    undo(updateNodes)
    {
        this.do(updateNodes);
    }
}


class ToggleParamHeaderAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    prevParamType;
    paramType;



    constructor(nodeId, paramType)
    {
        super(
            TOGGLE_PARAM_HEADER_ACTION,
            'TOGGLE PARAM HEADER ' + boolToString(paramType));
        
        this.affectsConnections = false;

        this.nodeId    = nodeId;
        this.paramType = paramType;
    }



    do(updateNodes)
    {
        this.prevParamType  = this.paramType;
        this.node.paramType = this.paramType;

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        this.node.paramType = this.prevParamType;

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }    
}


class UngroupNodesAction
extends Action
{
    constructor(pageId)
    {
        super(UNGROUP_NODES_ACTION, 'UNGROUP NODES');

    }



    do(updateNodes)
    {
        // get node bounds inside group
        // get node position of group node

        // disconnect params
        // unsave connections

        // delete param nodes

        // move rest of nodes one path level up
        // delete old nodes and connections
        // save new nodes and connections

        // offset new nodes to center on old group node

        // connect to outside directly
        // save new connections

        // delete group node
        // delete group page
    }



    undo(updateNodes)
    {

    }
}


const colFigmaBlue         = '#0c8ce9';



const rgbActiveFlowLight   = hex2rgb('#969696');
const rgbFlowLight         = hex2rgb('#D1D1D1');
  
const rgbActiveNumberLight = hex2rgb('#369FE5');
const rgbNumberLight       = hex2rgb('#B8D4F2');

const rgbActiveGroupLight  = hex2rgb('#3AAB5A');
const rgbGroupLight        = hex2rgb('#B9D9BF');

const rgbActiveShapeLight  = hex2rgb('#E1765F');
const rgbShapeLight        = hex2rgb('#F0C7C0');

const rgbActiveTextLight   = hex2rgb('#F6C953');
const rgbTextLight         = hex2rgb('#FBE6BE');


const rgbActiveFlowDark    = hex2rgb('#8B8B8B');
const rgbFlowDark          = hex2rgb('#4D4D4D');

const rgbActiveNumberDark  = hex2rgb('#1785CE');
const rgbNumberDark        = hex2rgb('#2B4E6E');

const rgbActiveGroupDark   = hex2rgb('#33AD55');
const rgbGroupDark         = hex2rgb('#365E3F');

const rgbActiveShapeDark   = hex2rgb('#E1765F');
const rgbShapeDark         = hex2rgb('#734B43');

const rgbActiveTextDark    = hex2rgb('#F4C855');
const rgbTextDark          = hex2rgb('#7E6E48');


const rgbColor             = hex2rgb('#c38fc5');   
const rgbActiveColor       = hex2rgb('#df2ae2');



const rgbNoColorLight      = [0.7, 0.7, 0.7];
const rgbNoColorDark       = [0.4, 0.4, 0.4];

const rgbaNoColorTextLight = [0, 0, 0, 0.6];
const rgbaNoColorTextDark  = [1, 1, 1, 0.4];



const rgbDefaultFill       = [0xD9, 0xD9, 0xD9];


var rgbDocumentBody;



function initThemeColors()
{
    rgbDocumentBody = computedStyle2rgba(document.body, 'background-color');

    darkMode = isDarkMode();
}


const panCursor = 
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3Ln'
    + 'czLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzJweCIgaGVpZ2h0PSIzMnB4Ij48aW1hZ2UgeGxpbms6aHJlZj0i'
    + 'ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWE'
    + 'hlQUFBSHFrbEVRVlI0WHUyYWY4aVY1Um5IUDlhbXpjM0tkRERkSDJ2WitpUEQvdEJTSEtLQ1EyVmJaTWdnbDAx'
    + 'TENUUmJ0Q1hLSFA1Z1N1UWZNZGtmZ3lrMkZLTWtjU0wrV0RKbExOU2xwaWtSaEdRU1VTMU4zV2JiYW5OOG50M1'
    + 'h1N3ZIOXpYUE9jOXp3dDczZ3B2M25QT2U4enpQOWIyLzE4Lzc2a1UzbDE3ZFhIOTZBT2hoUURkSG9NY0V1amtC'
    + 'ZXB4Z2p3bTAwUVFFTzFiYzlnSVFxNDJQOHY5YnRZTUIzdU9xdEs0R0JnRTNBdThBYndML1R1cy9nS3V0VWpjQV'
    + 'hsK2x2d0I4RVZnRXpNODBmQkZZRFR3UGZGd0NvaTNNcUJzQWxWZnhQc0R2Z0xFcVAyVElFSTRmUDU3djlGVGdq'
    + 'OEJOd0YrQk54SWJaRWV0ektnRGdMQnphYS95MXdEZkIzNnJ4cHMyYldMS2xDbWNPSEdDdVhQbnNtM2JOai9lQl'
    + 'h3TnVDMmhjaEJZRE93QlBrcnNxTVU4cWdTZ2JPdlMzcDN2Qzh3R2ZqNXk1RWoyN2R2WHNmT3JWNjltOW16LzFh'
    + 'VThEdndhK0ZkZElGUUZRRGc1ZDF6RjF3SERnZXVBVjREWGdBZVhMRm5DNHNWdTdQOWt6NTQ5akI4L3ZuanQ1K1'
    + 'BHamFOZnYzNXMzYm9Wdnd1OEM0d0FQZ0QrbVh5RXZxRXlxUUtBY0hTOTA0NmY3dXJwTGdYQXNXUEhHRHAwYU1k'
    + 'UGUvWHFlTFFKd0NIZ2ZES0hTazJoQ2dEQzBYMEplQWFZcUJaYnRteGgrUERoTEZpd2dIWHJKQVRGcm5iRmdBc1'
    + 'hQcm14TWtPR0FQY0RMd0IvU3l3d1dsVEdnbFlCOFBkU1h1Vy9BdndaK1BxcVZhdVlOMjlleDI0T0dEQ0EwNmRQ'
    + 'Tnd2QVE4bEpHaDFrZ2Y1QUZnaEN5MnhvRlFCdFgrcC9PZGw3RWR2S3U3bDA2ZEpDK1NZWjhDandUV0JrOGlWUE'
    + 'F5K1Y4b2FtR1ZFRkFJYTVmc0FOd0tzMUFOQ1pTM2tTK0VVV0hjd1htcEpXQWREK3BmKzF3SURrOGF0bUFLTkhq'
    + 'MmI1OHVYSXBPUVhWRlpmc3pmNUJYT0ZwbGpRS2dCaC80YTdnY0RMVlROZzJMQmhIRGx5cEdOM1I0MGF4Zjc5Kz'
    + 'MwdkEzNlovRUtFeUlaWlVBVUFKam9CZ09HcVN3WVlBVko4dnlnUDZDb0s3TjY5dThnUFFzS2ZKRDh3SmFYT0g2'
    + 'WVErWmtDOEZYQUZMWmRBSGl2SHdCbmdMOG5mOUN3R1ZURmdPdVRDYlFUQU0zdFhzREV5eHpoSDgzNGdTc1pnTV'
    + 'BBRHhNQTV4SUFEZWNGVnpJQWVzYjdnRk9BQU9nSGFnY2dBSXUvRmorR3dYQ0NCenJ6QVRvK25WZkZUckN0QU9T'
    + 'bGJsUis2aHIxZmlSQ3BzS2RPa0hqOTlpeFl5K0tBZ0tqNk8xektWZUpuVVFCQVpoZVlrRERDZEhsbUVBb2JNen'
    + 'ZiMDBEV0tHNTY2YSttNjE5QUIzaG56b0RvT0hZZElrZlpHR3dMUUJFc2VOT1c2ditDcml6aytjek0xbWJtaGNY'
    + 'TWVCS0JzQlUxMkpITy84TmNJL0tyRnk1a2hFalJuRDQ4T0hDcnMrZDB3Y1ZEUXM3UUxVQ0VQNEVxSjBCN3I3S1'
    + 'creVlkeityY3VYR3hjR0RCMW0wYUJFN2R1em8yT2h5VmxjbEE5b0pnTHZ2amxycVBnQThZVXBhZGxhaDNMSmx5'
    + 'enFhSFo4WEFLTFEwY1BQQVg1V0xrektPN3RyMXk3bXo1L1BvVU5GU1ZDTHRKTUJPajRMSFV2ZE85TGhSY0dBdk'
    + 'RncGEzbisvSG42OXZWbjljaG5CWUNsN25KZ3NtcHQzNzZkU1pNbTFhUGhwMXkxblFEa0ptQ3o0MmJnS2VBYlB1'
    + 'UEdqUnVaT3RVRG5mWktPd0hJbmFCSmp1V3VKemNMMCtFbWE5ZXVaY2FNR1cxRm9BUkExQUkyVEswRktzMEVEWU'
    + '9SNjBlcWE5L3ZGdUNud0xmVXZOd0JyaHVOVWlhWUYwT1d3NVVDb0M2UkNJVXpOQlYyYVFZL0FXNzFTeXRXckdE'
    + 'aFFvbFJ2OHlhTllzMWE5WjRvejhBUDY2N0dveFVPRnJmTWtGekVBUVBNMlhDN1Q2TkFBaEUzYUx6M2JsenA3ZD'
    + 'VEbGlXQUFnVHFLVWN0aGpTSVFxQ1RBZ1FCRUxuS0FpR3llSXdSSk9vVXdZT0hNaXBVN1lBaXFKTUVPd0lDWUFt'
    + 'VUFzQTNxd3pFS3dHZ3cyUEFhUDlvazVSNTFpSDdOMjd0MmlSSi9rZThIbzZPQlVBYTVGYWU0S0NFSkhCNGtnbU'
    + 'NJTG1JQkNQeEFDRTRkRXdXYlZNbno2ZDlldlhlMW1yVCszL0wxbFRWQUFhbHN2cEIrUVhEUkRDSER3UHpFRXda'
    + 'YlpYd01TSkV6OVJJRFg4WktVZmJONjh1UmlzU0xJQStEM3dQbkEyaFVBUFJ4cVdSZ0h3QnJsakRDYVlMa2VFZU'
    + 'JENHJsLzBkUGpBZ2FKTDFwS2NPWE9HL3YyOWZDRk9rM2dvOGw2cEk5eHdDQXhsbW5tNHZGR2lZd3dtaEUvNEVY'
    + 'QjNGVXpJaHlpQXQ0RlppZnA2UW5lLzZUT0JWZ0NJMytZTmt6SUltc0xEZm5ITW1ERkZtSnc4dVNnbExrdk9uaj'
    + 'NMaGcwYm1ETkhxeXJFM244a1BpcnYxRWljQnpnejBKUTBZd0w1amZMcGtKZ1IwQnhrZ2tzUXpKWDlqSmt6WnpK'
    + 'dDJqUW1UQ2pjUktkeTlPalJRbkhYeVpNbjR6c2VoeitSS0cvWVUvbUkvZHArdytFdkx0d3FBRGtUSW0yV0NTcX'
    + 'NjM1E1K25ZWDhKMjRhZS9ldlJrOGVEQ0RCZzJpVDUraWk0WjI3dVNZZnpQeGplMWlSMHg4cmVMU1BzNEJtajRV'
    + 'clJLQU1naTIwT3dpR1NZRndpVW8xZzdmVGtOUGd6K0ZyOGRTejg4dTgxdHB0MVhjSmUxalVxVGxjWmtxR0pDRE'
    + 'dWT2hnaEFtb2ZJdVFmRXp0OXoza1QrWVpTcFdjOUpiKzViV1puWXFxcE9UN2k1Zit6M0haR0tJc2luYnI1b0Ir'
    + 'Zlh5ckZHRlhVYUtlQzBBNWhHQzVYSVRZaXhXcGR4VkZSUUFsUlVFbDYvOVRIQXFVVDZvMnhLQ1hmdzRRTkF2cU'
    + 'd5TTBJWHlmcTd5Zmk5WUdDT3hBcUNTZ3FDTng0cGhTWlZ2T09YdFNza3FUYUI4ajRnUStiQjBERTNudXgvUEVG'
    + 'TmZ3WUlBd3IvNUlIVmx5dGZKZ0J5TU9GcUxORHAvci9JNUFEa0lNaUlmbHE1VThicDh3S1hNS1pUTi8rYWJFQW'
    + '9HQ0orTGNmazYvRXVsMTZ6VEIxVDZvSFZkckFlQXVwQzlVcTdiN1Jud1g2cWNXVzY0MVZ5REFBQUFBRWxGVGtT'
    + 'dVFtQ0MiIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIvPjwvc3ZnPg==) 15 15, auto';


const zoomInCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kKSI+PHBhdGgg'
    + 'ZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC41IDhDMTQuNSAxMS4wMzggMT'
    + 'IuMDM4IDEzLjUgOSAxMy41QzUuOTYyIDEzLjUgMy41IDExLjAzOCAzLjUgOEMzLjUgNC45NjIgNS45NjIgMi41'
    + 'IDkgMi41QzEyLjAzOCAyLjUgMTQuNSA0Ljk2MiAxNC41IDhaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGZpbGwtcn'
    + 'VsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAzOCAx'
    + 'My41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5IDIuNU'
    + 'MxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPjxwYXRoIGZpbGwtcnVsZT0i'
    + 'ZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNTg1NyAxOC4wMDAyTDE4Ljk5OTcgMTYuNTg2Mk'
    + 'wxMy41NTA3IDExLjEzNzJMMTIuMTM2NyAxMi41NTEyTDE3LjU4NTcgMTguMDAwMloiIGZpbGw9ImJsYWNrIi8+'
    + 'PC9nPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0gxMFY1SD'
    + 'hWN0g2VjguOThIOFYxMUgxMFY4Ljk4SDEyVjdaIiBmaWxsPSJibGFjayIvPjxkZWZzPjxmaWx0ZXIgaWQ9ImZp'
    + 'bHRlcjBfZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIxLjk5OTciIGhlaWdodD0iMjIuMDAwMiIgZmlsdGVyVW5pdH'
    + 'M9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPjxmZUZsb29kIGZs'
    + 'b29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQ29sb3JNYXRyaXggaW49Il'
    + 'NvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMTI3IDAiLz48ZmVPZmZzZXQgZHk9IjEiLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLj'
    + 'UiLz48ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMCAwIDAgMC4zNSAwIi8+PGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZU'
    + 'ZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3ciLz48ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3Vy'
    + 'Y2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvdyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjwvZG'
    + 'Vmcz48L3N2Zz4=) 8 8, auto';


const zoomOutCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZCkiPgo8cGF0'
    + 'aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjUgOEMxNC41IDExLjAzOC'
    + 'AxMi4wMzggMTMuNSA5IDEzLjVDNS45NjIgMTMuNSAzLjUgMTEuMDM4IDMuNSA4QzMuNSA0Ljk2MiA1Ljk2MiAy'
    + 'LjUgOSAyLjVDMTIuMDM4IDIuNSAxNC41IDQuOTYyIDE0LjUgOFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGZpbG'
    + 'wtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAz'
    + 'OCAxMy41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5ID'
    + 'IuNUMxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1'
    + 'bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3LjU4NTcgMTguMDAwMkwxOC45OTk3IDE2Lj'
    + 'U4NjJMMTMuNTUwNyAxMS4xMzcyTDEyLjEzNjcgMTIuNTUxMkwxNy41ODU3IDE4LjAwMDJaIiBmaWxsPSJibGFj'
    + 'ayIvPgo8L2c+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0'
    + 'g2VjguOThIMTJWN1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2QiIHg9IjAi'
    + 'IHk9IjAiIHdpZHRoPSIyMS45OTk3IiBoZWlnaHQ9IjIyLjAwMDIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPbl'
    + 'VzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0i'
    + 'MCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIi'
    + 'B0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAi'
    + 'Lz4KPGZlT2Zmc2V0IGR5PSIxIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIvPgo8ZmVDb2'
    + 'xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAw'
    + 'IDAgMC4zNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3'
    + 'VsdD0iZWZmZWN0MV9kcm9wU2hhZG93Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBo'
    + 'aWMiIGluMj0iZWZmZWN0MV9kcm9wU2hhZG93IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cj'
    + 'wvc3ZnPgo=) 8 8, auto';


var _dataModePages = [];
var _dataModeNodes = [];
var _dataModeConns = [];



function initDataMode()
{
    btnDataModeRestart.addEventListener('click', () => uiRestartGenerator(false));
}



dataModePagesWrapper.addEventListener('pointerdown', e =>
{
    e.preventDefault();

    if (e.button == 2)
    {
        e.stopPropagation();
        menuPageDataPages.showAt(e.clientX, e.clientY, false);
    }
});



dataModeNodesWrapper.addEventListener('pointerdown', e =>
{
    e.preventDefault();

    if (e.button == 2)
    {
        e.stopPropagation();
        menuNodeDataNodes.showAt(e.clientX, e.clientY, false);
    }
});



dataModeConnsWrapper.addEventListener('pointerdown', e =>
{
    e.preventDefault();

    if (e.button == 2)
    {
        e.stopPropagation();
        menuConnDataConns.showAt(e.clientX, e.clientY, false);
    }
});



function loadNodesAndConnsData(_pages, _nodes, _conns)
{
    _dataModePages = _pages;
    _dataModeNodes = _nodes;
    _dataModeConns = _conns;


    _dataModeNodes.sort((n1, n2) => 
    {
        if (n1.key.split(' ')[1] < n2.key.split(' ')[1]) return -1;
        if (n1.key.split(' ')[1] > n2.key.split(' ')[1]) return  1;
        return 0;
    });

    _dataModeConns.sort((c1, c2) => 
    {
        if (c1.value.outputNodeId != c2.value.outputNodeId) return c1.value.outputNodeId < c2.value.outputNodeId ? -1 : 1;
        if (c1.value.outputId     != c2.value.outputId    ) return c1.value.outputId     < c2.value.outputId     ? -1 : 1;
        if (c1.value.outputOrder  != c2.value.outputOrder ) return parseInt(c1.value.outputOrder) - parseInt(c2.value.outputOrder);
        return 0;
    });

    
    for (const _page of _dataModePages) dataModePages.appendChild(createPageDataDiv(_page));
    for (const _node of _dataModeNodes) dataModeNodes.appendChild(createNodeDataDiv(_node));
    for (const _conn of _dataModeConns) dataModeConns.appendChild(createConnDataDiv(_conn));


    updateDataModeInfo();

    
    loadingOverlay.style.display = 'none';
}



function updateDataModeInfo()
{
    dataModePagesTitle.innerHTML = dataModePages.children.length + '&thinsp;&nbsp;' + countString(dataModePages.children.length, 'page'      );
    dataModeNodesTitle.innerHTML = dataModeNodes.children.length + '&thinsp;&nbsp;' + countString(dataModeNodes.children.length, 'node'      );
    dataModeConnsTitle.innerHTML = dataModeConns.children.length + '&thinsp;&nbsp;' + countString(dataModeConns.children.length, 'connection');
}



function createPageDataDiv(_page)
{
    const div    = createDiv('dataModePage');
    
    const page   = JSON.parse(_page.value);
    page._key    = _page.key;


    div._page    = _page.value;
    div. page    =  page;

    div.showJson = false;


    expandPageData(div);


    div.addEventListener('dblclick', () =>
    {
        div.showJson = !div.showJson;
        expandPageData(div, page, _page);
    });


    div.addEventListener('pointerenter', () => div.style.background = 'var(--data-mode-node-active)');
    div.addEventListener('pointerleave', () => { if (!menuPageData._div) div.style.background = 'var(--data-mode-node)'; });


    div.addEventListener('pointerdown', e =>
    {
        e.preventDefault();

        if (e.button == 2)
        {
            e.stopPropagation();

            // div.style.background = 'var(--data-mode-node-active)';

            createDataMenuOnHide(
                menuPageData,
                div,
                'var(--data-mode-node)'); 

            menuPageData.showAt(e.clientX, e.clientY, false);
        }
    });


    return div;
}



function createNodeDataDiv(_node)
{
    const div    = createDiv('dataModeNode');
    
    const node   = JSON.parse(_node.value);
    node._key    = _node.key;
    node .div    = div;


    div._node    = _node.value;
    div. node    =  node;

    div.showJson = false;

    expandNodeData(div);


    div.addEventListener('dblclick', () =>
    {
        div.showJson = !div.showJson;
        expandNodeData(div, node, _node);
    });


    div.addEventListener('pointerenter', () => div.style.background = 'var(--data-mode-node-active)');
    div.addEventListener('pointerleave', () => { if (!menuNodeData._div) div.style.background = 'var(--data-mode-node)'; });


    div.addEventListener('pointerdown', e =>
    {
        e.preventDefault();

        if (e.button == 2)
        {
            e.stopPropagation();

            // div.style.background = 'var(--data-mode-node-active)';

            createDataMenuOnHide(
                menuNodeData,
                div,
                'var(--data-mode-node)'); 

            menuNodeData.showAt(e.clientX, e.clientY, false);
        }
    });


    return div;
}



function createConnDataDiv(_conn)
{
    const div    = createDiv('dataModeConn');

    const conn   = JSON.parse(_conn.value);
    conn._key    = _conn.key;

    div._conn    = _conn.value;
    div. conn    =  conn;

    div.showJson = false;

    expandConnData(div);


    div.addEventListener('dblclick', () =>
    {
        div.showJson = !div.showJson;
        expandConnData(div, conn, _conn);
    });


    div.addEventListener('pointerenter', () => div.style.background = 'var(--data-mode-conn-active)');
    div.addEventListener('pointerleave', () => { if (!menuConnData._div) div.style.background = 'var(--data-mode-conn)'; });


    div.addEventListener('pointerdown', e =>
    {
        e.preventDefault();
        
        if (e.button == 2)
        {
            e.stopPropagation();

            div.style.background = 'var(--data-mode-conn-active)';

            createDataMenuOnHide(
                menuConnData,
                div,
                'var(--data-mode-conn)');

            menuConnData.showAt(e.clientX, e.clientY, false);
        }
    });


    return div;
}



function createDataMenuOnHide(menu, div, normal)
{
    menu._div = div;
    
    menu.onHide = () =>
    { 
        menu._div.style.background = normal;
        setTimeout(() => menu._div = null);
    };
}



function expandPageData(div)
{
    if (div.showJson)
    {
        div.innerHTML =
              '<div class="pageDataHeader">' + div.page._key + '</div>'
            + '<div class="pageDataBody">' + formatSavedDataJson(div._page) + '</div>';

        div.style.paddingLeft   = '0px';
        div.style.paddingRight  = '0px';
        div.style.textAlign     = 'left';
        div.style.fontFamily    = 'Roboto Mono';
        div.style.letterSpacing = '-0.06em';
    }
    else
    {
        div.innerHTML = div.page.id;

        div.style.paddingLeft   = '6px';
        div.style.paddingRight  = '6px';
        div.style.textAlign     = 'center';
        div.style.fontFamily    = 'Inter';
        div.style.letterSpacing = 0;
    }
}



function expandNodeData(div)
{
    if (div.showJson)
    {
        div.innerHTML =
        //   '<div>' + div._key + '</div><div>'
        // + (div.node.loading ? '&nbsp;🛑<br/>' : '')
              '<div class="nodeDataHeader">' + (div.node.loading ? '🛑&nbsp;' : '') + div.node._key + '</div>'
            + '<div class="nodeDataBody">' + formatSavedDataJson(div._node) + '</div>';

        div.style.paddingLeft   = '0px';
        div.style.paddingRight  = '0px';
        div.style.textAlign     = 'left';
        div.style.fontFamily    = 'Roboto Mono';
        div.style.letterSpacing = '-0.06em';
    }
    else
    {
        div.innerHTML = 
             (div.node.loading ? '🛑&nbsp;&nbsp' : '')
            + div.node.id;

        div.style.paddingLeft   = '6px';
        div.style.paddingRight  = '6px';
        div.style.textAlign     = 'center';
        div.style.fontFamily    = 'Inter';
        div.style.letterSpacing = 0;
    }
}



function expandConnData(div)
{
    if (div.showJson)
    {
        div.innerHTML =
                '<div class="connDataHeader">' 
                  + (div.conn.loading ? '🛑&nbsp;' : '') 
                  + div.conn._key.replaceAll('undefined', '<span class="dataUndefined">undefined</span>') 
              + '</div>'
              + '<div class="connDataBody">' + formatSavedDataJson(div._conn) + '</div>';

        div.style.paddingLeft   = '0px';
        div.style.paddingRight  = '0px';
        div.style.textAlign     = 'left';
        div.style.fontFamily    = 'Roboto Mono';
        div.style.letterSpacing = '-0.06em';
    }
    else
    {
        div.innerHTML = 
             (div.conn.loading ? '🛑&nbsp;&nbsp' : '')
            + connToString(div.conn);

        div.style.paddingLeft   = '6px';
        div.style.paddingRight  = '6px';
        div.style.textAlign     = 'center';
        div.style.fontFamily    = 'Inter';
        div.style.letterSpacing = 0;
    }
}



function expandAllPageData()
{
    for (const div of dataModePages.children)
    {
        div.showJson = true;
        expandPageData(div, div.page, div._page);
    }
}



function collapseAllPageData()
{
    for (const div of dataModePages.children)
    {
        div.showJson = false;
        expandPageData(div, div.page, div._page);
    }
}



function expandAllNodeData()
{
    for (const div of dataModeNodes.children)
    {
        div.showJson = true;
        expandNodeData(div, div.node, div._node);
    }
}



function collapseAllNodeData()
{
    for (const div of dataModeNodes.children)
    {
        div.showJson = false;
        expandNodeData(div, div.node, div._node);
    }
}



function expandAllConnData()
{
    for (const div of dataModeConns.children)
    {
        div.showJson = true;
        expandConnData(div, div.conn, div._conn);
    }
}



function collapseAllConnData()
{
    for (const div of dataModeConns.children)
    {
        div.showJson = false;
        expandConnData(div, div.conn, div._conn);
    }
}



function dataModeDeleteAllPages()
{
    const nPages = graph.pages.length;
    const notice = 'Deleted ' + nPages + ' ' + countString(nPages, 'page');

    for (const page of graph.pages)
        dataModeDeletePage(page, false);

    if (nPages > 0)
        uiNotify(notice);
}



function dataModeDeletePage(page, notify = true)
{
    for (let i = dataModePages.children.length-1; i >= 0; i--)
    {
        const div = dataModePages.children[i];

        if (div.page.id == page.id)
            dataModePages.removeChild(div);
    }


    uiRemoveSavedPage(page.id);

    graph.nodes
        .filter (n => n.pageId == page.id)
        .forEach(n => dataModeDeleteNode(n));


    const notice = 'Deleted page \'' + page.id + '\'';

    updateDataModeInfo();

    if (notify)
        uiNotify(notice);
}



function dataModeDeleteNode(node)
{
    uiRemoveSavedNodesAndConns([node.id]);


    for (let i = dataModeNodes.children.length-1; i >= 0; i--)
    {
        const div = dataModeNodes.children[i];

        if (div.node.id == node.id)
            dataModeNodes.removeChild(div);
    }


    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (   div.conn.outputNodeId == node.id
            || div.conn. inputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    let notice = 'Deleted node \'' + node.id + '\'';

    if (nRemovedConns > 0)
        notice += ' and ' + nRemovedConns + ' ' + countString(nRemovedConns, 'connection');


    updateDataModeInfo();

    uiNotify(notice);
}



function dataModeDeleteAllNodes()
{
    uiRemoveAllSavedNodesAndConns();


    let nRemovedNodes = dataModeNodes.children.length;

    for (let i = dataModeNodes.children.length-1; i >= 0; i--)
        dataModeNodes.removeChild(dataModeNodes.children[i]);


    let nRemovedConns = dataModeConns.children.length;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
        dataModeConns.removeChild(dataModeConns.children[i]);


    let notice = 'Deleted ' + nRemovedNodes + ' ' + countString(nRemovedNodes, 'node');

    if (nRemovedConns > 0)
        notice += ' and ' + nRemovedConns + ' ' + countString(nRemovedConns, 'connection');


    updateDataModeInfo();

    uiNotify(notice);
}



function dataModeDeleteAllConnections()
{
    uiRemoveAllSavedConnections();


    let nRemovedConns = dataModeConns.children.length;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
        dataModeConns.removeChild(dataModeConns.children[i]);


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString(nRemovedConns, 'connection'));
}



function dataModeDeleteConnectionsToAndFromNode(node)
{
    uiDeleteSavedConnectionsToNodeId  (node.id);
    uiDeleteSavedConnectionsFromNodeId(node.id);

    
    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (   div.conn.outputNodeId == node.id
            || div.conn. inputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString(nRemovedConns, 'connection') + ' to and from \'' + node.id + '\'');
}



function dataModeDeletePathFromNodeId(node)
{
    console.log('node ', node);

    uiRemoveSavedNodesAndConns([node.id]);
    uiDeleteObjectsAndStyles([node.id], true);


    const div = node.div;
    

    node.id = stripPathFromId(node.id);

    delete node.loading;
    delete node._key;
    delete node.div;

    uiSaveNodesJson([node.id], [node]);
}



function dataModeDeleteConnectionsFromNode(node)
{
    uiDeleteSavedConnectionsFromNodeId(node.id);


    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (div.conn.outputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString(nRemovedConns, 'connection') + ' from \'' + node.id + '\'');
}



function dataModeDeleteConnectionsToNode(node)
{
    uiDeleteSavedConnectionsToNodeId(node.id);


    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (div.conn. inputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString(nRemovedConns, 'connection') + ' to \'' + node.id + '\'');
}



function dataModeDeleteConnection(conn)
{
    uiDeleteSavedConnection(
        conn._key,
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId,
        conn.list);


    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (div.conn._key == conn._key)
            dataModeConns.removeChild(div);
    }


    updateDataModeInfo();

    uiNotify('Deleted connection  ' + connToString(conn));
}



var documentBodyClient = null;


document.button0 = false;



document.addEventListener('pointerdown', function(e)
{
    if (e.button == 0)
        document.button0 = true;
}, 
true);



document.addEventListener('pointerup', function(e)
{
    if (e.button == 0)
        document.button0 = false;
},
true);



document.addEventListener('pointerup', function(e)
{
    graphView.scrollbarX.moving = false;
    graphView.scrollbarY.moving = false;
});



window.addEventListener('focus', () => graph.updatePages());
window.addEventListener('blur',  () => graph.updatePages());

document.addEventListener('contextmenu', e => e.preventDefault());



document.addEventListener('dragover',  e => e.preventDefault());

document.addEventListener("drop", async e => 
{
    e.preventDefault();
    

    const files = [];
    
    if (e.dataTransfer.items) 
    {
        for (const item of e.dataTransfer.items) 
        {
            if (item.kind === 'file') 
                files.push(item.getAsFile());
        }
    }
    else 
    {
        for (const file of e.dataTransfer.files) 
            files.push(file);
    }


    for (const file of files)
    {
        const reader = new FileReader();
        reader.readAsText(file,'UTF-8');

        reader.onload = e =>
            actionManager.do(new PasteNodesAction(e.target.result, false, false, true));
    }
});




var generatorStarted = false;


var uiFigMessages    = []; // messages from UI to Figma
var genMessages      = []; // messages from UI to Generator

var genMessagePosted = false;


var allUpdateNodes   = [];



var currentSessionId = '';



// uiClearAllLocalData();
//uiQueueMessageToFigma({cmd: 'figLogAllLocalData', darkMode: darkMode});

// uiClearLocalData('windowWidth');
// uiClearLocalData('windowHeight');

// uiClearLocalData('showRequests');
// uiClearLocalData('showWhatsNew');

//uiSetLocalData('enableBetaFeatures', 'true');
//uiSetLocalData('sessionId', '');
//uiSetLocalData('logLoading', 'true');

//uiRemoveConnsToNodes(['num3']);
//uiRemoveSavedNodesAndConns(['color']);
//uiRemovePluginDataFromAllLocalStyles();

//uiCleanAllIds();



//uiRemoveAllSavedNodesAndConns();
//uiRemoveAllSavedPages();



var currentUser  = null;



const generator = new Worker(
    window.URL.createObjectURL(
        new Blob([generatorScript.textContent])));


var panMode             = false;

var     copiedNodesJson = '';
var duplicatedNodesJson = '';

var pasteOffset         = point(0,  0);
var pasteOffsetDelta    = point(50, 50);



clearConsole();


initUtilContext();


initLoadingOverlay();
initDataMode();
initEulaDialog();
initWhatsNewDialog();
initAboutDialog();


uiQueueMessageToFigma({cmd: 'figStartGenerator'});



async function uiReturnFigStartGenerator(msg)
{
    currentUser = msg.currentUser;


    loadLocalSettings();


    figFonts           = [...msg.fonts];
    figUniqueFontNames = [...new Set(msg.fonts.map(f => f.fontName.family))];


    uiQueueMessageToGenerator(
    {
        cmd:            'initFonts',
        fonts:           figFonts,
        uniqueFontNames: figUniqueFontNames
    });


    graphView.updateMeasureData();

    viewportRect = msg.viewportRect;
    viewportZoom = msg.viewportZoom;


    initThemeColors();
    initKeyboardPanel();
    initWindowSizers();


    validateInit(msg.eulaRead);
}



function initGenerator()
{
    uiGetLocalData('showWhatsNew');

    setTimeout(() => loadingGraphic.style.display = 'block', 300);

    uiQueueMessageToFigma({
        cmd:     'figLoadNodesAndConns',
        dataMode: settings.dataMode });

    enableFeatures(subscribed());
}



function createSessionId()
{
    const date = getCurrentDateString();
    const hash = hashLicenseString(currentUser.id + date, licenseHashSize);
    const enc  = sign(hash, licenseKeys.private);
    
    return arrayToBase32(enc);
}



function subscribed()
{
    return currentSessionId == createSessionId();
}



function validateInit(eulaRead)
{
    try
    {
        checkSubActive().then(subActive => 
        {
            if (subActive) 
            {
                currentSessionId = createSessionId();
                //initGenerator();
            }

            // else checkTrialExists().then(trialExists => 
            // {
            //     if (trialExists)
            //         initGenerator();
            //     else
            //         showEulaDialog();
            // });

            if (!eulaRead)
                showEulaDialog();
            else
                initGenerator();
        });
    }
    catch (e)
    {
        console.error('Error connecting to license server...');
        console.error(e);
    }
}



function getCurrentDateString()
{
    const today = new Date();

    const year  = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0');
    const day   = String(today.getDate()).padStart(2, '0');

    return `${year}-${month}-${day}`;
}


var altPressedInMenu = false;



document.addEventListener('keydown', e =>
{
    if (   crashed
        || graphView.loadingNodes
        || graphView.pastingNodes
        || graphView.restoringNodes)
    {
        e.preventDefault();
        e.stopPropagation();
        return;
    }


    let setLastKeyDown = true;


    // restart
    if (    e.code == 'KeyR'
        &&  getCtrlKey(e)
        &&  e.altKey
        && !e.shiftKey)
    {
        e.preventDefault();
        uiRestartGenerator(true);
    }

    // hand tool
    if (    e.code == 'KeyH'
        && !getCtrlKey(e)
        && !e.altKey
        && !e.shiftKey)
    {
        e.preventDefault();
        updatePanMode(!panMode);
    }

    // save to file
    else if (   e.code == 'KeyS'
        &&  getCtrlKey(e)
        &&  e.shiftKey
        && !e.altKey)
    {
        e.preventDefault();
        uiSaveSelectionToLocalFile();
    }

    // focus mode
    else if (   e.code == 'KeyF'
        && !getCtrlKey(e)
        && !e.shiftKey
        &&  e.altKey)
    {
        e.preventDefault();
        updateSoloMode(!graphView.soloMode);
    }

    // cut
    else if (e.code == 'KeyX'
          && getCtrlKey(e))
    {
        graphView.copySelectedNodes();
        graphView.deleteSelectedNodes(true);
    }    

    // copy
    else if (e.code == 'KeyC'
          && getCtrlKey(e))
    {
        if (window.getSelection().toString().length == 0)
        {
            e.preventDefault();

            if (e.shiftKey) graphView.copySelectedNodesAsJavascript();
            else            graphView.copySelectedNodes();
        }
    }    

    // paste
    else if (e.code == 'KeyV'
          && getCtrlKey(e)
          && !e.altKey)
    {  
        e.preventDefault();
        graphView.pasteCopiedNodes(e.shiftKey);
    }    

    // duplicate
    else if (e.code == 'KeyD'
          && getCtrlKey(e)
          && !e.altKey)
    {
        if (e.shiftKey)
            e.preventDefault();
            
        graphView.duplicateSelectedNodes(e.shiftKey);
        return false;
    }

    // disable nodes
    else if (e.code == 'KeyE'
          && getCtrlKey(e)
          && e.shiftKey)
    {
        e.preventDefault();

        if (!graphView.selectedNodes.find(n => !n.canDisable))
            actionManager.do(new ToggleDisableNodesAction(graphView.selectedNodes.map(n => n.id)));
            
        return false;
    }

    // select all
    else if (e.code == 'KeyA'
          && getCtrlKey(e))
        graphView.selectAllNodes(e.shiftKey);

    // group selected
    else if (e.code == 'KeyG'
          && getCtrlKey(e))
    {
        if (!isEmpty(graphView.selectedNodes))
            actionManager.do(new GroupNodesAction(graphView.selectedNodes));
    }

    // undo/redo
    else if (e.code == 'KeyZ'
          && getCtrlKey(e)
          && !document.button0
          && isEmpty(currentMenus))
    {
             if (e.shiftKey && !actionManager.redoing) actionManager.redo();
        else if (              !actionManager.undoing) actionManager.undo();

        setLastKeyDown = false;
    }

    // delete / backspace
    else if (   e.key == 'Delete'
             || e.key == 'Backspace')
    {
        if (getCtrlKey(e)) graphView.removeSelectedNodes();
        else               graphView.deleteSelectedNodes();
    }

    // layout selected nodes
    else if (e.code == 'KeyL'
          && getCtrlKey(e)
          && e.shiftKey)
    {
        e.preventDefault();
        e.stopImmediatePropagation();

        layoutSelectedNodes();
    }

    else if (e.code == 'Slash'
          && getCtrlKey(e)
          && e.shiftKey)
    {
        e.preventDefault();
        e.stopPropagation();

        showKeyboardPanel();
    }

    // toggle node icons
    else if (e.code == 'KeyI'
          && getCtrlKey(e)
          && e.shiftKey)
    {
        updateSettingAndMenu('showNodeIcons',  true, !settings.showNodeIcons);  
        updateMenuItemShowNodeIcons();          
    }

    // toggle operation results
    else if (e.code == 'KeyR'
          && getCtrlKey(e)
          && e.shiftKey)
    {
        updateSettingAndMenu('showOperationResults',  true, !settings.showOperationResults);  
        updateMenuItemShowOperationResults();          
    }

    // rename selected node
    else if (e.code == 'KeyR'
          && getCtrlKey(e)
          && !e.shiftKey
          && !e.altKey)
    {
        graphView.renameSelectedNode();
    }

    // escape
    else if (e.key == 'Escape')
    {
        if (!isEmpty(currentMenus))
            hideAllMenus();

        else if (graphView.tempConn)
        {
            if (graphView.savedConn)
            {
                const savedConn = graphView.savedConn;

                setTimeout(() => 
                {
                    savedConn.wire.update();
                    savedConn.input.updateControl();
                });
            }

            graphView.cancelConnection(graphView.connPointerId);
        }


        else if (isVisible(whatsNewDialog         )) hideWhatsNewDialog();
        else if (isVisible(minZoomDialog          )) hideMinZoomDialog();
        //else if (isVisible(subscriptionDialog   )) hideSubscriptionDialog(); // no escape for subscriptions
        else if (isVisible(aboutDialog            )) hideAboutDialog();
        else if (isVisible(deleteConnectionsDialog)) hideDeleteConnectionsDialog();

        else if (!isEmpty(graphView.selectedNodes))
            graphView.deselectAllNodes(e.shiftKey);

        else
            stopRequestId = curRequestId;
    }

    //
    else if (e.code == 'Minus'
          || e.code == 'NumpadSubtract')
    {
        graph.currentPage.zoom /= Math.pow(2, 1/2);
    }

    else if (e.code == 'Equal'
          || e.code == 'NumpadAdd')
    {
        graph.currentPage.zoom *= Math.pow(2, 1/2);
    }

    else if ((   e.code == 'Digit0'
              || e.code == 'Numpad0')
          && getCtrlKey(e))
    {
        graph.currentPage.zoom = 1;
        uiNotify('Zoom to 100%');
    }

    else if (e.code == 'Digit1'
          && e.shiftKey)
    {
        graphView.zoomToFit();
        uiNotify('Zoom to fit');
    }

    else if (e.code == 'Digit2'
          && e.shiftKey)         
    {
        graphView.zoomToSelection();

        if (!isEmpty(graphView.selectedNodes))
            uiNotify('Zoom to selection');
    }

    else if (e.code == 'Space'
         && !getCtrlKey(e))
    {
        if (   !graphView.selecting
            && !graphView.spaceDown
            && !panMode)
        {
            graphView.spaceDown = true;
            setCursor(panCursor);
        }
    }

    else if (e.code == 'Enter'
          && getCtrlKey(e))
    {
        actionManager.do(new MakeActiveNodesAction(
            graph.nodes.filter(n => n.active).map(n => n.nodeId), 
            false));
    }

    else if (e.key == 'Shift')
    {
        if (    numberControlChanging
            && !numberControlChanging.shiftDown)
        {
            numberControlChanging.shiftDown = true;
            numberControlChanging.update();
        }
    }

    else if (e.key == 'Control'
         && !e.altKey
         && !e.shiftKey)
    {
        if (graphView.spaceDown)
        {
            graphView.zoomSelecting = true;
            graphView.altDown = e.altKey;

            if (e.altKey) setCursor(zoomOutCursor);
            else          setCursor(zoomInCursor);
        }

        else if (graphView.tempConn)
        {
            graphView.tempConn.backInit = true;

            const tc = graphView.tempConn;

            tc.wire.update(
                tc.wire.clientX,
                tc.wire.clientY);
        }

        else if (overNumberControl
              && overNumberControl.param)
        {
            if (overNumberControlCtrl)
            {
                overNumberControlCtrl.param.showFullPrecision = false;
                overNumberControlCtrl.update();
            }

            overNumberControlCtrl = overNumberControl;

            overNumberControlCtrl.param.showFullPrecision = true;
            overNumberControlCtrl.update();
        }
    }

    else if (    e.key == 'Alt'
             && !e.shiftKey
             && !getCtrlKey(e))
    {
        if (   currentMenus.length == 1
            && currentMenus[0] == menuColor)
        {
              menuItemColor.setIcon(iconRandomColor);
              altPressedInMenu = true;
        }
    }

    else if (    e.key == 'Alt'
             && !e.shiftKey
             &&  graphView.spaceDown
             &&  getCtrlKey(e))
    {
        setCursor(zoomOutCursor);
        graphView.altDown = true;
    }

    else if (e.code == 'Tab')
        e.preventDefault();

    else if (     (e.code == 'Slash'
                || e.code == 'KeyP')
             && getCtrlKey(e))
    {
        e.preventDefault();
        showSearchBox();
    }

    else if (e.code == 'ArrowUp')
    {
        e.preventDefault();
        graphView.nudgeSelected(0, -10);
    }

    else if (e.code == 'ArrowDown')
    {
        e.preventDefault();
        graphView.nudgeSelected(0, 10);
    }

    else if (e.code == 'ArrowLeft')
    {
        e.preventDefault();
        graphView.nudgeSelected(-10, 0);
    }

    else if (e.code == 'ArrowRight')
    {
        e.preventDefault();
        graphView.nudgeSelected(10, 0);
    }


    // else if (e.code == 'KeyN' && !getCtrlKey(e) && !e.shiftKey && !e.altKey) actionManager.do(getCreateNodeAction(NUMBER,      null, getCreateOptions(e)));
    // else if (e.code == 'KeyT' && !getCtrlKey(e) && !e.shiftKey && !e.altKey) actionManager.do(getCreateNodeAction(TEXT,        null, getCreateOptions(e)));
    // else if (e.code == 'KeyC' && !getCtrlKey(e) && !e.shiftKey && !e.altKey) actionManager.do(getCreateNodeAction(COLOR,       null, getCreateOptions(e, {random: e.altKey && !getCtrlKey(e)})));
    // else if (e.code == 'KeyG' && !getCtrlKey(e) && !e.shiftKey && !e.altKey) actionManager.do(getCreateNodeAction(GROUP_NODE,  null, getCreateOptions(e)));
    // else if (e.code == 'KeyP' && !getCtrlKey(e) && !e.shiftKey && !e.altKey) actionManager.do(getCreateNodeAction(GROUP_PARAM, null, getCreateOptions(e)));

    // graph.nodes.at(-1).div.style.left = e.clientX - (defNodeWidth    / 2) - (               + graph.currentPage.pan.x) / graph.currentPage.zoom;
    // graph.nodes.at(-1).div.style.top  = e.clientY - (defHeaderHeight / 2) - (getTopHeight() + graph.currentPage.pan.y) / graph.currentPage.zoom;

    // else
    //     e.preventDefault();
});



document.addEventListener('keyup', e =>
{
    graphView.altDown = false;


    if (e.code == 'Space')
    {
        if (graphView.spaceDown)
        {
            graphView.spaceDown     = false;
            graphView.zoomSelecting = false;
            setAutoCursor();
        }
    }

    else if (e.key == 'Alt')
    {
        if (graphView.spaceDown)
        {
            if (getCtrlKey(e)) 
                setCursor(zoomInCursor);
            else
            {
                setCursor(panCursor);
                graphView.zoomSelecting = false;
            }
        }

        else if (currentMenus.length == 1
            && currentMenus[0] == menuColor)
            menuItemColor.setIcon(iconColor);


        altPressedInMenu = false;
    }

    else if (e.key == 'Control')
    {
        if (graphView.spaceDown)
        {
            graphView.zoomSelecting = false;
            setCursor(panCursor);
        }
        else if (graphView.tempConn)
        {
            graphView.tempConn.backInit = false;

            const tc = graphView.tempConn;

            tc.wire.update( 
                tc.wire.clientX,
                tc.wire.clientY);
        }
        else if (overNumberControlCtrl)
        {
            overNumberControlCtrl.param.showFullPrecision = false;
            overNumberControlCtrl.update();
            overNumberControlCtrl.updateCursor();

            overNumberControlCtrl = null;
        }
    }

    else if (e.key == 'Shift')
    {
        if (numberControlChanging)
        {
            numberControlChanging.shiftDown = null;
            numberControlChanging.update();
        }
    }
},
false);


var currentKeyboardTab = 0;


function initKeyboardPanel()
{
    if (isMac)
    {
        const _ctrlShift = document.getElementsByClassName('ctrlShift');
        const  ctrlShift = Array.prototype.slice.call(_ctrlShift);
    
        const ctrlKeys  = ctrlShift.filter(k => k.innerHTML == 'Ctrl' );
        const shiftKeys = ctrlShift.filter(k => k.innerHTML == 'Shift');

        ctrlKeys .forEach(k => k.innerHTML = 'Shift');
        shiftKeys.forEach(k => k.innerHTML = 'Ctrl' );


        document.getElementsByClassName('treeLeftCtrl'  )[0].innerHTML = 'Alt';

        document.getElementsByClassName('newBranch1'    )[0].innerHTML = 'Alt';
        document.getElementsByClassName('newBranch2'    )[0].innerHTML = 'Ctrl';
        
        document.getElementsByClassName('treeRightCtrl1')[0].innerHTML = 'Shift';
        document.getElementsByClassName('treeRightCtrl2')[0].innerHTML = 'Ctrl';
        
        document.getElementsByClassName('treeAcross1'   )[0].innerHTML = 'Alt';
        document.getElementsByClassName('treeAcross2'   )[0].innerHTML = 'Ctrl';
    }


    const keys = document.getElementsByClassName('shortcutKey');

    for (const key of keys)
    {
             if (key.innerHTML == 'Ctrl' ) key.innerHTML = osCtrl (false);
        else if (key.innerHTML == 'Shift') key.innerHTML = osShift(false);
        else if (key.innerHTML == 'Alt'  ) key.innerHTML = osAlt  (false);
    }
}



function showKeyboardPanel()
{
    setCurrentKeyboardTab(0);

    keyboardPanel.style.display = 
        keyboardPanel.style.display != 'block'
        ? 'block'
        : 'none';
}



function hideKeyboardPanel()
{
    keyboardPanel.style.display = 'none';
}



function setCurrentKeyboardTab(tab)
{
    currentKeyboardTab = tab;

    for (let i = 0; i < keyboardPanelTabs.children.length; i++)
    {
        keyboardPanelTabs.children[i].style.background = i == currentKeyboardTab ? '#1E1E1E' : 'none';
        keyboardPanelTabs.children[i].style.boxShadow  = i == currentKeyboardTab ? '0 0 0 0.5px #ffffff2b' : 'none';

        keyboardPanelContent.children[i].style.display = i == currentKeyboardTab ? 'flex' : 'none';
    }
}


var loadRestartTimer = -1;



function initLoadingOverlay()
{
    btnLoadingRestart .style.display = 'none';
    btnLoadingRestart.addEventListener('click', () => uiRestartGenerator(true));
}



function restartLoadingTimer()
{
    if (loadRestartTimer > -1) 
        clearTimeout(loadRestartTimer);

    loadRestartTimer = setTimeout(() => 
    {
        btnLoadingRestart.style.display = 'inline-block';
        loadRestartTimer = -1;
    }, 
    5000);
}


var uiFigMessagePosted = false;



// --> from Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = e =>
{
    let msg = JSON.parse(e.data.pluginMessage);


    if (   msg.cmd == 'uiForwardToGenerator'
        || msg.cmd == 'uiEndFigMessage')
    {
        if (settings.logThreadMessages)
            logFigToUi(msg);
    }
    else if (msg.cmd == 'uiReturnFigGetLocalData'
          || msg.cmd == 'uiReturnFigGetPageData')
    {
        if (settings.logDataMessages)
            logFigToUi(msg);
    }
    else 
        if (settings.logMessages)
            logFigToUi(msg);


    switch (msg.cmd)
    {
        case 'uiForwardToGenerator':              uiPostMessageToGenerator         (msg.msg);           break;
       
        case 'uiStylePropertyChange':             uiStylePropertyChange            (msg);               break;
        case 'uiStyleDelete':                     uiStyleDelete                    (msg);               break;
                   
        case 'uiEndFigMessage':                   uiEndFigMessage                  (msg.msgCmd);        break;
                                           
        case 'uiReturnFigStartGenerator':         uiReturnFigStartGenerator        (msg);               break;
                                                    
        case 'uiReturnFigLoadNodesAndConns':      uiReturnFigLoadNodesAndConns     (msg);               break;
                                                    
        case 'uiReturnFigGetLocalData':           uiReturnFigGetLocalData          (msg);               break;
        case 'uiReturnFigGetPageData':            uiReturnFigGetPageData           (msg);               break;
                                                   
        case 'uiReturnFigResizeWindow':           uiReturnFigResizeWindow          ();                  break;
                           
        case 'uiReturnFigGetAllLocalColorStyles': uiReturnFigGetAllLocalColorStyles(msg);               break;
        case 'uiReturnGetAllLocalTemplateNames':  uiReturnGetAllLocalTemplateNames (msg.templateNames); break;
        
        case 'uiReturnFigGetMousePosition':       uiUpdateWindowStartRect          (msg);               break;

        case 'uiSetStyleId':                      uiSetStyleId                     (msg);               break;
        case 'uiHideClearUndoWarning':            uiHideClearUndoWarning           ();                  break;

        case 'uiUpdateZoom':                      uiUpdateZoom                     (msg.zoom);         break;

        case 'uiUpdateGroupBounds':               uiUpdateGroupBounds              (msg);              break;
    }
};



function logFigToUi(msg)
{
    let _msg = msg.cmd;

    if (msg.cmd == 'uiEndFigMessage')
        _msg += ': ' + msg.msgCmd;

    console.log('%cFIG '+_msg+' --► UI', 'background: #08f; color: white;');
}

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

function uiPostMessageToFigma(msg)
{
    uiFigMessagePosted = true;
    parent.postMessage({pluginMessage: JSON.stringify(msg)}, '*');

    
    if (   msg.cmd == 'figGetLocalData'
        || msg.cmd == 'figSetLocalData'
        || msg.cmd == 'figGetPageData'
        || msg.cmd == 'figSetPageData')
    {
        if (settings.logDataMessages)
            logUiToFig(msg);
    }
    else 
        if (settings.logMessages)
            logUiToFig(msg);
}



function logUiToFig(msg)
{
    console.log('%c%s FIG ◄-- UI ' + msg.cmd, 'background: #bef; color: black;', '\n            ');    
}



function uiQueueMessageToFigma(msg)
{
    uiFigMessages.push(msg);
    uiPostNextMessageToFigma();
}



function uiPostNextMessageToFigma()
{
    if (   !isEmpty(uiFigMessages)
        && !uiFigMessagePosted)
    {
        let msg = uiFigMessages.shift();


        if (   msg.cmd == 'figResizeWindow'
            || msg.cmd == 'figSetWindowRect')
        {
            // move along the queue since only the last message is important
            while (!isEmpty(uiFigMessages)
                &&  uiFigMessages[0].cmd == msg.cmd)
                msg = uiFigMessages.shift();
        }


        uiPostMessageToFigma(msg);    
    }
}



function uiEndFigMessage(msgCmd)
{
    uiFigMessagePosted = false;

    //if (msgCmd == 'figUpdateObjectsAndStyles')
    //{
        uiPostMessageToGenerator({
            cmd:      'genEndFigMessage',
            msgCmd:    msgCmd });
    //}

    uiPostNextMessageToFigma();
}

///////////////////////////////////////////////////////////////////////////////////////////////////



//                                                                               from Generator <--
///////////////////////////////////////////////////////////////////////////////////////////////////

generator.onmessage = function(e)
{
    //console.log('e =', e);
    const msg = JSON.parse(e.data);


    if (   msg.cmd == 'uiForwardToFigma'
        || msg.cmd == 'uiEndGenMessage')
    {
        if (settings.logThreadMessages)
            logGenToUi(msg);
    }
    else 
        if (settings.logMessages)
            logGenToUi(msg);


    switch (msg.cmd)
    {
        case 'uiEndGenMessage': uiEndGenMessage(); break;
        
        case 'uiEndRequest':    uiEndRequest(msg.requestId); break;

        case 'uiUpdateValuesAndObjects': 
            uiUpdateValuesAndObjects(
                parseInt(msg.requestId), 
                msg.actionId, 
                msg.updateNodeId, 
                msg.updateParamId, 
                msg.values, 
                msg.objects, 
                msg.styles,
                msg.updatedNodes,
                msg.totalNodes,
                msg.isFirstChunk,
                msg.isLastChunk,
                msg.save);  
                
            break;
        
        case 'uiInitNodeProgress':   nodeFromId(msg.nodeId).initProgress();      break;
        case 'uiUpdateNodeProgress': nodeFromId(msg.nodeId).updateProgress(msg); break;
        case 'uiEndNodeProgress':    nodeFromId(msg.nodeId).endProgress();       break;

        case 'uiInitGlobalProgress': uiInitGlobalProgress(msg.requestId);        break;
        case 'uiEndGlobalProgress':  uiEndGlobalProgress();                      break;
  
        case 'uiGetValue':           uiGetValue(msg.key);                        break;
        
        case 'uiForwardToFigma':     uiPostMessageToFigma(msg.msg);              break;
    }
};



function logGenToUi(msg)
{
    let _msg = msg.cmd;

    if (msg.cmd == 'uiEndGenMessage')
        _msg += ': ' + msg.msgCmd;

    console.log('%c%sUI ◄-- GEN '+_msg, 'background: #ca0; color: white;', '\n');
}



function uiEndGenMessage()
{
    genMessagePosted = false;
    uiPostNextMessageToGenerator();
}

///////////////////////////////////////////////////////////////////////////////////////////////////



//                                                                                 to Generator -->
///////////////////////////////////////////////////////////////////////////////////////////////////

function uiQueueMessageToGenerator(msg)
{
    genMessages.push(msg);
    
    if (!genMessagePosted)
        uiPostNextMessageToGenerator();
}



function uiPostNextMessageToGenerator()
{
    if (isEmpty(genMessages))
        return;


    let msg = genMessages[0];
    
    if (msg.cmd == 'genRequest')
    {
        // move along the queue since only the last message is important
        while (genMessages.length > 1
            && genMessages[1].cmd        == msg.cmd
            && genMessages[1].request[3] == msg.request[3]
            && genMessages[1].request[4] == msg.request[4])
        {
            genMessages.shift();
            msg = genMessages[0];
        }
    }

    
    if (!genMessagePosted)
    {
        genMessages.shift();
        uiPostMessageToGenerator(msg);

        genMessagePosted = true;
    }
}



function uiPostMessageToGenerator(msg)
{
    generator.postMessage(JSON.stringify(msg));
    
    
    if (      settings.logThreadMessages
        && msg.cmd == 'genEndUiMessage'
        && msg.cmd == 'genEndFigMessage'
     ||    settings.logMessages
        && msg.cmd != 'genEndUiMessage'
        && msg.cmd != 'genEndFigMessage')
        console.log('%c%s UI '+msg.cmd+' --► GEN', 'background: #ffb; color: black;', '\n            ');
}

///////////////////////////////////////////////////////////////////////////////////////////////////


function setCursor(cursor, forceAsync = true)
{
    document.body.style.cursor = cursor;
    if (forceAsync) setTimeout(null, 0);
}



function setAutoCursor()
{
    if (graphView.zoomSelecting)
        setCursor(graphView.altDown 
                ? zoomOutCursor 
                : zoomInCursor);
    else if (graphView.spaceDown
          || panMode
          || graphView.panning)
        setCursor(panCursor);
    else
        setCursor('default'); // 'auto');
};


var nextRequestId   =  0;
var lastRequestedId = -1;

var curRequestId    = null;



function pushUpdate(action, nodes, save = true)
{
    pushUpdateFromParam(action, nodes, null, save);
}



function pushUpdateFromParam(action, nodes, param, save = true)
{
    // first check if any nodes to the left are uncached
    // and replace in update array as necessary

    for (let i = nodes.length-1; i >= 0; i--)
    {
        const node               = nodes[i];
        const uncachedInputNodes = node.getUncachedInputNodes();
        
        if (!isEmpty(uncachedInputNodes))
        {
            removeFromArray(nodes, node);

            pushUnique(nodes, uncachedInputNodes);

            for (const uncached of uncachedInputNodes)
                pushUnique(nodes, getTerminalsAfterNode(uncached));

            param = null;
        }
    }

    
    const set =
          ((settings.showAllColorSpaces  ? 1 : 0) << 0)
        | ((settings.logRequests         ? 1 : 0) << 1)
        | ((settings.showTransformPoints ? 1 : 0) << 2);


    if (action)
        actionManager.updateActions.push(action);
        

    if (!curRequestId)
    {
        lastRequestedId = nextRequestId++;
        curRequestId    = lastRequestedId;
    }
    
    const request = 
    [
        curRequestId,
        action ? action.id : -1,
        set.toString()
    ];




    if (param) request.push(param.node.id, param.id);
    else       request.push(NULL, NULL);


    request.push(viewportZoom);


    if (   !graphView.loadingNodes
        && !graphView.pastingNodes
        && !graphView.restoringNodes)
        nodes.forEach(n => n.invalidate());


    const terminals = [];
    nodes.forEach(n => pushUnique(terminals, getTerminalsAfterNode(n)));

    
    const uncachedInputNodes = [];
    terminals.forEach(n => pushUnique(uncachedInputNodes, n.getUncachedInputNodes()));
    uncachedInputNodes.forEach(n => pushUnique(terminals, getTerminalsAfterNode(n)));

    const progressNodes = [];
    nodes.forEach(n => pushUnique(progressNodes, getProgressNodesAfterNode(n)));


    const gen = createGenObject(
        param ? param.node : null,
        terminals);


    for (const node of terminals)
    {
        if (gen.passedNodes.includes(node))
            continue;

        request.push(...getNodeRequest(node, gen));
        
        pushUnique(gen.passedNodes, node);
    }


    for (const node of gen.paramNodes)
    {
        if (   !terminals.includes(node)
            && !gen.passedNodes.includes(node))
            request.push(...getNodeRequest(node, gen));
    }


    if (settings.logRawRequests)
        console.log(
            '%c%s%s', 
            'background: #60aa60; color: #cfd', 
            'raw request = ', 
            request.toString());


    uiQueueMessageToGenerator({
        cmd:     'genRequest',
        request:  request,
        save:     save
    });
}



function pushInputOrParam(input, gen)
{
    if (   input.connectedOutput.param
        && gen.markParams
        && gen.scope.at(-1).nodeId != input.connectedOutput.node.id)
    {
        pushUnique(gen.paramNodes, input.connectedOutput.node);

        return [ PARAM,
                 input.connectedOutput.types[0],
                 input.connectedOutput.node.id,
                 input.connectedOutput.param.id ];
    }
    else
        return input.connectedOutput.genRequest(gen);
}



function getNodeRequest(node, gen)
{
    const request = [];


    if (!isEmpty(node.headerOutputs))
    {
        node.headerOutputs
            .forEach(o =>
            {
                const _r = o.genRequest(gen);
                const  r = [..._r];
                request.push(...r);
            });
    }
    else
    {
        request.push(...node.genRequest(gen));
    }


    return request;
}



function uiEndRequest(requestId)
{
    //consoleAssert(curRequestId == requestId);
    curRequestId = null;
}


var searchIndex = -1;



function showSearchBox()
{
    hideAllMenus();

    search.style.display = 'block';

    search.oldPan  = clone(graph.currentPage.pan);
    search.oldZoom = graph.currentPage.zoom;

    searchIcon.innerHTML = iconSearch;

    searchText.value = '';
    searchIndex      = -1;

    searchText.focus();
    searchText.select();

    initSearchBox('');
}



function hideSearchBox()
{
    search.style.display  = 'none';
    searchItems.innerHTML = '';

    if (graphView._soloNode)
        graphView.unsoloNode();

    // if (   search.oldPan
    //     && search.oldZoom)
    // {
    //     graph.currentPage.setPanAndZoom(
    //         search.oldPan, 
    //         search.oldZoom);

    //     search.oldPan  = null;
    //     search.oldZoom = null;
    // }
}



function initSearchBox(query)
{
    search.found = [];
    search.nodes = false;


    if (query != '')
    {
        if (query.charAt(0) == '/')
        {
            query = query.substring(1);
            search.nodes = true;

            for (const node of graph.currentPage.nodes)
            {
                if (node.name.toLowerCase().includes(query.toLowerCase()))
                {
                    node.foundExact = 0;
                    search.found.push(node);
                }
                else if (includesSimilar(node.name.toLowerCase(), query.toLowerCase(), 1))
                {
                    node.foundExact = 1;
                    search.found.push(node);
                }
            }
        }
        else
        {
            search.nodes = false;

            for (const menu of menuBarMenus)
            {
                for (const item of menu.items)
                {
                    if (   item.name.toLowerCase().includes(query.toLowerCase())
                        && item.callback)
                    {
                        item.foundExact = 0;
                        search.found.push(item);
                    }
                    else if (includesSimilar(item.name.toLowerCase(), query.toLowerCase(), 1)
                          && item.callback)
                    {
                        item.foundExact = 1;
                        search.found.push(item);
                    }
                }
            }
        }


        search.found.sort((_a, _b) => 
        {
            const a  = _a.name.toLowerCase().replaceAll(' . . .', '').replaceAll('. . . ', '').replaceAll('...', '');
            const b  = _b.name.toLowerCase().replaceAll(' . . .', '').replaceAll('. . . ', '').replaceAll('...', '');

            const ea = _a.foundExact;
            const eb = _b.foundExact;

            const qa = a.indexOf(query);
            const qb = b.indexOf(query);

            if (ea < eb) return -1;
            if (ea > eb) return  1;

            if (qa < qb) return -1;
            if (qa > qb) return  1;
 
            if (a  < b ) return -1;
            if (a  > b ) return  1;

            return 0;
        });
    }

    
    searchItems.innerHTML = '';

    searchIndex = search.found.length > 0 ? 0 : -1;


    for (let i = 0; i < search.found.length; i++)
    {
        const item   = search.found[i];

        const result = createDiv('resultItem'  );
        const icon   = createDiv('resultIcon'  );
        const legend = createDiv('resultLegend');


        result.innerHTML = 
            search.nodes 
            ? item.name 
            : item.searchName;


        icon.innerHTML = 
            darkMode
            ? item.icon
            : item.icon.replaceAll('white', 'black');

        
        let type = null;

             if (item.createType && item.createType != '') type = item.createType;
        else if (item.type       && item.type       != '') type = item.type;

        if (type) legend.style.background = rgb2style(rgbFromType(type, true));


        if (!search.nodes)
            result.callback = item.callback;


        result.index = i;

        result.appendChild(legend);
        result.appendChild(icon);
        
        result.addEventListener('click', e => selectSearchItem(result, e.shiftKey, getCtrlKey(e), e.altKey));

        result.addEventListener('pointerenter', e =>
        {
            searchIndex = result.index;
            updateSearchBox();
        });

        searchItems.appendChild(result);
    }
     

    searchResults.style.paddingBottom = 
           search.found.length > 0 
        && search.found.length < 10
        ? '8px'
        : 0;

    if (   query.length == 0
        || search.found.length > 0)
    {
        search.style.height = Math.min(
            searchText.offsetHeight + searchResults.offsetHeight,
            graphView.div.offsetHeight - search.offsetTop - 100);

        noSearchResults.style.display = 'none';
    }
    else
    {
        search.style.height = searchText.offsetHeight + 40;
        noSearchResults.style.display = 'inline';
    }


    updateSearchBox();
}



function selectSearchItem(item, shift, ctrl, alt)
{
    if (!shift) 
        hideSearchBox();

    const e = 
    {
        shiftKey: shift,
        ctrlKey:  ctrl,
        altKey:   alt
    };

    if (item)
    {
        if (item.callback)
            item.callback(e);
        else
        {
            if (!shift)
                graphView.selectedNodes = [];

            search.found[searchIndex].setSelected(true);
        }
    }

    searchIndex = -1;
}



function updateSearchBox()
{
    for (let i = 0; i < searchItems.children.length; i++)
    {
        const item = searchItems.children[i];

        item.style.background = 
            item.index == searchIndex
            ? (darkMode ? '#383838' : '#f5f5f5')
            : 'transparent';
    }


    const vpos = searchIndex * 32;

    if (vpos < searchResults.scrollTop)
        searchResults.scrollTop = vpos;

    if (vpos > searchResults.scrollTop + searchResults.offsetHeight - 32)
        searchResults.scrollTop = vpos + 32 - searchResults.offsetHeight;


    if (   search.nodes
        && searchIndex > -1)
    {
        graphView.soloNode(search.found[searchIndex]);
        graphView.zoomToNodes([search.found[searchIndex]], false, search.offsetTop + search.offsetHeight)
    }
}



searchText.addEventListener('keydown', e =>
{
    e.stopPropagation();

    if (e.code == 'Escape')
        hideSearchBox();

    else if (e.code == 'ArrowDown')
    {
        searchIndex =
            searchIndex < searchItems.children.length-1
            ? searchIndex + 1
            : 0;

        e.preventDefault();
        updateSearchBox();
    }

    else if (e.code == 'ArrowUp')
    {
        searchIndex = 
            searchIndex > 0
            ? searchIndex - 1
            : searchItems.children.length-1;

        e.preventDefault();
        updateSearchBox();
    }

    else if (   e.code == 'Enter' 
             || e.code == 'NumpadEnter')
        selectSearchItem(searchItems.children[searchIndex], e.shiftKey, getCtrlKey(e), e.altKey)
});



searchText.addEventListener('input', e =>
{
    initSearchBox(searchText.value);
});


function checkTrialExists()
{
    return postToServer(
        {
            action: 'getTrialExists',
            userId:  currentUser.id
        })
        .then(response =>
        { 
            consoleAssert(response, 'invalid response from server @ checkTrialExists()');
            return response ? response.result : false;
        })
        .catch(e =>
        {
            console.error(e);
            throw e;
        });
}



function checkSubActive()
{
    return postToServer(
        {
            action: 'getSubActive',
            userId:  currentUser.id
        })
        .then(response => 
        {
            consoleAssert(response, 'invalid response from server @ checkSubActive()');
            return response ? response.result : false;
        })
        .catch(e =>
        {
            console.error(e);
            throw e;
        });
}



function checkSubOrTrialActive()
{
    return postToServer(
        {
            action: 'getSubOrTrialActive',
            userId:  currentUser.id
        })
        .then(response => 
        {
            consoleAssert(response, 'invalid response from server @ checkSubOrTrialActive()');
            return response ? response.result : false;
        })
        .catch(e =>
        {
            console.error(e);
            throw e;
        });
}



function checkRemainingTrialDays()
{
    return postToServer(
        {
            action: 'getRemainingTrialDays',
            userId:  currentUser.id
        })
        .then(response => 
        {
            consoleAssert(response, 'invalid response from server @ checkRemainingTrialDays()');
            return response ? response.result : -1;
        })
        .catch(e =>
        {
            console.error(e);
            throw e;
        });
}



function checkLastSub()
{
    return postToServer(
        {
            action: 'getLastSub',
            userId:  currentUser.id
        })
        .then(response =>
        {
            if (   response.daysLeft != undefined
                && response.tier     != undefined)
                return response;
            else
                return null;
        })
        .catch(e =>
        {
            console.error(e);
            throw e;
        });
}



function startFreeTrial()
{
    uiSetLocalData('eulaRead', 'true');

    
    postToServer(
    {
        action: 'createTrial',
        userId:  currentUser.id
    })
    .then(response =>
    {
        consoleAssert(response, 'invalid response from server @ createTrial()');

        if (response.result)
            initGenerator();
    })
    .catch(e =>
    {
        console.error(e);
        throw e;
    });
}



function postToServer(cmd)
{
    return fetch(
        'https://brainshift.design/generator/license/',
        {
            method:  'POST',
            headers: { 'Content-Type': 'application/json' },
            body:    JSON.stringify(cmd)
        })
        .then(response => 
        { 
            if (!response.ok)
            {
                uiNotify(response.status, {error: true});
                throw new Error('fetch() failed with status ' + response.status);
            }
            
            return response.json();
        })
        .then(json => { return json; })
        .catch(e =>
        {
            console.error(e);
            throw e;
        });
}






function      uiGetLocalData(key)        { uiQueueMessageToFigma({ cmd:      'figGetLocalData', key: key               }); }
function      uiSetLocalData(key, value) { uiQueueMessageToFigma({ cmd:      'figSetLocalData', key: key, value: value }); }
function    uiClearLocalData(key)        { uiQueueMessageToFigma({ cmd:      'figSetLocalData', key: key, value: ''    }); }
function uiClearAllLocalData(key)        { uiQueueMessageToFigma({ cmd: 'figClearAllLocalData', key: key, value: ''    }); }

function       uiGetPageData(key)        { uiQueueMessageToFigma({ cmd:       'figGetPageData', key: key               }); } 
function       uiSetPageData(key, value) { uiQueueMessageToFigma({ cmd:       'figSetPageData', key: key, value: value }); }
function     uiClearPageData(key)        { uiQueueMessageToFigma({ cmd:       'figSetPageData', key: key, value: ''    }); }



// function saveToLocalFile(filename, str) 
// {
//     const link = document.createElement('a');
//     link.style.display = 'none';
    
//     link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(str));
//     link.setAttribute('download', filename);
    
//     document.body.appendChild(link);
//     link.click();
//     document.body.removeChild(link);
// }



///////////////////////////////////////////////////////////////////////////////////////////////////
   


async function uiReturnFigGetLocalData(msg)
{
    switch (msg.key)
    {
        case 'minZoomForParams':
            if (!isNaN(msg.value))
                updateSetting(msg.key, parseFloat(msg.value));
    
            break;

        case 'dataMode':
        case 'debugMode':

        case 'enableZoomedOutParams':
        case 'showPages':
        case 'showNodeIcons':
        case 'showBoolValues':
        case 'showColorLegendInMenus':
        case 'showOperationResults':
        case 'showClearUndoWarning':
        case 'showDebugMenu':

        case 'showNodeId':       
        case 'showTransformPoints':       
        case 'enableAsserts':       

        case 'showTooltipLongText':
        case 'showTooltipColorInterpolation':
        case 'showTooltipColorBlindness':
        case 'showTooltipColorContrast':

        //case 'enableBetaFeatures':       

        case 'logThreadMessages':      
        case 'logDataMessages':      
        case 'logMessages':     

        case 'logActions':       

        case 'logLoading':       
        case 'logRequests':      
        case 'logValueUpdates':  
        case 'logObjectUpdates': 
        case 'logStyleUpdates': 

        case 'logRawLoadPages':    
        case 'logRawLoadNodes':    
        case 'logRawLoadConnections':    

        case 'logRawSavePages': 
        case 'logRawSaveNodes': 
        case 'logRawSaveConnections': 

        case 'logRawRequests':   
        case 'logRawValues':     
            updateSettingAndMenu(
                msg.key, 
                msg.value, 
                msg.value 
                    ? parseBool(msg.value) 
                    : false,
                false); 

            break;

        case 'showWhatsNew':
            if (  !msg.value
                || parseInt(msg.value) < generatorVersion)
                showWhatsNewDialog();

            break;
    }


    if (    msg.key == 'dataMode'
        && !generatorStarted)
    {
        if (settings.dataMode)
        {
            dataModeView.style.display = 'block';
            initDataModeMenus();
        }
        else
            initGeneratorMenus();
     
        
        onClassChange(document.childNodes[0], () =>
        { 
            initThemeColors();

            if (!settings.dataMode)
            {
                graph.nodes.forEach(n => n.updateNode());
                graphView.updateNodeWireTransforms(graph.nodes);
            }
        });
    }


    if (!settings.dataMode)
    {
        // if (msg.key == 'enableBetaFeatures')
        //     enableFeatures(true, settings.enableBetaFeatures); 

        if (msg.key == 'showDebugMenu')
            updateMenuItemShowDebugMenu();
    }

    
    if (   msg.key == 'logLoading'
        && settings.logLoading)
        uiLogAllSavedNodesAndConns();
}



function uiReturnFigGetPageData(msg)
{
    // switch (msg.key)
    // {
    // }
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function uiReturnFigLoadNodesAndConns(msg)
{
    if (settings.logRawLoadNodes)
    {
        for (const json of msg.nodeJson)
        {
            console.log(
                '%cnodes JSON = \n%s', 
                'background: #fed; color: black;',
                json.replaceAll('\\n', '\n')
                    .replaceAll('\\"', '"'));
        }
    }


    if (settings.logRawLoadConnections)
    {
        for (const json of msg.connJson)
        {
            console.log(
                '%cconnections JSON = %s', 
                'background: #fed',
                json.replaceAll('\\n', '\n')
                    .replaceAll('\\"', '"'));
        }
    }

    
    const _showAllColorSpaces = msg.showAllColorSpaces;


    updateSettingAndMenu(
        'showAllColorSpaces',
        _showAllColorSpaces, 
        _showAllColorSpaces ? parseBool(_showAllColorSpaces) : false,
        false); 


    graphView.loadingNodes   = true;
    graphView.canUpdateNodes = false;


    if (!isEmpty(msg.pageKeys))
    {
        if (settings.logRawLoadPages)
        {
            for (const json of msg.pageJson)
            {
                console.log(
                    '%cpages JSON = %s', 
                    'background: #fee; color: black;',
                    json.replaceAll('\\n', '\n')
                        .replaceAll('\\"', '"'));
            }
        }


        const pages = [];

        for (let i = 0; i < msg.pageKeys.length; i++)
        {
            const page = new GraphPage();
            page.load(msg.pageJson[i]);
            pages.push(page);
        }

        
        for (const id of msg.pageOrder)
            graph.addPage(pages.find(p => p.id == id));


        //console.log('msg.currentPageId =', msg.currentPageId);
        graph.pageIndex = graph.pages.findIndex(p => p.id == msg.currentPageId);

        if (graph.pageIndex < 0) // for cases where the pages were corrupted
            graph.pageIndex = 0; // because of a crash or a bug
    }
    else
    {
        graph.createPage('');
        graph.updateSavedPages();
    }



    if (!settings.dataMode)
        graphView.updatePanAndZoom(true);


    let _pageKeys = msg.pageKeys;
    let _pages    = msg.pageJson;

    let _nodeKeys = msg.nodeKeys;
    let _nodes    = msg.nodeJson;

    let _connKeys = msg.connKeys;
    let _conns    = msg.connJson;

    
    const _p = [];
    const _n = [];
    const _c = [];

    for (let i = 0; i < _pages.length; i++) _p.push({key: _pageKeys[i], value: _pages[i]});
    for (let i = 0; i < _nodes.length; i++) _n.push({key: _nodeKeys[i], value: _nodes[i]});
    for (let i = 0; i < _conns.length; i++) _c.push({key: _connKeys[i], value: _conns[i]});
    

    _n.sort((a, b) => a.value.z - b.value.z);


    if (settings.dataMode)
    {
        menuBar.style.display = 'none';

        loadNodesAndConnsData(_p, _n, _c);
    }
    else
    {
        _nodes = _nodes.map(n => JSON.parse(n));
        _conns = _conns.map(c => JSON.parse(c));
            
        graph.clear();

        loadNodesAndConnsAsync(_nodes, _conns, setLoadingProgress);
    }
}



function setLoadingProgress(progress)
{
    if (graphView.loadingNodes) 
        progress *= 0.7;

    loadingProgress.style.width = (progress * 100) + '%';
}



function loadNodesAndConnsAsync(_nodes, _conns, setProgress)
{
    loadingProgress.style.width   = 0;
    loadingOverlay .style.display = 'block';


    let promise = Promise.resolve([]);


    _nodes = _nodes.sort((a, b) => a.type == GROUP_NODE && b.type != GROUP_NODE);


    const chunkSize = 10; // nodes

    for (let i = 0; i < _nodes.length; i += chunkSize)
    {
        restartLoadingTimer();
        
        promise = promise.then(nodes => 
        {
            const res = resolveNodes(
                _nodes, 
                i, 
                Math.min(i + chunkSize, _nodes.length), // exclusive
                nodes,
                false);

            setProgress(i / (_nodes.length + (_conns ? _conns.length : 0)));
            return res;
        });
    }

    promise.then(nodes => 
    {
        graph.addNodes(nodes, false, false);
        loadConnectionsAsync(_nodes, _conns, nodes, setProgress);    
    });
}



function loadConnectionsAsync(_nodes, _conns, loadedNodes, setProgress)
{
    let promise = Promise.resolve([]);


    if (_conns)
    {
        // variable inputs connections must be sorted by input index
        // as well as connection position left to right

        _conns.sort((c1, c2) => 
        {
            if (c1.inputNodeId != c2.inputNodeId ) return c1.inputNodeId < c2.inputNodeId ? -1 : 1;
            if (c1.inputId     != c2.inputId     ) return c1.inputId     < c2.inputId     ? -1 : 1;
            
            if (c1.inputNodeId == c2.outputNodeId) return -1;
            if (c2.inputNodeId == c1.outputNodeId) return  1;

            return 0;
        });
        

        // first resolve group parameter connections,
        // as they create inputs and outputs in other nodes
        
        restartLoadingTimer();


        const _paramConns = _conns.filter(c => 
               nodeFromId(c. inputNodeId) && nodeFromId(c. inputNodeId).type == GROUP_PARAM
            || nodeFromId(c.outputNodeId) && nodeFromId(c.outputNodeId).type == GROUP_PARAM);

        const _otherConns = _conns.filter(c => !_paramConns.includes(c));

        
        const chunkSize = 10; // connections

        for (let i = 0; i < _paramConns.length; i += chunkSize)
        {
            promise = promise.then(() => 
            {
                const res = resolveConnections(
                    _nodes,
                    _paramConns, 
                    i, 
                    Math.min(i + chunkSize, _paramConns.length)); // exclusive

                return res;
            });
        }

        for (let i = 0; i < _otherConns.length; i += chunkSize)
        {
            promise = promise.then(() => 
            {
                const res = resolveConnections(
                    _nodes,
                    _otherConns, 
                    i, 
                    Math.min(i + chunkSize, _otherConns.length)); // exclusive

                setProgress((_nodes.length + i) / nozero(_nodes.length + _otherConns.length * 19/20)); // the proportion is arbitrary
                return res;
            });
        }
    }


    promise.then(() => 
    {
        const updateNodes = [];
        
        finishLoadingNodes(_nodes, loadedNodes, updateNodes);
        finishLoading(_nodes);
        
        pushUpdate(null, updateNodes);
    });
}



function finishLoading(_nodes)
{
    if (isEmpty(_nodes))
    {
        graphView.creatingNodes  = false;
        graphView.pastingNodes   = false;
        graphView.loadingNodes   = false;
        graphView.restoringNodes = false;

        clearTimeout(loadRestartTimer);
        loadRestartTimer = -1;

        loadingOverlay.style.display = 'none';
    }


    graphView.canUpdateNodes = true;
    graphView.updateShowWires(false);

    generatorStarted = true;


    graphView.update();

    
    window.focus();
}



function finishLoadingNodes(_nodes, loadedNodes, updateNodes, duplicates = false)
{
    _nodes
        .filter(_n => _n.active)
        .map   (_n => nodeFromId(duplicates ? _n.newId : (pageIdFromPath(_n.id) == NULL ? makeNodePath(_n) : _n.id)))
            .forEach(n => n.makeActive());

    updateTerminalsAfterNodes(loadedNodes, updateNodes);
}



function resolveNodes(_nodes, first, last, nodes, pasting)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
                nodes.push(loadNode(_nodes[i], pasting));

            resolve(nodes);
        }));
}



function resolveConnections(nodes, _connections, first, last)
{
    _connections.sort((c1, c2) =>
    {
        if (c1.inputNodeId != c2.inputNodeId) return c1.inputNodeId - c2.inputNodeId;
        if (c1.inputId     != c2.inputId    ) return c1.inputId     - c2.inputId;
        //if (c1.outputOrder != c2.outputOrder) return c1.outputOrder - c2.outputOrder;
        return 0;
    });

    // for (const conn of _connections)
    //     console.log('conn =', getConnectionString(
    //         conn.outputNodeId,
    //         conn.outputId,
    //         conn.outputOrder,
    //         conn.inputNodeId,
    //         conn.inputId,
    //         false));


    return new Promise(resolve => 
        //requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
            {
                const _conn = _connections[i];

                const outputNode = nodes.find(n => (n.newId ?? n.id) == _conn.outputNodeId);
                const  inputNode = nodes.find(n => (n.newId ?? n.id) == _conn. inputNodeId);


                const strConn = connToString(_conn);

                if (!outputNode)
                { 
                    uiError(
                        '(no output) Cannot connect  ' + strConn + ',  \'' + _conn.outputNodeId + '\' not found', 
                        {
                            buttonText:   'Remove connection',
                            buttonAction: 'removeConnection,' + getStorageConnKey(_conn)
                        });

                    continue; 
                }

                if (!inputNode) 
                { 
                    uiError(
                        '(no input) Cannot connect  ' + strConn + ',  \'' + _conn.inputNodeId + '\' not found',
                        {
                            buttonText:   'Remove connection',
                            buttonAction: 'removeConnection,' + getStorageConnKey(_conn)
                        });
 
                    continue; 
                }


                parseConnectionJsonAndConnect(_conn, false);
            }

            resolve();
        });
        // /);
}



function loadNodes(data, pasting)
{
    const nodes = [];
   
    for (let i = 0; i < data.nodes.length; i++)
    {
        const node = loadNode(data.nodes[i], pasting);
        nodes.push(node);
    }

    return nodes;
}



function loadNode(_node, pasting)
{
    // replace legacy
    // if (_node.type == 'EXPAND') _node.type = CONDENSE;
    // if (_node.type == 'DISTR' ) _node.type = NUMBER_RANGE;


    const node = createNode(_node.type);
    node.div.style.display = 'none';


    node.loadFromParsedJson(_node, pasting);

    if (node.pageId == NULL)
        node.id = makeNodePath(node);

        
    node.setPosition(
        parseFloat(_node.x), 
        parseFloat(_node.y),
        false);

        
    return node;
}



function parseConnectionsAndConnect(data, pasteConnected, setProgress = null)
{
    data.connections.sort((c1, c2) =>
    {
        if (c1.outputOrder != c2.outputOrder) return c1.outputOrder - c2.outputOrder;
        if (c1.inputNodeId != c2.inputNodeId) return c1.inputNodeId - c2.inputNodeId;
        if (c1.inputId     != c2.inputId    ) return c1.inputId     - c2.inputId;
        return 0;
    });

    
    const connections = [];
    
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];
        
        if (      data.nodes.find(n => (n.newId ?? n.id) == _conn.outputNodeId)
               && data.nodes.find(n => (n.newId ?? n.id) == _conn. inputNodeId)
            || pasteConnected)
        {
            parseConnectionJsonAndConnect(_conn, pasteConnected);
            connections.push(_conn);
        }

        if (setProgress)
            setProgress(((data.nodes.length + i) / (data.nodes.length + data.connections.length)));
    }


    return connections;
}



// function uiSaveGraphView()
// {
//     uiSetPageData(currentUser.id + ',graphView', graphView.toJson());
// }



function dataColorToJson(color, nTab)
{
    let   pos = ' '.repeat(nTab);
    const tab = HTAB;

    let json =
          pos + tab + '[\n'
        + pos + tab + tab + '"' + color[0] +'",\n'
        + pos + tab + tab +       color[1] + ',\n'
        + pos + tab + tab +       color[2] + ',\n'
        + pos + tab + tab +       color[3] +  '\n'
        + pos + tab + ']';

    return json;
}


var tooltipTimer    = -1;
var tooltipOutTimer = -1;

var inTooltip = null;


var currentTooltipSource = null;
var currentTooltip       = null;

    

function createTooltipSrc(source, ref, getTooltip, canShow = null)
{
    source.addEventListener('pointerenter', () =>
    {
        if (tooltipTimer >= 0) 
            clearTimeout(tooltipTimer);


        if (    tooltipTimer < 0
            &&  graph.currentPage.zoom >= settings.minZoomForParams
            && !graphView.soloMode
            && (!canShow || canShow()))
        {
            tooltipTimer = setTimeout(() =>
            {
                const tooltip = getTooltip();

                if (tooltip) 
                    showTooltip(ref, tooltip);

                tooltipTimer = -1;
            }, 
               currentTooltip 
            && currentTooltip != getTooltip() 
            ? 0 
            : 1000);
        }
    });
      
    
    source.addEventListener('pointerleave', () =>
    {
        if (tooltipTimer >= 0)
        {
            clearTimeout(tooltipTimer);
            tooltipTimer = -1;
        }
    
        
        if (tooltipOutTimer >= 0)
            clearTimeout(tooltipOutTimer);
        
    
        tooltipOutTimer = setTimeout(() => 
        {
            if (currentTooltip) 
                hideTooltip(currentTooltip);
    
            currentTooltipSource = null;
    
            tooltipOutTimer      = -1;
        }, 
        400);
    });
}



function createTooltip(tooltip)
{
    tooltip.trap = false;
    

    tooltip.addEventListener('pointerenter', () => inTooltip = tooltip);
    tooltip.addEventListener('pointerleave', () => inTooltip = null   );


    hideTooltip(tooltip);
}



function createTooltipPointerTrap(tooltip)
{
    tooltip.addEventListener('pointerenter', e =>
    {
        //if (tooltipOutTimer >= 0)
        //{
            clearTimeout(tooltipOutTimer);
            tooltipOutTimer = -1;
        //}
    });

    
    tooltip.addEventListener('pointerleave', e =>
    {
        // if (tooltipOutTimer < 0)
        //     hideTooltip(tooltip);

        if (tooltipTimer >= 0)
        {
            clearTimeout(tooltipTimer);
            tooltipTimer = -1;
        }


        tooltipOutTimer = setTimeout(() => 
        {
            if (currentTooltip) 
                hideTooltip(currentTooltip);

            currentTooltipSource = null;

            tooltipOutTimer      = -1;
        }, 
        400);
    });
}



function showTooltip(source, tooltip)
{
    if (!isEmpty(currentMenus))
        return;

        
    if (   currentTooltip
        && currentTooltip != tooltip)
        hideTooltip(currentTooltip);


    tooltip     .style.display = 'block';
    tooltip     .style.opacity = '100%';

    tooltipArrow.style.display = 'block';
    tooltipArrow.style.opacity = '100%';

    let srcRect = source.getBoundingClientRect();

    srcRect.y -= 5;


    const margin = 10;
 
    tooltip.style.left = Math.min(Math.max(
        margin, 
        srcRect.x + srcRect.width/2 - tooltip.offsetWidth/2), 
        graphView.div.offsetWidth - tooltip.offsetWidth - margin);

    tooltipArrow.style.left = srcRect.x + srcRect.width/2;// - tooltipArrow.offsetWidth/2;

    
    const graphHeight = graphView.div.offsetHeight - getTopHeight();


    let top = srcRect.y;

    if (srcRect.y + tooltip.offsetHeight > graphView.div.offsetHeight-8)
        top = getTopHeight() + Math.max(8, graphHeight - tooltip.offsetHeight);
        
    tooltip.style.top = top + srcRect.height + tooltipArrow.offsetHeight - 3;
    
    
    const ttRect = tooltip.getBoundingClientRect();

    
    if (ttRect.bottom > getTopHeight() + graphView.div.offsetHeight - 8)
    {
        let y = srcRect.y;

        tooltipArrow.style.borderColor = '#1e1e1e transparent transparent transparent';
        tooltipArrow.style.top         = y;

        tooltip.style.top = y - ttRect.height + 1;
    }
    else
    {
        tooltipArrow.style.borderColor = 'transparent transparent #1e1e1e transparent';
        tooltipArrow.style.top         = ttRect.y - tooltipArrow.offsetHeight + 1;
    }


    // const graphHeight = graphView.div.offsetHeight - getTopHeight();

    // if (top + tooltip.offsetHeight > graphView.div.offsetHeight-8)
    //     top = getTopHeight() + Math.max(8, graphHeight - tooltip.offsetHeight);

    // tooltip.style.top = top;

    
    currentTooltip = tooltip;
}



function hideTooltip(tooltip)
{
    tooltip     .style.display = 'none';
    tooltip     .style.opacity = '0%';

    tooltipArrow.style.display = 'none';
    tooltipArrow.style.opacity = '0%';

    clearTimeout(tooltipTimer);
    clearTimeout(tooltipOutTimer);

    tooltipTimer   = -1;
    currentTooltip = null;
}


function updateZoomTooltip()
{
    if (graph.currentPage.zoom < settings.minZoomForParams)
    {
        ttMinValueZoom.innerHTML =
              '<p style="margin-top: 1px; width: 100%; text-align: center; position: relative; left: -2px;">Zoom/view options</p>'
            + '<p style="margin-top: 1.25em">'
            + '    An outline around the zoom means<br/>'
            + '    that values are too small to adjust<br/>'
            + '    and nodes can only be moved.'
            + '</p>'
            + '<p style="margin-top: 1.25em">The threshold can be changed in the<br/>preferences menu.</p>';

        ttMinValueZoom.style.height = '130px';
    }
    else
    {
        ttMinValueZoom.innerHTML = 'Zoom/view options';
        ttMinValueZoom.style.height = '15px';
    }
}


// function initPermanentTooltip(tooltip)
// {
//     tooltip.addEventListener('pointerenter', e =>
//     {
//         e.preventDefault();
//         e.stopImmediatePropagation();

//         clearTimeout(tooltipOutTimer);
//         tooltipOutTimer = null;
//     });
    
    
    
//     tooltip.addEventListener('pointerleave', e =>
//     {
//         e.preventDefault();
//         e.stopImmediatePropagation();

//         if (!tooltipOutTimer)
//             hideTooltip(tooltip);
//     });
// }



function initTextTooltip(str)
{
    ttTextString.innerHTML = str;
}



createTooltip(ttText);
createTooltip(ttWcag2);
createTooltip(ttWcag3);
createTooltip(ttInterpolationSpace);
createTooltip(ttColorblind);

//createTooltipPointerTrap(ttText);
createTooltipPointerTrap(ttWcag2);
createTooltipPointerTrap(ttWcag3);
createTooltipPointerTrap(ttInterpolationSpace);
createTooltipPointerTrap(ttColorblind);



function createNode(nodeType, creatingButton = null, createdNodeId = -1, options = {})
{
    let node;
 
    switch (nodeType)
    {
        case NULL_NODE:               node = new OpNull();              break;
        case START:                   node = new OpStart();             break;
        case REPEAT:                  node = new OpRepeat();            break;
        case CACHE:                   node = new OpCache();             break;
        case FREEZE:                  node = new OpFreeze();            break;
        case TIMER:                   node = new OpTimer();             break;
        case VALUE_NAME:              node = new OpValueName();         break;

        case LIST:                    node = new OpList();              break;
        case CONDENSE:                node = new OpCondense();          break;
        case ITEMS:                   node = new OpItems();             break;
        case LIST_COUNT:              node = new OpListCount();         break;
        case SELECT:                  node = new OpSelect();            break;
        case CONTAINS:                node = new OpContains();          break;
        case IF_ELSE:                 node = new OpIfElse();            break;
        case SUBLIST:                 node = new OpSublist();           break;
        case UNIQUE:                  node = new OpUnique();            break;
        case REVERSE_LIST:            node = new OpReverseList();       break;
        case SORT:                    node = new OpSort();              break;
        case COLUMN:                  node = new OpColumn();            break;
        case CELL:                    node = new OpCell();              break;
        
        case DEFINE:                  node = new OpDefine();            break;
        case NUMBER_RANGE:            node = new OpRange();             break;
        case NUMBER_SEQUENCE:         node = new OpSequence();          break;
        case NUMBER_RANDOM:           node = new OpRandom();            break;
        case NUMBER_NOISE:            node = new OpNoise();             break;
        case NUMBER_PROBABILITY:      node = new OpProbability();       break;
        case NUMBER_ACCUMULATE:       node = new OpAccumulate();        break;

        case NUMBER:                  node = new OpNumber();            break;
        case NUMBER_SIGN:             node = new OpSign();              break;
        case NUMBER_ABSOLUTE:         node = new OpAbsolute();          break;
        case NUMBER_ROUND:            node = new OpRound();             break;
        case NUMBER_MINMAX:           node = new OpMinMax();            break;
        case NUMBER_LIMITS:           node = new OpLimits();            break;
        case NUMBER_CONSTANT:         node = new OpConstant();          break;
        case NUMBER_DATETIME:         node = new OpDateTime();          break;

        case NUMBER_INTERPOLATE:      node = new OpInterpolate();       break;
        case NUMBER_TO_TEXT:          node = new OpNumberToText();      break;
        case NUMBER_SOLVE:            node = new OpSolve();             break;
        case NUMBER_ANIMATE:          node = new OpAnimate();           break;

        case NUMBER_MATH:             node = new OpMath();              break;
        case NUMBER_SIMPLE_MATH:      node = new OpSimpleMath();        break;
        case NUMBER_ADD:              node = new OpAdd();               break;
        case NUMBER_SUBTRACT:         node = new OpSubtract();          break;
        case NUMBER_MULTIPLY:         node = new OpMultiply();          break;
        case NUMBER_DIVIDE:           node = new OpDivide();            break;
        case NUMBER_MODULO:           node = new OpModulo();            break;
        case NUMBER_EXPONENT:         node = new OpExponent();          break;

        case NUMBER_BOOLEAN:          node = new OpBoolean();           break;
        case NUMBER_NOT:              node = new OpNot();               break;
        case NUMBER_AND:              node = new OpAnd();               break;
        case NUMBER_OR:               node = new OpOr();                break;
        case NUMBER_XOR:              node = new OpXor();               break;

        case NUMBER_CONDITION:        node = new OpCondition();         break;
        case NUMBER_EQUAL:            node = new OpEqual();             break;
        case NUMBER_NOT_EQUAL:        node = new OpNotEqual();          break;
        case NUMBER_LESS:             node = new OpLess();              break;
        case NUMBER_LESS_OR_EQUAL:    node = new OpLessOrEqual();       break;
        case NUMBER_GREATER:          node = new OpGreater();           break;
        case NUMBER_GREATER_OR_EQUAL: node = new OpGreaterOrEqual();    break;

        case NUMBER_TRIG:             node = new OpTrig();              break;
        case NUMBER_SIN:              node = new OpSine();              break;
        case NUMBER_COS:              node = new OpCosine();            break;
        case NUMBER_TAN:              node = new OpTangent();           break;

        case TEXT:                    node = new OpText();              break;
        case TEXT_LENGTH:             node = new OpTextLength();        break;
        case TEXT_TRIM:               node = new OpTextTrim();          break;
        case TEXT_SUBSTRING:          node = new OpTextSubstring();     break;
        case TEXT_CONTAINS:           node = new OpTextContains();      break;
        case TEXT_CASE:               node = new OpTextCase();          break;
        case TEXT_CHAR:               node = new OpTextCharacter();     break;
        case TEXT_REPLACE:            node = new OpTextReplace();       break;
        case TEXT_JOIN:               node = new OpTextJoin();          break;
        case TEXT_PAD:                node = new OpTextPad();           break;
        case TEXT_COMPARE:            node = new OpTextCompare();       break;
        case TEXT_TO_NUMBER:          node = new OpTextToNumber();      break;
        case TEXT_TO_COLOR:           node = new OpTextToColor();       break;
        case TEXT_SPLIT:              node = new OpTextSplit();         break;
        case TEXT_CSV:                node = new OpTextCSV();           break;
        case TEXT_JSON:               node = new OpTextJson();          break;
        case TEXT_FETCH:              node = new OpTextFetch();         break;
        case TEXT_FILE:               node = new OpTextFile();          break;

        case COLOR:                   node = new OpColor(options);      break;
        case VALID_COLOR:             node = new OpValidColor();        break;
        case CORRECT_COLOR:           node = new OpCorrectColor();      break;
        case COLOR_CONTRAST:          node = new OpColorContrast();     break;
        case COLOR_CONVERT_P3:        node = new OpConvertP3();         break;
        case COLORBLIND:              node = new OpColorBlind();        break;
        case COLOR_INTERPOLATE:       node = new OpColorInterpolate();  break;
        case COLOR_BLEND:             node = new OpColorBlend();        break;

        
        case FILL:                    node = new OpFill();              break;
        case GRADIENT:                node = new OpGradient();          break;
        case COLOR_STOP:              node = new OpColorStop();         break;

        case STROKE:                  node = new OpStroke();            break;

        case DROP_SHADOW:             node = new OpDropShadow();        break;
        case INNER_SHADOW:            node = new OpInnerShadow();       break;
        case LAYER_BLUR:              node = new OpLayerBlur();         break;
        case BACK_BLUR:               node = new OpBackBlur();          break;

        case LAYER_MASK:              node = new OpLayerMask();         break;

        case COLOR_STYLE:             node = new OpColorStyle(options); break;

        case RECTANGLE:               node = new OpRectangle();         break;
        case LINE:                    node = new OpLine();              break;
        case ELLIPSE:                 node = new OpEllipse();           break;
        case TRAPEZE:                 node = new OpTrapeze();           break;
        case POLYGON:                 node = new OpPolygon();           break;
        case STAR:                    node = new OpStar();              break;
        case TEXT_SHAPE:              node = new OpTextShape();         break;
        case POINT:                   node = new OpPoint();             break;
        case VECTOR_PATH:             node = new OpVectorPath();        break;
        case VECTOR_VERTEX:           node = new OpVectorVertex();      break;
        case VECTOR_EDGE:             node = new OpVectorEdge();        break;
        case VECTOR_REGION:           node = new OpVectorRegion();      break;
        case VECTOR_NETWORK:          node = new OpVectorNetwork();     break;
        case BOOLEAN:                 node = new OpShapeBoolean();      break;
        case SHAPE_GROUP:             node = new OpShapeGroup();        break;
        case FRAME:                   node = new OpFrame();             break;
        case SHAPE_APPLY:             node = new OpApply();             break;

        case MOVE:                    node = new OpMove();              break;
        case ROTATE:                  node = new OpRotate();            break;
        case SCALE:                   node = new OpScale();             break;
        case SKEW:                    node = new OpSkew();              break;

        case CENTER:                  node = new OpCenter();            break;
        case RESET_XFORM:             node = new OpResetTransform();    break;
        
        case MEASURE_POINTS:          node = new OpMeasurePoints();     break;
        case INTERPOLATE_POINT:       node = new OpInterpolatePoint();  break;
        case POINT_ON_PATH:           node = new OpPointOnPath();       break;

        case PLACE:                   node = new OpPlace();             break;

        case RENDER:                  node = new OpRender();            break;

        case GROUP_NODE:              node = new OpGroupNode();         break;
        case GROUP_PARAM:             node = new OpGroupParam();        break;

        case COMMENT:                 node = new OpComment();           break;
        case PANEL:                   node = new OpPanel();             break;

        default:                      consoleError('Graph.js/createNode() cannot create type ' + nodeType);
    }
    
    node._creatingButton = creatingButton;

    return node;
}


// menuSelect.addEventListener('change', async function(e) 
// {
//     switch (e.detail.selectedValue)
//     {
//         case 'saveLocal':  saveToLocalFile('graph.json'); break;
//         case 'loadLocal':  loadFromLocalFile();           break;
//         case 'duplicate':  console.log(graph.toJson());     break;
//     }
// });



subscriptionClose.addEventListener('click', e =>
{
    hideSubscriptionDialog();
});



// btnToggleWires.addEventListener('pointerenter', () => { btnToggleWires.mouseOver = true;  updateToggleShowWiresButton(); });
// btnToggleWires.addEventListener('pointerleave', () => { btnToggleWires.mouseOver = false; updateToggleShowWiresButton(); });


var importZoomToNodes = false;



function idFromNode(node)
{
    return node ? node.id : '';
}



function nodesToJson(nodes, encloseBraces = true, connOutputMustBeInNodes = true)
{
    const tab = HTAB;
    
    let json = 
          (encloseBraces ? '{\n' : '')
          + tab + '"nodes":\n'
          + tab + '[';

    let first = true;
    for (let i = 0; i < nodes.length; i++)
    {
        if (!first) json += ','; first = false;

        nodes[i].stripIdForCopy = true;
        json += NL + nodes[i].toJson(4);
    }

    json += NL + tab + ']';
    json += connectionsToJson(nodes, connOutputMustBeInNodes);
    json += (encloseBraces ? '\n}' :'');

    return json;
}



function connectionsToJson(nodes, connOutputMustBeInNodes)
{
    const connections = [];


    for (let i = 0; i < nodes.length; i++)
    {
        let node = nodes[i];

        // if (node.variableInputs)
        //     continue;

        for (let j = 0; j < node.inputs.length; j++)
        {
            if (   !node.inputs[j].connected
                ||     connOutputMustBeInNodes
                   && !nodes.includes(node.inputs[j].connectedOutput.node))
                continue;

            connections.push(node.inputs[j].connection);
        }
    }
    

    if (isEmpty(connections))
        return '';


    const tab = HTAB;

    let json = 
          ',\n'
        + tab + '"connections":\n'
        + tab + '[';
    
    for (let i = 0; i < connections.length; i++)
    {
        if (i > 0) json += ',';

        connections[i].stripIdForCopy = true;
        json += NL + connections[i].toJson(4);
    }

    json += NL + tab + ']';

    return json;
}



function canAutoConnectNode(node)
{
    const selNode = graph.pageNodes.find(n => n.selected);

    if (  !selNode
        || isEmpty(selNode.headerOutputs))
        return false;

    const inputs = node.headerInputs.filter(i => i.canConnectFrom(selNode.headerOutputs[0]));

    return !isEmpty(inputs)
         && node.canAutoConnectFrom(selNode.headerOutputs[0]);
}



function uiDeleteNodes(nodeIds)
{
    //nodeIds.forEach(id => nodeFromId(id).makePassive());

    graph.deleteNodes(nodeIds);

    uiRemoveSavedNodesAndConns(nodeIds);
    uiDeleteObjectsAndStyles(nodeIds, true);
}



function uiDeleteObjectsAndStyles(nodeIds, mustDelete = true)
{
    uiQueueMessageToFigma({
        cmd:       'figDeleteObjectsAndStyles',
        nodeIds:    nodeIds,
        mustDelete: mustDelete
    });
}



function uiCommitFigmaUndo()
{
    uiQueueMessageToFigma({cmd: 'figCommitUndo'});
}



function uiVariableConnect(outputNode, outputId, inputNode, inputId, outputOrder = -1)
{
    //console.log('uiVariableConnect()');

    const output = outputNode.outputFromId(outputId);
    return uiVariableConnectFromOutput(output, inputNode, inputId, outputOrder);
}



function uiVariableConnectFromOutput(output, inputNode, inputId, outputOrder = -1)
{
    //console.log('uiVariableConnectFromOutput()');

    if (!inputNode)
        return;
    

    const input = inputNode.inputFromId( inputId);


    if (    inputNode.variableInputs
        && (!input || !input.param))
    {
        const conn = uiConnect(
            output,
            inputNode.headerInputs.at(-1),
            inputId,
            outputOrder);

        if (outputOrder > -1)
            conn.outputOrder = outputOrder;

        if (   !graphView.loadingNodes
            && !graphView.pastingNodes
            && !graphView.restoringNodes)
            uiUpdateSavedConnectionsToNodeId(inputNode.id, true);

        return conn;
    }
    else
        return uiConnect(output, input, '', outputOrder);
}



function uiConnect(output, input, inputId = '', outputOrder = -1)
{
    return output.node.graph.connect(output, input, inputId, outputOrder);
}



function uiDisconnect(input, saveOld = true)
{
    //console.log('uiDisconnect()');
    
    const node = input.node;

    node.graph.disconnect(input);

    if (node.variableInputs)
        uiUpdateSavedConnectionsToNodeId(node.id, saveOld);
}



function uiDisconnectAny(input)
{
    //console.log('uiDisconnect()');
    
    uiDeleteSavedConnectionsToNodeId(input.node.id);

    input.node.graph.disconnect(input);
}



function uiUpdateSavedConnectionsToNodeId(nodeId, saveOld)
{
    const node = nodeFromId(nodeId);


    uiDeleteSavedConnectionsToNodeId(node.id);


    if (saveOld)
    {
        for (const input of node.inputs.filter(i => i.connected))
        {
            uiSaveConnection(
                input.connectedOutput.node.id,
                input.connectedOutput.id,
                input.connection.outputOrder,
                node .id,
                input.id,
                input.connection.toJson());
        }
    }
}



function uiUpdateSavedConnectionsFromNodeId(nodeId, saveOld)
{
    const node = nodeFromId(nodeId);


    uiDeleteSavedConnectionsFromNodeId(node.id);


    if (saveOld)
    {
        for (const output of node.outputs)
        {
            for (const input of output.connectedInputs)
            {
                uiSaveConnection(
                    output.node.id,
                    output.id,
                    input.connection.outputOrder,
                    input.node.id,
                    input.id,
                    input.connection.toJson());
            }
        }
    }
}



function makeSelectedNodesActive()
{
    if (graphView.selectedNodes.find(n => !n.active))
        actionManager.do(new MakeActiveNodesAction(graphView.selectedNodes.map(n => n.id), false));
}



function uiMakeNodeActive(node, makePassive = true)
{
    if (makePassive)
    {
        uiMakeNodeLeftPassive (node);
        uiMakeNodeRightPassive(node);
    }
    
    node.makeActive();
}    



function uiMakeNodesActive(nodes, shiftKey = false)
{
    if (!shiftKey)
    {
        for (const node of graph.nodes)
            if (node.active)
                uiMakeNodePassive(node);


        for (const node of nodes)
        {
            if (node.active) continue;
            
            pushUnique(graphView.activeNodes, node);
            node._active = true;
        }
    }
    else
    {
        for (const node of nodes)
        {
            if (node.active)
                uiMakeNodePassive(node);
            else
            {
                pushUnique(graphView.activeNodes, node);
                node._active = true;
            }
        }
    }
}



function uiMakeNodePassive(node)
{
    if (node.active)
    {
        node.makePassive();
        node.updateNode();
        
        uiDeleteObjectsAndStyles([node.id], false);
    }
}



function uiMakeNodeLeftPassive(node, fromNode = null)
{
    for (const input of node.inputs)
    {
        if (   input.connected
            && (  !fromNode
                || input.connectedOutput.node != fromNode))
        {
            uiMakeNodePassive(input.connectedOutput.node);
            uiMakeNodeLeftPassive(input.connectedOutput.node, node);
        }
    }
}



function uiMakeNodeRightPassive(node, fromNode = null)
{
    for (const output of node.outputs)
    {
        for (const connInput of output.connectedInputs)
        {
            uiMakeNodePassive(connInput.node);
            uiMakeNodeRightPassive(connInput.node, node);
        }
    }
}



function uiShowParamValue(nodeId, paramName, value)
{
    const node = nodeFromId(nodeId);

    if (!!node) // this is for deleted nodes which still exist
    {           // in genGraph but no longer in graph
        const param = node.params.find(p => p.name == paramName);
        param.controls[0].setValue(value, false);
    }
}



function uiCopyNodes(nodeIds)
{
    const nodes      = graph.nodes.filter(n => nodeIds.includes(n.id));
    const copiedJson = nodesToJson(nodes, true, false);

    // console.log(copiedJson);

    return copiedJson;
}



function uiPasteNodes(nodesJson, loading, pasteConnected, x, y, updateNodes)
{
    //console.log('nodesJson =', nodesJson);
    //console.log('x =', x);
    //console.log('y =', y);

    graphView.pastingNodes = true;


    pasteOffset.x += pasteOffsetDelta.x;
    pasteOffset.y += pasteOffsetDelta.y;


    try
    {
        const data = JSON.parse(nodesJson);


        if (   !isNaN(x) 
            && !isNaN(y)) // position new nodes
        {
            const positions = data.nodes.map(n => point(parseFloat(n.x), parseFloat(n.y)));

            for (let i = 0; i < data.nodes.length; i++)
            {
                data.nodes[i].x = x + positions[i].x - positions[0].x + 5 / graph.currentPage.zoom;
                data.nodes[i].y = y + positions[i].y - positions[0].y;
            }
        }
        else // offset new nodes (must be done before loading)
        {
            for (let i = 0; i < data.nodes.length; i++)
            {
                data.nodes[i].x = parseFloat(data.nodes[i].x) + pasteOffset.x;
                data.nodes[i].y = parseFloat(data.nodes[i].y) + pasteOffset.y;
            }
        }


        //moveNodesToViewport(data.nodes);


        const nodes = loadNodes(data, true);
        nodes.forEach(n => n.div.style.display ='none');

        
        // get the new names of the nodes after they've been added
        for (let i = 0; i < nodes.length; i++)
        {
            graph.addNode(nodes[i], false);
            data.nodes[i].newId = nodes[i].id;
        }


        if (data.connections)
        {
            correctNodeNamesInConnections(data);
            data.connections = parseConnectionsAndConnect(data, pasteConnected);
        }
        else
            data.connections = []; // return an empty array if no data was loaded


        if (loading)
        {
            graphView.selectedNodes = nodes;
            finishLoadingNodes(data.nodes, nodes, updateNodes, true);
        }


        return [nodes, data.connections];
    }
    catch (e)
    {
        return [[], []];
    }
}



function moveNodesToViewport(nodes)
{
    // if new nodes are outside of viewport, move them to center of viewport

    // const viewRect = graphView.measureData.clientRect;

    // let l = Number.MAX_SAFE_INTEGER;
    // let t = Number.MAX_SAFE_INTEGER;
    // let r = Number.MIN_SAFE_INTEGER;
    // let b = Number.MIN_SAFE_INTEGER;
    
    // for (let i = 0; i < nodes.length; i++)
    // {
    //     console.log('nodes[i] =', nodes[i]);

    //     l = Math.min(l, nodes[i].x);
    //     t = Math.min(t, nodes[i].y);
    //     r = Math.max(r, nodes[i].x + nodes[i].width);
    //     b = Math.max(b, nodes[i].y + nodes[i].height);
    // }
    
    // console.log('l =', l);
    // console.log('t =', t);
    // console.log('r =', r);
    // console.log('b =', b);

    // if (   l >  viewRect.r 
    //     || t >  viewRect.b 
    //     || r <= viewRect.l
    //     || b <= viewRect.t)
    // {
    //     const cx = (l + r) / 2;
    //     const cy = (t + b) / 2;
        
    //     const vx = viewRect.c;
    //     const vy = viewRect.m;
        
    //     for (let i = 0; i < nodes.length; i++)
    //     {
    //         nodes[i].x -= vx - cx;
    //         nodes[i].y -= vy - cy;

    //         console.log('nodes[i] =', nodes[i]);
    //     }
    // }
}



function correctNodeNamesInConnections(data)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];

        let outputNode = data.nodes.find(n => n.id == _conn.outputNodeId);
        if (outputNode) data.connections[i].outputNodeId = outputNode.newId;

        const inputNode = data.nodes.find(n => n.id == _conn.inputNodeId);

        data.connections[i].inputNodeId = inputNode.newId;
    }

    for (let i = 0; i < data.nodes.length; i++)
    {
        const _node = data.nodes[i];

        if (_node.newId && _node.newId != _node.id)
            _node.id = _node.newId;
    }
}



function updateGraphNodes()
{
    [...graphView.selectedNodes,     
     ...graphView._prevSelectedNodes,
     ...graphView.lastSelectedNodes]
       .forEach(n => n.updateNode());
}



function findConnectedClusters(nodes)
{
    let clusters = nodes.map(n => [n]);
    let first    = 0;


    while (true)
    {
        let moved = false;
        
        for (let i = clusters.length-1; i > first; i--)
        {
            if (clusters[i].at(0).immediatelyFollows(clusters[i-1].at(-1), true))
            {
                clusters[i-1].push(...clusters[i]);
                removeAt(clusters, i);
                moved = true;
            }
            else if (clusters[i-1].at(-1).immediatelyFollows(clusters[i].at(0)), true)
            {
                clusters[first] = [...clusters[i], ...clusters[i-1]];
                removeAt(clusters, i);
                moved = true;
            }
        }

        first++;

        if (  !moved
            || first >= clusters.length)
            break;
    }


    return clusters;
}



function uiToggleDisableNodes(nodes)
{
    nodes.forEach(n => { n.enabled = !n.enabled; });
}



function uiSavePages(pageIds, pageJson, currentPageId)
{
    if (settings.logRawSavePages)
        logSavePages(pageJson.join('\n'));

    uiQueueMessageToFigma({
        cmd:          'figSavePages',
        pageIds:       pageIds,
        pageJson:      pageJson,
        currentPageId: currentPageId });
}



function uiSaveNodes(nodeIds)
{
    const nodeJson = [];

    for (const id of nodeIds)
    {
        const node = nodeFromId(id);
        nodeJson.push(node.toJson());
    }

    uiSaveNodesJson(nodeIds, nodeJson);
}



function uiSaveNodesJson(nodeIds, nodeJson)
{
    if (isEmpty(nodeJson))
        return;

    if (settings.logRawSaveNodes)
        logSaveNodes(nodeJson.join('\n'));

    uiQueueMessageToFigma({
        cmd:     'figSaveNodes',
        nodeIds:  nodeIds,
        nodeJson: nodeJson });
}



function uiSaveConn(conn)
{
    if (settings.logRawSaveConnections)
        console.log('%cSAVING CONN\n' + conn.toJson(), 'color: black; background: #ddffee;');

    uiQueueMessageToFigma({
        cmd: 'figSaveConnection',
        key:  getConnKey(conn),
        json: conn.toJson()
    });
}



function uiSaveConnection(outputNodeId, outputId, outputOrder, inputNodeId, inputId, connJson)
{
    if (settings.logRawSaveConnections)
        console.log('%cSAVING CONNECTION\n' + connJson, 'color: black; background: #ddffee;');

    uiQueueMessageToFigma({
        cmd: 'figSaveConnection',
        key:  getConnectionKey(
                  outputNodeId, outputId, outputOrder,
                  inputNodeId, inputId),
        json: connJson
    });
}



function uiSaveConnections(conns)
{
    if (settings.logRawSaveConnections)
        logSaveConnections(conns);


    const keys     = [];
    const connJson = [];

    for (const conn of conns)
    {
        keys.push(getConnKey(conn));
        connJson.push(conn.toJson());
    }


    uiQueueMessageToFigma({
        cmd: 'figSaveConnections',
        keys: JSON.stringify(keys),
        json: JSON.stringify(connJson)
    });
}



function uiUpdateSavedConnections(curKeys, newKeys, conns)
{
    if (settings.logRawSaveConnections)
        logUpdateSavedConnections(conns);


    const connJson = [];

    for (const conn of conns)
        connJson.push(conn.toJson());


    uiQueueMessageToFigma({
        cmd:    'figUpdateSavedConnections',
        curKeys: JSON.stringify(curKeys),
        newKeys: JSON.stringify(newKeys),
        json:    JSON.stringify(connJson)
    });
}



function uiDeleteSavedConn(conn)
{
    if (settings.logRawSaveConnections)
    {
        //console.trace();

        console.log(
             '%cDELETING SAVED CONN '
            + getConnString(conn, true),
            'color: black; background: #ddeeff;');
    }


    uiQueueMessageToFigma({
        cmd: 'figDeleteSavedConnection',
        key:  getConnKey(conn)
    });
}



function uiDeleteSavedConnection(key, outputNodeId, outputId, outputOrder, inputNodeId, inputId, list)
{
    if (settings.logRawSaveConnections)
    {
        //console.trace();

        console.log(
             '%cDELETING SAVED CONNECTION ' 
            + getConnectionString(
                outputNodeId,
                outputId,
                outputOrder,
                inputNodeId,
                inputId,
                list,
                true), 
            'color: black; background: #ddeeff;');
    }


    uiQueueMessageToFigma({
        cmd: 'figDeleteSavedConnection',
        key:  key
    });
}



function uiRemoveSavedPage(pageId)
{
    uiQueueMessageToFigma({
        cmd:   'figRemoveSavedPage',
        pageId: pageId
    });
}



function uiRemoveAllSavedPages()
{
    uiQueueMessageToFigma({
        cmd: 'figRemoveAllSavedPages'
    });
}



function uiRemoveAllSavedConnections()
{
    for (const node of graph.nodes)
        for (const input of node.inputs)
            if (input.connected)
                uiDisconnectAny(input);

    uiQueueMessageToFigma({
        cmd: 'figRemoveAllSavedConnections'
    });
}



function uiDeleteSavedConnectionsToNodeId(nodeId)
{
    if (settings.logRawSaveConnections)
    {
        //console.trace();

        console.log(
            '%cDELETING SAVED CONNECTIONS TO ' + nodeId, 
            'color: black; background: #ddeeff;');
    }


    uiQueueMessageToFigma({
        cmd:   'figDeleteSavedConnectionsToNode',
        nodeId: nodeId
    });
}



function uiDeleteSavedConnectionsFromNodeId(nodeId)
{
    uiQueueMessageToFigma({
        cmd:   'figDeleteSavedConnectionsFromNode',
        nodeId: nodeId
    });
}



function uiRemoveSavedNodesAndConns(nodeIds)
{
    uiQueueMessageToFigma({
        cmd:    'figRemoveSavedNodesAndConns',
        nodeIds: nodeIds
    });
}



function uiRemoveConnsToNodes(nodeIds)
{
    const nodes = nodeIds.map(id => nodeFromId(id));

    for (const node of nodes)
        for (const input of node.inputs)
            if (input.connected)
                uiDisconnectAny(input);

                
    uiQueueMessageToFigma({
        cmd:    'figRemoveConnsToNodes',
        nodeIds: nodeIds
    });
}



function uiRemoveAllSavedNodesAndConns()
{
    uiQueueMessageToFigma({
        cmd: 'figRemoveAllSavedNodesAndConns'
    });
}



function uiRemovePluginDataFromAllLocalStyles()
{
    uiQueueMessageToFigma({
        cmd: 'figRemovePluginDataFromAllLocalStyles'
    });
}



function uiCleanAllIds()
{
    uiQueueMessageToFigma({
        cmd: 'figCleanAllIds'
    });
}



function uiLogAllSavedNodesAndConns()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedNodesAndConns',
        darkMode: darkMode,
        settings: settings
    });
}



function uiLogAllSavedNodes()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedNodes',
        darkMode: darkMode,
        settings: settings
    });
}



function uiLogAllSavedConns()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedConns',
        settings: settings
    });
}



function uiTriggerUndo()
{
    uiQueueMessageToFigma({
        cmd: 'figTriggerUndo'
    });
}



function uiUpdateViewportRect()
{
    uiQueueMessageToFigma({
        cmd: 'figUpdateViewportRect'
    });
}



function uiImportFromLocalFile()
{
    loadFromLocalFile(json => 
    {
        importZoomToNodes = true;
        actionManager.do(new PasteNodesAction(json, false, false, true, Number.NaN, Number.NaN, true));
    });
}



function uiSaveSelectionToLocalFile()
{
    if (isEmpty(graphView.selectedNodes))
        return;
        
    const json = uiCopyNodes(graphView.selectedNodes.map(n => n.id));

    saveToLocalFile(json, 'selection.gen', 'text/plain');
}



function getConnsFromNodes(nodes)
{
    const conns = [];

    for (const node of nodes)
    {
        pushUnique(conns, node.connectedInputs .map(i => i.connection));
        pushUnique(conns, node.connectedOutputs.map(o => o.connections));
    }

    return conns;
}



function uiUpdateGroupBounds(msg)
{
    const node = nodeFromId(msg.nodeId);

    node.paramX     .setValue(new NumberValue(msg.x     ), false, true, true);
    node.paramY     .setValue(new NumberValue(msg.y     ), false, true, true);
    node.paramWidth .setValue(new NumberValue(msg.width ), false, true, true);
    node.paramHeight.setValue(new NumberValue(msg.height), false, true, true);
}



function editSelectedGroup()
{
    const groupNode = graphView.selectedNodes[0];

    
    // set group as current page


    // hide page nodes


    // show group nodes
}



function findNodeAbove(node)
{
    const nodesAbove = [];

    for (const n of graph.nodes)
    {
        if (n == node) continue;

        if (   n.div.offsetTop < node.div.offsetTop
            && n.div.offsetLeft < node.div.offsetLeft + node.div.offsetWidth
            && n.div.offsetLeft + n.div.offsetWidth > node.div.offsetLeft
            && n.params.filter(p => !p.readOnly).length > 0)
            nodesAbove.push(n);
    }

    nodesAbove.sort((a, b) => b.div.offsetTop - a.div.offsetTop);

    return nodesAbove.length > 0
         ? nodesAbove[0]
         : null;
}



function findNodeBelow(node)
{
    const nodesBelow = [];

    for (const n of graph.nodes)
    {
        if (n == node) continue;

        if (   n.div.offsetTop + n.div.offsetHeight > node.div.offsetTop + node.div.offsetHeight
            && n.div.offsetLeft < node.div.offsetLeft + node.div.offsetWidth
            && n.div.offsetLeft + n.div.offsetWidth > node.div.offsetLeft
            && n.params.filter(p => !p.readOnly).length > 0)
            nodesBelow.push(n);
    }

    nodesBelow.sort((a, b) => a.div.offsetTop + a.div.offsetHeight - b.div.offsetTop - b.div.offsetHeight);

    return nodesBelow.length > 0
         ? nodesBelow[0]
         : null;
}



function layoutSelectedNodes()
{
    let bounds = Rect.NaN;

    for (const node of graphView.selectedNodes)
    {
        bounds = expandRect(
            bounds, 
            new Rect(
                node.div.offsetLeft, 
                node.div.offsetTop, 
                node.div.offsetWidth, 
                node.div.offsetHeight));
    }


    graphView.selectedNodes.forEach(n => n.layoutIndex = -1);
    graphView.selectedNodes.forEach(n => n.setLayoutIndex());


    let maxIndex = 0;

    for (const node of graphView.selectedNodes)
        maxIndex = Math.max(maxIndex, node.layoutIndex);


    let   totalWidth = 0;
    const maxWidth   = [];
    const gap        = 50;


    for (let i = 0; i <= maxIndex; i++)
    {
        const colNodes = graphView.selectedNodes.filter(n => n.layoutIndex == i);
        
        let width = 0;

        colNodes.forEach(n => width = Math.max(width, n.div.offsetWidth));
        maxWidth.push(width);

        totalWidth += width;
    }

    totalWidth += gap * Math.max(0, maxWidth.filter(w => w > 0).length - 1);


    let x = bounds.x + bounds.width/2 - totalWidth/2;

    // let first = false;
    
    for (let i = 0; i <= maxIndex; i++)
    {
        const colNodes = graphView.selectedNodes.filter(n => n.layoutIndex == i);
        colNodes.forEach(n => n.newX = x);

        x += maxWidth[i];

        if (maxWidth[i] > 0)
            x += gap;
    }


    const positions = graphView.selectedNodes.map(n => point(n.newX, n.div.offsetTop));


    actionManager.do(new MoveNodesAction(graphView.selectedNodes.map(n => n.nodeId), positions));
}



function setNodeHighlight(nodes, color)
{
    actionManager.do(new HighlightNodesAction(nodes.map(n => n.nodeId), color));
}


function uiLinkNodeToExistingColorStyle(node, styleId, styleName, paints)
{
    node.linkedStyleId   = styleId;
    node.linkedStyleName = styleName;


    if (styleName != NULL)
        node.name = styleName;

    // node.name =
    //     styleName != NULL
    //     ? styleName
    //     : node.defName;

        
    if (styleId != NULL)
    {
        if (!isEmpty(paints))
        {
            const c = paints[0];

            node.paramValue.setValue(FillValue.create(
                Math.round(c[0] * 0xff),
                Math.round(c[1] * 0xff),
                Math.round(c[2] * 0xff),
                Math.round(c[3] * 100 )));
        }
    }
    else
    {
        node.paramValue.setValue(FillValue.NaN);

        // if (node.paramValue.input.connected)
        //     actionManager.do(new DisconnectAction(node.paramValue.input), true);
    }


    pushUpdate(null, [node]);


    uiQueueMessageToFigma({
        cmd:    'figLinkNodeToExistingColorStyle',
        nodeId:  node.id,
        styleId: styleId});
}



function uiStylePropertyChange(msg)
{
    const node = graph.nodes.find(n => 
           n.type == COLOR_STYLE 
        && n.linkedStyleId == cleanStyleId(msg.styleId));

    if (!node)
        return;
    
    
    for (const prop of msg.properties)
    {
        switch (prop)
        {
            case 'name':
                node.name = msg.name;
                break;

            case 'paint':
                if (!isEmpty(msg.paints))
                {
                    const paint = msg.paints[0];

                    if (paint.type == 'SOLID')
                    {
                        node.paramValue.setValue(FillValue.create(
                            Math.round(paint.color.r * 0xff),
                            Math.round(paint.color.g * 0xff),
                            Math.round(paint.color.b * 0xff),
                            Math.round(paint.opacity * 100 )));
                    }
                }

                break;
        }
    }


    if (node)
    {
        pushUpdate(null, [node]);

        actionManager.clear();
        uiShowClearUndoWarning();
    }
}



function uiStyleDelete(msg)
{
    const node = graph.nodes.find(n => 
           n.type == COLOR_STYLE 
        && n.linkedStyleId == cleanStyleId(msg.styleId));


    if (node)
    {
        uiLinkNodeToExistingColorStyle(node, NULL, '', []);
        
        actionManager.clear();
        uiShowClearUndoWarning();
    }
}



function uiReturnFigGetAllLocalColorStyles(msg)
{
    const styles = JSON.parse(msg.styles);

    initLocalStylesMenu(styles, msg.nodeId);

    menuLocalStyles.showAt(msg.px, msg.py, false);
}



function uiReturnGetAllLocalTemplateNames(templateNames)
{
    console.log('return local templates');

    const menuItems = [];


    for (const templateName of templateNames)
        menuItems.push(new MenuItem(templateName, null, {callback: null}));


    if (menuItems.length > 0)
        menuItems.push(new MenuItem('', null, {separator: true}));


    menuItems.push(menuItemManageTemplates);


    menuTemplate.clearItems();
    menuTemplate.addItems(...menuItems);

    
    hideAllMenus();

    menuTemplate.show(btnTemplate.div, null, false, false);
}



function uiSetStyleId(msg)
{
    nodeFromId(msg.nodeId).linkedStyleId = msg.styleId;
}



function initLocalStylesMenu(styles, nodeId)
{
    const node = nodeFromId(nodeId);
    consoleAssert(node.type == COLOR_STYLE, 'node must be COLOR_STYLE');


    menuLocalStyles.clearItems();

    for (const style of styles)
    {
        const options = {};

        if (style.paints.length == 1)
        {
            const rgba = style.paints[0];
            options.icon = createStyleIcon(rgba);//'<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="8" fill="' + rgb2style(rgb) + '"/></svg>';
        }

        if (   style.existing == undefined
            || style.existing)
            options.enabled = false;


        options.callback = () => actionManager.do(
            new LinkExistingStyleAction(
                nodeId,
                style.id, 
                style.name,
                style.paints));
            
        const item = new MenuItem(style.name.replaceAll('/', ' / '), null, options);

        item.setChecked(style.nodeId == node.id);

        menuLocalStyles.addItems([item]);
    }


    if (!isEmpty(styles))
        menuLocalStyles.addItems([new MenuItem('', null, {separator: true})]);

        
    menuLocalStyles.addItems([
        new MenuItem('None', null, {
            callback: e => actionManager.do(new LinkExistingStyleAction(nodeId, NULL, '', [])),
            enabled:  node.linkedStyleId != NULL})
    ]);
}



function createStyleIcon(rgba)
{
    const rgba0 = hex2rgb('d9d9d9');
    const rgba1 = hex2rgb('f6f6f6');

    rgba0[3] = 1 - rgba[3];
    rgba1[3] = 1 - rgba[3];

    const icon = 
        '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"> \
            <g clip-path="url(#clip0_1300_182)"> \
            <rect width="16" height="16" rx="8" fill="#'+rgba2hex(rgba1)+'"/> \
            <path fill-rule="evenodd" clip-rule="evenodd" d="M3 0H0V3H3V6H0V9H3V12H0V15H3V18H6V15H9V18H12V15H15V18H18V15H15V12H18V9H15V6H18V3H15V0H12V3H9V0H6V3H3V0ZM6 6V3H9V6H6ZM6 9H3V6H6V9ZM9 9H6V12H3V15H6V12H9V15H12V12H15V9H12V6H15V3H12V6H9V9ZM9 9V12H12V9H9Z" fill="#'+rgba2hex(rgba0)+'"/> \
            <path d="M0 16V0L16 16H0Z" fill="#2C2C2C"/> \
            <rect width="16" height="16" fill="' + rgba2style(rgba) + '"/> \
            </g> \
            <defs> \
            <clipPath id="clip0_1300_182"> \
            <rect width="16" height="16" rx="8" fill="white"/> \
            </clipPath> \
            </defs> \
        </svg>';

    return icon.replaceAll('#', '%23');
}


var isGenerating  = false;
var stopRequestId = null;



function uiUpdateValuesAndObjects(requestId, actionId, updateNodeId, updateParamId, values, objects, styles, updatedNodes, totalNodes, isFirstChunk, isLastChunk, save)
{
    if (requestId < lastRequestedId) 
        return;
    
    lastRequestedId = -1;

        
    if (loadRestartTimer > -1)
    {
        clearTimeout(loadRestartTimer);
        loadRestartTimer = -1;
    }


    if (settings.logRawValues)  
        console.log('raw values = ', values);

    if (settings.logValueUpdates)  
        logValueUpdates(updateNodeId, updateParamId, values);


    const nodes = [];

    let i = 0;
    while (i < values.length)
    {
        const nodeId = values[i++];
        const count  = values[i++];

        const node   = nodeFromId(nodeId);


        if (node)
            pushUnique(nodes, node);


        if (count > 0)
        {
            const _ids    = [];
            const _values = [];


            for (let j = 0; j < count; j++)
            {
                const id   = values[i++];
                const type = values[i++];

                _ids.push(id);

                let value = parseValueFromType(type, values[i++]);

                if (value.nodeId)
                    value.nodeId = nodeId;
    
                _values.push(value);
            }


            if (node)
            {
                node.updateValues( 
                    requestId,
                    actionId,
                    updateNodeId == nodeId ? updateParamId : '',
                    _ids,
                    _values);

                node.valid = true;
            }
        }
    }

    
    if (   !isEmpty(objects)
        || !isEmpty(styles)
        || isLastChunk)
    {
        if (settings.logObjectUpdates) logObjectUpdates([...objects]);
        if (settings.logStyleUpdates ) logStyleUpdates ([...styles ]);

        objects = objects.filter(o => 
        {
            const node = nodeFromId(o[FO_NODE_ID]);
            return node && node.active;
        });

        uiQueueMessageToFigma(
        {
            cmd:          'figUpdateObjectsAndStyles',
            updateNodeId:  updateNodeId,
            updateParamId: updateParamId,
            nodeIds:       nodes.map(n => n.id),
            objects:       [...objects],
            styles:        [...styles ],
            firstChunk:    isFirstChunk,
            lastChunk:     isLastChunk 
        });
    }


    if (   !graphView.loadingNodes
        && !numberControlChanging
        &&  save)
        uiSaveNodes(nodes.map(n => n.id));


    for (const node of nodes)
    {
        if (   graphView.creatingNodes
            || graphView.loadingNodes
            || graphView.pastingNodes
            || graphView.restoringNodes)
            node.div.style.display = 'block';

        node.updateMeasureData();
        node.updateNode();
    }


    graphView.updateNodes(nodes);
    graphView.updateScrollWithBounds();


    if (graphView.loadingNodes)
        setLoadingProgress((0.7 + 0.3 * updatedNodes / totalNodes) / 0.7)

        
    if (isLastChunk)
    {
        if (graphView.loadingNodes)
        {
            if (save)
                uiSaveNodes(graph.nodes.map(n => n.id));
    
            graph.updatePages();
        }


        if (   graphView.loadingNodes
            || graphView.creatingNodes
            || graphView.pastingNodes)
            enableFeatures(subscribed());

            
        if (importZoomToNodes)
        {
            graphView.zoomToNodes(nodes);
            importZoomToNodes = false;
        }


        graphView.creatingNodes  = false;
        graphView.pastingNodes   = false;
        graphView.loadingNodes   = false;
        graphView.restoringNodes = false;

        actionManager.undoing    = false;
        actionManager.redoing    = false;
        

        loadingOverlay.style.display = 'none'; // for loading


        uiUpdateAnimateNodes();
    }
}



function uiUpdateAnimateNodes()
{
    const anims = graph.nodes.filter(n => 
           n.type == NUMBER_ANIMATE 
        && n.playing);

    anims.forEach(n => n.updatePlayback(false));

    if (anims.length > 0)
        pushUpdate(null, anims, false);
}



function uiInitGlobalProgress(requestId)
{
    commonProgressBar.style.width   = 0;
    commonProgressBar.style.display = 'block';

    isGenerating = true;
}



function uiUpdateGlobalProgress(progress)
{
    commonProgressBar.style.top     = (graphView.loadingNodes ? 0 : 40) + 'px';
    commonProgressBar.style.width   = (progress * 100) + '%';
    commonProgressBar.style.display = 'block';
}



function uiEndGlobalProgress()
{
    commonProgressBar.style.display = 'none';

    isGenerating = false;
}



function uiGetValue(key)
{
    switch (key)
    {
        case 'stopRequestId':  
        {
            uiPostMessageToGenerator(
            {
                cmd:  'returnUiGetValue',
                key:   key,
                value: stopRequestId
            });

            stopRequestId = null;

            if (graphView.loadingNodes)
                restartLoadingTimer();
            
            break;
        }
    }
}



const defNodeWidth          = 114;
const resizeEdgeWidth       = 8;


var   overNumberControl     = null;
var   overNumberControlCtrl = null;

var   numberControlChanging = null;


const graph                 = new Graph();
var   graphView             = new GraphView(_graphView);
         
var   viewportZoom          = 1;
var   viewportRect          = new Rect();


const smallScrollGap        =  6;
const largeScrollGap        = 14;
       
var   menuBarHeight         = 40;
var   pagesBarHeight        = 36;


var   figFonts              = [];
var   figUniqueFontNames    = [];



function getTopHeight() 
{ 
    return menuBarHeight 
        + (settings.showPages ? pagesBarHeight : 0);
}



function uiError(text, options = {}, delay = 6000)
{
    uiNotify(
        text, 
        {
            delay: delay,
            error: true,
            ...options
        });
}



function uiNotify(text, options = {})
{
    if (options.delay        == undefined) options.delay        = 4000;
    if (options.error        == undefined) options.error        = false;
    if (options.prefix       == undefined) options.prefix       = '';
    if (options.buttonText   == undefined) options.buttonText   = '';
    if (options.buttonAction == undefined) options.buttonAction = NULL;


    uiQueueMessageToFigma(
    { 
        cmd:         'figNotify',
        text:         text,
        prefix:       options.prefix,
        delay:        options.delay,
        error:        options.error,
        buttonText:   options.buttonText,
        buttonAction: options.buttonAction
    });        
}



function uiShowClearUndoWarning(deleting)
{
    if (settings.showClearUndoWarning)
    {
        uiNotify(
            'Changing or deleting linked styles in Figma clears undo in Generator', 
            {
                buttonText:   'Ignore',
                buttonAction: 'hideClearUndoWarning',
                delay:         8000 
            });
    }
}



function uiHideClearUndoWarning()
{
    updateSettingAndMenu(
        'showClearUndoWarning',  
         true, 
        !settings.showClearUndoWarning);
}



function uiRestartGenerator(dataMode)
{
    uiSetLocalData('dataMode', boolToString(dataMode));
    uiPostMessageToFigma({cmd: 'figRestartGenerator'});
}



function uiUpdateZoom(zoom)
{
    viewportZoom = zoom;
}





// function setCurrentGraph(graph)
// {
//     consoleAssert(graphView, 'there should be a valid graphView');

//     const elements = Array.prototype.slice.call(document.children);
//     const index    = elements.indexOf(graphView.div);

//     document.body.removeChild(graphView.div);
//     document.body.insertBefore(graphView.div, document.children[index]);

//     graphView.updateMeasureData();
// }


function initWhatsNewDialog()
{
    //whatsNew0.innerHTML = whatsNew0.innerHTML.replace('%Ctrl%', osCtrl());


    initCheckbox(chkHideWhatsNew, 'Don\'t show again', false);
    chkHideWhatsNew.addEventListener('change', () => uiSetLocalData('showWhatsNew', generatorVersion));


    whatsNewBack.addEventListener('pointerdown', e => { e.preventDefault(); });


    whatsNewDialog.mouseOver = false;

    whatsNewDialog.addEventListener('pointerenter', e => { whatsNewDialog.mouseOver = true;  updateWhatsNewScroll(); });
    whatsNewDialog.addEventListener('pointerleave', e => { whatsNewDialog.mouseOver = false; updateWhatsNewScroll(); });
    

    let r = simpleIntHash(generatorVersion);
    r = 3*r*r - 2*r*r*r;

    whatsNewWatermark.style.left = Math.round(r * 100) + '%';


    whatsNewDialogContainer.addEventListener('wheel', e =>
    {    
        const bounds = whatsNewDialogContent.getBoundingClientRect();

        if (bounds.bottom - bounds.top <= whatsNewDialogContainer.clientHeight)
            return;


        let oy = whatsNewDialogContent.style.top = whatsNewDialogContent.offsetTop - e.deltaY / 3;

        oy = Math.max(oy, whatsNewDialogContainer.clientHeight - whatsNewDialogContent.clientHeight + whatsNewTitle.clientHeight);
        whatsNewDialogContent.style.top = Math.min(oy, getTopHeight());

        updateWhatsNewScroll();
    });



    whatsNewScrollbarY.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            whatsNewScrollbarY.moving = true;
            whatsNewScrollbarY.yStart = whatsNewScrollbarY.offsetTop;
            whatsNewScrollbarY.hStart = whatsNewScrollbarY.offsetHeight;
            whatsNewScrollbarY.pStart = e.clientY;
            whatsNewScrollbarY.setPointerCapture(e.pointerId);
    
            for (const node of graph.nodes)
                node.div.sly = node.div.offsetTop;
    
            whatsNewDialogContent.topStart = whatsNewDialogContent.offsetTop;
        }
    });
    
    
    
    whatsNewScrollbarY.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && whatsNewScrollbarY.moving)
        {
            whatsNewScrollbarY.moving = false;
            whatsNewScrollbarY.releasePointerCapture(e.pointerId);
 
            let bounds = Rect.NaN;
    
            for (const node of graph.nodes)
                bounds = expandRect(bounds, boundingRect(node.div));
    
            // if (bounds.t >= 0 && bounds.b < whatsNewDialog.clientHeight)
            //     whatsNewScrollbarY.style.display = 'none';
        }
    });
    
    
    
    whatsNewScrollbarY.addEventListener('pointermove', e =>
    {
        if (whatsNewScrollbarY.moving)
            updateWhatsNewScrollbar(e.clientY);
    });


    whatsNewTitleText.innerHTML = 'Version ' + generatorVersion;
}



function showWhatsNewDialog()
{
    whatsNewBack  .style.display = 'block';
    whatsNewDialog.style.display = 'block';
    //whatsNewClose .style.display = 'block';

    updateWhatsNewScroll();

    dialogShown = true;
}



function hideWhatsNewDialog()
{
    whatsNewBack  .style.display = 'none';
    whatsNewDialog.style.display = 'none';

    dialogShown = false;
}



whatsNewClose.addEventListener('pointerdown', e => e.stopPropagation());



whatsNewBack.addEventListener('pointerdown', () =>
{
    hideWhatsNewDialog();
});



/////////////////////////////////////////////////////////////////////////////////////



function updateWhatsNewScrollbar(clientY)
{
    let t = whatsNewScrollbarY.yStart + clientY - whatsNewScrollbarY.pStart;
    let b = t + whatsNewScrollbarY.hStart;

    t = Math.max(whatsNewTitle.clientHeight + smallScrollGap, t);
    b = Math.min(b, whatsNewDialogContainer.clientHeight - largeScrollGap);

    t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
    b = Math.max(t + smallScrollGap, b);


    let oy = 
          whatsNewDialogContent.topStart 
        - (clientY - whatsNewScrollbarY.pStart) / whatsNewScrollbarY.hStart * whatsNewDialogContainer.clientHeight;

    oy = Math.max(oy, whatsNewDialogContainer.clientHeight - whatsNewDialogContent.clientHeight + whatsNewTitle.clientHeight);


    whatsNewDialogContent.style.top = Math.min(
        oy,
        getTopHeight());


    updateWhatsNewScroll();
}



function updateWhatsNewScroll()
{
    const x       = whatsNewDialog.clientLeft;
    const w       = whatsNewDialog.clientWidth;
    const h       = whatsNewDialogContainer.clientHeight;
    const yOffset = getTopHeight();
    
    const bounds = whatsNewDialogContent.getBoundingClientRect();
    
    updateWhatsNewScrollY(x, w, h, bounds, yOffset);
}



function updateWhatsNewScrollY(x, w, h, bounds, yOffset)
{
    if (   whatsNewDialog.mouseOver
        && bounds.bottom - bounds.top > h)
    {
        const height = sqr(h) / bounds.height - 2*smallScrollGap;

        whatsNewScrollbarY.style.display = 'inline-block';
        whatsNewScrollbarY.style.height  =  height;
        whatsNewScrollbarY.style.left    =  x + w - smallScrollGap - 6;
        whatsNewScrollbarY.style.top     =  yOffset - (bounds.top - 100) * h / bounds.height;
    }
    else
       whatsNewScrollbarY.style.display = 'none';
}


function initWindowSizers()
{
    //initWindowSizerEvents(windowSizerL,  setWindowSizerRectL);
    initWindowSizerEvents(windowSizerR,  setWindowSizerRectR);
    initWindowSizerEvents(windowSizerB,  setWindowSizerRectB);

    //initWindowSizerEvents(windowSizerBL, setWindowSizerRectBL);
    initWindowSizerEvents(windowSizerBR, setWindowSizerRectBR);
}



function initWindowSizerEvents(sizer, setRect)
{
    sizer.resizing = false;


    sizer.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            if (document.activeElement)
                document.activeElement.blur();


            hideAllMenus();
               
            sizer.setPointerCapture(e.pointerId);


            e.stopPropagation();


            sizer.startRect = new Rect(0, 0, window.innerWidth, window.innerHeight);
            sizer.resizing  = true;
            

            sizer.sx = e.clientX;
            sizer.sy = e.clientY;
        }        
    });



    sizer.addEventListener('pointermove', e =>
    {
        if (!sizer.resizing)
            return;


        const dx = e.clientX - sizer.sx;
        const dy = e.clientY - sizer.sy;
    
        setRect(sizer, dx, dy);
            

        e.preventDefault();
        e.stopPropagation();
    });
    

    
    sizer.addEventListener('pointerup', e =>
    {
        if (e.button == 0)
        {
            if (sizer.resizing)
                sizer.resizing = false;

            if (sizer.hasPointerCapture(e.pointerId))
                sizer.releasePointerCapture(e.pointerId);
        }
    });
}



function setWindowSizerRectL(sizer, dx, dy) // these have to be lambdas for 'this'
{
    setWindowSizerRect(
        sizer.startRect.x + dx,
        sizer.startRect.y, 
        sizer.startRect.w - dx, 
        sizer.startRect.h);
}



function setWindowSizerRectR(sizer, dx, dy)
{
    uiResizeWindow(
        sizer.startRect.w + Math.round(dx),
        sizer.startRect.h);

    setWindowSizerRect(
        sizer.startRect.x, 
        sizer.startRect.y, 
        sizer.startRect.w + dx, 
        sizer.startRect.h);
}



function setWindowSizerRectB(sizer, dx, dy)
{
    uiResizeWindow(
        sizer.startRect.w,
        sizer.startRect.h + Math.round(dy));

    setWindowSizerRect(
        sizer.startRect.x, 
        sizer.startRect.y, 
        sizer.startRect.w, 
        sizer.startRect.h + dy);
}



function setWindowSizerRectBL(sizer, dx, dy)
{
    setWindowSizerRect(
        sizer.startRect.x + dx, 
        sizer.startRect.y, 
        sizer.startRect.w - dx, 
        sizer.startRect.h + dy);
}



function setWindowSizerRectBR(sizer, dx, dy)
{
    uiResizeWindow(
        sizer.startRect.w + Math.round(dx),
        sizer.startRect.h + Math.round(dy));

    setWindowSizerRect(
        sizer.startRect.x, 
        sizer.startRect.y, 
        sizer.startRect.w + dx, 
        sizer.startRect.h + dy);
}


function setWindowSizerSize(w, h, updateTransform = true)
{
    updateWindowSizers();
}



function setWindowSizerRect(x, y, w, h, updateTransform = true)
{
    updateWindowSizers();
}



function updateWindowSizers()
{
    const edge   = Math.ceil(windowBorderWidth);
    const corner = Math.max(windowBorderWidth, edge);

    //windowSizerL .style.width  = edge; 
    windowSizerR .style.width  = edge; 
    windowSizerB .style.height = edge; 

    //windowSizerBL.style.width  = corner; 
    //windowSizerBL.style.height = corner; 

    windowSizerBR.style.width  = corner; 
    windowSizerBR.style.height = corner; 


    //windowSizerL.style.cursor  = 'ew-resize';
    windowSizerR.style.cursor  = 'ew-resize';
    windowSizerB.style.cursor  = 'ns-resize';
    
    //windowSizerBL.style.cursor = 'nesw-resize';
    windowSizerBR.style.cursor = 'nwse-resize';
}


// document.canResizeL = false;
// document.canResizeR = false;
// document.canResizeB = false;
   
// document.resizingL  = false;
// document.resizingR  = false;
// document.resizingB  = false;

document.startRect  = new Rect();



//window.addEventListener('keydown',       e => e.preventDefault());

window.addEventListener('gesturestart',  e => e.preventDefault());
window.addEventListener('gesturechange', e => e.preventDefault());
window.addEventListener('gestureend',    e => e.preventDefault());



var crashed     = false;
var dialogShown = false;

var darkMode;



function checkResize(x, y)
{
    if (!documentBodyClient)
    {
        setAutoCursor();
        return;
    }


    // document.canResizeL = false;//!dialogShown &&                      x <= resizeEdgeWidth;
    // document.canResizeR = !dialogShown && window.innerWidth  - x <= resizeEdgeWidth;
    // document.canResizeB = !dialogShown && window.innerHeight - y <= resizeEdgeWidth;

    
    // if (     document.canResizeR
    //       && document.canResizeB) setCursor('nwse-resize', false); 
    // else if (document.canResizeL
    //       && document.canResizeB) setCursor('nesw-resize', false); 
    // else if (document.canResizeL
    //       || document.canResizeR) setCursor('ew-resize',   false);   
    // else if (document.canResizeB) setCursor('ns-resize',   false);   
    // else                          setAutoCursor();
}



function uiSetWindowRect(x, y, width, height)
{
    uiQueueMessageToFigma({ 
        cmd:   'figSetWindowRect', 
        x:      x,
        y:      y,
        width:  Math.max(660, width),
        height: height
    });
}



function uiResizeWindow(width, height)
{
    uiQueueMessageToFigma({ 
        cmd:   'figResizeWindow', 
        width:  Math.max(660, width),
        height: height
    });
}



function uiReturnFigResizeWindow()
{
    if (settings.dataMode)
        return;

    graphView.update();
    updateWhatsNewScrollbar(0);

    graph.updatePageName();
}



function uiUpdateWindowStartRect(msg)
{
    document.startRect = new Rect(
        msg.position.x - msg.clientPosition.x,
        msg.position.y - msg.clientPosition.y,
        window.innerWidth,
        window.innerHeight);

    // console.log('position       =', position);
    // console.log('clientPosition =', clientPosition);

    viewportZoom = msg.viewportZoom;
    viewportRect = msg.viewportRect;
    
    document.startRectIsValid = true;
}



function isDarkMode()
{
    const style = window.getComputedStyle(document.body);
    return isDark(style2rgba(style.backgroundColor));
}



// create an observer for when the UI theme changes

function onClassChange(element, callback) 
{
    const observer = new MutationObserver((mutations) => 
    {
        mutations.forEach((mutation) => 
        {
            if (   mutation.type          == 'attributes' 
                && mutation.attributeName == 'class'    )
                callback(mutation.target);
        });
    });

    observer.observe(element, { attributes: true });

    return observer.disconnect;
}



function dockWindowNormal  () { uiQueueMessageToFigma({cmd: 'figDockWindowNormal'  }); }
function dockWindowMaximize() { uiQueueMessageToFigma({cmd: 'figDockWindowMaximize'}); }
function dockWindowTop     () { uiQueueMessageToFigma({cmd: 'figDockWindowTop'     }); }
function dockWindowLeft    () { uiQueueMessageToFigma({cmd: 'figDockWindowLeft'    }); }
function dockWindowRight   () { uiQueueMessageToFigma({cmd: 'figDockWindowRight'   }); }
function dockWindowBottom  () { uiQueueMessageToFigma({cmd: 'figDockWindowBottom'  }); }



function initAboutDialog()
{
    // initCheckbox(chkAboutHideWhatsNew, 'Show what\'s new at startup', settings.showWhatsNew);
    // chkAboutHideWhatsNew.addEventListener('change', () => uiSetLocalData('showWhatsNew', chkAboutHideWhatsNew.checked ? (generatorVersion-1) : (generatorVersion)));

    aboutBack .addEventListener('pointerdown', e => { e.preventDefault(); });
    aboutBack .addEventListener('pointerdown', () => { hideAboutDialog(); });
    aboutClose.addEventListener('pointerdown', e => e.stopPropagation());

    aboutVersion.innerHTML = 'Generator&nbsp;&hairsp;version&nbsp;&thinsp;' + generatorVersion;
}



function showAboutDialog()
{
    aboutBack  .style.display = 'block';
    aboutDialog.style.display = 'block';

    //aboutUserId.innerHTML = '<span style="user-select: none; color: var(--figma-color-bg-disabled-secondary);">Your Figma user ID:&nbsp;&nbsp;</span>' + currentUser.id;

    dialogShown = true;
}



function hideAboutDialog()
{
    aboutBack  .style.display = 'none';
    aboutDialog.style.display = 'none';

    dialogShown = false;
}



function copyUserId()
{
    writeTextToClipboard(currentUser.id);
    selectElementText('aboutUserId');
    uiNotify('Copied user ID');
}



aboutBack.addEventListener('pointerdown', () =>
{
    hideAboutDialog();
});



var deleteConnectionsDialogVisible = false;



function showDeleteConnectionsDialog()
{
    deleteConnectionsDialog.style.left      = '50%';
    deleteConnectionsDialog.style.top       = '50%';
    deleteConnectionsDialog.style.transform = 'translateX(-50%) translateY(-50%)';

    deleteConnectionsDialog.style.display   = 'block';
    deleteConnectionsDialogVisible          = true;
  
    deleteConnectionsTitle.buttonDown0      = false;
       
    deleteConnectionsTitle.moveStart        = point_NaN;
    deleteConnectionsTitle.pStart           = point_NaN;
    
    deleteConnectionsInput.value            = graphView.selectedNodes.map(n => n.id).join(', ');

    updateDeleteConnectionsInputBack();


    window.setTimeout(() => document.getElementById('deleteConnectionsInput').focus(), 0);
}



function hideDeleteConnectionsDialog()
{
    deleteConnectionsDialog.style.display = 'none';
    deleteConnectionsDialogVisible        = false;
}



deleteConnectionsClose.addEventListener('pointerdown', e => e.stopPropagation());



deleteConnectionsTitle.addEventListener('pointerdown', e => 
{
    deleteConnectionsTitle.setPointerCapture(e.pointerId);
    deleteConnectionsTitle.buttonDown0 = true;

    deleteConnectionsTitle.moveStart = point(deleteConnectionsDialog.offsetLeft, deleteConnectionsDialog.offsetTop);
    deleteConnectionsTitle.pStart    = point(e.clientX, e.clientY);
});



deleteConnectionsTitle.addEventListener('pointermove', e =>
{
    if (deleteConnectionsTitle.buttonDown0)
    {
        deleteConnectionsDialog.style.left = (deleteConnectionsTitle.moveStart.x + (e.clientX - deleteConnectionsTitle.pStart.x)) + 'px';
        deleteConnectionsDialog.style.top  = (deleteConnectionsTitle.moveStart.y + (e.clientY - deleteConnectionsTitle.pStart.y)) + 'px';
    }
});



deleteConnectionsTitle.addEventListener('pointerup', e =>
{
    deleteConnectionsTitle.buttonDown0 = false;
    deleteConnectionsTitle.releasePointerCapture(e.pointerId);
});



deleteConnectionsInput.addEventListener('input', () =>
{
    updateDeleteConnectionsInputBack();
});



function updateDeleteConnectionsInputBack()
{
    deleteConnectionsInputBack.innerHTML          = deleteConnectionsInput.value == '' ? 'Node IDs' : '';
    deleteConnectionsInputBack.style.borderBottom = deleteConnectionsInput.value == '' ? '1px solid var(--figma-color-bg-tertiary)' : 'none';
}



deleteConnectionsInput.addEventListener('pointerup', () =>
{
    deleteConnectionsInput.select();
});



function deleteConnectionsToNodes(str)
{
    str = str.replace(',', ' ');
    
    const nodeIds = str.split(' ').filter(i => i);

    uiRemoveConnsToNodes(nodeIds);

    if (!isEmpty(nodeIds))
        hideDeleteConnectionsDialog();
}


function initEulaDialog()
{
    //eulaBack.addEventListener('pointerdown', e => { e.preventDefault(); });


    eulaDialog.mouseOver = false;

    eulaDialog.addEventListener('pointerenter', e => { eulaDialog.mouseOver = true;  updateEulaScroll(); });
    eulaDialog.addEventListener('pointerleave', e => { eulaDialog.mouseOver = false; updateEulaScroll(); });
    

    let r = simpleIntHash(generatorVersion);
    r = 3*r*r - 2*r*r*r;

    eulaWatermark.style.left = Math.round(r * 100) + '%';


    eulaDialogContainer.addEventListener('wheel', e =>
    {    
        const bounds = eulaDialogContent.getBoundingClientRect();

        if (bounds.bottom - bounds.top <= eulaDialogContainer.clientHeight)
            return;


        let oy = eulaDialogContent.style.top = eulaDialogContent.offsetTop - e.deltaY / 3;

        oy = Math.max(oy, eulaDialogContainer.clientHeight - eulaDialogContent.clientHeight + eulaTitle.clientHeight);
        eulaDialogContent.style.top = Math.min(oy, getTopHeight());

        updateEulaScroll();
    });



    eulaScrollbarY.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            eulaScrollbarY.moving = true;
            eulaScrollbarY.yStart = eulaScrollbarY.offsetTop;
            eulaScrollbarY.hStart = eulaScrollbarY.offsetHeight;
            eulaScrollbarY.pStart = e.clientY;
            eulaScrollbarY.setPointerCapture(e.pointerId);
    
            for (const node of graph.nodes)
                node.div.sly = node.div.offsetTop;
    
            eulaDialogContent.topStart = eulaDialogContent.offsetTop;
        }
    });
    
    
    
    eulaScrollbarY.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && eulaScrollbarY.moving)
        {
            eulaScrollbarY.moving = false;
            eulaScrollbarY.releasePointerCapture(e.pointerId);
 
            let bounds = Rect.NaN;
    
            for (const node of graph.nodes)
                bounds = expandRect(bounds, boundingRect(node.div));
    
            // if (bounds.t >= 0 && bounds.b < eulaDialog.clientHeight)
            //     eulaScrollbarY.style.display = 'none';
        }
    });
    
    
    
    eulaScrollbarY.addEventListener('pointermove', e =>
    {
        if (eulaScrollbarY.moving)
            updateEulaScrollbar(e.clientY);
    });
}



function showEulaDialog()
{
    eulaBack  .style.display = 'block';
    eulaDialog.style.display = 'block';

    updateEulaScroll();

    dialogShown = true;
}



function hideEulaDialog()
{
    eulaBack  .style.display = 'none';
    eulaDialog.style.display = 'none';

    dialogShown = false;
}



/////////////////////////////////////////////////////////////////////////////////////



function updateEulaScrollbar(clientY)
{
    let t = eulaScrollbarY.yStart + clientY - eulaScrollbarY.pStart;
    let b = t + eulaScrollbarY.hStart;

    t = Math.max(eulaTitle.clientHeight + smallScrollGap, t);
    b = Math.min(b, eulaDialogContainer.clientHeight - largeScrollGap);

    t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
    b = Math.max(t + smallScrollGap, b);


    let oy = 
          eulaDialogContent.topStart 
        - (clientY - eulaScrollbarY.pStart) / eulaScrollbarY.hStart * eulaDialogContainer.clientHeight;

    oy = Math.max(oy, eulaDialogContainer.clientHeight - eulaDialogContent.clientHeight + eulaTitle.clientHeight);


    eulaDialogContent.style.top = Math.min(
        oy,
        getTopHeight());


    updateEulaScroll();
}



function updateEulaScroll()
{
    const x       = eulaDialog.clientLeft;
    const w       = eulaDialog.clientWidth;
    const h       = eulaDialogContainer.clientHeight;
    const yOffset = getTopHeight();
    
    const bounds = eulaDialogContent.getBoundingClientRect();
    
    updateEulaScrollY(x, w, h, bounds, yOffset);
}



function updateEulaScrollY(x, w, h, bounds, yOffset)
{
    if (   /*eulaDialog.mouseOver
        &&*/ bounds.bottom - bounds.top > h)
    {
        const height = sqr(h) / bounds.height - 2*smallScrollGap;

        eulaScrollbarY.style.display = 'inline-block';
        eulaScrollbarY.style.height  =  height;
        eulaScrollbarY.style.left    =  x + w - smallScrollGap - 6;
        eulaScrollbarY.style.top     =  yOffset - (bounds.top - 100) * h / bounds.height;
    }
    else
       eulaScrollbarY.style.display = 'none';
}


var minZoomDialogVisible = false;



function showMinZoomDialog()
{
    minZoomDialog.style.left      = '50%';
    minZoomDialog.style.top       = '50%';
    minZoomDialog.style.transform = 'translateX(-50%) translateY(-50%)';

    minZoomDialog.style.display   = 'block';
    minZoomDialogVisible          = true;
  
    minZoomTitle.buttonDown0      = false;
       
    minZoomTitle.moveStart        = point_NaN;
    minZoomTitle.pStart           = point_NaN;
    
    minZoomInput.value = numToString(settings.minZoomForParams * 100, -1) + '%';
    minZoomInput.select();

    window.setTimeout(() => document.getElementById('minZoomInput').focus(), 0);
}



function hideMinZoomDialog()
{
    minZoomDialog.style.display = 'none';
    minZoomDialogVisible        = false;
}



minZoomClose.addEventListener('pointerdown', e => e.stopPropagation());



minZoomTitle.addEventListener('pointerdown', e => 
{
    minZoomTitle.setPointerCapture(e.pointerId);
    minZoomTitle.buttonDown0 = true;

    minZoomTitle.moveStart = point(minZoomDialog.offsetLeft, minZoomDialog.offsetTop);
    minZoomTitle.pStart    = point(e.clientX, e.clientY);
});



minZoomTitle.addEventListener('pointermove', e =>
{
    if (minZoomTitle.buttonDown0)
    {
        minZoomDialog.style.left = (minZoomTitle.moveStart.x + (e.clientX - minZoomTitle.pStart.x)) + 'px';
        minZoomDialog.style.top  = (minZoomTitle.moveStart.y + (e.clientY - minZoomTitle.pStart.y)) + 'px';
    }
});



minZoomTitle.addEventListener('pointerup', e =>
{
    minZoomTitle.buttonDown0 = false;
    minZoomTitle.releasePointerCapture(e.pointerId);
});



minZoomInput.addEventListener('keydown', e => 
{
    e.stopPropagation();

    
    if (   (   e.key < '0' 
            || e.key > '9')
        &&  e.key != '.'
        &&  e.key != '%'
        &&  e.code != 'Backspace'
        &&  e.code != 'Delete'
        &&  e.code != 'Enter'
        &&  e.code != 'NumpadEnter'
        && !isArrowKey(e.code))
        e.preventDefault();    
        
        
    switch (e.code)
    {
        case 'Enter':
        case 'NumpadEnter':
        {
            const minZoom = parseFloat(minZoomInput.value.replace('%', ''));

            if (!isNaN(minZoom))
            {
                updateSetting('minZoomForParams', minZoom / 100);
                uiSetLocalData('minZoomForParams', settings.minZoomForParams);
                
                updateZoomIcon();
            }

            hideMinZoomDialog();
            break;
        }
    }
});



minZoomInput.addEventListener('pointerup', e =>
{
    e.stopPropagation();

    if (e.button == 2)
    {
        initTextMenu(minZoomInput);
        menuText.showAt(e.clientX, e.clientY, false, false);
    }
});



var saveAsTemplateDialogVisible = false;



function showSaveAsTemplateDialog()
{
    saveAsTemplateDialog.copiedJson      = uiCopyNodes(graphView.selectedNodes.map(n => n.id));


    saveAsTemplateBack.addEventListener('pointerdown', e => { e.preventDefault(); });


    saveAsTemplateDialog.style.left      = '50%';
    saveAsTemplateDialog.style.top       = '50%';
    saveAsTemplateDialog.style.transform = 'translateX(-50%) translateY(-50%)';

    saveAsTemplateBack  .style.display   = 'block';
    saveAsTemplateDialog.style.display   = 'block';
    saveAsTemplateDialogVisible          = true;
  
    saveAsTemplateTitle.buttonDown0      = false;
       
    saveAsTemplateTitle.moveStart        = point_NaN;
    saveAsTemplateTitle.pStart           = point_NaN;
    
    // TODO suggest correct template name with increment

    saveAsTemplateInput.value            = 'template';
    saveAsTemplateInput.select();

    updateSaveAsTemplateInputBack();


    window.setTimeout(() => document.getElementById('saveAsTemplateInput').focus(), 0);
}



function hideSaveAsTemplateDialog()
{
    saveAsTemplateDialog.style.display = 'none';
    saveAsTemplateBack  .style.display = 'none';

    saveAsTemplateDialogVisible        = false;
}



saveAsTemplateClose.addEventListener('pointerdown', e => e.stopPropagation());


saveAsTemplateTitle.addEventListener('pointerdown', e => 
{
    saveAsTemplateTitle.setPointerCapture(e.pointerId);
    saveAsTemplateTitle.buttonDown0 = true;

    saveAsTemplateTitle.moveStart = point(saveAsTemplateDialog.offsetLeft, saveAsTemplateDialog.offsetTop);
    saveAsTemplateTitle.pStart    = point(e.clientX, e.clientY);
});



saveAsTemplateTitle.addEventListener('pointermove', e =>
{
    if (saveAsTemplateTitle.buttonDown0)
    {
        saveAsTemplateDialog.style.left = (saveAsTemplateTitle.moveStart.x + (e.clientX - saveAsTemplateTitle.pStart.x)) + 'px';
        saveAsTemplateDialog.style.top  = (saveAsTemplateTitle.moveStart.y + (e.clientY - saveAsTemplateTitle.pStart.y)) + 'px';
    }
});



saveAsTemplateTitle.addEventListener('pointerup', e =>
{
    saveAsTemplateTitle.buttonDown0 = false;
    saveAsTemplateTitle.releasePointerCapture(e.pointerId);
});



saveAsTemplateInput.addEventListener('keydown', e => 
{
    e.stopPropagation();

    if (e.code == 'Enter')
    {
        saveSelectedAsTemplate(saveAsTemplateInput.value); 
        hideSaveAsTemplateDialog();
    }
    else if (e.code == 'Escape')
        hideSaveAsTemplateDialog();
});



saveAsTemplateInput.addEventListener('input', () =>
{
    updateSaveAsTemplateInputBack();
});



function updateSaveAsTemplateInputBack()
{
    saveAsTemplateInputBack.innerHTML          = saveAsTemplateInput.value == '' ? 'Node IDs' : '';
    saveAsTemplateInputBack.style.borderBottom = saveAsTemplateInput.value == '' ? '1px solid var(--figma-color-bg-tertiary)' : 'none';
}



saveAsTemplateInput.addEventListener('pointerup', () =>
{
    saveAsTemplateInput.select();
});



function saveSelectedAsTemplate(templateName)
{
    uiQueueMessageToFigma({
        cmd:         'figSaveLocalTemplate',
        templateName: templateName,
        template:     saveAsTemplateDialog.copiedJson
    });

    // TODO
    // increment name if exists
    // or warn and don't close dialog if it doesn't



    // str = str.replace(',', ' ');
    
    // const nodeIds = str.split(' ').filter(i => i);

    // uiRemoveConnsToNodes(nodeIds);

    // if (!isEmpty(nodeIds))
    //hideSaveAsTemplateDialog();

    uiNotify('Saved template \'' + templateName + '\'');
}


var subscription            = NULL;
var checkoutTimer           = -1;
var subscriptionDialogShown = false;



function onSubscribeClick()
{
    let checkoutSession = arrayToBase32(sign(hashLicenseString(
        currentUser.id + (new Date().getTime()).toString(),
        30), licenseKeys.private));


    const response = postToServer(
    {
        action: 'createCheckout',
        userId:  currentUser.id,
        session: checkoutSession
    }); 
    

    if (   response
        && response.result)
    {
        window.open('https://brainshift.design/generator/checkout.html?' + checkoutSession, '_blank');

        checkoutTimer = setInterval(() => 
        {
            checkLastSub().then(lastSub =>
            {
                if (   lastSub
                    && lastSub.daysLeft > 0)
                    uiRestartGenerator(false);
            });
        }, 
        4000);
    }
    else
    {
        console.error('Could not create create Generator checkout session.')
    }
}



function showSubscriptionDialog(showBack = true)
{
    subscriptionBack  .style.display = 'block';
    subscriptionDialog.style.display = 'block';

    subscriptionBack.style.backgroundColor = showBack ? '#0005' : 'transparent';
    
    updateLicenseInfo()
        // subscription != NULL
        // ? validateLicense(currentUser.id, subscription)
        // : null)
    .then(() => 
    {
        dialogShown             = true;
        subscriptionDialogShown = true;
    });
}



function hideSubscriptionDialog()
{
    if (checkoutTimer >= 0)
        clearInterval(checkoutTimer);

    subscriptionBack  .style.display = 'none';
    subscriptionDialog.style.display = 'none';

    dialogShown             = false;
    subscriptionDialogShown = false;
}



subscriptionClose.addEventListener('pointerdown', e => e.stopPropagation());



async function updateLicenseInfo()
{
    const lastSub       = await checkLastSub();
    const trialDaysLeft = await checkRemainingTrialDays();


    if (   lastSub
        && lastSub.daysLeft > 0)
    {
        const daysLeft = formatDaysLeft(lastSub.daysLeft);

        licenseInfo.innerHTML            = daysLeft + ' of your Pro subscription.';
     
        licenseInfo.style.top            = '55%';
        licenseInfo.style.transform      = 'translateX(-50%) translateY(-50%)';

        // aboutUserId.style.display = 'none';
        btnSubscribe      .style.display = 'none';

        if (checkoutTimer >= 0)
            clearInterval(checkoutTimer);
    }
    else     
    {
        const daysLeft =
            lastSub
            ? formatDaysLeft(lastSub.daysLeft)
            : trialDaysLeft;

        const expDays   = Math.abs  (daysLeft);
        const expWeeks  = Math.round(expDays / 7);
        const expMonths = Math.round(expDays / 30.5);
        const expYears  = Math.round(expDays / 365)

        let expired;

             if (expYears  > 0) expired = 'expired ' + expYears  + ' ' + countString(expYears,  'year' ) + ' ago';
        else if (expMonths > 0) expired = 'expired ' + expMonths + ' ' + countString(expMonths, 'month') + ' ago';
        else if (expWeeks  > 0) expired = 'expired ' + expWeeks  + ' ' + countString(expWeeks,  'week' ) + ' ago';
        else if (expDays   > 1) expired = 'expired ' + expDays   + ' ' + countString(expDays,   'day'  ) + ' ago';
        else                    expired = 'has expired';


        const subOrTrial = lastSub ? 'subscription' : 'free trial';

        //licenseInfo.innerHTML            = 'Your ' + subOrTrial + ' ' + expired + '.<br/><br/>Please subscribe to continue using Generator.';
        
        licenseInfo.innerHTML            = 'If Generator is useful to you,<br/>subscribe to access Pro features<br/>and support further development.';

        licenseInfo.style.top            = '70px';
        licenseInfo.style.transform      = 'translateX(-50%)';

        // aboutUserId.style.display = 'none';
        btnSubscribe      .style.display = 'block';
    }
}



function formatDaysLeft(daysLeft)
{
    return daysLeft == 1
        ? 'Last day'
        :  daysLeft + ' ' + countString(daysLeft, 'day') + ' left';

}




////////////////////////////////////////////////////

</script>
