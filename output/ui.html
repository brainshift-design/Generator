<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<style>


body
{
    margin: 0;
}

#container
{
    display: table-column;
}

div
{
    margin:  0;
    padding: 0;
}


.slider
{
    padding:        0;
    width:          74px;
    height:         24px;
    border:         1px solid transparent;
    border-bottom:  1px solid rgba(0, 0, 0, 0.1);
    border-radius:  2px;
    overflow:       hidden;
}    

.sliderBar
{
    position:       absolute;
    pointer-events: none;
}

.slider .sliderText
{
    position:       absolute;
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
}

.slider:hover
{
    border: 1px solid rgba(0, 0, 0, 0.1);
}    

.slider:focus
{
    outline: none;
    box-shadow: 0 0 0 2px #18A0FB;
}    


</style>

<div id='container'>

    <h1>Generator</h1>

</div>





<script>

////////////////////////////////////////////////////





const R = 0, G = 1, B = 2, A = 3;
const Eps = 0.0000001;

function nozero(x)
{
    return x != 0 ? x : Eps;
}


function getDigitCount(i)
{
    var l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}


function isDigit(key)
{
    var is = 
           key >= '0' 
        && key <= '9';

    return is;
}

function isHexLetter(key)
{
    var is =
           key.length == 1
        && (   key >= 'A' && key <= 'F'
            || key >= 'a' && key <= 'f');

    return is;
}


function getNumberString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (i < str.length && str[i] !== '.' && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
    str = str.substring(0, i--);
    
    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales    
    str = str.substring(0, i--);
    
    return str;
}    


function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (var property in properties)
        elem.style[property] = properties[property];
}


function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}

function containsChild(parent, child)
{
    return child.parentNode == parent;
}


function forwardEvent(element, event)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}


// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });

//     element.dispatchEvent(e);
// }


function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}


function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}


function colorStyle(rgb)
{
    return colorStyle_(rgb[R], rgb[G], rgb[B], 1);
}


function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}



function loadState(state)
{
    resizeWindow(
        window.innerWidth, 
        state.windowHeight);
}    


function save(key, value)
{
    parent.postMessage({ pluginMessage:
    { 
        cmd:   'save', 
        key:   key,
        value: value
    }}, '*');
}


function saveState()
{
    save('state',
    {
        //windowHeight: window.innerHeight
    });
}


class Input
{
    _op;
    
    #dataType;

    #connection;

    constructor(dataType)
    {
        this.#dataType = dataType;
    }

    get connection() { return this.#connection; }
    set connection(conn)
    {
        this.#connection = conn;
    }
}


class Output
{
    _op;

    #dataType;

    #connections = {};

    constructor(dataType)
    {
        this.#dataType = dataType;
    }

    get connections() { return this.#connections; }

    addConnection(conn)
    {
        this.#connections.push(conn);
    }

    removeConnection(conn)
    {
        var index = this.#connections.indexOf(conn);

        if (index >= 0)
            this.#connections.slice(index, 1);
    }
}


class Connection
{
    constructor()
    {
        
    }
}


class Parameter
{
    #type;
    _control;

    constructor(type)
    {
        this.#type = type;
    }

    get type()    { return this.#type;    }
    get control() { return this._control; }
}


class   ValueParam
extends Parameter
{
    constructor(name, min, max)
    {
        super('value');

        this._control = document.createElement('div');

        initSlider(
            this._control,
            100,  // width
            20,   // height
            name, 
            min,
            max,
            50,   // default
            0.01, // drag scale
            1,    // wheel step
            0,    // decimals
            0,    // acceleration
            '');  // suffix
    }
}


class Operator
{
    #type;
    get type() { return this.#type; }


    _id;
    _graph = null;
    
    params = new Array();
    
    inputs = new Array();
    output;


    div; // container for the op's controls


    constructor(type)
    {
        this.#type = type;
        this._id   = type; // this is a temp until the op becomes a graph node

        this.createDiv();
    }    
    
    
    createDiv()
    {
        this.div = document.createElement('div');
        this.div.op = this;

        this.div.style.display   = 'inline-block';
        this.div.style.position  = 'absolute';
        this.div.style.width     = 100;
        this.div.style.height    = 'auto';
        //this.div.style.border = '1px solid red';
        
        this.div.dragging = false;
        
    
        this.div.addEventListener('pointerdown', function(e) 
        {
            if (e.button == 0)
            {
                this.sx  = e.clientX;
                this.sy  = e.clientY;
                this.slx = this.offsetLeft;
                this.sly = this.offsetTop;
    
                this.dragging = true;
                this.setPointerCapture(e.pointerId);
            }
        });
    
        this.div.addEventListener('pointermove', function(e) 
        {
            if (this.dragging)
            {
                this.op.setDivPosition(
                    this.slx + e.clientX - this.sx,
                    this.sly + e.clientY - this.sy);
            };
        });
    
        this.div.addEventListener('pointerup', function(e) 
        {
            if (   e.button == 0
                && this.dragging)
            {
                this.dragging = false;
                this.releasePointerCapture(e.pointerId);
            }
        });
        
        
        this.createDivLabel();
    }     


    createDivLabel()
    {
        var label = document.createElement('div');
        
        label.innerHTML          = this.id;
           
        label.style.fontFamily   = 'Inter';
        label.style.fontSize     = '11';
        label.style.paddingLeft  = '4px';
        label.style.display      = 'inline-block';
        label.style.width        = 'calc(100% - 2px)';
        label.style.height       = 15;
        label.style.background   = '#a3d3fd';
        label.style.borderRadius = '4px 4px 0 0';
        label.style.color        = 'black';
        
        this.div.appendChild(label);
    }
    

    setDivPosition(x, y)
    {
        this.div.style.left = x;
        this.div.style.top  = y;
    }


    addParam(param)
    {
        this.params.push(param);

        param.control.style.display = 'inline-block';
        
        this.div.appendChild(param.control);
    }
 
    
    get id() { return this._id;   }


    setId(newId)
    {
        if (this.graph.nodes.indexOf(newId) >= 0)
            return false; // graph already contains a node with this id

        this._id = newId;
        return true;
    }


    update()
    {

    }
}


class   OpRect
extends Operator
{
    #width;
    #height;

    constructor()
    {
        super('rect');

        this.#width = new ValueParam('Width',  0, Number.MAX_SAFE_INTEGER);
        this.addParam(this.#width);

        this.#height = new ValueParam('Height', 0, Number.MAX_SAFE_INTEGER);
        this.addParam(this.#height);
    }

    update()
    {
        // TODO add an "update this rect" instruction to the update list,
        // maybe through super.update('instruction')
        super.update();
    }
}


class   OpSpread 
extends Operator
{
    #radius;
    #density;

    constructor()
    {
        super('spread');

        this.#radius = new ValueParam('Radius',  0, Number.MAX_SAFE_INTEGER);
        this.addParam(this.#radius);

        this.#density = new ValueParam('Density', 0, Number.MAX_SAFE_INTEGER);
        this.addParam(this.#density);
    }

    update()
    {
        // TODO add an "update this spread" instruction to the update list,
        // maybe through super.update('instruction')
        super.update();
    }
}


function initSlider(slider, width, height, name, min, max, def, dragScale, wheelStep, dec, acc, suffix = '', log = false, backColor = '#fff', valueColor = '#eee', fontSize = 11)
{
    slider.className         = 'slider';

    slider.width             = width;
    slider.height            = height;
        
    slider.style.width       = width;
    slider.style.height      = height;
        
    slider.min               = min;
    slider.max               = max;
    slider.value             = def;
    slider.dec               = dec;
    slider.editDec           = dec;
    slider.acc               = acc;
               
    slider.name              = name;
    slider.suffix            = suffix;
    slider.log               = log;

    slider.dragScale         = dragScale;
    slider.wheelStep         = wheelStep;
        
    slider.backColor         = backColor;
    slider.valueColor        = valueColor;
           
    slider.fontSize          = fontSize;
        
    slider.style.display     = 'inline';
        
    slider.mouseOver         = false;
    slider.buttonDown0       = false;
        
    slider.clickSize         = 4;
    slider.moved             = false;
    
    slider.tabIndex          = 0;
    slider.inFocus           = false;
    slider.clicked           = false;

    slider.wrapValue         = false;
    
    slider.enableChangeEvent = true;

    initSliderChildren(slider);    
    initSliderTextbox(slider);
    
    //

    slider.onchange = new Event('onchange');

    //

    slider.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault(); // this is fine since I capture the pointer anyway
            e.stopPropagation();

            slider.buttonDown0  = true;
            slider.buttonDown0_ = true;
            slider.moved        = false;
            slider.clientX      = 0;
            slider.sx           = e.clientX;
            slider.sv           = slider.value;

            slider.style.border = '1px solid #18A0FB';
                        
            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();

            slider.clickTimer = setTimeout(function() 
            {
                //slider.clickId = e.pointerId;
                onSliderClickTimer(slider); 
            }, 500);
        }
    });

    slider.addEventListener('losecapture', function()
    {
        slider.buttonDown0 = false;
        slider.mouseOver  = false;
        slider.update();
    });

    slider.addEventListener('pointerup', function(e)
    {
        clearTimeout(slider.clickTimer);

        if (   slider.moved
            || document.menuHadFocus)
        {
            slider.unlockPointer(e.pointerId);
            return;            
        }    

        if (slider.buttonDown0_)
        {
            slider.clicked = true;
            slider.showTextbox();
        }
        
        slider.buttonDown0_ = false;
    });    


    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && slider.buttonDown0)
        {
            slider.buttonDown0 = false;
            slider.unlockPointer(e.pointerId);
            slider.style.border = '1px solid rgba(0, 0, 0, 0.1)';
        }
    });


    slider.addEventListener('pointermove', function(e)
    {
        var rect = slider.getBoundingClientRect();
        
        slider.mouseOver = 
        e.clientX >= rect.left
        && e.clientX <  rect.right
        && e.clientY >= rect.top
        && e.clientY <  rect.bottom;
        
        slider.clientX = e.clientX;
        
        if (slider.buttonDown0)
        {
            if (slider.isPointerLocked())
            {
                slider.movedX += e.movementX;
                
                var dx       = slider.sx - slider.movedX;
                var adaptive = 10 * Math.pow(Math.abs(dx), slider.acc);
                
                // TODO: if (log) do log scaling
                slider.setValue(slider.sv - dx*slider.dragScale*adaptive);
            }
            else
            {
                if (Math.abs(e.clientX - slider.sx) > slider.clickSize/2)
                {
                    slider.moved = true;
                    slider.lockPointer();//e.pointerId);
                }
            }
        }
        
        slider.update();
    });
    
    slider.addEventListener('mousewheel', function(e)
    {
        slider.setValue(slider.value + (e.wheelDeltaY > 0 ? 1 : -1) * slider.wheelStep);
    });

    
    slider.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter'
        || e.code == 'NumpadEnter')
            slider.showTextbox();

        else if (e.code == 'ArrowRight')
            slider.setValue(slider.value + (1+slider.dec));

        else if (e.code == 'ArrowLeft')
            slider.setValue(slider.value - (1+slider.dec));
    });


    slider.addEventListener('focus', function()
    {
        slider.showTextbox();
    });

    //

    slider.setValue = function(value, fireChangeEvent = true)
    {
        if (slider.wrapValue)
        {
            while (value < slider.min) value += slider.max - slider.min;
            while (value > slider.max) value -= slider.max - slider.min;
        }
        else
        value = Math.min(Math.max(slider.min, value), slider.max);
        
        
        slider.value = value;
        
        
        var v  = value / (slider.max - slider.min);
        var cx = -slider.min / (slider.max - slider.min) * slider.clientWidth;
        
        slider.bar.style.background = slider.valueColor;
        
        if (v >= 0)
        {
            slider.bar.style.left  = 1 + slider.offsetLeft + Math.round(cx);
            slider.bar.style.width = Math.round(v * slider.clientWidth);
        }
        else
        {
            slider.bar.style.left  = slider.offsetLeft + cx + v * slider.clientWidth;
            slider.bar.style.width = -v * slider.clientWidth;
        }
        
        slider.bar.style.background =
        slider.value >= 0
        ? slider.valueColor
        : 'repeating-linear-gradient(-60deg, #fff, #fff 1px, #e5e5e5 2px, #e5e5e5 3px, #fff 4px)';
        
        slider.bar.style.height = slider.clientHeight;
        
        slider.text.innerHTML = slider.name + "&nbsp;&nbsp;" + getNumberString(value, slider.dec) + slider.suffix;

        slider.text.style.left = slider.offsetLeft + Math.floor((slider.clientWidth  - slider.text.offsetWidth ) / 2);
        slider.text.style.top  = slider.offsetTop  + Math.floor((slider.clientHeight - slider.text.offsetHeight) / 2) + 1;

        if (   fireChangeEvent
            && slider.enableChangeEvent)
            slider.dispatchEvent(slider.onchange);
    };


    slider.update = function()
    {
        slider.setValue(slider.value, false);
    }


    slider.lockPointer = function()//pointerId)
    {
        slider.requestPointerLock =    
               slider.requestPointerLock 
            || slider.mozRequestPointerLock;

        slider.requestPointerLock();
        //slider.setPointerCapture(pointerId);
        clearTimeout(slider.clickTimer);

        slider.movedX = 0;
        slider.sx     = 0;
    };

    slider.unlockPointer = function()//pointerId)
    {
        document.exitPointerLock =    
               document.exitPointerLock    
            || document.mozExitPointerLock;

        document.exitPointerLock();
        //slider.releasePointerCapture(pointerId);
    };

    slider.isPointerLocked = function()//pointerId)
    {
        //return slider.hasPointerCapture(pointerId);

        return (document.pointerLockElement    === slider 
             || document.mozPointerLockElement === slider);
    }
    
    //

    slider.update();
}


function initSliderChildren(slider)
{
    slider.bar = document.createElement('div');
    slider.bar.className = 'sliderBar';

    slider.text = document.createElement('div');
    slider.text.className = 'sliderText';

    slider.appendChild(slider.bar);
    slider.appendChild(slider.text);
}


function onSliderClickTimer(slider)
{
    if (!document.menuHadFocus)
    {
        slider.moved = true;
        slider.lockPointer();//slider.clickId);
        //slider.clickId = null;
    }
}


function initSliderTextbox(slider)
{
    slider.textbox = document.createElement('INPUT');
    slider.textbox.setAttribute('type', 'text'); 
    slider.textbox.className = 'sliderTextbox';
    
    slider.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            slider.textbox.finish(true);

        else if (e.code == 'Escape')
            slider.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.slider, .figmaSelect, #hexValue, button');
            var index = slider.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && slider.min < 0))
                e.preventDefault();

            var t = slider.textbox;

            var curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            var nextVal = parseFloat(curVal + e.key);

            if (   nextVal < slider.min - 0.001
                || nextVal > slider.max)
                e.preventDefault();            
        }
    });


    slider.textbox.addEventListener('input', function()
    {
        slider.setValue(Number(slider.textbox.value));
    });

    slider.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(slider.min, val), slider.max);

        slider.textbox.value = val;
    });

    slider.textbox.addEventListener('focusout', function()
    {
        slider.parentNode.removeChild(slider.textbox);
        slider.clicked = false;
    });
    
    slider.textbox.finish = function(success)
    {
        if (success)
            slider.setValue(Number(slider.textbox.value), false);
        else
            slider.setValue(Number(slider.textbox.savedValue), true);

        slider.textbox.blur();

        if (slider.inFocus)
            slider.focus();
    };    
    
    
    slider.showTextbox = function()
    {
        slider.inFocus = 
                slider == document.activeElement
            && !slider.clicked;
    
        slider.textbox.style.position = 'absolute';
    
        slider.textbox.style.left      = slider.offsetLeft   + 1;
        slider.textbox.style.top       = slider.offsetTop    + 1;
        slider.textbox.style.width     = slider.offsetWidth  - 2;
        slider.textbox.style.height    = slider.offsetHeight - 2;
        slider.textbox.style.boxShadow = '0 0 0 2px #18A0FB';
        slider.textbox.style.outline   = 'none';
    
        slider.textbox.style.textAlign = 'center';
    
        slider.textbox.value = numToString(slider.value, slider.editDec);
        slider.textbox.savedValue = slider.textbox.value;
        
        slider.parentNode.appendChild(slider.textbox);
        
        slider.textbox.focus();
        slider.textbox.select();
    }
}


function updateCanvas()
{
    // build updated geometry description, with info about
    // whether to modify or recreate (for example, spread density change = modify,
    // spread count change = recreate, and this might be detailed further)


    // pass this info to the canvas
}


class Graph
{
    nodes       = new Array();
    #activeNode = null;

    addNode(node)
    {
        this.nodes.push(node);
        
        node._id    = this.getNewId(node.type);
        node._graph = this;

        document.body.appendChild(node.div);

        this.activeNode = node;
    }


    get activeNode() { return this.#activeNode; }
    set activeNode(node)
    {
        this.#activeNode = node;
        updateCanvas(this); // send this graph to be created in the canvas
    }


    getNewId(type)
    {
        var maxNum = 0;

        for (const node of this.nodes)
        {
            if (   node.id.length < type.length
                || node.id.substring(0, type.length) !== type)
                continue;

            var num = parseInt(node.id.substring(type.length));
            if (num == 0) num = 1;

            maxNum = Math.max(num, maxNum);
        }

        if (maxNum == 0)
            return type;

        maxNum++;

        return type + maxNum;
    }
}


const resizeEdgeWidth = 8;

document.canResizeX = false;
document.canResizeY = false;

document.resizingX  = false;
document.resizingY  = false;

document.startX     = 0;
document.startY     = 0;

document.startH     = 0;
document.startW     = 0;


document.addEventListener('pointerdown', function(e)
{
    if (   document.canResizeX
        || document.canResizeY)
    {
        if (document.canResizeX) document.resizingX = true;
        if (document.canResizeY) document.resizingY = true;

        document.startX   = e.clientX;
        document.startY   = e.clientY;

        document.startW   = window.innerWidth;
        document.startH   = window.innerHeight;

        document.body.setPointerCapture(e.pointerId);
    }
});


document.addEventListener('pointermove', function(e)
{
    if (   document.resizingX
        && document.resizingY)
    {
        resizeWindow(
            document.startW + e.clientX - document.startX,
            document.startH + e.clientY - document.startY);
    }
    else if (document.resizingX)
    {
        resizeWindow(
            document.startW + e.clientX - document.startX,
            document.body.clientHeight);
    }
    else if (document.resizingY)
    {
        resizeWindow(
            document.body.clientWidth,
            document.startH + e.clientY - document.startY);
    }
    else
        checkResize(e.clientX, e.clientY);
});


document.addEventListener('pointerup', function(e)
{
    if (   document.resizingX
        || document.resizingY)
    {
        document.resizingX = false;
        document.resizingY = false;
        
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }
});


function resizeWindow(width, height)
{
    parent.postMessage({ pluginMessage: 
    { 
        cmd:    'resizeWindow', 
        width:  width,
        height: height
    }}, '*');

}


function checkResize(x, y)
{
    document.canResizeX = document.body.clientWidth  - x <= resizeEdgeWidth;
    document.canResizeY = document.body.clientHeight - y <= resizeEdgeWidth;

         if (document.canResizeX
          && document.canResizeY) document.body.style.cursor = 'nwse-resize';
    else if (document.canResizeX) document.body.style.cursor = 'ew-resize';
    else if (document.canResizeY) document.body.style.cursor = 'ns-resize';
    else                          document.body.style.cursor = 'auto';
}


//save('state', null);
//save('windowWidth', null);
//save('windowHeight', null);


parent.postMessage({ pluginMessage: 
{ 
    cmd:    'loadState',
    onLoad: 'loadState'
}}, '*');


onmessage = (e) =>
{
    var msg = e.data.pluginMessage;
}


/////////////////////////////////////////////////////////


var graph = new Graph();

graph.addNode(new OpRect());
//graph.addNode(new OpSpread());

//updateCanvas(graph);




////////////////////////////////////////////////////

</script>
