<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>


.button
{
    font-family:   Inter;
    font-size:     11px;
    width:         30;
    height:        30;
    background:    white;
    min-width:     0;
    min-height:    0;
    border:        none;
    border-radius: 2px;
    position:      relative;
    padding:       0;
}


.button:hover
{
    background: #f0f0f0;
}


.button:active
{
    box-shadow: 0 0 0 2px var(--activeObjectColor) inset;
    outline:    none;
}


#controlBar
{
    display:          flex;
    height:           40px;
    background-color: #2c2c2c;
    /* vertical-align:   middle; */
    padding:          0;
}



#btnCreateNumber
{
    padding-left:  15px;
    padding-right: 35px;
}


#btnZoom
{
    position:      absolute;
    padding-left:  15px;
    padding-right: 45px;
}


#btnToggleWires
{
    position:            absolute;
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="%23d5d5d5" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="%23d5d5d5"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnToggleWires:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="white" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="white"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}



#btnCreateInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.3"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="%23d5d5d5"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="white"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="white"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.5"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="white"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateValidateColor
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="%23d5d5d5"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateValidateColor:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateWebContrast
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="%23d5d5d5" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateWebContrast:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="white" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorBlind
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15.2335" cy="15.4506" r="14.25" stroke="%23d5d5d5" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="7.63405" stroke="%23d5d5d5" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="1.75413" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorBlind:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15.2335" cy="15.4506" r="14.25" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="7.63405" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="1.75413" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#loadingOverlay
{
    position:   absolute;
    top:        0;
    left:       0;
    width:      100%;
    height:     100%;
    background: #e5e5e5;
    display:    none;
}


#loadingGraphic 
{
    font-family: Inter;
    font-size:   26;
    font-weight: 800;
    color:       #333;
    position:    absolute;
    left:        50%;
    top:         45%;
    transform:   translateX(-50%)
                 translateY(-50%);
}


#loadingEmpty
{
    font-size:   18;
    font-weight: 800;
    color:       #666;
    margin-right: 6px;
    position:     relative;
    top:          -4px;
}


#loadingFull
{
    font-size:   12;
    font-weight: 800;
    color:       #666;
    margin-left: 7px;
    position:     relative;
    top:          -6px;
}


#loadingBar
{
    position:      absolute;
    left:          50%;
    top:           50%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         180px;
    height:        5px;   
    background:    white;
    border-radius: 2.5px;
    overflow:      hidden;
}


#loadingProgress
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         0;
    height:        5px;   
    background:    #333;
}


.menuButton
{
    font-family:   Inter;
    font-size:     11px;
    width:         40px;
    height:        40px;
    background:    #2c2c2c;
    border-radius: 0;
    min-width:     0;
    min-height:    0;
    border:        none;
    position:      relative;
    padding:       0;
    padding-right: 2px;
    margin-right:  -4px;
    color:         #d5d5d5;
    overflow:      hidden;
    /* box-shadow:    0 0 0 1px red inset; */
}


.menuButton:hover
{
    background: black;
    color:      white;
}


.menuButton:focus
{
    background: var(--activeObjectColor);
    color:      white;
}


#productKeyBack
{
    display:          none;

    z-index:          1;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;

    background-color: #0002
}


#productKeyDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    top:           60px;
    left:          calc(50% - 130px);
    width:         220px;
    height:        170px;
    
    background:    white;
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);
    box-shadow:    0px 2px 14px rgba(0, 0, 0, 0.15);
    border-radius: 4px;
}


#productKeyTitle
{
    height:        40px;
    border-bottom: 1px solid rgb(0, 0, 0, 0.15);
}


#productKeyText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          rgba(0, 0, 0, 0.8);
}


#productKeyClose
{
    width:    32px;
    height:   32px;
    position: absolute;
    left:     calc(100% - 36px);
    top:      4px;
}

#productKeyClose:active
{
    box-shadow: none;
}


#productKeyUserInfo
{
    font-size:      12px;

    margin-top:     16px;
    margin-bottom:  12px;

    position:       relative;
    left:           21px;

    user-select:    text;
}


#productKeyWebsite
{
    font-size:      12px;
    text-align:     center;

    margin-top:     16px;
    margin-bottom:   8px;
}


#productKeyInput
{
    font-family:  'Roboto Mono';
    font-size:     16px;
     
    width:         calc(9em + 1px);
    padding-left:  10px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-bottom: -3px;

    position:      relative;
    left:          calc(50% - 4.5em);
}



#productKeyInputBack
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    color:          #ddd;
    
    width:           9em;
    padding-left:   10px;
    padding-top:    -2px;
    padding-bottom:  2px;

    position:       absolute;
    left:           calc(calc(50% - 4.5em) + 1px);
    top:            calc(50% + 2px);

    pointer-events: none;
}


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    padding-top:   1px; 
    height:        20px;
    line-height:   14px;
    border:        none;
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:focus
{
    box-shadow: 0 0 0 1px var(--activeObjectColor) inset;
    outline:    none;
}


input[type=text]::selection
{
    background-color: #b9e2fe;
    color:            black;
}


body
{
    margin:           0;
    background-color: #f4f4f4;
    user-select:      none;
    font-family:      Inter;

    -webkit-touch-callout: none; 
      -webkit-user-select: none; 
       -khtml-user-select: none; 
         -moz-user-select: none; 
          -ms-user-select: none; 
              user-select: none; 
}


div
{
    margin:  0;
    padding: 0;
}


.tooltip
{
    display:          none;
    opacity:          0;
    width:            auto;
    height:           15px;
    background-color: #040404;
    color:            #eee;
    border-radius:    2px;
    padding:          5px 10px 5px 10px;
    position:         absolute;
    z-index:          10000;
    bottom:           125%;
    left:             13px;
    top:              44px;
    font-family:      Inter;
    font-size:        11px;
    /* pointer-events:   none; */
}


#tooltipArrow
{
    content:      '';
    position:     absolute;
    margin-left:  -6px;
    border-width: 6px;
    border-style: solid;
    border-color: transparent transparent #040404 transparent;
    display:      none;
    opacity:      0%;
}


#ttCreateColorblind
{
    width:  200px; 
    height: 310px;
}


#ttInterpolationSpace
{
    width:  200px;
    height: 178px;
}


#ttWcag2
{
    width:  240px;
    height: 146px;
}



.wcag2description
{
    text-align:       left;
    position:         absolute;
    top:              70px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag2value
{
    position:  absolute;
    top:       109px;
    transform: translateX(-50%);
}


#wcag2info
{
    position:  absolute;
    left:      50%;
    top:       130px;
    transform: translateX(-50%);
}


#wcag2info a
{
    color: #6eb8e9
}


#ttWcag3
{
    width:  240px;
    height: 140px;
}


.wcag3description
{
    text-align:       left;
    position:         absolute;
    top:              62px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag3value
{
    position:  absolute;
    top:       101px;
    transform: translateX(-50%);
}


#wcag3info
{
    position:  absolute;
    left:      50%;
    top:       124px;
    transform: translateX(-50%);
}


#wcag3info a
{
    color: #6eb8e9
}


:root
{
    --activeObjectColor:    #18a0fb;
}


#selectBox
{
    outline:          1pt solid var(--activeObjectColor);
    background-color: #18A0FB20;
    pointer-events:   none;
    margin:           0;
    padding:          0;
    position:         absolute;
    visibility:       hidden;
}


#scrollbarX
{
    background-color: #a7a7a7;
    height:           6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);
}


#scrollbarY
{
    background-color: #a7a7a7;
    width:            6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);
}


:root
{
    --arithmeticSymbolSize: 26;
    --colorBackSize:        45px;
}


#graphView
{
    z-index:  0;
    display:  block;
    overflow: hidden;
    height:   calc(100% - 40px);
    position: relative;
}


#wireContainer
{
    position:       absolute;
    width:          100%;
    height:         calc(100% - 1px);
    z-index:        0;
    pointer-events: none;
    /* box-shadow: 0 0 0 1px red inset; */
}


#graphViewCapture
{
    position:   fixed;
    left:       0;
    top:        0;
    width:      100%;
    height:     calc(100% - 1px);
    z-index:    1;
    box-shadow: 0 0 0 1px green inset;
}


.toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="black"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="black"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.toggleButton:hover
{
    /* background:            url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 1C4.10457 1 5 1.89543 5 3V5H6V3C6 1.34315 4.65685 0 3 0C1.34315 0 0 1.34315 0 3V5H1V3C1 1.89543 1.89543 1 3 1Z" fill="black"/><path d="M5 9H6V11C6 12.6569 4.65685 14 3 14C1.34315 14 0 12.6569 0 11V9H1V11C1 12.1046 1.89543 13 3 13C4.10457 13 5 12.1046 5 11V9Z" fill="black"/><path d="M2.5 4V10H3.5V4H2.5Z" fill="black"/></svg>');
    background-position:   50% 50%;
    background-repeat:     no-repeat;
    background-blend-mode: multiply; */
    /* background-color:      #f0f0f0; */
    box-shadow: 0 0 0 1px #e6e6e6
}


.toggleButton:active
{
    box-shadow: 0 0 0 2px #18A0FB;
}


.numberSlider
{
    padding:          0;
    width:            74px;
    height:           26px;
    overflow:         hidden;
    background-color: white;
    text-align:       center;
    touch-action:     none;
}    


.numberSliderName
{
    color: #0006;
}


.numberSliderBar
{
    position:       absolute;
    pointer-events: none;
}


.numberSliderText
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    pointer-events:       none;
    letter-spacing:       -0.35px;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    top:                  3px;
    white-space:          nowrap;
}


.numberSliderText .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
}


.numberSliderTextbox
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    white-space:          nowrap;
    background-color:     transparent;
}


.numberSliderFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px var(--activeObjectColor) inset;
    visibility:     hidden;
    opacity:        0;
}


.numberSliderRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}




.menuSelect
{
    font-family:         Inter;
    font-size:           14;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         1;
    margin-right:        6;
    margin-top:          0;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
    color:               white;
}


.menuSelect:hover
{
    /* box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1); */
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) calc(50% + 3px);
    background-repeat:   no-repeat;
    padding-right:       30;
    transition:          all 0.2s ease;
}


.menuSelect:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.menuSelectText
{
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
    position:       relative;
    top:            3px;
}


.menuSelectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px  7px rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2 );
    /* overflow:      hidden; */
}


.menuSelectMenu::after 
{
    content:       '';
    position:      absolute;
    top:           -10px;
    left:          65px;
    border-width:  5px;
    border-style:  solid;
    border-color:  transparent transparent #222 transparent;
}




.select
{
    font-family:         Inter;
    font-size:           11;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         2;
    margin-right:        6;
    margin-top:          1;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.4"/> </svg>');
    background-position: calc(100% - 17px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
}


.select:hover
{
    box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1);
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 7px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
}


.select:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 6px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.selectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px 7px  rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2);
    overflow:      hidden;
}


.inputControls
{
    width:          12px;
    height:         auto;
    float:          left;
    margin-right:   auto;
    padding-top:    13px;
    /* box-shadow:     0 0 0 1px red inset; */
    pointer-events: none;
}


.input
{
    width:          6px;
    height:         6px;
    background:     transparent;
    border-radius:  3px;
    margin:         0;
    /* margin-left:    0px; */
    position:       absolute;
    left:           3px;
    pointer-events: none;
    box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12);
}


.inputBall
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    top:            50%;
    left:           50%;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.inputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: auto;
}


.node
{
    display:       block;
    position:      absolute;
    height:        auto;
    border-radius: 4px 4px 0 0;
    padding:       0;
    /* overflow:      visible; */
}


.nodeInner
{
    display:       block;
    position:      relative;
    width:         100%;
    height:        auto;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    padding:       0;
    box-shadow:    0 0 0 1px #0001;
    overflow:      visible;
}    


.nodeHeader
{
    background:    'magenta';
    display:       flex;
    width:         100%;
    position:      relative;
    border-radius: 4px 4px 0 0;
    z-index:       1;
    /* overflow:      visible; */
    /* box-shadow:    0 0 0 1px red inset; */
}


.nodeParamBack
{
    display:    block;
    position:   absolute;
    width:      100%;
    height:     20;
    background: #fffe;
    z-index:    -1;
}


.nodeLabelWrapper
{
    position:   absolute;
    width:      100%;
    height:     100%;   
    /* box-shadow: 0 0 0 1px blue inset; */
}


.nodeLabel
{
    font-family:    Inter;
    font-size:      11;
    padding:        0;
    margin:         0;
    display:        block;
    width:          auto;
    height:         14;
    text-align:     center;
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-50%) 
                    translateY(calc(-50% - 0.5px));
    pointer-events: none;
    z-index:        10;
    white-space:    nowrap;
    /* box-shadow:     0 0 0 1px red inset; */
}


.nodeLabelTextbox
{
    font-family: Inter;
    font-size:   11;
}


.nodeLabelTextbox::selection
{
    background-color: white;
}


.arithmeticSymbol
{
    font-family:    Inter;
    font-size:      20px;
    width:          auto;/*var(--arithmeticSymbolSize);*/
    height:         auto;/*var(--arithmeticSymbolSize);*/
    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);
    /* pointer-events: none; */
    /* box-shadow:     0 0 0 1px red inset; */
}


.colorWarningOverlay
{
    width:            100%;
    height:           var(--colorBackSize);
    z-index:          10;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.colorValueWarningOverlay
{
    width:            100%;
    z-index:          1000;
    position:         absolute;
    top:              var(--colorBackSize);
    pointer-events:   none;
}


.colorBack
{
    width:            100%;
    height:           var(--colorBackSize);
    z-index:          0;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.hexbox
{
    text-align:  center;
    width:       100%;
    background:  transparent;
    cursor:      default;
}


.hexbox:hover
{
    box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.1) inset;
}


.txtOrder
{
    text-align:  center;
    width:       100%;
    background:  transparent;
    cursor:      default;
}


.txtOrder:hover
{
    box-shadow: 0  1px 0 0 rgba(0, 0, 0, 0.1) inset,
                0 -1px 0 0 rgba(0, 0, 0, 0.1) inset;
}


.paramLock
{
    width:               11px;
    height:              11px;
    position:            absolute;
    display:             none;
}


.findColorCorrection
{
    display:             block;
    width:               10px;
    height:              10px;
    position:            absolute;
    left:                50%;
    top:                 50%;
    transform:           translateX(-50%)
                         translateY(-50%);
    /* box-shadow:          0 0 0 1 red inset; */
    background:          url('data:image/svg+xml;utf8,<svg width="10" height="10" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.10345 5.05172C8.10345 7.01329 6.51329 8.60345 4.55172 8.60345C2.59016 8.60345 1 7.01329 1 5.05172C1 3.09016 2.59016 1.5 4.55172 1.5C6.51329 1.5 8.10345 3.09016 8.10345 5.05172ZM7.39723 8.60458C6.61787 9.22958 5.62846 9.60345 4.55172 9.60345C2.03788 9.60345 0 7.56557 0 5.05172C0 2.53788 2.03788 0.5 4.55172 0.5C7.06557 0.5 9.10345 2.53788 9.10345 5.05172C9.10345 6.12858 8.72949 7.1181 8.10436 7.8975L11.3535 11.1467L10.6464 11.8538L7.39723 8.60458Z" fill="black" fill-opacity="0.8"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


.findBar
{
    position:      absolute;
    left:          50%;
    top:           66%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         46px;
    height:        3px;   
    background:    transparent;
    border-radius: 2.5px;
    overflow:      hidden;
    display:       none;
}


.findProgress
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         0;
    height:        5px;   
    background:    #333;
}


.asterisk
{
    font-size: 8px;
    position:  relative;
    top:       -2px;
}


.outputControls
{
    width:          12px;
    height:         auto;
    float:          right;
    margin-left:    auto;
    padding-top:    10px;
    /* box-shadow:     0 0 0 1px green inset; */
    pointer-events: none;
}


.output
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    /* margin-left:    3px; */
    position: absolute;
    right:          3px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.outputBall
{
    width:          6px;
    height:         6px;
    border-radius:  6px;
    margin:         0;
    position:       relative;
    top:            -12px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.outputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: auto;
}


</style>

<div id='controlBar'>
    
    <!-- <div id='menuSelect' style='margin-left: 10px;'></div> -->
    
    <!-- &nbsp;
    <button class='menuButton' id='btnLoad'                   onclick='graph.clear(); Operator.nextId = 0; uiGetPageData("graph"); this.blur();'>LOAD</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <button class='menuButton' id='btnSave'                   onclick='saveGraph(); this.blur();'>SAVE</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <button class='menuButton' id='btnCreateNumber'           onclick='actionManager.do(new CreateNodeAction("number",           btnCreateNumber));           this.blur();'><span style='font-size: 13px; letter-spacing: -0.05em;'>123</span></button>
    <button class='menuButton' id='btnCreateMinMax'           onclick='actionManager.do(new CreateNodeAction("minmax",           btnCreateMinMax));           this.blur();'><span style='font-size: 8px;'>MAX<br/>MIN</span></button>
    <button class='menuButton' id='btnCreateAdd'              onclick='actionManager.do(new CreateNodeAction("add",              btnCreateAdd));              this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'>+</span></button>
    <button class='menuButton' id='btnCreateSubtract'         onclick='actionManager.do(new CreateNodeAction("subtract",         btnCreateSubtract));         this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'>−</span></button>
    <button class='menuButton' id='btnCreateMultiply'         onclick='actionManager.do(new CreateNodeAction("multiply",         btnCreateMultiply));         this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'>×</span></button>
    <button class='menuButton' id='btnCreateDivide'           onclick='actionManager.do(new CreateNodeAction("divide",           btnCreateDivide));           this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'>÷</span></button>
    <button class='menuButton' id='btnCreateModulo'           onclick='actionManager.do(new CreateNodeAction("modulo",           btnCreateModulo));           this.blur();'><span style='font-size: 15px;'>%</span></button>
    <button class='menuButton' id='btnCreateExponent'         onclick='actionManager.do(new CreateNodeAction("exponent",         btnCreateExponent));         this.blur();'><span style='font-size: 16px;'>x<sup><sub><sup>y</sup></sub></sup></span></button>
    <button class='menuButton' id='btnCreateInterpolate'      onclick='actionManager.do(new CreateNodeAction("interpolate",      btnCreateInterpolate));      this.blur();'></button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <button class='menuButton' id='btnCreateColor'            onclick='actionManager.do(new CreateNodeAction("color",            btnCreateColor));            this.blur();'><span style='font-size: 17px;'>Ͼ</span></button>
    <button class='menuButton' id='btnCreateColorInterpolate' onclick='actionManager.do(new CreateNodeAction("colorinterpolate", btnCreateColorInterpolate)); this.blur();'></button>
    <button class='menuButton' id='btnCreateValidateColor'    onclick='actionManager.do(new CreateNodeAction("validatecolor",    btnCreateValidateColor));    this.blur();'></span></button>
    <button class='menuButton' id='btnCreateWebContrast'      onclick='actionManager.do(new CreateNodeAction("webcontrast",      btnCreateWebContrast));      this.blur();'></button>
    <button class='menuButton' id='btnCreateColorblind'       onclick='actionManager.do(new CreateNodeAction("colorblind",       btnCreateColorblind));       this.blur();'></button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <button class='menuButton' id='btnCreateRectangle'        onclick='actionManager.do(new CreateNodeAction("rectangle",        btnCreateRectangle));        this.blur();'>RECT</button>
    <button class='menuButton' id='btnCreateRow'              onclick='actionManager.do(new CreateNodeAction("row",              btnCreateRow));              this.blur();'>ROW</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <button class='menuButton' id='btnToggleWires'            onclick='graphView.toggleShowWires(); this.blur();'></button>

    <button class='menuButton' id='btnZoom'                   onclick='graphView.zoom = 1; this.blur();'></button>
    
</div>
    
<div id='selectBox'></div>

<div id='graphView'>
    <div id="wireContainer"></div>
    <div id='scrollbarX'></div>
    <div id='scrollbarY'></div>
</div>

<!-- <div id='graphViewCapture'></div> -->



<div id='loadingOverlay'>
    <div id='loadingGraphic'>
        <span id='loadingEmpty'>○</span>G<span id='loadingFull'>●</span>
    </div>
    <div id='loadingBar'>
        <div id='loadingProgress'></div>
    </div>
</div>


<div id='productKeyBack'></div>

<div id='productKeyDialog'>

    <div id='productKeyTitle'>
        <div id='productKeyText'>Enter product key</div>
        <div class='button' id='productKeyClose' onclick='productKeyClose.blur();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="black" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='productKeyBody'>
        <div id='productKeyUserInfo'></div>
        <input type='text' id='productKeyInput' />
        <div id='productKeyInputBack'></div>
        <div id='productKeyWebsite'>Get product key at<br/><a href='http://www.bourt.com/generator' target='_blank'>bourt.com/generator</a></div>
    </div>

</div>


<span id='tooltipArrow'></span>


<div id='ttCreateNumber'      class='tooltip'>Number</div>
<div id='ttCreateMinMax'      class='tooltip'>Limits</div>
<div id='ttCreateAdd'         class='tooltip'>Add</div>
<div id='ttCreateSubtract'    class='tooltip'>Subtract</div>
<div id='ttCreateMultiply'    class='tooltip'>Multiply</div>
<div id='ttCreateDivide'      class='tooltip'>Divide</div>
<div id='ttCreateModulo'      class='tooltip'>Remainder</div>
<div id='ttCreateExponent'    class='tooltip'>Power</div>
<div id='ttCreateInterpolate' class='tooltip'>Interpolate</div>


<div id='ttCreateColor' class='tooltip'>Color</div>
<div id='ttCreateColorInterpolate' class='tooltip'>Interpolate color</div>
<div id='ttCreateValidateColor' class='tooltip'>Validate color</div>
<div id='ttCreateWebContrast' class='tooltip'>Web contrast</div>

<div id='ttCreateColorblind' class='tooltip'>

    <div style="text-align: center;">Colorblind</div>
    
    <div style='margin-top: 14px; margin-bottom: 10px;'>
        Three receptor cone types in our eyes<br/>
        see <i>three calibers of light</i>&ThinSpace;:<br/><br/>
        <p style='margin-top: 4px; margin-bottom: 20px;'><b>S</b>mall, <b>M</b>edium and <b>L</b>arge.</p>
    </div>

    <svg width="189" height="97" viewBox="0 0 189 97" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: relative; left: 5px">
        <path d="M64.3525 17.3547C63.1278 17.3547 62.0721 1.13879 60.8053 1.13879C59.5384 1.13879 58.4827 17.3547 57.258 17.3547" stroke="white"/>
        <path d="M84.3644 10.4618C83.8577 8.49826 82.9076 1.13879 82.0886 1.13879C80.8217 1.13879 79.766 17.3547 78.5414 17.3547" stroke="white"/>
        <path d="M78.5414 17.3547C77.3167 17.3547 76.261 1.13879 74.9942 1.13879C73.7273 1.13879 72.6716 17.3547 71.4469 17.3547" stroke="white"/>
        <path d="M71.4469 17.3547C70.2223 17.3547 69.1666 1.13879 67.8997 1.13879C66.6328 1.13879 65.5771 17.3547 64.3525 17.3547" stroke="white"/>
        <path d="M35.9747 17.3547C34.75 17.3547 33.6943 1.13879 32.4274 1.13879C31.1606 1.13879 30.1049 17.3547 28.8802 17.3547" stroke="white"/>
        <path d="M57.258 17.3547C56.0334 17.3547 54.9776 1.13879 53.7108 1.13879C52.4439 1.13879 51.3882 17.3547 50.1635 17.3547" stroke="white"/>
        <path d="M50.1636 17.3547C48.9389 17.3547 47.8832 1.13879 46.6163 1.13879C45.3495 1.13879 44.2938 17.3547 43.0691 17.3547" stroke="white"/>
        <path d="M43.0691 17.3547C41.8445 17.3547 40.7887 1.13879 39.5219 1.13879C38.255 1.13879 37.1993 17.3547 35.9746 17.3547" stroke="white"/>
        <path d="M7.59684 17.3547C6.3722 17.3547 5.31647 1.13879 4.04961 1.13879C2.78274 1.13879 1.72702 17.3547 0.50238 17.3547" stroke="white"/>
        <path d="M28.8802 17.3547C27.6556 17.3547 26.5998 1.13879 25.333 1.13879C24.0661 1.13879 23.0104 17.3547 21.7857 17.3547" stroke="white"/>
        <path d="M21.7857 17.3547C20.5611 17.3547 19.5054 1.13879 18.2385 1.13879C16.9716 1.13879 15.9159 17.3547 14.6913 17.3547" stroke="white"/>
        <path d="M14.6913 17.3547C13.4666 17.3547 12.4109 1.13879 11.144 1.13879C9.87716 1.13879 8.82144 17.3547 7.5968 17.3547" stroke="white"/>
        <path d="M26.1023 49.8573C21.6833 49.8573 17.8738 28.2361 13.3023 28.2361C8.73093 28.2361 4.92142 49.8573 0.50238 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M97.2868 40.4082C95.3801 36.1644 93.2103 28.2361 90.1022 28.2361C85.5307 28.2361 81.7212 49.8573 77.3022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M77.3021 49.8573C72.8831 49.8573 69.0736 28.2361 64.5022 28.2361C59.9308 28.2361 56.1212 49.8573 51.7022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M51.7022 49.8573C47.2832 49.8573 43.4737 28.2361 38.9023 28.2361C34.3308 28.2361 30.5213 49.8573 26.1023 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M130.23 95.5318C119.033 95.5318 109.381 65.8027 97.7978 65.8027C86.215 65.8027 76.5627 95.5318 65.366 95.5318" stroke="white" stroke-width="2"/>
        <path d="M65.366 95.5318C54.1693 95.5318 44.517 65.8027 32.9342 65.8027C21.3514 65.8027 11.6991 95.5318 0.50238 95.5318" stroke="white" stroke-width="2"/>
        <circle cx="133.608" cy="79.9916" r="15.8916" stroke="white" stroke-width="2"/>
        <circle cx="133.608" cy="79.9916" r="15.8916" stroke="white" stroke-width="2"/>
        <circle cx="133.608" cy="79.9916" r="15.8916" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="14.3697" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="14.3697" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="14.3697" stroke="white" stroke-width="2"/>
        <circle cx="105.364" cy="39.0467" r="7.78361" stroke="white" stroke-width="2"/>
        <circle cx="105.364" cy="39.0467" r="7.78361" stroke="white" stroke-width="2"/>
        <circle cx="105.364" cy="39.0467" r="7.78361" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0468" r="8.38539" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0468" r="8.38539" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0468" r="8.38539" stroke="white" stroke-width="2"/>
        <circle cx="87.3593" cy="9.85939" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="87.3593" cy="9.85939" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="87.3593" cy="9.85939" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="2.37831" stroke="white" stroke-width="2"/>
    </svg>
                                                                      
    <div style='margin-top: 20px; margin-bottom: -5px;'>
        If one or more are defective or absent,<br/>
        we call that <i>color blindness</i>.
    </div>
       
    <div style='margin-top: 16;'>
        Set the condition of each cone type<br/>
        to simulate all types of color vision deficiency.
    </div>

</div>


<div id='ttToggleWires' class='tooltip'>Show&thinsp;/&thinsp;hide wires</div>


<div id='ttInterpolationSpace' class='tooltip'>

    <div>
        The color space determines<br/>the path of interpolation.
    </div>
    <div style="margin-top: 14px;">
        Through RGB it goes in a straight line,<br/>through spaces with Hue &mdash; in a circle.
    </div>

    <div style="position: absolute; left:  47px; top: 110px;">RGB</div>
    <div style="position: absolute; left: 152px; top: 110px;">HCL</div>

    <svg width="192" height="88" viewBox="0 0 192 88" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-top: 13px; margin-left: 4px;">
        <circle cx="43.945" cy="43.6699" r="42.9129" transform="rotate(164.053 43.945 43.6699)" stroke="white"/>
        <circle cx="148.459" cy="43.6699" r="42.9129" transform="rotate(164.053 148.459 43.6699)" stroke="white"/>
        <path d="M177.161 53.8683C175.042 59.8328 171.117 64.9889 165.932 68.6199C160.747 72.2509 154.56 74.1764 148.23 74.1287C141.9 74.081 135.743 72.0626 130.613 68.3539C125.484 64.6453 121.637 59.4307 119.607 53.4349" stroke="white" stroke-width="0.8" stroke-dasharray="2 2"/>
        <circle cx="16.6584" cy="54.5167" r="2.79505" transform="rotate(164.053 16.1584 54.5167)" fill="white"/>
        <circle cx="71.0077" cy="54.5167" r="2.79505" transform="rotate(164.053 71.5077 54.4231)" fill="white"/>
        <circle cx="121.173" cy="54.5167" r="2.79505" transform="rotate(164.053 120.673 54.5167)" fill="white"/>
        <circle cx="175.522" cy="54.5167" r="2.79505" transform="rotate(164.053 176.022 54.4231)" fill="white"/>
        <line x1="72.3693" y1="54.0053" x2="15.8716" y2="54.0053" stroke="white" stroke-dasharray="2 2"/>
    </svg>

</div>


<!-- <div id='ttInterpolationGamma' class='tooltip'>
    <div style="text-align: center;">Gamma correction</div>              
    <div style="margin-top: 14px;">How linearly the lightness is interpolated.</div>
</div> -->


<div id='ttWcag2' class='tooltip'>

    <div style='text-align: center;'>Contrast ratio</div>
    
    <div class='wcag2description' style='left: 50px;'>min. normal  </div>
    <div class='wcag2description' style='left: 71px;'>min. reduced </div>
    <div class='wcag2description' style='left: 93px;'>min. assisted</div>
    <div class='wcag2description' style='left: 115px;'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vision</div>

    <svg width="221" height="21" viewBox="0 0 221 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 20px; top: 86px">
        <path d="M220.452 20.2466H70.0214V10.7924H220.452V20.2466Z" fill="white" fill-opacity="0.4"/>
        <path d="M30.0214 0V20.2466" stroke="white"/>
        <path d="M45.0214 0V20.2466" stroke="white"/>
        <path d="M70.0214 0V20.2466" stroke="white"/>
        <rect x="0.0214233" y="10.7924" width="30" height="9.45416" fill="#FF7048" fill-opacity="0.5"/>
        <rect x="30.0214" y="10.7924" width="15" height="9.45416" fill="#FFFF36" fill-opacity="0.5"/>
        <rect x="45.0214" y="10.7924" width="25" height="9.45416" fill="#4FFE15" fill-opacity="0.5"/>
    </svg>
        
    <div class='wcag2value' style='left:  18px;'> 0  </div>
    <div class='wcag2value' style='left:  48px;'> 3  </div>
    <div class='wcag2value' style='left:  68px;'> 4.5</div>
    <div class='wcag2value' style='left:  90px;'> 7  </div>
    <div class='wcag2value' style='left: 239px;'>21  </div>

    <div id='wcag2info'><a href='https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html#visual-audio-contrast7-87-head' target='_blank'>More details</a></div>
</div>


<div id='ttWcag3' class='tooltip'>

    <div style='text-align: center;'>APCA visual contrast</div>
    
    <div class='wcag3description' style='left:  52px;'>discernible</div>
    <div class='wcag3description' style='left:  84px;'>minimum</div>
    <div class='wcag3description' style='left: 117px;'>large text</div>
    <div class='wcag3description' style='left: 148px;'>other text</div>
    <div class='wcag3description' style='left: 179px;'>body text</div>
    <div class='wcag3description' style='left: 211px;'>all text</div>

    <svg width="222" height="21" viewBox="0 0 222 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 19px; top: 78px">
        <rect x="0.854492" y="10.7924" width="31.5139" height="9.45416" fill="#FF0040" fill-opacity="0.5"/>
        <rect x="32.3684" y="10.7924" width="31.5139" height="9.45416" fill="#FF7048" fill-opacity="0.5"/>
        <rect x="63.8822" y="10.7924" width="31.5139" height="9.45416" fill="#FFB92F" fill-opacity="0.5"/>
        <rect x="95.3961" y="10.7924" width="31.5139" height="9.45416" fill="#FFFF36" fill-opacity="0.5"/>
        <rect x="126.91" y="10.7924" width="31.5139" height="9.45416" fill="#4FFE15" fill-opacity="0.5"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 158.424 20.2466)" fill="#7070FF" fill-opacity="0.7"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 189.938 20.2466)" fill="white" fill-opacity="0.4"/>
        <line x1="32.8684" x2="32.8684" y2="20.2466" stroke="white"/>
        <line x1="64.3822" x2="64.3822" y2="20.2466" stroke="white"/>
        <line x1="95.8961" x2="95.8961" y2="20.2466" stroke="white"/>
        <line x1="127.41" x2="127.41" y2="20.2466" stroke="white"/>
        <line x1="158.924" x2="158.924" y2="20.2466" stroke="white"/>
        <line x1="190.438" x2="190.438" y2="20.2466" stroke="white"/>
    </svg>

    <div class='wcag3value' style='left:  20px;'>  0</div>
    <div class='wcag3value' style='left:  52px;'> 15</div>
    <div class='wcag3value' style='left:  84px;'> 30</div>
    <div class='wcag3value' style='left: 114px;'> 45</div>
    <div class='wcag3value' style='left: 147px;'> 60</div>
    <div class='wcag3value' style='left: 179px;'> 75</div>
    <div class='wcag3value' style='left: 210px;'> 90</div>
    <div class='wcag3value' style='left: 239px;'>105</div>

    <div id='wcag3info'><a href='https://www.myndex.com/APCA/#font-size-and-weight' target='_blank'>More details</a></div>
</div>


<script id='generatorScript' type='javascript/worker'>



//const inputColor        = 'rgba(0, 0, 0, 0.12)';

const smallScrollGap    =  6;
const largeScrollGap    = 14;

const MAX_INT32         = 2147483647;


const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigitChar(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigitChar(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function getNumberString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    
    let i = 0;

    // find decimal place

    while (i < str.length 
        //&& str[i] == getUserDecimalSeparator())
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript
        //if (str[i] == getUserDecimalSeparator())
            str = str.substring(0, i--);
    }    

    return str;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    let last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function beforeLastOf(array)
{
    return array.length > 1 
         ? array[array.length-2]
         : null;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveIn(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}


function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}


function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}


function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return point(this.l, this.t); }
    get tc() { return point(this.c, this.t); }
    get tr() { return point(this.r, this.t); }
    get ml() { return point(this.l, this.m); }
    get mc() { return point(this.c, this.m); }
    get cm() { return point(this.c, this.m); }
    get mr() { return point(this.r, this.m); }
    get bl() { return point(this.l, this.b); }
    get bc() { return point(this.c, this.b); }
    get br() { return point(this.r, this.b); }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function getDecimalCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');//getUserDecimalSeparator());
    const commaIndex = strValue.indexOf(',');//getUserDecimalSeparator());

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign({}, obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element, show = true) { element.style.visibility = show ? 'visible' : 'hidden'; }
function hide(element)              { element.style.visibility = 'hidden';  }

function isVisible(element) { return element.style.visibility == 'visible'; }


function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function removeFromArray(array, obj)
{
    var index = array.indexOf(obj);
    
    if (index > -1)
        array.splice(index, 1);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params));
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function boolString(bool)
{
    return bool ? 'true' : 'false';
}



function isTrue(strBool)
{
    return strBool == 'true';
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj, null).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '')
{
    const div = document.createElement('div');
    
    if (className.trim() != '')
        div.className = className;
    
    return div;
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function enableSliderText(slider, enable)
{
    enableElementText(slider, enable);
    slider.readOnly = !enable;
}



function enableElementText(elem, enable)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 
    elem.style.fontWeight = enable ? 'normal' : 'bold';
}


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



// function readTextFromClipboard() 
// {
//     if (   navigator.clipboard 
//         && window.isSecureContext) 
//         return navigator.clipboard.readText();

//     else 
//     {
//         let textArea = document.createElement('textarea');

//         textArea.style.position = 'fixed';
//         textArea.style.left     = '-999999px';
//         textArea.style.top      = '-999999px';
        
//         document.body.appendChild(textArea);
        
//         textArea.focus();
//         textArea.select();
        
//         return new Promise((res, rej) => 
//         {
//             document.execCommand('paste') ? res(textArea.value) : rej();
//             textArea.remove();
//         });
//     }
// }


const nodeTag   = 'GN';
const activeTag = 'GA';
const connTag   = 'GC';



const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;


class NoiseSeed
{
    initial;
    current;

    
    constructor()
    {
        this.reset();
    }
    
    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    
    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    
    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }

    reset()
    {
        this.current = this.initial;
    }
};


class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        var next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


/*

*/


var nextGenObjectId = 0;


const OBJ_RECT = 1;


//const genGraph          = new GGraph();
const deletedNodeArrays = []; // array of [id,nodeArray,actionId] tuples



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = function(e)
{
    switch (e.data.msg)
    {
        case 'genFindCorrection':   
            genFindCorrection(
                e.data.nodeId, 
                e.data.inputColor, 
                e.data.param1,  e.data.param2,  e.data.param3,
                e.data.locked1, e.data.locked2, e.data.locked3);  
        
            break;
        
        case 'genGenerateRequest': genGenerateRequest(e.data.request); break;
        // case 'genCreateNode':    genCreateNode   (e.data.opType,   e.data.nodeId, e.data.nodeId); break; 
        // case 'genDeleteNodes':   genDeleteNodes  (e.data.nodeIds,  e.data.uiActionId);            break;             
        // case 'genUndeleteNodes': genUndeleteNodes(e.data.uiActionId);                             break;             
        // case 'genSetNodeId':     genSetNodeId    (e.data.nodeId,   e.data.newId);                 break; 
        // case 'genSetActive':     genSetActive    (e.data.nodeId,   e.data.active);                break;  // only state, no regeneration
        // case 'genConnect':       genConnect      (e.data.outputId, e.data.inputs);                break; 
        // case 'genDisconnect':    genDisconnect   (e.data.input);                                  break;
        // case 'genSetParam':      genSetParam     (e.data.nodeId,   e.data.param, e.data.value);   break;
        // case 'genInvalidate':    genInvalidate   (e.data.nodeId);                                 break;
        // case 'genUpdateObjects': genUpdateObjects(e.data.nodeIds);                                break;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////



function genPostMessageToUi(msg)
{
    postMessage(msg); // this call is too ambiguous to understand when reading code
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genGenerateRequest(request)
{
    const objects = [];
    const stackOverflowProtect = 100;

    nextGenObjectId = 0;

    for (let i = 0, so = 0; i < request.length && so < stackOverflowProtect; )
    {
        if (request[i] == 'rectangle' && request.length >= i+8) { objects.push(genGenerateRectangle(request, i)); i += 8; }
        else so++;
    }

    genPostMessageToUi({ 
        msg:    'uiUpdateCanvasObjects',
        objects: objects
    });
}



function genGenerateRectangle(request, i)
{
    return {
        type:   OBJ_RECT,
        id:     nextGenObjectId++,
        nodeId: request[i+1],
        x:      request[i+2],
        y:      request[i+3],
        width:  request[i+4],
        height: request[i+5],
        angle:  request[i+6],
        round:  request[i+7] };
}



// function genClearGraph()
// {
//     genGraph.clear();
// }



// function genCreateNode(type, id, name)
// {
//     const node = genGraph.createNode(type, id, name);
//     genGraph.addNode(node);

//     // on the UI side the node has already been created by this point

//     genPostMessageToUi({
//         msg:     'uiMakeActive',
//         nodeIds: [node.id]
//     });
// }



// function genDeleteNodes(nodeIds, uiActionId)
// {
//     var deleted = genGraph.deleteNodes(nodeIds);
//     deletedNodeArrays.push([uiActionId, deleted]);
// }



// function genUndeleteNodes(uiActionId)
// {
//     var deleted = deletedNodeArrays.find(n => n[0] == uiActionId);
//     var nodeIds = [];


//     for (const node of deleted[1])
//     {
//         genGraph.addNode(node);
//         nodeIds.push(node.id);
//     }

    
//     genPostMessageToUi({ 
//         msg:    'uiMakeActive',
//         nodeIds: nodeIds
//     });

    
//     removeFromArray(deletedNodeArrays, deleted);
// }



// function genSetNodeId(id, newId)
// {
//     const node = genGraph.nodeFromId(id);
//     node.id    = newId;
// }



// function genSetActive(nodeId, active)
// {
//     const node  = genGraph.nodeFromId(nodeId);
//     node.active = active;
// }



// function genConnect(outputId, inputs)
// {
//     const outNode = genGraph.nodeFromId(outputId);

//     for (const input of inputs)
//     {
//         const inNode = genGraph.nodeFromId(input.nodeId);

//         genGraph.connect(
//             outNode.output, 
//             input.index >= 0
//             ? inNode.inputs[input.index]
//             : inNode.params.find(p => p.name == input.param).input);

//         if (inNode.dataType == 'object')
//             genUpdateObjects([input.nodeId]);
//     }
// }



// function genDisconnect(input)
// {
//     const node = genGraph.nodeFromId(input.nodeId);
//     genGraph.disconnect(node.inputs[input.index]);
// }



// function genSetParam(nodeId, name, value)
// {
//     const node  = genGraph.nodeFromId(nodeId);
//     const param = node.params.find(p => p.name == name);

//     param.value = value;

//     updateNodeGraph(node);
// }



// function updateNodeGraph(_node)
// {
//     const node = nodeFromId(_node.id);

//     let activeId = activeNodeInTree(node).id;

//     if (activeId > -1)
//     {
//         genPostMessageToUi({ 
//             msg:    'uiUpdateNodes',
//             nodeIds: [activeId]
//         });
//     }
// }



// function genInvalidate(nodeId)
// {
//     const node = nodeFromId(nodeId);
//     node.valid = false;
// }



// function genUpdateObjects(nodeIds)
// {
//     for (const node of genGraph.nodes)
//         node.reset();


//     // first determine number of objects

//     let nObjects = 0;

//     for (const nodeId of nodeIds)
//     {
//         const node = genGraph.nodeFromId(nodeId);
//         const data = node.output.getData();
//         nObjects  += data.length;
//     }    

    
//     // now create the objects if necessary

//     if (nObjects > 0)
//     {
//         const objects = new Array(nObjects);

//         let i = 0;
//         for (const nodeId of nodeIds)
//         {
//             const node = genGraph.nodeFromId(nodeId);
//             const data = node.output.getData();
            
//             for (const obj of data)
//                 objects[i++] = obj;
//         }    

//         genPostMessageToUi({ 
//             msg:    'uiUpdateCanvasObjects',
//             objects: objects
//         });
//     }
//     // else
//     // {
//     //     genPostMessageToUi({ msg: 'uiUpdateGraph' });
//     // }
// }



// Observer = 2°

const D65 = [0.95047, 1, 1.08883]; 

function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v > 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h += 1;
    while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k * xw + 0.16)/1.16;
    yw = yw > e ? Math.cbrt(yw) : (k * yw + 0.16)/1.16;
    zw = zw > e ? Math.cbrt(zw) : (k * zw + 0.16)/1.16;

    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = cube(6/29) / 100;
    const k = cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16)/k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16)/k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16)/k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


const okLabScale = 5.8209716167;



function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l_, a_, b_) 
{
    return [
        l_ + 0.3963377774 * a_ + 0.2158037573 * b_,
        l_ - 0.1055613458 * a_ - 0.0638541728 * b_,
        l_ - 0.0894841775 * a_ - 1.2914855480 * b_ ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclokl2rgb(hcl, cs = sRGB)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 
    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclokl2rgb_(h, c, l, cs = sRGB)
{
    return hclokl2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclokl(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hclokl_(r, g, b, cs = sRGB)
{
    return rgb2hclokl([r, g, b], cs);
}



function hcllab2lab(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hcllab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hcllab2lab(hcl), cs);
}



function lab2hcllab(lab)
{
    let hcl = opp2pol(lab);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hcllab(rgb, cs = sRGB)
{
    return lab2hcllab(rgb2lab(rgb, cs));
}



function hclluv2luv(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hclluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hclluv2luv(hcl), cs);
}



function luv2hclluv(luv)
{
    let hcl = opp2pol(luv);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hclluv(rgb, cs = sRGB)
{
    return luv2hclluv(rgb2luv(rgb, cs));
}


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function isRgbValid(rgb, lim = Eps)
{
    return (!isNaN(rgb[0])
         && !isNaN(rgb[1])
         && !isNaN(rgb[2])
         && rgb[0] > -lim && rgb[0] < 1 + lim 
         && rgb[1] > -lim && rgb[1] < 1 + lim 
         && rgb[2] > -lim && rgb[2] < 1 + lim);
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


const color_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const dataColor_NaN = [
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ];



function colorIsNaN(c)
{
    return isNaN(c[0])
        || isNaN(c[1])
        || isNaN(c[2]);
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function colorStyleRgb(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function colorStyleRgba(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function colorStyleRgb_a(rgb, a)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(color, threshold = 0.71)
{
    return rgb2hclokl(color)[2] > threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < Eps
        && Math.abs(rgb1[1] - rgb2[1]) < Eps
        && Math.abs(rgb1[2] - rgb2[2]) < Eps;        
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }

    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    return rgb;
}


function getContrastRatio2(textColor, backColor)
{
    if (!isRgbValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!isRgbValid(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 
      loWoBthresh = 0.035991,
      loBoWfactor = 
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const OpColorSpaces = 
[
    ['hex',    'Hex'   ],
    //['rgbhex', '<span class=\'hash\'>#</span>RGB'],
    ['rgb',    'RGB'   ], 
    ['hsv',    'HSV'   ], 
    ['hsl',    'HSL'   ], 
    ['hclokl', 'HCL/ok'],
    ['hcllab', 'HCL/ab'],
    ['hclluv', 'HCL/uv']/*,
    ['oklab',  'okLab' ],
    ['lab',    'Lab'   ],
    ['luv',    'Luv'   ]*/
];

function colorSpace(index) { return OpColorSpaces[index][0]; }

function colorSpaceIndex(space) { return OpColorSpaces.findIndex(s => s[0] == space); }



const rgbFactor   = [255, 255, 255];
const hs_Factor   = [360, 100, 100];
const hclFactor   = [360, 100, 100];
const oppFactor   = [100, 100, 100];

const rgbScale    = [255, 255, 255];
const hs_Scale    = [360, 100, 100];
const hcloklScale = [360,  51, 100];
const hcllabScale = [360, 400, 100];
const hclluvScale = [360, 330, 100];
const oklabScale  = [100,  30,  30];
const labScale    = [100, 100, 100];
const luvScale    = [100, 150, 150];



function switchToSpace(op, space)
{
    switch (space)
    {
        case 'hex':    switchToHex   (op); break;
        case 'rgbhex': switchToRgbHex(op); break;
        case 'rgb':    switchToRgb   (op); break;
        case 'hsv':    switchToHsv   (op); break;
        case 'hsl':    switchToHsl   (op); break;
        case 'hclokl': switchToHclOkl(op); break;
        case 'hcllab': switchToHclLab(op); break;
        case 'hclluv': switchToHclLuv(op); break;
        case 'oklab':  switchToOklab (op); break;
        case 'lab':    switchToLab   (op); break;
        case 'luv':    switchToLuv   (op); break;
    }

    op.resetAllControlRanges();
}



function switchToHex   (op) { switchToTextbox       (op);           }
function switchToRgbHex(op) { switchToRgbHexControls(op);           }
function switchToRgb   (op) { switchToRgbControls   (op);           }
function switchToHsv   (op) { switchToHs_Controls   (op, 'V');      }
function switchToHsl   (op) { switchToHs_Controls   (op, 'L');      }
function switchToHclOkl(op) { switchToHclOklControls(op);           }
function switchToHclLab(op) { switchToHclLabControls(op);           }
function switchToHclLuv(op) { switchToHclLuvControls(op);           }
function switchToOklab (op) { switchToOklabControls (op, 'a', 'b'); }
function switchToLab   (op) { switchToLabControls   (op, 'a', 'b'); }
function switchToLuv   (op) { switchToLuvControls   (op, 'u', 'v'); }
   


function switchToRgbHexControls(op)
{
    switchToControls(op, 
        '<span class=\'hash\'>#</span>R', 0, rgbScale[0], '', false, 
        '<span class=\'hash\'>#</span>G', 0, rgbScale[1], 
        '<span class=\'hash\'>#</span>B', 0, rgbScale[2]);  

    showRgbControlHex(op, true);
}



function switchToRgbControls(op)
{
    switchToControls(op, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    showRgbControlHex(op, false);    
}



function switchToHs_Controls(op, v_or_l) 
{ 
    switchToControls(op, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToHclControls(op, scale) 
{ 
    switchToControls(op, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToHclOklControls(op) { switchToHclControls(op, hcloklScale); }
function switchToHclLabControls(op) { switchToHclControls(op, hcllabScale); }
function switchToHclLuvControls(op) { switchToHclControls(op, hclluvScale); }



function switchToOppControls(op, c2, c3, scale)
{ 
    switchToControls(op, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToOklabControls(op) { switchToOppControls(op, 'a', 'b', oklabScale); }
function switchToLabControls  (op) { switchToOppControls(op, 'a', 'b', labScale  ); }
function switchToLuvControls  (op) { switchToOppControls(op, 'u', 'v', luvScale  ); }



function showRgbControlHex(op, show)
{
    op.param1.control.showHex = show;
    op.param2.control.showHex = show;
    op.param3.control.showHex = show;
}



function switchToControls(op, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(op);

    op.param1.setName(c1, false); 
    op.param2.setName(c2, false); 
    op.param3.setName(c3, false);

    op.param1.control.wrapValue = c1wrap;
    op.param1.control.setSuffix(c1suffix, c1suffix != '');

    op.param1.control.setMin(c1min, false); 
    op.param2.control.setMin(c2min, false);
    op.param3.control.setMin(c3min, false);
    
    op.param1.control.setMax(c1max, false); 
    op.param2.control.setMax(c2max, false); 
    op.param3.control.setMax(c3max, false); 
    
    op.param1.updateControls();
    op.param2.updateControls();
    op.param3.updateControls();
}



function switchToTextbox(op)
{
    if (!op.inner.contains(op.hexbox))
    {
        removeOpColorParamWires(op);

        op.inner.removeChild(op.param1.div);
        op.inner.removeChild(op.param2.div);
        op.inner.removeChild(op.param3.div);
        
        op.inner.appendChild(op.hexbox);

        //graphView.updateNodeTransform(op);
    }
}



function removeOpColorParamWires(op)
{
    for (let i = op.inputs.length-1; i >= 2; i--)
        if (op.inputs[i].isConnected)
            uiDisconnect(op.inputs[i]);

    for (let i = op.outputs.length-1; i >= 2; i--)
        for (const input of op.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(op)
{
    if (op.inner.contains(op.hexbox))
    {
        op.inner.removeChild(op.hexbox);

        op.inner.appendChild(op.param1.div);
        op.inner.appendChild(op.param2.div);
        op.inner.appendChild(op.param3.div);

        graphView.updateNodeTransform(op);
    }
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return getNormalValueRgb_(value, chan);
        case 'hsv':   
        case 'hsl':    return getNormalValueHs_ (value, chan);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalValueHcl (value, chan);
        case 'oklab':  
        case 'lab':    
        case 'luv':    return getNormalValuesOpp(value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return getNormalColorRgb_(c1, c2, c3);
        case 'hsv':   
        case 'hsl':    return getNormalColorHs_(c1, c2, c3);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalColorHcl(c1, c2, c3);
        case 'oklab': 
        case 'lab': 
        case 'luv':    return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return getDataColorRgb(color[1], color[2], color[3]);
        case 'hsv':   
        case 'hsl':    return getDataColorHs_(color[1], color[2], color[3]);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getDataColorHcl(color[1], color[2], color[3]);
        case 'oklab': 
        case 'lab': 
        case 'luv':    return getDataColorOpp(color[1], color[2], color[3]);
    }
}



function getDataColorRgb(c1, c2, c3)
{
    return [
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getDataColorHs_(c1, c2, c3)
{
    return [
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getDataColorOpp(c1, c2, c3)
{
    return [
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function getDataColorHcl(c1, c2, c3)
{
    return [
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function setDataColorToCurrentSpace(op, color)
{
    const toSpace = colorSpace(op.paramSpace.value);
    op._color = convertDataColorToSpace(color, toSpace);
    op.setColorParams(op._color);
}



function getColorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return rgbFactor;
        case 'hsv':   
        case 'hsl':    return hs_Factor;
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return hclFactor;
        case 'oklab': 
        case 'lab': 
        case 'luv':    return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return rgbScale;
        case 'hsv':   
        case 'hsl':    return hs_Scale;
        case 'hclokl': return hcloklScale;
        case 'hcllab': return hcllabScale;
        case 'hclluv': return hclluvScale;
        case 'oklab':  return oklabScale;
        case 'lab':    return labScale;
        case 'luv':    return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgbhex': 
        case 'rgb':    return            col;
        case 'hsv':    return hsv2rgb   (col);
        case 'hsl':    return hsl2rgb   (col);
        case 'hclokl': return hclokl2rgb(col);
        case 'hcllab': return hcllab2rgb(col);
        case 'hclluv': return hclluv2rgb(col);
        case 'oklab':  return oklab2rgb (col);
        case 'lab':    return lab2rgb   (col);
        case 'luv':    return luv2rgb   (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgbhex': { let hex = convert2rgb(color); hex[0] = toSpace; return hex; }
        case 'rgb':    return convert2rgb   (color);
        case 'hsv':    return convert2hsv   (color);
        case 'hsl':    return convert2hsl   (color);
        case 'hclokl': return convert2hclokl(color);
        case 'hcllab': return convert2hcllab(color);
        case 'hclluv': return convert2hclluv(color);
        case 'oklab':  return convert2oklab (color);
        case 'lab':    return convert2lab   (color);
        case 'luv':    return convert2luv   (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    rgb =            col;  break;
        case 'hsv':    rgb = hsv2rgb   (col); break;
        case 'hsl':    rgb = hsl2rgb   (col); break;
        case 'hclokl': rgb = hclokl2rgb(col); break;
        case 'hcllab': rgb = hcllab2rgb(col); break;
        case 'hclluv': rgb = hclluv2rgb(col); break;
        case 'oklab':  rgb = oklab2rgb (col); break;
        case 'lab':    rgb = lab2rgb   (col); break;
        case 'luv':    rgb = luv2rgb   (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hsv = rgb2hsv(           col ); break;
        case 'hsv':    hsv =                    col;   break;
        case 'hsl':    hsv = rgb2hsv(hsl2rgb   (col)); break;
        case 'hclokl': hsv = rgb2hsv(hclokl2rgb(col)); break;
        case 'hcllab': hsv = rgb2hsv(hcllab2rgb(col)); break;
        case 'hclluv': hsv = rgb2hsv(hclluv2rgb(col)); break;
        case 'oklab':  hsv = rgb2hsv(oklab2rgb (col)); break;
        case 'lab':    hsv = rgb2hsv(lab2rgb   (col)); break;
        case 'luv':    hsv = rgb2hsv(luv2rgb   (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hsl = rgb2hsl(           col ); break;
        case 'hsv':    hsl = rgb2hsl(hsv2rgb   (col)); break;
        case 'hsl':    hsl =                    col;   break;
        case 'hclokl': hsl = rgb2hsl(hclokl2rgb(col)); break;
        case 'hcllab': hsl = rgb2hsl(hcllab2rgb(col)); break;
        case 'hclluv': hsl = rgb2hsl(hclluv2rgb(col)); break;
        case 'oklab':  hsl = rgb2hsl(oklab2rgb (col)); break;
        case 'lab':    hsl = rgb2hsl(lab2rgb   (col)); break;
        case 'luv':    hsl = rgb2hsl(luv2rgb   (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function convert2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    lab = rgb2oklab(           col ); break;
        case 'hsv':    lab = rgb2oklab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2oklab(hsl2rgb   (col)); break;
        case 'hclokl': lab = rgb2oklab(hclokl2rgb(col)); break;
        case 'hcllab': lab = rgb2oklab(hcllab2rgb(col)); break;
        case 'hclluv': lab = rgb2oklab(hclluv2rgb(col)); break;
        case 'oklab':  lab =                      col;   break;
        case 'lab':    lab = rgb2oklab(lab2rgb   (col)); break;
        case 'luv':    lab = rgb2oklab(luv2rgb   (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    lab = rgb2lab(           col ); break;
        case 'hsv':    lab = rgb2lab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2lab(hsl2rgb   (col)); break;
        case 'hclokl': lab = rgb2lab(hclokl2rgb(col)); break;
        case 'hcllab': lab =         hcllab2lab(col);  break;
        case 'hclluv': lab = rgb2lab(hclluv2rgb(col)); break;
        case 'oklab':  lab = rgb2lab(oklab2rgb (col)); break;
        case 'lab':    lab =                    col;   break;
        case 'luv':    lab = rgb2lab(luv2rgb   (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    luv = rgb2luv(           col ); break;
        case 'hsv':    luv = rgb2luv(hsv2rgb   (col)); break;
        case 'hsl':    luv = rgb2luv(hsl2rgb   (col)); break;
        case 'hclokl': luv = rgb2luv(hclokl2rgb(col)); break;
        case 'hcllab': luv = rgb2luv(hcllab2rgb(col)); break;
        case 'hclluv': luv =         hclluv2luv(col);  break;
        case 'oklab':  luv = rgb2luv(oklab2rgb (col)); break;
        case 'lab':    luv = rgb2luv(lab2rgb   (col)); break;
        case 'luv':    luv =                    col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclokl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hclokl(           col);  break;
        case 'hsv':    hcl = rgb2hclokl(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclokl(hsl2rgb   (col)); break;
        case 'hclokl': hcl =                       col;   break;
        case 'hcllab': hcl = rgb2hclokl(hcllab2rgb(col)); break;
        case 'hclluv': hcl = rgb2hclokl(hclluv2rgb(col)); break;
        case 'oklab':  hcl = rgb2hclokl(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclokl(lab2rgb   (col)); break;
        case 'luv':    hcl = rgb2hclokl(luv2rgb   (col)); break;
    }

    return [
       'hclokl',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcllab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hcllab(           col) ; break;
        case 'hsv':    hcl = rgb2hcllab(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hcllab(hsl2rgb   (col)); break;
        case 'hclokl': hcl = rgb2hcllab(hclokl2rgb(col)); break;
        case 'hcllab': hcl =                       col;   break;
        case 'hclluv': hcl = rgb2hcllab(hclluv2rgb(col)); break;
        case 'oklab':  hcl = rgb2hcllab(oklab2rgb (col)); break;
        case 'lab':    hcl = lab2hcllab(           col ); break;
        case 'luv':    hcl = rgb2hcllab(luv2rgb   (col)); break;
    }

    return [
       'hcllab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hclluv(           col ); break;
        case 'hsv':    hcl = rgb2hclluv(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclluv(hsl2rgb   (col)); break;
        case 'hcllab': hcl = rgb2hclluv(hcllab2rgb(col)); break;
        case 'hclluv': hcl =                       col;   break;
        case 'hclokl': hcl = rgb2hclluv(hclokl2rgb(col)); break;
        case 'oklab':  hcl = rgb2hclluv(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclluv(lab2rgb   (col)); break;
        case 'luv':    hcl = luv2hclluv(           col ); break;
    }

    return [
       'hclluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


function validateColor(color, order, margin1, margin2, margin3)
{
    let i1, i2, i3;
    
         if (order == 0) { i1 = 0; i2 = 1; i3 = 2; } // HCL
    else if (order == 1) { i1 = 1; i2 = 0; i3 = 2; } // CHL
    else if (order == 2) { i1 = 1; i2 = 2; i3 = 0; } // CLH
    else if (order == 3) { i1 = 0; i2 = 2; i3 = 1; } // HLC
    else if (order == 4) { i1 = 2; i2 = 0; i3 = 1; } // LHC
    else if (order == 5) { i1 = 2; i2 = 1; i3 = 0; } // LCH
 
                                           color = validateChannel(color, i1, margin1);
    if (!isRgbValid(dataColor2rgb(color))) color = validateChannel(color, i2, margin2);
    if (!isRgbValid(dataColor2rgb(color))) color = validateChannel(color, i3, margin3);

    return color;
}



function validateChannel(color, iChan, margin)
{
    const factor = getColorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = isRgbValid(dataColor2rgb(color));
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c -= d;  _valid = isColorValid(_c, iChan, savedColor);
        c_ += d;  valid_ = isColorValid(c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = isRgbValid(dataColor2rgb(color));
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorValid(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = isRgbValid(dataColor2rgb(color));
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorValid(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorValid(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return isRgbValid(dataColor2rgb(color));
}



function getValidateMax(order)
{
    switch (order)
    {
        case 0: return [180, 100, 100]; // HCL
        case 1: return [100, 180, 100]; // CHL
        case 2: return [100, 100, 180]; // CLH
        case 3: return [180, 100, 100]; // HLC
        case 4: return [100, 180, 100]; // LHC
        case 5: return [100, 100, 180]; // LCH
    }

    // should never get here
    return [0, 0, 0];
}


function genFindCorrection(nodeId, 
                           inputColor, 
                           param1,  param2,  param3, 
                           locked1, locked2, locked3)
{
    const refOklab = dataColor2array(convert2oklab(inputColor));

    let
  [ closestOklab,
    closestOrder,
    closest1,
    closest2,
    closest3 ] = findCorrection(
                     nodeId, 
                     inputColor, 
                     refOklab, 
                     param1,  param2,  param3, 
                     locked1, locked2, locked3); 

//   [ closestOrder,
//     closest1, closest2, closest3,
//     locked1,  locked2,  locked3 ] = reorderCorrection(
//                                         closestOrder,
//                                         closest1, closest2, closest3,
//                                         locked1,  locked2,  locked3);

    genPostMessageToUi(
    {
        msg:         'uiEndFindCorrection',
        nodeId:       nodeId,
        success:      closestOklab != null,
        closestOrder: closestOrder,
        closest1:     closest1,
        closest2:     closest2,
        closest3:     closest3
    });
}



function findCorrection(nodeId, 
                        color, 
                        refOklab, 
                        param1,  param2,  param3, 
                        locked1, locked2, locked3) 
{
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);


    let d = 1;

    while (d > 1/1024)
    {
        let _closestColor = [...closestColor];


        for (let order = 0; order < 6; order++)
        {
            closestColor = [..._closestColor];

            const [max1, max2, max3] = getValidateMax(order);

            let start1 = lerp(0, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(0, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(0, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = param1; start1 = closest1; end1 = start1+Eps; }
            if (locked2) { closest2 = param2; start2 = closest2; end2 = start2+Eps; }
            if (locked3) { closest3 = param3; start3 = closest3; end3 = start3+Eps; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = findCorrectionInOrder(
                nodeId,
                refOklab,
                order, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }

        
        d /= 2;
    }


    // reduce closest to necessary minimums

    const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

    let c1 = closest1;
    let c2 = closest2;
    let c3 = closest3;

    // console.log('closest1', closest1);
    // console.log('closest2', closest2);
    // console.log('closest3', closest3);
    // console.log('');

    while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
    while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
    while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

    closest1 = Math.max(0, c1);
    closest2 = Math.max(0, c2);
    closest3 = Math.max(0, c3);

    // console.log('closest1', closest1);
    // console.log('closest2', closest2);
    // console.log('closest3', closest3);
    // console.log('');

    
    return [
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



function findCorrectionInOrder(nodeId,
                               refOklab,
                               order, 
                               locked1,  locked2,  locked3,
                               closest1, closest2, closest3,
                               start1,   start2,   start3, 
                               end1,     end2,     end3,
                               closestColor,
                               closestOklab,
                               closestOrder,
                               progress,
                               total)
{
    const color = [...closestColor];

    // console.log('order', order);
    // console.log('-------------------')

    // console.log('locked1',  locked1);
    // console.log('start1',   start1);
    // console.log('end1',     end1);
    
    // console.log('locked2',  locked2);
    // console.log('start2',   start2);
    // console.log('end2',     end2);
    
    // console.log('locked3',  locked3);
    // console.log('start3',   start3);
    // console.log('end3',     end3);

    // console.log('-------------------')
    // console.log('')

    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   isRgbValid(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    closestOrder = order;
                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;

                    console.log('order', order);
                    console.log('closest1', closest1);
                    console.log('closest2', closest2);
                    console.log('closest3', closest3);
                    console.log('');
                }

                progress++;
            }
        }

        genPostMessageToUi(
        {
            msg:     'uiUpdateFindCorrection',
            nodeId:   nodeId,
            progress: progress / total
        });
    }


    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = validateColor(color, order, m1, m2, m3);
    const _oklab = dataColor2array(convert2oklab(_color));
    const _rgb   = oklab2rgb(_oklab);

    return [_color, _oklab, _rgb];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Eps
        && c2.closest <  Eps
        && c3.closest >= Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Eps
          && c2.closest <  Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getObjectBounds(objects)
{
    var boundsL = Number.MAX_SAFE_INTEGER;
    var boundsT = Number.MAX_SAFE_INTEGER;
    var boundsR = Number.MIN_SAFE_INTEGER;
    var boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const obj of objects)
    {
        switch (obj[0])
        {
            case OBJ_RECT:
                boundsL = Math.min(boundsL, obj[3]);
                boundsT = Math.min(boundsT, obj[4]);
                boundsR = Math.max(boundsR, obj[3] + obj[5]);
                boundsB = Math.max(boundsB, obj[4] + obj[6]);
                break;
        }
    }

    return {
        x: boundsL, 
        y: boundsT,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
}


</script>


<script>

////////////////////////////////////////////////////


//const inputColor        = 'rgba(0, 0, 0, 0.12)';

const smallScrollGap    =  6;
const largeScrollGap    = 14;

const MAX_INT32         = 2147483647;


const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigitChar(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigitChar(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function getNumberString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    
    let i = 0;

    // find decimal place

    while (i < str.length 
        //&& str[i] == getUserDecimalSeparator())
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript
        //if (str[i] == getUserDecimalSeparator())
            str = str.substring(0, i--);
    }    

    return str;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    let last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function beforeLastOf(array)
{
    return array.length > 1 
         ? array[array.length-2]
         : null;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveIn(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}


function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}


function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}


function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return point(this.l, this.t); }
    get tc() { return point(this.c, this.t); }
    get tr() { return point(this.r, this.t); }
    get ml() { return point(this.l, this.m); }
    get mc() { return point(this.c, this.m); }
    get cm() { return point(this.c, this.m); }
    get mr() { return point(this.r, this.m); }
    get bl() { return point(this.l, this.b); }
    get bc() { return point(this.c, this.b); }
    get br() { return point(this.r, this.b); }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function getDecimalCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');//getUserDecimalSeparator());
    const commaIndex = strValue.indexOf(',');//getUserDecimalSeparator());

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign({}, obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element, show = true) { element.style.visibility = show ? 'visible' : 'hidden'; }
function hide(element)              { element.style.visibility = 'hidden';  }

function isVisible(element) { return element.style.visibility == 'visible'; }


function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function removeFromArray(array, obj)
{
    var index = array.indexOf(obj);
    
    if (index > -1)
        array.splice(index, 1);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params));
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function boolString(bool)
{
    return bool ? 'true' : 'false';
}



function isTrue(strBool)
{
    return strBool == 'true';
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj, null).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '')
{
    const div = document.createElement('div');
    
    if (className.trim() != '')
        div.className = className;
    
    return div;
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function enableSliderText(slider, enable)
{
    enableElementText(slider, enable);
    slider.readOnly = !enable;
}



function enableElementText(elem, enable)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 
    elem.style.fontWeight = enable ? 'normal' : 'bold';
}


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



// function readTextFromClipboard() 
// {
//     if (   navigator.clipboard 
//         && window.isSecureContext) 
//         return navigator.clipboard.readText();

//     else 
//     {
//         let textArea = document.createElement('textarea');

//         textArea.style.position = 'fixed';
//         textArea.style.left     = '-999999px';
//         textArea.style.top      = '-999999px';
        
//         document.body.appendChild(textArea);
        
//         textArea.focus();
//         textArea.select();
        
//         return new Promise((res, rej) => 
//         {
//             document.execCommand('paste') ? res(textArea.value) : rej();
//             textArea.remove();
//         });
//     }
// }


const nodeTag   = 'GN';
const activeTag = 'GA';
const connTag   = 'GC';



// Observer = 2°

const D65 = [0.95047, 1, 1.08883]; 

function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v > 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h += 1;
    while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k * xw + 0.16)/1.16;
    yw = yw > e ? Math.cbrt(yw) : (k * yw + 0.16)/1.16;
    zw = zw > e ? Math.cbrt(zw) : (k * zw + 0.16)/1.16;

    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = cube(6/29) / 100;
    const k = cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16)/k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16)/k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16)/k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


const okLabScale = 5.8209716167;



function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l_, a_, b_) 
{
    return [
        l_ + 0.3963377774 * a_ + 0.2158037573 * b_,
        l_ - 0.1055613458 * a_ - 0.0638541728 * b_,
        l_ - 0.0894841775 * a_ - 1.2914855480 * b_ ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclokl2rgb(hcl, cs = sRGB)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 
    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclokl2rgb_(h, c, l, cs = sRGB)
{
    return hclokl2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclokl(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hclokl_(r, g, b, cs = sRGB)
{
    return rgb2hclokl([r, g, b], cs);
}



function hcllab2lab(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hcllab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hcllab2lab(hcl), cs);
}



function lab2hcllab(lab)
{
    let hcl = opp2pol(lab);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hcllab(rgb, cs = sRGB)
{
    return lab2hcllab(rgb2lab(rgb, cs));
}



function hclluv2luv(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hclluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hclluv2luv(hcl), cs);
}



function luv2hclluv(luv)
{
    let hcl = opp2pol(luv);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hclluv(rgb, cs = sRGB)
{
    return luv2hclluv(rgb2luv(rgb, cs));
}


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function isRgbValid(rgb, lim = Eps)
{
    return (!isNaN(rgb[0])
         && !isNaN(rgb[1])
         && !isNaN(rgb[2])
         && rgb[0] > -lim && rgb[0] < 1 + lim 
         && rgb[1] > -lim && rgb[1] < 1 + lim 
         && rgb[2] > -lim && rgb[2] < 1 + lim);
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


const color_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const dataColor_NaN = [
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ];



function colorIsNaN(c)
{
    return isNaN(c[0])
        || isNaN(c[1])
        || isNaN(c[2]);
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function colorStyleRgb(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function colorStyleRgba(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function colorStyleRgb_a(rgb, a)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(color, threshold = 0.71)
{
    return rgb2hclokl(color)[2] > threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < Eps
        && Math.abs(rgb1[1] - rgb2[1]) < Eps
        && Math.abs(rgb1[2] - rgb2[2]) < Eps;        
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }

    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    return rgb;
}


function getContrastRatio2(textColor, backColor)
{
    if (!isRgbValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!isRgbValid(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 
      loWoBthresh = 0.035991,
      loBoWfactor = 
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const cryptoModulusSize     = 64; // to keep the keys short
const millerRabinIterations = 40;

const cryptoBufferSize      = cryptoModulusSize/8;
const cryptoPrimeBufferSize = cryptoBufferSize /2;
     
const cryptoBuffer          = new Uint8Array(cryptoPrimeBufferSize);


function bigCryptoRandom()
{
    for (var i = 0; i < cryptoPrimeBufferSize; i++)
        cryptoBuffer[i] = toInt(Math.random() * 0x100);

    cryptoBuffer[0]                       |= 0xC0; // set the top bit to ensure a relatively large number
    cryptoBuffer[cryptoPrimeBufferSize-1] |= 0x01; // set low bit to ensure the number is odd

    return bigFromBuffer(cryptoBuffer);
}



function bigNextCryptoPrime(n) 
{
    while (!bigIsPrime(n))
        n += 2n;
    
    return n;
}



function bigCryptoPrime(e)
{
    // set p so that gcd(e, p-1) = 1
    
    var p;

    do
    {
        var rnd = bigCryptoRandom();
        p       = bigNextCryptoPrime(rnd);
    }
    while (gcd(p-1n, e) != 1n); 
        
    return p;
}



function createCryptoKeys()
{
    var e = 65537n; // 0x10001


    // var p = bigCryptoPrime(e);
    
    // var q;
    // do { q = bigCryptoPrime(e); } 
    // while (q == p);

    
    // if (p < q)
    //     [p,q] = [q,p];

    
    // console.log('p: ' + p);
    // console.log('q: ' + q);


    var p = 4131437551n,
        q = 3567532051n;
    

    var n   = p * q;
    var phi = (p-1n) * (q-1n);

    var d = bigModInvert(e, phi);


    return {
        public:  {n:n, e:e },
        private: {n:n, d:d, p:p, q:q} };
}                        



function encryptBlock(n, key, sign  ) { return bigPowMod(n, (sign   ? key.d : key.e), key.n); }        
function decryptBlock(n, key, verify) { return bigPowMod(n, (verify ? key.e : key.d), key.n); }        



function encrypt(data, key) { return encryptData(data, key, false); }
function decrypt(data, key) { return decryptData(data, key, false); }

function sign   (data, key) { return encryptData(data, key, true); } // yes I know real sign/verify uses a hash,
function verify (data, key) { return decryptData(data, key, true); } // but I prefer it this way for what I need



function encryptData(data, key, sign)
{
    // prep array should be a multiple of cryptoBufferSize
    var prep   = new Uint8Array(Math.ceil((data.length) / cryptoBufferSize) * cryptoBufferSize); 
    var cipher = new Uint8Array(prep.length);


    var start = prep.length - data.length;
    for (var i = 0; i < data.length; i++)
        prep[start+i] = data[i];


    var length = prep.length;
    var nBlock = 0;

    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);
        
        var block = bigFromBufferAt(prep, blockStart, cryptoBufferSize);
        var enc   = encryptBlock(block, key, sign);
        
        bigToBufferAt(enc, cipher, blockStart, cryptoBufferSize);
        
        nBlock++;
        length -= blockSize;
    }
    
    
    return cipher;
}



function decryptData(cipher, key, verify)
{
    var data = new Uint8Array(cipher.length);
    
    
    var length = cipher.length;
    var nBlock = 0;
    
    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);

        var block = bigFromBufferAt(cipher, blockStart, cryptoBufferSize);
        var dec   = decryptBlock(block, key, verify);
        bigToBufferAt(dec, data, blockStart, cryptoBufferSize); 

        nBlock++;
        length -= blockSize;
    }    


    return data;    
}


const base32chars = '12345679ABCDEFGHJKLMNPQRSTUVWXYZ';



function arrayToBase32(array, chars = base32chars)
{
    var base32 = '';

    
    var len = array.length;
    var i   = 0;

    while (len > 0)
    {
        if (len >= 5)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3],
                a4 = array[i+4];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[(a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) << 3) | ((a4 & 0xE0) >>> 5)];
            base32 += chars[(a4 & 0x1F)];
        }
        else if (len == 4)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[(a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) << 3)];
        }
        else if (len == 3)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1)];
        }
        else if (len == 2)
        {
            var a0 = array[i  ],
                a1 = array[i+1];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4)];
        }
        else if (len == 1)
        {
            var a0 = array[i];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2)];
        }


        i   += 5;
        len -= 5;
    }


    return base32;
}



function base32toArray(base32, chars = base32chars)
{
    var array = [];


    var len = base32.length;
    var c   = 0;

    while (len > 0)
    {
        if (len >= 8)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]),
                c7 = chars.indexOf(base32[c+7]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
            array.push(((c6 & 0x07) << 5) | c7);
        }
        else if (len == 7)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
        }
        else if (len == 5)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
        }
        else if (len == 4)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
        }
        else if (len == 2)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
        }


        c   += 8;
        len -= 8;
    }


    return array;
}


function createToggleButton(width, height)
{
    const btn = createDiv('toggleButton');
    btn.enabled = false;

    btn.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();

        btn.setPointerCapture(e.pointerId);
        btn.enabled = !btn.enabled;
        btn.updateBackground(true);
    });


    btn.addEventListener('pointerup', e =>
    {
        btn.releasePointerCapture(e.pointerId);
        btn.updateBackground(false);
    });


    btn.updateBackground = (enabled) =>
    {
        btn.style.background = 
            btn.enabled 
            ? 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 1C4.10457 1 5 1.89543 5 3V5H6V3C6 1.34315 4.65685 0 3 0C1.34315 0 0 1.34315 0 3V5H1V3C1 1.89543 1.89543 1 3 1Z" fill="black"/><path d="M5 9H6V11C6 12.6569 4.65685 14 3 14C1.34315 14 0 12.6569 0 11V9H1V11C1 12.1046 1.89543 13 3 13C4.10457 13 5 12.1046 5 11V9Z" fill="black"/><path d="M2.5 4V10H3.5V4H2.5Z" fill="black"/></svg>\')'
            : 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="black"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="black"/></svg>\')';

        btn.style.backgroundPosition = '50% 50%';
        btn.style.backgroundRepeat   = 'no-repeat';

        btn.style.backgroundColor = btn.enabled && enabled ? '#e6e6e6' : 'transparent';
    };


    return btn;
}


class NumberSliderRange
{
    start;
    end;

    background;

    top;
    bottom;


    constructor(start, end = start, background = 'magenta', top = 0, bottom = 1)
    {
        this.start      = start;
        this.end        = end;

        this.background = background;

        this.top        = top;
        this.bottom     = bottom;
    }
}



function updateSliderRanges(slider, sliderWidth, sliderHeight)
{
    if (slider.ranges.length == slider.rangeDivs.length) // update
    {
        for (let i = 0; i < slider.ranges.length; i++)
        {
            updateSliderRangeDiv(
                slider.ranges   [i],
                slider.rangeDivs[i],
                sliderWidth,
                sliderHeight);
        }
    }
    else // recreate
    {
        resetSliderRangeDivs(slider);

        for (let i = 0; i < slider.ranges.length; i++)
        {
            const range = slider.ranges[i];

            const div = createDiv('numberSliderRange');
            div.style.zIndex = 0;
            slider.rangeDivs.push(div);
            slider.appendChild(div);
        
            updateSliderRangeDiv(range, div, sliderWidth, sliderHeight);
        }
    }
};



function updateSliderRangeDiv(range, div, sliderWidth, sliderHeight)
{
    if (range.start == range.end)
        div.style.display = 'none';
    else
    {
        div.style.display    = 'block';
        div.style.left       = sliderWidth * range.start;  
        div.style.top        = range.top * sliderHeight;
        div.style.width      = sliderWidth * (range.end - range.start);
        div.style.height     = (range.bottom - range.top) * sliderHeight;
        div.style.background = range.background;
    }
};



function resetSliderRanges(slider)
{
    slider.ranges = [];
    resetSliderRangeDivs(slider);        
};



function resetSliderRangeDivs(slider)
{
    for (const div of slider.rangeDivs)
        if (slider.contains(div))
            slider.removeChild(div);

    slider.rangeDivs = [];
}


function initNumberSliderTextbox(slider)
{
    slider.textbox = createTextbox('numberSliderTextbox');
    slider.textbox.slider = slider;
    


    slider.textbox.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();
    });



    slider.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();
        slider.textbox.style.cursor = 'default';
    });



    slider.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !slider.readOnly)
        {
            // by doing nothing here I let the OS do its thing
        }
        
        else if (   (   e.code == 'Enter'
                     || e.code == 'NumpadEnter')
                 && !slider.readOnly)
            slider.textbox.finish(true);

        else if (e.code == 'Escape')
            slider.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            e.stopPropagation();
            
            if (slider.param)
            {
                const params = slider.param.op.params;
                let   index  = params.indexOf(slider.param);

                slider.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (params[--index].control.readOnly);
                    params[index].control.showTextbox();
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (params[++index].control.readOnly);
                    params[index].control.showTextbox();
                }
            }

            // let tabs  = document.querySelectorAll('.numberSlider, .selectSlider, .select, .menuSelect, button, .menuButton');
            // let index = slider.tabIndex;

            // for (let i = 0; i < tabs.length; i++) 
            // {
            //     if (   e.shiftKey && tabs[i].tabIndex == index - 1
            //         ||               tabs[i].tabIndex == index + 1) 
            //     {
            //         if (tabs[i].className == 'slider')
            //             tabs[i].showTextbox();
            //         else 
            //         {
            //             document.activeElement.blur();
            //             tabs[i].focus();
            //         }

            //         break;
            //     }
            // }
        }

        else if ((   e.key == 'ArrowUp'
                  || e.key == 'ArrowDown')
              && !slider.readOnly)
        {
            e.preventDefault();

            let text = slider.textbox.value;

            if (   slider.valueCanContainSuffix   
                && text.length >= slider.suffix.length
                && text.substring(text.length - slider.suffix.length) == slider.suffix)
                text = text.substring(0, text.length - slider.suffix.length);


            if (slider.textbox.selectionStart != slider.textbox.selectionEnd)
                slider.textbox.selectionStart =  slider.textbox.selectionEnd;

            const pos = Math.min(
                slider.textbox.selectionStart,
                text.length);

            const revPos = text.length - pos;

            const val  = parseFloat(text);
            const sign = e.key == 'ArrowUp' ? 1 : -1;

            let decIndex = text.indexOf('.');
            if (decIndex < 0) decIndex = text.indexOf(',');
            
            if (   text[0] != '-'
                || pos > 0)
            {
                if (decIndex < 0) // integer
                {
                    let dec = Math.pow(10, revPos);

                    if (e.shiftKey) 
                        dec *= 10;

                    slider.setValue((val + sign * dec) / slider.valueScale);
                    slider.updateTextbox();
                }
                else // floating point
                {
                    const _edit = pos - decIndex - 1;

                    let  dec  = 
                        _edit < 0
                        ?     Math.pow(10, -_edit - 1)
                        : 1 / Math.pow(10,  _edit    );

                    if (e.shiftKey) 
                        dec *= 10;

                    slider.displayDec = text.length-1 - decIndex;
                    slider.setValue((val + sign * dec) / slider.valueScale);
                    slider.updateTextbox();
                }

                slider.textbox.selectionStart =
                slider.textbox.selectionEnd   = slider.textbox.savedValue.length - revPos - slider.suffix.length;
            }
        }
        else 
        {
            let curVal = slider.textbox.value;

            if (      e.key.length == 1
                   && !isDigitChar(e.key)
                   && e.key != '?'
                   && (   !slider.valueCanContainSuffix
                       || !slider.suffix.includes(e.key))
                   && (   !slider.showHex 
                       || !isHexDigitChar(e.key))
                   && (   slider.showHex
                       ||    e.key != '.'
                          && e.key != ',')
                   && !(   ((      e.code == 'Minus'
                                || e.code == 'NumpadSubtract')
                             && !curVal.includes('-'))
                        && slider.min < 0)
                ||     slider.readOnly
                   && !isArrowKey(e.code))
                e.preventDefault();


            curVal =
                curVal == '?'
                ? ''
                :   curVal.substring(0, slider.textbox.selectionStart) 
                  + curVal.substring(slider.textbox.selectionEnd, curVal.length);

                  
            const nextVal = parseFloat(curVal + e.key);

            if (   nextVal < slider.min - 0.001
                || nextVal > slider.max)
                e.preventDefault();            
        }
    });



    slider.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        const str = e.clipboardData.getData('text/plain');

        let val = 
            slider.showHex
            ? parseInt(str, 16)
            : parseFloat(str);

        val = Math.min(Math.max(slider.min, val), slider.max);

        slider.textbox.value = isNaN(val) ? '' : val;
    });



    slider.textbox.addEventListener('focusout', function()
    {
        if (slider.successOnFocusOut)
            slider.textbox.finish(true);
            
        slider.parentNode.removeChild(slider.textbox);
        slider.clicked = false;
    });
    


    slider.textbox.finish = function(success, focusSlider = true)
    {
        let   value      = slider.textbox.value;
        const savedValue = slider.textbox.savedValue;

        value = value.replace(slider.suffix, '');
        
        
        let   val        = value     .indexOf('?') > -1 ? Number.NaN : (slider.showHex ? parseInt(value,      16) : parseFloat(value     ));
        let   savedVal   = savedValue.indexOf('?') > -1 ? Number.NaN : (slider.showHex ? parseInt(savedValue, 16) : parseFloat(savedValue));

        if (!isNaN(val))
            val /= slider.valueScale;

       
        if (success) 
        {
            slider.setValue(
                   value.trim() != '' 
                && value.trim() != '-'
                ? val 
                : savedVal);
        }
        else
            slider.setValue(savedVal);

            
        slider.dispatchEvent(new CustomEvent('finishedit', { 'detail': {
            'success':  success,
            'value':    value,
            'oldValue': savedValue }}));


        slider.textbox.blur();

        slider.text.style.display = 'block';

        if (   slider.inFocus
            && focusSlider)
            slider.focus();
    };    
    
    

    slider.showTextbox = function()
    {
        slider.text.style.display = 'none';

        slider.inFocus = 
                slider == document.activeElement
            && !slider.clicked;
    
        slider.textbox.style.position  = 'absolute';
        slider.textbox.style.left      = '50%';
        slider.textbox.style.transform = 'translate(-50%)';
        slider.textbox.style.top       = slider.offsetTop    + 1;
        slider.textbox.style.width     = slider.offsetWidth  - 2;
        slider.textbox.style.height    = slider.offsetHeight - 2;
        slider.textbox.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
        slider.textbox.style.outline   = 'none';
        slider.textbox.style.textAlign = 'center';

        const isConnected =    
               slider.param != null
            && slider.param.input
            && slider.param.input.isConnected;

        enableElementText(
            slider.textbox, 
               !slider.readOnly
            && !isConnected);

        slider.updateTextbox();
        
        slider.parentNode.appendChild(slider.textbox);
        
        slider.textbox.focus();
        slider.textbox.select();

        slider.textbox.style.cursor = 'default';
    }



    slider.updateTextbox = function()
    {
        slider.textbox.value =
            (isNaN(slider.value)
             ? '?'
             : getNumberString(
                   slider.value * slider.valueScale, 
                   slider.displayDec, 
                   slider.showHex
               ).toUpperCase())
            + (slider.valueCanContainSuffix ? slider.suffix : '');
            
        slider.textbox.savedValue = slider.textbox.value;
    };
}


function initNumberSliderChildren(slider)
{
    slider.bar   = createDiv('numberSliderBar');
    slider.text  = createDiv('numberSliderText');
    slider.focus = createDiv('numberSliderFocus');

    slider.appendChild(slider.bar);
    slider.appendChild(slider.text);
    slider.appendChild(slider.focus);
}



function initNumberSlider(param, slider, width, height, id, name, showName, min, max, def, dec = 0, dragScale = 0.05, wheelScale = 1, acc = 0, suffix = '', log = false)
{
    slider.param                 = param;
    
    slider.className             = 'numberSlider';
    
    slider.width                 = width;
    slider.height                = height;
            
    slider.style.width           = width;
    slider.style.height          = height;
            
    slider.min                   = min;
    slider.max                   = max;
    slider.value                 = def;
    slider.acc                   = acc;
    
    slider.dec                   =
    slider.displayDec            = dec;
        
    slider.displayMin            = min;
    slider.displayMax            = max;
    slider.valueScale            = 1;
               
    slider.id                    = id;
    slider.name                  = name;
    slider.suffix                = suffix;
    slider.valueCanContainSuffix = false;
    slider.log                   = log;
    
    slider.dragScale             = dragScale;
    slider.wheelScale            = wheelScale;
            
    slider.backColor             = 'transparent';
    slider.valueColor            = '#7772';
    slider.textColor             = '#000';
               
    slider.fontSize              = 11;
            
    slider.style.display         = 'inline';
            
    slider.mouseOver             = false;
    slider.buttonDown0           = false;
    slider.buttonDown1           = false;
            
    slider.clickSize             = 4;
    slider.moved                 = false;
        
    slider.tabIndex              = 0;
    slider.inFocus               = false;
    slider.clicked               = false;

    slider.oldValue;

    slider.wrapValue             = false;
    
    slider.showName              = showName;
    slider.showHex               = false;
        
    slider.enableChangeEvent     = true;
    slider.successOnFocusOut     = false;
    
    slider.pointerEvents         = true;
    slider.readOnly              = false;
    
    slider.valueText             = '';
    
    slider.barTop                = 0;
    slider.barBottom             = 1;
    
    slider.ranges                = [];
    slider.rangeDivs             = [];
    
    slider.options               = []; // if dec == 0, show named choices instead of a value


    
    initNumberSliderChildren(slider);    
    initNumberSliderTextbox(slider);

    

    //

    slider.onstartchange = new Event('startchange');
    slider.onchange      = new Event('change');
    slider.onconfirm     = new Event('confirm');



    //

    slider.addEventListener('pointerdown', function(e)
    {
        if (graphView.spaceDown)
            return;

        if (e.button == 0)
        {
            if (!slider.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let opDiv = 
                   slider.parentNode
                && slider.parentNode.parentNode
                && slider.parentNode.parentNode.parentNode
                ? slider.parentNode.parentNode.parentNode
                : null;

            if (opDiv && opDiv.className == 'node') 
                graphView.putNodeOnTop(opDiv.op);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();
                
            slider.buttonDown0  = true;
            slider.buttonDown0_ = true;
            slider.moved        = false;
            slider.clientX      = e.clientX;
            slider.movedX       = 0;


            if (!slider.readOnly)
            {
                slider.oldValue   = slider.value;
                slider.startValue = slider.value;
                slider.prevValue  = slider.value;
                slider.sx         = e.clientX;

                slider.clickTimer = setTimeout(() => 
                {
                    if (!document.menuHadFocus)
                    {
                        slider.moved = true;
                        slider.lockPointer(e.pointerId);
                    }
                }, 
                500);
            }


            const objCol = colorStyleRgb(rgbActiveObject);

            if (   !slider.param
                || !slider.param.op.selected)
                slider.focus.style.boxShadow = '0 0 0 1px ' + objCol + ' inset';

            else
            {
                slider.focus.style.boxShadow = '0 1px 0 0 ' + objCol + ' inset';
                    
                if (param.op.params.indexOf(param) < param.op.params.length-1)
                    slider.focus.style.boxShadow += ', 0 -1px 0 0 ' + objCol + ' inset';
            }


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            slider.buttonDown1 = true;
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            slider.buttonDown2 = true;
        }
    });



    slider.addEventListener('pointermove', e =>
    {
        if (!slider.pointerEvents)
            return;
        

        let rect = boundingRect(slider);
        
        slider.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        slider.clientX = e.clientX;

        
        if (    slider.buttonDown0
            && !slider.readOnly)
        {
            if (slider.isPointerLocked())
            {
                slider.movedX  += e.movementX;
                
                if (!isNaN(slider.value))
                {
                    const dx       = slider.movedX;
                    const adaptive = 10 * Math.pow(Math.abs(dx), slider.acc);
                    const grain    = Math.pow(10, -slider.dec);
                    const drag     = grain * sqr(slider.dragScale);

                    const val = slider.startValue + dx * drag * adaptive;


                    // reset slider movement at the limits for better UX
                    const min = getCtrlKey(e) ? slider.min : slider.displayMin;
                    const max = getCtrlKey(e) ? slider.max : slider.displayMax;

                    slider.setValue(
                        Math.round(val / grain) * grain, 
                        true, 
                        false, 
                        false,
                        getCtrlKey(e));


                    if (   val <= min
                        || val >= max)
                    {
                        slider.movedX     = 0;
                        slider.startValue = slider.value;
                        slider.sx         = e.clientX;
                    } 


                    if (slider.value != slider.prevValue)
                        slider.param.op.pushUpdate();
                                        
                    slider.prevValue = slider.value;
                }
            }
            else
            {
                if (Math.abs(e.clientX - slider.sx) > slider.clickSize/2)
                {
                    slider.moved = true;
                    slider.lockPointer(e.pointerId);

                    slider.dispatchEvent(slider.onstartchange);
                }
            }
        }
        else if (graphView.tempConn
              && slider.param)
        {
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

            if (    graphView.tempConn.output
                &&  slider.param.input
                &&  graphView.tempConn.output.dataType == slider.param.input.dataType
                && !graphView.tempConn.output.op.follows(slider.param.op)
                && (  !slider.param.input.isConnected // not already connected to this input
                    || slider.param.input.connectedOutput != graphView.tempConn.output
                    || slider.param.input == savedInput))
            {
                graphView.overInput = slider.param.input;
                    
                slider.param.input.mouseOver = true;
                slider.param.input.updateControl();

                const rect = boundingRect(slider.param.input.control);

                graphView.tempConn.wire.inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - controlBar.offsetHeight);
            }
            else if ( graphView.tempConn.input
                  &&  slider.param.output
                  &&  graphView.tempConn.input.dataType == slider.param.output.dataType
                  && !slider.param.op.follows(graphView.tempConn.input.op))
            {
                graphView.overOutput = slider.param.output;
                    
                slider.param.output.mouseOver = true;
                slider.param.output.updateControl();


                const rect = boundingRect(slider.param.output.control);

                graphView.tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - controlBar.offsetHeight);


                graphView.tempConn.input.updateControl();
            }
        }
        else if (slider.readOnly)
        {
            slider.moved = true;
        }
    });
    
    
    
    slider.addEventListener('losecapture', function()
    {
        slider.buttonDown0 = false;
        slider.buttonDown1 = false;
        slider.buttonDown2 = false;
        slider.mouseOver   = false;
        slider.update();
    });



    slider.addEventListener('pointerup', function(e)
    {
        clearTimeout(slider.clickTimer);


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.op.follows(slider.param.op)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !slider.param.op.follows(graphView.tempConn.input.op)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overOutput.endConnection();
            }
        }
        
        else if (   slider.moved
            || document.menuHadFocus)
        {
            slider.unlockPointer(e.pointerId);
            return;            
        }

        else if (slider.buttonDown0_)
        {
            slider.clicked = true;
            slider.showTextbox();
        }

             if (e.button == 0) slider.buttonDown0 = false;
        else if (e.button == 1) slider.buttonDown1 = false;
        else if (e.button == 2) slider.buttonDown2 = false;

        slider.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && slider.buttonDown0)
        {
            slider.buttonDown0 = false;
            slider.unlockPointer(e.pointerId);

            slider.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            if (slider.value != slider.oldValue)
                slider.dispatchEvent(slider.onconfirm);
        }
        // else if (   e.button == 1
        //     && slider.buttonDown1)
        // {
        //     slider.buttonDown1 = false;            
        // }
    });


    
    slider.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.spaceDown
            && slider.pointerEvents)
        {
            if (graphView.tempConn)
                slider.style.cursor = 'default';
            
            else
                slider.style.cursor = 
                       slider.readOnly 
                    || containsChild(slider, slider.textbox) 
                    ? 'default' //(slider.readOnly ? 'default' : 'auto')
                    : 'ew-resize';
            
            if (slider.param)
            {
                slider.focus.style.boxShadow = '0  1px 0 0 rgba(0, 0, 0, 0.1) inset';
                
                if (param.op.params.indexOf(param) < param.op.params.length-1)
                    slider.focus.style.boxShadow += ', 0 -1px 0 0 rgba(0, 0, 0, 0.1) inset';
            }
            else
            {
                slider.focus.style.boxShadow  = '0 0 0 1px rgba(0, 0, 0, 0.1) inset ';
            }

            slider.focus.style.visibility = 'visible';
            slider.focus.style.opacity    = '100%';
    
            slider.update();
        }
    });



    slider.addEventListener('pointerleave', function(e)
    {
        slider.style.cursor           = 'default';
        
        slider.focus.style.visibility = 'hidden';
        slider.focus.style.opacity    = 0;

        slider.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.op != slider.param.op)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.op != slider.param.op)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    slider.addEventListener('wheel', e =>
    {
        if (!slider.pointerEvents)
            return;


        const isTouchpad = 
               Math.abs(e.deltaX) < 100
            && Math.abs(e.deltaY) < 100;


        if (isTouchpad)
        {
            e.preventDefault();
            return;
        }


        const dWheelX = e.deltaX /  20;
        const dWheelY = e.deltaY / 100;


        if (   !getCtrlKey(e)
            && !slider.buttonDown1)
        {
            e.stopPropagation();

            if (!slider.readOnly)
            {
                if (   document.activeElement
                    && document.activeElement.tagName.toLowerCase() == 'input'
                    && document.activeElement.slider)
                    document.activeElement.slider.textbox.finish(true, false);

                slider.oldValue = slider.value;

                const dec = Math.pow(10, -slider.dec);

                const val =
                    isTouchpad
                    ? slider.value -  dWheelX               * slider.wheelScale * dec
                    : slider.value + (dWheelY > 0 ? -1 : 1) * slider.wheelScale * dec;
                
                slider.setValue(val, true, true, false, false);
            }
        }
    });



    // graphView.addEventListener('touchstart', e =>
    // {
    //     graphView.touches.push(e);
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchmove', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches[i] = e;
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchend', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchcancel', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    slider.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            slider.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    slider.addEventListener('focus', function()
    {
        if (   !graphView.spaceDown
            && !slider.buttonDown1
            && slider.pointerEvents)
            slider.showTextbox();
    });


    
    slider.setName = function(name)
    {
        slider.name = name;
        slider.update();
    };



    slider.setValue = function(value, fireChangeEvent = true, confirm = true, forceChange = false, fullRange = true)
    {
        const oldValue = slider.value;


        if (isNaN(value))
            forceChange = true;

        else
        {
            const dec = Math.pow(10, Math.abs(slider.dec));
            value = Math.round(value * dec) / dec;

            if (slider.wrapValue)
            {
                while (value < slider.displayMin) value += slider.displayMax - slider.displayMin;
                while (value > slider.displayMax) value -= slider.displayMax - slider.displayMin;
            }
            else if (fullRange)
                value = Math.min(Math.max(slider.min, value), slider.max);
            else
                value = Math.min(Math.max(slider.displayMin, value), slider.displayMax);
        }


        if (   forceChange
            || isNaN(oldValue)
            || Math.abs(value - oldValue) > Number.EPSILON)
        {
            slider.value = value;

            slider.update();

            if (   fireChangeEvent
                && slider.enableChangeEvent
                && value != slider.prevValue)
                slider.dispatchEvent(slider.onchange);

            if (   confirm
                && slider.enableChangeEvent
                && value != oldValue)
                slider.dispatchEvent(slider.onconfirm);
        }
    };




    slider.setSuffix = function(suffix, valueCanContainSuffix = false)
    {
        slider.suffix                = suffix;
        slider.valueCanContainSuffix = valueCanContainSuffix;
    };
    


    slider.setMin = (min, dispatchEvents = true) =>
    {
        slider.min        = min;
        slider.displayMin = min;

        if (slider.value < min) 
            slider.setValue(min, true, true, dispatchEvents);
    };



    slider.setMax = (max, dispatchEvents = true) =>
    {
        slider.max        = max;
        slider.displayMax = max;

        if (max < slider.value) 
            slider.setValue(max, true, true, dispatchEvents);
    };



    slider.setDecimals = (dec, dspDec = dec) =>
    {
        slider.dec        = dec;
        slider.displayDec = dspDec;
    };



    slider.update = function()
    {
        const sw = slider.clientWidth;
        const sh = slider.clientHeight;

        const sx = slider.offsetLeft;
        const cx = -slider.displayMin / (slider.displayMax - slider.displayMin) * sw;
        const v  =  slider.value      / (slider.displayMax - slider.displayMin);

        slider.updateBar(sx, cx, v, sw, sh);
        slider.updateColors();
        slider.updateText();
        slider.updateFocus(sw, sh);
        
        updateSliderRanges(slider, sw, sh);
    };



    slider.updateBar = function(sx, cx, v, sw, sh)
    {
        if (isNaN(slider.value))
            slider.bar.style.display = 'none';

        else
        {
            slider.bar.style.display = 'block';

            const x = 
                v >= 0
                ? sx + cx
                : sx + cx + v * sw;

            slider.bar.style.left   = Math.max(0, x);
            slider.bar.style.width  = Math.min(Math.max(0, Math.round(Math.abs(v) * sw) + Math.min(0, x)), slider.offsetWidth);

            slider.bar.style.top    = sh * slider.barTop;
            slider.bar.style.height = sh * (slider.barBottom - slider.barTop);
        }
    };



    slider.updateColors = function()
    {
        slider     .style.background = slider.backColor;
        slider.bar .style.background = slider.valueColor;
        slider.text.style.color      = slider.textColor;
    };



    slider.updateText = function()
    {
        slider.text.innerHTML = '';
        
        if (   slider.name.length > 0
            && slider.showName)
            slider.text.innerHTML += '<span class="numberSliderName">' + slider.name + "</span>&nbsp;&nbsp;";

        slider.text.innerHTML += slider.getValueText() + slider.suffix;
    };



    slider.updateFocus = function(sw, sh)
    {
        slider.focus.style.left   = 0;
        slider.focus.style.top    = 0;
        slider.focus.style.width  = sw;
        slider.focus.style.height = sh;
    };



    slider.getValueText = function()
    {
        if (   slider.options.length > 0
            && slider.displayDec == 0)
        {
            if (   slider.value <  0 
                || slider.value >= slider.options.length)
                return '?';
            else
                return slider.options[Math.round(slider.value)];
        }
        else if (slider.valueText != '')
        {
            return slider.valueText;
        }
        else
        {
            return isNaN(slider.value)
                   ? '?'
                   : getNumberString(
                         slider.value * slider.valueScale, 
                         slider.displayDec, 
                         slider.showHex
                     ).toUpperCase();
        }
    };



    slider.lockPointer = function(pointerId)
    {
        clearTimeout(slider.clickTimer);

        slider.requestPointerLock =    
               slider.      requestPointerLock 
            || slider.   mozRequestPointerLock
            || slider.webkitRequestPointerLock;

        slider.requestPointerLock();
    };



    slider.unlockPointer = function(pointerId)
    {
        document.exitPointerLock =    
               document.      exitPointerLock    
            || document.   mozExitPointerLock
            || document.webkitExitPointerLock;

        document.exitPointerLock();
    };



    slider.isPointerLocked = function()
    {
        return (document.      pointerLockElement === slider 
             || document.   mozPointerLockElement === slider
             || document.webkitPointerLockElement === slider);
    }



    slider.update();
}


function initColorSliderTextbox(slider)
{
    slider.textbox = createTextbox('sliderText');
    
    
    slider.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            slider.textbox.finish(true);

        else if (e.code == 'Escape')
            slider.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.slider, .select, .menuSelect, button, .menuButton');
            var index = slider.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && slider.min < 0))
                e.preventDefault();

            var t = slider.textbox;

            var curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            var nextVal = parseFloat(curVal + e.key);

            if (   nextVal < slider.min - 0.001
                || nextVal > slider.max)
                e.preventDefault();            
        }
    });



    // slider.textbox.addEventListener('input', function()
    // {
    //     slider.setValue(Number(slider.textbox.value));
    // });



    slider.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(slider.min, val), slider.max);

        slider.textbox.value = isNaN(val) ? '' : val;
    });



    slider.textbox.addEventListener('focusout', function()
    {
        slider.parentNode.removeChild(slider.textbox);
        slider.clicked = false;
    });
    


    slider.textbox.finish = function(success)
    {
        if (success) slider.setValue(Number(slider.textbox.value     ));
        else         slider.setValue(Number(slider.textbox.savedValue));

        slider.textbox.blur();

        if (slider.inFocus)
            slider.focus();
    };    
    
    
    
    slider.showTextbox = function()
    {
        slider.inFocus = 
                slider == document.activeElement
            && !slider.clicked;
    
        slider.textbox.style.position = 'absolute';
    
        slider.textbox.style.left      = slider.offsetLeft   + 1;
        slider.textbox.style.top       = slider.offsetTop    + 1;
        slider.textbox.style.width     = slider.offsetWidth  - 2;
        slider.textbox.style.height    = slider.offsetHeight - 2;
        slider.textbox.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
        slider.textbox.style.outline   = 'none';
    
        slider.textbox.style.textAlign = 'center';
    
        slider.textbox.value      = numToString(slider.value, slider.dec);
        slider.textbox.savedValue = slider.textbox.value;
        
        slider.parentNode.appendChild(slider.textbox);
        
        slider.textbox.focus();
        slider.textbox.select();
    }
}


function initColorSliderChildren(slider)
{
    slider.text  = createDiv('sliderText');
    slider.focus = createDiv('sliderFocus');

    slider.appendChild(slider.text);
    slider.appendChild(slider.focus);
}



function initColorSlider(slider, width, height, name, def, dragScale, wheelStep, acc, suffix = '', log = false, backColor = '#fff', valueColor = '#eee', fontSize = 11)
{
    slider.className         = 'slider';

    slider.width             = width;
    slider.height            = height;
        
    slider.style.width       = width;
    slider.style.height      = height;
        
    slider.value             = def;
    slider.acc               = acc;
               
    slider.name              = name;
    slider.suffix            = suffix;
    slider.log               = log;

    slider.dragScale         = dragScale;
    slider.wheelStep         = wheelStep;
        
    slider.backColor         = backColor;
    slider.valueColor        = valueColor;
           
    slider.fontSize          = fontSize;
        
    slider.style.display     = 'inline';
        
    slider.mouseOver         = false;
    slider.buttonDown0       = false;
    slider.buttonDown1       = false;
        
    slider.clickSize         = 4;
    slider.moved             = false;
    
    slider.tabIndex          = 0;
    slider.inFocus           = false;
    slider.clicked           = false;

    slider.oldValue;

    //slider.wrapValue         = false;
    
    slider.enableChangeEvent = true;

    slider.pointerEvents     = true;

    slider.valueText         = '';



    initColorSliderChildren(slider);    
    initColorSliderTextbox(slider);

    

    //

    slider.onchange  = new Event('change');
    slider.onconfirm = new Event('confirm');



    //

    slider.addEventListener('pointerdown', function(e)
    {
        if (graphView.spaceDown)
            return;

        if (e.button == 0)
        {
            if (!slider.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let opDiv = 
                   slider.parentNode
                && slider.parentNode.parentNode
                && slider.parentNode.parentNode.parentNode
                ? slider.parentNode.parentNode.parentNode
                : null;

            if (opDiv && opDiv.className == 'node') 
                graphView.putNodeOnTop(opDiv.op);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();

            slider.buttonDown0  = true;
            slider.buttonDown0_ = true;
            slider.moved        = false;
            slider.clientX      = 0;
            slider.oldValue     = slider.value;

            slider.prevValue    = slider.value;
            slider.sx           = e.clientX;

            slider.focus.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject) + ' inset';
            
            


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();

            slider.clickTimer = setTimeout(function() 
            {
                onSliderClickTimer(slider); 
            }, 500);
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            slider.buttonDown1 = true;
        }
    });



    slider.addEventListener('pointermove', function(e)
    {
        if (!slider.pointerEvents)
            return;
        

        let rect = boundingRect(slider);
        
        slider.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;
        
        slider.clientX = e.clientX;

        
        if (slider.buttonDown0)
        {
            //slider.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
            
            if (slider.isPointerLocked())
            {
                slider.movedX += e.movementX;
                
                let dx       = slider.sx - slider.movedX;             
                let adaptive = 10 * Math.pow(Math.abs(dx), slider.acc);
                
                // TODO: if (log) do log scaling
                let val = slider.oldValue - dx*slider.dragScale*adaptive;
                
                const grain = Math.pow(10, -slider.dec);
                val = Math.floor(val / grain) * grain;
                
                slider.setValue(val, true, false);

                slider.prevValue = slider.value;
            }
            else
            {
                if (Math.abs(e.clientX - slider.sx) > slider.clickSize/2)
                {
                    slider.moved = true;
                    slider.lockPointer();
                }
            }
        }
        //else
        //    slider.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
        
        // slider.update();
    });
    
    
    
    slider.addEventListener('losecapture', function()
    {
        slider.buttonDown0 = false;
        slider.mouseOver   = false;
        slider.update();
    });



    slider.addEventListener('pointerup', function(e)
    {
        clearTimeout(slider.clickTimer);

        if (   slider.moved
            || document.menuHadFocus)
        {
            slider.unlockPointer(e.pointerId);
            return;            
        }    

        if (slider.buttonDown0_)
        {
            slider.clicked = true;
            slider.showTextbox();
        }
        
        if (slider.buttonDown1)
            slider.buttonDown1 = false;

        slider.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && slider.buttonDown0)
        {
            slider.buttonDown0 = false;
            slider.unlockPointer(e.pointerId);

            slider.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            if (slider.value != slider.oldValue)
                slider.dispatchEvent(slider.onconfirm);
        }
        if (   e.button == 1
            && slider.buttonDown1)
        {
            slider.buttonDown1 = false;            
        }
    });


    
    slider.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.spaceDown
            && slider.pointerEvents)
        {
            slider.style.cursor           = 'all-scroll';
            
            slider.focus.style.boxShadow  = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
            slider.focus.style.visibility = 'visible';
            slider.focus.style.opacity    = '100%';
    
            slider.update();
        }
    });



    slider.addEventListener('pointerleave', function(e)
    {
        slider.style.cursor     = 'default';
        
        slider.focus.style.visibility = 'hidden';
        slider.focus.style.opacity    = 0;

        slider.update();
    });



    slider.addEventListener('wheel', e =>
    {
        if (   !getCtrlKey(e)
            && !slider.buttonDown1)
        {
            e.stopPropagation();

            slider.oldValue = slider.value;
            slider.setValue(slider.value + (e.deltaY > 0 ? -1 : 1) * slider.wheelStep);
            // TODO conform after a delay and/or another action, same with key changes 
        }
    });



    slider.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            slider.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    slider.addEventListener('focus', function()
    {
        if (   !graphView.spaceDown
            && !slider.buttonDown1
            && slider.pointerEvents)
            slider.showTextbox();
    });


    
    slider.setValue = function(value, fireChangeEvent = true, confirm = true)
    {
        const oldValue = slider.value;

        // if (slider.wrapValue)
        // {
        //     while (value < slider.min) value += slider.max - slider.min;
        //     while (value > slider.max) value -= slider.max - slider.min;
        // }
        // else
        //     value = Math.min(Math.max(slider.min, value), slider.max);
        
        if (  !confirm
            || value != oldValue)
            slider.value = value;


        slider.update();


        if (   fireChangeEvent
            && slider.enableChangeEvent
            && value != slider.prevValue)
            slider.dispatchEvent(slider.onchange);


        if (   confirm
            && slider.enableChangeEvent
            && value != oldValue)
            slider.dispatchEvent(slider.onconfirm);
    };




    slider.update = function()
    {
        // let v  =  slider.value / (slider.max - slider.min);
        // let cx = -slider.min / (slider.max - slider.min) * slider.clientWidth;

        // slider.bar.style.background = slider.valueColor;

        // slider.bar.style.top    = 0;//slider.mouseOver ? 1 : 0;
        // slider.bar.style.height = slider.clientHeight;// - (slider.mouseOver ? 2 : 0);

        slider.focus.style.left   = 0;
        slider.focus.style.top    = 0;
        slider.focus.style.width  = slider.clientWidth;
        slider.focus.style.height = slider.clientHeight;

        // if (v >= 0)
        // {
        //     slider.bar.style.left  = slider.offsetLeft + Math.round(cx);
        //     slider.bar.style.width = Math.round(v * slider.clientWidth);
        // }
        // else
        // {
        //     slider.bar.style.left  = slider.offsetLeft + cx + v * slider.clientWidth;
        //     slider.bar.style.width = -v * slider.clientWidth;
        // }

        // slider.bar.style.background =
        //     slider.value >= 0
        //     ? slider.valueColor
        //     : 'repeating-linear-gradient(-60deg, #fff, #fff 1px, #e5e5e5 2px, #e5e5e5 3px, #fff 4px)';

        slider.text.innerHTML = '';
        
        if (slider.name.length > 0)
            slider.text.innerHTML += '<span class="sliderName">' + slider.name + "</span>&nbsp;&nbsp;";
        
        let valueText = 
            slider.valueText != ''
            ? slider.valueText
            : rgb2hex(slider.value);

        slider.text.innerHTML += valueText + slider.suffix;

        slider.style.backgroundColor = colorStyleRgb(slider.value);
    };



    slider.lockPointer = function()
    {
        slider.requestPointerLock =    
               slider.requestPointerLock 
            || slider.mozRequestPointerLock;

        slider.requestPointerLock();
        clearTimeout(slider.clickTimer);

        slider.movedX = 0;
        slider.sx     = 0;
    };



    slider.unlockPointer = function()
    {
        document.exitPointerLock =    
               document.exitPointerLock    
            || document.mozExitPointerLock;

        document.exitPointerLock();
    };



    slider.isPointerLocked = function()
    {
        return (document.pointerLockElement    === slider 
             || document.mozPointerLockElement === slider);
    }
    


    slider.update();
}



function onSliderClickTimer(slider)
{
    if (!document.menuHadFocus)
    {
        slider.moved = true;
        slider.lockPointer();
    }
}


function initSelectMenu(select)
{
    select.menu = createDiv('selectMenu');

    select.menu.hoverIndex       =  0;
    select.menu.tabIndex         =  0;

    select.menu.style.left       =  select.offsetLeft;
    select.menu.style.height     = 'auto';
    select.menu.style.textAlign  = 'center';
    select.menu.style.background = '#222';
    select.menu.style.zIndex     =  MAX_INT32-3;
    


    select.menu.addEventListener('focus', function() { select.menu.style.outline = 'none'; });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });        
    

    
    select.menu.tabIndex   = 0;
    
    select.menu.hoverIndex = 0;


    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = 'calc(100% + 1px)';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = colorStyleRgb(rgbActiveObject);
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = -1; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();
        select.dispatchChangeEvent();
        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initSelect(select, items)
{
    select.className = 'menuSelect';
    select.tabIndex = 0;    
    
    initSelectMenu(select);

    select.holding  = false;
    

    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function()
    {
        select.resetMenu();
        
        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            if (select.items[i].value == '-')
            {
                item.style.borderTop = '1px solid white';
                item.style.marginTop = '6px';
                item.style.height    = '4px';
                item.style.position  = 'relative';
                item.style.left      = '6px';
                
                item.disabled = true;
            }
            else
            {
                item.style.border = 'none';
                item.style.height = 24;

                item.disabled = false;

                sub.innerHTML = select.items[i].text;
            }

            item.appendChild(sub);
            select.menuWrap.appendChild(item);
        }


        let options = select.getElementsByTagName('option');
        for (const op of options) op.disabled = op.value == '-';
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();
            
            select.buttonDown0 = true;        
            select.setPointerCapture(e.pointerId);
            
            select.holding = false;
            setTimeout(function() { onSelectClickTimer(select); }, 200);
            
            select.menu.hoverIndex = select.getSelectedIndex();

            select.showMenu();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        let menuTop =
            select.offsetTop 
            - 3 // paddingTop
            - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
            - iy * 24;
        
        menuTop = Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
        iy = Math.min(Math.max(0, iy), select.items.length-1);
        return iy;
    };        
    

    
    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    }



    select.dispatchChangeEvent = function()
    {
        const onchange = new Event('change', 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        });

        select.dispatchEvent(onchange);
    };


    //////////////////////////////////////////////////////////////////////////////////

    
    select.items = items;
    
    select.update(0);
    select.updateItems();
}



function onSelectClickTimer(select)
{
    select.holding = true;
}


function initMenuSelectMenu(select)
{
    select.menu = createDiv('menuSelectMenu');

    select.menu.hoverIndex   = 0;
    select.menu.tabIndex     = 0;

    select.menu.style.left   = select.offsetLeft;
    select.menu.style.zIndex = MAX_INT32;

    select.menu.addEventListener('focus', function() 
    {
         select.menu.style.outline = 'none'; 
    });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });
    
    

    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = '100%';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = colorStyleRgb(rgbActiveObject);
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = 0; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();

        const onchange = new CustomEvent('change', { detail: 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        }});

        select.dispatchEvent(onchange);

        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initMenuSelectTextbox(select)
{
    select.textbox = createTextbox('menuSelectText');
    
    
    select.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            select.textbox.finish(true);

        else if (e.code == 'Escape')
            select.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            let tabs  = document.querySelectorAll('.slider, .menuSelect, .select, button, .menuButton');
            let index = select.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && select.min < 0))
                e.preventDefault();

            let t = select.textbox;

            let curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            let nextVal = parseFloat(curVal + e.key);

            if (   nextVal < select.min - 0.001
                || nextVal > select.max)
                e.preventDefault();            
        }
    });


    // slider.textbox.addEventListener('input', function()
    // {
    //     slider.setValue(Number(slider.textbox.value));
    // });


    select.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        let val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(select.min, val), select.max);

        select.textbox.value = isNaN(val) ? '' : val;
    });


    select.textbox.addEventListener('focusout', function()
    {
        select.parentNode.removeChild(select.textbox);
        select.clicked = false;
    });
    

    select.textbox.finish = function(success)
    {
        if (success) select.setValue(Number(select.textbox.value     ));
        else         select.setValue(Number(select.textbox.savedValue));

        select.textbox.blur();

        if (select.inFocus)
            select.focus();
    };    
    
    
    select.showTextbox = function()
    {
        select.inFocus = 
                select == document.activeElement
            && !select.clicked;
    
        select.textbox.style.position = 'absolute';
    
        select.textbox.style.left      = select.offsetLeft   + 1;
        select.textbox.style.top       = select.offsetTop    + 1;
        select.textbox.style.width     = select.offsetWidth  - 2;
        select.textbox.style.height    = select.offsetHeight - 2;
        select.textbox.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
        select.textbox.style.outline   = 'none';
    
        select.textbox.style.textAlign = 'center';
    
        select.textbox.value = numToString(select.value, select.dec);
        select.textbox.savedValue = select.textbox.value;
        
        select.parentNode.appendChild(select.textbox);
        
        select.textbox.focus();
        select.textbox.select();
    }
}


function initMenuSelect(select)
{
    select.className = 'menuSelect';
    select.tabIndex  = 0;    
    
    initMenuSelectMenu   (select);
    initMenuSelectTextbox(select);

    select.holding = false;

    select.enableChangeEvent = true;


    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function(items)
    {
        select.resetMenu();
        
        
        select.items = items;
        select.update(0);


        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            item.style.border      = 'none';
            item.style.height      = 24;

            item.disabled = false;

            sub.innerHTML = select.items[i].text;

            item.appendChild(sub);

            select.menuWrap.appendChild(item);
        }
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();

            var rect = boundingRect(select);

            if (e.clientX > rect.width - 20)
            {
                select.buttonDown0 = true;        
                select.setPointerCapture(e.pointerId);
                
                select.holding = false;
                setTimeout(function() { onSelectClickTimer(select); }, 200);
                
                select.menu.hoverIndex = select.getSelectedIndex();

                select.showMenu();
            }
            else
                select.showTextbox();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        // let menuTop =
        //     select.offsetTop; 
        //     - 3 // paddingTop
        //     - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
        //     - iy * 24;
        
        menuTop = select.offsetTop + select.offsetHeight + 11;//Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
            iy = Math.min(Math.max(0, iy), select.items.length-1);

        return iy;
    };        
    

    
    select.getSelectedValue = function()
    {
        return select.items[select.getSelectedIndex()].value;
    };        



    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    };



    select.setSelectedIndex = function(index)
    {
        select.value = select.items[index].value;
        select.update(select.getSelectedIndex());
        
        select.enableChangeEvent = false;
        select.dispatchChangeEvent();
        select.enableChangeEvent = true;
    };



    select.dispatchChangeEvent = function()
    {
        if (!select.enableChangeEvent)
            return;
    
        let index = select.getSelectedIndex();
    
        const onchange = new Event('change', 
        {
            selectedIndex: index,
            selectedValue: select.items[index].value
        });

        select.dispatchEvent(onchange);
    };
}



graphView.wires          = [];

graphView.loadingNodes   = false;
graphView.canUpdateNodes = true;


graphView.overNode       = null;
graphView.overInput      = null;
graphView.overOutput     = null;
   
graphView.headerInput    = null; // same as overInput, but when snapping from a header
graphView.headerOutput   = null; // same as overOutput, but when snapping from a header
   
graphView.tempConn       = null;
graphView.savedConn      = null;

graphView.connPointerId  = -1;

graphView.showWires      = true;
graphView._soloNode      = null;
   
graphView.selecting      = false;
graphView.selectionRect  = Rect.NaN;

graphView.btn1down       = false; // this is to help deal with mouse wheels that send X values as
                                  // sometimes a MMB press is followed by wheelX as a "deeper" middle-click

graphView.pan            = point(0, 0);
graphView.zoom           = 1;

graphView.panning        = false;

graphView.pViewport;
graphView.pStart         = point(0, 0);
graphView.zoomStart;


scrollbarX.style.zIndex  = MAX_INT32-1;
scrollbarY.style.zIndex  = MAX_INT32-2;


graphView.touches        = [];



graphView.addEventListener('pointerenter', e => 
{
    if (    graphView.hasPointerCapture(e.pointerId)
        && !graphView.tempConn)
        graphView.releasePointerCapture(e.pointerId);
});



graphView.addEventListener('pointerleave', e => 
{
    if (graphView.tempConn)
        graphView.setPointerCapture(e.pointerId);
});



graphView.addEventListener('pointerdown', e =>
{
    graphView.pStart = point(e.clientX, e.clientY);

    const sx = e.clientX;
    const sy = e.clientY;

    if (   e.button == 0                 
        && !graphView.panning
        && !document.canResizeX
        && !document.canResizeY
        && !scrollbarX.moving
        && !scrollbarY.moving)
    {
        if (graphView.spaceDown)
        {
            if (getCtrlKey(e)) graphView.startZoomSelection(e.pointerId, e.clientX, e.clientY);
            else               graphView.startPan(e.pointerId);
        }
        else if (graphView.overOutput)
        {
            graphView.overOutput.connecting = true;
            graphView.startConnectionFromOutput(e.pointerId, graphView.overOutput);
            graphView.updateNodeWire(graphView.tempConn.wire, sx, sy);
        }
        else if (graphView.overInput)
        {
            if (graphView.overInput.connectedOutput) // pretend to disconnect
            {
                oldReorderIndex = graphView.overNode.inputs.indexOf(graphView.overInput);

                graphView.startConnectionFromOutput(e.pointerId, graphView.overInput.connectedOutput, false);
                graphView.updateNodeWire(graphView.tempConn.wire, sx, sy);
                
                graphView.savedConn = graphView.overInput.connection;
                graphView.updateNodeWire(graphView.savedConn.wire);
            }
            else
            {
                graphView.overInput.connecting = true;
                graphView.startConnectionFromInput(e.pointerId, graphView.overInput);
                graphView.updateNodeWire(graphView.tempConn.wire, sx, sy);
            }
        }
        else // selection
        {
            graphView.lastSelectedNodes = [...graphView.selectedNodes];

            graphView.startSelection(
                e.pointerId, 
                e.clientX, 
                e.clientY, 
                e.shiftKey,
                getCtrlKey(e));
        }
    }
    
    else if (e.button == 1)
    {
        graphView.btn1down = true;
        setCursor(panCursor);
        graphView.startPan(e.pointerId);
    }
});



graphView.addEventListener('pointermove', graphView_onpointermove);



function graphView_onpointermove(e)
{
    graphView.p = point(e.clientX, e.clientY);


    if (   graphView.panning
        && graphView.hasPointerCapture(e.pointerId))
    {
        setTimeout(() =>
        {
            setCursor(panCursor);

            const dp = subv(graphView.p, graphView.pStart);

            graphView.setPanAndZoom(
                addv(graphView.panStart, dp), 
                graphView.zoom);
        });
    }
    
    else if (graphView.selecting)
        graphView.updateSelection(e.clientX, e.clientY, e.shiftKey, getCtrlKey(e));
    
    else if (graphView.zoomSelecting)
        graphView.updateZoomSelection(e.clientX, e.clientY);
    
    else if (graphView.tempConn)
    {
        graphView.updateNodeWire(
            graphView.tempConn.wire, 
            e.clientX, 
            e.clientY);
    }
}



graphView.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && graphView.spaceDown)
    {
        if (getCtrlKey(e))
        {
            if (   graphView.selectionRect.w > 0
                && graphView.selectionRect.h > 0)
            {
                graphView.endZoomSelection(e.pointerId, true);
            }
            else
            {
                graphView.endZoomSelection(e.pointerId, false);

                graphView.oldZoom = graphView.zoom;

                if (e.altKey) graphView.zoom /= 2;
                else          graphView.zoom *= 2;

                graphView.pan = subv(
                    graphView.pan, 
                    mulvs(
                        subv(
                            point(e.clientX, e.clientY), 
                            graphView.pan), 
                        graphView.zoom / graphView.oldZoom - 1));
            }
        }
        
        graphView.endPan(e.pointerId, false);
    }

    else if (e.button == 0
         && !graphView.selectionRect.isNaN)
        graphView.endSelection(e.pointerId);

    else if (e.button == 0
          && graphView.tempConn)
        graphView.endConnection(e.pointerId);

    else if (e.button == 1
          && graphView.panning)
    {
        graphView.btn1down = false;
        graphView.endPan(e.pointerId, true);
    }
});



graphView.addEventListener('wheel', e =>
{
    if (graphView.btn1down)
        return;


    e.preventDefault();


    const dZoom = Math.log(graphView.zoom) / Math.log(2);


    const isTouchpad = 
           Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;


    const dWheelX = e.deltaX / (isTouchpad ? 20 : 100);
    const dWheelY = e.deltaY / (isTouchpad ? 20 : 100);


    if (e.ctrlKey)
    {
        let pos = point(e.clientX, e.clientY);
        pos.y -= controlBar.offsetHeight;

        const zoom = Math.max(0.0001, Math.pow(2, dZoom - dWheelY / (isTouchpad ? 5 : 10)));
        const pan  = subv(graphView.pan, mulvs(subv(pos, graphView.pan), zoom / graphView.zoom - 1));

        graphView.setPanAndZoom(pan, zoom);
    }
    else
    {
        const dPanX = (e.shiftKey ? dWheelY : dWheelX) * 20 / Math.pow(graphView.zoom, 0.1);
        const dPanY = (e.shiftKey ? dWheelX : dWheelY) * 20 / Math.pow(graphView.zoom, 0.1);

        graphView.pan = point(
            graphView.pan.x - dPanX,
            graphView.pan.y - dPanY);

        if (graphView.selecting)
        {
            graphView.updateSelection(
                e.clientX, 
                e.clientY, 
                e.shiftKey);
        }
    }


    if (graphView.tempConn)
        graphView_onpointermove(e);
});



graphView.addEventListener('gesturestart', e => { graphView.zoomStart = graphView.zoom; });

graphView.addEventListener('gesturechange', e => 
{
    const p = point(
        graphView.p.x,
        graphView.p.y - controlBar.offsetHeight);

    const zoom = graphView.zoomStart * e.scale;
    const pan  = subv(graphView.pan, mulvs(subv(p, graphView.pan), zoom / graphView.zoom - 1));

    graphView.setPanAndZoom(pan, zoom);
});



graphView.addEventListener('touchstart', e =>
{
    graphView.touches.push(e);
    e.preventDefault();
});



graphView.addEventListener('touchmove', e =>
{
    for (let i = 0; i < graphView.touches.length; i++)
        if (graphView.touches[i].pointerId == e.pointerId)
        {
            graphView.touches[i] = e;
            break;
        }

    e.preventDefault();
});



graphView.addEventListener('touchend', e =>
{
    for (let i = 0; i < graphView.touches.length; i++)
        if (graphView.touches[i].pointerId == e.pointerId)
        {
            graphView.touches.splice(i, 1);
            break;
        }

    e.preventDefault();
});



graphView.addEventListener('touchcancel', e =>
{
    for (let i = 0; i < graphView.touches.length; i++)
        if (graphView.touches[i].pointerId == e.pointerId)
        {
            graphView.touches.splice(i, 1);
            break;
        }

    e.preventDefault();
});



graphView.getAllNodeBounds = function()
{
    let bounds = Rect.NaN;

    for (const node of graph.nodes)
        bounds = expandRect(bounds, boundingRect(node.div));

    return bounds;
};



graphView.getNodeBounds = node =>
{
    const bounds = boundingRect(node.div);

    return new Rect(
        parseFloat(node.div.style.left ),
        parseFloat(node.div.style.top  ),
        parseFloat(node.div.style.width),
        bounds.h / graphView.zoom); // node height isn't defined
}



graphView.getZoomedNodeBounds = node =>
{
    const bounds = graphView.getNodeBounds(node);

    bounds.x += graphView.pan.x / graphView.zoom;
    bounds.y += graphView.pan.y / graphView.zoom;
    bounds.w /= graphView.zoom;
    bounds.h /= graphView.zoom;

    return bounds;
};



graphView.getIntersectingNodes = node =>
{
    const nodeBounds = graphView.getZoomedNodeBounds(node);

    const intersecting = [];
    
    for (const n of graph.nodes)
    {
        const nBounds = graphView.getZoomedNodeBounds(n);
        
        if (   n != node
            && rectsIntersect(nBounds, nodeBounds))
        {
            intersecting.push(n);
        }
    }

    return intersecting;
}



graphView.placeNewNode = function(node)
{
    //log('graphView.placeNewNode()');

    const nodeRect = boundingRect(node.div);
    
    const btn = node._creatingButton;

    if (btn)
    {
        node.div.style.left = (btn.offsetLeft + btn.offsetWidth/2 - graphView.pan.x) / graphView.zoom - nodeRect.width/2;
        node.div.style.top  = (20 - graphView.pan.y) / graphView.zoom;
    }
    else
    {
        node.div.style.left = (graphView.offsetWidth /2 - graphView.pan.x                          ) / graphView.zoom - nodeRect.width/2;
        node.div.style.top  = (graphView.offsetHeight/2 - graphView.pan.y - controlBar.offsetHeight) / graphView.zoom - nodeRect.height/2;
    }


    // const nodeRect = boundingRect(node.div);

    // const defx = (graphView.offsetWidth /2 - graphView.pan.x) / graphView.zoom - nodeRect.width /2,
    //       defy = (graphView.offsetHeight/2 - graphView.pan.y - controlBar.offsetHeight) / graphView.zoom - nodeRect.height/2;

    // node.div.style.left = (graphView.offsetWidth  / 6 - graphView.pan.x) / graphView.zoom;
    // node.div.style.top  = (graphView.offsetHeight / 4 - graphView.pan.y) / graphView.zoom;


    // const dx = 30,
    //       dy = 20;

    // let   ox = defx,
    //       oy = defy;

        
    // let maxIter = 100; // stack overflow safeguard
    
    // let intersecting;
    // while (   maxIter-- > 0
    //        && (intersecting = graphView.getIntersectingNodes(node)).length > 0)
    // {
    //     let bounds = Rect.NaN;
        
    //     for (const n of intersecting)
    //         bounds = expandRect(bounds, graphView.getNodeBounds(n));

    //     const right = intersecting.reduce((a, b) => 
    //         graphView.getNodeBounds(a).r > graphView.getNodeBounds(b).r ? a : b);

    //     if (   right.opType == node.opType
    //         && node.opType != 'color'
    //         && node.opType != 'webcontrast') ox = bounds.b + dy;
    //     else                                 oy = bounds.r + dx;
    // }

    
    // const margin = 100;

    // node.div.style.left = (ox > margin && ox < window.clientWidth  - margin) ? ox : defx;
    // node.div.style.top  = (oy > margin && oy < window.clientHeight - margin) ? oy : defy;
};



graphView.putNodeOnTop = function(node)
{
    const topIndices = 
          1 
        + node.inputs.filter(i => i.isConnected).length 
        + (node.outputs.find(o => o.isConnected) ? 1 : 0);
        
    for (const n of graph.nodes)
        n.div.style.zIndex = Math.max(0, Number(n.div.style.zIndex) - topIndices);
        
    node.div.style.zIndex = MAX_INT32-3; // -3 is for scrollbars;

    graphView.putWiresOnTop(node);
};



graphView.putWiresOnTop = function(node)
{
    // changing z-index doesn't work so easily with SVG,
    // so reinsert the wires on top instead 🤷‍♂️

    let z = MAX_INT32;

    for (const input of node.inputs.filter(i => i.isConnected))
    {
        wireContainer.removeChild(input.connection.wire);
        wireContainer.appendChild(input.connection.wire);
    }
        
    for (const output of node.outputs)
    {
        for (const connInput of output.connectedInputs)
        {
            wireContainer.removeChild(connInput.connection.wire);
            wireContainer.appendChild(connInput.connection.wire);
        }
    }
};



graphView.updateNodeTransforms = function(nodes)
{
    const nodeLeft = nodes.map(n => n.div.offsetLeft);
    const nodeTop  = nodes.map(n => n.div.offsetTop);
    const nodeRect = nodes.map(n => graphView.getNodeOffsetRect(n.div));
    

    const wires = [];

    for (const node of nodes)
    {
        for (const input of node.inputs)
            if (   input.isConnected
                && input.connection
                && !wires.includes(input.connection.wire))
                wires.push(input.connection.wire);        

        for (const output of node.outputs)
            for (const connInput of output.connectedInputs)
                if (   connInput.connection
                    && !wires.includes(connInput.connection.wire))
                    wires.push(connInput.connection.wire);
    }


    for (let i = 0; i < nodes.length; i++)
        graphView.setNodeTransform(nodes[i], nodeLeft[i], nodeTop[i], nodeRect[i]);


    graphView.updateNodeWires(wires);
};



graphView.updateNodeTransform = function(node)
{
    const nodeLeft = node.div.offsetLeft;
    const nodeTop  = node.div.offsetTop;
    const nodeRect = graphView.getNodeOffsetRect(node.div);
    

    const wires = [];

    for (const input of node.inputs)
        if (   input.isConnected
            && input.connection)
            wires.push(input.connection.wire);        

    for (const output of node.outputs)
        for (const connInput of output.connectedInputs)
            if (connInput.connection)
                wires.push(connInput.connection.wire);


    graphView.setNodeTransform(node, nodeLeft, nodeTop, nodeRect);

    graphView.updateNodeWires(wires);
};



graphView.setNodeTransform = function(node, nodeLeft, nodeTop, nodeRect)
{
    node.div.style.transform =
          'translate(' 
        + (graphView.pan.x * graphView.zoom) + 'px, '  
        + (graphView.pan.y * graphView.zoom) + 'px) '
        + 'scale(' + graphView.zoom + ')';
    
    node.div.style.transformOrigin = 
          ((graphView.pan.x - nodeLeft) / nodeRect.width  * 100) + '% ' 
        + ((graphView.pan.y - nodeTop ) / nodeRect.height * 100) + '%';  
};



graphView.updateNodeWires = function(wires)
{
    const pOut    = [];            
    const pIn     = [];
    
    const cw      = graphView.clientWidth;
    const ch      = graphView.clientHeight;
    const yOffset = controlBar.offsetHeight;


    wires.forEach(w => 
    {
        const ro = boundingRect(w.connection.output.control);
        const ri = boundingRect(w.connection.input .control);

        pOut.push(point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset));
        pIn .push(point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset));
    });

    
    for (let i = 0; i < wires.length; i++)
    {
        const wire = wires[i];

        // the yOffset is to start wire coords just below the control bar,
        // not at the top of the window

        wire.updateCurve  (pOut[i].x, pOut[i].y, pIn[i].x, pIn[i].y);
        wire.updateOutBall(pOut[i].x, pOut[i].y                    );
        wire.updateInBall (                      pIn[i].x, pIn[i].y);

        wire.updateStyle(wire.getColor());

        wire.setAttribute('width',  cw);
        wire.setAttribute('height', ch);
    
        wire.setAttribute('viewBox',
                    0
            + ' ' + yOffset/2 // why is only half of yOffset taken???
            + ' ' + cw
            + ' ' + ch);
    }


    for (let i = 0; i < wires.length; i++)
    {
        const conn   = wires[i].connection;
        const input  = conn.input;
        const output = conn.output;

            const isSolo = 
                   graphView._soloNode
                && (    input.op == graphView._soloNode
                    || output.op == graphView._soloNode);

        show(wires[i],         (graphView.showWires || isSolo) && conn != graphView.savedConn);
        show(wires[i].curve,   (graphView.showWires || isSolo) && conn != graphView.savedConn);
        show(wires[i].outBall, !graphView.tempConn || graphView.tempConn.output);
        show(wires[i]. inBall, !graphView.tempConn || graphView.tempConn. input);
    }
};



graphView.updateNodeWire = function(wire, x = 0, y = 0)
{
    const yOffset = controlBar.offsetHeight;

    let pOut = point(0, 0),
        pIn  = point(0, 0);


    if (wire.connection.output)
    {
        const ro = boundingRect(wire.connection.output.control);
        pOut = point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset);
    }
    else
        pOut = point(x, y - yOffset);


    if (wire.connection.input)
    {
        const ri = boundingRect(wire.connection.input .control);
        pIn = point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset);
    }
    else
        pIn = point(x, y - yOffset);


    wire.update(
        pOut.x, 
        pOut.y, 
        pIn.x, 
        pIn.y);        
};



graphView.addWire = function(wire, updateTransform = true)
{
    graphView.wires.push(wire);
    wireContainer.appendChild(wire);

    if (updateTransform)
        graphView.updateNodeWire(wire);
};



graphView.removeWire = function(wire)
{
    wireContainer.removeChild(wire);    
    removeFromArray(graphView.wires, wire);
};



graphView.getNodeOffsetRect = function(node)
{
    const ox   = -graphView.pan.x / graphView.zoom;
    const oy   = -graphView.pan.y / graphView.zoom;

    const rect = boundingRect(node);

    return new DOMRect(
        ox + (rect.left / graphView.zoom),
        oy + (rect.top  / graphView.zoom), 
        rect.width      / graphView.zoom, 
        rect.height     / graphView.zoom);
};



graphView.soloNode = function(node)
{
    graphView._soloNode = node;

    graph.nodes.forEach(n => 
        n.div.style.opacity = 
            graphView._soloNode == n 
            ? 1 
            : 0.12);

    graph.connections.forEach(c =>
    { 
        c.wire.style.opacity = 
               c.input  && graphView._soloNode == c.input .op
            || c.output && graphView._soloNode == c.output.op
            ? 1 
            : 0.09;
    });

    graphView.updateNodeWires(graph.connections.map(c => c.wire));
};



graphView.unsoloNode = function()
{
    graphView._soloNode = null;

    graph.nodes.forEach(n => n.div .style.opacity = 1);

    graph.connections.forEach(c => c.wire.style.opacity = 1);
    graphView.updateNodeWires(graph.connections.map(c => c.wire));
};



graphView.toggleShowWires = function()
{
    graphView.showWires = !graphView.showWires;

    uiSaveGraphView();

    updateToggleShowWiresButton();
    graphView.updateShowWires();
};



graphView.updateShowWires = function()
{
    graph.nodes      .forEach(n => n.updateNode());
    graph.connections.forEach(c => show(c.wire, graphView.showWires));
};



graphView.toJson = function()
{
    const tab = '  ';

    return '{\n'
        + tab + '"zoom": "'      + graphView.zoom  + '",\n'
        + tab + '"panx": "'      + graphView.pan.x + '",\n'
        + tab + '"pany": "'      + graphView.pan.y + '",\n'
        + tab + '"showWires": "' + boolString(graphView.showWires) + '"\n'
        + '\n}';
};


graphView._pan = point(0, 0);
  
Object.defineProperty(graphView, 'pan',
{
    get: () => graphView._pan,
    set: pan =>
    {
        if (graphView._pan == pan) return;

        graphView._pan = pan;
        
        uiSaveGraphView();
        graphView.updatePanAndZoom();
    }
});



graphView.panning = false;
graphView.panStart;

graphView.spaceDown = false;


graphView._zoom   = 1;
graphView.oldZoom = 1;

Object.defineProperty(graphView, 'zoom',
{
    get: () => graphView._zoom,
    set: zoom =>
    {
        if (graphView._zoom == zoom) return;

        let pos = point(
            window.innerWidth /2,
            window.innerHeight/2);

        pos.y -= controlBar.offsetHeight;

        const pan = subv(graphView.pan, mulvs(subv(pos, graphView.pan), zoom / graphView.zoom - 1));

        graphView.setPanAndZoom(pan, zoom);
    }
});



graphView.zooming   = false;
graphView.zoomStart = 1;

graphView.zoomSelecting = false;



graphView.setPanAndZoom = (pan, zoom) =>
{
    if ((   pan  != graphView._pan
         || zoom != graphView._zoom)
        && zoom >=  0.02
        && zoom <= 50   ) 
    {
        graphView.oldZoom = graphView.zoom;

        graphView._zoom = zoom;
        graphView._pan  = pan;

        uiSaveGraphView();
        graphView.updatePanAndZoom();
    }
};



graphView.updatePanAndZoom = () =>
{
    graphView.updateNodeTransforms(graph.nodes);
    
    const x       = graphView.clientLeft;
    const w       = graphView.clientWidth;
    const h       = graphView.clientHeight;
    const yOffset = controlBar.offsetHeight;
    const bounds  = graphView.getAllNodeBounds();
    
    graphView.updateNodeTransforms(graph.nodes); // this has to be done twice because getAllNodeBounds() forces a reflow
    graphView.updateScroll(x, w, h, bounds, yOffset);

    btnZoom.innerHTML = Math.round(graphView.zoom * 100) + '%';
};



graphView.startPan = pointerId =>
{
    graphView.panning  = true;
    graphView.panStart = graphView.pan;
    graphView.setPointerCapture(pointerId);
    setCursor(panCursor);
};



graphView.endPan = (pointerId, changeCursor) =>
{
    graphView.panning = false;
    graphView.releasePointerCapture(pointerId);

    if (changeCursor)
        setAutoCursor();
};



graphView.startZoomSelection = (pointerId, x, y) =>
{
    graphView.setPointerCapture(pointerId);

    graphView.zoomSelecting = true;
    graphView.selectionRect = new Rect(x, y, 0, 0);
    
    selectBox.style.visibility = 'visible';
    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelection = (x, y) =>
{
    if (!graphView.zoomSelecting) return;

    graphView.selectionRect.w = x - graphView.selectionRect.x;
    graphView.selectionRect.h = y - graphView.selectionRect.y;

    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelectBox = () =>
{
    const selection = graphView.selectionRect;

    selectBox.style.left   = selection.x + Math.min(selection.w, 0);
    selectBox.style.top    = selection.y + Math.min(selection.h, 0);
    selectBox.style.width  = Math.abs(selection.w);
    selectBox.style.height = Math.abs(selection.h);

    selectBox.style.zIndex = MAX_INT32-3;
};



graphView.endZoomSelection = (pointerId, zoom) =>
{
    graphView.releasePointerCapture(pointerId);

    graphView.zoomSelecting    = false;
    selectBox.style.visibility = 'hidden';

    const selection = graphView.selectionRect;

    if (zoom)
    {
        // graphView.oldZoom = graphView.zoom;
        
        let box = {
            x: selection.x,
            y: selection.y - controlBar.offsetHeight,
            w: selection.w,
            h: selection.h };
            
        const wndHeight = graphView.offsetHeight; 

        const diff = { w: (window.innerWidth - box.w) / 2,
                       h: (wndHeight         - box.h) / 2 };

        graphView.setPanAndZoom(
            point(
                -(box.x - diff.w) * graphView.zoom,
                -(box.y - diff.h) * graphView.zoom),
            graphView.zoom * Math.min(
                window.innerWidth / box.w,
                wndHeight         / box.h));
    }

    graphView.selectionRect = Rect.NaN;
};


graphView._selectedNodes     = [];
graphView._prevSelectedNodes = [];
graphView.lastSelectedNodes  = [];


Object.defineProperty(graphView, 'selectedNodes',
{
    get: () => graphView._selectedNodes,
    set: selectedNodes =>
    {
        graphView.deselectAll();

        graphView._selectedNodes = [...selectedNodes];
    
        for (const node of graphView._selectedNodes)
            node.setSelected(true);
    }
});



graphView.deselectAll = () =>
{
    for (const node of graphView._selectedNodes)            
        node.setSelected(false);

    graphView._selectedNodes = [];
};



graphView.selectByIds = (nodeIds) =>
{
    graphView.deselectAll();

    for (const id of nodeIds)
    {
        const node = nodeFromId(id);
        graphView._selectedNodes.push(node);
        node.setSelected(true);
    }
};



graphView.startSelection = (pointerId, x, y, shiftKey, ctrlKey) =>
{
    graphView.setPointerCapture(pointerId);

    graphView.selecting = true;

    graphView.selectionRect = new Rect(x, y, 0, 0);
    graphView._prevSelectedNodes = [];
   
    selectBox.style.visibility = 'visible';

    graphView.updateSelectBox(shiftKey, ctrlKey);
};



graphView.updateSelection = (x, y, shiftKey, ctrlKey) =>
{
    if (!graphView.selecting) return;

    graphView.selectionRect.w = x - graphView.selectionRect.x;
    graphView.selectionRect.h = y - graphView.selectionRect.y;

    graphView.updateSelectBox(shiftKey, ctrlKey);
};



graphView.updateSelectBox = (shiftKey, ctrlKey) =>
{
    const wndRect = new Rect(
        1,
        controlBar.offsetHeight + 1,
        graphView.offsetWidth  - 2,
        graphView.offsetHeight - 5);

    
    let selection = validateRect(graphView.selectionRect);
    
    selection = clipRect(selection, wndRect);


    selectBox.style.left   = selection.x;
    selectBox.style.top    = selection.y;
    selectBox.style.width  = selection.width;
    selectBox.style.height = selection.height;


    const selected = [];

    for (const node of graph.nodes)
    {
        if (rectsIntersect(
                boundingRect(node.div), 
                selection))
            selected.push(node);
    }


    if (ctrlKey)
        graphView.selectedNodes = graphView.lastSelectedNodes.concat(selected);
    else if (shiftKey)
        graphView.selectedNodes = graphView.lastSelectedNodes
                             .filter(node => !selected.includes(node))
                             .concat(selected.filter(node => !graphView.lastSelectedNodes.includes(node)));
    else
        graphView.selectedNodes = selected;
    
        
    selectBox.style.zIndex = MAX_INT32-3;
        
        
    //updateGraphNodes();
    for (const node of selected)
        node.updateBorder();


    graphView._prevSelectedNodes = selected;
};



graphView.endSelection = pointerId =>
{
    if (   graphView.selectedNodes    .length > 0
        || graphView.lastSelectedNodes.length > 0)
    {
        actionManager.do(new SelectNodesAction(
            graphView.selectedNodes    .map(n => n.id), 
            graphView.lastSelectedNodes.map(n => n.id)));
    }


    graphView.releasePointerCapture(pointerId);

    graphView.selecting     = false;
    graphView.selectionRect = Rect.NaN;
    graphView._prevSelectedNodes = [];

    selectBox.style.visibility = 'hidden';
};


graphView.startConnectionFromOutput = (pointerId, output, updateTempWire = true) =>
{
    graphView.connPointerId = pointerId;

    graphView.tempConn = new Connection(output, null);
    graphView.tempConn.wire.output = output;

    graphView.addWire(graphView.tempConn.wire, false);

    if (updateTempWire)
    {
        graphView.updateNodeWire(
            graphView.tempConn.wire,
            graphView.pStart.x, 
            graphView.pStart.y);
    }
        
    output.updateControl();
};



graphView.startConnectionFromInput = (pointerId, input) =>
{
    graphView.connPointerId = pointerId;

    graphView.tempConn = new Connection(null, input);
    graphView.tempConn.wire.input = input;
    
    graphView.addWire(graphView.tempConn.wire, false);

    graphView.updateNodeWire(
        graphView.tempConn.wire,
        graphView.pStart.x, 
        graphView.pStart.y);

    input.updateControl();
};



graphView.cancelConnection = pointerId =>
{
    const output = graphView.tempConn.output;
    const input  = graphView.tempConn.input;

    graphView.removeWire(graphView.tempConn.wire);    

    graphView.savedConn = null;
    graphView.tempConn  = null;

    if (output) output.updateControl();
    if (input ) input .updateControl();

    if (graphView.overInput ) graphView.overInput .updateControl();
    if (graphView.overOutput) graphView.overOutput.updateControl();


    if (graphView.hasPointerCapture(pointerId))
        graphView.releasePointerCapture(pointerId);

    graphView.connPointerId = -1;

     newReorderIndex = Number.NaN;
    prevReorderIndex = Number.NaN;
     oldReorderIndex = Number.NaN;
};



graphView.endConnection = pointerId =>
{
    if (graphView.tempConn.output) // FROM OUTPUT
    {
        let output = graphView.tempConn.output;
        let input  = graphView.overInput;

        let savedInput = 
            graphView.savedConn
            ? graphView.savedConn.input
            : null;
        
        output.connecting = false;
        
        if (   input
            && input.dataType == output.dataType) // TO INPUT
        {
            if (   !isNaN(newReorderIndex)
                && !isNaN(oldReorderIndex))
                actionManager.do(new ReorderInputAction(input.op.id, oldReorderIndex, newReorderIndex));

            else if (input == savedInput) // reconnect old
            {
                graphView.savedConn = null; // done here to redraw the saved wire correctly
                graphView.updateNodeWire(input.connection.wire);
            }

            else if (savedInput)
                actionManager.do(new ReconnectAction(output, savedInput, input));

            else if (   !savedInput
                     && (  !input.isConnected
                         || input.connectedOutput != graphView.tempConn.output)) // connect new
                actionManager.do(new ConnectAction(output, input));
        }
        else if (savedInput) // disconnect old
            actionManager.do(new DisconnectAction(output, savedInput));
        
        graphView.cancelConnection(pointerId);
    }
    
    else if (graphView.tempConn.input) // FROM INPUT
    {
        let input  = graphView.tempConn.input;
        let output = graphView.overOutput;

        input.connecting = false;
        
        if (   output
            && output.dataType == input.dataType) // TO OUTPUT
            actionManager.do(new ConnectAction(output, input));

        graphView.cancelConnection(pointerId);
    }
};


// assuming here elementsFromPoint() will always return graphViewCapture as [0], and then the element I need
// graphViewCapture.addEventListener('pointerdown', e => forwardEvent(e, document.elementsFromPoint(e.clientX, e.clientY)[1]));
// graphViewCapture.addEventListener('pointermove', e => forwardEvent(e, document.elementsFromPoint(e.clientX, e.clientY)[1]));
// graphViewCapture.addEventListener('pointerup',   e => forwardEvent(e, document.elementsFromPoint(e.clientX, e.clientY)[1]));


scrollbarX.moving = false;
scrollbarY.moving = false;



graphView.updateScrollWithBounds = () =>
{
    const bounds = graphView.getAllNodeBounds();

    graphView.updateScroll(
        graphView.clientLeft,
        graphView.clientWidth,
        graphView.clientHeight,
        bounds,
        controlBar.offsetHeight);
};



graphView.updateScroll = (x, w, h, bounds, yOffset) =>
{
    graphView.updateScrollX(   w, h, bounds);
    graphView.updateScrollY(x, w, h, bounds, yOffset);

    scrollbarX.style.zIndex = MAX_INT32-1;
    scrollbarY.style.zIndex = MAX_INT32-2;
};



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollX = (w, h, bounds) =>
{
    if (bounds.l < 0)
    {
        const width = sqr(w) / (w - bounds.l) - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  width;
        scrollbarX.style.left    =  w - largeScrollGap - width;
        scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else if (bounds.r >= w)
    {
        const width = sqr(w) / bounds.r - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  width;
        scrollbarX.style.left    =  smallScrollGap;
        scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else
        scrollbarX.style.display = 'none';
};



scrollbarX.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarX.moving = true;
        scrollbarX.xStart = scrollbarX.offsetLeft;
        scrollbarX.wStart = scrollbarX.offsetWidth;
        scrollbarX.pStart = e.clientX;
        scrollbarX.setPointerCapture(e.pointerId);

        graphView.panStart = graphView.pan;

        for (const node of graph.nodes)
            node.div.slx = node.div.offsetLeft;
    }
});



scrollbarX.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarX.moving)
    {
        scrollbarX.moving = false;
        scrollbarX.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of graph.nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        if (bounds.l >= 0 && bounds.r < graphView.clientWidth)
            scrollbarX.style.display = 'none';
    }
});



scrollbarX.addEventListener('pointermove', e =>
{
    if (scrollbarX.moving)
    {
        var x = scrollbarX.xStart + e.clientX - scrollbarX.pStart;

        var l = x;
        var r = l + scrollbarX.wStart;

        l = Math.max(smallScrollGap, l);
        r = Math.min(r, graphView.clientWidth - largeScrollGap);

        l = Math.max(smallScrollGap, Math.min(l, r - smallScrollGap));
        r = Math.max(l + smallScrollGap, r);

        scrollbarX.style.left  = l;
        scrollbarX.style.width = r-l;

        graphView.pan = point(
            graphView.panStart.x - (e.clientX - scrollbarX.pStart) / scrollbarX.wStart * graphView.clientWidth,
            graphView.panStart.y);
    }
});



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollY = (x, w, h, bounds, yOffset) =>
{
    if (bounds.t < controlBar.offsetHeight)
    {
        const ot     = bounds.t - yOffset;
        const height = sqr(h) / (h - ot) - (smallScrollGap + largeScrollGap);

        scrollbarY.style.height  = height;
        scrollbarY.style.left    = x + w - smallScrollGap - 6;
        scrollbarY.style.top     = h - largeScrollGap - height;
        scrollbarY.style.display = 'inline-block';
    }
    else if (bounds.b >= yOffset + h)
    {
        const ob     = bounds.b - h;
        const height = sqr(h) / ob - (smallScrollGap + largeScrollGap);

        scrollbarY.style.height  = height;
        scrollbarY.style.left    = x + w - smallScrollGap - 6;
        scrollbarY.style.top     = smallScrollGap;
        scrollbarY.style.display = 'inline-block';
    }
    else
        scrollbarY.style.display = 'none';
};



scrollbarY.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarY.moving = true;
        scrollbarY.yStart = scrollbarY.offsetTop;
        scrollbarY.hStart = scrollbarY.offsetHeight;
        scrollbarY.pStart = e.clientY;
        scrollbarY.setPointerCapture(e.pointerId);

        for (const node of graph.nodes)
            node.div.sly = node.div.offsetTop;

        graphView.panStart = graphView.pan;
    }
});



scrollbarY.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarY.moving)
    {
        scrollbarY.moving = false;
        scrollbarY.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of graph.nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        if (bounds.t >= 0 && bounds.b < graphView.clientHeight)
            scrollbarY.style.display = 'none';
    }
});



scrollbarY.addEventListener('pointermove', e =>
{
    if (scrollbarY.moving)
    {
        var y = scrollbarY.yStart + e.clientY - scrollbarY.pStart;

        var t = y;
        var b = t + scrollbarY.hStart;

        t = Math.max(smallScrollGap, t);
        b = Math.min(b, graphView.clientHeight - largeScrollGap);

        t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
        b = Math.max(t + smallScrollGap, b);

        scrollbarY.style.top    = t;
        scrollbarY.style.height = b-t;

        graphView.pan = point(
            graphView.panStart.x, 
            graphView.panStart.y - (e.clientY - scrollbarY.pStart) / scrollbarY.hStart * graphView.clientHeight);
    }
});


class Parameter
extends EventTarget
{
    #type;
    get type() { return this.#type; }
    
    #id;
    get id() { return this.#id; }

    #name;
    get name() { return this.#name; }

    _op;
    get op()   { return this._op; }


    _control; get control() { return this._control; }
    _div;     get div()     { return this._div;     }


    input;
    output;

    
    onbeforechange = new Event('beforechange');
    onchange       = new Event('change');
    onconfirm      = new Event('confirm');
    onchangelock   = new Event('changelock');


    locked = false;

    showParamLock = false;
    paramLock;


    constructor(id, name, type)
    {
        super();

        this.#id   = id;
        this.#name = name;
        this.#type = type;

        this._div = createDiv();

        this.div.style.position = 'relative';
        this.div.style.padding  = 0;
        this.div.style.width    = '100%';

        this.input  = null;
        this.output = null;

        this.paramLock = createDiv('paramLock');
        this.paramLock.param = this;
        this.paramLock.addEventListener('pointerenter', paramLock_onpointerenter);
        this.paramLock.addEventListener('pointerleave', paramLock_onpointerleave);
        this.paramLock.addEventListener('pointerdown',  paramLock_onpointerdown );
        this.paramLock.addEventListener('pointerup',    paramLock_onpointerup   );
        this._div.appendChild(this.paramLock);

        enableElementText(this.div, true);

        this.updateLock();
    }



    setName(name, dispatchEvents = true)
    {
        this.#name = name; 
        this.update(dispatchEvents);
    }



    initInput(hasInput, dataType)
    {
        this.input = hasInput ? new Input(dataType) : null;
        if (!this.input) return;

        this.input._param = this;
        this.input.control.style.float     = 'left';
        this.input.control.style.position  = 'absolute';
        this.input.control.style.top       = '50%';
        this.input.control.style.transform = 'translateY(-50%)';
        this.div.appendChild(this.input.control);

        this.input.addEventListener('connect',    () => enableSliderText(this.control, false));
        this.input.addEventListener('disconnect', () => enableSliderText(this.control, true ));
    }



    initOutput(hasOutput, dataType)
    {
        this.output = hasOutput ? new Output(dataType) : null;
        if (!this.output) return;

        this.output._param = this;
        this.output.control.style.float     = 'right';
        this.output.control.style.position  = 'absolute';
        this.output.control.style.top       = '50%';
        this.output.control.style.transform = 'translateY(-50%)';
        
        this.div.appendChild(this.output.control);
    }



    isDefault() { return false; }


    
    update(dispatchEvents)
    {
        if (   this.input
            && this.input.isConnected)
            this.input.connectedOutput.op.update();

        if (this.showParamLock)
            this.paramLock.style.display = 'block';
        else
            this.paramLock.style.display = 'none';
    }    



    updateControls()
    {
        this.control.update();
        
        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    setOutputData() { }



    setLocked(locked)
    {
        this.locked = locked;
        this.updateLock();
    }



    updateLock()
    {
        let opacity = this.locked ? 0.5 : 0.1;
        
             if (this.paramLock.down0) opacity += 0.3;
        else if (this.paramLock.over ) opacity += 0.15;
        
        this.paramLock.style.background = 
            this.locked
            ? 'url(\'data:image/svg+xml;utf8,<svg width="5" height="7" viewBox="0 0 5 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.57143 1.75V2.8H1.42857V1.75C1.42857 1.1701 1.90826 0.7 2.5 0.7C3.09174 0.7 3.57143 1.1701 3.57143 1.75ZM0.714286 2.8V1.75C0.714286 0.783503 1.51378 0 2.5 0C3.48622 0 4.28571 0.783503 4.28571 1.75V2.8H4.64286C4.8401 2.8 5 2.9567 5 3.15V6.65C5 6.8433 4.8401 7 4.64286 7H0.357143C0.159899 7 0 6.8433 0 6.65V3.15C0 2.9567 0.159899 2.8 0.357143 2.8H0.714286Z" fill="black" fill-opacity="'+opacity+'" /></svg>\')'
            : 'url(\'data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.30997 3.10005V3.80005H4.66913C4.86749 3.80005 5.02829 3.95675 5.02829 4.15005V7.65005C5.02829 7.84332 4.86749 8.00005 4.66913 8.00005H0.359164C0.160803 8.00005 0 7.84332 0 7.65005V4.15005C0 3.95675 0.160803 3.80005 0.359164 3.80005H3.59164V2.05005C3.59164 1.08355 4.39566 0.300049 5.38746 0.300049C6.37926 0.300049 7.18328 1.08355 7.18328 2.05005V3.10005H6.46495V2.05005C6.46495 1.47015 5.98254 1.00005 5.38746 1.00005C4.79237 1.00005 4.30997 1.47015 4.30997 2.05005V3.10005Z" fill="black" fill-opacity="'+opacity+'" /></svg>\')';

        this.paramLock.style.backgroundPosition = '50% 50%';
        this.paramLock.style.backgroundRepeat   = 'no-repeat';

        this.paramLock.style.left = this.locked ? 11 : 12;
        this.paramLock.style.top  = this.locked ?  4 :  3;
    }



    preSetValue(value, confirm, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (value != this.oldValue)
                this.dispatchEvent(this.onbeforechange);
        }
    }



    setValue(value, confirm, updateControl = true, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (value != this.oldValue)
            {
                this.dispatchEvent(this.onchange);
                
                if (confirm)
                {
                    actionManager.do(new SetParamValueAction(this, value));
                    this.dispatchEvent(this.onconfirm);
                }
            }
        }
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);

        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + this.value + '"]';
    }
}



function paramLock_onpointerenter(e)
{
    const paramLock = e.target;

    paramLock.over = true;
    paramLock.param.updateLock();
}



function paramLock_onpointerleave(e)
{
    const paramLock = e.target;

    paramLock.over = false;
    paramLock.param.updateLock();
}



function paramLock_onpointerdown(e)
{
    const paramLock = e.target;

    // e.preventDefault();
    e.stopPropagation();

    if (e.button == 0)
    {
        paramLock.down0 = true;
        paramLock.param.updateLock();
    }
}



function paramLock_onpointerup(e)
{
    const paramLock = e.target;

    if (e.button == 0)
    {
        paramLock.down0 = false;
        paramLock.param.locked = !paramLock.param.locked;
        paramLock.param.updateLock();

        paramLock.param.dispatchEvent(paramLock.param.onchangelock);
    }
}


class   NumberParam
extends Parameter
{
    defaultValue;
    
    allowEditDecimals = true;
    

    get value()      { return this._control.value;    }
    set value(value) { this._control.setValue(value); }
    
    get oldValue()   { return this._control.oldValue; }


    
    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                value     = 0, 
                min       = Number.MIN_SAFE_INTEGER, 
                max       = Number.MAX_SAFE_INTEGER,
                decimals  = 0,
                dragScale = 0.05)
    {
        super(id, name, 'number');

        this._control       = createDiv();
        
        this.control.param  = this;
        this.control.zIndex = 0;
   
        this.defaultValue   = value;


        initNumberSlider(
            this,
            this.control,
            120,        // width
            20,         // height
            this.id,
            this.name, 
            showName,
            min,
            max,
            value,      // default
            decimals,   // decimals
            dragScale); // drag scale

        this.control.successOnFocusOut = true;

        this.div.appendChild(this.control);

       
        this.initInput (hasInput,  'number');
        this.initOutput(hasOutput, 'number');


        this.control.addEventListener('change',  () => { this.setValue(this.value, false, false); });
        this.control.addEventListener('confirm', () => { this.setValue(this.value, true,  false); });

        this.control.addEventListener('finishedit', e =>
        { 
            const dec    = getDecimalCount(e.detail.value);
            const oldDec = getDecimalCount(e.detail.oldValue);

            if (   e.detail.success
                && (   Math.abs(e.detail.value - e.detail.oldValue) <= Number.EPSILON
                    || dec >= oldDec)
                && this.allowEditDecimals)
            {
                const _dec = Math.log10(this.control.valueScale);

                actionManager.do(new SetParamDecimalsAction(this,
                    dec    + _dec, 
                    oldDec + _dec,
                    dec, 
                    oldDec
                ), true);
            }
        });
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.control.setName(name);
    }



    setDecimalsFrom(strValue)
    {
        this.setDecimals(getDecimalCount(strValue));
    }



    setDecimals(dec, displayDec)
    {
        this.control.setDecimals(dec, displayDec);
        this.control.update();
        this.op.pushUpdate();
    }



    isDefault()
    {
        return this.value == this.defaultValue;
    }



    update(dispatchEvents)
    {
        super.update();

        if (   this.input
            && this.input.isConnected)
        {
            this.setDecimals(this.input.data.decimals);

            this.setValue(
                this.input.data.value, 
                false, 
                true, 
                dispatchEvents);
        }
    }



    setOutputData()
    {
        if (this.output)
        {
            this.output._data = dataFromNumber(
                this.control.value,
                   this.input
                && this.input.isConnected
                ? this.input.data.decimals
                : this.control.dec);
        }
    }



    setValue(value, confirm, updateControl = true, dispatchEvents = true, forceChange = false) 
    {
        this.preSetValue(value, confirm, dispatchEvents);

        if (updateControl)
            this._control.setValue(value, false, false, forceChange); 

        super.setValue(value, confirm, updateControl, dispatchEvents);
    }    



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + getNumberString(this.value, this._control.dec) + '"]';
    }
}


class   ColorParam
extends Parameter
{
    defaultValue;
    
    
    get value()      { return this._control.value;    }
    set value(value) { this._control.setValue(value); }
    
    get oldValue()   { return this._control.oldValue; }


    
    input;
    output;

    

    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    constructor(name, 
                hasOutput,
                value     = [0, 0, 0],
                dragScale = 0.05)
    {
        super(name, 'color');

        this._control = createDiv();
        
        this.control.param  = this;
        this.control.zIndex = 0;

        this.defaultValue = value;

        this.control.style.height = 20;


        initColorSlider(
            this.control,
            120,       // width
            20,        // height
            this.name, 
            value,     // default
            dragScale, // drag scale
            1,         // wheel step
            0,         // decimals
            0,         // acceleration
            '');       // suffix



        this.div.appendChild(this.control);


        this.initInput();
        this.initOutput(hasOutput);



        this.control.addEventListener('change', e =>
        {
            this.op.valid = false;
            uiSetParam(this, this.value);
        });


        this.control.addEventListener('confirm', e =>
        {
            this.op.valid = false;
            //actionManager.do(new SetParamValueAction(this, this.value));
        });
    }



    isDefault()
    {
        return this.value == this.defaultValue;
    }



    setValue(value, fireChangeEvent = true, confirm = true) 
    { 
        //this._control.setValue(value, fireChangeEvent, confirm); 
    }
}


class   SelectParam
extends Parameter
{
    defaultValue;

    options = [];
    

    
    get value()      { return this._control.value;    }
    set value(value) { this._control.setValue(value); }
    
    get oldValue()   { return this._control.oldValue; }



    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    constructor(id,
                name,
                showName,
                hasInput,
                hasOutput,
                options,
                value = 0)
    {
        super(id, name, 'number');

        this._control       = createDiv();
        
        this.control.param  = this;
        this.control.zIndex = 0;

        this.options        = options;
        
        this.defaultValue   = value;


        initNumberSlider(
            this,
            this.control,
            120,       // width
            20,        // height
            this.id,
            this.name, 
            showName,
            0,
            options.length-1,
            value,     // default
            0,         // decimals
            0.02);


        this.control.options           = [...options];
        this.control.successOnFocusOut = true;
        this.control.barTop            = 0.8;

        this.div.appendChild(this.control);


        this.initInput (hasInput,  'number');
        this.initOutput(hasOutput, 'number');

            
        this.control.addEventListener('change',  () => { this.setValue(this.value, false, false); });
        this.control.addEventListener('confirm', () => { this.setValue(this.value, true,  false); });
    }



    setDecimalsFrom(strValue)
    {
        this.setDecimals(getDecimalCount(strValue));
    }



    setDecimals(dec, displayDec)
    {
        this.control.setDecimals(dec, displayDec);
        this.control.update();
        this.op.pushUpdate();
    }



    isDefault()
    {
        return this.value == this.defaultValue;
    }



    update(dispatchEvents)
    {
        super.update();

        if (   this.input
            && this.input.isConnected)
            this.setValue(Math.round(this.input.data.value), false, true, dispatchEvents); // assuming the data types match
    }



    setOutputData()
    {
        if (this.output)
            this.output._data = dataFromNumber(this._control.value, 0);
    }



    setValue(value, confirm, updateControl = true, dispatchEvents = true, forceChange = false) 
    { 
        this.preSetValue(value, confirm, dispatchEvents);

        if (updateControl)
            this._control.setValue(value, false, false, forceChange); 

        // if (this.output)
        //     this.output._data = dataFromNumber(value);
            
        super.setValue(value, confirm, updateControl, dispatchEvents);
    }    
}


const rgbObject       = hex2rgb('#bee0ff');
const rgbActiveObject = hex2rgb('#18a0fb');
const rgbNumber       = hex2rgb('#ddd');
const rgbActiveNumber = hex2rgb('#787878');
const rgbColor        = hex2rgb('#ddd');   //hex2rgb('#cc33cc'); // these are normally
const rgbActiveColor  = hex2rgb('#787878');//hex2rgb('#ff00ff'); // not used



function dataType2rgb(dataType, active)
{
    switch (dataType)
    {
        case 'number': return active ? rgbActiveNumber : rgbNumber;
        case 'color':  return active ? rgbActiveColor  : rgbColor;
        case 'object': return active ? rgbActiveObject : rgbObject;
    }

    return 'magenta';
}



function dataFromNumber(num, dec = -1)
{
    return {
        type:    'number',
        value:    floorTo(num, dec),
        decimals: dec
    };
}



function dataFromDataColor(color)
{
    return {
        type:   'color',
        color:   color,
        isValid: isRgbValid(dataColor2rgb(color))
    };
}



function dataFromRectangle(x, y, width, height, angle, round)//, nodeId, opType)
{
    return {
        type: 'object',

        //nodeId: nodeId,
        //opType: opType,

        x:      x,
        y:      y,
        width:  width,
        height: height,
        angle:  angle,
        round:  round
        //color: color
    };
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


class Graph
{
    nodes        = [];
    deferNodeIds = [];
    
    mutex        = false;

    connections  = [];



    clear()
    {
        this.deleteNodes(this.nodes.map(n => n.id));
        this.connections = [];
    }



    getNewNodeId(curId, id)
    {
        if (!this.nodes.find(n => n.id == id))
            return id;
        

        let numLength = this.getNumLength(id);

        if (numLength > 0)
        {
            const len = id.length - numLength;
            let   num = parseInt(id.substring(len));

            let newId = '';
            while (newId == '' || this.nodes.find(n => n.id == newId))
                newId = id.substring(0, len) + (++num);

            return newId;
        }

        else if (numLength == 0)
        {
            let num   = 2;
            let newId = id + num;

            while (this.nodes.find(n => 
                   n.id != curId 
                && n.id == newId))
                newId = id + (++num);

            return newId;
        }

        else
            return id;
    }
    
    
    
    getNumLength(name)
    {
        let numLength = 0;

        for (let i = name.length - 1; i >= 0; i--)
        {
            if (isDigitChar(name[i])) numLength++;
            else break;
        }

        return numLength;
    }
    
    

    addNodes(nodes, placeNode = true)
    {
        for (const node of nodes)
            this.addNode(node, placeNode);
        
        setTimeout(() => nodes.forEach(n => n.updateNode()));
    }



    addNode(node, placeNode = true, updateLabel = true)
    {
        node.graph = this;

        node._id = this.getNewNodeId(node.id, node.id);
        
        this.nodes.push(node);
        graphView.appendChild(node.div);
        
        if (placeNode)
            graphView.placeNewNode(node);
        
        node.div.style.zIndex = graph.nodes.length-1;

        graphView.putNodeOnTop(node);
        graphView.updateScrollWithBounds();

        if (updateLabel)
            setTimeout(() => node.updateNode());
    }
    


    deleteNodes(nodeIds)
    {
        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            for (let i = node.inputs.length-1; i >= 0; i--) // backwards for the sake of variable inputs
            {
                const input = node.inputs[i];
                if (!input.isConnected) continue;

                uiMakeNodeActive(input.connectedOutput.op);
                this.disconnect(input, true);
            }
            
            for (let i = node.outputs.length-1; i >= 0; i--)
            {
                const output = node.outputs[i];
                
                for (const connInput of output.connectedInputs)
                {
                    this.disconnect(connInput, true);
    
                    // if (!activeNodeInTree(connInput.op))
                    //     lastNodesInTreeFrom(connInput.op).forEach(n => uiMakeNodeActive(n));
                    //     uiMakeNodeActive(connInput.op.lastNodeInTree);
                }
            }
            
            node.selected = false;
            node.graph    = null;

            removeFromArray(this.nodes, node);
            graphView.removeChild(node.div);
        }

        graphView.updateScrollWithBounds();
    }



    connect(output, input, inputIndex = -1)
    {
        //console.log('graph.connect()');
        if (input.connectedOutput == output)
            return null;
            

        if (input.connectedOutput)
        {
            const output = input.connectedOutput;
            this.disconnect(input);
            output.updateControl();
        }


        if (   input.op._variableInputs
            && inputIndex > -1)
        {
            input = lastOf(input.op.inputs);
            
            // move new input back to correct index
            moveIn(input.op.inputs, input.op.inputs.length-1, inputIndex);

            input.op.inputControls.insertBefore(
                lastOf(input.op.inputControls.childNodes), 
                input.op.inputControls.childNodes[inputIndex]);
        }


        output.connectedInputs.push(input);
        input .connectedOutput = output;


        const conn = new Connection(output, input);

        input .connection = conn;
        output.connection = conn;
        
        graphView.addWire(conn.wire);

        this.connections.push(conn);

        
        // output.op.makePassive();

        // if (!activeNodeInTree(input.op))
        //     uiMakeNodeActive(input.op);
       
           
        output.updateControl();


        return conn;
    }



    disconnect(input)
    {
        //console.log( 'graph.disconnect(' + input.op.id + '.in[' + input.op.inputs.indexOf(input) + '])');
        // first remove the current output

        // if (activeNodeInTree(input.op))
        //     uiDeleteCanvasObjects([activeNodeInTree(input.op).id]);


        // then disconnect

        var output = input.connectedOutput;
        if (!output) return false;


        graphView.removeWire(input.connection.wire);

        removeFromArray(this.connections, input.connection);
        removeFromArray(output.connectedInputs, input);

        
        input .connectedOutput = null;
        input .connection      = null;
        output.connection      = null;


        if (input.param)
            input.param.valueText = '';


        // if (!activeNodeInTree(output.op))
        //      uiMakeNodeActive(output.op);
            
        
        output.updateControl();
        input.op.pushUpdate();


        return true;
    }
}



function nodesToJson(nodes, encloseBraces = true, connOutputMustBeInNodes = true)
{
    const tab = '  ';

    
    let json = 
          (encloseBraces ? '{\n' : '')
          + tab + '"nodes":\n'
          + tab + '[';


    let first = true;
    for (let i = 0; i < nodes.length; i++)
    {
        if (!first) json += ','; first = false;
        json += '\n' + nodes[i].toJson(4);
    }
    

    json += 
            '\n' + 
          tab + ']';
          
          
    json += this.connectionsToJson(nodes, connOutputMustBeInNodes);


    json += (encloseBraces ? '\n}' :'');


    return json;
}



function connectionsToJson(nodes, connOutputMustBeInNodes)
{
    const connections = [];


    for (let i = 0; i < nodes.length; i++)
    {
        let node = nodes[i];

        for (let j = 0; j < node.inputs.length; j++)
        {
            if (   !node.inputs[j].isConnected
                ||    !nodes.includes(node.inputs[j].connectedOutput.op)
                   && connOutputMustBeInNodes)
                continue;

            connections.push(node.inputs[j].connection);
        }
    }
    

    if (connections.length == 0)
        return '';


    const tab = '  ';

    let json = 
          ',\n'
        + tab + '"connections":\n'
        + tab + '[';

    
    for (let i = 0; i < connections.length; i++)
    {
        if (i > 0) json += ',';
        json += '\n' + connections[i].toJson(4);
    }


    json += '\n'
        + tab + ']';


    return json;
}



function createNode(opType, creatingButton = null)//, createdNodeId = -1)
{
    let node;

    switch (opType)
    {
        case 'number':           node = new OpNumber();           break;
        case 'minmax':           node = new OpMinMax();           break;
        case 'add':              node = new OpAdd();              break;
        case 'subtract':         node = new OpSubtract();         break;
        case 'multiply':         node = new OpMultiply();         break;
        case 'divide':           node = new OpDivide();           break;
        case 'modulo':           node = new OpModulo();           break;
        case 'exponent':         node = new OpExponent();         break;
        case 'interpolate':      node = new OpInterpolate();      break;
        // case 'random': node = new OpRandom(); break;
        
        case 'color':            node = new OpColor();            break;
        case 'validatecolor':    node = new OpValidateColor();    break;
        case 'colorinterpolate': node = new OpColorInterpolate(); break;
        case 'webcontrast':      node = new OpWebContrast();      break;
        case 'colorblind':       node = new OpColorblind();       break;
        
        case 'rectangle':        node = new OpRectangle();        break;
        case 'row':              node = new OpRow();              break;
        // case 'column': node = new OpColumn(); break;
        //case 'spread': node = new OpSpread(); break;
    }
    
    node._creatingButton = creatingButton;

    return node;
}



function nodeFromId(id)
{
    return graph.nodes.find(n => n.id == id);
}


// function activeNodeInTree(node) 
// { 
//     const left  = activeNodeLeft(node);  if (!!left ) return left;
//     const right = activeNodeRight(node); if (!!right) return right;

//     return null;
// }



// function activeNodeLeft(node)
// {
//     if (node.active) return node;

//     for (const input of node.inputs)
//     {
//         if (input.isConnected)
//         {
//             const left = activeNodeLeft(input.connectedOutput.op);
//             if (left) return left;
//         }
//     }

//     return null;
// }



// function activeNodeRight(node)
// {
//     if (node.active) return node;

//     for (const output of node.outputs)
//     {
//         for (const connInput of output.connectedInputs)
//         {
//             const right = activeNodeRight(connInput.op);
//             if (right) return right;
//         }
//     }

//     return null;
// }



function getAllNodesFromNode(node, ignore = [])
{
    const nodes = [node];


    if (!ignore.includes(node)) 
        ignore.push(node);


    for (const input of node.inputs.filter(i => i.isConnected))
    {
        const op = input.connectedOutput.op;
        if (ignore.includes(op)) continue;

        nodes.push(...getAllNodesFromNode(op, ignore));
    }


    for (const output of node.outputs)
    {
        for (const _input of output.connectedInputs)
        {
            const op = _input.op;
            if (ignore.includes(op)) continue;

            nodes.push(...getAllNodesFromNode(op, ignore));
        }
    }


    return nodes;
}



function getNodesAcrossNode(node)
{
    let nodes = [];

    nodes = [...nodes, ...getNodesBeforeNode(node)];
    nodes = [...nodes, ...getNodesAfterNode (node)];

    return nodes;
}


function getNodesBeforeNode(node)
{
    let before = [];

    for (const input of node.inputs.filter(i => i.isConnected))
    {
        if (!before.includes(input.connectedOutput.op)) // avoid including diamond tips twice
            before.push(input.connectedOutput.op);
    
        before.push(...getNodesBeforeNode(input.connectedOutput.op));
    }

    return before;
}



function getNodesAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
        for (const input of output.connectedInputs)
        {
            if (!after.includes(input.op)) // avoid including diamond tips twice
                after.push(input.op);

            after.push(...getNodesAfterNode(input.op));
        }

    return after;
}



function getTerminalsAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
        for (const input of output.connectedInputs)
            after.push(...getTerminalsAfterNode(input.op));

    return after.length > 0 ? after : [node];
}



function updateTerminalsAfterNodes(nodes)
{
    const terminals = [];

    for (const node of nodes)
    {
        const tt = getTerminalsAfterNode(node);

        for (const t of tt)
        {
            if (!terminals.includes(t))
                terminals.push(t);
        }
    }

    for (const t of terminals)
        t.update();
}


class   Input
extends EventTarget
{
    _dataType;     
    get dataType() { return this._dataType; }

    get data()
    {
        return (
            this.isConnected
            ? this.connectedOutput.data
            : null);
    }


    _op    = null; get op   () { return this._op;    }
    _param = null; get param() { return this._param; }

    
    color;
    wireColor;

    control;
    hitbox;
    wireBall;
  

    _connectedOutput = null;
    get connectedOutput() { return this._connectedOutput; }
    set connectedOutput(output)
    {
        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'disconnect', 
                { 'input': this }));
        }

        this._connectedOutput = output;

        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'connect', 
                { 
                    'output': output,
                    'input':  this 
                }));
        }
    }


    connection = null;
    
    connecting = false;
    mouseOver  = false;
    

    initialSeed = 0;
    currentSeed = 0;

    get isConnected() { return this.connectedOutput != null; }


    isNew      = false; // this indicates that the input is the empty "new" input of a variable node


    onconnect    = new Event('connect');
    ondisconnect = new Event('disconnect');



    constructor(dataType)
    {
        super();
        
        this._dataType = dataType;

        this.control  = createDiv('input');
        this.hitbox   = createDiv('inputHitbox');
        this.wireBall = createDiv('inputBall');
        
        this.control.input = this;
        

        this.control.appendChild(this.hitbox);
        this.control.appendChild(this.wireBall);

        this.color     = [0, 0, 0, 0.12];
        this.wireColor = dataType2rgb(this.dataType, true);

        
        //this.hitbox.addEventListener('pointerdown', e => e.preventDefault());


        this.hitbox.addEventListener('pointerenter', e => 
        {
            if (graphView.headerInput)
            {
                graphView.headerInput.updateControl();
                graphView.headerInput = null;
            }

            this.mouseOver = true;
            this.updateControl();

            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

            if (   graphView.tempConn
                && graphView.tempConn.output
                && graphView.tempConn.output.dataType == this.dataType
                && (  !this.isConnected
                    || this.connectedOutput != graphView.tempConn.output
                    || this == savedInput))
            {
                const rect = boundingRect(this.control);
                const loop = graphView.tempConn.output.op.follows(this.op);

                if (!loop)
                {
                    graphView.tempConn.wire.inputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - controlBar.offsetHeight);
                }

                graphView.overInput = !loop ? this : null;
                this.op.inputs.forEach(i => i.updateControl());
            }
            else
                graphView.overInput = this;
        });


        this.hitbox.addEventListener('pointerleave', e => 
        {
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overInput = null;

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.output)
            graphView.tempConn.wire.inputPos = point_NaN;
    }



    updateControl()
    {
        const mouseOver =
               this.mouseOver
            && !(   graphView.tempConn
                 && graphView.tempConn.input)
            && !(   graphView.tempConn
                 && graphView.tempConn.output
                 && (   graphView.tempConn.output.dataType != this.dataType
                     || graphView.tempConn.output.op.follows(this.op)));

        const colorStyle = 
            graphView.showWires
            ? colorStyleRgba(rgb_a(
                this.color, 
                mouseOver 
                ? Math.min(this.color[3] * 1.8, 1) 
                : this.color[3]))
            : 'transparent';


        const isConnected =
               this.isConnected
            ||     graphView.tempConn
               && (   graphView.tempConn.input == this
                   ||    graphView.overInput == this
                      && !graphView.tempConn.input)
               && !(   graphView.tempConn.output
                    && graphView.tempConn.output.dataType != this.dataType);

        this.control.style.transform = 
              'translateX(' + (isConnected ? -1 : 0) + 'px)'
            + 'translateY(-50%)';
        
        this.control.style.width         = (isConnected ? 8 : 6) + 'px';
        this.control.style.height        = (isConnected ? 8 : 6) + 'px';
        this.control.style.borderRadius  = (isConnected ? 4 : 4) + 'px';
        this.control.style.marginBottom  = (isConnected ? 4 : 6) + 'px';
        this.control.style.boxShadow     = '0 0 0 1px ' + colorStyle;
        this.control.style.pointerEvents = graphView.showWires ? 'auto' : 'none';

        this.hitbox.style.left = isConnected ? -2 : -3;
        this.hitbox.style.top  = isConnected ? -2 : -3;

        this.wireBall.style.backgroundColor = 
            this.isConnected
            ? (   graphView.savedConn
               && graphView.savedConn.input == this
               && graphView.overInput != this
               ? 'transparent'
               : colorStyleRgba(toRgba(this.connectedOutput.wireColor)))
            : (   graphView.tempConn
               && graphView.tempConn.output
               && graphView.tempConn.output.dataType == this.dataType
               && graphView.overInput == this
               ? colorStyleRgba(toRgba(graphView.tempConn.output.wireColor))
               : (   graphView.tempConn
                  && graphView.tempConn.input
                  && graphView.tempConn.input == this)
                  ? (graphView.overOutput
                     ? colorStyleRgba(toRgba(graphView.overOutput.wireColor))
                     : (graphView.headerOutput
                        ? colorStyleRgba(toRgba(graphView.headerOutput.wireColor))
                        : colorStyleRgba(toRgba(graphView.tempConn.input.wireColor))))
                  : colorStyle);

        this.wireBall.style.zIndex = MAX_INT32;
        this.wireBall.style.left   = '1px';
        this.wireBall.style.top    = 'calc(50% - 3px)';


        show(this.wireBall, isConnected); 
    }
}


class Output
{
    _dataType;     
    get dataType() { return this._dataType; }

    _op    = null; get op()    { return this._op;    }
    _param = null; get param() { return this._param; }
    
    
    color;
    wireColor;

    control;
    hitbox;
    wireBall;
    
    
    connectedInputs = [];
    
    mouseOver  = false;
    connecting = false;
    
    
    _data;

    get data() 
    {
        if (this.param) this.param.setOutputData();
        if (this.op   ) this.op.update();

        return this._data;
    }
    
    set data(value)
    {
        this._data = value;

        // for (const input of this.connectedInputs)
        //     input.op.pushUpdate();
    }



    get isConnected() { return this.connectedInputs.length > 0; }



    constructor(dataType)
    {
        this._dataType = dataType;
        
        this.control  = createDiv('output');
        this.hitbox   = createDiv('outputHitbox');
        this.wireBall = createDiv('outputBall');
        
        this.control.output = this;
        
        
        this.control.appendChild(this.hitbox);
        this.control.appendChild(this.wireBall);

        this.color     = [0, 0, 0, 0.12];
        this.wireColor = dataType2rgb(this.dataType, true);
        
        this.updateControl();

        
        //this.hitbox.addEventListener('pointerdown', e => e.preventDefault());


        this.hitbox.addEventListener('pointerenter', e => 
        { 
            if (graphView.headerOutput)
            {
                graphView.headerOutput.updateControl();
                graphView.headerOutput = null;
            }


            this.mouseOver = true;
            this.updateControl();


            if (   graphView.tempConn
                && graphView.tempConn.input
                && graphView.tempConn.input.dataType == this.dataType)
            {
                const rect = boundingRect(this.control);
                const loop = this.op.follows(graphView.tempConn.input.op);

                if (!loop)
                {
                    graphView.tempConn.wire.outputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - controlBar.offsetHeight);
                }

                graphView.overOutput = !loop ? this : null;
                this.op.outputs.forEach(o => o.updateControl());
            }
            else
                graphView.overOutput = this; 
        });



        this.hitbox.addEventListener('pointerleave', e => 
        { 
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overOutput = null; 

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.input)
            graphView.tempConn.wire.outputPos = point_NaN;
    }



    updateControl()
    {
        const mouseOver =
               this.mouseOver
            && !(   graphView.tempConn
                 && graphView.tempConn.output)
            && !(   graphView.tempConn
                 && graphView.tempConn.input
                 && (   graphView.tempConn.input.dataType != this.dataType
                     || this.op.follows(graphView.tempConn.input.op)));

        const colorStyle = 
            graphView.showWires
            ? colorStyleRgba(rgb_a(this.color, mouseOver ? Math.min(this.color[3] * 1.4, 1) : this.color[3] / 1.4))
            : 'transparent';

        this.control.style.pointerEvents = graphView.showWires ? 'auto' : 'none';
        this.control.style.backgroundColor = colorStyle;

        this.control.style.boxShadow = 
               this.connectedInputs.length > 0
            ||    graphView.tempConn
               && (   graphView.tempConn.output == this
                   || graphView.overOutput == this)
            ? '0 0 0 1px ' + colorStyle
            : 'none';

        this.wireBall.style.backgroundColor = colorStyleRgba(toRgba(this.wireColor));

        this.wireBall.style.zIndex = MAX_INT32;


        const isConnected =
               this.connectedInputs.length > 0
            ||     graphView.tempConn
               && (   graphView.tempConn.output == this
                   ||     graphView.overOutput == this
                      && !graphView.tempConn.output)
               && !(   graphView.tempConn.input
                    && graphView.tempConn.input.dataType != this.dataType);

        show(this.wireBall, isConnected);
    }
}


class Connection
{
    output;
    input;

    wire;


    constructor(output, input)
    {
        this.output = output;
        this.input  = input;


        this.wire                        = createSvg('svg');
        this.wire.connection             = this;
        this.wire.style.position         = 'absolute';
        this.wire.style.left             = 0;
        this.wire.style.top              = 0;
        this.wire.style.width            = '100%';
        this.wire.style.height           = '100vh';
  
        this.wire.outputPos              = point_NaN;
        this.wire. inputPos              = point_NaN;
  
        this.wire.curve                  = createSvg('path');
        this.wire.curve.style.fill       = 'none';
        this.wire.curve.style.position   = 'absolute';

        this.wire.outBall                = createSvg('circle');
        this.wire.outBall.style.position = 'absolute';

        this.wire.inBall                 = createSvg('circle');
        this.wire.inBall.style.position  = 'absolute';


        this.wire.appendChild(this.wire.curve);
        this.wire.appendChild(this.wire.outBall);
        this.wire.appendChild(this.wire.inBall);

        

        this.wire.update = (x1, y1, x2, y2) =>
        {
            const cw      = graphView.clientWidth;
            const ch      = graphView.clientHeight;
            const yOffset = controlBar.offsetHeight;
        
            // the yOffset is to start wire coords just below the control bar,
            // not at the top of the window

            this.wire.updateCurve  (x1, y1, x2, y2);
            this.wire.updateOutBall(x1, y1        );
            this.wire.updateInBall (        x2, y2);

            this.wire.updateStyle(this.wire.getColor());

            this.wire.setAttribute('width',  cw);
            this.wire.setAttribute('height', ch);
        
            this.wire.setAttribute('viewBox',
                        0
                + ' ' + yOffset/2 // why is only half of yOffset taken???
                + ' ' + cw
                + ' ' + ch);

            const isSolo = 
                   graphView._soloNode
                && (   this. input.op == graphView._soloNode
                    || this.output.op == graphView._soloNode);
            
            const showWire = 
                   graphView.showWires 
                || isSolo;

            const isReordering =   
                   isNaN(newReorderIndex)
                || isNaN(oldReorderIndex);


            show(this.wire,         showWire && (this != graphView.savedConn || isReordering));
            show(this.wire.curve,   showWire && (this != graphView.savedConn || isReordering));
            show(this.wire.outBall, showWire && (!graphView.tempConn || graphView.tempConn.output));
            show(this.wire. inBall, showWire && (!graphView.tempConn || graphView.tempConn. input));
        };



        this.wire.updateCurve = (x1, y1, x2, y2) =>
        {
            if (!pointIsNaN(this.wire.outputPos))
            {
                x1 = this.wire.outputPos.x;
                y1 = this.wire.outputPos.y;
            }

            if (!pointIsNaN(this.wire.inputPos))
            {
                x2 = this.wire.inputPos.x;
                y2 = this.wire.inputPos.y;
            }

            
            const _x0 = x1;
            const _y0 = y1;

            const _x3 = x2;
            const _y3 = y2;


            const tx  = 600 * graphView.zoom;
            const ty  = 300 * graphView.zoom;
            const ecc = 100 * graphView.zoom;

            const yf  = (0.3 + Math.min(Math.abs(y2 - y1) / ty, 0.8));

            const df  = Math.pow((1 - Math.min(Math.abs(_x3 - _x0) / tx, 0.65)), 0.5)
                      * yf;

            const dx = 
                  (_x3 - _x0) * df 
                * (_x3 < _x0 ? -1 : 1);


            let _x1 = Math.max(_x0 + ecc * Math.pow(0.1 + yf*0.9, 1.5), _x0 + dx);
            let _y1 = _y0;

            let _x2 = Math.min(_x3 - ecc * Math.pow(0.1 + yf*0.9, 1.5), _x3 - dx);
            let _y2 = _y3;


            if (   graphView.tempConn == this
                && graphView.tempConn.output == graphView.overOutput)
            {
                _x1 += (_x0 - _x1) * 5/8;
                _y1 += (_y0 - _y1) * 5/8;
            }

            if (   graphView.tempConn == this
                && graphView.tempConn.input == graphView.overInput)
            {
                _x2 += (_x3 - _x2) * 5/8;
                _y2 += (_y3 - _y2) * 5/8;
            }

            
            this.wire.curve.setAttribute('d',
                   'M ' + _x0 + ',' + _y0
                + ' C ' + _x1 + ',' + _y1
                + ' '   + _x2 + ',' + _y2
                + ' '   + _x3 + ',' + _y3);
        };



        this.wire.getColor = () =>
        {
            if (this.output)
                return this.output.wireColor;

            else if (this.input)
            {
                if (   graphView.overOutput
                    && graphView.overOutput.dataType == this.input.dataType) 
                    return graphView.overOutput.wireColor;
                else
                    return this.input.wireColor;
            }
                
            else 
                return [255, 0, 255];
        };



        this.wire.updateOutBall = (x, y) =>
        {
            this.wire.outBall.setAttribute('cx', x);
            this.wire.outBall.setAttribute('cy', y);
        };



        this.wire.updateInBall = (x, y) =>
        {
            this.wire.inBall.setAttribute('cx', x);
            this.wire.inBall.setAttribute('cy', y);
        };



        this.wire.updateStyle = (color) =>
        {
            const l = rgb2hclokl(color)[2];
            
            const bright       = Math.min(Math.max(0, (l-0.6) / 0.4), 1);
            const innerOpacity = Math.round(bright * 44 * Math.min(graphView.zoom, 1)).toString(16).padStart(2, '0');
            const outerOpacity = Math.round(bright * 60).toString(16).padStart(2, '0');

            this.wire.curve.style.filter = 
                l > 0.6
                ?   'drop-shadow(0px 0px 1px #000000' + innerOpacity + ') '
                  + 'drop-shadow(0px 0px 6px #000000' + outerOpacity + ')'
                : 'none';

            this.wire.curve.style.stroke      = colorStyleRgb(color);
            this.wire. inBall.style.fill      = colorStyleRgb(color);
            this.wire.outBall.style.fill      = colorStyleRgb(color);

            this.wire.curve.style.strokeWidth = (1.2 + 0.3 * bright * (1 + 1/(graphView.zoom/4))) * graphView.zoom;
            this.wire. inBall.style.r         = 3 * graphView.zoom;
            this.wire.outBall.style.r         = 3 * graphView.zoom;

            this.wire.style.zIndex = 0;
        };
    }



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';
        
        let json = 
              pos + '{'
            +  '\n' + pos + tab + '"outputOp": "'    + this.output.op.id + '"'
            + ',\n' + pos + tab + '"outputIndex": "' + this.output.op.outputs.indexOf(this.output) + '"'
            + (this.output.param ? ',\n' + pos + tab + '"outputParam": "' + this.output.param.name + '"' : '')
            + ',\n' + pos + tab + '"inputOp": "'     + this.input.op.id + '"'
            + ',\n' + pos + tab + '"inputIndex": "'  + this.input.op.inputs.indexOf(this.input) + '"'
            + (this.input.param ? ',\n' + pos + tab  + '"inputParam": "' + this.input.param.name + '"' : '')
            +  '\n' + pos + '}';

        return json;
    }



    static parseJson(_conn)
    {
        const outputOp    = nodeFromId(_conn.outputOp);
        const outputIndex = parseInt(_conn.outputIndex);

        const inputOp     = nodeFromId(_conn.inputOp);
        const inputIndex  = parseInt(_conn.inputIndex);


        // log('---------------------------------------');

        // log('outputOp',                outputOp);
        // log('outputIndex',             outputIndex);
        // log('outputOp.outputs.length', outputOp.outputs.length);
        
        // log('inputOp',               inputOp);
        // log('inputIndex',            inputIndex);
        // log('inputOp.inputs.length', inputOp.inputs.length);



        if (   !outputOp || outputIndex >= outputOp.outputs.length
            || !inputOp  ||  inputIndex >= inputOp .inputs .length)
        {
            uiError(
                  'Cannot connect ' 
                + _conn.outputOp + '.outputs[' + outputIndex + '] to ' 
                + _conn.inputOp  + '.inputs[' + _conn.inputIndex + ']');
        }
        else
            uiVariableConnect(outputOp, outputIndex, inputOp, inputIndex);
    }
}



function getConnectionForArrayWithIds(conn)
{
    return {
        outputOpId:  conn.output.op.id,
        outputIndex: conn.output.op.outputs.indexOf(conn.output),
        inputOpId:   conn.input .op.id,
        inputIndex:  conn.input .op. inputs.indexOf(conn. input)};
}



function getConnectionForArrayWithNames(conn)
{
    return {
        outputOpName: conn.output.op.id,
        outputIndex:  conn.output.op.outputs.indexOf(conn.output),
        inputOpName:  conn.input .op.id,
        inputIndex:   conn.input .op. inputs.indexOf(conn. input)};
}


const connectionSize = 9;
const connectionGap  = 2;



class Operator
{
    #opType;
    get opType() { return this.#opType; }
    
    _dataType;
    get dataType() { return this._dataType; }

    _id;
    get id() { return this._id; }
    set id(id) { this._id = id; }

    _name;
    get name() { return this._name; }
    set name(name) { this.setName(name); }

    shortTypeName;
    defaultWidth;


    graph = null;
    
    
    inputs  = [];
    outputs = [];
    params  = [];
    
    
    _variableInputs  = false;

    alwaysLoadParams = false;
    loading          = false;

    labelOffsetFactor;


    _creatingButton  = null; // this is used to place the node under its creating button


    


    // node UI

    div;
    inner;
    header;
    paramBack;
    labelWrapper;
    label;
    inputControls;
    outputControls;


   

    valid; // this is the flag for regeneration



    _selected;
    get selected() { return this._selected; }
    set selected(sel) 
    {
        if (this._selected)
            removeFromArray(graphView.selectedNodes, this);

        this.setSelected(sel);     

        if (this._selected)
            graphView.selectedNodes.push(this);
    }        



    _active = false;
    get active() { return this._active; }
       
    
    get activeColor()
    {
        switch (this._dataType)
        {
            case 'number': return rgbNumber; //activeNumberColor;
            case 'color':  return rgbActiveColor;
            case 'object': return rgbActiveObject;
        }

        return 'magenta';
    }



    get passiveColor()
    {
        switch (this._dataType)
        {
            case 'number': return rgbNumber;
            case 'color':  return rgbColor;
            case 'object': return rgbObject;
        }

        return 'magenta';
    }



    constructor(opType, shortType, dataType, defWidth = 80)
    {
        this.#opType           = opType;   // this is the operator type
        this._dataType         = dataType; // this is the op's main data type
           
        this.shortTypeName     = shortType;
        this._id               = shortType;

        this.valid             = false;

        this.defaultWidth      = defWidth;
        
        this.labelOffsetFactor = 0;

        createOperatorNode(this);

        this.setName(shortType);
    }    



    addInput(input)
    {
        input._op = this;
        this.inputs.push(input);
        this.inputControls.appendChild(input.control);
    }



    getAutoInput(dataType)
    {
        const inputs = this.inputs.filter(i => i.dataType == dataType);

        
        if (graphView.overInput)
            return graphView.overInput;

        if (   graphView.savedConn
            && graphView.savedConn.input
            && graphView.savedConn.input.op == this)
            return graphView.savedConn.input;
        
        else if (!graphView.tempConn.output.op.follows(this))
        {
            if (this._variableInputs)
                return lastOf(inputs);

            else
            {
                for (const input of inputs)
                {
                    if (!input.isConnected)
                        return input;
                }

                // at this point no empty inputs were found, so connect to the first one
                return inputs[0];
            }
        }

        return null;
    }



    addOutput(output)
    {
        output._op = this;
        this.outputs.push(output);
        this.outputControls.appendChild(output.control);
    }



    getAutoOutput(dataType)
    {
        const outputs = this.outputs.filter(o => o.dataType == dataType);

        return     outputs.length == 1
               && !this.follows(graphView.tempConn.input.op)
               ? outputs[0]
               : null;
    }



    addParam(param)
    {
        this.params.push(param);
        
        param._op = this;

        if (param.input)
        {
            param.input._op = this;
            this.inputs.push(param.input);
        }

        if (param.output)
        {
            param.output._op = this;
            this.outputs.push(param.output);
        }

        param.control.style.display = 'inline-block';
        param.control.style.width   = '100%';
        
''
        this.inner.appendChild(param.div);
    }
 
    

    reset() // for the entire generation run
    {
        for (const input of this.inputs)
        {
            input.currentSeed = input.initialSeed;
            
            if (input.isConnected)
                input.connectedOutput.op.reset();
        }
    }



    // refresh() // for repeats requests from nodes that duplicate their input, like row and column
    // {
    //     for (const input of this.inputs)
    //     {
    //         if (input.isConnected)
    //             input.connectedOutput.op.refresh();
    //     }
    // }


    
    invalidate()
    {
        if (!this.valid) // stops an op with inputs from same output 
            return;      // from being invalidated more than once
    
        this.valid = false;


        for (const output of this.outputs)
            for (const connInput of output.connectedInputs)
                connInput.op.invalidate();
    }



    pushUpdate()
    {
        //log(this.id + '.Operator.pushUpdate()');

        this.invalidate();

        setTimeout(() => getTerminalsAfterNode(this).forEach(n => n.update()));
    }



    update()
    {
        if (this.valid) return;
        
        //log(this.id + '.Operator.update()');
    
        this.updateParams(false);
        this.updateData();

        this.valid = true;

        if (this.active)
            uiPostGeneratorRequest(this.makeGenRequest());

        if (graphView.canUpdateNodes)
            this.updateNode();

        this.loading = false;
    }



    updateData()
    {
        //log(this.id + '.Operator.updateData()');

        this.setParamOutputData();
    }



    makeGenRequest() 
    { 
        // create the generation string here

        /*

            A generation string is only to calculate graph results.

            [ ] = optional
            ... = list

            The general format is

                opType [params...] [inputs...]


            #               # of following values
            N               number value
            C               color value


            OpNumber        number [N]

            OpArithmetic    add [onlySymbol] # N...

            OpColor         color [color C] [space N] [c1 N] [c2 N] [c3 N]

            OpWebContrast   webcontrast [wcag N] [1:C] [2:C]

        */

        return '';
    }



    updateNode() 
    {
        //log(this.id + '.Operator.updateNode()');

        this.updateBorder();
        this.updateHeader();
        this.updateParamControls();

        graphView.updateNodeTransform(this);
    }



    updateBorder()
    {
        // this.inner.style.boxShadow = 
        //       '0 0 0 1px ' 
        //     + (this.div.over ? colorStyleRgb(rgbActiveObject) : '#0001');
    }



    updateHeader()
    {
        //log(this.id + '.Operator.updateHeader()');
        
        const height = this.updateHeaderInputsAndOutputs();

        this.header.style.height = height;

        this.paramBack.style.height = this.inner.offsetHeight - height;
        this.paramBack.style.top    = height;


        updateNodeLabelOffset(this);
    }



    updateHeaderInputsAndOutputs()
    {
        const headerInputs  = this.inputs .filter(i => !i.param);
        const headerOutputs = this.outputs.filter(o => !o.param);

        const padding  = this.header.connectionPadding;
            
        const [ inputY,  inputHeight] = getHeaderConnY(headerInputs,  padding, 5);
        const [outputY, outputHeight] = getHeaderConnY(headerOutputs, padding, 2);

             if (inputHeight  > outputHeight) for (let i = 0; i < headerOutputs.length; i++) outputY[i] += (inputHeight  - outputHeight)/2;
        else if (outputHeight > inputHeight ) for (let i = 0; i < headerInputs .length; i++)  inputY[i] += (outputHeight - inputHeight )/2;


        for (let i = 0; i < headerInputs.length; i++) 
        {
            headerInputs[i].control.style.top = inputY[i];
            headerInputs[i].updateControl();
        }

        for (let i = 0; i < headerOutputs.length; i++) 
        {
            headerOutputs[i].control.style.top = outputY[i];
            headerOutputs[i].updateControl();
        }


        return Math.max(inputHeight, outputHeight) 
             + this.header.connectionPadding * 2;
    }



    updateParams(dispatchEvents)
    {
        for (const param of this.params)
            param.update(dispatchEvents);
    }



    setParamOutputData()
    {
        for (const param of this.params)
            param.setOutputData();
    }



    updateParamControls()
    {
        this.params.forEach(p => p.updateControls());
    }



    setName(newName)
    {
        this._name = newName;
        // this.label.innerHTML = this._name;
        // //this.label.innerHTML = this.id;
        
        return true;
    }



    isBefore(node)
    {
        if (!this.outputs.find(o => o.isConnected))
            return false;

        for (const input of output.connectedInputs)
        {
            if (input.op == node)        return true;
            if (input.op.isBefore(node)) return true;
        }

        return false;
    }



    isAfter(node)
    {
        if (this.inputs.length == 0)
            return false;

        for (const input of inputs)
        {
            if (input.connectedOutput.op == node)       return true;
            if (input.connectedOutput.op.isAfter(node)) return true;
        }

        return false;
    }

    

    updateConnectedInputValueText() {}



    setSelected(sel)
    {
        this._selected = sel;

        this.div.style.boxShadow = 
            this._selected
            ? '0 0 0 2px ' + colorStyleRgb(rgbActiveObject)
            : 'none';
    }
    


    follows(node)
    {
        if (this == node)
            return true;
            
        for (const input of this.inputs)
        {
            if (   input.isConnected
                && input.connectedOutput.op.follows(node))
                return true;
        }

        return false;
    }



    paramIsConsideredDefault(param)
    {
        return param.isDefault()
            && (   !param.input 
                || !param.input.isConnected);
    }



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';
        
        let json = 
              pos + '{\n'
            + this.toJsonBase(nTab);

        if (this.params.filter(p => !this.paramIsConsideredDefault(p)).length > 0)
        {
            // json +=
            //     ',\n'
            //     + pos + tab + '"params":\n'
            //     + pos + tab + '[\n';

            json += this.paramsToJson(nTab);

            // json += 
            //     pos + tab + ']';
        }

        json += '\n' + pos + '}';

        return json;
    }



    toJsonBase(nTab)
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        let json =
              pos + tab + '"type": "'        + this.opType            + '",\n'
            + pos + tab + '"id": "'          + this.id                + '",\n'
            + pos + tab + '"name": "'        + this.name              + '",\n'
            + pos + tab + '"x": "'           + this.div.style.left    + '",\n'
            + pos + tab + '"y": "'           + this.div.style.top     + '",\n'
            + pos + tab + '"labelOffset": "' + this.labelOffsetFactor + '"';

        return json;
    }



    paramsToJson(nTab = 0)
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
            
        let first = true;
        for (const param of this.params)
        {
            if (   !param.isDefault()
                && (   !param.input
                    || !param.input.isConnected))
            {
                if (!first) json += ',\n'; first = false;
                json += pos + tab + tab + param.toJson(nTab);
            }
        }

        if (!first)
            json += '\n';

        json += pos + tab + ']';

        return json;
    }



    loadParams(_node)
    {
        if (_node.params)
        {
            for (const _param of _node.params)
            {
                const index = this.params.findIndex(p => p.id == _param[0]);
                
                if (index >= 0) 
                {
                    this.params[index].setDecimalsFrom(_param[1]);
                    this.params[index].setValue(parseFloat(_param[1]), true, true, false);
                }
            }
        }
    }
}



function getHeaderConnY(conns, padding, offset)
{
    const y      = [];
    let   height = 0;
    
    for (let i = 0; i < conns.length; i++)
    {
        if (i > 0) height += connectionGap;
        y.push(offset + padding + height);
        height += connectionSize;
    }

    return [y, height];
}


class OperatorBase
extends Operator
{
    updateHeader()
    {
        //log(this.id + '.OperatorBase.updateHeader()');

        super.updateHeader();

        const colBack   = dataType2rgb(this._dataType, this.active);
        const darkText  = rgb2hclokl(colBack)[2] > 0.71;
        
        const colText   = darkText ? [0, 0, 0]      : [1, 1, 1];
        const colInput  = darkText ? [0, 0, 0, 0.1] : [1, 1, 1, 0.3];
        const colOutput = darkText ? [0, 0, 0, 0.1] : [1, 1, 1, 0.35];


        this.header.style.backgroundColor = colorStyleRgb_a(colBack, 0.95);

        this.label .style.color           = colorStyleRgb(colText);
        this.label .style.fontWeight      = this.active ? 'bold' : 'normal';


        for (const input  of this.inputs .filter(i => !i.param)) input .color = colInput;
        for (const output of this.outputs.filter(i => !i.param)) output.color = colOutput;
    }
}


var  newReorderIndex = Number.NaN;
var prevReorderIndex = Number.NaN;
var  oldReorderIndex = Number.NaN;



function createOperatorNode(node)
{
    node.div                    = createDiv('node');
    node.div.op                 = node;
       
    node.div.style.width        = node.defaultWidth + 'px';
           
    node.div.selectedSet        = false;
    node.div.over               = false;
    node.div.dragging           = false;
    node.div.shiftOnPointerDown = false;
    node.div.moved              = false;
       

    node.inner = createDiv('nodeInner');
    node.div.appendChild(node.inner);


    node.div.addEventListener('pointerenter', e =>
    {
        node.div.over      = true;
        graphView.overNode = node;
        
        if (    e.altKey
            && !getCtrlKey(e)
            && !e.shiftKey
            &&  graphView._soloNode != node) 
            graphView.soloNode(node);
        
        node.updateBorder();
    });

    
    node.div.addEventListener('pointerleave', e =>
    {
        node.div.over      = false;
        graphView.overNode = null;
        
        if (  !e.altKey
            || getCtrlKey(e)
            || e.shiftKey)
            graphView.unsoloNode();

        node.updateBorder();
    });

    
    node.paramBack = createDiv('nodeParamBack');
    node.inner.appendChild(node.paramBack);
    

    // node.div.addEventListener('pointermove', e =>
    // {
    //     const rect = boundingRect(node.div);
    
    //     let y = 
    //         + (e.clientY - rect.y) / graphView.zoom 
    //         - node.header.offsetHeight;

    //     const paramHeight = 20;

    //     y = Math.floor(y / paramHeight) * paramHeight;

    //     log(y);
        
    //     node.dragParam.style.top = node.header.offsetHeight + y + paramHeight/2 - 5.5;
    // });


    createNodeHeader(node);
}     



function createNodeHeader(node)
{
    node.header = createDiv('nodeHeader');
    
    node.header.connectionPadding = 8;


    createNodeLabel(node);

    
    node. inputControls = createDiv('inputControls');
    node.outputControls = createDiv('outputControls');

    node.header.appendChild(node. inputControls);
    node.header.appendChild(node.outputControls);

    node.inner.appendChild(node.header);



    node.header.addEventListener('pointerleave', e => 
    { 
        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.op != node)
            {
                const input = graphView.headerInput;
                
                graphView.overInput   = null;
                graphView.headerInput = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.op != node)
            {
                const output = graphView.headerOutput;
                
                graphView.overOutput   = null;
                graphView.headerOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    node.header.addEventListener('pointerdown', e =>
    {
        if (graphView.spaceDown)    
            return;


        graphView.lastSelectedNodes = [...graphView.selectedNodes];
        
        graphView.putNodeOnTop(node);


        for (const param of node.params)
        {
            if (param.control.textbox == document.activeElement)
                param.control.textbox.finish(true);
        }


        if (    e.button == 0
            && !graphView.overOutput
            && !graphView.overInput)
        {
            e.stopPropagation();

            node.div.selectedSet = false;
            node.div.moved       = false;

            node.div.shiftOnPointerDown = 
                    e.shiftKey
                && !getCtrlKey(e)
                && !e.altKey;


            if (   getCtrlKey(e)
                && e.shiftKey
                && e.altKey)
                graphView.selectedNodes = [node, ...getAllNodesFromNode(node)];

            else if (e.shiftKey
                  && e.altKey)
            {
                if (isMac) graphView.selectedNodes = [node, ...getNodesBeforeNode(node)];
                else       graphView.selectedNodes = [node, ...getNodesAcrossNode(node)];
            }
            else if (getCtrlKey(e)
                  && e.shiftKey)
            {
                if (isMac) graphView.selectedNodes = [node, ...getNodesAcrossNode(node)];
                else       graphView.selectedNodes = [node, ...getNodesBeforeNode(node)];
            }
            else if (getCtrlKey(e)
                  && e.altKey)
                graphView.selectedNodes = [node, ...getNodesAfterNode(node)];

            else if (!node.selected)
            {
                if (e.shiftKey) node     .selected      = true;
                else            graphView.selectedNodes = [node];

                node.selectedSet = true;
            }

            
            node.div.sx = e.clientX;
            node.div.sy = e.clientY;


            for (const n of graphView.selectedNodes)
            {
                n.div.slx = n.div.offsetLeft;
                n.div.sly = n.div.offsetTop;
            }


            node.div.dragging = true;
            node.header.setPointerCapture(e.pointerId);
        }


        updateGraphNodes();
    });



    node.header.addEventListener('pointermove', e =>
    {
        const toTheRightOfInputs = e.clientX - boundingRect(node.header).x > 12 * graphView.zoom;

        const  tempConn = graphView. tempConn;
        const savedConn = graphView.savedConn;


        if (node.div.dragging)
        {
            const x       = graphView.clientLeft;
            const w       = graphView.clientWidth;
            const h       = graphView.clientHeight;
            const bounds  = graphView.getAllNodeBounds();
            const yOffset = controlBar.offsetHeight;
        
            setNodePositions(
                graphView.selectedNodes,
                (e.clientX - node.div.sx) / graphView.zoom,
                (e.clientY - node.div.sy) / graphView.zoom);
            
            node.div.moved = true;

            graphView.updateScroll(x, w, h, bounds, yOffset);
        }
        else if (   tempConn
                 && toTheRightOfInputs)
        {
            if (    tempConn.output
                && !tempConn.output.op.follows(node))
            {
                if (   node._variableInputs
                    && savedConn)
                {
                    const rect    = boundingRect(node.div);
                    const padding = node.header.connectionPadding;

                    const index = Math.min(Math.round(
                          ((e.clientY - rect.y) / graphView.zoom - padding - (connectionSize + connectionGap)/2) 
                        / (connectionSize + connectionGap)),
                        node.inputs.length-2);
                    
                    if (index != prevReorderIndex)
                    {
                        newReorderIndex = index;

                        moveIn(
                            node.inputs, 
                            node.inputs.indexOf(savedConn.input),
                            newReorderIndex);

                        node.updateNode();
                         
                        prevReorderIndex = newReorderIndex;
                    }

                    graphView.overInput   = savedConn.input;
                    graphView.headerInput = savedConn.input;

                    graphView.overInput.updateControl();

                    
                    const inputRect = boundingRect(savedConn.input.control);

                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - controlBar.offsetHeight);
                }
                else
                {
                    const input = node.getAutoInput(tempConn.output.dataType);

                    if ( !input
                        ||    input.isConnected
                           && input.connectedOutput.op == tempConn.output.op) 
                        return;

                    graphView.overInput   = input;
                    graphView.headerInput = input;
                        
                    input.mouseOver = true;
                    input.updateControl();


                    const inputRect = boundingRect(input.control);

                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - controlBar.offsetHeight);
                }
            }
            else if (tempConn.input
                  && !node.follows(tempConn.input.op))
            {
                const output = node.getAutoOutput(tempConn.input.dataType);
                if (!output) return;

                graphView.overOutput   = output;
                graphView.headerOutput = output;
                    
                output.mouseOver = true;
                output.updateControl();


                const rect = boundingRect(output.control);

                tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - controlBar.offsetHeight);


                tempConn.input.updateControl();
            }
        }
    });



    node.header.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && node.div.dragging)
        {
            if (node.div.moved)
            {
                actionManager.do(new SelectMoveNodesAction(
                    graphView.lastSelectedNodes.map(n => n.id), 
                    graphView.selectedNodes.map(n => n.id), 
                    point(node.div.slx,        node.div.sly      ),
                    point(node.div.offsetLeft, node.div.offsetTop),
                    node.div.shiftOnPointerDown ));
            }
            else if (!node.selected)
            {
                actionManager.do(new SelectNodesAction(
                    graphView.selectedNodes    .map(n => n.id), 
                    graphView.lastSelectedNodes.map(n => n.id)));
            }


            node.div.dragging = false;
            node.header.releasePointerCapture(e.pointerId);
        }
        else if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.op.follows(node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overInput.endConnection();
            }
            else if ( graphView.tempConn.input
                  && !node.follows(graphView.tempConn.input.op)
                  &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overOutput.endConnection();
            }
        }


        node.div.shiftOnPointerDown = false;
    });
    
    

    node.header.addEventListener('dblclick', e =>
    {
        e.preventDefault();

        var bounds = boundingRect(node.label);

        if (   e.clientX >= bounds.left && e.clientX < bounds.right
            && e.clientY >= bounds.top  && e.clientY < bounds.bottom)
            node.showLabelTextbox();
        else
            actionManager.do(new MakeNodeActiveAction(node.id));
    });
}



function setNodePositions(nodes, dx, dy, updateTransform = true)
{
    //log('setNodePositions()');

    for (const node of nodes)
    {
        node.div.style.left = node.div.slx + dx;
        node.div.style.top  = node.div.sly + dy;
    }

    if (updateTransform)
        graphView.updateNodeTransforms(nodes);
}



function setNodePosition(node, x, y, updateTransform = true)
{
    //log('setNodePosition()');

    node.div.style.left = x;
    node.div.style.top  = y;

    if (updateTransform)
        graphView.updateNodeTransform(node);
}


function createNodeLabel(node)
{
    node.labelWrapper = createDiv('nodeLabelWrapper');

    node.label        = createDiv('nodeLabel');
    node.label.op     = node;
    
    node.labelWrapper.appendChild(node.label);
    node.header.appendChild(node.labelWrapper);


    node.labelWrapper.addEventListener('pointerdown', e =>
    {
        e.preventDefault();
    });

    node.labelWrapper.addEventListener('pointermove', e =>
    {
        const wrect      = boundingRect(node.labelWrapper);
        const margin     = 14;
        const viewMargin = margin * graphView.zoom;
        
        const x          = e.clientX - wrect.x;

        if (x >= wrect.width - viewMargin)
            updateNodeLabelOffset(node, 1);
        else if (x >= viewMargin
              && x < wrect.width - viewMargin)
            updateNodeLabelOffset(node, (x - viewMargin) / (wrect.width - viewMargin*2));
        else
            updateNodeLabelOffset(node);
    });


    initLabelTextbox(node);
}



function updateNodeLabelOffset(node, f = node.labelOffsetFactor)
{
    node.labelOffsetFactor = Math.min(Math.max(0, f), 1);


    const margin     = 15;
    const viewMargin = margin * graphView.zoom;

    const wrect      = boundingRect(node.labelWrapper);
    const rect       = boundingRect(node.label);

    const rw         = wrect.width - viewMargin*2;
    const sf         = rw / nozero(rect.width);
    const df         = viewMargin / rect.width / 2;
        
    const s1         = node.labelOffsetFactor * (rect.width - rw) / rect.width;
    const s0         = s1 - df;
    const s2         = s1 + sf;
    const s3         = s2 + df;


    //node.label.innerHTML = node._name;
    node.label.innerHTML = node.id;


    if (rect.width > rw)
    {
        node.label.style.left = margin - node.labelOffsetFactor * (rect.width - rw - 1) / graphView.zoom;
        node.label.style.transform = 'translateY(calc(-50% - 0.5px))';
    }
    else
    {
        node.label.style.left = '50%';
        node.label.style.transform = 
              'translateX(-50%) '
            + 'translateY(calc(-50% - 0.5px))';
    }


    const color = 
        node.label.style.color.trim() != ''
        ? node.label.style.color
        : 'black';

    node.label.style.background = 
          'linear-gradient(90deg, '
        + '#0000 ' + (s0 * 100) + '%, '
        + color + ' ' + (s1 * 100) + '%, '
        + color + ' ' + (s2 * 100) + '%, '
        + '#0000 ' + (s3 * 100) + '%)';

    node.label.style.WebkitBackgroundClip = 'text';
    node.label.style.WebkitTextFillColor  = 'transparent';
}


function initLabelTextbox(node)
{
    node.textbox = createTextbox('nodeLabelTextbox');
    node.textbox.spellcheck = false;
    


    node.textbox.addEventListener('keydown', function(e)
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
        {
            node.textbox.finish(true);
        }

        else if (e.code == 'Escape')
            node.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.node, .figmaSelect, .menuSelect #hexValue, button');
            var index = node.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'node')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else if (e.key == 'Alt')
            e.preventDefault();
    });


    
    // node.textbox.addEventListener('input', function()
    // {
    //     node.setValue(Number(node.textbox.value));
    // });



    node.textbox.addEventListener('pointerdown', e => e.stopPropagation());
    node.textbox.addEventListener('pointermove', e => node.textbox.style.cursor = 'default');



    node.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(node.min, val), node.max);

        node.textbox.value = isNaN(val) ? '' : val;
    });

    
    
    node.textbox.addEventListener('focusout', function()
    {
        if (node.textbox.value != '')
            node.textbox.finish(true);

        node.label.style.display = 'block';

        node.header.removeChild(node.textbox);
        node.clicked = false;
    });
    


    node.textbox.finish = function(success)
    {
        const enteredValue = node.textbox.value;
        const   savedValue = node.textbox.savedValue;

        if (success) 
        {
            if (   enteredValue != ''
                && enteredValue != savedValue)
            {
                const newName = node.textbox.value;
                setTimeout(() => node.setName(newName));
                actionManager.do(new RenameNodeAction(node.id, newName));
            }
        }
        else
            node.textbox.value = node.textbox.savedValue;


        node.textbox.dispatchEvent(new CustomEvent('finishedit', { 'detail': {
            'success':  success,
            'value':    enteredValue,
            'oldValue': savedValue }}));
    

        node.textbox.blur();
        
        node.label.style.display = 'block';

        if (node.inFocus)
            node.focus();

        setTimeout(() => updateNodeLabelOffset(node));
    };    
 
    
    
    node.showLabelTextbox = function()
    {
        node.inFocus = 
                node == document.activeElement
            && !node.clicked;
    
        node.textbox.style.width           = node.header.offsetWidth  - 2;
        node.textbox.style.height          = node.header.offsetHeight - 4;
        node.textbox.style.position        = 'absolute';
        node.textbox.style.left            = '50%';
        node.textbox.style.top             = '50%';
        node.textbox.style.transform       = 'translateX(-50%) translateY(-50%)';
        node.textbox.style.textAlign       = 'center';

        node.textbox.style.backgroundColor = node.header.style.backgroundColor;
        node.textbox.style.color           = node.label.style.color;

        node.textbox.value                 = node.name;
        node.textbox.savedValue            = node.textbox.value;
        
        node.header.appendChild(node.textbox);

        node.label.style.display           = 'none';
        
        node.textbox.focus();
        node.textbox.select();
    }
}


class   OpNumber
extends OperatorBase
{
    #paramValue;



    constructor()
    {
        super('number', 'num', 'number', 70);

        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramValue = new NumberParam('value', '', false, false, false));
        
        this.alwaysLoadParams = true;
    }



    updateData()
    {
        if (this.inputs[0].isConnected)
        {
            this.#paramValue.control.setDecimals(this.inputs[0].data.decimals);
            this.#paramValue.setValue(this.inputs[0].data.value, true, true, false);
        }

        this.#paramValue.control.readOnly = this.inputs[0].isConnected;
        
        this.outputs[0]._data = dataFromNumber(
            this.#paramValue.value, 
            this.#paramValue.control.dec);
            
                  
        super.updateData()
    }



    updateNode()
    {
        enableElementText(this.#paramValue.control, !this.inputs[0].isConnected);
        
        super.updateNode();
    }



    updateParams(dispatchEvents)
    {
        super.updateParams(dispatchEvents);

        this.outputs[0]._value = this.#paramValue.value;
    }



    loadParams(_node)
    {
        if (_node.decimals)
            this.#paramValue.setDecimals(parseInt(_node.decimals));

            
        super.loadParams(_node);
    }



    paramIsConsideredDefault(param)
    {
        return param.isDefault()
            && !this.inputs[0].isConnected;
    }



    toJsonBase(nTab)
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';


        let json = super.toJsonBase(nTab);

        if (this.#paramValue.control.dec != 0)
        {
            json += ',\n'
                + pos + tab + '"decimals": "' + this.#paramValue.control.dec + '"';
        }


        return json;
    }



    toString()
    {
        // let str = opType;

        // if (this.inputs[0].isConnected)
        //     str +=

        // return str;
    }
}


class   OpMinMax
extends OperatorBase
{
    #paramMin;
    #paramMax;



    constructor()
    {
        super('minmax', 'limits', 'number', 70);

        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramMin = new NumberParam('min', 'min', true, true, true, 0));
        this.addParam(this.#paramMax = new NumberParam('max', 'max', true, true, true));
        
        // this.#paramMin.addEventListener('change', () =>
        // {
        //     if (this.#paramMin.value > this.#paramMax.value)
        //         this.#paramMin.setValue(this.#paramMax.value, false, true, false);
        // });

        // this.#paramMax.addEventListener('change', () => 
        // {
        //     if (this.#paramMax.value < this.#paramMin.value)
        //         this.#paramMax.setValue(this.#paramMin.value, false, true, false);
        // });
    }



    updateData()
    {
        if (this.inputs[0].isConnected)
        {
            this.#paramMin.control.setDecimals(this.inputs[0].data.decimals);
            this.#paramMax.control.setDecimals(this.inputs[0].data.decimals);
            
            if (this.#paramMin.value > this.#paramMax.value)
                this.#paramMin.setValue(this.#paramMax.value, false, true, false);

            if (this.#paramMax.value < this.#paramMin.value)
                this.#paramMax.setValue(this.#paramMin.value, false, true, false);

            this.outputs[0]._data = dataFromNumber(
                Math.min(Math.max(
                    this.#paramMin.value, 
                    this.inputs[0].data.value), 
                    this.#paramMax.value),
                this.inputs[0].data.decimals);
        }
        else
            this.outputs[0]._data = dataFromNumber(Number.Nan, 0);
            
                  
        super.updateData()
    }



    toString()
    {
        // let str = opType;

        // if (this.inputs[0].isConnected)
        //     str +=

        // return str;
    }
}


class   OpArithmetic
extends OperatorBase
{
    #paramValue;

    _symbol;
    _showOnlySymbol;


    constructor(opType, shortType, symbol)
    {
        super(opType, shortType, 'number', 50);

        this._variableInputs  = true;
        this.alwaysLoadParams = true;

        this._showOnlySymbol  = true;


        this.addNewInput();
        this.addOutput(new Output(this.dataType));
        
        this.addParam(this.#paramValue = new NumberParam('value', '', false, false, false));

        enableSliderText(this.#paramValue.control, false);


        this._symbol           = createDiv('arithmeticSymbol');
        this._symbol.innerHTML = symbol;
        this._symbol.clicked0  = false;
        
        this._symbol.addEventListener('pointerenter', () => this._symbol.style.opacity = this._showOnlySymbol ? 1 : 0.65);
        this._symbol.addEventListener('pointerleave', () => this._symbol.style.opacity = 1);

        this._symbol.addEventListener('pointerdown', e => 
        { 
            if (e.button == 0)
            {
                if (this._symbol.clicked0)
                {
                    this._symbol.clicked0      = false;
                    this._symbol.style.opacity = 1;

                    actionManager.do(new ToggleArithmeticSymbolAction(this.id, true));
                }
                else if (!this._showOnlySymbol)
                {
                    this._symbol.clicked0 = true;
                    setTimeout(() => this._symbol.clicked0 = false, 250); // seems like a good default guess
                }
            }
        });

        this.header.appendChild(this._symbol);

        
        this.textbox.addEventListener('finishedit', e => 
        {
            actionManager.do(new ToggleArithmeticSymbolAction(this.id, false), e.detail.value != e.detail.oldValue);
        });
    }
    
    
    
    addNewInput()
    {
        const input = new Input(this.dataType);
        input.isNew = true;

        input.addEventListener('connect',    () => { onConnectInput(this); input.isNew = false; });
        input.addEventListener('disconnect', () => onDisconnectInput(this, input));

        this.addInput(input);

        return input;
    }



    // refresh()
    // {
    //     super.refresh();
        
    //     //this._sampled = Number.NaN;
    // }



    updateData()
    {
        let maxDec = 0;

        for (const input of this.inputs)
        {
            if (input.isConnected)
            {
                //input.connectedOutput.op.updateData();

                // ^ this could have removed one or more inputs and connections
                // in which case abort
                if (!input.isConnected)
                {
                    super.updateData();
                    return;
                }

                maxDec = Math.max(maxDec, input.data.decimals);
            }
        }


        const result = this.getResult();

        this.outputs[0]._data = dataFromNumber(result, maxDec);

        this.#paramValue.control.setDecimals(maxDec);
        this.#paramValue.setValue(result, false, true, false);

        
        super.updateData()
    }



    updateHeader()
    {
        super.updateHeader();


        const colBack  = dataType2rgb(this._dataType, this.active);
        const darkText = rgb2hclokl(colBack)[2] > 0.71;
        
        const colText  = darkText ? [0, 0, 0] : [1, 1, 1];

        this._symbol.style.color      = colorStyleRgb(colText);
        this._symbol.style.fontWeight = this.active ? 'bold' : 'normal';
    }



    getResult()
    {
        return Number.NaN;
    }



    updateNode()
    {
        super.updateNode();


        if (this._showOnlySymbol)
        {
            this._symbol.style.fontSize = 17;
            this._symbol.style.left     = 'calc(50% + 1px)';
            this._symbol.style.top      = this.header.offsetHeight/2 - 11;
        }
        else
        {
            this._symbol.style.fontSize = 12;
            this._symbol.style.left     = 'calc(50% + 1px)';
            this._symbol.style.top      = this.header.offsetHeight/2 - 15;
            this.label  .style.top      = 'calc(50% + 3px)';
        }
       
        
        this.label.style.visibility = this._showOnlySymbol ? 'hidden'  : 'visible';
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"showOnlySymbol": "' + boolString(this._showOnlySymbol) + '"';
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }



    loadParams(_node)
    {
        if (_node.showOnlySymbol)
            this._showOnlySymbol = isTrue(_node.showOnlySymbol);

        //super.loadParams(_node);
    }
}



function onConnectInput(op)
{
    op.addNewInput();
    op.updateNode();
    graphView.updateNodeTransform(op);
}



function onDisconnectInput(op, input)
{
    removeFromArray(op.inputs, input);
    op.inputControls.removeChild(input.control);
    op.updateNode();
}


class   OpAdd
extends OpArithmetic
{
    constructor()
    {
        super('add', 'add', '+');
    }
    
    
    
    getResult()
    {
        let result = 0;

        for (let i = 0; i < this.inputs.length-1; i++)
            result += this.inputs[i].data.value;

        return result;
    }
}


class   OpSubtract
extends OpArithmetic
{
    constructor()
    {
        super('subtract', 'sub', '−');
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;

        let result = this.inputs[0].data.value;

        for (let i = 1; i < this.inputs.length-1; i++)
            result -= this.inputs[i].data.value;

        return result;
    }
}


class   OpMultiply
extends OpArithmetic
{
    constructor()
    {
        super('multiply', 'mul', '×');
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;

        let result = 1;

        for (let i = 0; i < this.inputs.length-1; i++)
            result *= this.inputs[i].data.value;

        return result;
    }
}


class   OpDivide
extends OpArithmetic
{
    constructor()
    {
        super('divide', 'div', '÷');
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;

        let result = this.inputs[0].data.value;

        for (let i = 1; i < this.inputs.length-1; i++)
        {
            const div = this.inputs[i].data.value;
            if (div == 0) return Number.NaN;
            result /= div;
        }

        return result;
    }
}


class   OpModulo
extends OpArithmetic
{
    constructor()
    {
        super('modulo', 'mod', '%');
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;

        let result = this.inputs[0].data.value;

        for (let i = 1; i < this.inputs.length-1; i++)
        {
            const div = this.inputs[i].data.value;
            if (div == 0) return Number.NaN;
            result %= div;
        }

        return result;
    }



    updateNode()
    {
        super.updateNode();

        // this._symbol.innerHTML =
        //     this._showOnlySymbol
        //     ? '<span style="font-size: 14px;">x</span><span style="position: relative; left: -1px; top: -7px; font-size: 7px; font-weight: bold;">y</span>'
        //     : '<span style="position: relative; top: -1.5px; font-size: 8px;">x</span><span style="position: relative; left: -0.5px; top: -5.15px; font-size: 3.75px; font-weight: bold;">y</span>';

        this._symbol.style.fontSize   = this._showOnlySymbol ? 11 : 8;
        this._symbol.style.fontWeight = 'bold';
        this._symbol.style.left       = 'calc(50% + ' + (this._showOnlySymbol ? 1.5 : 1) + 'px)';
        this._symbol.style.top        = parseFloat(this._symbol.style.top) + (this._showOnlySymbol ? 4 : 4.5);
    }
}


class   OpExponent
extends OpArithmetic
{
    constructor()
    {
        super('exponent', 'exp', 'xʸ'); // placeholder symbol, actual symbol set in updateNode()
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;
            
        let result = this.inputs[0].data.value;

        for (let i = 1; i < this.inputs.length-1; i++)
            result = Math.pow(result, this.inputs[i].data.value);

        return result;
    }



    updateNode()
    {
        super.updateNode();

        this._symbol.innerHTML =
            this._showOnlySymbol
            ? '<span style="font-size: 14px;">x</span><span style="position: relative; left: -1px; top: -7px; font-size: 7px; font-weight: bold;">y</span>'
            : '<span style="position: relative; top: -2.5px; font-size: 9px;">x</span><span style="position: relative; left: -0.5px; top: -7.5px; font-size: 3.75px; font-weight: bold;">y</span>';

        this._symbol.style.left = 'calc(50% + ' + (this._showOnlySymbol ? 1.5 : 1) + 'px)';
        this._symbol.style.top  = parseFloat(this._symbol.style.top) + (this._showOnlySymbol ? 1.5 : 6);
    }
}


class   OpInterpolate
extends OperatorBase
{
    #paramValue;
    #paramAmount;



    constructor()
    {
        super('interpolate', 'inter', 'number', 70);

        this.addInput(new Input(this.dataType));
        this.addInput(new Input(this.dataType));

        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramValue  = new NumberParam('value',  '', false, false, false, 0));
        this.addParam(this.#paramAmount = new NumberParam('amount', '', true,  true,  true, 50, 0, 100, 0));

        enableSliderText(this.#paramValue.control, false);
        
        this.#paramAmount.control.min        = Number.MIN_SAFE_INTEGER; // allow
        this.#paramAmount.control.max        = Number.MAX_SAFE_INTEGER; // extrapolation
        this.#paramAmount.control.displayDec = 0;
        
        this.#paramAmount.control.setSuffix('%', true);
    }



    updateData()
    {
        let result = Number.NaN;
        let maxDec = 0;

        if (   this.inputs[0].isConnected
            && this.inputs[1].isConnected)
        {
            const a = this.inputs[0].data.value; 
            const b = this.inputs[1].data.value; 

            result = a + (b - a) * this.#paramAmount.value / 100;

            maxDec = Math.max(
                this.inputs[0].data.decimals,
                this.inputs[1].data.decimals);
        }
        else if (this.inputs[0].isConnected)
        {
            result = this.inputs[0].data.value;
            maxDec = this.inputs[0].data.decimals;
        }
        else if (this.inputs[1].isConnected)
        {
            result = this.inputs[1].data.value;
            maxDec = this.inputs[1].data.decimals;
        }


        this.outputs[0]._data = dataFromNumber(result, maxDec);

        this.#paramValue.control.setDecimals(maxDec);
        this.#paramValue.setValue(result, false, true, false);

        this.#paramValue.control.update();


        super.updateData()
    }
}


class OpColorBase
extends Operator
{
    _color = dataColor_NaN;

    _warningOverlay;

    
    forceShowWarning = false;
    warningStyle;
    


    constructor(opType, shortType, dataType, defWidth = 80)
    {
        super(opType, shortType, dataType, defWidth);


        this._warningOverlay = createDiv('colorWarningOverlay');
        this._warningOverlay.style.zIndex = 1;
        this.inner.appendChild(this._warningOverlay);


        this.header.addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.header.addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });
    }



    updateHeader()
    {
        //log(this.id + '.OpColorBase.updateHeader()');


        const [colBack,, colInput, colOutput,,] = this.getHeaderColors();

        this.header.style.background = 
            this.canShowColor()
            ? colorStyleRgb(colBack)
            : '#ead8eaee';


        const noColor = [0.7, 0.7, 0.7];

        for (const input of this.inputs.filter(i => !i.param))
        {
            input.wireColor = this.canShowColor() ? colBack : noColor;
            input.color     = colInput;
        }


        for (const output of this.outputs.filter(i => !i.param))
        {
            output.wireColor = this.canShowColor() ? colBack : noColor;
            output.color     = colOutput;
        }


        this.updateHeaderLabel();
        this.updateWarningOverlay();


        super.updateHeader();
    }



    updateHeaderLabel()
    {
        const [,,,,, textStyle] = this.getHeaderColors();
        
        this.label.style.color = textStyle;
    }



    getHeaderColors()
    {
        const colBack = 
            dataColorIsNaN(this._color)
            ? color_NaN
            : dataColor2rgb(this._color);

        const darkText = 
               !this.canShowColor()
            || rgb2hclokl(colBack)[2] > 0.71;

        const ba = Math.min((this.header.over ? 14 : 1) * (isRgbValid(colBack) ? 0.03 : 0.22), 0.5);
        const wa = Math.min((this.header.over ? 14 : 1) * (isRgbValid(colBack) ? 0.03 : 0.14), 0.5);

        const colText = 
            this.canShowColor()
            ? (darkText 
               ? [0, 0, 0, ba] 
               : [1, 1, 1, wa])
            : [0, 0, 0, 1];

        const colInput  = this.canShowColor() ? colText : [0, 0, 0, 0.12];
        const colOutput = this.canShowColor() ? colText : [0, 0, 0, 0.1 ];

        const textStyle = colorStyleRgba(colText);

        return [
            colBack, 
            darkText,
            colInput,
            colOutput, 
            colText,
            textStyle ];
    }



    updateWarningOverlay() 
    {
        //log(this.id + '.updateWarningOverlay()');
        
        if (this.canShowColor())
        {
            const rgb = dataColor2rgb(this._color);

            if (   !isRgbValid(rgb)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = this.getDefaultWarningStyle(rgb);

                this.updateWarningOverlayStyle(rgb);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.resetWarningStyle();
            this.updateWarningOverlayStyle(color_NaN);
        }
    }



    getDefaultWarningStyle(colBack)
    {
        return colorStyleRgba(
            isDark(colBack) 
            ? [0, 0, 0, 0.12]  
            : [1, 1, 1, 0.2 ]);
    }



    resetWarningStyle()
    {
        this.warningStyle = colorStyleRgba([0.5, 1, 0.5, 0.2]);        
    }



    canShowColor()
    {
        return !isDataColorNaN(this._color);
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        this._warningOverlay.style.height = 
            height < 0
            ? this.header.offsetHeight
            : height;

        this._warningOverlay.style.background =
               isRgbValid(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : 'repeating-linear-gradient('
              + '-45deg, '
              + 'transparent 0 7px,'
              +  this.warningStyle + ' 7px 14px)';

        this._warningOverlay.style.display = 'block';
    }
}


/* 
    the data type 'color' contains four elements: 
        color space 
        component 1
        component 2
        component 3
*/



class   OpColor
extends OpColorBase
{
    paramSpace;
    
    param1;
    param2;
    param3;

    #colorBack;


    hexbox;

    
    _oldSpace;
    _oldSpaceConnections = [];


    _colorBeforeNaN = dataColor_NaN;


    #init = false;
    


    constructor()
    {
        super('color', 'color', 'color', 80);


        this._color    = ['rgb', 0.5, 0.5, 0.5];
        this._oldSpace =  'rgb';


        this.#colorBack = createDiv('colorBack');
        this.inner.appendChild(this.#colorBack);


        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));


        this.inputs[0].addEventListener('connect', () =>
        {
            for (let i = 1; i < this.params.length; i++)
                enableSliderText(this.params[i].control, false);
        });
    
        this.inputs[0].addEventListener('disconnect', () =>
        {
            for (let i = 1; i < this.params.length; i++)
            {
                if (!this.params[i].input.isConnected) 
                    enableSliderText(this.params[i].control, true);
            }

            this.updateNode();
        });

        
        this.addParam(this.paramSpace = new SelectParam('space', 'space', false, true, true, OpColorSpaces.map(s => s[1]), 0));
        this.addParam(this.param1     = new NumberParam('c1',    '',      true,  true, true, Math.round(this._color[1] * rgbFactor[0])));
        this.addParam(this.param2     = new NumberParam('c2',    '',      true,  true, true, Math.round(this._color[2] * rgbFactor[1])));
        this.addParam(this.param3     = new NumberParam('c3',    '',      true,  true, true, Math.round(this._color[3] * rgbFactor[2])));

        
        this.paramSpace.control.barTop  = 0.8;

        this.paramSpace.control.wheelScale = 1;
        this.param1    .control.wheelScale = 1;
        this.param2    .control.wheelScale = 1;
        this.param3    .control.wheelScale = 1;


        this.paramSpace.control.addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.paramSpace.control.addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });


        // this.paramSpace.addEventListener('beforechange', e => paramSpace_onbeforechange(e.target));
        // this.paramSpace.addEventListener('change',       e => paramSpace_onchange(e.target));


        initHexbox(this);


        for (let i = 1; i < this.params.length; i++)
            this.params[i].input.addEventListener('disconnect', () => { enableSliderText(this.params[i].control, !this.inputs[0].isConnected); });
    }



    getDataColorFromParams()
    {
        const col = getNormalColor_(
            colorSpace(this.paramSpace.value),
            this.param1.value,
            this.param2.value,
            this.param3.value);
    
        return [
            colorSpace(this.paramSpace.value),
            col[0],
            col[1],
            col[2] ];
    }
    
    
    
    setColorParams(color, fireChangeEvent = false)
    {
        const col = getDataColor(color);

        this.param1.setValue(col[0], fireChangeEvent);
        this.param2.setValue(col[1], fireChangeEvent);
        this.param3.setValue(col[2], fireChangeEvent);
    }



    isConnected()
    {
        return this.inputs[0].isConnected
            || this.inputs[2].isConnected
            || this.inputs[3].isConnected
            || this.inputs[4].isConnected;
    }



    getHeaderColor() 
    {
        return dataColor2rgb(this._color); 
    }



    updateData()
    {
        //log(this.id + '.OpColor.updateData()');

        if (this.inputs[0].isConnected) 
        {
            if (   dataColorIsNaN(this.inputs[0].data.color)
                && !this.loading
                && !dataColorIsNaN(this._color))
            {
                this._colorBeforeNaN = this._color;
                this._color          = dataColor_NaN;
            }
            else
            {
                const toSpace = colorSpace(this.paramSpace.value);
                const color   = convertDataColorToSpace(this.inputs[0].data.color, toSpace);
                
                if (this.param1.input.isConnected) color[1] = getNormalValue(this.param1.input.data.value, color[0], 0);
                if (this.param2.input.isConnected) color[2] = getNormalValue(this.param2.input.data.value, color[0], 1);
                if (this.param3.input.isConnected) color[3] = getNormalValue(this.param3.input.data.value, color[0], 2);

                switchToSpace(this, toSpace);
                setDataColorToCurrentSpace(this, color);
            }
        }
        else
        {
            if (!dataColorIsNaN(this._colorBeforeNaN))
            {
                this._color          = this._colorBeforeNaN;
                this._colorBeforeNaN = dataColor_NaN;

                const toSpace = colorSpace(this.paramSpace.value);

                switchToSpace(this, toSpace);
                setDataColorToCurrentSpace(this, this._color);

                this._oldSpace = toSpace;
            }
            else
            {
                const toSpace = colorSpace(this.paramSpace.value);

                if (   !this.#init
                    ||  this._oldSpace != toSpace
                    || !dataColorIsNaN(this._colorBeforeNaN))
                {
                    this.param1.allowEditDecimals = this.paramSpace.value > 1;
                    this.param2.allowEditDecimals = this.paramSpace.value > 1;
                    this.param3.allowEditDecimals = this.paramSpace.value > 1;

                    const color =
                        this.loading 
                        ? this.getDataColorFromParams()
                        : this._color;


                    switchToSpace(this, toSpace);
                    setDataColorToCurrentSpace(this, color);


                    for (let i = 2; i < 5; i++)
                    {
                        if (this.inputs[i].isConnected) 
                        { 
                            const param = this.inputs[i].param;

                            param.update(); 
                            this._color[i-1] = param.value; 
                        }
                    }


                    this.#init = true;
                }

                this._color    = this.getDataColorFromParams();
                this._oldSpace = toSpace;
            }
        }

    
        this.outputs[0]._data = dataFromDataColor(this._color);


        super.updateData()
    }



    updateNode()
    {
        //log(this.id + '.OpColor.updateNode()');

        
        enableElementText(this.hexbox, !this.isConnected());

        if (this.hexbox != document.activeElement)
        {
            const colBack = dataColor2rgb(this._color);

            this.hexbox.value = 
                isRgbValid(colBack)
                ? rgb2hex(colBack)
                : '?';
        }


        super.updateNode();
    }



    updateHeader()
    {
        //log(this.id + '.OpColor.updateHeader()');

        super.updateHeader();
        

        this.header.style.background = 'transparent';
    
    
        const [colBack, darkText, colInput, colOutput,, textStyle] = this.getHeaderColors();

        this.#colorBack.style.background = 
            this.canShowColor()
            ? colorStyleRgb(colBack)
            : '#ead8eaee';


        const colSpaceBar = 
            darkText 
            ? [0, 0, 0, isRgbValid(colBack) ? (this.header.over ? 3 : 1) * 0.03 : 0.12] 
            : [1, 1, 1, isRgbValid(colBack) ? (this.header.over ? 3 : 1) * 0.05 : 0.24];

        this.paramSpace.control.backColor  = 'transparent';
        this.paramSpace.control.valueColor = colorStyleRgba(colSpaceBar);
        this.paramSpace.control.textColor  = textStyle;
        this.paramSpace.input .color       = colInput;
        this.paramSpace.output.color       = colOutput;
        this.paramSpace.updateControls();

        const colWarning = 
            darkText 
            ? [0, 0, 0, 0.12] 
            : [1, 1, 1, 0.2 ];

        this.warningStyle = colorStyleRgba(colWarning);


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colBack, 45);
    }



    updateParamControls()
    {
        const [colBack,,,,] = this.getHeaderColors();

        this.updateAllSliderRanges();

        const isValid = 
               colorSpaceIndex(this._color[0]) > 3
            || isRgbValid(colBack);

        this.updateSlider(this.param1.control, isValid);
        this.updateSlider(this.param2.control, isValid);
        this.updateSlider(this.param3.control, isValid);
    }



    updateSlider(slider, isValid)
    {
        // slider.valueText = 
        //        this.inputs[0].isConnected 
        //     // && this.inputs[0].data.color[0] != this._color[0]
        //     && !isValid 
        //     ? '?' 
        //     : '';

        if (    this.inputs[0].isConnected
            && !isValid)
            slider.setValue(Number.NaN, true, false, false);

        enableElementText(slider.textbox, !this.inputs[0].isConnected);

        slider.update();
    }



    resetAllControlRanges()
    {
        resetSliderRanges(this.param1.control);
        resetSliderRanges(this.param2.control);
        resetSliderRanges(this.param3.control);
    }



    updateAllSliderRanges()
    {
        if (this.paramSpace.value > 3) // warning ranges
        {
            this.updateSliderRanges(this.param1.control, f =>
                dataColor2rgb([
                    this._color[0],
                    (this.param1.control.displayMin + f * (this.param1.control.displayMax - this.param1.control.displayMin)) / getColorSpaceFactor(this._color[0])[0],
                    this._color[2],
                    this._color[3]]));

            this.updateSliderRanges(this.param2.control, f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    (this.param2.control.displayMin + f * (this.param2.control.displayMax - this.param2.control.displayMin)) / getColorSpaceFactor(this._color[0])[1],
                    this._color[3]]));

            this.updateSliderRanges(this.param3.control, f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    this._color[2],
                    (this.param3.control.displayMin + f * (this.param3.control.displayMax - this.param3.control.displayMin)) / getColorSpaceFactor(this._color[0])[2]]));
        }
        else // no warning ranges
        {
            this.resetAllControlRanges();
        }
    }



    updateSliderRanges(slider, getRgb)
    {
        const ranges    = [];
 
        
        const precision = 0.01;
        let   open      = false;

        for (let f = 0; f <= 1; f += precision)
        {
            const rgb = getRgb(f);

            if (!open && !isRgbValid(rgb))
            {
                ranges.push(new NumberSliderRange(f, f, 'rgba(255, 0, 0, 0.16)', 0.8));
                open = true;
            }
            else if (open && isRgbValid(rgb)) 
            {
                ranges[ranges.length-1].end = f;
                open = false;
            }
        }

        
        if (open)
            lastOf(ranges).end = 1;
        else if (!open
              && ranges.length == 0)
            resetSliderRanges(slider);


        slider.ranges = ranges;
    }



    paramIsConsideredDefault(param)
    {
        return super.paramIsConsideredDefault(param)
            && !this.inputs[0].isConnected
            && (  !this.paramSpace.input.isConnected
                || this.paramSpace.value == 0);
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        let json = super.toJsonBase(nTab);

        if (!dataColorIsNaN(this._colorBeforeNaN))
            json += ',\n' + pos + tab + '"colorBeforeNaN":\n' + dataColorToJson(this._colorBeforeNaN, 4);

        return json;
    }



    paramsToJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
        
        let first = true;
        for (let i = 0; i < this.params.length; i++)
        {
            const param = this.params[i];

            if (!this.paramIsConsideredDefault(param))
            {
                if (!first) json += ',\n'; first = false;
                json += pos + tab + tab + param.toJson(nTab, i > 0 ? 'c' + i : '');
            }
        }

        if (!first)
            json += '\n';

        json += pos + tab + ']';

        return json;
    }



    loadParams(_node)
    {
        if (_node.colorBeforeNaN)
            this._colorBeforeNaN = _node.colorBeforeNaN;

        super.loadParams(_node);
    }
}



// function paramSpace_onbeforechange(paramSpace)
// {
//     if (   paramSpace.value == 0
//         && paramSpace.oldValue > 0)
//     {
//         for (let i = 2; i < paramSpace.op.inputs.length; i++)
//         {
//             const input = paramSpace.op.inputs[i];

//             if (input.isConnected)
//                 paramSpace.op._oldSpaceConnections.push(getConnectionForArrayWithNames(input.connection));
//         }   

//         for (let i = 2; i < paramSpace.op.outputs.length; i++)
//         {
//             const output = paramSpace.op.outputs[i];

//             for (const input of output.connectedInputs)
//                 paramSpace.op._oldSpaceConnections.push(getConnectionForArrayWithNames(input.connection));
//         }   
//     }
// }



// function paramSpace_onchange(paramSpace)
// {
//     // restore the old connections
    
//     if (   paramSpace.value > 0
//         && paramSpace.oldValue == 0)
//     {
//         for (const conn of paramSpace.op._oldSpaceConnections)
//         {
//             const outputOp = nodeFromId(conn.outputOpName);
//             const  inputOp = nodeFromId(conn. inputOpName);

//             if (outputOp && inputOp)
//             {
//                 const output = outputOp.outputs[conn.outputIndex];
//                 const  input =  inputOp. inputs[conn. inputIndex];

//                 uiVariableConnect(outputOp, conn.outputIndex, inputOp, conn.inputIndex);
//             }
//         }

//         paramSpace.op._oldSpaceConnections = [];
//     }

//     //paramSpace.op.pushUpdate();
// }


const OpColorSpaces = 
[
    ['hex',    'Hex'   ],
    //['rgbhex', '<span class=\'hash\'>#</span>RGB'],
    ['rgb',    'RGB'   ], 
    ['hsv',    'HSV'   ], 
    ['hsl',    'HSL'   ], 
    ['hclokl', 'HCL/ok'],
    ['hcllab', 'HCL/ab'],
    ['hclluv', 'HCL/uv']/*,
    ['oklab',  'okLab' ],
    ['lab',    'Lab'   ],
    ['luv',    'Luv'   ]*/
];

function colorSpace(index) { return OpColorSpaces[index][0]; }

function colorSpaceIndex(space) { return OpColorSpaces.findIndex(s => s[0] == space); }



const rgbFactor   = [255, 255, 255];
const hs_Factor   = [360, 100, 100];
const hclFactor   = [360, 100, 100];
const oppFactor   = [100, 100, 100];

const rgbScale    = [255, 255, 255];
const hs_Scale    = [360, 100, 100];
const hcloklScale = [360,  51, 100];
const hcllabScale = [360, 400, 100];
const hclluvScale = [360, 330, 100];
const oklabScale  = [100,  30,  30];
const labScale    = [100, 100, 100];
const luvScale    = [100, 150, 150];



function switchToSpace(op, space)
{
    switch (space)
    {
        case 'hex':    switchToHex   (op); break;
        case 'rgbhex': switchToRgbHex(op); break;
        case 'rgb':    switchToRgb   (op); break;
        case 'hsv':    switchToHsv   (op); break;
        case 'hsl':    switchToHsl   (op); break;
        case 'hclokl': switchToHclOkl(op); break;
        case 'hcllab': switchToHclLab(op); break;
        case 'hclluv': switchToHclLuv(op); break;
        case 'oklab':  switchToOklab (op); break;
        case 'lab':    switchToLab   (op); break;
        case 'luv':    switchToLuv   (op); break;
    }

    op.resetAllControlRanges();
}



function switchToHex   (op) { switchToTextbox       (op);           }
function switchToRgbHex(op) { switchToRgbHexControls(op);           }
function switchToRgb   (op) { switchToRgbControls   (op);           }
function switchToHsv   (op) { switchToHs_Controls   (op, 'V');      }
function switchToHsl   (op) { switchToHs_Controls   (op, 'L');      }
function switchToHclOkl(op) { switchToHclOklControls(op);           }
function switchToHclLab(op) { switchToHclLabControls(op);           }
function switchToHclLuv(op) { switchToHclLuvControls(op);           }
function switchToOklab (op) { switchToOklabControls (op, 'a', 'b'); }
function switchToLab   (op) { switchToLabControls   (op, 'a', 'b'); }
function switchToLuv   (op) { switchToLuvControls   (op, 'u', 'v'); }
   


function switchToRgbHexControls(op)
{
    switchToControls(op, 
        '<span class=\'hash\'>#</span>R', 0, rgbScale[0], '', false, 
        '<span class=\'hash\'>#</span>G', 0, rgbScale[1], 
        '<span class=\'hash\'>#</span>B', 0, rgbScale[2]);  

    showRgbControlHex(op, true);
}



function switchToRgbControls(op)
{
    switchToControls(op, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    showRgbControlHex(op, false);    
}



function switchToHs_Controls(op, v_or_l) 
{ 
    switchToControls(op, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToHclControls(op, scale) 
{ 
    switchToControls(op, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToHclOklControls(op) { switchToHclControls(op, hcloklScale); }
function switchToHclLabControls(op) { switchToHclControls(op, hcllabScale); }
function switchToHclLuvControls(op) { switchToHclControls(op, hclluvScale); }



function switchToOppControls(op, c2, c3, scale)
{ 
    switchToControls(op, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToOklabControls(op) { switchToOppControls(op, 'a', 'b', oklabScale); }
function switchToLabControls  (op) { switchToOppControls(op, 'a', 'b', labScale  ); }
function switchToLuvControls  (op) { switchToOppControls(op, 'u', 'v', luvScale  ); }



function showRgbControlHex(op, show)
{
    op.param1.control.showHex = show;
    op.param2.control.showHex = show;
    op.param3.control.showHex = show;
}



function switchToControls(op, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(op);

    op.param1.setName(c1, false); 
    op.param2.setName(c2, false); 
    op.param3.setName(c3, false);

    op.param1.control.wrapValue = c1wrap;
    op.param1.control.setSuffix(c1suffix, c1suffix != '');

    op.param1.control.setMin(c1min, false); 
    op.param2.control.setMin(c2min, false);
    op.param3.control.setMin(c3min, false);
    
    op.param1.control.setMax(c1max, false); 
    op.param2.control.setMax(c2max, false); 
    op.param3.control.setMax(c3max, false); 
    
    op.param1.updateControls();
    op.param2.updateControls();
    op.param3.updateControls();
}



function switchToTextbox(op)
{
    if (!op.inner.contains(op.hexbox))
    {
        removeOpColorParamWires(op);

        op.inner.removeChild(op.param1.div);
        op.inner.removeChild(op.param2.div);
        op.inner.removeChild(op.param3.div);
        
        op.inner.appendChild(op.hexbox);

        //graphView.updateNodeTransform(op);
    }
}



function removeOpColorParamWires(op)
{
    for (let i = op.inputs.length-1; i >= 2; i--)
        if (op.inputs[i].isConnected)
            uiDisconnect(op.inputs[i]);

    for (let i = op.outputs.length-1; i >= 2; i--)
        for (const input of op.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(op)
{
    if (op.inner.contains(op.hexbox))
    {
        op.inner.removeChild(op.hexbox);

        op.inner.appendChild(op.param1.div);
        op.inner.appendChild(op.param2.div);
        op.inner.appendChild(op.param3.div);

        graphView.updateNodeTransform(op);
    }
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return getNormalValueRgb_(value, chan);
        case 'hsv':   
        case 'hsl':    return getNormalValueHs_ (value, chan);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalValueHcl (value, chan);
        case 'oklab':  
        case 'lab':    
        case 'luv':    return getNormalValuesOpp(value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return getNormalColorRgb_(c1, c2, c3);
        case 'hsv':   
        case 'hsl':    return getNormalColorHs_(c1, c2, c3);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalColorHcl(c1, c2, c3);
        case 'oklab': 
        case 'lab': 
        case 'luv':    return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return getDataColorRgb(color[1], color[2], color[3]);
        case 'hsv':   
        case 'hsl':    return getDataColorHs_(color[1], color[2], color[3]);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getDataColorHcl(color[1], color[2], color[3]);
        case 'oklab': 
        case 'lab': 
        case 'luv':    return getDataColorOpp(color[1], color[2], color[3]);
    }
}



function getDataColorRgb(c1, c2, c3)
{
    return [
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getDataColorHs_(c1, c2, c3)
{
    return [
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getDataColorOpp(c1, c2, c3)
{
    return [
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function getDataColorHcl(c1, c2, c3)
{
    return [
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function setDataColorToCurrentSpace(op, color)
{
    const toSpace = colorSpace(op.paramSpace.value);
    op._color = convertDataColorToSpace(color, toSpace);
    op.setColorParams(op._color);
}



function getColorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return rgbFactor;
        case 'hsv':   
        case 'hsl':    return hs_Factor;
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return hclFactor;
        case 'oklab': 
        case 'lab': 
        case 'luv':    return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    return rgbScale;
        case 'hsv':   
        case 'hsl':    return hs_Scale;
        case 'hclokl': return hcloklScale;
        case 'hcllab': return hcllabScale;
        case 'hclluv': return hclluvScale;
        case 'oklab':  return oklabScale;
        case 'lab':    return labScale;
        case 'luv':    return luvScale;
    }    
}


function initHexbox(op)
{
    op.hexbox = createTextbox('hexbox');
    
    op.hexbox.op      = op;
    op.hexbox.editing = false;
    
    op.hexbox.addEventListener('pointerdown', onHexboxPointerDown);
    op.hexbox.addEventListener('pointerup',   onHexboxPointerUp);
    op.hexbox.addEventListener('focus',       onHexboxFocus);
    op.hexbox.addEventListener('focusout',    onHexboxFocusOut);
    op.hexbox.addEventListener('input',       onHexboxInput);
    op.hexbox.addEventListener('keydown',     onHexboxKeyDown);
}



function onHexboxPointerDown(e)
{
    //const hexbox = e.target;

    if (e.button > 0)
        e.preventDefault();

    e.stopPropagation();
}



function onHexboxPointerUp(e)
{
    const hexbox = e.target;

    if (    e.button == 0
        && !hexbox.editing)
    {
        e.preventDefault();

        hexbox.savedValue = hexbox.value;

        hexbox.focus();
        hexbox.select();
        hexbox.editing = true;
    }
}



function onHexboxFocus(e)
{
    const hexbox = e.target;
    hexbox.style.cursor = 'default';
}



function onHexboxFocusOut(e)
{
    const hexbox = e.target;
    hexboxFinish(hexbox.op, true);
    hexbox.style.cursor = 'default';//hexbox.op.isConnected() ? 'default' : 'text';
}



function onHexboxInput(e)
{
    const hexbox = e.target;
    
    let val = hexbox.value;

    if (val.trim() == '')
        return;

         if (   val.length > 7 
             && val[0] == '#') hexbox.value = val.trim().slice(0, 7);
    else if (val.length > 6)   hexbox.value = val.trim().slice(0, 6);
}



function onHexboxKeyDown(e)
{
    e.stopPropagation();

    
    const hexbox = e.target;

    if (   e.code == 'KeyC'
        && getCtrlKey(e))
    {
        e.preventDefault();
        document.execCommand('copy');
    }

    else if (   e.code == 'KeyV'
        && getCtrlKey(e)
        && !hexbox.op.isConnected())
    {
        // do nothing and let the OS do its thing
    }

    else if ((   e.code == 'Enter'
              || e.code == 'NumpadEnter')
           && !hexbox.op.isConnected())
        hexboxFinish(hexbox.op, true);

    else if (e.code == 'Escape')
        hexboxFinish(hexbox.op, false);

    else if (   e.key.length == 1
             && !isDigitChar(e.key)
             && !isHexDigitChar(e.key)
         ||     hexbox.op.isConnected()
            && !isArrowKey(e.code)
         ||    e.key != 'ArrowLeft'
            && e.key != 'ArrowRight'
            && e.key != 'Delete'
            && e.key != 'Backspace'
            && hexbox.value.length >= 6
            && hexbox.selectionStart == hexbox.selectionEnd)
        e.preventDefault();

    // else if (e.key == 'ArrowUp'
    //       || e.key == 'ArrowDown')
    // {

    // }
}



function hexboxFinish(op, success)
{
    if (op.hexbox.value.trim() == '')
        op.hexbox.value = op.hexbox.savedValue;


    var rgb = hex2rgb(op.hexbox.value);

    if (success) 
    {
        setDataColorToCurrentSpace(op, rgb2dataColor(rgb));
        op.hexbox.op.pushUpdate();
    }

    
    op.hexbox.selectionEnd = op.hexbox.selectionStart;
    op.hexbox.editing = false;
    op.hexbox.blur();
};


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgbhex': 
        case 'rgb':    return            col;
        case 'hsv':    return hsv2rgb   (col);
        case 'hsl':    return hsl2rgb   (col);
        case 'hclokl': return hclokl2rgb(col);
        case 'hcllab': return hcllab2rgb(col);
        case 'hclluv': return hclluv2rgb(col);
        case 'oklab':  return oklab2rgb (col);
        case 'lab':    return lab2rgb   (col);
        case 'luv':    return luv2rgb   (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgbhex': { let hex = convert2rgb(color); hex[0] = toSpace; return hex; }
        case 'rgb':    return convert2rgb   (color);
        case 'hsv':    return convert2hsv   (color);
        case 'hsl':    return convert2hsl   (color);
        case 'hclokl': return convert2hclokl(color);
        case 'hcllab': return convert2hcllab(color);
        case 'hclluv': return convert2hclluv(color);
        case 'oklab':  return convert2oklab (color);
        case 'lab':    return convert2lab   (color);
        case 'luv':    return convert2luv   (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    rgb =            col;  break;
        case 'hsv':    rgb = hsv2rgb   (col); break;
        case 'hsl':    rgb = hsl2rgb   (col); break;
        case 'hclokl': rgb = hclokl2rgb(col); break;
        case 'hcllab': rgb = hcllab2rgb(col); break;
        case 'hclluv': rgb = hclluv2rgb(col); break;
        case 'oklab':  rgb = oklab2rgb (col); break;
        case 'lab':    rgb = lab2rgb   (col); break;
        case 'luv':    rgb = luv2rgb   (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hsv = rgb2hsv(           col ); break;
        case 'hsv':    hsv =                    col;   break;
        case 'hsl':    hsv = rgb2hsv(hsl2rgb   (col)); break;
        case 'hclokl': hsv = rgb2hsv(hclokl2rgb(col)); break;
        case 'hcllab': hsv = rgb2hsv(hcllab2rgb(col)); break;
        case 'hclluv': hsv = rgb2hsv(hclluv2rgb(col)); break;
        case 'oklab':  hsv = rgb2hsv(oklab2rgb (col)); break;
        case 'lab':    hsv = rgb2hsv(lab2rgb   (col)); break;
        case 'luv':    hsv = rgb2hsv(luv2rgb   (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hsl = rgb2hsl(           col ); break;
        case 'hsv':    hsl = rgb2hsl(hsv2rgb   (col)); break;
        case 'hsl':    hsl =                    col;   break;
        case 'hclokl': hsl = rgb2hsl(hclokl2rgb(col)); break;
        case 'hcllab': hsl = rgb2hsl(hcllab2rgb(col)); break;
        case 'hclluv': hsl = rgb2hsl(hclluv2rgb(col)); break;
        case 'oklab':  hsl = rgb2hsl(oklab2rgb (col)); break;
        case 'lab':    hsl = rgb2hsl(lab2rgb   (col)); break;
        case 'luv':    hsl = rgb2hsl(luv2rgb   (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function convert2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    lab = rgb2oklab(           col ); break;
        case 'hsv':    lab = rgb2oklab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2oklab(hsl2rgb   (col)); break;
        case 'hclokl': lab = rgb2oklab(hclokl2rgb(col)); break;
        case 'hcllab': lab = rgb2oklab(hcllab2rgb(col)); break;
        case 'hclluv': lab = rgb2oklab(hclluv2rgb(col)); break;
        case 'oklab':  lab =                      col;   break;
        case 'lab':    lab = rgb2oklab(lab2rgb   (col)); break;
        case 'luv':    lab = rgb2oklab(luv2rgb   (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    lab = rgb2lab(           col ); break;
        case 'hsv':    lab = rgb2lab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2lab(hsl2rgb   (col)); break;
        case 'hclokl': lab = rgb2lab(hclokl2rgb(col)); break;
        case 'hcllab': lab =         hcllab2lab(col);  break;
        case 'hclluv': lab = rgb2lab(hclluv2rgb(col)); break;
        case 'oklab':  lab = rgb2lab(oklab2rgb (col)); break;
        case 'lab':    lab =                    col;   break;
        case 'luv':    lab = rgb2lab(luv2rgb   (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    luv = rgb2luv(           col ); break;
        case 'hsv':    luv = rgb2luv(hsv2rgb   (col)); break;
        case 'hsl':    luv = rgb2luv(hsl2rgb   (col)); break;
        case 'hclokl': luv = rgb2luv(hclokl2rgb(col)); break;
        case 'hcllab': luv = rgb2luv(hcllab2rgb(col)); break;
        case 'hclluv': luv =         hclluv2luv(col);  break;
        case 'oklab':  luv = rgb2luv(oklab2rgb (col)); break;
        case 'lab':    luv = rgb2luv(lab2rgb   (col)); break;
        case 'luv':    luv =                    col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclokl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hclokl(           col);  break;
        case 'hsv':    hcl = rgb2hclokl(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclokl(hsl2rgb   (col)); break;
        case 'hclokl': hcl =                       col;   break;
        case 'hcllab': hcl = rgb2hclokl(hcllab2rgb(col)); break;
        case 'hclluv': hcl = rgb2hclokl(hclluv2rgb(col)); break;
        case 'oklab':  hcl = rgb2hclokl(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclokl(lab2rgb   (col)); break;
        case 'luv':    hcl = rgb2hclokl(luv2rgb   (col)); break;
    }

    return [
       'hclokl',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcllab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hcllab(           col) ; break;
        case 'hsv':    hcl = rgb2hcllab(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hcllab(hsl2rgb   (col)); break;
        case 'hclokl': hcl = rgb2hcllab(hclokl2rgb(col)); break;
        case 'hcllab': hcl =                       col;   break;
        case 'hclluv': hcl = rgb2hcllab(hclluv2rgb(col)); break;
        case 'oklab':  hcl = rgb2hcllab(oklab2rgb (col)); break;
        case 'lab':    hcl = lab2hcllab(           col ); break;
        case 'luv':    hcl = rgb2hcllab(luv2rgb   (col)); break;
    }

    return [
       'hcllab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hclluv(           col ); break;
        case 'hsv':    hcl = rgb2hclluv(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclluv(hsl2rgb   (col)); break;
        case 'hcllab': hcl = rgb2hclluv(hcllab2rgb(col)); break;
        case 'hclluv': hcl =                       col;   break;
        case 'hclokl': hcl = rgb2hclluv(hclokl2rgb(col)); break;
        case 'oklab':  hcl = rgb2hclluv(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclluv(lab2rgb   (col)); break;
        case 'luv':    hcl = luv2hclluv(           col ); break;
    }

    return [
       'hclluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


function validateColor(color, order, margin1, margin2, margin3)
{
    let i1, i2, i3;
    
         if (order == 0) { i1 = 0; i2 = 1; i3 = 2; } // HCL
    else if (order == 1) { i1 = 1; i2 = 0; i3 = 2; } // CHL
    else if (order == 2) { i1 = 1; i2 = 2; i3 = 0; } // CLH
    else if (order == 3) { i1 = 0; i2 = 2; i3 = 1; } // HLC
    else if (order == 4) { i1 = 2; i2 = 0; i3 = 1; } // LHC
    else if (order == 5) { i1 = 2; i2 = 1; i3 = 0; } // LCH
 
                                           color = validateChannel(color, i1, margin1);
    if (!isRgbValid(dataColor2rgb(color))) color = validateChannel(color, i2, margin2);
    if (!isRgbValid(dataColor2rgb(color))) color = validateChannel(color, i3, margin3);

    return color;
}



function validateChannel(color, iChan, margin)
{
    const factor = getColorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = isRgbValid(dataColor2rgb(color));
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c -= d;  _valid = isColorValid(_c, iChan, savedColor);
        c_ += d;  valid_ = isColorValid(c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = isRgbValid(dataColor2rgb(color));
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorValid(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = isRgbValid(dataColor2rgb(color));
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorValid(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorValid(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return isRgbValid(dataColor2rgb(color));
}



function getValidateMax(order)
{
    switch (order)
    {
        case 0: return [180, 100, 100]; // HCL
        case 1: return [100, 180, 100]; // CHL
        case 2: return [100, 100, 180]; // CLH
        case 3: return [180, 100, 100]; // HLC
        case 4: return [100, 180, 100]; // LHC
        case 5: return [100, 100, 180]; // LCH
    }

    // should never get here
    return [0, 0, 0];
}


var validateIsFinding = false;



class OpValidateColor_Correction
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    locked;

    constructor(name, max, value = 0, locked = false)
    {
        this.name   = name;
        this.max    = max;
        this.value  = value;
        this.locked = locked;
    }
}



class   OpValidateColor
extends OpColorBase
{
    paramOrder;

    param1;
    param2;
    param3;

    btnFind;


    findBar;
    findProgress;


    corrections = [];



    constructor()
    {
        super('validatecolor', 'validate', 'color', 80);


        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));


        this.alwaysLoadParams = true;


        this.addParam(this.paramOrder = new SelectParam('order', '', false, true, true, [
            'H,&thinsp;C,&thinsp;L', 
            'C,&thinsp;H,&thinsp;L', 
            'C,&thinsp;L,&thinsp;H', 
            'H,&thinsp;L,&thinsp;C', 
            'L,&thinsp;H,&thinsp;C', 
            'L,&thinsp;C,&thinsp;H' 
        ], 2));

        this.paramOrder.addEventListener('change', () => this.updateCorrections());


        this.addParam(this.param1 = new NumberParam('margin1', '', true, true, true, 0));
        this.addParam(this.param2 = new NumberParam('margin2', '', true, true, true, 0));
        this.addParam(this.param3 = new NumberParam('margin3', '', true, true, true, 0));

        this.param1.showParamLock = true;
        this.param2.showParamLock = true;
        this.param3.showParamLock = true;


        this.param1.addEventListener('change', () => 
        {
            const [i1,,] = getCorrectionOrder(this.paramOrder.value);
            this.corrections[i1].value = this.param1.value;
            uiSaveNodesAndConns([this.id]);
        });

        this.param1.addEventListener('changelock', () => 
        {
            const [i1,,] = getCorrectionOrder(this.paramOrder.value);
            this.corrections[i1].locked = this.param1.locked;
            actionManager.do(new SetParamLockAction(this.params[1+i1], this.param1.locked));
        });


        this.param2.addEventListener('change', () => 
        {
            const [, i2,] = getCorrectionOrder(this.paramOrder.value);
            this.corrections[i2].value = this.param2.value;
            uiSaveNodesAndConns([this.id]);
        });

        this.param2.addEventListener('changelock', () => 
        {
            const [, i2,] = getCorrectionOrder(this.paramOrder.value);
            this.corrections[i2].locked = this.param2.locked;
            actionManager.do(new SetParamLockAction(this.params[1+i2], this.param2.locked));
        });


        this.param3.addEventListener('change', () => 
        {
            const [,, i3] = getCorrectionOrder(this.paramOrder.value);
            this.corrections[i3].value = this.param3.value;
            uiSaveNodesAndConns([this.id]);
        });

        this.param3.addEventListener('changelock', () => 
        {
            const [,, i3] = getCorrectionOrder(this.paramOrder.value);
            this.corrections[i3].locked = this.param3.locked;
            actionManager.do(new SetParamLockAction(this.params[1+i3], this.param3.locked));
        });


        this.initCorrections();
        this.updateCorrections();


        this.header.connectionPadding = 18;


        this.btnFind = createDiv('findColorCorrection');
        this.header.appendChild(this.btnFind);


        this.btnFind.addEventListener('pointerenter', () => { this.btnFind.over = true;  this.updateHeaderLabel(); });
        this.btnFind.addEventListener('pointerleave', () => { this.btnFind.over = false; this.updateHeaderLabel(); });


        this.btnFind.addEventListener('pointerdown', e => 
        { 
            if (e.button == 0) 
            {
                this.btnFind.button0 = true;  
                this.updateHeaderLabel(); 
            }
        });

        
        this.header.addEventListener('pointerup', e => 
        { 
            if (   e.button == 0
                && this.btnFind.button0
                && !validateIsFinding
                && this.inputs[0].isConnected) 
            { 
                this.btnFind.button0 = false;

                this.btnFind     .style.display = 'none';
                this.findBar     .style.display = 'block';
                this.findProgress.style.width   = 0;
                
                validateIsFinding = true;

                uiPostMessageToGenerator(
                {
                    msg:       'genFindCorrection',
                    nodeId:     this.id,
                    inputColor: this.inputs[0].data.color,
                    param1:     this.param1.value,
                    param2:     this.param2.value,
                    param3:     this.param3.value,
                    locked1:    this.param1.locked,
                    locked2:    this.param2.locked,
                    locked3:    this.param3.locked
                });
            }
        });


        this.createProgressBar();
    }



    createProgressBar()
    {
        this.findBar      = createDiv('findBar');
        this.findProgress = createDiv('findProgress');

        this.findBar.appendChild(this.findProgress);
        this.header .appendChild(this.findBar);
    }



    initCorrections()
    {
        this.corrections.push(new OpValidateColor_Correction('H', 180));
        this.corrections.push(new OpValidateColor_Correction('C', 100));
        this.corrections.push(new OpValidateColor_Correction('L', 100));
    }



    updateCorrections()
    {
        const [i1, i2, i3] = getCorrectionOrder(this.paramOrder.value);

        this.updateMargin(this.param1, this.corrections[i1]);
        this.updateMargin(this.param2, this.corrections[i2]);
        this.updateMargin(this.param3, this.corrections[i3]);
    }



    updateData()
    {
        //log(this.id + '.OpValidColor.updateData()');

        if (this.inputs[0].isConnected)
        {
            this._color = [...validateColor(
                [...this.inputs[0].data.color],
                this.paramOrder.value, 
                this.param1.value,
                this.param2.value,
                this.param3.value)];
        }
        else
            this._color = dataColor_NaN;

            
        this.outputs[0]._data = dataFromDataColor(this._color);


        super.updateData()
    }



    updateMargin(margin, correction)
    {
        margin.setName(correction.name, false);
        margin.control.name = addValidateSymbol(correction.name);

        margin.control.setMin(0,              false);
        margin.control.setMax(correction.max, false);

        margin.locked = correction.locked;
        margin.updateLock();

        if (!margin.locked)
        {
            margin.control.setDecimals(Math.min(getDecimalCount(getNumberString(correction.value, -1))));
            margin.setValue(correction.value, true, true, false);
        }
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();

        this.label  .style.top = '40%';
        this.btnFind.style.top = '67%';

        const [,,,, textColor,] = this.getHeaderColors();

        const textStyle = colorStyleRgb_a(
            textColor, 
            this.btnFind.over
            ? Math.min(textColor[3] * 1.8, 1) 
            : textColor[3]);

        this.btnFind.style.background         = 'url(\'data:image/svg+xml;utf8,<svg width="10" height="10" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.10345 5.05172C8.10345 7.01329 6.51329 8.60345 4.55172 8.60345C2.59016 8.60345 1 7.01329 1 5.05172C1 3.09016 2.59016 1.5 4.55172 1.5C6.51329 1.5 8.10345 3.09016 8.10345 5.05172ZM7.39723 8.60458C6.61787 9.22958 5.62846 9.60345 4.55172 9.60345C2.03788 9.60345 0 7.56557 0 5.05172C0 2.53788 2.03788 0.5 4.55172 0.5C7.06557 0.5 9.10345 2.53788 9.10345 5.05172C9.10345 6.12858 8.72949 7.1181 8.10436 7.8975L11.3535 11.1467L10.6464 11.8538L7.39723 8.60458Z" fill="'+textStyle+'" fill-opacity="0.8"/></svg>\')';
        this.btnFind.style.backgroundPosition = '50% 50%';
        this.btnFind.style.backgroundRepeat   = 'no-repeat';


        const findStyle = colorStyleRgb_a(textColor, 0.35);

        this.findBar     .style.outline    = '1px solid ' + findStyle;
        this.findProgress.style.background = findStyle;
    }



    canShowColor()
    {
        return this.inputs[0].isConnected;
    }



    isConnected()
    {
        return this.inputs[0].isConnected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        const [i1, i2, i3] = getCorrectionOrder(this.paramOrder.value);

        return super.toJsonBase(nTab)
            + ',\n' + pos + tab + '"locked1": "' + boolString(this.corrections[i1].locked) + '"'
            + ',\n' + pos + tab + '"locked2": "' + boolString(this.corrections[i2].locked) + '"'
            + ',\n' + pos + tab + '"locked3": "' + boolString(this.corrections[i3].locked) + '"';
    }



    loadParams(_node)
    {
        super.loadParams(_node);

        const [i1, i2, i3] = getCorrectionOrder(this.paramOrder.value);

        if (_node.locked1) this.corrections[i1].locked = isTrue(_node.locked1);
        if (_node.locked2) this.corrections[i2].locked = isTrue(_node.locked2);
        if (_node.locked3) this.corrections[i3].locked = isTrue(_node.locked3);

        this.updateCorrections();

        super.loadParams(_node); // must be done again after the locks have been set
    }
}



function uiUpdateFindCorrectionProgress(nodeId, progress)
{
    const node = nodeFromId(nodeId);

    node.findProgress.style.width = (progress * 100) + '%';
}



function uiEndFindCorrection(nodeId, success, closestOrder, closest1, closest2, closest3)
{
    const node = nodeFromId(nodeId);

    if (success)
    {
        node.paramOrder.setValue(closestOrder, true, true, false);

        const [i1, i2, i3] = getCorrectionOrder(closestOrder);

        node.corrections[i1].value = closest1;
        node.corrections[i2].value = closest2;
        node.corrections[i3].value = closest3;

        node.updateCorrections();
    }

    validateIsFinding = false;

    node.findBar.style.display = 'none';
    node.btnFind.style.display = 'block';

    node.pushUpdate();

    uiSaveNodesAndConns([nodeId]);
}



function getCorrectionOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }
}



function addValidateSymbol(name)
{
    return /*'<span class="asterisk">±&thinsp;</span>' + */name;
}


class   OpWebContrast
extends OpColorBase
{
    #paramValue;
    #paramStandard;



    constructor()
    {
        super('webcontrast', 'contrast', 'color', 80);


        this.addInput(new Input(this.dataType));
        this.addInput(new Input(this.dataType));


        this.addParam(this.#paramStandard = new SelectParam('standard', '', false, true,  true, ['WCAG 2', 'WCAG 3'], 1));
        this.addParam(this.#paramValue    = new NumberParam('value',    '', false, false, true, 0, 0));
      

        enableSliderText(this.#paramValue.control, false);


        createTooltip(ttWcag2);
        createTooltip(ttWcag3);

        createTooltipSrc(
            this.#paramValue.control, 
            () => this.#paramStandard.value == 1 ? ttWcag3 : ttWcag2);


            this.header.connectionPadding = 12.5;
    }



    getShowTooltip()
    {
        return this.#paramStandard.value == 1
               ? ttWcag3
               : ttWcag2;
    }



    updateData()
    {
        //log(this.id + '.OpWebContrast.updateData()');

        
        this._color = 
            this.inputs[1].isConnected
            ? this.inputs[1].data.color
            : dataColor_NaN;


        if (   this.inputs[0].isConnected
            && this.inputs[1].isConnected)
        {
            const rgb0 = dataColor2rgb(this.inputs[0].data.color);
            const rgb1 = dataColor2rgb(this.inputs[1].data.color);
            
            if (   isRgbValid(rgb0) && this.inputs[0].data.isValid
                && isRgbValid(rgb1) && this.inputs[1].data.isValid)
            {
                if (this.#paramStandard.value == 0)
                {
                    const ratio = getContrastRatio2(
                        dataColor2rgb(this.inputs[0].data.color),
                        dataColor2rgb(this.inputs[1].data.color));

                    let rating = getContrastRating2(ratio);

                    if (rating != '')
                        rating = '&nbsp;&nbsp;' + rating;

                    this.#paramValue.control.min        = 
                    this.#paramValue.control.displayMin = 0;

                    this.#paramValue.control.max        = 
                    this.#paramValue.control.displayMax = 21;

                    this.#paramValue.control.setDecimals(2);
                    this.#paramValue.control.setSuffix(rating);
                    this.#paramValue.control.setValue(ratio, false, false, false);
                }
                else
                {
                    const ratio = getContrastRatio3(
                        dataColor2rgb(this.inputs[0].data.color),
                        dataColor2rgb(this.inputs[1].data.color));
                        
                    this.#paramValue.control.min        = 
                    this.#paramValue.control.displayMin = 0;

                    this.#paramValue.control.max        = 
                    this.#paramValue.control.displayMax = 105;

                    this.#paramValue.control.setDecimals(1);
                    this.#paramValue.control.setSuffix('<span style="font-size: 5; position: relative; top: -7px; left: 2px;">L</span><span style="font-size: 3; font-weight: bold; position: relative; top: -9px; left: 2px;">c</span>');
                    this.#paramValue.control.setValue(Math.abs(ratio), false, false, false);
                }


                this.forceShowWarning = false;

                super.updateData();
                return;
            }

            else if ((!isRgbValid(rgb0) || !this.inputs[0].data.isValid)
                   &&  isRgbValid(rgb1) &&  this.inputs[1].data.isValid)
            {
                this.warningStyle     = colorStyleRgb_a(invalid2validRgb(rgb0), 0.3);
                this.forceShowWarning = true;
            }
            
            else if (  isRgbValid(rgb0) &&  this.inputs[0].data.isValid
                  && (!isRgbValid(rgb1) || !this.inputs[1].data.isValid))
            {
                this.warningStyle     = this.getDefaultWarningStyle(rgb1);
                this.forceShowWarning = true;
            }

            else
                this.forceShowWarning = false;
        }

        else if (this.inputs[1].isConnected)
        {
            const rgb1 = dataColor2rgb(this.inputs[1].data.color);
            
            this.forceShowWarning = 
                   !isRgbValid(rgb1) 
                || !this.inputs[1].data.isValid;
        }


        this.#paramValue.setValue(Number.NaN, false, true, false);

        
        super.updateData();
    }



    updateNode()
    {
        this.setRanges();
        
        super.updateNode();
    }



    setRanges()
    {
        if (this.#paramStandard.value == 0)
            this.#paramValue.control.ranges = [
                new NumberSliderRange(0  /21,  3  /21, 'rgba(255, 112,  0, 0.1)', 0.8),
                new NumberSliderRange(3  /21,  4.5/21, 'rgba(255, 255,  0, 0.2)', 0.8),
                new NumberSliderRange(4.5/21,  7  /21, 'rgba(64,  255, 64, 0.2)', 0.8),
                new NumberSliderRange(7  /21, 21  /21, 'transparent') ];

        else
            this.#paramValue.control.ranges = [
                new NumberSliderRange( 0/105,  15/105, 'rgba(255,   0,  64, 0.2 )', 0.8),
                new NumberSliderRange(15/105,  30/105, 'rgba(255, 112,   0, 0.2 )', 0.8),
                new NumberSliderRange(30/105,  45/105, 'rgba(255, 185,   0, 0.2 )', 0.8),
                new NumberSliderRange(45/105,  60/105, 'rgba(255, 255,   0, 0.2 )', 0.8),
                new NumberSliderRange(60/105,  75/105, 'rgba(64,  255,  64, 0.2 )', 0.8),
                new NumberSliderRange(75/105,  90/105, 'rgba(0,     0, 255, 0.07)', 0.8),
                new NumberSliderRange(90/105, 105/105, 'transparent') ];

        this.#paramValue.control.update();
    }



    canShowColor()
    {
        return this.inputs[1].isConnected;
    }



    updateHeaderLabel()
    {
        if (   this.inputs[0].isConnected 
            && this.inputs[1].isConnected)
            this.label.style.color = colorStyleRgb(dataColor2rgb(this.inputs[0].data.color));
        else if (this.inputs[1].isConnected)
        {
            const [,,,, colText,] = this.getHeaderColors();
            this.label.style.color = colorStyleRgba(colText);
        }
        else 
            this.label.style.color = 'black';
    }
}


class   OpColorInterpolate
extends OpColorBase
{
    #paramSpace;
    #paramAmount;



    constructor()
    {
        super('colorinterpolate', 'inter', 'color', 80);

        
        this.addInput(new Input(this.dataType));
        this.addInput(new Input(this.dataType));

        this.addOutput(new Output(this.dataType));


        this.addParam(this.#paramSpace  = new SelectParam('space',  '',  false, true, true, OpColorSpaces.map(s => s[1]), 1));
        this.addParam(this.#paramAmount = new NumberParam('amount', '',  true,  true, true, 50, 0, 100, 0));
      
        
        this.#paramSpace.control.min         = 1;
        this.#paramSpace.control.displayMin  = 1;
        this.#paramSpace.control.update();
        
        this.#paramAmount.control.min        = Number.MIN_SAFE_INTEGER; // allow
        this.#paramAmount.control.max        = Number.MAX_SAFE_INTEGER; // extrapolation

        this.#paramAmount.control.setSuffix('%', true);
        

        this.header.connectionPadding = 12.5;


        this.inputs[0].addEventListener('connect', () => 
        {
            if (   !this.inputs[1].isConnected
                && !graphView.loadingNodes) 
                this.#paramSpace.setValue(
                    colorSpaceIndex(this.inputs[0].data.color[0]),
                    true, true, false);
        });


        this.inputs[1].addEventListener('connect', () => 
        {
            if (   !this.inputs[0].isConnected
                && !graphView.loadingNodes) 
                this.#paramSpace.setValue(
                    colorSpaceIndex(this.inputs[1].data.color[0]),
                    true, true, false);
        });


        this.#paramSpace.control.addEventListener('change', () => hideTooltip(ttInterpolationSpace));


        createTooltip(ttInterpolationSpace);
        createTooltipSrc(this.#paramSpace.control, () => ttInterpolationSpace);
    }



    updateData()
    {
        //log(this.id + '.OpColorInterpolate.updateData()');

        if (   this.inputs[0].isConnected
            && this.inputs[1].isConnected)
        {
            const space = colorSpace(this.#paramSpace.value);
            const f     = this.#paramAmount.value / 100;
            
            const col = this.interpolate(
                space,
                dataColor2array(convertDataColorToSpace(this.inputs[0].data.color, space)),
                dataColor2array(convertDataColorToSpace(this.inputs[1].data.color, space)),
                f);

            this._color = [
                space, 
                col[0], 
                col[1], 
                col[2] ];
        }

        else if(this.inputs[0].isConnected) this._color = this.inputs[0].data.color;
        else if(this.inputs[1].isConnected) this._color = this.inputs[1].data.color;
        else                                this._color = dataColor_NaN;

        this.outputs[0]._data = dataFromDataColor(this._color);


        super.updateData()
    }



    interpolate(space, col0, col1, f)
    {
        const iSpace = colorSpaceIndex(space);

        if (iSpace <= 1) // hex, rgb
        {
            return rgbAdd(col0, rgbMuls(rgbSub(col1, col0), f));
        }
        else // hsv, hsl, hcl
        {
            const h0 = col0[0] * Tau;
            const h1 = col1[0] * Tau;
            
            return [
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(col0[1], col1[1], f),
                lerp(col0[2], col1[2], f) ];
        }
    }



    canShowColor()
    {
        return this.inputs[0].isConnected
            || this.inputs[1].isConnected;
    }
}


class   OpColorblind
extends OpColorBase
{
    #paramL;
    #paramM;
    #paramS;



    constructor()
    {
        super('colorblind', 'colorblind', 'color', 80);


        this.addInput (new  Input(this.dataType));
        this.addOutput(new Output(this.dataType));


        this.addParam(this.#paramL = new NumberParam('l', 'L', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.#paramM = new NumberParam('m', 'M', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.#paramS = new NumberParam('s', 'S', false, true, true, 2, 0, 2, 0, 0.02));

        this.#paramL.addEventListener('change', () => this.#paramL.control.dragScale = getDecimalCount(getNumberString(this.#paramL.value, this.#paramL.control.displayDec)) == 0 ? 0.02 : 0.05);
        this.#paramM.addEventListener('change', () => this.#paramM.control.dragScale = getDecimalCount(getNumberString(this.#paramM.value, this.#paramM.control.displayDec)) == 0 ? 0.02 : 0.05);
        this.#paramS.addEventListener('change', () => this.#paramS.control.dragScale = getDecimalCount(getNumberString(this.#paramS.value, this.#paramS.control.displayDec)) == 0 ? 0.02 : 0.05);


        this.header.connectionPadding = 18;
    }



    updateData()
    {
        super.updateData()


        let valid = true;
        
        if (this.inputs[0].isConnected)
        {
            const rgb      = dataColor2rgb(this.inputs[0].data.color);
            const validRgb = invalid2validRgb(rgb);
            
            const cb = rgb2colorblind(
                validRgb,
                this.#paramL.value / 2,
                this.#paramM.value / 2,
                this.#paramS.value / 2);

            const validCb = invalid2validRgb(cb);

            this._color = rgb2dataColor(validCb);


            if (!isRgbValid(rgb))
            {
                this.warningStyle = this.getDefaultWarningStyle(validRgb);
                valid             = false;
            }

            this.forceShowWarning = 
                   this.inputs[0].isConnected
                && !isRgbValid(rgb);        
        }
        else 
        {
            this._color = dataColor_NaN;
            this.forceShowWarning = false;

            valid = false;
        }
                

        this.outputs[0]._data = dataFromDataColor(this._color);

        if (  !valid
            || this.forceShowWarning) 
            this.outputs[0]._data.isValid = false;
    }



    updateParams(dispatchEvents)
    {
        super.updateParams(dispatchEvents);

        this.setParamText(this.#paramL, 'L');
        this.setParamText(this.#paramM, 'M');
        this.setParamText(this.#paramS, 'S');
    }



    setParamText(param, cone)
    {
        const v = Math.round(param.value);

             if (v == 2) param.control.valueText = cone;
        else if (v == 1) param.control.valueText = cone + ' weak';
        else             param.control.valueText = cone + ' blind';
    }



    canShowColor()
    {
        return this.inputs[0].isConnected;
    }
}


class   OpRectangle
extends OperatorBase
{
    #paramX;
    #paramY;
    #paramWidth;
    #paramHeight;
    #paramAngle;
    #paramRound;
    //#paramColor;

    #btnProportional;

    #refWidth  = Number.NaN;
    #refHeight = Number.NaN;


    
    constructor()
    {
        super('rectangle', 'rect', 'object');

        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.#paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.#paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.#paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.#paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        this.addParam(this.#paramRound  = new NumberParam('round',  'round',  true, true, true,   0,    0));
        

        this.#paramAngle.control.setSuffix('°', true);

        
        this.updateRound();

        this.#btnProportional = createToggleButton(12, 12);
        this.inner.appendChild(this.#btnProportional);


        this.inputs[0].addEventListener('connect', () =>
        {
            for (const param of this.params)
                enableSliderText(param.control, false);
        });


        this.inputs[0].addEventListener('disconnect', () =>
        {
            for (const param of this.params)
                if (!param.input.isConnected) 
                    enableSliderText(param.control, true);
        });


        this.#btnProportional.addEventListener('click', () =>
        {
            if (this.#btnProportional.enabled)
            {
                this.#refWidth  = this.#paramWidth .value;
                this.#refHeight = this.#paramHeight.value;
            }
        });


        this.#paramWidth.addEventListener('change', () =>
        {
            if (this.#btnProportional.enabled)
                this.#paramHeight.setValue(this.#paramWidth.value * this.#refHeight / this.#refWidth, false, true, false);
        });


        this.#paramHeight.addEventListener('change', () =>
        {
            if (this.#btnProportional.enabled)
                this.#paramWidth.setValue(this.#paramHeight.value * this.#refWidth / this.#refHeight, false, true, false);
        });
    }
    
    
    
    updateRound()
    {
        const min = Math.min(this.#paramWidth.value, this.#paramHeight.value);
        this.setRoundMinMax(0, min/2);
    }

    

    setRoundMinMax(min, max)
    {
        const control = this.#paramRound.control;

        control.min   = min;
        control.max   = max;

        this.#paramRound.control.update();
    }



    updateData()
    {
        if (this.inputs[0].isConnected) 
        {
            const data = this.inputs[0].data;

            this.#paramX     .setValue(this.#paramX     .input.isConnected ? this.#paramX     .input.data.value : data.x,      false, true, false);
            this.#paramY     .setValue(this.#paramY     .input.isConnected ? this.#paramY     .input.data.value : data.y,      false, true, false);
            this.#paramWidth .setValue(this.#paramWidth .input.isConnected ? this.#paramWidth .input.data.value : data.width,  false, true, false);
            this.#paramHeight.setValue(this.#paramHeight.input.isConnected ? this.#paramHeight.input.data.value : data.height, false, true, false);
            this.#paramAngle .setValue(this.#paramAngle .input.isConnected ? this.#paramAngle .input.data.value : data.angle,  false, true, false);
            this.#paramRound .setValue(this.#paramRound .input.isConnected ? this.#paramRound .input.data.value : data.round,  false, true, false);
        }

    
        this.outputs[0]._data = dataFromRectangle(
            this.#paramX     .value,
            this.#paramY     .value,
            this.#paramWidth .value,
            this.#paramHeight.value,
            this.#paramAngle .value,
            this.#paramRound .value);


        super.updateData()
    }



    makeGenRequest()
    {
        return [
            this.opType,
            this.id,
            this.#paramX     .value,
            this.#paramY     .value,
            this.#paramWidth .value,
            this.#paramHeight.value,
            this.#paramAngle .value,
            this.#paramRound .value ];
    }



    updateNode()
    {
        this.#btnProportional.style.left = 45;
        this.#btnProportional.style.top  = 79;

        super.updateNode();
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        let json = super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"proportional": "' + boolString(this.#btnProportional.enabled) + '"';

        if (this.#btnProportional.enabled)
        {
            json +=
                  ',\n' + pos + tab + '"refWidth": "'  + this.#refWidth  + '"'
                + ',\n' + pos + tab + '"refHeight": "' + this.#refHeight + '"';
        }

        return json;
    }



    loadParams(_node)
    {
        super.loadParams(_node);

        // if (_node.proportional)
        // {
            this.#btnProportional.enabled = isTrue(_node.proportional);
            this.#btnProportional.updateBackground(false);

            if (this.#btnProportional.enabled)
            {
                this.#refWidth  = parseFloat(_node.refWidth);
                this.#refHeight = parseFloat(_node.refHeight);
            }
        //}
    }
}


class   OpRow
extends OperatorBase
{
    #count;
    #gap;


    constructor()
    {
        super('row', 'row', 'object');

        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));
        
        this.addParam(this.#count = new NumberParam('count', 'count', true, true, true,  7, 1));
        this.addParam(this.#gap   = new NumberParam('gap',   'gap',   true, true, true, 10, 0));
    }
}




// class   OpRow
// extends Operator
// {
//     #count;
//     #gap;


//     constructor()
//     {
//         super('row', 'object');

//         this.addInput (new Input (this.dataType));
//         this.addOutput(new Output(this.dataType));
        
//         this.addParam(this.#count = new NumberParam('count', 'count',  4, 1));
//         this.addParam(this.#gap   = new NumberParam('gap',   'gap',   10, 0));
//     }


//     updateData()
//     {
//         const input  = this.inputs[0];
//         const output = this.output;

//         if (!input.isConnected)
//         {
//             output._data = {};
//             return;
//         }

    
//         const objects = input.data;
//         const bounds = getObjectBounds(objects);


//         output._data = [];
    
//         for (var i = 0, x = 0; i < this.#count.value; i++)
//         {
//             for (var j = 0; j < objects.length; j++)
//             {
//                 const obj = shallowCopy(objects[j]);
//                 obj.itemId = 'row_' + i + '_' + j;
   
//                 obj.x += x;
                
//                 output._data.push(obj);
//             }
            
//             x += bounds.w + this.#gap.value;
//         }

        
//         super.updateData();
//     }
// }


class Action
{
    manager;
 
    id;
    name;
  
    prevAction; // these are used to link actions into sequences
    nextAction; 
  
    data;
  
    onBefore;
    onAfter;

    onBeforeUndo;
    onAfterUndo;

    
    _linkWithNext = false;


    constructor(name)
    {
        this.name = name;

        console.assert(
               this.name != undefined
            && this.name != null
            && this.name != '');
    }



    do() {}



    redo()
    {
        this.do();
    }



    undo() {}
};



function linkActions(prevAction, action)
{
    prevAction.nextAction = action;
    action    .prevAction = prevAction;
}


class ActionManager
{
    actions      = [];
    redoActions  = [];
    
    nextActionId = 0;
   
    
    
    do(action, linkWithPrevious = false, linkWithNext = false)
    {
        // this is a fresh new action so any 
        // old redo queue is no longer relevant
        this.redoActions = [];

        this.actions.push(action);

        action.id            = this.nextActionId++;
        action.manager       = this;
        action._linkWithNext = linkWithNext;

        if (this.actions.length > 1)
        {
            const before = beforeLastOf(this.actions);
            const last   = lastOf      (this.actions);

            if (   linkWithPrevious
                || before._linkWithNext)
            {
                linkActions(before, last);
                before._linkWithNext = false;
            }
        }

        action.do(); 
        log("DO " + action.name);
    }



    undo()
    {
        if (this.actions.length == 0)
            return;

        for (;;)
        {
            let last = removeLast(this.actions);
            this.redoActions.push(last);

            last.undo(); 
            log("UNDO " + last.name);

            if (   this.actions.length == 0
                || last.prevAction != lastOf(this.actions))
                break;
        }
    }



    redo()
    {
        if (this.redoActions.length == 0)
            return;

        for (;;)
        {
            let last = removeLast(this.redoActions);
            this.actions.push(last);

            last.redo(); 
            log("REDO " + last.name);
        
            if (   this.redoActions.length == 0
                || last.nextAction != lastOf(this.redoActions))
                break;
        }
    }
}



const actionManager = new ActionManager();


class ConnectAction
extends Action
{
    outputOpId;
    outputIndex;
    get outputOp() { return nodeFromId(this.outputOpId); }
    
    oldOutputOpId = '';
    oldOutputIndex;
    get oldOutputOp() { return nodeFromId(this.oldOutputOpId); }
    
    inputOpId;
    inputIndex;
    get inputOp() { return nodeFromId(this.inputOpId); }
    
    oldOutputActiveOpId;      // the active node in the output node's tree
    oldInputActiveOpIds = []; // the active nodes in the input node's tree

    newActiveOpIds = [];



    constructor(output, input)
    {
        const outIndex = output.op.outputs.indexOf(output);
        const  inIndex = input.op.inputs.indexOf(input); 

        const oldOutIndex = 
            input.isConnected 
            ? input.connectedOutput.op.outputs.indexOf(input.connectedOutput) 
            : -1; 

        super('connect ' 
            + output.op.id + '.out[' + outIndex + ']'
            + ' -> '
            + input.op.id + '.in[' + inIndex + ']');


        this.outputOpId          = output.op.id;
        this.outputIndex         = outIndex;
   
        this.oldOutputOpId       = input.isConnected ? input.connectedOutput.op.id : '';
        this.oldOutputIndex      = oldOutIndex;
   
        this.inputOpId           = input.op.id;
        this.inputIndex          = inIndex;

        this.oldOutputActiveOpId = getActiveNodeInTreeFrom(nodeFromId(this.outputOpId)).id;
        this.oldInputActiveOpIds = [...getActiveNodesInTreeFrom(nodeFromId(this.inputOpId)).map(n => n.id)];
    }


    
    do()
    {
        this.newActiveOpIds = [];

        if (    this.oldOutputOp
            && !getActiveNodeInTreeFrom(this.oldOutputOp))
        {
            uiMakeNodeActive(this.oldOutputOp);
            this.newActiveOpIds.push(this.oldOutputOpId);
            this.oldOutputOp.pushUpdate();
            //graphView.updateNodeTransform(oldPrevOutputActiveOp);
        }


        uiConnect(
            this.outputOp.outputs[this.outputIndex], 
            this.inputOp. inputs [this. inputIndex],
            this.inputIndex);


        let oldInputActiveOpIds = [...this.oldInputActiveOpIds];
        oldInputActiveOpIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).follows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldInputActiveOpIds)
            uiMakeNodeActive(nodeFromId(id));


        graphView.updateNodeTransform(this.inputOp);
        this.inputOp.pushUpdate();
    }



    undo()
    {
        uiDisconnect(this.inputOp.inputs[this.inputIndex]);


        if (this.oldOutputOpId != '')
        {
            uiVariableConnect(
                this.oldOutputOp, 
                this.oldOutputIndex, 
                this.inputOp, 
                this.inputIndex);
        }

        graphView.updateNodeTransform(this.inputOp);
        this.inputOp.pushUpdate();


        for (const id of this.newActiveOpIds)
            uiMakeNodePassive(nodeFromId(id));

        for (const id of this.oldInputActiveOpIds)
            uiMakeNodeActive(nodeFromId(id));

        if (!this.oldInputActiveOpIds.includes(this.oldOutputActiveOpId))
            uiMakeNodeActive(nodeFromId(this.oldOutputActiveOpId));
    }
}


class CreateNodeAction
extends Action
{
    opType;
    createdNodeId;

    prevSelectedIds = []; // currently selected nodes that are deselected as a result of creation

    creatingButton;
    


    constructor(opType, creatingButton)
    {
        super('create node \'' + opType + '\'');
        
        this.opType         = opType;
        this.creatingButton = creatingButton;
    }



    do()
    {
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);

        const node = uiCreateNode(this.opType, this.creatingButton);
        this.createdNodeId = node.id;

        graphView.updateNodeTransform(node);
        setTimeout(() => graphView.updateScrollWithBounds());
        
        uiMakeNodeActive(node);
        node.pushUpdate();
    }



    undo()
    {
        uiDeleteNodes([this.createdNodeId]);

        graphView.selectByIds(this.prevSelectedIds);
    }



    redo()
    {
        const node = uiCreateNode(this.opType, this.creatingButton, this.createdNodeId);

        graphView.updateNodeTransform(node);
        setTimeout(() => graphView.updateScrollWithBounds());

        uiMakeNodeActive(node);
        node.pushUpdate();
    }
}


class DeleteNodesAction
extends Action
{
    nodeIds          = [];
    prevSelectedIds  = [];
    
    nodes            = [];
    nodePos          = [];

    connections      = []; // [{outputOpId, outputIndex, inputOpId, inputIndex}]

    newActiveOpIds   = [];
    oldActiveOpIds   = [];



    constructor(nodeIds)
    {
        super('delete ' + nodeIds.length + ' node' + (nodeIds.length == 1 ? '' : 's'));

        this.nodeIds         = [...nodeIds]; // clone the array
        this.nodes           = nodeIds.map(id => nodeFromId(id));
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);

        for (const nodeId of nodeIds)
        {
            const activeIds = getActiveNodesInTreeFrom(nodeFromId(nodeId)).map(n => n.id);

            for (const activeId of activeIds)
            {
                if (!this.oldActiveOpIds.includes(activeId))
                    this.oldActiveOpIds.push(activeId);
            }
        }
    }



    addConnection(conn)
    {
        const outputIndex = conn.output.op.outputs.indexOf(conn.output);
        const  inputIndex = conn.input .op. inputs.indexOf(conn. input);

        if (!this.connections.find(c => 
                   c.outputOpId  == conn.output.op.id
                && c.outputIndex == outputIndex
                && c.inputOpId   == conn.input.op.id
                && c.inputIndex  == inputIndex))
            this.connections.push(getConnectionForArrayWithIds(conn));
    }



    do()
    {
        for (const nodeId of this.nodeIds)
        {
            const node = nodeFromId(nodeId);

            this.nodePos.push(point(
                node.div.offsetLeft, 
                node.div.offsetTop));

            for (const input of node.inputs.filter(i => i.isConnected))
                this.addConnection(input.connection);

            for (const output of node.outputs)
                for (const input of output.connectedInputs)
                    this.addConnection(input.connection);
        }


        for (const nodeId of this.nodeIds)
        {
            const node = nodeFromId(nodeId);


            const nodeInputs = [...node.inputs.filter(i => i.isConnected)];

            for (const input of nodeInputs)
                this.disconnect(input);


            for (const output of node.outputs)
            {
                const connectedInputs = [...output.connectedInputs];

                for (const input of connectedInputs)
                    this.disconnect(input);
            }
        }


        console.log(this.newActiveOpIds);

        uiDeleteNodes(this.nodeIds, this.id);

        for (const nodeId of this.nodeIds)
            uiClearPageData(activeTag + ' ' + nodeId)
    }



    undo()
    {
        this.undeleteNodes();
        this.undeleteConnections();

        this.nodePos     = [];
        this.connections = [];

        graphView.selectByIds(this.prevSelectedIds);

        for (const id of this.newActiveOpIds)
            uiMakeNodePassive(nodeFromId(id));
        
        this.newActiveOpIds = [];

        
        let oldActiveOpIds = [...this.oldActiveOpIds];
        oldActiveOpIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).follows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldActiveOpIds)
            uiMakeNodeActive(nodeFromId(id));
    }



    undeleteNodes()
    {
        //log('this.nodes', this.nodes);

        graph.addNodes(this.nodes);
        graphView.selected = this.nodes;
        graphView.putNodeOnTop(lastOf(this.nodes));
    
        for (let i = 0; i < this.nodes.length; i++)
        {
            setNodePosition(
                this.nodes[i], 
                this.nodePos[i].x, 
                this.nodePos[i].y);
        }

        for (let i = 0; i < this.nodes.length; i++)
            this.nodes[i].id = this.nodeIds[i];

        
        for (const activeId of this.oldActiveOpIds)
            uiMakeNodeActive(nodeFromId(activeId));


        uiSaveNodesAndConns(this.nodeIds);
    }



    undeleteConnections()
    {
        const connections    = [...this.connections];
        const varConnections = [];
       
        
        // connections going into variable inputs must be treated separately
        for (let i = connections.length-1; i >= 0; i--)
        {
            if (nodeFromId(connections[i].inputOpId)._variableInputs)
            {
                varConnections.push(connections[i]);
                removeAt(connections, i);
            }
        }

        
        varConnections.sort((c1, c2) =>
        {
            if (c1.inputOpId  != c2.inputOpId ) return c1.inputOpId  - c2.inputOpId;
            if (c1.inputIndex != c2.inputIndex) return c1.inputIndex - c2.inputIndex;
            return 0;
        });
        
        
        this.connect(connections);
        this.connect(varConnections);
    }



    connect(connections)
    {
        for (const conn of connections)
        {
            const outputOp = nodeFromId(conn.outputOpId);
            const inputOp  = nodeFromId(conn. inputOpId);

            uiVariableConnect(outputOp, conn.outputIndex, inputOp, conn.inputIndex);
        }
    }



    disconnect(input)
    {
        const output = input.connectedOutput;
        
        uiDisconnect(input);


        const outputOp = output.op;
        const  inputOp =  input.op;


        if (getActiveNodesInTreeFrom(inputOp))
        {
            uiMakeNodeActive(inputOp);

            if (!this.newActiveOpIds.includes(inputOp.id))
                this.newActiveOpIds.push(inputOp.id);

            inputOp.pushUpdate();
            //graphView.updateNodeTransform(input.op);
        }


        if (!getActiveNodeInTreeFrom(outputOp))
        {
            uiMakeNodeActive(outputOp);

            if (!this.newActiveOpIds.includes(outputOp.id))
                this.newActiveOpIds.push(outputOp.id);

            outputOp.pushUpdate();
            //graphView.updateNodeTransform(output.op);
        }
    }
}


class DisconnectAction
extends Action
{
    outputOpId;
    outputIndex;
    get outputOp() { return nodeFromId(this.outputOpId); }

    inputOpId;
    inputIndex;
    get inputOp() { return nodeFromId(this.inputOpId); }

    oldActiveOpIds = [];
    newActiveOpIds = [];



    constructor(output, input)
    {
        const outputIndex = output.op.outputs.indexOf(output);
        const  inputIndex = input .op. inputs.indexOf( input); 


        super('disconnect ' 
            + output.op.id + '.outputs[' + outputIndex + ']'
            + ' -> '
            + input.op.id + '.inputs[' + inputIndex + ']');


        this.outputOpId  = output.op.id;
        this.outputIndex = outputIndex;

        this.inputOpId   = input.op.id;
        this.inputIndex  = inputIndex;


        this.oldActiveOpIds = [...getActiveNodesInTreeFrom(nodeFromId(this.inputOpId)).map(n => n.id)];
    }



    do()
    {
        uiDisconnect(this.inputOp.inputs[this.inputIndex]);
        
        if (!getActiveNodeInTreeFrom(this.inputOp))
        {
            uiMakeNodeActive(this.inputOp);
            this.newActiveOpIds.push(this.inputOpId);
            this.inputOp.pushUpdate();
            //graphView.updateNodeTransform(this.inputOp);
        }

        if (!getActiveNodeInTreeFrom(this.outputOp))
        {
            uiMakeNodeActive(this.outputOp);
            this.newActiveOpIds.push(this.outputOpId);
            this.outputOp.pushUpdate();
            //graphView.updateNodeTransform(this.outputOp);
        }
    }
    
    
    
    undo()
    {
        uiVariableConnect(
            this.outputOp, this.outputIndex, 
            this. inputOp, this. inputIndex);

        for (const id of this.newActiveOpIds)
            uiMakeNodePassive(nodeFromId(id));

        let oldActiveOpIds = [...this.oldActiveOpIds];
        oldActiveOpIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).follows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldActiveOpIds)
            uiMakeNodeActive(nodeFromId(id));

        //graphView.updateNodeTransform(this.inputOp);
        this.inputOp.pushUpdate();
    }
    
    
    
    redo()
    {
        uiDisconnect(this.inputOp.inputs[this.inputIndex]);
        
        if (!getActiveNodeInTreeFrom(this.inputOp))
        {
            uiMakeNodeActive(this.inputOp);
            this.inputOp.pushUpdate();
            //graphView.updateNodeTransform(this.inputOp);
        }

        if (!getActiveNodeInTreeFrom(this.outputOp))
        {
            uiMakeNodeActive(this.outputOp);
            this.outputOp.pushUpdate();
            //graphView.updateNodeTransform(this.outputOp);
        }
   }
}


class DuplicateNodesAction
extends Action
{
    copiedJson;
    pastedNodeIds = [];


    constructor(copiedJson)
    {
        const data = JSON.parse(copiedJson);

        super('paste ' + data.nodes.length + ' node' + (data.nodes.length == 1 ? '' : 's'));

        this.copiedJson = copiedJson;
    }



    do()
    {
        this.pastedNodeIds = uiPasteNodes(this.copiedJson).map(n => n.id);

        uiSaveNodesAndConns(nodes.map(n => n.id));
    }



    undo()
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        pasteOffset[0] -= pasteOffsetDelta[0];
        pasteOffset[1] -= pasteOffsetDelta[1];

        uiRemoveSavedNodesAndConns(this.pastedNodeIds);
    }
}


class FindValidColorAction
extends Action
{
    nodeId;

    oldValue1;
    oldValue1;
    oldValue1;
    
    newValue;



    constructor(param, value)
    {
        super('set ' + param.op.id + '.' + param.id + ' = ' + value);

        this.nodeId     = param.op.id;
        this.paramIndex = param.op.params.indexOf(param);

        this.newValue   = value;
    }



    do()
    {
        this.oldValue = this.param.oldValue;
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    undo()
    {
        this.param.setValue(this.oldValue, false, true);
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    redo()
    {
        this.param.setValue(this.newValue);
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }
}


class MakeNodeActiveAction
extends Action
{
    activeId;

    oldActiveIds = [];



    constructor(activeId)
    {
        const oldActiveIds = [...getActiveNodesInTreeFrom(nodeFromId(activeId)).map(n => n.id)]; 

        super(
             'make ' + activeId + ' active, '
            + oldActiveIds.length + ' active before');

        this.activeId     = activeId;
        this.oldActiveIds = [...oldActiveIds];
    }



    do()
    {
        uiMakeNodeActive(nodeFromId(this.activeId));
    }



    undo()
    {
        if (!this.oldActiveIds.includes(this.activeId));
            uiMakeNodePassive(nodeFromId(this.activeId));

        for (const id of this.oldActiveIds)
            uiMakeNodeActive(nodeFromId(id));
    }
}


class PasteNodesAction
extends Action
{
    copiedNodesJson;

    pasteOutsideConnections;

    pastedNodeIds = [];
    pastedNodePos = [];

    prevSelectedNodeIds = [];


    constructor(copiedNodesJson, pasteOutsideConnections)
    {
        const data = JSON.parse(copiedNodesJson);

        super('paste ' + data.nodes.length + ' node' + (data.nodes.length == 1 ? '' : 's'));

        this.copiedNodesJson         = copiedNodesJson;
        this.prevSelectedNodeIds     = graphView.selectedNodes.map(n => n.id);
        this.pasteOutsideConnections = pasteOutsideConnections;
    }



    do()
    {
        const nodes = uiPasteNodes(this.copiedNodesJson, this.pasteOutsideConnections);

        this.pastedNodeIds = nodes.map(n => n.id);
        this.pastedNodePos = nodes.map(n => { return point(n.div.offsetLeft, n.div.offsetTop); });

        updateTerminalsAfterNodes(nodes);

        graphView.updateNodeTransforms(nodes);

        uiSaveNodesAndConns(nodes.map(n => n.id));
    }



    undo()
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        pasteOffset[0] -= pasteOffsetDelta[0];
        pasteOffset[1] -= pasteOffsetDelta[1];

        graphView.selectedNodes = graph.nodes.filter(n => this.prevSelectedNodeIds.includes(n.id));

        uiRemoveSavedNodesAndConns(this.pastedNodeIds);
    }



    redo()
    {
        const nodes = uiPasteNodes(this.copiedNodesJson, this.pasteOutsideConnections);
        
        this.pastedNodeIds = nodes.map(n => n.id);

        for (let i = 0; i < nodes.length; i++)
        {
            setNodePosition(
                nodes[i], 
                this.pastedNodePos[i].x,
                this.pastedNodePos[i].y);
        }

        updateTerminalsAfterNodes(nodes);

        uiSaveNodesAndConns(nodes.map(n => n.id));
    }
}


class ReconnectAction
extends Action
{
    outputOpId;
    outputIndex;
    get outputOp() { return nodeFromId(this.outputOpId); }

    oldOutputOpId = '';
    oldOutputIndex;
    get oldOutputOp() { return nodeFromId(this.oldOutputOpId); }

    inputOpId;
    inputIndex;
    get inputOp() { return nodeFromId(this.inputOpId); }

    oldInputOpId = '';
    oldInputIndex;
    get oldInputOp() { return nodeFromId(this.oldInputOpId); }
    
    oldOutputActiveOpId;      // the active node in the output node's tree
    oldInputActiveOpIds = []; // the active nodes in the input node's tree

    newActiveOpIds = [];



    constructor(output, oldInput, input)
    {
        const outIndex = output.op.outputs.indexOf(output);
        const  inIndex =  input.op. inputs.indexOf(input); 

        const oldOutIndex = 
            input.isConnected 
            ? input.connectedOutput.op.outputs.indexOf(input.connectedOutput) 
            : -1; 

        const oldInIndex = oldInput.op.inputs.indexOf(oldInput); 
        

        super(
             'reconnect '
            + output.op.id + '.outputs[' + outIndex + ']'
            + ' ( <- '
            + oldInput.op.id + '.inputs[' + oldInIndex + '])'
            + ' -> '
            + input.op.id + '.inputs[' + inIndex + ']');


        this.outputOpId          = output.op.id;
        this.outputIndex         = outIndex;
             
        this.oldOutputOpId       = input.isConnected ? input.connectedOutput.op.id : '';
        this.oldOutputIndex      = oldOutIndex;
     
        this.oldInputOpId        = oldInput.op.id;
        this.oldInputIndex       = oldInIndex;
     
        this.inputOpId           = input.op.id;
        this.inputIndex          = inIndex;

        this.oldOutputActiveOpId = getActiveNodeInTreeFrom(nodeFromId(this.outputOpId)).id;
        this.oldInputActiveOpIds = [...getActiveNodesInTreeFrom(nodeFromId(this.inputOpId)).map(n => n.id)];
    }



    do()
    {
        uiDisconnect(this.oldInputOp.inputs[this.oldInputIndex]);

        graphView.updateNodeTransform(this.oldInputOp);
        

        this.newActiveOpIds = [];

        if (!getActiveNodeInTreeFrom(this.oldOutputOp))
        {
            uiMakeNodeActive(this.oldOutputOp);
            this.newActiveOpIds.push(this.oldOutputOpId);
            this.oldOutputOp.pushUpdate();
            //graphView.updateNodeTransform(oldPrevOutputActiveOp);
        }


        uiConnect(
            this.outputOp.outputs[this.outputIndex], 
            this. inputOp. inputs[this. inputIndex],
            this.inputIndex);
            

        let oldInputActiveOpIds = [...this.oldInputActiveOpIds];
        oldInputActiveOpIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).follows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldInputActiveOpIds)
            uiMakeNodeActive(nodeFromId(id));


        graphView.updateNodeTransform(this.inputOp);

        this.oldInputOp.pushUpdate();
        this.inputOp   .pushUpdate();
    }



    undo()
    {
        uiDisconnect(this.inputOp.inputs[this.inputIndex]);


        uiVariableConnect(
            this.outputOp, 
            this.outputIndex, 
            this.oldInputOp, 
            this.oldInputIndex);

        graphView.updateNodeTransform(this.oldInputOp);
        this.oldInputOp.pushUpdate();
    

        if (this.oldOutputOpId != '')
        {
            uiVariableConnect(
                this.oldOutputOp, 
                this.oldOutputIndex, 
                this.inputOp, 
                this.inputIndex);

            graphView.updateNodeTransform(this.inputOp);
            this.inputOp.pushUpdate();
        }


        for (const id of this.newActiveOpIds)
            uiMakeNodePassive(nodeFromId(id));

        for (const id of this.oldInputActiveOpIds)
            uiMakeNodeActive(nodeFromId(id));

        if (!this.oldInputActiveOpIds.includes(this.oldOutputActiveOpId))
            uiMakeNodeActive(nodeFromId(this.oldOutputActiveOpId));
    }
}


class RenameNodeAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    oldName;
    newName;



    constructor(nodeId, name)
    {
        super('rename node');

        this.nodeId  = nodeId;
        this.newName = name;
    }



    do()
    {
        this.oldName = this.node.name;
        this.node.setName(this.newName);

        uiSaveNodesAndConns([nodeId]);
    }



    undo()
    {
        this.node.setName(this.oldName);

        uiSaveNodesAndConns([nodeId]);
    }



    redo()
    {
        this.node.setName(this.newName);
        
        uiSaveNodesAndConns([nodeId]);
    }
}


class ReorderInputAction
extends Action
{
    nodeId;

    oldIndex;
    newIndex;
 


    constructor(nodeId, oldIndex, newIndex)
    {
        super(
              'reorder ' + nodeFromId(nodeId).id 
            + '.inputs[' + oldIndex + ']'
            + ' to [' + newIndex + ']');

        this.nodeId   = nodeId;
        this.oldIndex = oldIndex;
        this.newIndex = newIndex;
    }



    do()
    {
        // .. already done

        nodeFromId(this.nodeId).pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    undo()
    {
        const node = nodeFromId(this.nodeId);

        moveIn(
            node.inputs,
            this.newIndex,
            this.oldIndex);
            
        node.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    redo()
    {
        const node = nodeFromId(this.nodeId);

        moveIn(
            node.inputs,
            this.oldIndex,
            this.newIndex);

        uiSaveNodesAndConns([this.nodeId]);

        node.pushUpdate();
    }
}


class SelectMoveNodesAction
extends Action
{
    newSelectedIds  = [];
    prevSelectedIds = [];

    shiftPressed;

    fromPos;
    toPos;

    from;
    to;



    constructor(prevSelectedIds, newSelectedIds, fromPos, toPos, shiftPressed)
    {
        super(
            'select move ' + newSelectedIds.length 
          + ' node' + (newSelectedIds.length == 1 ? '' : 's'));// + ', '
          //+ prevSelectedIds.length + ' selected before');


        this.prevSelectedIds = [...prevSelectedIds];
        this.newSelectedIds  = [...newSelectedIds];
          
        this.shiftPressed    = shiftPressed;

        this.fromPos         = fromPos;
        this.toPos           = toPos;


        
        const dx = this.toPos.x - this.fromPos.x;
        const dy = this.toPos.y - this.fromPos.y;


        this.from = []; // these hold tuples
        this.to   = []; // [id, pos]

        for (const id of this.getMovedIds())
        {
            const node = nodeFromId(id);

            this.from.push([id, point(node.div.slx,      node.div.sly     )]);
            this.to  .push([id, point(node.div.slx + dx, node.div.sly + dy)]);
        }
    }



    getMovedIds()
    {
        const movedIds = [];

        if (this.shiftPressed)
            movedIds.push(...this.prevSelectedIds);
        
        movedIds.push(...this.newSelectedIds);

        return movedIds;
    }



    do()
    {
        const movedIds   = this.getMovedIds();
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (var i = 0; i < movedNodes.length; i++)
        {
            const p = this.to.find(t => t[0] == movedNodes[i].id)[1];
            setNodePosition(movedNodes[i].div.op, p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateBorder();

        uiSaveNodesAndConns(movedIds);
    }



    undo()
    {
        const movedIds   = this.getMovedIds();
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (var i = 0; i < movedNodes.length; i++)
        {
            const p = this.from.find(t => t[0] == movedNodes[i].id)[1];
            setNodePosition(movedNodes[i].div.op, p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateBorder();
            
        graphView.selectByIds(this.prevSelectedIds);

        uiSaveNodesAndConns(movedIds);
    }



    redo()
    {
        this.do();

        graphView.selectByIds(this.getMovedIds());
    }
}


class SelectNodesAction
extends Action
{
    selectedIds     = [];
    prevSelectedIds = [];



    constructor(selectedIds, prevSelectedIds)
    {
        super(
              'select ' + selectedIds.length 
            + ' node' + (selectedIds.length == 1 ? '' : 's'));// + ', '
            //+ prevSelectedIds.length + ' selected before');

        this.selectedIds     = [...selectedIds];
        this.prevSelectedIds = [...prevSelectedIds];
    }



    do()
    {
        // this happens in the UI
    }



    undo()
    {
        graphView.selectByIds(this.prevSelectedIds);
    }



    redo()
    {
        graphView.selectByIds(this.selectedIds);
    }
}


class SetParamDecimalsAction
extends Action
{
    nodeId;
    paramIndex;

    get param() { return nodeFromId(this.nodeId).params[this.paramIndex]; } 


    newDecimals;
    oldDecimals;

    newDisplayDecimals;
    oldDisplayDecimals;



    constructor(param, dec, oldDec, dspDec, oldDspDec)
    {
        super('set param settings');

        this.nodeId             = param.op.id;
        this.paramIndex         = param.op.params.indexOf(param);
       
        this.newDecimals        = dec;
        this.oldDecimals        = oldDec;

        this.newDisplayDecimals = dspDec;
        this.oldDisplayDecimals = oldDspDec;
    }



    do()
    {
        this.param.setDecimals(
            this.newDecimals, 
            this.newDisplayDecimals);

        uiSaveNodesAndConns([this.nodeId]);
    }



    undo()
    {
        this.param.setDecimals(
            this.oldDecimals, 
            this.oldDisplayDecimals);

        uiSaveNodesAndConns([this.nodeId]);
    }
}


class SetParamLockAction
extends Action
{
    nodeId;
    paramIndex;

    get param() { return nodeFromId(this.nodeId).params[this.paramIndex]; } 


    locked;



    constructor(param, locked)
    {
        super('set ' + param.op.id + '.' + param.id + '.locked = ' + boolString(locked));

        this.nodeId     = param.op.id;
        this.paramIndex = param.op.params.indexOf(param);

        this.locked  = locked;
    }



    do()
    {
        //this.oldValue = this.param.oldValue;
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    undo()
    {
        this.param.setLocked(!this.locked);
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    redo()
    {
        this.param.setLocked(this.locked);
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }
}


class SetParamValueAction
extends Action
{
    nodeId;
    paramIndex;

    get param() { return nodeFromId(this.nodeId).params[this.paramIndex]; } 


    oldValue;
    newValue;



    constructor(param, value)
    {
        super('set ' + param.op.id + '.' + param.id + ' = ' + value);

        this.nodeId     = param.op.id;
        this.paramIndex = param.op.params.indexOf(param);

        this.newValue   = value;
    }



    do()
    {
        this.oldValue = this.param.oldValue;
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    undo()
    {
        this.param.setValue(this.oldValue, false, true);
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }



    redo()
    {
        this.param.setValue(this.newValue);
        this.param.op.pushUpdate();

        uiSaveNodesAndConns([this.nodeId]);
    }
}


class ToggleArithmeticSymbolAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    showOnlySymbol;



    constructor(nodeId, showOnlySymbol)
    {
        super('show only symbol = ' + boolString(showOnlySymbol));

        this.nodeId         = nodeId;
        this.showOnlySymbol = showOnlySymbol;
    }



    do()
    {
        this.node._showOnlySymbol = this.showOnlySymbol;
        this.node.updateNode();

        uiSaveNodesAndConns([this.nodeId]);
    }



    undo()
    {
        this.node._showOnlySymbol = !this.showOnlySymbol;
        this.node.updateNode();

        uiSaveNodesAndConns([this.nodeId]);
    }    
}


function updateToggleShowWiresButton()
{
    const color = 
           graphView.showWires 
        || btnToggleWires.mouseOver 
        ? 'white' 
        : '%23d5d5d5';

    btnToggleWires.style.background         = 'url(\'data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="'+color+'" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="'+color+'"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="'+color+'"/></svg>\')';
    btnToggleWires.style.backgroundPosition = '50% 50%';
    btnToggleWires.style.backgroundRepeat   = 'no-repeat';
    btnToggleWires.style.backgroundColor    = graphView.showWires ? '#18a0fb' : (btnToggleWires.mouseOver ? 'black' : '#2c2c2c');
}



btnToggleWires.addEventListener('pointerover',  () => updateToggleShowWiresButton());
btnToggleWires.addEventListener('pointerleave', () => updateToggleShowWiresButton());


const panCursor = 
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3Ln'
    + 'czLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzJweCIgaGVpZ2h0PSIzMnB4Ij48aW1hZ2UgeGxpbms6aHJlZj0i'
    + 'ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWE'
    + 'hlQUFBSHFrbEVRVlI0WHUyYWY4aVY1Um5IUDlhbXpjM0tkRERkSDJ2WitpUEQvdEJTSEtLQ1EyVmJaTWdnbDAx'
    + 'TENUUmJ0Q1hLSFA1Z1N1UWZNZGtmZ3lrMkZLTWtjU0wrV0RKbExOU2xwaWtSaEdRU1VTMU4zV2JiYW5OOG50M1'
    + 'h1N3ZIOXpYUE9jOXp3dDczZ3B2M25QT2U4enpQOWIyLzE4Lzc2a1UzbDE3ZFhIOTZBT2hoUURkSG9NY0V1amtC'
    + 'ZXB4Z2p3bTAwUVFFTzFiYzlnSVFxNDJQOHY5YnRZTUIzdU9xdEs0R0JnRTNBdThBYndML1R1cy9nS3V0VWpjQV'
    + 'hsK2x2d0I4RVZnRXpNODBmQkZZRFR3UGZGd0NvaTNNcUJzQWxWZnhQc0R2Z0xFcVAyVElFSTRmUDU3djlGVGdq'
    + 'OEJOd0YrQk54SWJaRWV0ektnRGdMQnphYS95MXdEZkIzNnJ4cHMyYldMS2xDbWNPSEdDdVhQbnNtM2JOai9lQl'
    + 'h3TnVDMmhjaEJZRE93QlBrcnNxTVU4cWdTZ2JPdlMzcDN2Qzh3R2ZqNXk1RWoyN2R2WHNmT3JWNjltOW16LzFh'
    + 'VThEdndhK0ZkZElGUUZRRGc1ZDF6RjF3SERnZXVBVjREWGdBZVhMRm5DNHNWdTdQOWt6NTQ5akI4L3ZuanQ1K1'
    + 'BHamFOZnYzNXMzYm9Wdnd1OEM0d0FQZ0QrbVh5RXZxRXlxUUtBY0hTOTA0NmY3dXJwTGdYQXNXUEhHRHAwYU1k'
    + 'UGUvWHFlTFFKd0NIZ2ZES0hTazJoQ2dEQzBYMEplQWFZcUJaYnRteGgrUERoTEZpd2dIWHJKQVRGcm5iRmdBc1'
    + 'hQcm14TWtPR0FQY0RMd0IvU3l3d1dsVEdnbFlCOFBkU1h1Vy9BdndaK1BxcVZhdVlOMjlleDI0T0dEQ0EwNmRQ'
    + 'Tnd2QVE4bEpHaDFrZ2Y1QUZnaEN5MnhvRlFCdFgrcC9PZGw3RWR2S3U3bDA2ZEpDK1NZWjhDandUV0JrOGlWUE'
    + 'F5K1Y4b2FtR1ZFRkFJYTVmc0FOd0tzMUFOQ1pTM2tTK0VVV0hjd1htcEpXQWREK3BmKzF3SURrOGF0bUFLTkhq'
    + 'MmI1OHVYSXBPUVhWRlpmc3pmNUJYT0ZwbGpRS2dCaC80YTdnY0RMVlROZzJMQmhIRGx5cEdOM1I0MGF4Zjc5Kz'
    + 'MwdkEzNlovRUtFeUlaWlVBVUFKam9CZ09HcVN3WVlBVko4dnlnUDZDb0s3TjY5dThnUFFzS2ZKRDh3SmFYT0g2'
    + 'WVErWmtDOEZYQUZMWmRBSGl2SHdCbmdMOG5mOUN3R1ZURmdPdVRDYlFUQU0zdFhzREV5eHpoSDgzNGdTc1pnTV'
    + 'BBRHhNQTV4SUFEZWNGVnpJQWVzYjdnRk9BQU9nSGFnY2dBSXUvRmorR3dYQ0NCenJ6QVRvK25WZkZUckN0QU9T'
    + 'bGJsUis2aHIxZmlSQ3BzS2RPa0hqOTlpeFl5K0tBZ0tqNk8xektWZUpuVVFCQVpoZVlrRERDZEhsbUVBb2JNen'
    + 'ZiMDBEV0tHNTY2YSttNjE5QUIzaG56b0RvT0hZZElrZlpHR3dMUUJFc2VOT1c2ditDcml6aytjek0xbWJtaGNY'
    + 'TWVCS0JzQlUxMkpITy84TmNJL0tyRnk1a2hFalJuRDQ4T0hDcnMrZDB3Y1ZEUXM3UUxVQ0VQNEVxSjBCN3I3S1'
    + 'creVlkeityY3VYR3hjR0RCMW0wYUJFN2R1em8yT2h5VmxjbEE5b0pnTHZ2amxycVBnQThZVXBhZGxhaDNMSmx5'
    + 'enFhSFo4WEFLTFEwY1BQQVg1V0xrektPN3RyMXk3bXo1L1BvVU5GU1ZDTHRKTUJPajRMSFV2ZE85TGhSY0dBdk'
    + 'RncGEzbisvSG42OXZWbjljaG5CWUNsN25KZ3NtcHQzNzZkU1pNbTFhUGhwMXkxblFEa0ptQ3o0MmJnS2VBYlB1'
    + 'UEdqUnVaT3RVRG5mWktPd0hJbmFCSmp1V3VKemNMMCtFbWE5ZXVaY2FNR1cxRm9BUkExQUkyVEswRktzMEVEWU'
    + '9SNjBlcWE5L3ZGdUNud0xmVXZOd0JyaHVOVWlhWUYwT1d3NVVDb0M2UkNJVXpOQlYyYVFZL0FXNzFTeXRXckdE'
    + 'aFFvbFJ2OHlhTllzMWE5WjRvejhBUDY2N0dveFVPRnJmTWtGekVBUVBNMlhDN1Q2TkFBaEUzYUx6M2JsenA3ZD'
    + 'VEbGlXQUFnVHFLVWN0aGpTSVFxQ1RBZ1FCRUxuS0FpR3llSXdSSk9vVXdZT0hNaXBVN1lBaXFKTUVPd0lDWUFt'
    + 'VUFzQTNxd3pFS3dHZ3cyUEFhUDlvazVSNTFpSDdOMjd0MmlSSi9rZThIbzZPQlVBYTVGYWU0S0NFSkhCNGtnbU'
    + 'NJTG1JQkNQeEFDRTRkRXdXYlZNbno2ZDlldlhlMW1yVCszL0wxbFRWQUFhbHN2cEIrUVhEUkRDSER3UHpFRXda'
    + 'YlpYd01TSkV6OVJJRFg4WktVZmJONjh1UmlzU0xJQStEM3dQbkEyaFVBUFJ4cVdSZ0h3QnJsakRDYVlMa2VFZU'
    + 'JENHJsLzBkUGpBZ2FKTDFwS2NPWE9HL3YyOWZDRk9rM2dvOGw2cEk5eHdDQXhsbW5tNHZGR2lZd3dtaEUvNEVY'
    + 'QjNGVXpJaHlpQXQ0RlppZnA2UW5lLzZUT0JWZ0NJMytZTmt6SUltc0xEZm5ITW1ERkZtSnc4dVNnbExrdk9uaj'
    + 'NMaGcwYm1ETkhxeXJFM244a1BpcnYxRWljQnpnejBKUTBZd0w1amZMcGtKZ1IwQnhrZ2tzUXpKWDlqSmt6WnpK'
    + 'dDJqUW1UQ2pjUktkeTlPalJRbkhYeVpNbjR6c2VoeitSS0cvWVUvbUkvZHArdytFdkx0d3FBRGtUSW0yV0NTcX'
    + 'NjM1E1K25ZWDhKMjRhZS9ldlJrOGVEQ0RCZzJpVDUraWk0WjI3dVNZZnpQeGplMWlSMHg4cmVMU1BzNEJtajRV'
    + 'clJLQU1naTIwT3dpR1NZRndpVW8xZzdmVGtOUGd6K0ZyOGRTejg4dTgxdHB0MVhjSmUxalVxVGxjWmtxR0pDRE'
    + 'dWT2hnaEFtb2ZJdVFmRXp0OXoza1QrWVpTcFdjOUpiKzViV1puWXFxcE9UN2k1Zit6M0haR0tJc2luYnI1b0Ir'
    + 'Zlh5ckZHRlhVYUtlQzBBNWhHQzVYSVRZaXhXcGR4VkZSUUFsUlVFbDYvOVRIQXFVVDZvMnhLQ1hmdzRRTkF2cU'
    + 'd5TTBJWHlmcTd5Zmk5WUdDT3hBcUNTZ3FDTng0cGhTWlZ2T09YdFNza3FUYUI4ajRnUStiQjBERTNudXgvUEVG'
    + 'TmZ3WUlBd3IvNUlIVmx5dGZKZ0J5TU9GcUxORHAvci9JNUFEa0lNaUlmbHE1VThicDh3S1hNS1pUTi8rYWJFQW'
    + '9HQ0orTGNmazYvRXVsMTZ6VEIxVDZvSFZkckFlQXVwQzlVcTdiN1Jud1g2cWNXVzY0MVZ5REFBQUFBRWxGVGtT'
    + 'dVFtQ0MiIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIvPjwvc3ZnPg==) 15 15, auto';


const zoomInCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kKSI+PHBhdGgg'
    + 'ZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC41IDhDMTQuNSAxMS4wMzggMT'
    + 'IuMDM4IDEzLjUgOSAxMy41QzUuOTYyIDEzLjUgMy41IDExLjAzOCAzLjUgOEMzLjUgNC45NjIgNS45NjIgMi41'
    + 'IDkgMi41QzEyLjAzOCAyLjUgMTQuNSA0Ljk2MiAxNC41IDhaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGZpbGwtcn'
    + 'VsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAzOCAx'
    + 'My41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5IDIuNU'
    + 'MxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPjxwYXRoIGZpbGwtcnVsZT0i'
    + 'ZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNTg1NyAxOC4wMDAyTDE4Ljk5OTcgMTYuNTg2Mk'
    + 'wxMy41NTA3IDExLjEzNzJMMTIuMTM2NyAxMi41NTEyTDE3LjU4NTcgMTguMDAwMloiIGZpbGw9ImJsYWNrIi8+'
    + 'PC9nPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0gxMFY1SD'
    + 'hWN0g2VjguOThIOFYxMUgxMFY4Ljk4SDEyVjdaIiBmaWxsPSJibGFjayIvPjxkZWZzPjxmaWx0ZXIgaWQ9ImZp'
    + 'bHRlcjBfZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIxLjk5OTciIGhlaWdodD0iMjIuMDAwMiIgZmlsdGVyVW5pdH'
    + 'M9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPjxmZUZsb29kIGZs'
    + 'b29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQ29sb3JNYXRyaXggaW49Il'
    + 'NvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMTI3IDAiLz48ZmVPZmZzZXQgZHk9IjEiLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLj'
    + 'UiLz48ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMCAwIDAgMC4zNSAwIi8+PGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZU'
    + 'ZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3ciLz48ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3Vy'
    + 'Y2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvdyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjwvZG'
    + 'Vmcz48L3N2Zz4=) 8 8, auto';


const zoomOutCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZCkiPgo8cGF0'
    + 'aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjUgOEMxNC41IDExLjAzOC'
    + 'AxMi4wMzggMTMuNSA5IDEzLjVDNS45NjIgMTMuNSAzLjUgMTEuMDM4IDMuNSA4QzMuNSA0Ljk2MiA1Ljk2MiAy'
    + 'LjUgOSAyLjVDMTIuMDM4IDIuNSAxNC41IDQuOTYyIDE0LjUgOFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGZpbG'
    + 'wtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAz'
    + 'OCAxMy41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5ID'
    + 'IuNUMxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1'
    + 'bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3LjU4NTcgMTguMDAwMkwxOC45OTk3IDE2Lj'
    + 'U4NjJMMTMuNTUwNyAxMS4xMzcyTDEyLjEzNjcgMTIuNTUxMkwxNy41ODU3IDE4LjAwMDJaIiBmaWxsPSJibGFj'
    + 'ayIvPgo8L2c+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0'
    + 'g2VjguOThIMTJWN1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2QiIHg9IjAi'
    + 'IHk9IjAiIHdpZHRoPSIyMS45OTk3IiBoZWlnaHQ9IjIyLjAwMDIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPbl'
    + 'VzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0i'
    + 'MCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIi'
    + 'B0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAi'
    + 'Lz4KPGZlT2Zmc2V0IGR5PSIxIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIvPgo8ZmVDb2'
    + 'xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAw'
    + 'IDAgMC4zNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3'
    + 'VsdD0iZWZmZWN0MV9kcm9wU2hhZG93Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBo'
    + 'aWMiIGluMj0iZWZmZWN0MV9kcm9wU2hhZG93IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cj'
    + 'wvc3ZnPgo=) 8 8, auto';


document.addEventListener('pointerdown', function(e)
{
    if (   e.button == 0
        && (   document.canResizeX
            || document.canResizeY))
    {
        document.startRect = new Rect(
            e.clientX,
            e.clientY,
            window.innerWidth,
            window.innerHeight);

        document.body.setPointerCapture(e.pointerId);

        document.resizingX = document.canResizeX;
        document.resizingY = document.canResizeY;
    }
});



document.addEventListener('pointermove', function(e)
{
    if (   document.resizingX
        && document.resizingY)
    {
        uiResizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (document.resizingX)
    {
        uiResizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            window.innerHeight);
    }
    else if (document.resizingY)
    {
        uiResizeWindow(
            window.innerWidth,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (!graphView.selecting)
        checkResize(e.clientX, e.clientY);
});



document.addEventListener('pointerup', function(e)
{
     if (   document.resizingX
         || document.resizingY)
    {
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }

    document.resizingX = false;
    document.resizingY = false;

    scrollbarX.moving  = false;
    scrollbarY.moving  = false;
});


var figMessages = [];



//uiClearLocalData('windowWidth');
//uiClearLocalData('windowHeight');
//uiClearLocalData('productKey');

//uiClearPageData('GA rect');
//uiRemoveAllSavedNodesAndConns();
uiLogAllSavedNodesAndConns();


var currentUser = '';



const graph = new Graph();

const generator = new Worker(
    window.URL.createObjectURL(
        new Blob([generatorScript.textContent])));



var     copiedNodesJson = '';
var duplicatedNodesJson = '';

var pasteOffset         = [ 0,   0];
var pasteOffsetDelta    = [40, 100];



clearConsole();



uiPostMessageToFigma({cmd: 'figStartGenerator'});

function uiEndStartGenerator(msg)
{
    currentUser = msg.currentUser;
    productKey  = msg.productKey;

    uiGetLocalData('graphView');
    uiPostMessageToFigma({cmd: 'figLoadNodesAndConns'});        

    uiEndResizeWindow();

    window.focus();
}


document.addEventListener('keydown', e =>
{
    let setLastKeyDown = true;


    // copy
    if (   e.code == 'KeyC'
        && getCtrlKey(e))
    {
        pasteOffset     = [0, 0];
        copiedNodesJson = uiCopyNodes(graphView.selectedNodes.map(n => n.id));
    }

    // paste
    else if (e.code == 'KeyV'
          && getCtrlKey(e))
    {
        actionManager.do(new PasteNodesAction(copiedNodesJson, e.shiftKey));
    }

    // duplicate
    else if (e.code == 'KeyD'
          && getCtrlKey(e))
    {
        pasteOffset = [0, 0];
        actionManager.do(new PasteNodesAction(uiCopyNodes(graphView.selectedNodes.map(n => n.id)), e.shiftKey));
        return false;
    }

    // select all
    else if (e.code == 'KeyA'
          && getCtrlKey(e))
    {
        graphView.selectedNodes = graph.nodes;
    }

    // undo/redo
    else if (e.code == 'KeyZ'
          && getCtrlKey(e))
    {
        if (e.shiftKey) actionManager.redo();
        else            actionManager.undo();

        setLastKeyDown = false;
    }

    // delete / backspace
    else if (   e.key == 'Delete'
             || e.key == 'Backspace')
    {
        const nodeIds = graphView.selectedNodes.map(n => n.id);
        actionManager.do(new DeleteNodesAction(nodeIds));
        graphView._selected = [];
    }

    // escape
    else if (e.key == 'Escape')
    {
        if (graphView.tempConn)
        {
            if (graphView.savedConn)
            {
                const savedConn = graphView.savedConn;

                setTimeout(() => 
                {
                    graphView.updateNodeWire(savedConn.wire);
                    savedConn.input.updateControl();
                });
            }

            graphView.cancelConnection(graphView.connPointerId);
        }
    }

    //
    else if (e.code == 'Minus')
    {
        graphView.zoom /= 2;
    }

    else if (e.code == 'Equal')
    {
        graphView.zoom *= 2;
    }

    else if (e.code == 'Digit0'
          && getCtrlKey(e))
    {
        graphView.zoom = 1;
        uiNotify('Zoom to 100%');
    }

    else if (e.code == 'Space'
         && !getCtrlKey(e))
    {
        if (   !graphView.selecting
            && !graphView.spaceDown)
        {
            graphView.spaceDown = true;
            setCursor(panCursor);
        }
    }

    else if (e.key == 'Shift')
    {
        if (graphView._soloNode)
            graphView.unsoloNode();
    }

    else if (e.key == 'Control')
    {
        if (graphView._soloNode)
            graphView.unsoloNode();

        if (graphView.spaceDown)
        {
            graphView.zoomSelecting = true;

            if (e.altKey) setCursor(zoomOutCursor);
            else          setCursor(zoomInCursor);
        }
    }

    else if (    e.key == 'Alt'
             && !e.shiftKey
             && !getCtrlKey(e))
    {
        if (   graphView.spaceDown
            && getCtrlKey(e))
            setCursor(zoomOutCursor);
        else if (graphView.overNode)
            graphView.soloNode(graphView.overNode);
    }

    else if (e.code == 'Tab')
        e.preventDefault();
});



document.addEventListener('keyup', e =>
{
    if (e.code == 'Space')
    {
        if (graphView.spaceDown)
        {
            graphView.spaceDown     = false;
            graphView.zoomSelecting = false;
            setAutoCursor();
        }
    }

    else if (e.key == 'Alt')
    {
        if (graphView.spaceDown)
        {
            if (getCtrlKey(e)) 
                setCursor(zoomInCursor);
            else
            {
                setCursor(panCursor);
                graphView.zoomSelecting = false;
            }
        }
        else if (graphView._soloNode)
            graphView.unsoloNode();
    }

    else if (e.key == 'Control'
          && graphView.spaceDown)
    {
        graphView.zoomSelecting = false;
        setCursor(panCursor);
    }
},false);


// --> from Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = e =>
{
    let msg = e.data.pluginMessage;

    switch (msg.cmd)
    {
        case 'uiEndStartGenerator':  uiEndStartGenerator(msg);                                          break;
        case 'uiLoadNodesAndConns':  uiLoadNodesAndConns(msg.nodesJson, msg.connsJson, msg.activeJson); break;
        
        case 'uiGetLocalDataReturn': uiGetLocalDataReturn(msg);                                         break;
        case 'uiGetPageDataReturn':  uiGetPageDataReturn(msg);                                          break;
              
        case 'uiEndResizeWindow':    uiEndResizeWindow();                                               break;
              
        case 'uiForwardToGen':       uiPostMessageToGenerator(msg.msg);                                 break;
              
        case 'uiEndFigMessage':      uiPostNextMessageToFigma();                                        break;
    }
}    
  
///////////////////////////////////////////////////////////////////////////////////////////////////



// from Generator <--
///////////////////////////////////////////////////////////////////////////////////////////////////

generator.onmessage = function(e)
{
    switch (e.data.msg)
    {
        case 'uiUpdateFindCorrection': uiUpdateFindCorrectionProgress(e.data.nodeId, e.data.progress); break;
        case 'uiEndFindCorrection':    uiEndFindCorrection           (e.data.nodeId, e.data.success, e.data.closestOrder, e.data.closest1, e.data.closest2, e.data.closest3); break;
        // case 'uiMakeActive':        uiMakeActive    (e.data.nodeIds);                            break;
        // case 'uiShowParamValue':    uiShowParamValue(e.data.nodeId, e.data.param, e.data.value); break;
        // case 'uiUpdateNodes':       uiUpdateNodes   (e.data.nodeIds);                            break;
        // case 'uiUpdateGraph':       uiUpdateGraph   ();                                          break;
        case 'uiUpdateCanvasObjects':  uiUpdateCanvasObjects         (e.data.objects);                 break;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////






// <-- to Figma
function uiPostMessageToFigma(msg)
{
    figMessages.push(msg);
    uiPostNextMessageToFigma();
}



function uiPostNextMessageToFigma()
{
    if (figMessages.length > 0)
    {
        let msg = figMessages.shift();

        if (   msg.cmd == 'figResizeWindow'
            || msg.cmd == 'figUpdateCanvasObjects')
        {
            // move along the queue since only the last message is important
            while (figMessages.length > 0
                && figMessages[0].cmd == msg.cmd)
                msg = figMessages.shift();
        }

        parent.postMessage({pluginMessage: msg}, '*');    
    }
}



///////////////////////////////////////////////////////////////////////////////////////////////////



// to Generator -->
function uiPostMessageToGenerator(msg)
{
    generator.postMessage(msg);
}



function uiPostGeneratorRequest(request)
{
    uiPostMessageToGenerator({
        msg:    'genGenerateRequest',
        request: request
    });
}


///////////////////////////////////////////////////////////////////////////////////////////////////


function setCursor(cursor, asyncForce = true)
{
    document.body.style.cursor = cursor;
    if (asyncForce) setTimeout(null, 0);
}



function setAutoCursor()
{
    if (graphView.zoomSelecting)
        setCursor(zoomInCursor);
    else if (graphView.spaceDown
          || graphView.panning)
        setCursor(panCursor);
    else
        setCursor('default'); // 'auto');
};


function uiGetLocalData(key, value)
{
    uiPostMessageToFigma({ 
        cmd: 'figGetLocalData', 
        key:  key
    });
}



function uiSetLocalData(key, value)
{
    uiPostMessageToFigma({ 
        cmd:  'figSetLocalData',
        key:   key,
        value: value
    });
}



function uiClearLocalData(key)
{
    uiPostMessageToFigma({ 
        cmd:  'figSetLocalData',
        key:   key,
        value: ''
    });
}



function uiGetPageData(key)
{
    uiPostMessageToFigma({ 
        cmd: 'figGetPageData', 
        key:  key
    });
}



function uiSetPageData(key, value)
{
    uiPostMessageToFigma({ 
        cmd:  'figSetPageData', 
        key:   key,
        value: value
    });
}



function uiClearPageData(key)
{
    uiPostMessageToFigma({ 
        cmd:  'figSetPageData', 
        key:   key,
        value: ''
    });
}



// function saveToLocalFile(filename, str) 
// {
//     const link = document.createElement('a');
//     link.style.display = 'none';
    
//     link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(str));
//     link.setAttribute('download', filename);
    
//     document.body.appendChild(link);
//     link.click();
//     document.body.removeChild(link);
// }



///////////////////////////////////////////////////////////////////////////////////////////////////
   


function uiGetLocalDataReturn(msg)
{
    switch (msg.key)
    {
        case 'graphView':
            uiLoadGraphView(msg.value);
            break;
    }
}


function uiGetPageDataReturn(msg)
{
    // switch (msg.key)
    // {
    //     case '':
    //         break;
    // }
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function uiLoadGraphView(json)
{
    graphView.loadingNodes   = true;
    graphView.canUpdateNodes = false;
    

    // if (  !json
    //     || json == '')
    // {
    //     // set defaults
    //     //graphView.setPanAndZoom(point(0, 0), 1);
    //     finishLoading();
    //     return;
    // }


    const data = JSON.parse(json);
    //log(json);


    const pan = point( 
        parseFloat(data.panx), 
        parseFloat(data.pany));

    if (isNaN(pan.x)) pan.x = 0;
    if (isNaN(pan.y)) pan.y = 0;

    
    const zoom = parseFloat(data.zoom);
    if (isNaN(zoom)) zoom  = 1;


    graphView.setPanAndZoom(pan, zoom);


    graphView.showWires = isTrue(data.showWires);
}



function uiLoadNodesAndConns(nodesJson, connsJson, activeJson)
{
    graph.clear();

    const nodes  = JSON.parse( nodesJson).map(n => JSON.parse(n));
    const conns  = JSON.parse( connsJson).map(c => JSON.parse(c));
    const active = JSON.parse(activeJson);

    //console.log('nodes', nodes);
    //console.log('conns', conns);
    //console.log('active', active);

    loadNodesAndConnsAsync(nodes, conns, active, setLoadingProgress);
}



// function saveGraph()
// {
//     const json = graph.toJson(); 
//     //log(json); 
//     uiSetPageData("graph", json);
// }



function setLoadingProgress(progress)
{
    loadingProgress.style.width = (progress * 100) + '%';
}



function loadNodesAndConnsAsync(nodes, connections, activeNodeIds, setProgress)
{
    loadingProgress.style.width   = 0;
    loadingOverlay .style.display = 'block';


    let promise = Promise.resolve([]);


    const chunkSize = 10; // nodes
    for (let i = 0; i < nodes.length; i += chunkSize)
    {
        promise = promise.then(_nodes => 
        {
            const res = resolveLoadNodes(
                nodes, 
                i, 
                Math.min(i + chunkSize, nodes.length), // exclusive
                _nodes);

            setProgress(i / (nodes.length + (connections ? connections.length : 0)));
            return res;
        });
    }


    promise.then(_nodes => 
    {
        graph.addNodes(_nodes, false, false);
        loadConnectionsAsync(nodes, connections, activeNodeIds, _nodes, setProgress);    
    });
}



function loadConnectionsAsync(nodes, connections, activeNodeIds, _nodes, setProgress)
{
    let promise = Promise.resolve([]);
    
    if (connections)
    {
        // variable inputs need connections to be sorted by input index
        connections.sort((c1, c2) => 
        {
            if (c1.inputOp.id != c2.inputOp.id) return c1.inputOp.id - c2.inputOp.id;
            if (c1.inputIndex != c2.inputIndex) return c1.inputIndex - c2.inputIndex;
            return 0;
        });


        const chunkSize = 10; // connections
        for (let i = 0; i < connections.length; i += chunkSize)
        {
            promise = promise.then(() => 
            {
                const res = resolveLoadConnections(
                    nodes,
                    connections, 
                    i, 
                    Math.min(i + chunkSize, connections.length)); // exclusive

                setProgress((nodes.length + i) / nozero(nodes.length + connections.length * 19/20)); // the proportion is arbitrary
                return res;
            });
        }
    }


    promise.then(() => 
    {
        updateTerminalsAfterNodes(_nodes);
        finishLoading();

        const activeNodes = activeNodeIds.map(id => nodeFromId(id));

        for (const node of activeNodes)
            uiMakeNodeActive(node);
    });
}



function finishLoading()
{
    loadingOverlay.style.display = 'none';
    
    graphView.loadingNodes   = false;
    graphView.canUpdateNodes = true;
   
    
    updateToggleShowWiresButton();
    graphView.updateShowWires();

    
    // now that the graph is loaded, the auto save can start
    //setInterval(autoSave, 1000);
}



function resolveLoadNodes(_nodes, first, last, nodes)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
                nodes.push(loadNode(_nodes[i]));

            resolve(nodes);
        }));
}



function resolveLoadConnections(nodes, _connections, first, last)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
            {
                const _conn = _connections[i];

                if (   nodes.find(n => (n.newId ? n.newId : n.id) == _conn.outputOp)
                    && nodes.find(n => (n.newId ? n.newId : n.id) == _conn. inputOp))
                    Connection.parseJson(_conn);
            }

            resolve();
        }));
}



function loadNodes(data)
{
    const nodes = [];
    
    for (let i = 0; i < data.nodes.length; i++)
        nodes.push(loadNode(data.nodes[i]));

    return nodes;
}



function loadNode(_node)
{
    const node = createNode(_node.type);
    node.loading = true;

    node.id   = _node.id;
    node.name = _node.name;

    if (_node.labelOffset)
        node.labelOffsetFactor = parseFloat(_node.labelOffset);

    if (  _node.params
        || node.alwaysLoadParams)
        node.loadParams(_node);

    setNodePosition(
        node, 
        parseFloat(_node.x), 
        parseFloat(_node.y),
        false);

    return node;
}



function loadConnections(data, loadOutsideConnections, setProgress = null)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];
        
        if (      data.nodes.find(n => (n.newId ? n.newId : n.id) == _conn.outputOp)
               && data.nodes.find(n => (n.newId ? n.newId : n.id) == _conn. inputOp)
            || loadOutsideConnections)
            Connection.parseJson(_conn);

        if (setProgress)
            setProgress(((data.nodes.length + i) / (data.nodes.length + data.connections.length)));
    }
}



function uiSaveGraphView()
{
    uiSetLocalData('graphView', graphView.toJson());
}



function dataColorToJson(color, nTab)
{
    let   pos = ' '.repeat(nTab);
    const tab = '  ';

    let json =
          pos + tab + '[\n'
        + pos + tab + tab + '"'+color[0] +'",\n'
        + pos + tab + tab +     color[1] + ',\n'
        + pos + tab + tab +     color[2] + ',\n'
        + pos + tab + tab +     color[3] + '\n'
        + pos + tab + ']';

    return json;
}


var tooltipTimer, 
    tooltipInTimer,
    tooltipOutTimer, 
    tooltipLeaveTimer;

var curTooltipSource = null;
var curTooltip       = null;

    

function createTooltipSrc(source, getTooltip, bottomArrow = false)
{
    source.addEventListener('pointerenter', () =>
    {
        clearTimeout(tooltipInTimer);
        clearTimeout(tooltipLeaveTimer);
    
        if (!tooltipTimer)
        {
            tooltipTimer = setTimeout(() =>
            {
                showTooltip(source, getTooltip(), bottomArrow);

                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }, 
            curTooltip ? 0 : 1000);
        }
    });
      
    
    source.addEventListener('pointerleave', () =>
    {
        clearTimeout(tooltipTimer);
        curTooltipSource = null;

        tooltipOutTimer = setTimeout(() => 
        {
            hideTooltip(getTooltip());
        }, 
        400);
    });
}



function createTooltip(tooltip)
{
    tooltip.addEventListener('pointerenter', () =>
    {
        clearTimeout(tooltipOutTimer);
        tooltipOutTimer = null;
    });
    
    
    tooltip.addEventListener('pointerleave', () =>
    {
        hideTooltip(tooltip);
    });


    hideTooltip(tooltip);
}



function showTooltip(source, tooltip, bottomArrow)
{
    if (curTooltip)
        hideTooltip(curTooltip);


    tooltip     .style.display = 'block';
    tooltip     .style.opacity = '100%';

    tooltipArrow.style.display = 'block';
    tooltipArrow.style.opacity = '100%';

    let srcRect = source.getBoundingClientRect();

    srcRect.y -= 5;


    const margin = 10;
 
    tooltip.style.left = Math.min(Math.max(
        margin, 
        srcRect.x + srcRect.width/2 - tooltip.offsetWidth/2), 
        graphView.offsetWidth - tooltip.offsetWidth - margin);

    tooltipArrow.style.left = srcRect.x + srcRect.width/2;// - tooltipArrow.offsetWidth/2;

    
    if (bottomArrow)
    {
        const ttRect = tooltip.getBoundingClientRect();

        tooltip.style.top = srcRect.y - tooltipArrow.offsetHeight - ttRect.height;

        tooltipArrow.style.borderColor = '#040404 transparent transparent transparent';
        tooltipArrow.style.top         = srcRect.y - tooltipArrow.offsetHeight;
    }
    else
    {
        tooltip.style.top = srcRect.y + srcRect.height + tooltipArrow.offsetHeight;

        const ttRect = tooltip.getBoundingClientRect();

        tooltipArrow.style.borderColor = 'transparent transparent #040404 transparent';
        tooltipArrow.style.top         = ttRect.y - tooltipArrow.offsetHeight;
    }


    curTooltip = tooltip;
}



function hideTooltip(tooltip)
{
    tooltip     .style.display = 'none';
    tooltip     .style.opacity = '0%';

    tooltipArrow.style.display = 'none';
    tooltipArrow.style.opacity = '0%';

    clearTimeout(tooltipTimer);
    clearTimeout(tooltipOutTimer);

    tooltipTimer               = null;
    curTooltip                 = null;
}


createTooltip(ttCreateNumber);           createTooltipSrc(btnCreateNumber,           () => ttCreateNumber);
createTooltip(ttCreateMinMax);           createTooltipSrc(btnCreateMinMax,           () => ttCreateMinMax);
createTooltip(ttCreateAdd);              createTooltipSrc(btnCreateAdd,              () => ttCreateAdd);
createTooltip(ttCreateSubtract);         createTooltipSrc(btnCreateSubtract,         () => ttCreateSubtract);
createTooltip(ttCreateMultiply);         createTooltipSrc(btnCreateMultiply,         () => ttCreateMultiply);
createTooltip(ttCreateDivide);           createTooltipSrc(btnCreateDivide,           () => ttCreateDivide);
createTooltip(ttCreateModulo);           createTooltipSrc(btnCreateModulo,           () => ttCreateModulo);
createTooltip(ttCreateExponent);         createTooltipSrc(btnCreateExponent,         () => ttCreateExponent);
createTooltip(ttCreateInterpolate);      createTooltipSrc(btnCreateInterpolate,      () => ttCreateInterpolate);

createTooltip(ttCreateColor);            createTooltipSrc(btnCreateColor,            () => ttCreateColor);
createTooltip(ttCreateColorInterpolate); createTooltipSrc(btnCreateColorInterpolate, () => ttCreateColorInterpolate);
createTooltip(ttCreateValidateColor);    createTooltipSrc(btnCreateValidateColor,    () => ttCreateValidateColor);
createTooltip(ttCreateWebContrast);      createTooltipSrc(btnCreateWebContrast,      () => ttCreateWebContrast);
createTooltip(ttCreateColorblind);       createTooltipSrc(btnCreateColorblind,       () => ttCreateColorblind);

createTooltip(ttToggleWires);            createTooltipSrc(btnToggleWires,            () => ttToggleWires);


// menuSelect.addEventListener('change', async function(e) 
// {
//     switch (e.detail.selectedValue)
//     {
//         case 'saveLocal':  saveToLocalFile('graph.json'); break;
//         case 'loadLocal':  loadFromLocalFile();           break;
//         case 'duplicate':  console.log(graph.toJson());     break;
//         case 'productKey': showProductKeyDialog();        break;
//     }
// });



productKeyClose.addEventListener('click', e =>
{
    hideProductKeyDialog();
});



btnToggleWires.addEventListener('pointerenter', () => { btnToggleWires.mouseOver = true;  updateToggleShowWiresButton(); });
btnToggleWires.addEventListener('pointerleave', () => { btnToggleWires.mouseOver = false; updateToggleShowWiresButton(); });


/*
    At least one node in a tree must be active. It doesn't have to be a terminal,
    but there can be no other active nodes downstream.

    In diamonds exactly one node can be active.



    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

√       █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

√       █████████     █████████



    Connecting


        █████████─ ─ →█████████
√                  ↓
        [̅_̅_̅_̅_̅_̅_̅_]─────█████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]──┘
                   └ →█████████

√                 ↓

                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]══╡
                   └──█████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        [̅_̅_̅_̅_̅_̅_̅_]──┐
                   └─→█████████
        █████████─ ┘

√                 ↓

        [̅_̅_̅_̅_̅_̅_̅_]──┐
                   ╞══█████████
        [̅_̅_̅_̅_̅_̅_̅_]──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        █████████──┐
                   └─→[̅_̅_̅_̅_̅_̅_̅_]
        █████████─ ┘

√                 ↓

        █████████──┐
                   ╞══[̅_̅_̅_̅_̅_̅_̅_]
        [̅_̅_̅_̅_̅_̅_̅_]──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──█████████─ ┐
        [̅_̅_̅_̅_̅_̅_̅_]══╡              → █████████
                   └──█████████

√                         ↓

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐
        [̅_̅_̅_̅_̅_̅_̅_]══╡             └──█████████
                   └──█████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐
        [̅_̅_̅_̅_̅_̅_̅_]══╡             └─→█████████
                   └──█████████─ ┘

√                         ↓

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐
        [̅_̅_̅_̅_̅_̅_̅_]══╡             ╞══█████████
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──█████████──┐
        [̅_̅_̅_̅_̅_̅_̅_]══╡             └─→[̅_̅_̅_̅_̅_̅_̅_]
                   └──█████████─ ┘

√                         ↓

                   ┌──█████████──┐
        [̅_̅_̅_̅_̅_̅_̅_]══╡             ╞══[̅_̅_̅_̅_̅_̅_̅_]
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙



    Activating
    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        █████████─────[̅_̅_̅_̲̅√̅_̅_̅_]
√                  ↓
        [̅_̅_̅_̅_̅_̅_̅_]─────█████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        [̅_̅_̅_̲̅√̅_̅_̅_]─────█████████
√                  ↓
        █████████─────[̅_̅_̅_̅_̅_̅_̅_]

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──[̅_̅_̅_̲̅√̅_̅_̅_]
        █████████══╡
                   └──[̅_̅_̅_̅_̅_̅_̅_]
√                 ↓
                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]══╡
                   └──[̅_̅_̅_̅_̅_̅_̅_]

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]══╡
                   └──[̅_̅_̅_̲̅√̅_̅_̅_]
√                 ↓
                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]══╡
                   └──█████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──█████████
        [̅_̅_̅_̲̅√̅_̅_̅_]══╡
                   └──█████████
√                 ↓
                   ┌──[̅_̅_̅_̅_̅_̅_̅_]
        █████████══╡
                   └──[̅_̅_̅_̅_̅_̅_̅_]

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──[̅_̅_̅_̲̅√̅_̅_̅_]──┐
        █████████══╡             ╞══[̅_̅_̅_̅_̅_̅_̅_]
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘

√                         ↓

                   ┌──█████████──┐
        [̅_̅_̅_̅_̅_̅_̅_̅]══╡             ╞══[̅_̅_̅_̅_̅_̅_̅_]
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──█████████──┐
        [̅_̅_̅_̅_̅_̅_̅_̅]══╡             ╞══[̅_̅_̅_̅_̅_̅_̅_]
                   └──[̅_̅_̅_̲̅√̅_̅_̅_]──┘

√                         ↓

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐
        [̅_̅_̅_̅_̅_̅_̅_̅]══╡             ╞══[̅_̅_̅_̅_̅_̅_̅_]
                   └──█████████──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐
        [̅_̅_̅_̅_̅_̅_̅_̅]══╡             ╞══[̅_̅_̅_̲̅√̅_̅_̅_]
                   └──█████████──┘

√                         ↓

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐
        [̅_̅_̅_̅_̅_̅_̅_̅]══╡             ╞══█████████
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙



    Disconnecting
    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        [̅_̅_̅_̅_̅_̅_̅_]──╳──█████████
√                  ↓
        █████████     █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        █████████──╳──[̅_̅_̅_̅_̅_̅_̅_]
√                  ↓
        █████████     █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        █████████─────[̅_̅_̅_̅_̅_̅_̅_]──╳──[̅_̅_̅_̅_̅_̅_̅_]
√                  ↓
        █████████─────[̅_̅_̅_̅_̅_̅_̅_]     █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]══╡
                   ╳──█████████
√                 ↓
                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]──┘
                      █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]
        █████████══╡
                   ╳──[̅_̅_̅_̅_̅_̅_̅_]
√                 ↓
                   ┌──[̅_̅_̅_̅_̅_̅_̅_]
        █████████──┘
                      █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        [̅_̅_̅_̅_̅_̅_̅_]──┐
                   ╞══█████████
        [̅_̅_̅_̅_̅_̅_̅_]──╳

√                 ↓

        [̅_̅_̅_̅_̅_̅_̅_]──┐
                   └──█████████
        █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        █████████──┐
                   ╞══[̅_̅_̅_̅_̅_̅_̅_]
        [̅_̅_̅_̅_̅_̅_̅_]──╳

√                 ↓

        █████████──┐
                   └──[̅_̅_̅_̅_̅_̅_̅_]
        █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        [̅_̅_̅_̅_̅_̅_̅_]──┐
                   ╞══[̅_̅_̅_̅_̅_̅_̅_]
        █████████──╳

√                 ↓

        [̅_̅_̅_̅_̅_̅_̅_]──┐
                   └──█████████
        █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙



    Deleting
    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                         ╲ ╱
        [̅_̅_̅_̅_̅_̅_̅_]─────████╳████
√                  ↓     ╱ ╲
        █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
           ╲ ╱
        [̅_̅_̅_╳̅_̅_̅_]─────█████████
√          ╱ ╲     ↓
                      █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

           ╲ ╱
        ████╳████─────[̅_̅_̅_̅_̅_̅_̅_]
√          ╱ ╲     ↓
                      █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                         ╲ ╱
        █████████─────[̅_̅_̅_╳̅_̅_̅_]
√                  ↓     ╱ ╲
        █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                         ╲ ╱
        [̅_̅_̅_̅_̅_̅_̅_]─────████╳████─────[̅_̅_̅_̅_̅_̅_̅_]
√                        ╱ ╲
        █████████         ↓         █████████


    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

        [̅_̅_̅_̅_̅_̅_̅_]──┐     ╲ ╱
                   ╞══████╳████
        [̅_̅_̅_̅_̅_̅_̅_]──┘     ╱ ╲

√                 ↓

        █████████

        █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

           ╲ ╱     ┌──[̅_̅_̅_̅_̅_̅_̅_]
        ████╳████══╡
           ╱ ╲     └──[̅_̅_̅_̅_̅_̅_̅_]

√                 ↓

                      █████████

                      █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

                   ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐     ╲ ╱
        [̅_̅_̅_̅_̅_̅_̅_]══╡             ╞══████╳████
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘     ╱ ╲

√                         ↓

                   ┌──█████████
        [̅_̅_̅_̅_̅_̅_̅_]══╡
                   └──█████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙

           ╲ ╱     ┌──[̅_̅_̅_̅_̅_̅_̅_]──┐
        ████╳████══╡             ╞══[̅_̅_̅_̅_̅_̅_̅_]
           ╱ ╲     ╟──[̅_̅_̅_̅_̅_̅_̅_]──┘
                   │
                   └──[̅_̅_̅_̅_̅_̅_̅_]

√                         ↓

                      █████████──┐
                                 ╞══[̅_̅_̅_̅_̅_̅_̅_]
                      [̅_̅_̅_̅_̅_̅_̅_]──┘

                      █████████

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
                         ╲ ╱
                   ┌──████╳████──┐
        [̅_̅_̅_̅_̅_̅_̅_]══╡     ╱ ╲     ╞══[̅_̅_̅_̅_̅_̅_̅_]
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘

√                         ↓

        █████████──┐             ┌──[̅_̅_̅_̅_̅_̅_̅_]
                   └──[̅_̅_̅_̅_̅_̅_̅_]──┘

    ∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙∙
*/



graphView.activeNodes = [];



function uiCreateNode(opType, creatingButton, createdId = -1, updateUi = true)
{
    let node = createNode(opType, creatingButton, createdId);

    graph.addNode(node);

    uiSaveNodesAndConns([node.id]);


    // if (graphView.selectedNodes.length > 0)
    // {
    //     const selNode = graph.nodes.find(n => n.selected);
    //     const inputs  = node.inputs.filter(i => i.dataType == selNode.dataType);

    //     if (   !!selNode
    //         && selNode.output
    //         && inputs.length > 0)
    //         uiConnect(selNode.output, inputs[0]);
    // }


    if (updateUi)
    {
        graphView.lastSelectedNodes = graphView.selectedNodes;
        graphView.selectedNodes     = [node];

        //node.pushUpdate();

        //graphView.putNodeOnTop(node);
        //graphView.updateNodeTransform(node);

        //updateGraphNodes();
    }


    return node;
}



function uiDeleteNodes(nodeIds, actionId)
{
    graph.deleteNodes(nodeIds);

    uiRemoveSavedNodesAndConns(nodeIds);
    uiDeleteCanvasObjects(nodeIds);
}



// function uiUndeleteNodes(nodes, nodePos, actionId)
// {
//     graph.addNodes(nodes);


//     graphView.selectedNodes = nodes;

//     graphView.putNodeOnTop(lastOf(nodes));

//     for (let i = 0; i < nodes.length; i++)
//     {
//         setNodePosition(
//             nodes[i],
//             nodePos[i].x,
//             nodePos[i].y);
//     }


//     // uiPostMessageToGenerator({
//     //     msg:       'genUndeleteNodes',
//     //     uiActionId: actionId
//     // });
// }



function uiDeleteCanvasObjects(nodeIds)
{
    uiPostMessageToFigma({
        cmd:    'figDeleteCanvasObjects',
        nodeIds: nodeIds
    });
}



function uiSetNodeId(nodeId, newId)
{
    const node = nodeFromId(nodeId);

    node.id = newId;
}



function uiVariableConnect(outputOp, outputIndex, inputOp, inputIndex)
{
    //console.log('uiVariableConnect()');

    if (inputOp._variableInputs)
    {
        const input = lastOf(inputOp.inputs);

        uiConnect(
            outputOp.outputs[outputIndex],
            input,
            inputIndex);
    }
    else
    {
        uiConnect(
            outputOp.outputs[outputIndex],
             inputOp. inputs[ inputIndex]);
    }
}



function uiConnect(output, input, inputIndex = -1)
{
    const conn = graph.connect(output, input, inputIndex);

    uiSaveConnection(
        output.op.id,
        output.op.outputs.indexOf(output),
        input.op.id,
        input.op.inputs.indexOf(input),
        conn.toJson());

    return conn;
}



function uiDisconnect(input)
{
    uiRemoveSavedConnection(
        input.connectedOutput.op.id,
        input.connectedOutput.op.outputs.indexOf(input.connectedOutput),
        input.op.id,
        input.op.inputs.indexOf(input));

    const inputOp = input.op;

    graph.disconnect(input);

    // uiPostMessageToGenerator({
    //     msg: 'genDisconnect',
    //     input:
    //     {
    //         nodeId: input.op.id,
    //         index:  input.op.inputs.indexOf(input)
    //     }
    // });
}



function uiMakeNodeActive(node)
{
    uiMakeNodeLeftPassive (node);
    uiMakeNodeRightPassive(node);

    node._active = true;

    if (!graphView.activeNodes.includes(node))
        graphView.activeNodes.push(node);

    uiPostMessageToFigma({
        cmd:   'figSaveActiveNode',
        nodeId: node.id
    });

    // if (node.dataType == 'object')
    //     uiGenerateObjects([node.id]);

    node.updateNode();
    node.pushUpdate();
}



// function uiMakeNodesActive(nodes)
// {
//     for (const node of nodes)
//     {
//         uiMakeNodePassive(node);
//         uiMakeNodeLeftPassive (node);
//         uiMakeNodeRightPassive(node);
//     }
    
//     for (const node of nodes)
//     {
//         node._active = true;

//         if (!graphView.activeNodes.includes(node))
//             graphView.activeNodes.push(node);

//         uiPostMessageToFigma({
//             cmd:   'figSaveActiveNode',
//             nodeId: node.id
//         });
    
//         // if (node.dataType == 'object')
//         //     uiGenerateObjects([node.id]);

//         node.updateNode();
//         node.pushUpdate();
//     }
// }



function uiMakeNodePassive(node)
{
    //if (node.active)
    //    uiDeleteCanvasObjects([node.id]);

    if (node.active)
    {
        removeFromArray(graphView.activeNodes, node);

        uiPostMessageToFigma({
            cmd:   'figRemoveSavedActiveNode',
            nodeId: node.id
        });
    }

    node._active = false;

    node.updateNode();
}



function uiMakeNodeLeftPassive(node, fromNode = null)
{
    for (const input of node.inputs)
    {
        if (input.isConnected)
        {
            //console.log(input.connectedOutput);
            uiMakeNodePassive(input.connectedOutput.op);
            uiMakeNodeLeftPassive(input.connectedOutput.op, node);
        }
    }

    // for (const output of node.outputs)
    // {
    //     for (const input of output.connectedInputs)
    //     {
    //         if (input.op != fromNode)
    //         {
    //             //console.log(input.connectedOutput);
    //             uiMakeNodePassive(input.op);
    //             uiMakeNodeRightPassive(input.op, node);
    //         }
    //     }
    // }
}



function uiMakeNodeRightPassive(node, fromNode = null)
{
    for (const output of node.outputs)
    {
        for (const connInput of output.connectedInputs)
        {
            uiMakeNodePassive(connInput.op);
            uiMakeNodeRightPassive(connInput.op, node);
        }
    }

    for (const input of node.inputs)
    {
        if (   input.isConnected
            && input.connectedOutput.op != fromNode)
        {
            //console.log(input.connectedOutput);
            uiMakeNodePassive(input.connectedOutput.op);
            uiMakeNodeLeftPassive(input.connectedOutput.op, node);
        }
    }
}



function getActiveNodeInBranchFrom(node, alreadyChecked = [])
{
    if (node.active) return node;


    const nodeInputs = [...node.inputs.filter(i => i.isConnected)];

    if (    nodeInputs.length == 1
        && !alreadyChecked.includes(nodeInputs[0].connectedOutput.op))
    {
        const leftActive = getActiveNodeInBranchFrom(
            nodeInputs[0].connectedOutput.op, 
            [...alreadyChecked, node]);

        if (leftActive) return leftActive;
    }


    const nodeOutputs = [...node.outputs.filter(o => o.connectedInputs.length == 1)];

    if (    nodeOutputs.length == 1
        && !alreadyChecked.includes(nodeOutputs[0].connectedInputs[0].op))
    {
        const rightActive = getActiveNodeInBranchFrom(
            nodeOutputs[0].connectedInputs[0].op, 
            [...alreadyChecked, node]);

        if (rightActive) return rightActive;
    }


    return null;
}



function getActiveNodeInTreeFrom(node, alreadyChecked = [])
{
    if (node.active) return node;


    const leftActive = getActiveNodeLeftInTreeFrom(node, [...alreadyChecked]);
    if (leftActive) return leftActive;


    for (const output of node.outputs)
    {
        for (const input of output.connectedInputs)
        {
            if (!alreadyChecked.includes(input.op))
            {
                const rightActive = getActiveNodeInTreeFrom(
                    input.op, 
                    [...alreadyChecked, node]);

                if (rightActive) return rightActive;
            }
        }
    }


    return null;
}



function getActiveNodeLeftInTreeFrom(node, alreadyChecked = [])
{
    if (node.active) return node;


    for (const input of node.inputs)
    {
        if (    input.isConnected
            && !alreadyChecked.includes(input.connectedOutput.op))
        {
            const leftActive = getActiveNodeInTreeFrom(
                input.connectedOutput.op, 
                [...alreadyChecked, node]);

            if (leftActive) return leftActive;
        }
    }


    return null;
}



function getActiveNodesInTreeFrom(node, alreadyChecked = [])
{
    const activeNodes = [];


    if (node.active) 
        activeNodes.push(node);


    for (const input of node.inputs)
    {
        if (    input.isConnected
            && !alreadyChecked.includes(input.connectedOutput.op))
        {
            const leftActive = getActiveNodesInTreeFrom(input.connectedOutput.op, [...alreadyChecked, node]);
            
            // if (leftActive.length > 0) 
            // {
                activeNodes.push(...leftActive);
            //    break;
            // }
        }
    }


    for (const output of node.outputs)
    {
        for (const input of output.connectedInputs)
        {
            if (!alreadyChecked.includes(input.op))
            {
                const rightActive = getActiveNodesInTreeFrom(input.op, [...alreadyChecked, node]);
                
                // if (rightActive.length > 0) 
                // {
                    activeNodes.push(...rightActive);
                //    break;
                // }
            }
        }
    }


    return activeNodes;
}



function uiShowParamValue(nodeId, paramName, value)
{
    const node = nodeFromId(nodeId);

    if (!!node) // this is for deleted nodes which still exist
    {           // in genGraph but no longer in graph
        const param = node.params.find(p => p.name == paramName);
        param.control.setValue(value, false);
    }
}



function uiCopyNodes(nodeIds)
{
    const nodes      = graph.nodes.filter(n => nodeIds.includes(n.id));
    const copiedJson = nodesToJson(nodes, true, false);

    //log(copiedJson);

    return copiedJson;
}



function uiPasteNodes(nodesJson, pasteOutsideConnections)
{
    graphView.loadingNodes = true;


    pasteOffset[0] += pasteOffsetDelta[0];
    pasteOffset[1] += pasteOffsetDelta[1];


    const data  = JSON.parse(nodesJson);


    // offset new nodes (must be done before loading)
    for (let i = 0; i < data.nodes.length; i++)
    {
        data.nodes[i].x = parseFloat(data.nodes[i].x) + pasteOffset[0] / graphView.zoom;
        data.nodes[i].y = parseFloat(data.nodes[i].y) + pasteOffset[1] / graphView.zoom;
    }


    const nodes = loadNodes(data);

    // get the new names of the nodes after they've been added
    for (let i = 0; i < nodes.length; i++)
    {
        graph.addNode(nodes[i], false);
        data.nodes[i].newId = nodes[i].id;
    }

    if (data.connections)
    {
        correctNodeNamesInConnections(data);
        loadConnections(data, pasteOutsideConnections);
    }

    graphView.selectedNodes = nodes;


    graphView.loadingNodes = false;
    return nodes;
}



function correctNodeNamesInConnections(data)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];

        let outputOpIndex = data.nodes.findIndex(n => n.id == _conn.outputOp);
        if (outputOpIndex > -1) data.connections[i].outputOp = data.nodes[outputOpIndex].newId;

        const inputOpIndex = data.nodes.findIndex(n => n.id == _conn. inputOp);
        data.connections[i].inputOp = data.nodes[inputOpIndex].newId;
    }
}



function updateGraphNodes()
{
    for (const node of graphView.selectedNodes)      node.updateNode();
    for (const node of graphView._prevSelectedNodes) node.updateNode();
    for (const node of graphView.lastSelectedNodes)  node.updateNode();
}



function uiUpdateNodes(nodeIds)
{
    if (graph.mutex)
    {
        for (const nodeId of nodeIds)
            graph.deferNodeIds.push(nodeId);

        return;
    }


    graph.mutex = true;


    // uiPostMessageToGenerator({
    //     msg:    'genUpdateObjects',
    //     nodeIds: nodeIds
    // });
}



function uiUpdateGraph()
{
    graph.mutex = false;


    if (graph.deferNodeIds.length > 0)
    {
        let deferNodes = Array.from(graph.deferNodeIds).filter(
            (value, index, self) => self.indexOf(value) === index);

        graph.deferNodeIds = [];

        uiUpdateNodes(deferNodes);
    }
}



function uiUpdateCanvasObjects(objects)
{
    //uiUpdateGraph();

    uiPostMessageToFigma({
        cmd:    'figUpdateCanvasObjects',
        objects: objects
    });
}



function uiSaveNodesAndConns(nodeIds)
{
    const nodes    = graph.nodes.filter(n => nodeIds.includes(n.id));
    const nodeJson = [];

    for (const node of nodes)
    {
        nodeJson.push(node.toJson());
        //log(node.toJson());
    }

    uiPostMessageToFigma({
        cmd:     'figSaveNodesAndConns',
        nodeIds:  nodeIds,
        nodeJson: nodeJson
    });
}



function uiRemoveSavedNodesAndConns(nodeIds)
{
    uiPostMessageToFigma({
        cmd:    'figRemoveSavedNodesAndConns',
        nodeIds: nodeIds
    });
}



function uiRemoveAllSavedNodesAndConns()
{
    uiPostMessageToFigma({
        cmd: 'figRemoveAllSavedNodesAndConns'
    });
}



function uiLogAllSavedNodesAndConns()
{
    uiPostMessageToFigma({
        cmd: 'figLogAllSavedNodesAndConns'
    });
}



function uiSaveConnection(outputOpId, outputIndex, inputOpId, inputIndex, connJson)
{
    uiPostMessageToFigma({
        cmd: 'figSaveConnection',
        name: outputOpId  + ' '
            + outputIndex + ' '
            + inputOpId   + ' '
            + inputIndex,
        json: connJson
    });
}



function uiRemoveSavedConnection(outputOpId, outputIndex, inputOpId, inputIndex)
{
    uiPostMessageToFigma({
        cmd: 'figRemoveSavedConnection',
        name: outputOpId  + ' '
            + outputIndex + ' '
            + inputOpId   + ' '
            + inputIndex
    });
}


// function checkAddMenuItemProductKey(menuSelectItems)
// {
//     if (!validateProductKey(currentUser.id, productKey))
//         menuSelectItems.push({value: 'productKey', text: 'Enter product key'});
// }



// function removeMenuItemProductKey()
// {
//     let index = menuSelect.items.findIndex(item => item.value == 'productKey');
//     removeAt(menuSelect.items, index);
//     menuSelect.updateItems();
// }



function uiError(text, delay = 6000)
{
    uiNotify(text, 'Generator error: ', delay, true);
}



function uiNotify(text, prefix = 'Generator: ', delay = 4000, error = false)
{
    uiPostMessageToFigma({ 
        cmd:   'figNotify',
        text:   text,
        prefix: prefix,
        delay:  delay,
        error:  error
    });        
}


document.canResizeX = false;
document.canResizeY = false;
   
document.resizingX  = false;
document.resizingY  = false;

document.startRect  = new Rect();



window.addEventListener('keydown',       e => e.preventDefault());

window.addEventListener('gesturestart',  e => e.preventDefault());
window.addEventListener('gesturechange', e => e.preventDefault());
window.addEventListener('gestureend',    e => e.preventDefault());



function checkResize(x, y)
{
    const resizeEdgeWidth = 8;

    document.canResizeX = document.body.clientWidth  - x <= resizeEdgeWidth;
    document.canResizeY = document.body.clientHeight - y <= resizeEdgeWidth;

         if (document.canResizeX
          && document.canResizeY) setCursor('nwse-resize', false); 
    else if (document.canResizeX) setCursor('ew-resize',   false);   
    else if (document.canResizeY) setCursor('ns-resize',   false);   
    else                          setAutoCursor();
}



function uiResizeWindow(width, height)
{
    uiPostMessageToFigma({ 
        cmd:   'figResizeWindow', 
        width:  width,
        height: height
    });
}



function uiEndResizeWindow()
{
    graphView.updatePanAndZoom();

    btnZoom.style.top  = 0;
    btnZoom.style.left = window.innerWidth - btnZoom.offsetWidth;

    btnToggleWires.style.top  = 0;
    btnToggleWires.style.left = btnZoom.offsetLeft - btnToggleWires.offsetWidth;
}


const licenseKeys     = createCryptoKeys();
const licenseHashSize = 4;



function createProductKey(name)
{
    var hash = hashLicenseName(name, licenseHashSize);
    var enc  = sign(hash, licenseKeys.private);
    var key  = arrayToBase32(enc);

    return key;
}



function validateProductKey(name, key, rec = false)
{
    // TODO: check from today until 1 year from now (max license length)
    // 1/day, so 365 max, add end day to name
    // check today against last launch date (in private data) to prevent clock tampering

    var arr  = base32toArray(key.toUpperCase());
    var dec  = verify(arr, licenseKeys.public).subarray(licenseHashSize);
    var trim = dec.subarray(dec.length - licenseHashSize);
    var hash = hashLicenseName(name, licenseHashSize);
    
    var valid = arraysEqual(trim, hash);

    if (valid && !rec)
    {
        var lowerKey  = key;

        var lastChar  = lowerKey[lowerKey.length-1];
        var lastIndex = base32chars.indexOf(lastChar);

        if (lastIndex > 0)
        {
            lowerKey = replaceInStringAt(lowerKey, lowerKey.length-1, base32chars[lastIndex-1]);

            if (validateProductKey(name, lowerKey, true))
                return false; // at this scale of product key the last bit needs to be guarded against
        }
    }

    return valid;
}



function hashLicenseName(name, nBytes)
{
    // XOR wrap name around a given number of bytes

    var bytes = stringToArray(name);

    if (bytes.length > nBytes)
    {
        var pos    = nBytes;
        var length = bytes.length - nBytes;
        
        while (length > 0)
        {
            for (var i = 0; i < nBytes; i++)
                bytes[i] ^= bytes[pos+i];
            
            pos    += nBytes;
            length -= nBytes;
        }
    }
    

    return newSizeArrayFrom(bytes, nBytes);
}


var productKey = '';



function showProductKeyDialog()
{
    productKeyBack  .style.display = 'block';
    productKeyDialog.style.display = 'block';

    productKeyUserInfo.innerHTML = '<span style="user-select: none; color: #aaa;">User ID: </span>' + currentUser.id;

    setDefaultProductKeyInput();
    productKeyInputBack.innerHTML = '•'.repeat(13);
    productKeyInput.value = '';
    
    //menuSelect.setSelectedIndex(0);
    
    window.setTimeout(() => document.getElementById('productKeyInput').focus(), 0);
}



function hideProductKeyDialog()
{
    productKeyBack  .style.display = 'none';
    productKeyDialog.style.display = 'none';
}



productKeyBack.addEventListener('pointerdown', () =>
{
    hideProductKeyDialog();
});



productKeyInput.addEventListener('input', () =>
{
    let val = productKeyInput.value;
    
    val = val.toUpperCase();
    val = val.replace(/[^12345679ABCDEFGHJKLMNPQRSTUVWXYZ]/g, '');
    val = val.substring(0, Math.min(val.length, 13));
    
    productKeyInput.value = val;

    productKeyInputBack.innerHTML = 
          '&nbsp;'.repeat(val.length)
        + '•'.repeat(13 - val.length);

    
    if (val.length == 13)
    {
        if (validateProductKey(currentUser.id, val))
        {
            productKey = val;        
            uiSetLocalData('productKey', productKey);
            
            productKeyInput.blur();
            setGoodProductKeyInput();
            
            window.setTimeout(() => 
            {
                hideProductKeyDialog();
                //updateMenuSelectItems();

                uiNotify('✨ Thank you for subscribing to Generator! ✨', '', 6000);    
            }, 
            1200);
        }
        else
            setBadProductKeyInput();
    }
    else
        setDefaultProductKeyInput();
});



function setBadProductKeyInput()
{
    productKeyInput.style.outline   = '2px dashed #e00';        
    productKeyInput.style.boxShadow = 'none';
}



function setGoodProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px #0b0';
}



function setDefaultProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px ' + colorStyleRgb(rgbActiveObject); 
}




////////////////////////////////////////////////////

</script>
