<link href="https://fonts.googleapis.com/css2?Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<style>


.button
{
    font-family:   Inter;
    font-size:     11px;
    width:         30;
    height:        30;
    background:    white;
    min-width:     0;
    min-height:    0;
    border:        none;
    border-radius: 2px;
    position:      relative;
    padding:       0;
}


.button:hover
{
    background: #f0f0f0;
}


.button:active
{
    box-shadow: 0 0 0 2px var(--activeObjectColor) inset;
    outline:    none;
}


#controlBar
{
    display:          block;
    height:           40px;
    background-color: #2c2c2c;
    /* vertical-align:   middle; */
    padding:          0;
}


body
{
    margin:           0;
    background-color: #f4f4f4;
    user-select:      none;
}


div
{
    margin:  0;
    padding: 0;
}


#graphView
{
    display:  block;
    overflow: hidden;
    height:   calc(100% - 40px);
    position: relative;
}


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    height:        28px;
    padding-top:   1;
    border:        none;
    box-shadow:    0px 1px 0px 0px rgba(0, 0, 0, 0.1);
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:hover
{
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}


input[type=text]:focus
{
    box-shadow: 0 0 0 1px var(--activeObjectColor);
    outline: none;
}


input[type=text]::selection
{
    background-color: #b9e2fe;
}



#loadingOverlay
{
    position:   absolute;
    top:        0;
    left:       0;
    width:      100%;
    height:     100%;
    background: #e5e5e5;
    display:    none;
}


#loadingGraphic 
{
    font-family: Inter;
    font-size:   26;
    font-weight: 700;
    color:       #333;
    position:    absolute;
    left:        50%;
    top:         45%;
    transform:   translateX(-50%)
                 translateY(-50%);
}


#loadingEmpty
{
    font-size:   12;
    color:       #666;
    margin-right: 6px;
    position:     relative;
    top:          -4px;
}


#loadingFull
{
    font-size:   8;
    color:       #666;
    margin-left: 7px;
    position:     relative;
    top:          -6px;
}


#loadingBar
{
    position:      absolute;
    left:          50%;
    top:           50%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         180px;
    height:        5px;   
    background:    white;
    border-radius: 2.5px;
    overflow:      hidden;
}


#loadingProgress
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         0;
    height:        5px;   
    background:    #333;
}


.menuButton
{
    font-family:     Inter;
    font-size:       11px;
    width:           40px;
    height:          40px;
    background:      #2c2c2c;
    border-radius:   0;
    min-width:       0;
    min-height:      0;
    border:          none;
    position:        relative;
    padding:         0;
    padding-top:     1px;
    padding-bottom: -1px;
    margin-right:   -4px;
    color:          #d5d5d5;
}


.menuButton:hover
{
    background: black;
    color:      white;
}


.menuButton:focus
{
    background: var(--activeObjectColor);
    color:      white;
}


#btnCreateNumber
{
    padding-left:  15px;
    padding-right: 35px;
}


#btnZoom
{
    position: absolute;
    padding-left:  15px;
    padding-right: 45px;
}


#btnToggleWires
{
    position: absolute;
    padding-left: 3px;
    padding-right: 30px;
    background: url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="white" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="white"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat: no-repeat;
}


#productKeyBack
{
    display:          none;

    z-index:          1;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;

    background-color: #0002
}


#productKeyDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    top:           60px;
    left:          calc(50% - 130px);
    width:         220px;
    height:        170px;
    
    background:    white;
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);
    box-shadow:    0px 2px 14px rgba(0, 0, 0, 0.15);
    border-radius: 4px;
}


#productKeyTitle
{
    height:        40px;
    border-bottom: 1px solid rgb(0, 0, 0, 0.15);
}


#productKeyText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          rgba(0, 0, 0, 0.8);
}


#productKeyClose
{
    width:    32px;
    height:   32px;
    position: absolute;
    left:     calc(100% - 36px);
    top:      4px;
}

#productKeyClose:active
{
    box-shadow: none;
}


#productKeyUserInfo
{
    font-size:      12px;

    margin-top:     16px;
    margin-bottom:  12px;

    position:       relative;
    left:           21px;

    user-select:    text;
}


#productKeyWebsite
{
    font-size:      12px;
    text-align:     center;

    margin-top:     16px;
    margin-bottom:   8px;
}


#productKeyInput
{
    font-family:  'Roboto Mono';
    font-size:     16px;
     
    width:         calc(9em + 1px);
    padding-left:  10px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-bottom: -3px;

    position:      relative;
    left:          calc(50% - 4.5em);
}



#productKeyInputBack
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    color:          #ddd;
    
    width:           9em;
    padding-left:   10px;
    padding-top:    -2px;
    padding-bottom:  2px;

    position:       absolute;
    left:           calc(calc(50% - 4.5em) + 1px);
    top:            calc(50% + 2px);

    pointer-events: none;
}


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    height:        28px;
    padding-top:   1;
    border:        none;
    box-shadow:    0px 1px 0px 0px rgba(0, 0, 0, 0.1);
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:hover
{
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}


input[type=text]:focus
{
    box-shadow: 0 0 0 2px var(--activeObjectColor);
    outline:    none;
}


input[type=text]::selection
{
    background-color: #b9e2fe;
    color:            black;
}


:root
{
    --activeObjectColor:    #18a0fb;
}


#selectBox
{
    outline:          1pt solid var(--activeObjectColor);
    background-color: #18A0FB20;
    pointer-events:   none;
    margin:           0;
    padding:          0;
    position:         absolute;
    visibility:       hidden;
}


#scrollbarX
{
    background-color: #a7a7a7;
    height:           6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);
}


#scrollbarY
{
    background-color: #a7a7a7;
    width:            6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);
}


:root
{
    --arithmeticSymbolSize: 26;
    --colorBackSize:        45px;
}


#graphView
{
    z-index:  0;
    overflow: hidden;
    /* box-shadow: 0 0 0 1px red inset;
    background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 10 10'> <path d='M0 0 L0 10 L10 10' fill='red' /></svg>");
    background-repeat:no-repeat;
    background-position:center center;
    background-size: 100% 100%, auto; */
}


#wireContainer
{
    position:       absolute;
    width:          100%;
    height:         calc(100% - 1px);
    z-index:        0;
    pointer-events: none;
    /* box-shadow: 0 0 0 1px red inset; */
}


.toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="black"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="black"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.toggleButton:hover
{
    /* background:            url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 1C4.10457 1 5 1.89543 5 3V5H6V3C6 1.34315 4.65685 0 3 0C1.34315 0 0 1.34315 0 3V5H1V3C1 1.89543 1.89543 1 3 1Z" fill="black"/><path d="M5 9H6V11C6 12.6569 4.65685 14 3 14C1.34315 14 0 12.6569 0 11V9H1V11C1 12.1046 1.89543 13 3 13C4.10457 13 5 12.1046 5 11V9Z" fill="black"/><path d="M2.5 4V10H3.5V4H2.5Z" fill="black"/></svg>');
    background-position:   50% 50%;
    background-repeat:     no-repeat;
    background-blend-mode: multiply; */
    /* background-color:      #f0f0f0; */
    box-shadow: 0 0 0 1px #e6e6e6
}


.toggleButton:active
{
    box-shadow: 0 0 0 2px #18A0FB;
}


.numberSlider
{
    padding:          0;
    width:            74px;
    height:           26px;
    overflow:         hidden;
    background-color: white;
    text-align:       center;
}    


.numberSliderName
{
    color: #0006;
}


.numberSliderBar
{
    position:       absolute;
    pointer-events: none;
}


.numberSliderText
{
    font-family:          Inter;
    font-size:            11;
    pointer-events:       none;
    font-variant-numeric: tabular-nums;
    letter-spacing:       -0.35px;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    top:                  3px;
    white-space:          nowrap;
}


.numberSliderText .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
}


.numberSliderTextbox
{
    font-family:    Inter;
    font-size:      11;
    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);
    white-space:    nowrap;
}


.numberSliderFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px var(--activeObjectColor) inset;
    visibility:     hidden;
    opacity:        0;
}


.numberSliderRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}




.menuSelect
{
    font-family:         Inter;
    font-size:           14;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         1;
    margin-right:        6;
    margin-top:          0;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
    color:               white;
}


.menuSelect:hover
{
    /* box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1); */
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) calc(50% + 3px);
    background-repeat:   no-repeat;
    padding-right:       30;
    transition:          all 0.2s ease;
}


.menuSelect:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.menuSelectText
{
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
    position:       relative;
    top:            3px;
}


.menuSelectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px  7px rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2 );
    /* overflow:      hidden; */
}


.menuSelectMenu::after 
{
    content:       '';
    position:      absolute;
    top:           -10px;
    left:          65px;
    border-width:  5px;
    border-style:  solid;
    border-color:  transparent transparent #222 transparent;
}




.select
{
    font-family:         Inter;
    font-size:           11;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         2;
    margin-right:        6;
    margin-top:          1;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.4"/> </svg>');
    background-position: calc(100% - 17px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
}


.select:hover
{
    box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1);
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 7px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
}


.select:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 6px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.selectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px 7px  rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2);
    overflow:      hidden;
}


.inputControls
{
    width:          12px;
    height:         auto;
    float:          left;
    margin-right:   auto;
    padding-top:    13px;
    /* box-shadow:     0 0 0 1px red inset; */
    pointer-events: none;
}


.input
{
    width:          6px;
    height:         6px;
    background:     transparent;
    border-radius:  3px;
    margin:         0;
    /* margin-left:    0px; */
    position:       absolute;
    left:           3px;
    pointer-events: none;
    box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12);
}


.inputBall
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    top:            50%;
    left:           50%;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.inputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: auto;
}


.node
{
    display:       block;
    position:      absolute;
    height:        auto;
    border-radius: 4px 4px 0 0;
    padding:       0;
    /* overflow:      visible; */
}


.nodeInner
{
    display:       block;
    position:      relative;
    width:         100%;
    height:        auto;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    padding:       0;
    box-shadow:    0 0 0 1px #0001;
    overflow:      visible;
}    


.nodeHeader
{
    background:    'magenta';
    display:       flex;
    width:         100%;
    position:      relative;
    border-radius: 4px 4px 0 0;
    z-index:       1;
    /* overflow:      visible; */
}


.nodeParamBack
{
    display:    block;
    position:   absolute;
    width:      100%;
    height:     20;
    background: #fffe;
    z-index:    -1;
}


.nodeLabelWrapper
{
    position:   absolute;
    width:      100%;
    height:     100%;   
    /* box-shadow: 0 0 0 1px blue inset; */
}


.nodeLabel
{
    font-family:    Inter;
    font-size:      11;
    padding:        0;
    margin:         0;
    display:        block;
    width:          auto;
    height:         14;
    text-align:     center;
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-50%) 
                    translateY(calc(-50% - 0.5px));
    pointer-events: none;
    z-index:        10;
    white-space:    nowrap;
    /* box-shadow:     0 0 0 1px red inset; */
}


.nodeLabelTextbox
{
    font-family: Inter;
    font-size:   11;
}


.nodeLabelTextbox::selection
{
    background-color: white;
}



.arithmeticSymbol
{
    font-family:    Inter;
    font-size:      20px;
    width:          auto;/*var(--arithmeticSymbolSize);*/
    height:         auto;/*var(--arithmeticSymbolSize);*/
    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);
    /* pointer-events: none; */
    /* box-shadow:     0 0 0 1px red inset; */
}


.colorWarningOverlay
{
    width:            100%;
    height:           var(--colorBackSize);
    z-index:          10;
    position:         absolute;
    top:              0;
    pointer-events:   none;
}


.colorValueWarningOverlay
{
    width:            100%;
    z-index:          1000;
    position:         absolute;
    top:              var(--colorBackSize);
    pointer-events:   none;
}


.colorBack
{
    width:            100%;
    height:           var(--colorBackSize);
    z-index:          0;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.outputControls
{
    width:          12px;
    height:         auto;
    float:          right;
    margin-left:    auto;
    padding-top:    10px;
    /* box-shadow:     0 0 0 1px green inset; */
    pointer-events: none;
}


.output
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    /* margin-left:    3px; */
    position: absolute;
    right:          3px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.outputBall
{
    width:          6px;
    height:         6px;
    border-radius:  6px;
    margin:         0;
    position:       relative;
    top:            -12px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.outputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: auto;
}


</style>

<div id='controlBar'>
    
    <!-- <div id='menuSelect' style='margin-left: 10px;'></div> -->
    
    <!-- &nbsp;
    <button class='menuButton' id='btnLoad'                   onclick='graph.clear(); Operator.nextId = 0; uiGetPluginData("graph"); this.blur();'>LOAD</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <button class='menuButton' id='btnSave'                   onclick='saveGraph(); this.blur();'>SAVE</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <button class='menuButton' id='btnCreateNumber'           onclick='actionManager.do(new CreateNodeAction("number"          )); this.blur();'>NUM</button>
    <button class='menuButton' id='btnCreateLimits'           onclick='actionManager.do(new CreateNodeAction("limits"          )); this.blur();'>LIM</button>
    <button class='menuButton' id='btnCreateAdd'              onclick='actionManager.do(new CreateNodeAction("add"             )); this.blur();'>ADD</button>
    <button class='menuButton' id='btnCreateSubtract'         onclick='actionManager.do(new CreateNodeAction("subtract"        )); this.blur();'>SUB</button>
    <button class='menuButton' id='btnCreateMultiply'         onclick='actionManager.do(new CreateNodeAction("multiply"        )); this.blur();'>MUL</button>
    <button class='menuButton' id='btnCreateDivide'           onclick='actionManager.do(new CreateNodeAction("divide"          )); this.blur();'>DIV</button>
    <button class='menuButton' id='btnCreateExponent'         onclick='actionManager.do(new CreateNodeAction("exponent"        )); this.blur();'>EXP</button>
    <button class='menuButton' id='btnCreateInterpolate'      onclick='actionManager.do(new CreateNodeAction("interpolate"     )); this.blur();'>INTR</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <button class='menuButton' id='btnCreateColor'            onclick='actionManager.do(new CreateNodeAction("color"           )); this.blur();'>COL</button>
    <button class='menuButton' id='btnCreateColorInterpolate' onclick='actionManager.do(new CreateNodeAction("colorinterpolate")); this.blur();'>INTR</button>
    <button class='menuButton' id='btnCreateWebContrast'      onclick='actionManager.do(new CreateNodeAction("webcontrast"     )); this.blur();'>CTR</button>
    <!-- <button class='menuButton' id='btnCreateColorblind'       onclick='actionManager.do(new CreateNodeAction("colorblind"      )); this.blur();'>BLND</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnCreateRectangle'        onclick='actionManager.do(new CreateNodeAction("rectangle"       )); this.blur();'>RECT</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <button class='menuButton' id='btnToggleWires'            onclick='graphView.toggleShowWires(); this.blur();'></button>

    <button class='menuButton' id='btnZoom'                   onclick='graphView.zoom = 1; this.blur();'></button>
    
</div>
    
<div id='selectBox'></div>

<div id='graphView'>
    <div id="wireContainer"></div>
    <div id='scrollbarX'></div>
    <div id='scrollbarY'></div>
</div>


<div id='loadingOverlay'>
    <div id='loadingGraphic'>
        <span id='loadingEmpty'>○</span>G<span id='loadingFull'>●</span>
    </div>
    <div id='loadingBar'>
        <div id='loadingProgress'></div>
    </div>
</div>


<div id='productKeyBack'></div>

<div id='productKeyDialog'>

    <div id='productKeyTitle'>
        <div id='productKeyText'>Enter product key</div>
        <div class='button' id='productKeyClose' onclick='productKeyClose.blur();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="black" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='productKeyBody'>
        <div id='productKeyUserInfo'></div>
        <input type='text' id='productKeyInput' />
        <div id='productKeyInputBack'></div>
        <div id='productKeyWebsite'>Get product key at<br/><a href='http://www.bourt.com/generator' target='_blank'>bourt.com/generator</a></div>
    </div>

</div>


<script id='generatorScript' type='javascript/worker'>



//const inputColor        = 'rgba(0, 0, 0, 0.12)';

const smallScrollGap    =  6;
const largeScrollGap    = 14;

const MAX_INT32         = 2147483647;


const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigitChar(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigitChar(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function getNumberString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    
    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] == getUserDecimalSeparator())
        //&& str[i] !== '.' 
        //&& str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
        // if (   str[i] === '.' 
        //     || str[i] === ',') // hack because JavaScript
        if (str[i] == getUserDecimalSeparator())
            str = str.substring(0, i--);
    }    

    return str;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    let last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function beforeLastOf(array)
{
    return array.length > 1 
         ? array[array.length-2]
         : null;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveIn(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}


function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return point(this.l, this.t); }
    get tc() { return point(this.c, this.t); }
    get tr() { return point(this.r, this.t); }
    get ml() { return point(this.l, this.m); }
    get mc() { return point(this.c, this.m); }
    get cm() { return point(this.c, this.m); }
    get mr() { return point(this.r, this.m); }
    get bl() { return point(this.l, this.b); }
    get bc() { return point(this.c, this.b); }
    get br() { return point(this.r, this.b); }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function getDecimalCount(strValue)
{
    const decIndex = strValue.indexOf(getUserDecimalSeparator());

    return decIndex >= 0
         ? strValue.length-1 - decIndex
         : 0;
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign({}, obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element, show = true) { element.style.visibility = show ? 'visible' : 'hidden'; }
function hide(element)              { element.style.visibility = 'hidden';  }

function isVisible(element) { return element.style.visibility == 'visible'; }


function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function removeFromArray(array, obj)
{
    var index = array.indexOf(obj);
    
    if (index > -1)
        array.splice(index, 1);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params));
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj, null).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '')
{
    const div = document.createElement('div');
    
    if (className.trim() != '')
        div.className = className;
    
    return div;
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function enableSliderText(slider, enable)
{
    slider.style.fontStyle = enable ? 'normal' : 'italic'; 
    slider.readOnly        = !enable;
}


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



// function readTextFromClipboard() 
// {
//     if (   navigator.clipboard 
//         && window.isSecureContext) 
//         return navigator.clipboard.readText();

//     else 
//     {
//         let textArea = document.createElement('textarea');

//         textArea.style.position = 'fixed';
//         textArea.style.left     = '-999999px';
//         textArea.style.top      = '-999999px';
        
//         document.body.appendChild(textArea);
        
//         textArea.focus();
//         textArea.select();
        
//         return new Promise((res, rej) => 
//         {
//             document.execCommand('paste') ? res(textArea.value) : rej();
//             textArea.remove();
//         });
//     }
// }


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;


class NoiseSeed
{
    initial;
    current;

    
    constructor()
    {
        this.reset();
    }
    
    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    
    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    
    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }

    reset()
    {
        this.current = this.initial;
    }
};


class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        var next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


/*

*/


const OBJ_RECT = 1;


//const genGraph          = new GGraph();
const deletedNodeArrays = []; // array of [id,nodeArray,actionId] tuples



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = function(e)
{
    switch (e.data.msg)
    {
        // case 'genCreateNode':    genCreateNode   (e.data.opType,   e.data.nodeId, e.data.nodeId); break; 
        // case 'genDeleteNodes':   genDeleteNodes  (e.data.nodeIds,  e.data.uiActionId);            break;             
        // case 'genUndeleteNodes': genUndeleteNodes(e.data.uiActionId);                             break;             
        // case 'genSetNodeId':     genSetNodeId    (e.data.nodeId,   e.data.newId);                 break; 
        // case 'genSetActive':     genSetActive    (e.data.nodeId,   e.data.active);                break;  // only state, no regeneration
        // case 'genConnect':       genConnect      (e.data.outputId, e.data.inputs);                break; 
        // case 'genDisconnect':    genDisconnect   (e.data.input);                                  break;
        // case 'genSetParam':      genSetParam     (e.data.nodeId,   e.data.param, e.data.value);   break;
        // case 'genInvalidate':    genInvalidate   (e.data.nodeId);                                 break;
        // case 'genUpdateObjects': genUpdateObjects(e.data.nodeIds);                                break;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////



function genPostMessageToUi(msg)
{
    postMessage(msg); // this call is too ambiguous to understand when reading code
}



///////////////////////////////////////////////////////////////////////////////////////////////////



// function genClearGraph()
// {
//     genGraph.clear();
// }



// function genCreateNode(type, id, name)
// {
//     const node = genGraph.createNode(type, id, name);
//     genGraph.addNode(node);

//     // on the UI side the node has already been created by this point

//     genPostMessageToUi({
//         msg:     'uiMakeActive',
//         nodeIds: [node.id]
//     });
// }



// function genDeleteNodes(nodeIds, uiActionId)
// {
//     var deleted = genGraph.deleteNodes(nodeIds);
//     deletedNodeArrays.push([uiActionId, deleted]);
// }



// function genUndeleteNodes(uiActionId)
// {
//     var deleted = deletedNodeArrays.find(n => n[0] == uiActionId);
//     var nodeIds = [];


//     for (const node of deleted[1])
//     {
//         genGraph.addNode(node);
//         nodeIds.push(node.id);
//     }

    
//     genPostMessageToUi({ 
//         msg:    'uiMakeActive',
//         nodeIds: nodeIds
//     });

    
//     removeFromArray(deletedNodeArrays, deleted);
// }



// function genSetNodeId(id, newId)
// {
//     const node = genGraph.nodeFromId(id);
//     node.id    = newId;
// }



// function genSetActive(nodeId, active)
// {
//     const node  = genGraph.nodeFromId(nodeId);
//     node.active = active;
// }



// function genConnect(outputId, inputs)
// {
//     const outNode = genGraph.nodeFromId(outputId);

//     for (const input of inputs)
//     {
//         const inNode = genGraph.nodeFromId(input.nodeId);

//         genGraph.connect(
//             outNode.output, 
//             input.index >= 0
//             ? inNode.inputs[input.index]
//             : inNode.params.find(p => p.name == input.param).input);

//         if (inNode.dataType == 'object')
//             genUpdateObjects([input.nodeId]);
//     }
// }



// function genDisconnect(input)
// {
//     const node = genGraph.nodeFromId(input.nodeId);
//     genGraph.disconnect(node.inputs[input.index]);
// }



// function genSetParam(nodeId, name, value)
// {
//     const node  = genGraph.nodeFromId(nodeId);
//     const param = node.params.find(p => p.name == name);

//     param.value = value;

//     updateNodeGraph(node);
// }



// function updateNodeGraph(_node)
// {
//     const node = genGraph.nodes.find(n => n.id == _node.id);

//     let activeId = activeNodeInTree(node).id;

//     if (activeId > -1)
//     {
//         genPostMessageToUi({ 
//             msg:    'uiUpdateNodes',
//             nodeIds: [activeId]
//         });
//     }
// }



// function genInvalidate(nodeId)
// {
//     const node = genGraph.nodes.find(n => n.id == nodeId);
//     node.valid = false;
// }



// function genUpdateObjects(nodeIds)
// {
//     for (const node of genGraph.nodes)
//         node.reset();


//     // first determine number of objects

//     let nObjects = 0;

//     for (const nodeId of nodeIds)
//     {
//         const node = genGraph.nodeFromId(nodeId);
//         const data = node.output.getData();
//         nObjects  += data.length;
//     }    

    
//     // now create the objects if necessary

//     if (nObjects > 0)
//     {
//         const objects = new Array(nObjects);

//         let i = 0;
//         for (const nodeId of nodeIds)
//         {
//             const node = genGraph.nodeFromId(nodeId);
//             const data = node.output.getData();
            
//             for (const obj of data)
//                 objects[i++] = obj;
//         }    

//         genPostMessageToUi({ 
//             msg:    'uiUpdateObjects',
//             objects: objects
//         });
//     }
//     // else
//     // {
//     //     genPostMessageToUi({ msg: 'uiUpdateGraph' });
//     // }
// }



function getObjectBounds(objects)
{
    var boundsL = Number.MAX_SAFE_INTEGER;
    var boundsT = Number.MAX_SAFE_INTEGER;
    var boundsR = Number.MIN_SAFE_INTEGER;
    var boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const obj of objects)
    {
        switch (obj[0])
        {
            case OBJ_RECT:
                boundsL = Math.min(boundsL, obj[3]);
                boundsT = Math.min(boundsT, obj[4]);
                boundsR = Math.max(boundsR, obj[3] + obj[5]);
                boundsB = Math.max(boundsB, obj[4] + obj[6]);
                break;
        }
    }

    return {
        x: boundsL, 
        y: boundsT,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
}


</script>


<script>

////////////////////////////////////////////////////


//const inputColor        = 'rgba(0, 0, 0, 0.12)';

const smallScrollGap    =  6;
const largeScrollGap    = 14;

const MAX_INT32         = 2147483647;


const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigitChar(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigitChar(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function getNumberString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    
    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] == getUserDecimalSeparator())
        //&& str[i] !== '.' 
        //&& str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
        // if (   str[i] === '.' 
        //     || str[i] === ',') // hack because JavaScript
        if (str[i] == getUserDecimalSeparator())
            str = str.substring(0, i--);
    }    

    return str;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    let last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function beforeLastOf(array)
{
    return array.length > 1 
         ? array[array.length-2]
         : null;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveIn(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}


function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return point(this.l, this.t); }
    get tc() { return point(this.c, this.t); }
    get tr() { return point(this.r, this.t); }
    get ml() { return point(this.l, this.m); }
    get mc() { return point(this.c, this.m); }
    get cm() { return point(this.c, this.m); }
    get mr() { return point(this.r, this.m); }
    get bl() { return point(this.l, this.b); }
    get bc() { return point(this.c, this.b); }
    get br() { return point(this.r, this.b); }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function getDecimalCount(strValue)
{
    const decIndex = strValue.indexOf(getUserDecimalSeparator());

    return decIndex >= 0
         ? strValue.length-1 - decIndex
         : 0;
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign({}, obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element, show = true) { element.style.visibility = show ? 'visible' : 'hidden'; }
function hide(element)              { element.style.visibility = 'hidden';  }

function isVisible(element) { return element.style.visibility == 'visible'; }


function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function removeFromArray(array, obj)
{
    var index = array.indexOf(obj);
    
    if (index > -1)
        array.splice(index, 1);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params));
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj, null).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '')
{
    const div = document.createElement('div');
    
    if (className.trim() != '')
        div.className = className;
    
    return div;
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function enableSliderText(slider, enable)
{
    slider.style.fontStyle = enable ? 'normal' : 'italic'; 
    slider.readOnly        = !enable;
}


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



// function readTextFromClipboard() 
// {
//     if (   navigator.clipboard 
//         && window.isSecureContext) 
//         return navigator.clipboard.readText();

//     else 
//     {
//         let textArea = document.createElement('textarea');

//         textArea.style.position = 'fixed';
//         textArea.style.left     = '-999999px';
//         textArea.style.top      = '-999999px';
        
//         document.body.appendChild(textArea);
        
//         textArea.focus();
//         textArea.select();
        
//         return new Promise((res, rej) => 
//         {
//             document.execCommand('paste') ? res(textArea.value) : rej();
//             textArea.remove();
//         });
//     }
// }


// Observer = 2°

const D65 = [0.95047, 1, 1.08883]; 

function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v > 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h += 1;
    while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k * xw + 0.16)/1.16;
    yw = yw > e ? Math.cbrt(yw) : (k * yw + 0.16)/1.16;
    zw = zw > e ? Math.cbrt(zw) : (k * zw + 0.16)/1.16;

    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16)/k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16)/k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16)/k;

    x *= W[0];
    y *= W[1];
    z *= W[2];

    return [x, y, z];
}


const okLabScale = 5.8209716167;



function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l_, a_, b_) 
{
    return [
        l_ + 0.3963377774 * a_ + 0.2158037573 * b_,
        l_ - 0.1055613458 * a_ - 0.0638541728 * b_,
        l_ - 0.0894841775 * a_ - 1.2914855480 * b_ ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclokl2rgb(hcl, cs = sRGB)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 
    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclokl2rgb_(h, c, l, cs = sRGB)
{
    return hclokl2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclokl(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hclokl_(r, g, b, cs = sRGB)
{
    return rgb2hclokl([r, g, b], cs);
}



function hcllab2rgb(hcl, cs = sRGB)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return lab2rgb(pol2opp(hcl), cs);
}



function rgb2hcllab(rgb, cs = sRGB)
{
    let hcl = opp2pol(rgb2lab(rgb, cs));
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function hclluv2rgb(hcl, cs = sRGB)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return luv2rgb(pol2opp(hcl), cs);
}



function rgb2hclluv(rgb, cs = sRGB)
{
    let hcl = opp2pol(rgb2luv(rgb, cs));
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function isValidRgb(rgb, lim = -Eps)
{
    return (!isNaN(rgb[0])
         && !isNaN(rgb[1])
         && !isNaN(rgb[2])
         && rgb[0] >= 0 + lim && rgb[0] <= 1 - lim 
         && rgb[1] >= 0 + lim && rgb[1] <= 1 - lim 
         && rgb[2] >= 0 + lim && rgb[2] <= 1 - lim);
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


// achromatopsia
const ACR = [0.212656, 0.715158, 0.072186];


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1], sRGB));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1], sRGB));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0], sRGB));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];



function col2xyz(col, colorSpace, w = sRGB.W)
{
    if (colorSpace == 1) return lab2xyz(col, w);
    else                 return luv2xyz(col, w);
}



function xyz2col(col, w = sRGB.W)
{
    switch (setColorSpace)
    {
        case 2: return xyz2lab(col, w);
        case 1: return xyz2luv(col, w);
    }
}



function lch2rgb_CB(l, c, h, colorSpace, cones)
{
    const col = lch2col([
        l, 
        c * l/100, 
        h]);

    const xyz = col2xyz(col, colorSpace);
    

    let rgb;

    if (   cones.l == 0
        && cones.m == 0
        && cones.s == 0)
    {
        rgb = xyz2rgb(xyz, sRGB);

        const a = 
              ACR[0] * rgb[0]
            + ACR[1] * rgb[1]
            + ACR[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const lms = xyz2lms(xyz);

        const lms_ =
               cones.l == 0
            && cones.m == 0

            ? [ lms[0] + blueMono * (bq1*lms[2] - lms[0]),
                lms[1] + blueMono * (bq2*lms[2] - lms[1]),
                lms[2] ]
             
            : [ lms[0] + (1 - cones.l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]),
                lms[1] + (1 - cones.m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]),
                lms[2] + (1 - cones.s) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]) ];

        let xyz_ = lms2xyz(lms_);
            rgb  = xyz2rgb(xyz_, sRGB);
    }
    
    return rgb;
}    



function oklch2rgb_CB(l, c, h, colorSpace, cones)
{
    let rgb;
    
    if (   cones.l == 0
        && cones.m == 0
        && cones.s == 0)
    {
        const lab = lch2col([
            l, 
            c,//okLabScale * l/100, 
            h ]);
    
        rgb = oklab2rgb(lab, sRGB);

        const a = 
              ACR[0] * rgb[0]
            + ACR[1] * rgb[1]
            + ACR[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const _rgb = lch2rgb_CB(l, c, h, colorSpace, cones);

        const xyz = rgb2xyz(_rgb, sRGB);
        const lms = xyz2lms(xyz);

        const lms_ =
               cones.l == 0
            && cones.m == 0

            ? [ lms[0] + blueMono * (bq1*lms[2] - lms[0]),
                lms[1] + blueMono * (bq2*lms[2] - lms[1]),
                lms[2] ]
             
            : [ lms[0] + (1 - cones.l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]),
                lms[1] + (1 - cones.m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]),
                lms[2] + (1 - cones.s) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]) ];

        let xyz_ = lms2xyz(lms_);
            rgb  = xyz2rgb(xyz_, sRGB);
    }
    
    return rgb;
}    






const color_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const dataColor_NaN = [
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ];



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function colorStyleRgb(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function colorStyleRgba(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function colorStyleRgb_a(rgb, a)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(color, threshold = 0.71)
{
    return rgb2hclokl(color)[2] > threshold;
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }

    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    return rgb;
}


function getContrastRatio2(textColor, backColor)
{
    if (!isValidRgb(textColor))
        return Number.NaN;

    const yText = sRGB.luminance(textColor);
    const yBack = sRGB.luminance(backColor);

    return (
        yBack > yText
        ? (yBack + 0.05) / (yText + 0.05)
        : (yText + 0.05) / (yBack + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!isValidRgb(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGB.luminance(textColor),
        sRGB.luminance(backColor));
        // sRGBtoY(textColor),
        // sRGBtoY(contrastBackColor));
}



// I copied the code below from https://stackoverflow.com/questions/66567403/how-do-you-find-the-color-contrast-using-apca-advanced-perpetual-contrast-algor.
// It's almost verbatim, I only reformatted it a tiny bit to better fit my code style.



///////////////////////////////////////////////////////////////////////////////
/////
/////    APCA - Advanced Perceptual Contrast Algorithm - Beta 0.98G-4g
/////     
/////    Function to parse color values and determine SAPC/APCA contrast
/////    Copyright © 2019-2021 by Andrew Somers. All Rights Reserved.
/////    LICENSE: APCA version to be licensed under W3 cooperative agrmnt.
/////    CONTACT: For SAPC/APCA Please use the ISSUES tab at:
/////    https://github.com/Myndex/SAPC-APCA/
/////
///////////////////////////////////////////////////////////////////////////////
/////
/////    USAGE:
/////        Use sRGBtoY(color) to convert sRGB to Luminance (Y)
/////        Then send Y-text and Y-background to APCAcontrast(Text, BG)
/////
/////    Lc = APCAcontrast( sRGBtoY(TEXTcolor) , sRGBtoY(BACKGNDcolor) );
/////
/////    Live Demonstrator at https://www.myndex.com/APCA/
/////
///////////////////////////////////////////////////////////////////////////////



//////////   APCA G - 4g Constants   //////////////////////////////////////


const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65;  // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 
      loWoBthresh = 0.035991,
      loBoWfactor = 
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



////////// ƒ sRGBtoY()   ///////////////////////////////////////////////

// function sRGBtoY(rgb) 
// {
//     // linearize r, g, or b then apply coefficients
//     // and sum then return the resulting luminance
    
//     return sRco * Math.pow(rgb[0], mainTRC) 
//          + sGco * Math.pow(rgb[1], mainTRC)
//          + sBco * Math.pow(rgb[2], mainTRC);
// }



////////// ƒ APCAcontrast()   //////////////////////////////////////////

function APCAcontrast(txtY, bgY) 
{
    // send linear Y (luminance) for text and background.
    // IMPORTANT: Do not swap, polarity is important.
        
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values
    
    // TUTORIAL
    
    // Use Y for text and BG, and soft clamp black,
    // return 0 for very close luminances, determine
    // polarity, and calculate SAPC raw contrast
    // Then scale for easy to remember levels.
  
    // Note that reverse contrast (white text on black)
    // intentionally returns a negative number
    // Proper polarity is important!
 
//////////   BLACK SOFT CLAMP   ///////////////////////////////////////////

    // Soft clamps Y for either color if it is near black.
    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    ///// Return 0 Early for extremely low ∆Y
    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


//////////   APCA/SAPC CONTRAST   /////////////////////////////////////////

    if (bgY > txtY) 
    {  
        // For normal polarity, black text on white (BoW)

        // Calculate the SAPC contrast value and scale
      
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        // Low Contrast smooth rollout to prevent polarity reversal
        // and also a low-clip for very low contrasts
        outputContrast = 
            SAPC < loClip 
            ? 0 
            : (SAPC < loBoWthresh
               ? SAPC - SAPC * loBoWfactor * loBoWoffset 
               : SAPC - loBoWoffset);

    } 
    else 
    {  
        // For reverse polarity, light text on dark (WoB)
        // WoB should always return negative value.

        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : (SAPC > -loWoBthresh 
               ? SAPC - SAPC * loWoBfactor * loWoBoffset 
               : SAPC + loWoBoffset);
    }

    // return Lc (lightness contrast) as a signed numeric value 
    // It is permissible to round to the nearest whole number.
       
    return outputContrast * 100;
}



////////////////////////////////////////////////////////////////////////////////
/////
/////                 SAPC Method and APCA Algorithm
/////
/////   Thanks To: 
/////   • This project references the research and work of Dr.Legge, Dr.Arditi,
/////     Dr.Lovie-Kitchin, M.Fairchild, R.Hunt, M.Stone, Dr.Poynton, L.Arend, &
/////     many others — see refs at https://www.myndex.com/WEB/WCAG_CE17polarity
/////   • Stoyan Stefanov for his input parsing idea, Twitter @stoyanstefanov
/////   • Bruce Bailey of USAccessBoard for his encouragement, ideas, & feedback
/////   • Chris Loiselle of Oracle for getting us back on track in a pandemic
/////
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/////
/////   *****  SAPC BLOCK  *****
/////
/////   For Evaluations, this is referred to as: SAPC-8, 0.98 G-series constants
/////                S-LUV Advanced Perceptual Contrast
/////   Copyright © 2019-2021 by Andrew Somers. All Rights Reserved.
/////   SIMPLE VERSION — Only the basic APCA contrast predictor.
/////
/////   Included Extensions & Model Features in this file:
/////       • SAPC-8 Core Contrast (Base APCA) 
/////       • G series constants, group "G-4g" using a 2.4 monitor exponent
/////       • sRGB to Y, parses numeric sRGB color to luminance
/////       • SmoothScale™ scaling technique (non-clinical use only)
/////       • SoftToe black level soft clamp and flare compensation.
/////
/////
////////////////////////////////////////////////////////////////////////////////
/////
/////                DISCLAIMER AND LIMITATIONS OF USE
/////     APCA is an embodiment of certain suprathreshold contrast
/////     prediction technologies and it is licensed to the W3 on a
/////     limited basis for use in certain specific accessibility
/////     guidelines for web content only. APCA may be used for 
/////     predicting colors for web content use without royalty.
/////
/////     However, Any such license excludes other use cases
/////     not related to web content. Prohibited uses include
/////     medical, clinical evaluation, human safety related,
/////     aerospace, transportation, military applications, 
/////     and uses which are not specific to web based content
/////     presented on self-illuminated displays or devices.
/////
/////
////////////////////////////////////////////////////////////////////////////////


// function uiLoadState(state)
// {
//     uiResizeWindow(
//         window.innerWidth, 
//         state.windowHeight);
// }    



function uiGetPluginData(key)
{
    uiPostMessageToFigma({ 
        cmd: 'figGetPluginData', 
        key:  key
    });
}



function uiGetPluginDataReturn(msg)
{
    // choose here which data is being returned

    switch (msg.key)
    {
        case 'graph':
            loadGraph(msg.value);
            break;
    }
}



function uiEndResizeWindow()
{
    graphView.updatePanAndZoom();

    btnZoom.style.top  = 0;
    btnZoom.style.left = window.innerWidth - btnZoom.offsetWidth;

    btnToggleWires.style.top  = 0;
    btnToggleWires.style.left = btnZoom.offsetLeft - btnToggleWires.offsetWidth;
}



function uiSetPluginData(key, value)
{
    uiPostMessageToFigma({ 
        cmd:  'figSetPluginData', 
        key:   key,
        value: value
    });
}



function uiSaveLocal(key, value)
{
    uiPostMessageToFigma({ 
        cmd:  'figSaveLocal', 
        key:   key,
        value: value
    });
}



// function uiSaveState()
// {
//     uiPostMessageToFigma({ 
//         cmd:  'figSaveState', 
//         key:   key,
//         value: value
//     });
// }


const cryptoModulusSize     = 64; // to keep the keys short
const millerRabinIterations = 40;

const cryptoBufferSize      = cryptoModulusSize/8;
const cryptoPrimeBufferSize = cryptoBufferSize /2;
     
const cryptoBuffer          = new Uint8Array(cryptoPrimeBufferSize);


function bigCryptoRandom()
{
    for (var i = 0; i < cryptoPrimeBufferSize; i++)
        cryptoBuffer[i] = toInt(Math.random() * 0x100);

    cryptoBuffer[0]                       |= 0xC0; // set the top bit to ensure a relatively large number
    cryptoBuffer[cryptoPrimeBufferSize-1] |= 0x01; // set low bit to ensure the number is odd

    return bigFromBuffer(cryptoBuffer);
}



function bigNextCryptoPrime(n) 
{
    while (!bigIsPrime(n))
        n += 2n;
    
    return n;
}



function bigCryptoPrime(e)
{
    // set p so that gcd(e, p-1) = 1
    
    var p;

    do
    {
        var rnd = bigCryptoRandom();
        p       = bigNextCryptoPrime(rnd);
    }
    while (gcd(p-1n, e) != 1n); 
        
    return p;
}



function createCryptoKeys()
{
    var e = 65537n; // 0x10001


    // var p = bigCryptoPrime(e);
    
    // var q;
    // do { q = bigCryptoPrime(e); } 
    // while (q == p);

    
    // if (p < q)
    //     [p,q] = [q,p];

    
    // console.log('p: ' + p);
    // console.log('q: ' + q);


    var p = 4131437551n,
        q = 3567532051n;
    

    var n   = p * q;
    var phi = (p-1n) * (q-1n);

    var d = bigModInvert(e, phi);


    return {
        public:  {n:n, e:e },
        private: {n:n, d:d, p:p, q:q} };
}                        



function encryptBlock(n, key, sign  ) { return bigPowMod(n, (sign   ? key.d : key.e), key.n); }        
function decryptBlock(n, key, verify) { return bigPowMod(n, (verify ? key.e : key.d), key.n); }        



function encrypt(data, key) { return encryptData(data, key, false); }
function decrypt(data, key) { return decryptData(data, key, false); }

function sign   (data, key) { return encryptData(data, key, true); } // yes I know real sign/verify uses a hash,
function verify (data, key) { return decryptData(data, key, true); } // but I prefer it this way for what I need



function encryptData(data, key, sign)
{
    // prep array should be a multiple of cryptoBufferSize
    var prep   = new Uint8Array(Math.ceil((data.length) / cryptoBufferSize) * cryptoBufferSize); 
    var cipher = new Uint8Array(prep.length);


    var start = prep.length - data.length;
    for (var i = 0; i < data.length; i++)
        prep[start+i] = data[i];


    var length = prep.length;
    var nBlock = 0;

    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);
        
        var block = bigFromBufferAt(prep, blockStart, cryptoBufferSize);
        var enc   = encryptBlock(block, key, sign);
        
        bigToBufferAt(enc, cipher, blockStart, cryptoBufferSize);
        
        nBlock++;
        length -= blockSize;
    }
    
    
    return cipher;
}



function decryptData(cipher, key, verify)
{
    var data = new Uint8Array(cipher.length);
    
    
    var length = cipher.length;
    var nBlock = 0;
    
    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);

        var block = bigFromBufferAt(cipher, blockStart, cryptoBufferSize);
        var dec   = decryptBlock(block, key, verify);
        bigToBufferAt(dec, data, blockStart, cryptoBufferSize); 

        nBlock++;
        length -= blockSize;
    }    


    return data;    
}


const base32chars = '12345679ABCDEFGHJKLMNPQRSTUVWXYZ';



function arrayToBase32(array, chars = base32chars)
{
    var base32 = '';

    
    var len = array.length;
    var i   = 0;

    while (len > 0)
    {
        if (len >= 5)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3],
                a4 = array[i+4];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[(a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) << 3) | ((a4 & 0xE0) >>> 5)];
            base32 += chars[(a4 & 0x1F)];
        }
        else if (len == 4)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[(a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) << 3)];
        }
        else if (len == 3)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1)];
        }
        else if (len == 2)
        {
            var a0 = array[i  ],
                a1 = array[i+1];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4)];
        }
        else if (len == 1)
        {
            var a0 = array[i];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2)];
        }


        i   += 5;
        len -= 5;
    }


    return base32;
}



function base32toArray(base32, chars = base32chars)
{
    var array = [];


    var len = base32.length;
    var c   = 0;

    while (len > 0)
    {
        if (len >= 8)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]),
                c7 = chars.indexOf(base32[c+7]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
            array.push(((c6 & 0x07) << 5) | c7);
        }
        else if (len == 7)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
        }
        else if (len == 5)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
        }
        else if (len == 4)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
        }
        else if (len == 2)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
        }


        c   += 8;
        len -= 8;
    }


    return array;
}


function createToggleButton(width, height)
{
    const btn = createDiv('toggleButton');
    btn.enabled = false;

    btn.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();

        btn.setPointerCapture(e.pointerId);
        btn.enabled = !btn.enabled;
        btn.updateBackground(true);
    });


    btn.addEventListener('pointerup', e =>
    {
        btn.releasePointerCapture(e.pointerId);
        btn.updateBackground(false);
    });


    btn.updateBackground = (enabled) =>
    {
        btn.style.background = 
            btn.enabled 
            ? 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 1C4.10457 1 5 1.89543 5 3V5H6V3C6 1.34315 4.65685 0 3 0C1.34315 0 0 1.34315 0 3V5H1V3C1 1.89543 1.89543 1 3 1Z" fill="black"/><path d="M5 9H6V11C6 12.6569 4.65685 14 3 14C1.34315 14 0 12.6569 0 11V9H1V11C1 12.1046 1.89543 13 3 13C4.10457 13 5 12.1046 5 11V9Z" fill="black"/><path d="M2.5 4V10H3.5V4H2.5Z" fill="black"/></svg>\')'
            : 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="black"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="black"/></svg>\')';

        btn.style.backgroundPosition = '50% 50%';
        btn.style.backgroundRepeat   = 'no-repeat';

        btn.style.backgroundColor = btn.enabled && enabled ? '#e6e6e6' : 'transparent';
    };


    return btn;
}


class NumberSliderRange
{
    start;
    end;

    background;

    top;
    bottom;


    constructor(start, end = start, background = 'magenta', top = 0, bottom = 1)
    {
        this.start      = start;
        this.end        = end;

        this.background = background;

        this.top        = top;
        this.bottom     = bottom;
    }
}



function updateSliderRanges(slider, sliderWidth, sliderHeight)
{
    if (slider.ranges.length == slider.rangeDivs.length) // update
    {
        for (let i = 0; i < slider.ranges.length; i++)
        {
            updateSliderRangeDiv(
                slider.ranges   [i],
                slider.rangeDivs[i],
                sliderWidth,
                sliderHeight);
        }
    }
    else // recreate
    {
        resetSliderRangeDivs(slider);

        for (let i = 0; i < slider.ranges.length; i++)
        {
            const range = slider.ranges[i];

            const div = createDiv('numberSliderRange');
            slider.rangeDivs.push(div);
            slider.appendChild(div);
        
            updateSliderRangeDiv(range, div, sliderWidth, sliderHeight);
        }
    }
};



function updateSliderRangeDiv(range, div, sliderWidth, sliderHeight)
{
    if (range.start == range.end)
        div.style.display = 'none';
    else
    {
        div.style.display    = 'block';
        div.style.left       = sliderWidth * range.start;  
        div.style.top        = range.top * sliderHeight;
        div.style.width      = sliderWidth * (range.end - range.start);
        div.style.height     = (range.bottom - range.top) * sliderHeight;
        div.style.background = range.background;
    }
};



function resetSliderRanges(slider)
{
    slider.ranges = [];
    resetSliderRangeDivs(slider);        
};



function resetSliderRangeDivs(slider)
{
    for (const div of slider.rangeDivs)
        if (slider.contains(div))
            slider.removeChild(div);

    slider.rangeDivs = [];
}


function initNumberSliderTextbox(slider)
{
    slider.textbox = createTextbox('numberSliderTextbox');
    


    slider.textbox.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();
    });

    slider.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();
        slider.textbox.style.cursor = 'text';
    });



    slider.textbox.addEventListener('keydown', function(e)
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !slider.readOnly)
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (   (   e.code == 'Enter'
                     || e.code == 'NumpadEnter')
                 && !slider.readOnly)
            slider.textbox.finish(true);

        else if (e.code == 'Escape')
            slider.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            e.stopPropagation();
            
            if (slider.param)
            {
                const params = slider.param.op.params;
                let   index  = params.indexOf(slider.param);

                slider.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (params[--index].control.readOnly);
                    params[index].control.showTextbox();
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (params[++index].control.readOnly);
                    params[index].control.showTextbox();
                }
            }

            // let tabs  = document.querySelectorAll('.numberSlider, .selectSlider, .select, .menuSelect, button, .menuButton');
            // let index = slider.tabIndex;

            // for (let i = 0; i < tabs.length; i++) 
            // {
            //     if (   e.shiftKey && tabs[i].tabIndex == index - 1
            //         ||               tabs[i].tabIndex == index + 1) 
            //     {
            //         if (tabs[i].className == 'slider')
            //             tabs[i].showTextbox();
            //         else 
            //         {
            //             document.activeElement.blur();
            //             tabs[i].focus();
            //         }

            //         break;
            //     }
            // }
        }

        else 
        {
            if (      e.key.length == 1
                   && !isDigitChar(e.key)
                   && (   !slider.showHex 
                       || !isHexDigitChar(e.key))
                   && (   slider.showHex
                       || e.key != getUserDecimalSeparator())
                   && !(   (   e.code == 'Minus'
                            || e.code == 'NumpadSubtract')
                        && slider.min < 0)
                ||     slider.readOnly
                   && !isArrowKey(e.code))
                e.preventDefault();

            let curVal = slider.textbox.value;

            curVal = 
                  curVal.substring(0,                           slider.textbox.selectionStart) 
                + curVal.substring(slider.textbox.selectionEnd, curVal.length);

            let nextVal = parseFloat(curVal + e.key);

            if (   nextVal < slider.min - 0.001
                || nextVal > slider.max)
                e.preventDefault();            
        }
    });



    // slider.textbox.addEventListener('input', function()
    // {
    //     slider.setValue(Number(slider.textbox.value));
    // });



    slider.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        const str = e.clipboardData.getData('text/plain');

        let val = 
            slider.showHex
            ? parseInt(str, 16)
            : parseFloat(str);

        val = Math.min(Math.max(slider.min, val), slider.max);

        slider.textbox.value = isNaN(val) ? '' : val;
    });



    slider.textbox.addEventListener('focusout', function()
    {
        if (slider.successOnFocusOut)
            slider.textbox.finish(true);
            
        slider.parentNode.removeChild(slider.textbox);
        slider.clicked = false;
    });
    


    slider.textbox.finish = function(success, focusSlider = true)
    {
        const value      = slider.textbox.value;
        const savedValue = slider.textbox.savedValue;

        let val = 
            slider.showHex
            ? parseInt(value, 16)
            : parseFloat(value);

        if (success) slider.setValue(Number(val));
        else         slider.setValue(Number(savedValue));

        slider.dispatchEvent(new CustomEvent('finishedit', { 'detail': {
            'success':  success,
            'value':    value,
            'oldValue': savedValue }}));


        slider.textbox.blur();

        if (   slider.inFocus
            && focusSlider)
            slider.focus();
    };    
    
    

    slider.showTextbox = function()
    {
        slider.inFocus = 
                slider == document.activeElement
            && !slider.clicked;
    
        slider.textbox.style.position = 'absolute';
    
        slider.textbox.style.left      = '50%';
        slider.textbox.style.transform = 'translate(-50%)';
        slider.textbox.style.top       = slider.offsetTop    + 1;
        slider.textbox.style.width     = slider.offsetWidth  - 2;
        slider.textbox.style.height    = slider.offsetHeight - 2;
        slider.textbox.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
        slider.textbox.style.outline   = 'none';
        slider.textbox.style.textAlign = 'center';
        slider.textbox.style.fontStyle = slider.readOnly ? 'italic' : 'normal';

    
        slider.textbox.value =
            isNaN(slider.value)
            ? '?'
            : getNumberString(slider.value, slider.dec, slider.showHex).toUpperCase();
            
        slider.textbox.savedValue = slider.textbox.value;
        
        slider.parentNode.appendChild(slider.textbox);
        
        slider.textbox.focus();
        slider.textbox.select();

        slider.textbox.style.cursor = 'text';
    }
}


function initNumberSliderChildren(slider)
{
    slider.bar   = createDiv('numberSliderBar');
    slider.text  = createDiv('numberSliderText');
    slider.focus = createDiv('numberSliderFocus');

    slider.appendChild(slider.bar);
    slider.appendChild(slider.text);
    slider.appendChild(slider.focus);
}



function initNumberSlider(param, slider, width, height, id, name, showName, min, max, def, dec = 0, dragScale = 0.05, wheelStep = 1, acc = 0, suffix = '', log = false)
{
    slider.param             = param;

    slider.className         = 'numberSlider';

    slider.width             = width;
    slider.height            = height;
        
    slider.style.width       = width;
    slider.style.height      = height;
        
    slider.min               = min;
    slider.max               = max;
    slider.value             = def;
    slider.dec               = dec;
    slider.editDec           = dec;
    slider.acc               = acc;
    
    slider.displayMin        = min;
    slider.displayMax        = max;
    slider.displayMultiplier = 1;
               
    slider.id                = id;
    slider.name              = name;
    slider.suffix            = suffix;
    slider.log               = log;

    slider.dragScale         = dragScale;
    slider.wheelStep         = wheelStep;
        
    slider.backColor         = 'transparent';//'#fffe';
    slider.valueColor        = '#7772';
    slider.textColor         = '#000';
           
    slider.fontSize          = 11;
        
    slider.style.display     = 'inline';
        
    slider.mouseOver         = false;
    slider.buttonDown0       = false;
    slider.buttonDown1       = false;
        
    slider.clickSize         = 4;
    slider.moved             = false;
    
    slider.tabIndex          = 0;
    slider.inFocus           = false;
    slider.clicked           = false;

    slider.oldValue;

    slider.wrapValue         = false;

    slider.showName          = showName;
    slider.showHex           = false;
    
    slider.enableChangeEvent = true;
    slider.successOnFocusOut = false;

    slider.pointerEvents     = true;
    slider.readOnly          = false;

    slider.valueText         = '';

    slider.barTop            = 0;
    slider.barBottom         = 1;

    slider.ranges            = [];
    slider.rangeDivs         = [];

    slider.options           = []; // if dec == 0, show named choices instead of a value


    
    initNumberSliderChildren(slider);    
    initNumberSliderTextbox(slider);

    

    //

    slider.onstartchange = new Event('startchange');
    slider.onchange      = new Event('change');
    slider.onconfirm     = new Event('confirm');



    //

    slider.addEventListener('pointerdown', function(e)
    {
        if (graphView.spaceDown)
            return;

        if (e.button == 0)
        {
            if (!slider.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let opDiv = 
                   slider.parentNode
                && slider.parentNode.parentNode
                && slider.parentNode.parentNode.parentNode
                ? slider.parentNode.parentNode.parentNode
                : null;

            if (opDiv && opDiv.className == 'node') 
                graphView.putNodeOnTop(opDiv.op);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();
                
            slider.buttonDown0  = true;
            slider.buttonDown0_ = true;
            slider.moved        = false;
            slider.clientX      = 0;


            if (!slider.readOnly)
            {
                slider.oldValue   = slider.value;
                slider.prevValue  = slider.value;
                slider.sx         = e.clientX;

                slider.clickTimer = setTimeout(function() { onSliderClickTimer(slider); }, 500);
            }


            slider.focus.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject) + ' inset';

            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            slider.buttonDown1 = true;
        }
    });



    slider.addEventListener('pointermove', e =>
    {
        if (!slider.pointerEvents)
            return;
        

        let rect = boundingRect(slider);
        
        slider.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        slider.clientX = e.clientX;

        
        if (    slider.buttonDown0
            && !slider.readOnly)
        {
            if (slider.isPointerLocked())
            {
                slider.movedX += e.movementX;
                
                const dx       = slider.sx - slider.movedX;             
                const adaptive = 10 * Math.pow(Math.abs(dx), slider.acc);
                const drag     = slider.dragScale * Math.pow(10, -slider.editDec);
                const grain    = Math.pow(10, -slider.editDec);

                let val = slider.oldValue - dx * drag * slider.dragScale * adaptive;
                val = Math.floor(val / grain) * grain;

                slider.setValue(val, true, false, false, getCtrlKey(e));

                const _val = Math.min(Math.max(slider.min, val), slider.max);

                if (_val != slider.prevValue)
                    slider.param.op.pushUpdate();
                    
                slider.prevValue = slider.value;
            }
            else
            {
                if (Math.abs(e.clientX - slider.sx) > slider.clickSize/2)
                {
                    slider.moved = true;
                    slider.lockPointer();

                    slider.dispatchEvent(slider.onstartchange);
                }
            }
        }
        else if (graphView.tempConn
              && slider.param)
        {
            if (    graphView.tempConn.output
                &&  slider.param.input
                &&  graphView.tempConn.output.dataType == slider.param.input.dataType
                && !graphView.tempConn.output.op.follows(slider.param.op))
            {
                graphView.overInput = slider.param.input;
                    
                slider.param.input.mouseOver = true;
                slider.param.input.updateControl();

                const rect = boundingRect(slider.param.input.control);

                graphView.tempConn.wire.inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - controlBar.offsetHeight);
            }
            else if ( graphView.tempConn.input
                  &&  slider.param.output
                  &&  graphView.tempConn.input.dataType == slider.param.output.dataType
                  && !slider.param.op.follows(graphView.tempConn.input.op))
            {
                graphView.overOutput = slider.param.output;
                    
                slider.param.output.mouseOver = true;
                slider.param.output.updateControl();


                const rect = boundingRect(slider.param.output.control);

                graphView.tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - controlBar.offsetHeight);


                graphView.tempConn.input.updateControl();
            }
        }
        else if (slider.readOnly)
        {
            slider.moved = true;
        }
    });
    
    
    
    slider.addEventListener('losecapture', function()
    {
        slider.buttonDown0 = false;
        slider.mouseOver   = false;
        slider.update();
    });



    slider.addEventListener('pointerup', function(e)
    {
        clearTimeout(slider.clickTimer);


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.op.follows(slider.param.op)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !slider.param.op.follows(graphView.tempConn.input.op)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overOutput.endConnection();
            }
        }
        
        else if (   slider.moved
            || document.menuHadFocus)
        {
            slider.unlockPointer(e.pointerId);
            return;            
        }

        else if (slider.buttonDown0_)
        {
            slider.clicked = true;
            slider.showTextbox();
        }

        else if (slider.buttonDown1)
            slider.buttonDown1 = false;

        slider.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && slider.buttonDown0)
        {
            slider.buttonDown0 = false;
            slider.unlockPointer(e.pointerId);

            slider.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            if (slider.value != slider.oldValue)
                slider.dispatchEvent(slider.onconfirm);
        }
        else if (   e.button == 1
            && slider.buttonDown1)
        {
            slider.buttonDown1 = false;            
        }
    });


    
    slider.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.spaceDown
            && slider.pointerEvents)
        {
            if (graphView.tempConn)
                slider.style.cursor = 'default';
            
            else
                slider.style.cursor = 
                       slider.readOnly 
                    || containsChild(slider, slider.textbox) 
                    ? (slider.readOnly ? 'default' : 'text')
                    : 'ew-resize';
            
            slider.focus.style.boxShadow  = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
            slider.focus.style.visibility = 'visible';
            slider.focus.style.opacity    = '100%';
    
            slider.update();
        }
    });



    slider.addEventListener('pointerleave', function(e)
    {
        slider.style.cursor           = 'default';
        
        slider.focus.style.visibility = 'hidden';
        slider.focus.style.opacity    = 0;

        slider.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.op != slider.param.op)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.op != slider.param.op)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    slider.addEventListener('wheel', e =>
    {
        if (!slider.pointerEvents)
            return;

        if (   !getCtrlKey(e)
            && !slider.buttonDown1)
        {
            e.stopPropagation();

            if (!slider.readOnly)
            {
                slider.oldValue = slider.value;

                const dec = Math.pow(10, -slider.editDec);
                const val = slider.value + (e.deltaY > 0 ? -1 : 1) * slider.wheelStep * dec;
                
                slider.setValue(val);
            }
        }
    });



    slider.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            slider.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    slider.addEventListener('focus', function()
    {
        if (   !graphView.spaceDown
            && !slider.buttonDown1
            && slider.pointerEvents)
            slider.showTextbox();
    });


    
    slider.setName = function(name)
    {
        slider.name = name;
        slider.update();
    };



    slider.setValue = function(value, fireChangeEvent = true, confirm = true, forceChange = false, fullRange = false)
    {
        const oldValue = slider.value;


        if (slider.wrapValue)
        {
            while (value < slider.displayMin) value += slider.displayMax - slider.displayMin;
            while (value > slider.displayMax) value -= slider.displayMax - slider.displayMin;
        }
        else if (fullRange)
            value = Math.min(Math.max(slider.min, value), slider.max);
        else
            value = Math.min(Math.max(slider.displayMin, value), slider.displayMax);
        

        if (   value != oldValue
            || forceChange)
        {
            slider.value = value;

            slider.update();

            if (   fireChangeEvent
                && slider.enableChangeEvent
                && value != slider.prevValue)
                slider.dispatchEvent(slider.onchange);

            if (   confirm
                && slider.enableChangeEvent
                && value != oldValue)
                slider.dispatchEvent(slider.onconfirm);
        }
    };




    slider.update = function()
    {
        const sw = slider.clientWidth;
        const sh = slider.clientHeight;

        const sx = slider.offsetLeft;
        const cx = -slider.displayMin / (slider.displayMax - slider.displayMin) * sw;
        const v  =  slider.value      / (slider.displayMax - slider.displayMin);

        slider.updateBar(sx, cx, v, sw, sh);
        slider.updateColors();
        slider.updateText();
        slider.updateFocus(sw, sh);
        
        updateSliderRanges(slider, sw, sh);
    };



    slider.updateBar = function(sx, cx, v, sw, sh)
    {
        const x = 
            v >= 0
            ? sx + cx
            : sx + cx + v * sw;

        slider.bar.style.left  = Math.max(0, x);
        slider.bar.style.width = Math.min(Math.max(0, Math.round(Math.abs(v) * sw) + Math.min(0, x)), slider.offsetWidth);

        slider.bar.style.top    = sh * slider.barTop;
        slider.bar.style.height = sh * (slider.barBottom - slider.barTop);
    };



    slider.updateColors = function()
    {
        slider     .style.background = slider.backColor;
        slider.bar .style.background = slider.valueColor;
        slider.text.style.color      = slider.textColor;
    };



    slider.updateText = function()
    {
        slider.text.innerHTML = '';
        
        if (   slider.name.length > 0
            && slider.showName)
            slider.text.innerHTML += '<span class="numberSliderName">' + slider.name + "</span>&nbsp;&nbsp;";

        slider.text.innerHTML += slider.getValueText() + slider.suffix;
    };



    slider.updateFocus = function(sw, sh)
    {
        slider.focus.style.left   = 0;
        slider.focus.style.top    = 0;
        slider.focus.style.width  = sw;
        slider.focus.style.height = sh;
    };



    slider.getValueText = function()
    {
        if (   slider.options.length > 0
            && slider.dec == 0)
        {
            if (   slider.value <  0 
                || slider.value >= slider.options.length)
                return '?';
            else
                return slider.options[Math.round(slider.value)];
        }
        else if (slider.valueText != '')
        {
            return slider.valueText;
        }
        else
        {
            return isNaN(slider.value)
                   ? '?'
                   : getNumberString(
                         slider.value * slider.displayMultiplier, 
                         slider.dec, 
                         slider.showHex
                     ).toUpperCase();
        }
    };



    slider.lockPointer = function()
    {
        slider.requestPointerLock =    
               slider.requestPointerLock 
            || slider.mozRequestPointerLock;

        slider.requestPointerLock();
        clearTimeout(slider.clickTimer);

        slider.movedX = 0;
        slider.sx     = 0;
    };



    slider.unlockPointer = function()
    {
        document.exitPointerLock =    
               document.exitPointerLock    
            || document.mozExitPointerLock;

        document.exitPointerLock();
    };



    slider.isPointerLocked = function()
    {
        return (document.pointerLockElement    === slider 
             || document.mozPointerLockElement === slider);
    }
    


    slider.setMin = (min, dispatchEvents = true) =>
    {
        slider.min        = min;
        slider.displayMin = min;

        if (slider.value < min) 
            slider.setValue(min, true, true, dispatchEvents);
    };



    slider.setMax = (max, dispatchEvents = true) =>
    {
        slider.max        = max;
        slider.displayMax = max;

        if (max < slider.value) 
            slider.setValue(max, true, true, dispatchEvents);
    };



    slider.update();
}



function onSliderClickTimer(slider)
{
    if (!document.menuHadFocus)
    {
        slider.moved = true;
        slider.lockPointer();
    }
}


function initColorSliderTextbox(slider)
{
    slider.textbox = createTextbox('sliderText');
    
    
    slider.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            slider.textbox.finish(true);

        else if (e.code == 'Escape')
            slider.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.slider, .select, .menuSelect, button, .menuButton');
            var index = slider.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && slider.min < 0))
                e.preventDefault();

            var t = slider.textbox;

            var curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            var nextVal = parseFloat(curVal + e.key);

            if (   nextVal < slider.min - 0.001
                || nextVal > slider.max)
                e.preventDefault();            
        }
    });



    // slider.textbox.addEventListener('input', function()
    // {
    //     slider.setValue(Number(slider.textbox.value));
    // });



    slider.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(slider.min, val), slider.max);

        slider.textbox.value = isNaN(val) ? '' : val;
    });



    slider.textbox.addEventListener('focusout', function()
    {
        slider.parentNode.removeChild(slider.textbox);
        slider.clicked = false;
    });
    


    slider.textbox.finish = function(success)
    {
        if (success) slider.setValue(Number(slider.textbox.value     ));
        else         slider.setValue(Number(slider.textbox.savedValue));

        slider.textbox.blur();

        if (slider.inFocus)
            slider.focus();
    };    
    
    
    
    slider.showTextbox = function()
    {
        slider.inFocus = 
                slider == document.activeElement
            && !slider.clicked;
    
        slider.textbox.style.position = 'absolute';
    
        slider.textbox.style.left      = slider.offsetLeft   + 1;
        slider.textbox.style.top       = slider.offsetTop    + 1;
        slider.textbox.style.width     = slider.offsetWidth  - 2;
        slider.textbox.style.height    = slider.offsetHeight - 2;
        slider.textbox.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
        slider.textbox.style.outline   = 'none';
    
        slider.textbox.style.textAlign = 'center';
    
        slider.textbox.value = numToString(slider.value, slider.editDec);
        slider.textbox.savedValue = slider.textbox.value;
        
        slider.parentNode.appendChild(slider.textbox);
        
        slider.textbox.focus();
        slider.textbox.select();
    }
}


function initColorSliderChildren(slider)
{
    slider.text  = createDiv('sliderText');
    slider.focus = createDiv('sliderFocus');

    slider.appendChild(slider.text);
    slider.appendChild(slider.focus);
}



function initColorSlider(slider, width, height, name, def, dragScale, wheelStep, acc, suffix = '', log = false, backColor = '#fff', valueColor = '#eee', fontSize = 11)
{
    slider.className         = 'slider';

    slider.width             = width;
    slider.height            = height;
        
    slider.style.width       = width;
    slider.style.height      = height;
        
    slider.value             = def;
    slider.acc               = acc;
               
    slider.name              = name;
    slider.suffix            = suffix;
    slider.log               = log;

    slider.dragScale         = dragScale;
    slider.wheelStep         = wheelStep;
        
    slider.backColor         = backColor;
    slider.valueColor        = valueColor;
           
    slider.fontSize          = fontSize;
        
    slider.style.display     = 'inline';
        
    slider.mouseOver         = false;
    slider.buttonDown0       = false;
    slider.buttonDown1       = false;
        
    slider.clickSize         = 4;
    slider.moved             = false;
    
    slider.tabIndex          = 0;
    slider.inFocus           = false;
    slider.clicked           = false;

    slider.oldValue;

    //slider.wrapValue         = false;
    
    slider.enableChangeEvent = true;

    slider.pointerEvents     = true;

    slider.valueText         = '';



    initColorSliderChildren(slider);    
    initColorSliderTextbox(slider);

    

    //

    slider.onchange  = new Event('change');
    slider.onconfirm = new Event('confirm');



    //

    slider.addEventListener('pointerdown', function(e)
    {
        if (graphView.spaceDown)
            return;

        if (e.button == 0)
        {
            if (!slider.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let opDiv = 
                   slider.parentNode
                && slider.parentNode.parentNode
                && slider.parentNode.parentNode.parentNode
                ? slider.parentNode.parentNode.parentNode
                : null;

            if (opDiv && opDiv.className == 'node') 
                graphView.putNodeOnTop(opDiv.op);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();

            slider.buttonDown0  = true;
            slider.buttonDown0_ = true;
            slider.moved        = false;
            slider.clientX      = 0;
            slider.oldValue     = slider.value;

            slider.prevValue    = slider.value;
            slider.sx           = e.clientX;

            slider.focus.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject) + ' inset';
            
            


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();

            slider.clickTimer = setTimeout(function() 
            {
                onSliderClickTimer(slider); 
            }, 500);
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            slider.buttonDown1 = true;
        }
    });



    slider.addEventListener('pointermove', function(e)
    {
        if (!slider.pointerEvents)
            return;
        

        let rect = boundingRect(slider);
        
        slider.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;
        
        slider.clientX = e.clientX;

        
        if (slider.buttonDown0)
        {
            //slider.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
            
            if (slider.isPointerLocked())
            {
                slider.movedX += e.movementX;
                
                let dx       = slider.sx - slider.movedX;             
                let adaptive = 10 * Math.pow(Math.abs(dx), slider.acc);
                
                // TODO: if (log) do log scaling
                let val = slider.oldValue - dx*slider.dragScale*adaptive;
                
                const grain = Math.pow(10, -slider.editDec);
                val = Math.floor(val / grain) * grain;
                
                slider.setValue(val, true, false);

                slider.prevValue = slider.value;
            }
            else
            {
                if (Math.abs(e.clientX - slider.sx) > slider.clickSize/2)
                {
                    slider.moved = true;
                    slider.lockPointer();
                }
            }
        }
        //else
        //    slider.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
        
        // slider.update();
    });
    
    
    
    slider.addEventListener('losecapture', function()
    {
        slider.buttonDown0 = false;
        slider.mouseOver   = false;
        slider.update();
    });



    slider.addEventListener('pointerup', function(e)
    {
        clearTimeout(slider.clickTimer);

        if (   slider.moved
            || document.menuHadFocus)
        {
            slider.unlockPointer(e.pointerId);
            return;            
        }    

        if (slider.buttonDown0_)
        {
            slider.clicked = true;
            slider.showTextbox();
        }
        
        if (slider.buttonDown1)
            slider.buttonDown1 = false;

        slider.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && slider.buttonDown0)
        {
            slider.buttonDown0 = false;
            slider.unlockPointer(e.pointerId);

            slider.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            if (slider.value != slider.oldValue)
                slider.dispatchEvent(slider.onconfirm);
        }
        if (   e.button == 1
            && slider.buttonDown1)
        {
            slider.buttonDown1 = false;            
        }
    });


    
    slider.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.spaceDown
            && slider.pointerEvents)
        {
            slider.style.cursor           = 'all-scroll';
            
            slider.focus.style.boxShadow  = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
            slider.focus.style.visibility = 'visible';
            slider.focus.style.opacity    = '100%';
    
            slider.update();
        }
    });



    slider.addEventListener('pointerleave', function(e)
    {
        slider.style.cursor     = 'default';
        
        slider.focus.style.visibility = 'hidden';
        slider.focus.style.opacity    = 0;

        slider.update();
    });



    slider.addEventListener('wheel', e =>
    {
        if (   !getCtrlKey(e)
            && !slider.buttonDown1)
        {
            e.stopPropagation();

            slider.oldValue = slider.value;
            slider.setValue(slider.value + (e.deltaY > 0 ? -1 : 1) * slider.wheelStep);
            // TODO conform after a delay and/or another action, same with key changes 
        }
    });



    slider.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            slider.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    slider.addEventListener('focus', function()
    {
        if (   !graphView.spaceDown
            && !slider.buttonDown1
            && slider.pointerEvents)
            slider.showTextbox();
    });


    
    slider.setValue = function(value, fireChangeEvent = true, confirm = true)
    {
        const oldValue = slider.value;

        // if (slider.wrapValue)
        // {
        //     while (value < slider.min) value += slider.max - slider.min;
        //     while (value > slider.max) value -= slider.max - slider.min;
        // }
        // else
        //     value = Math.min(Math.max(slider.min, value), slider.max);
        
        if (  !confirm
            || value != oldValue)
            slider.value = value;


        slider.update();


        if (   fireChangeEvent
            && slider.enableChangeEvent
            && value != slider.prevValue)
            slider.dispatchEvent(slider.onchange);


        if (   confirm
            && slider.enableChangeEvent
            && value != oldValue)
            slider.dispatchEvent(slider.onconfirm);
    };




    slider.update = function()
    {
        // let v  =  slider.value / (slider.max - slider.min);
        // let cx = -slider.min / (slider.max - slider.min) * slider.clientWidth;

        // slider.bar.style.background = slider.valueColor;

        // slider.bar.style.top    = 0;//slider.mouseOver ? 1 : 0;
        // slider.bar.style.height = slider.clientHeight;// - (slider.mouseOver ? 2 : 0);

        slider.focus.style.left   = 0;
        slider.focus.style.top    = 0;
        slider.focus.style.width  = slider.clientWidth;
        slider.focus.style.height = slider.clientHeight;

        // if (v >= 0)
        // {
        //     slider.bar.style.left  = slider.offsetLeft + Math.round(cx);
        //     slider.bar.style.width = Math.round(v * slider.clientWidth);
        // }
        // else
        // {
        //     slider.bar.style.left  = slider.offsetLeft + cx + v * slider.clientWidth;
        //     slider.bar.style.width = -v * slider.clientWidth;
        // }

        // slider.bar.style.background =
        //     slider.value >= 0
        //     ? slider.valueColor
        //     : 'repeating-linear-gradient(-60deg, #fff, #fff 1px, #e5e5e5 2px, #e5e5e5 3px, #fff 4px)';

        slider.text.innerHTML = '';
        
        if (slider.name.length > 0)
            slider.text.innerHTML += '<span class="sliderName">' + slider.name + "</span>&nbsp;&nbsp;";
        
        let valueText = 
            slider.valueText != ''
            ? slider.valueText
            : rgb2hex(slider.value);

        slider.text.innerHTML += valueText + slider.suffix;

        slider.style.backgroundColor = colorStyleRgb(slider.value);
    };



    slider.lockPointer = function()
    {
        slider.requestPointerLock =    
               slider.requestPointerLock 
            || slider.mozRequestPointerLock;

        slider.requestPointerLock();
        clearTimeout(slider.clickTimer);

        slider.movedX = 0;
        slider.sx     = 0;
    };



    slider.unlockPointer = function()
    {
        document.exitPointerLock =    
               document.exitPointerLock    
            || document.mozExitPointerLock;

        document.exitPointerLock();
    };



    slider.isPointerLocked = function()
    {
        return (document.pointerLockElement    === slider 
             || document.mozPointerLockElement === slider);
    }
    


    slider.update();
}



function onSliderClickTimer(slider)
{
    if (!document.menuHadFocus)
    {
        slider.moved = true;
        slider.lockPointer();
    }
}


function initSelectMenu(select)
{
    select.menu = createDiv('selectMenu');

    select.menu.hoverIndex       =  0;
    select.menu.tabIndex         =  0;

    select.menu.style.left       =  select.offsetLeft;
    select.menu.style.height     = 'auto';
    select.menu.style.textAlign  = 'center';
    select.menu.style.background = '#222';
    select.menu.style.zIndex     =  MAX_INT32-3;
    


    select.menu.addEventListener('focus', function() { select.menu.style.outline = 'none'; });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });        
    

    
    select.menu.tabIndex   = 0;
    
    select.menu.hoverIndex = 0;


    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = 'calc(100% + 1px)';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = colorStyleRgb(rgbActiveObject);
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = -1; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();
        select.dispatchChangeEvent();
        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initSelect(select, items)
{
    select.className = 'menuSelect';
    select.tabIndex = 0;    
    
    initSelectMenu(select);

    select.holding  = false;
    

    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function()
    {
        select.resetMenu();
        
        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            if (select.items[i].value == '-')
            {
                item.style.borderTop = '1px solid white';
                item.style.marginTop = '6px';
                item.style.height    = '4px';
                item.style.position  = 'relative';
                item.style.left      = '6px';
                
                item.disabled = true;
            }
            else
            {
                item.style.border = 'none';
                item.style.height = 24;

                item.disabled = false;

                sub.innerHTML = select.items[i].text;
            }

            item.appendChild(sub);
            select.menuWrap.appendChild(item);
        }


        let options = select.getElementsByTagName('option');
        for (const op of options) op.disabled = op.value == '-';
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();
            
            select.buttonDown0 = true;        
            select.setPointerCapture(e.pointerId);
            
            select.holding = false;
            setTimeout(function() { onSelectClickTimer(select); }, 200);
            
            select.menu.hoverIndex = select.getSelectedIndex();

            select.showMenu();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        let menuTop =
            select.offsetTop 
            - 3 // paddingTop
            - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
            - iy * 24;
        
        menuTop = Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
        iy = Math.min(Math.max(0, iy), select.items.length-1);
        return iy;
    };        
    

    
    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    }



    select.dispatchChangeEvent = function()
    {
        const onchange = new Event('change', 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        });

        select.dispatchEvent(onchange);
    };


    //////////////////////////////////////////////////////////////////////////////////

    
    select.items = items;
    
    select.update(0);
    select.updateItems();
}



function onSelectClickTimer(select)
{
    select.holding = true;
}


function initMenuSelectMenu(select)
{
    select.menu = createDiv('menuSelectMenu');

    select.menu.hoverIndex   = 0;
    select.menu.tabIndex     = 0;

    select.menu.style.left   = select.offsetLeft;
    select.menu.style.zIndex = MAX_INT32;

    select.menu.addEventListener('focus', function() 
    {
         select.menu.style.outline = 'none'; 
    });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });
    
    

    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = '100%';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = colorStyleRgb(rgbActiveObject);
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = 0; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();

        const onchange = new CustomEvent('change', { detail: 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        }});

        select.dispatchEvent(onchange);

        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initMenuSelectTextbox(select)
{
    select.textbox = createTextbox('menuSelectText');
    
    
    select.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            select.textbox.finish(true);

        else if (e.code == 'Escape')
            select.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            let tabs  = document.querySelectorAll('.slider, .menuSelect, .select, button, .menuButton');
            let index = select.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && select.min < 0))
                e.preventDefault();

            let t = select.textbox;

            let curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            let nextVal = parseFloat(curVal + e.key);

            if (   nextVal < select.min - 0.001
                || nextVal > select.max)
                e.preventDefault();            
        }
    });


    // slider.textbox.addEventListener('input', function()
    // {
    //     slider.setValue(Number(slider.textbox.value));
    // });


    select.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        let val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(select.min, val), select.max);

        select.textbox.value = isNaN(val) ? '' : val;
    });


    select.textbox.addEventListener('focusout', function()
    {
        select.parentNode.removeChild(select.textbox);
        select.clicked = false;
    });
    

    select.textbox.finish = function(success)
    {
        if (success) select.setValue(Number(select.textbox.value     ));
        else         select.setValue(Number(select.textbox.savedValue));

        select.textbox.blur();

        if (select.inFocus)
            select.focus();
    };    
    
    
    select.showTextbox = function()
    {
        select.inFocus = 
                select == document.activeElement
            && !select.clicked;
    
        select.textbox.style.position = 'absolute';
    
        select.textbox.style.left      = select.offsetLeft   + 1;
        select.textbox.style.top       = select.offsetTop    + 1;
        select.textbox.style.width     = select.offsetWidth  - 2;
        select.textbox.style.height    = select.offsetHeight - 2;
        select.textbox.style.boxShadow = '0 0 0 1px ' + colorStyleRgb(rgbActiveObject);
        select.textbox.style.outline   = 'none';
    
        select.textbox.style.textAlign = 'center';
    
        select.textbox.value = numToString(select.value, select.editDec);
        select.textbox.savedValue = select.textbox.value;
        
        select.parentNode.appendChild(select.textbox);
        
        select.textbox.focus();
        select.textbox.select();
    }
}


function initMenuSelect(select)
{
    select.className = 'menuSelect';
    select.tabIndex  = 0;    
    
    initMenuSelectMenu   (select);
    initMenuSelectTextbox(select);

    select.holding = false;

    select.enableChangeEvent = true;


    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function(items)
    {
        select.resetMenu();
        
        
        select.items = items;
        select.update(0);


        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            item.style.border      = 'none';
            item.style.height      = 24;

            item.disabled = false;

            sub.innerHTML = select.items[i].text;

            item.appendChild(sub);

            select.menuWrap.appendChild(item);
        }
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();

            var rect = boundingRect(select);

            if (e.clientX > rect.width - 20)
            {
                select.buttonDown0 = true;        
                select.setPointerCapture(e.pointerId);
                
                select.holding = false;
                setTimeout(function() { onSelectClickTimer(select); }, 200);
                
                select.menu.hoverIndex = select.getSelectedIndex();

                select.showMenu();
            }
            else
                select.showTextbox();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        // let menuTop =
        //     select.offsetTop; 
        //     - 3 // paddingTop
        //     - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
        //     - iy * 24;
        
        menuTop = select.offsetTop + select.offsetHeight + 11;//Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
            iy = Math.min(Math.max(0, iy), select.items.length-1);

        return iy;
    };        
    

    
    select.getSelectedValue = function()
    {
        return select.items[select.getSelectedIndex()].value;
    };        



    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    };



    select.setSelectedIndex = function(index)
    {
        select.value = select.items[index].value;
        select.update(select.getSelectedIndex());
        
        select.enableChangeEvent = false;
        select.dispatchChangeEvent();
        select.enableChangeEvent = true;
    };



    select.dispatchChangeEvent = function()
    {
        if (!select.enableChangeEvent)
            return;
    
        let index = select.getSelectedIndex();
    
        const onchange = new Event('change', 
        {
            selectedIndex: index,
            selectedValue: select.items[index].value
        });

        select.dispatchEvent(onchange);
    };
}



graphView.startConnectionFromOutput = (pointerId, output) =>
{
    //graphView.setPointerCapture(pointerId);

    graphView.tempConn = new Connection(output, null);
    graphView.addWire(graphView.tempConn.wire, false);

    graphView.tempConn.wire.output = output;

    graphView.updateNodeWire(
        graphView.tempConn.wire,
        graphView.pStart.x, 
        graphView.pStart.y);

    output.updateControl();
};



graphView.startConnectionFromInput = (pointerId, input) =>
{
    //graphView.setPointerCapture(pointerId);

    graphView.tempConn = new Connection(null, input);
    graphView.addWire(graphView.tempConn.wire, false);
    
    graphView.tempConn.wire.input = input;

    graphView.updateNodeWire(
        graphView.tempConn.wire,
        graphView.pStart.x, 
        graphView.pStart.y);

    input.updateControl();
};



graphView.cancelConnection = pointerId =>
{
    //graphView.releasePointerCapture(pointerId);

    const output = graphView.tempConn.output;
    const input  = graphView.tempConn.input;

    graphView.removeWire(graphView.tempConn.wire);    

    graphView.savedConn = null;
    graphView.tempConn  = null;

    if (output) output.updateControl();
    if (input ) input .updateControl();

    if (graphView.overInput ) graphView.overInput .updateControl();
    if (graphView.overOutput) graphView.overOutput.updateControl();
};



graphView.endConnection = pointerId =>
{
    if (graphView.tempConn.output) // FROM OUTPUT
    {
        let output = graphView.tempConn.output;
        let input  = graphView.overInput;

        let savedInput = 
            graphView.savedConn
            ? graphView.savedConn.input
            : null;
        
        output.connecting = false;
        
        if (   input
            && input.dataType == output.dataType) // TO INPUT
        {
            if (input == savedInput) // reconnect old
            {
                graphView.savedConn = null; // done here to redraw the saved wire correctly
                graphView.updateNodeWire(input.connection.wire);
            }
            else if (savedInput)
            {
                if (  !input.op._variableInputs
                    || input != lastOf(input.op.inputs)) // disconnect old, connect new
                    actionManager.do(new ReconnectAction(output, savedInput, input));
                else
                {
                    show(savedInput.connection.wire); // show old wire
                    savedInput.updateControl();
                }
            }
            else if (!savedInput) // connect new
                actionManager.do(new ConnectAction(output, input));
        }
        else if (savedInput) // disconnect old
            actionManager.do(new DisconnectAction(output, savedInput));
        
        graphView.cancelConnection(pointerId);
    }
    
    else if (graphView.tempConn.input) // FROM INPUT
    {
        let input  = graphView.tempConn.input;
        let output = graphView.overOutput;

        input.connecting = false;
        
        if (   output
            && output.dataType == input.dataType) // TO OUTPUT
            actionManager.do(new ConnectAction(output, input));

        graphView.cancelConnection(pointerId);
    }
};


graphView._pan = point(0, 0);
  
Object.defineProperty(graphView, 'pan',
{
    get: () => graphView._pan,
    set: pan =>
    {
        if (graphView._pan == pan) return;
        graphView._pan = pan;
        graphView.updatePanAndZoom();
    }
});



graphView.panning = false;
graphView.panStart;

graphView.spaceDown = false;


graphView._zoom   = 1;
graphView.oldZoom = 1;

Object.defineProperty(graphView, 'zoom',
{
    get: () => graphView._zoom,
    set: zoom =>
    {
        if (graphView._zoom == zoom) return;

        let pos = point(
            window.innerWidth /2,
            window.innerHeight/2);

        pos.y -= controlBar.offsetHeight;

        const pan = subv(graphView.pan, mulvs(subv(pos, graphView.pan), zoom / graphView.zoom - 1));

        graphView.setPanAndZoom(pan, zoom);
        graphView.updatePanAndZoom();
    }
});



graphView.zooming   = false;
graphView.zoomStart = 1;

graphView.zoomSelecting = false;



graphView.setPanAndZoom = (pan, zoom) =>
{
    if (      graphView._pan  == pan
           && graphView._zoom == zoom
        || zoom < 0.02
        || zoom > 50) 
        return;

    graphView.oldZoom = graphView.zoom;

    graphView._zoom = zoom;
    graphView._pan  = pan;

    graphView.updatePanAndZoom();
};



graphView.startPan = pointerId =>
{
    graphView.panning  = true;
    graphView.panStart = graphView.pan;
    graphView.setPointerCapture(pointerId);
    setCursor(panCursor);
};



graphView.updatePanAndZoom = () =>
{
    graphView.updateNodeTransforms(graph.nodes);
    graphView.updateScroll();

    btnZoom.innerHTML = Math.round(graphView.zoom * 100) + '%';
};



graphView.endPan = (pointerId, changeCursor) =>
{
    graphView.panning = false;
    graphView.releasePointerCapture(pointerId);

    if (changeCursor)
        setAutoCursor();
};



graphView.startZoomSelection = (pointerId, x, y) =>
{
    graphView.setPointerCapture(pointerId);

    graphView.zoomSelecting = true;
    graphView.selectionRect = new Rect(x, y, 0, 0);
    
    selectBox.style.visibility = 'visible';
    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelection = (x, y) =>
{
    if (!graphView.zoomSelecting) return;

    graphView.selectionRect.w = x - graphView.selectionRect.x;
    graphView.selectionRect.h = y - graphView.selectionRect.y;

    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelectBox = () =>
{
    const selection = graphView.selectionRect;

    selectBox.style.left   = selection.x + Math.min(selection.w, 0);
    selectBox.style.top    = selection.y + Math.min(selection.h, 0);
    selectBox.style.width  = Math.abs(selection.w);
    selectBox.style.height = Math.abs(selection.h);

    selectBox.style.zIndex = MAX_INT32-3;
};



graphView.endZoomSelection = (pointerId, zoom) =>
{
    graphView.releasePointerCapture(pointerId);

    graphView.zoomSelecting    = false;
    selectBox.style.visibility = 'hidden';

    const selection = graphView.selectionRect;

    if (zoom)
    {
        // graphView.oldZoom = graphView.zoom;
        
        let box = {
            x: selection.x,
            y: selection.y - controlBar.offsetHeight,
            w: selection.w,
            h: selection.h };
            
        const wndHeight = graphView.offsetHeight; 

        const diff = { w: (window.innerWidth - box.w) / 2,
                       h: (wndHeight         - box.h) / 2 };

        graphView.setPanAndZoom(
            point(
                -(box.x - diff.w) * graphView.zoom,
                -(box.y - diff.h) * graphView.zoom),
            graphView.zoom * Math.min(
                window.innerWidth / box.w,
                wndHeight         / box.h));
    }

    graphView.selectionRect = Rect.NaN;
};


scrollbarX.moving = false;
scrollbarY.moving = false;



graphView.updateScroll = () =>
{
    const bounds = graphView.getAllNodeBounds();

    graphView.updateScrollX(bounds);
    graphView.updateScrollY(bounds);

    scrollbarX.style.zIndex = MAX_INT32-1;
    scrollbarY.style.zIndex = MAX_INT32-2;
};



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollX = bounds =>
{
    if (bounds.l < 0)
    {
        const width = sqr(graphView.clientWidth) / (graphView.clientWidth - bounds.l) - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  width;
        scrollbarX.style.left    =  graphView.clientWidth - largeScrollGap - width;
        scrollbarX.style.top     =  graphView.clientHeight - smallScrollGap - 6;
    }
    else if (bounds.r >= graphView.clientWidth)
    {
        const width = sqr(graphView.clientWidth) / bounds.r - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  width;
        scrollbarX.style.left    =  smallScrollGap;
        scrollbarX.style.top     =  graphView.clientHeight - smallScrollGap - 6;
    }
    else
        scrollbarX.style.display = 'none';
};



scrollbarX.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarX.moving = true;
        scrollbarX.xStart = scrollbarX.offsetLeft;
        scrollbarX.wStart = scrollbarX.offsetWidth;
        scrollbarX.pStart = e.clientX;
        scrollbarX.setPointerCapture(e.pointerId);

        graphView.panStart = graphView.pan;

        for (const node of graph.nodes)
            node.div.slx = node.div.offsetLeft;
    }
});



scrollbarX.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarX.moving)
    {
        scrollbarX.moving = false;
        scrollbarX.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of graph.nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        if (bounds.l >= 0 && bounds.r < graphView.clientWidth)
            scrollbarX.style.display = 'none';
    }
});



scrollbarX.addEventListener('pointermove', e =>
{
    if (scrollbarX.moving)
    {
        var x = scrollbarX.xStart + e.clientX - scrollbarX.pStart;

        var l = x;
        var r = l + scrollbarX.wStart;

        l = Math.max(smallScrollGap, l);
        r = Math.min(r, graphView.clientWidth - largeScrollGap);

        l = Math.max(smallScrollGap, Math.min(l, r - smallScrollGap));
        r = Math.max(l + smallScrollGap, r);

        scrollbarX.style.left  = l;
        scrollbarX.style.width = r-l;

        graphView.pan = point(
            graphView.panStart.x - (e.clientX - scrollbarX.pStart) / scrollbarX.wStart * graphView.clientWidth,
            graphView.panStart.y);
    }
});



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollY = bounds =>
{
    if (bounds.t < controlBar.offsetHeight)
    {
        const ot     = bounds.t - controlBar.offsetHeight;
        const height = sqr(graphView.clientHeight) / (graphView.clientHeight - ot) - (smallScrollGap + largeScrollGap);

        scrollbarY.style.height  = height;
        scrollbarY.style.left    = graphView.clientLeft + graphView.clientWidth - smallScrollGap - 6;
        scrollbarY.style.top     = graphView.clientHeight - largeScrollGap - height;
        scrollbarY.style.display = 'inline-block';
    }
    else if (bounds.b >= controlBar.offsetHeight + graphView.clientHeight)
    {
        const ob     = bounds.b - controlBar.offsetHeight;
        const height = sqr(graphView.clientHeight) / ob - (smallScrollGap + largeScrollGap);

        scrollbarY.style.height  = height;
        scrollbarY.style.left    = graphView.clientLeft + graphView.clientWidth - smallScrollGap - 6;
        scrollbarY.style.top     = smallScrollGap;
        scrollbarY.style.display = 'inline-block';
    }
    else
        scrollbarY.style.display = 'none';
};



scrollbarY.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarY.moving = true;
        scrollbarY.yStart = scrollbarY.offsetTop;
        scrollbarY.hStart = scrollbarY.offsetHeight;
        scrollbarY.pStart = e.clientY;
        scrollbarY.setPointerCapture(e.pointerId);

        for (const node of graph.nodes)
            node.div.sly = node.div.offsetTop;

        graphView.panStart = graphView.pan;
    }
});



scrollbarY.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarY.moving)
    {
        scrollbarY.moving = false;
        scrollbarY.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of graph.nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        if (bounds.t >= 0 && bounds.b < graphView.clientHeight)
            scrollbarY.style.display = 'none';
    }
});



scrollbarY.addEventListener('pointermove', e =>
{
    if (scrollbarY.moving)
    {
        var y = scrollbarY.yStart + e.clientY - scrollbarY.pStart;

        var t = y;
        var b = t + scrollbarY.hStart;

        t = Math.max(smallScrollGap, t);
        b = Math.min(b, graphView.clientHeight - largeScrollGap);

        t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
        b = Math.max(t + smallScrollGap, b);

        scrollbarY.style.top    = t;
        scrollbarY.style.height = b-t;

        graphView.pan = point(
            graphView.panStart.x, 
            graphView.panStart.y - (e.clientY - scrollbarY.pStart) / scrollbarY.hStart * graphView.clientHeight);
    }
});


graphView._selectedNodes     = [];
graphView._prevSelectedNodes = [];
graphView.lastSelectedNodes  = [];


Object.defineProperty(graphView, 'selectedNodes',
{
    get: () => graphView._selectedNodes,
    set: selectedNodes =>
    {
        graphView.deselectAll();

        graphView._selectedNodes = [...selectedNodes];
    
        for (const node of graphView._selectedNodes)
            node.setSelected(true);
    }
});



graphView.deselectAll = () =>
{
    for (const node of graphView._selectedNodes)            
        node.setSelected(false);

    graphView._selectedNodes = [];
};



graphView.selectByIds = (nodeIds) =>
{
    graphView.deselectAll();

    for (const id of nodeIds)
    {
        const node = graph.nodes.find(n => n.id == id);
        graphView._selectedNodes.push(node);
        node.setSelected(true);
    }
};



graphView.startSelection = (pointerId, x, y, shiftKey, ctrlKey) =>
{
    graphView.setPointerCapture(pointerId);

    graphView.selecting = true;

    graphView.selectionRect = new Rect(x, y, 0, 0);
    graphView._prevSelectedNodes = [];
   
    selectBox.style.visibility = 'visible';

    graphView.updateSelectBox(shiftKey, ctrlKey);
};



graphView.updateSelection = (x, y, shiftKey, ctrlKey) =>
{
    if (!graphView.selecting) return;

    graphView.selectionRect.w = x - graphView.selectionRect.x;
    graphView.selectionRect.h = y - graphView.selectionRect.y;

    graphView.updateSelectBox(shiftKey, ctrlKey);
};



graphView.updateSelectBox = (shiftKey, ctrlKey) =>
{
    const wndRect = new Rect(
        1,
        controlBar.offsetHeight + 1,
        graphView.offsetWidth  - 2,
        graphView.offsetHeight - 5);

    
    let selection = validateRect(graphView.selectionRect);
    
    selection = clipRect(selection, wndRect);


    selectBox.style.left   = selection.x;
    selectBox.style.top    = selection.y;
    selectBox.style.width  = selection.width;
    selectBox.style.height = selection.height;


    const selected = [];

    for (const node of graph.nodes)
    {
        if (rectsIntersect(
                boundingRect(node.div), 
                selection))
            selected.push(node);
    }


    if (ctrlKey)
        graphView.selectedNodes = graphView.lastSelectedNodes.concat(selected);
    else if (shiftKey)
        graphView.selectedNodes = graphView.lastSelectedNodes
                             .filter(node => !selected.includes(node))
                             .concat(selected.filter(node => !graphView.lastSelectedNodes.includes(node)));
    else
        graphView.selectedNodes = selected;
    
        
    selectBox.style.zIndex = MAX_INT32-3;
        
        
    //updateGraphNodes();
    for (const node of selected)
        node.updateBorder();


    graphView._prevSelectedNodes = selected;
};



graphView.endSelection = pointerId =>
{
    if (   graphView.selectedNodes    .length > 0
        || graphView.lastSelectedNodes.length > 0)
    {
        actionManager.do(new SelectNodesAction(
            graphView.selectedNodes    .map(n => n.id), 
            graphView.lastSelectedNodes.map(n => n.id)));
    }


    graphView.releasePointerCapture(pointerId);

    graphView.selecting     = false;
    graphView.selectionRect = Rect.NaN;
    graphView._prevSelectedNodes = [];

    selectBox.style.visibility = 'hidden';
};


graphView.wires          = [];

graphView.loadingNodes   = false;
graphView.canUpdateNodes = true;


graphView.overNode       = null;
graphView.overInput      = null;
graphView.overOutput     = null;
   
graphView.headerInput    = null; // same as overInput, but when snapping from a header
graphView.headerOutput   = null; // same as overOutput, but when snapping from a header
   
graphView.tempConn       = null;
graphView.savedConn      = null;

graphView.showWires      = true;
graphView._soloNode      = null;
   
graphView.selecting      = false;
graphView.selectionRect  = Rect.NaN;

graphView.btn1down       = false; // this is to help deal with mouse wheels that send X values as
                                  // sometimes a MMB press is followed by wheelX as a "deeper" middle-click

graphView.panning        = false;

graphView.pStart         = point(0, 0);


scrollbarX.style.zIndex  = MAX_INT32-1;
scrollbarY.style.zIndex  = MAX_INT32-2;



graphView.addEventListener('pointerdown', e =>
{
    graphView.pStart = point(e.clientX, e.clientY);

    const sx = e.clientX;// / graphView.zoom;
    const sy = e.clientY;// / graphView.zoom;

    if (   e.button == 0                 
        && !graphView.panning
        && !document.canResizeX
        && !document.canResizeY
        && !scrollbarX.moving
        && !scrollbarY.moving)
    {
        if (graphView.spaceDown)
        {
            if (getCtrlKey(e)) graphView.startZoomSelection(e.pointerId, e.clientX, e.clientY);
            else               graphView.startPan(e.pointerId);
        }
        else if (graphView.overOutput)
        {
            graphView.overOutput.connecting = true;
            graphView.startConnectionFromOutput(e.pointerId, graphView.overOutput);
            graphView.updateNodeWire(graphView.tempConn.wire, sx, sy);
        }
        else if (graphView.overInput)
        {
            if (graphView.overInput.connectedOutput) // pretend to disconnect
            {
                graphView.startConnectionFromOutput(e.pointerId, graphView.overInput.connectedOutput);
                graphView.updateNodeWire(graphView.tempConn.wire, sx, sy);
                
                graphView.savedConn = graphView.overInput.connection;
                graphView.updateNodeWire(graphView.savedConn.wire);
            }
            else
            {
                graphView.overInput.connecting = true;
                graphView.startConnectionFromInput(e.pointerId, graphView.overInput);
                graphView.updateNodeWire(graphView.tempConn.wire, sx, sy);
            }
        }
        else // selection
        {
            graphView.lastSelectedNodes = [...graphView.selectedNodes];

            graphView.startSelection(
                e.pointerId, 
                e.clientX, 
                e.clientY, 
                e.shiftKey,
                getCtrlKey(e));
        }
    }
    
    else if (e.button == 1)
    {
        graphView.btn1down = true;
        graphView.startPan(e.pointerId);
    }
});



graphView.addEventListener('pointermove', graphView_onpointermove);



function graphView_onpointermove(e)
{
    graphView.p = point(e.clientX, e.clientY);

    if (graphView.panning)
    {
        setTimeout(() =>
        {
            setCursor(panCursor);

            const dp = subv(graphView.p, graphView.pStart);

            graphView.setPanAndZoom(
                addv(graphView.panStart, dp), 
                graphView.zoom);
        });
    }
    
    else if (graphView.selecting)
        graphView.updateSelection(e.clientX, e.clientY, e.shiftKey, getCtrlKey(e));
    
    else if (graphView.zoomSelecting)
        graphView.updateZoomSelection(e.clientX, e.clientY);
    
    else if (graphView.tempConn)
    {
        graphView.updateNodeWire(
            graphView.tempConn.wire, 
            e.clientX, 
            e.clientY);
    }
}



graphView.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && graphView.spaceDown)
    {
        if (getCtrlKey(e))
        {
            if (   graphView.selectionRect.w > 0
                && graphView.selectionRect.h > 0)
            {
                graphView.endZoomSelection(e.pointerId, true);
            }
            else
            {
                graphView.endZoomSelection(e.pointerId, false);

                graphView.oldZoom = graphView.zoom;

                if (e.altKey) graphView.zoom /= 2;
                else          graphView.zoom *= 2;

                graphView.pan = subv(
                    graphView.pan, 
                    mulvs(
                        subv(
                            point(e.clientX, e.clientY), 
                            graphView.pan), 
                        graphView.zoom / graphView.oldZoom - 1));
            }
        }
        
        graphView.endPan(e.pointerId, false);
    }

    else if (e.button == 0
         && !graphView.selectionRect.isNaN)
        graphView.endSelection(e.pointerId);

    else if (e.button == 0
          && graphView.tempConn)
        graphView.endConnection(e.pointerId);

    else if (e.button == 1
          && graphView.panning)
    {
        graphView.btn1down = false;
        graphView.endPan(e.pointerId, true);
    }
});



graphView.addEventListener('wheel', e =>
{
    if (graphView.btn1down)
        return;


    const dZoom = Math.log(graphView.zoom) / Math.log(2);

    const dWheelX = e.deltaX / 120;
    const dWheelY = e.deltaY / 120;

    if (getCtrlKey(e))
    {
        let pos = point(e.clientX, e.clientY);
        pos.y -= controlBar.offsetHeight;

        const zoom = Math.max(0.0001, Math.pow(2, dZoom - dWheelY / 10));
        const pan  = subv(graphView.pan, mulvs(subv(pos, graphView.pan), zoom / graphView.zoom - 1));

        graphView.setPanAndZoom(pan, zoom);
        graphView.updatePanAndZoom();
    }
    else
    {
        const dPanX = dWheelX * 20 / Math.pow(graphView.zoom, 0.1);
        const dPanY = dWheelY * 20 / Math.pow(graphView.zoom, 0.1);

        graphView.pan = 
            dWheelX != 0
            ? point(
                 e.shiftKey ? graphView.pan.x : graphView.pan.x - dPanX,
                !e.shiftKey ? graphView.pan.y : graphView.pan.y - dPanX)
            : point(
                !e.shiftKey ? graphView.pan.x : graphView.pan.x - dPanY,
                 e.shiftKey ? graphView.pan.y : graphView.pan.y - dPanY);

        if (graphView.selecting)
        {
            graphView.updateSelection(
                e.clientX, 
                e.clientY, 
                e.shiftKey);
        }
    }


    if (graphView.tempConn)
        graphView_onpointermove(e);
});



graphView.getAllNodeBounds = () =>
{
    let bounds = Rect.NaN;

    for (const node of graph.nodes)
        bounds = expandRect(bounds, boundingRect(node.div));

    return bounds;
};



graphView.getNodeBounds = node =>
{
    const bounds = boundingRect(node.div);

    return new Rect(
        parseFloat(node.div.style.left ),
        parseFloat(node.div.style.top  ),
        parseFloat(node.div.style.width),
        bounds.h / graphView.zoom); // node height isn't defined
}



graphView.getZoomedNodeBounds = node =>
{
    const bounds = graphView.getNodeBounds(node);

    bounds.x += graphView.pan.x / graphView.zoom;
    bounds.y += graphView.pan.y / graphView.zoom;
    bounds.w /= graphView.zoom;
    bounds.h /= graphView.zoom;

    return bounds;
};



graphView.getIntersectingNodes = node =>
{
    const nodeBounds = graphView.getZoomedNodeBounds(node);

    const intersecting = [];
    
    for (const n of graph.nodes)
    {
        const nBounds = graphView.getZoomedNodeBounds(n);
        
        if (   n != node
            && rectsIntersect(nBounds, nodeBounds))
        {
            intersecting.push(n);
        }
    }

    return intersecting;
}



graphView.placeNewNode = (node) =>
{
    //log('graphView.placeNewNode()');

    node.div.style.left = (graphView.offsetWidth  / 6 - graphView.pan.x) / graphView.zoom;
    node.div.style.top  = (graphView.offsetHeight / 4 - graphView.pan.y) / graphView.zoom;


    const dx = 30;
    const dy = 20;


    let maxLength = 100; // stack overflow safeguard
    
    let intersecting;
    while (   maxLength-- > 0
           && (intersecting = graphView.getIntersectingNodes(node)).length > 0)
    {
        let bounds = Rect.NaN;
        
        for (const n of intersecting)
            bounds = expandRect(bounds, graphView.getNodeBounds(n));

        const right = intersecting.reduce((a, b) => 
            graphView.getNodeBounds(a).r > graphView.getNodeBounds(b).r ? a : b);

        if (   right.opType == node.opType
            && node.opType != 'color'
            && node.opType != 'webcontrast') node.div.style.top  = bounds.b + dy;
        else                                 node.div.style.left = bounds.r + dx;
    }
};



graphView.putNodeOnTop = node =>
{
    const topIndices = 
          1 
        + node.inputs.filter(i => i.isConnected).length 
        + (node.outputs.find(o => o.isConnected) ? 1 : 0);
        
    for (const n of graph.nodes)
        n.div.style.zIndex = Math.max(0, Number(n.div.style.zIndex) - topIndices);
        
    node.div.style.zIndex = MAX_INT32-3; // -3 is for scrollbars;

    graphView.putWiresOnTop(node);
};



graphView.putWiresOnTop = node =>
{
    // changing z-index doesn't work so easily with SVG,
    // so reinsert the wires on top instead 🤷‍♂️

    let z = MAX_INT32;

    for (const input of node.inputs.filter(i => i.isConnected))
    {
        wireContainer.removeChild(input.connection.wire);
        wireContainer.appendChild(input.connection.wire);
    }
        
    for (const output of node.outputs)
    {
        for (const connInput of output.connectedInputs)
        {
            wireContainer.removeChild(connInput.connection.wire);
            wireContainer.appendChild(connInput.connection.wire);
        }
    }
};



graphView.updateNodeTransforms = nodes =>
{
    const nodeLeft = nodes.map(n => n.div.offsetLeft);
    const nodeTop  = nodes.map(n => n.div.offsetTop);
    const nodeRect = nodes.map(n => graphView.getNodeOffsetRect(n.div));
    
    for (let i = 0; i < nodes.length; i++)
        graphView.setNodeTransform(nodes[i], nodeLeft[i], nodeTop[i], nodeRect[i]);


    const wires = [];

    for (const node of nodes)
    {
        for (const input of node.inputs)
            if (   input.isConnected
                && input.connection
                && !wires.includes(input.connection.wire))
                wires.push(input.connection.wire);        

        for (const output of node.outputs)
            for (const connInput of output.connectedInputs)
                if (   connInput.connection
                    && !wires.includes(connInput.connection.wire))
                    wires.push(connInput.connection.wire);
    }


    graphView.updateNodeWires(wires);
};



graphView.updateNodeTransform = node =>
{
    const nodeLeft = node.div.offsetLeft;
    const nodeTop  = node.div.offsetTop;
    const nodeRect = graphView.getNodeOffsetRect(node.div);
    
    graphView.setNodeTransform(node, nodeLeft, nodeTop, nodeRect);
    

    const wires = [];

    for (const input of node.inputs)
        if (   input.isConnected
            && input.connection)
            wires.push(input.connection.wire);        

    for (const output of node.outputs)
        for (const connInput of output.connectedInputs)
            if (connInput.connection)
                wires.push(connInput.connection.wire);


    graphView.updateNodeWires(wires);
};



graphView.setNodeTransform = (node, nodeLeft, nodeTop, nodeRect) =>
{
    node.div.style.transform =
          'translate(' 
        + (graphView.pan.x * graphView.zoom) + 'px, '  
        + (graphView.pan.y * graphView.zoom) + 'px) '
        + 'scale(' + graphView.zoom + ')';
    
    node.div.style.transformOrigin = 
          ((graphView.pan.x - nodeLeft) / nodeRect.width  * 100) + '% ' 
        + ((graphView.pan.y - nodeTop ) / nodeRect.height * 100) + '%';  
};



graphView.updateNodeWires = wires =>
{
    const pOut    = [];            
    const pIn     = [];
    const yOffset = controlBar.offsetHeight;

    wires.forEach(w => 
    {
        const ro = boundingRect(w.connection.output.control);
        const ri = boundingRect(w.connection.input .control);

        pOut.push(point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset));
        pIn .push(point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset));
    });

    for (let i = 0; i < wires.length; i++)
    {
        wires[i].update(
            pOut[i].x, 
            pOut[i].y, 
            pIn[i].x, 
            pIn[i].y);        
    }
};



graphView.updateNodeWire = (wire, x = 0, y = 0) =>
{
    const yOffset = controlBar.offsetHeight;

    let pOut = point(0, 0),
        pIn  = point(0, 0);


    if (wire.connection.output)
    {
        const ro = boundingRect(wire.connection.output.control);
        pOut = point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset);
    }
    else
        pOut = point(x, y - yOffset);


    if (wire.connection.input)
    {
        const ri = boundingRect(wire.connection.input .control);
        pIn = point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset);
    }
    else
        pIn = point(x, y - yOffset);


    wire.update(
        pOut.x, 
        pOut.y, 
        pIn.x, 
        pIn.y);        
};



graphView.addWire = (wire, updateTransform = true) =>
{
    graphView.wires.push(wire);
    wireContainer.appendChild(wire);

    if (updateTransform)
        graphView.updateNodeWire(wire);
};



graphView.removeWire = wire =>
{
    wireContainer.removeChild(wire);    
    removeFromArray(graphView.wires, wire);
};



graphView.getNodeOffsetRect = node =>
{
    const ox   = -graphView.pan.x / graphView.zoom;
    const oy   = -graphView.pan.y / graphView.zoom;

    const rect = boundingRect(node);

    return new DOMRect(
        ox + (rect.left / graphView.zoom),
        oy + (rect.top  / graphView.zoom), 
        rect.width      / graphView.zoom, 
        rect.height     / graphView.zoom);
};



graphView.soloNode = node =>
{
    graphView._soloNode = node;

    graph.nodes.forEach(n => 
        n.div.style.opacity = 
            graphView._soloNode == n 
            ? 1 
            : 0.12);

    graph.connections.forEach(c =>
    { 
        c.wire.style.opacity = 
               c.input  && graphView._soloNode == c.input .op
            || c.output && graphView._soloNode == c.output.op
            ? 1 
            : 0.09;

        graphView.updateNodeWire(c.wire);
    });
};



graphView.unsoloNode = () =>
{
    graphView._soloNode = null;

    graph.nodes.forEach(n => n.div .style.opacity = 1);

    graph.connections.forEach(c => 
    {
        c.wire.style.opacity = 1;
        graphView.updateNodeWire(c.wire);
    });
};



graphView.toggleShowWires = () =>
{
    graphView.showWires = !graphView.showWires;
    graphView.updateShowWires();
};



graphView.updateShowWires = () =>
{
    btnToggleWires.style.color           = graphView.showWires ? 'white'   : '#d5d5d5';
    btnToggleWires.style.backgroundColor = graphView.showWires ? '#18a0fb' : (btnToggleWires.mouseOver ? 'black' : '#2c2c2c');

    graph.nodes      .forEach(n => n.updateNode());
    graph.connections.forEach(c => show(c.wire, graphView.showWires));
};


class Parameter
extends EventTarget
{
    #type;
    get type() { return this.#type; }
    
    #id;
    get id() { return this.#id; }

    #name;
    get name() { return this.#name; }

    _op;
    get op()   { return this._op; }


    valueIsValid = true;

    
    // _operator; get operator() { return this._operator; }
    _control;  get control()  { return this._control;  }
    _div;      get div()      { return this._div;      }


    input;
    output;

    
    onbeforechange = new Event('beforechange');
    onchange       = new Event('change');
    onconfirm      = new Event('confirm');



    constructor(id, name, type)
    {
        super();

        this.#id   = id;
        this.#name = name;
        this.#type = type;

        this._div = createDiv();

        this.div.style.position = 'relative';
        this.div.style.padding  = 0;
        this.div.style.width    = '100%';

        this.input  = null;
        this.output = null;
    }



    setName(name, dispatchEvents = true)
    {
        this.#name = name; 
        this.update(dispatchEvents);
    }



    initInput(hasInput, dataType)
    {
        this.input = hasInput ? new Input(dataType) : null;
        if (!this.input) return;

        this.input._param = this;
        this.input.control.style.float     = 'left';
        this.input.control.style.position  = 'absolute';
        this.input.control.style.top       = '50%';
        this.input.control.style.transform = 'translateY(-50%)';
        this.div.appendChild(this.input.control);


        this.input.addEventListener('connect', () =>
        {
            this.control.style.fontStyle = 'italic';
            this.control.readOnly        = true;
        });
    
        
        this.input.addEventListener('disconnect', () =>
        {
            this.control.style.fontStyle = 'normal';
            this.control.readOnly        = false;
        });
    }



    initOutput(hasOutput, dataType)
    {
        this.output = hasOutput ? new Output(dataType) : null;
        if (!this.output) return;

        this.output._param = this;
        this.output.control.style.float     = 'right';
        this.output.control.style.position  = 'absolute';
        this.output.control.style.top       = '50%';
        this.output.control.style.transform = 'translateY(-50%)';
        this.div.appendChild(this.output.control);
    }



    isDefault() { return false; }


    
    update(dispatchEvents)
    {
        if (   this.input
            && this.input.isConnected)
            this.input.connectedOutput.op.update();
    }    



    updateControls()
    {
        this.control.update();
        
        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    setOutputData() { }



    preSetValue(value, confirm, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (value != this.oldValue)
                this.dispatchEvent(this.onbeforechange);
        }
    }



    setValue(value, confirm, updateControl = true, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (value != this.oldValue)
            {
                this.dispatchEvent(this.onchange);
                
                if (confirm)
                {
                    actionManager.do(new SetParamValueAction(this, value));
                    this.dispatchEvent(this.onconfirm);
                }
            }
        }
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);

        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + this.value + '"]';
    }
}


class   NumberParam
extends Parameter
{
    defaultValue;
    
    allowEditDecimals = false;
    

    get value()      { return this._control.value;    }
    set value(value) { this._control.setValue(value); }
    
    get oldValue()   { return this._control.oldValue; }


    
    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                value     = 0, 
                min       = Number.MIN_SAFE_INTEGER, 
                max       = Number.MAX_SAFE_INTEGER,
                decimals  = 0,
                dragScale = 0.05)
    {
        super(id, name, 'number');

        this._control          = createDiv();
        
        this.control.param     = this;
        this.control.zIndex    = 0;
   
        this.defaultValue      = value;


        initNumberSlider(
            this,
            this.control,
            120,        // width
            20,         // height
            this.id,
            this.name, 
            showName,
            min,
            max,
            value,      // default
            decimals,   // decimals
            dragScale); // drag scale

        this.control.successOnFocusOut = true;


        this.div.appendChild(this.control);

       
        this.initInput (hasInput,  'number');
        this.initOutput(hasOutput, 'number');

        // if (this.input)
        //     this.input.addEventListener('connect', () => this.op.pushUpdate());


        this.control.addEventListener('change',  () => { this.setValue(this.value, false, false); });
        this.control.addEventListener('confirm', () => { this.setValue(this.value, true,  false); });

        this.control.addEventListener('finishedit', e =>
        { 
            if (   e.detail.success
                && this.allowEditDecimals)
            {
                actionManager.do(new SetParamDecimalsAction(this,
                    getDecimalCount(e.detail.value), 
                    getDecimalCount(e.detail.oldValue)), true);
            }
        });
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.control.setName(name);
    }



    setDecimalsFrom(strValue)
    {
        this.setDecimals(getDecimalCount(strValue));
        //this.op.pushUpdate();
    }



    setDecimals(dec)
    {
        this.control.dec     = dec;
        this.control.editDec = dec;
        this.control.update();

        this.op.pushUpdate();
    }



    isDefault()
    {
        return this.value == this.defaultValue;
    }



    update(dispatchEvents)
    {
        super.update();

        if (   this.input
            && this.input.isConnected)
        {
            this.setDecimals(this.input.data.decimals);
            this.setValue(this.input.data.value, false, true, dispatchEvents); // assuming the data types match
        }
    }



    setOutputData()
    {
        if (this.output)
        {
            this.output._data = dataFromNumber(
                this._control.value,
                   this.input
                && this.input.isConnected
                ? this.input.data.decimals
                : this._control.dec);
        }
    }



    setValue(value, confirm, updateControl = true, dispatchEvents = true, forceChange = false) 
    {
        this.preSetValue(value, confirm, dispatchEvents);

        if (updateControl)
            this._control.setValue(value, false, false, forceChange); 

        super.setValue(value, confirm, updateControl, dispatchEvents);
    }    



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + getNumberString(this.value, this._control.dec) + '"]';
    }
}


class   ColorParam
extends Parameter
{
    defaultValue;
    
    
    get value()      { return this._control.value;    }
    set value(value) { this._control.setValue(value); }
    
    get oldValue()   { return this._control.oldValue; }


    
    input;
    output;

    

    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    constructor(name, 
                hasOutput,
                value     = [0, 0, 0],
                dragScale = 0.05)
    {
        super(name, 'color');

        this._control = createDiv();
        
        this.control.param  = this;
        this.control.zIndex = 0;

        this.defaultValue = value;

        this.control.style.height = 20;


        initColorSlider(
            this.control,
            120,       // width
            20,        // height
            this.name, 
            value,     // default
            dragScale, // drag scale
            1,         // wheel step
            0,         // decimals
            0,         // acceleration
            '');       // suffix



        this.div.appendChild(this.control);


        this.initInput();
        this.initOutput(hasOutput);



        this.control.addEventListener('change', e =>
        {
            this.op.valid = false;
            uiSetParam(this, this.value);
        });


        this.control.addEventListener('confirm', e =>
        {
            this.op.valid = false;
            //actionManager.do(new SetParamValueAction(this, this.value));
        });
    }



    isDefault()
    {
        return this.value == this.defaultValue;
    }



    setValue(value, fireChangeEvent = true, confirm = true) 
    { 
        //this._control.setValue(value, fireChangeEvent, confirm); 
    }
}


class   SelectParam
extends Parameter
{
    defaultValue;

    options = [];
    

    
    get value()      { return this._control.value;    }
    set value(value) { this._control.setValue(value); }
    
    get oldValue()   { return this._control.oldValue; }



    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    constructor(id,
                name, 
                hasInput,
                hasOutput,
                options,
                value = 0)
    {
        super(id, name, 'number');

        this._control       = createDiv();
        
        this.control.param  = this;
        this.control.zIndex = 0;

        this.options        = options;
        
        this.defaultValue   = value;


        initNumberSlider(
            this,
            this.control,
            120,       // width
            20,        // height
            this.id,
            this.name, 
            false,
            0,
            options.length-1,
            value);    // default
            
        this.control.options = [...options];
        //this.control.barTop  = 0.8;

        this.div.appendChild(this.control);


        this.initInput (hasInput,  'number');
        this.initOutput(hasOutput, 'number');

            
        this.control.addEventListener('change',  () => { this.setValue(this.value, false, false); });
        this.control.addEventListener('confirm', () => { this.setValue(this.value, true,  false); });
    }



    isDefault()
    {
        return this.value == this.defaultValue;
    }



    update(dispatchEvents)
    {
        super.update();

        if (   this.input
            && this.input.isConnected)
            this.setValue(Math.round(this.input.data.value), false, true, dispatchEvents); // assuming the data types match
    }



    setOutputData()
    {
        if (this.output)
            this.output._data = dataFromNumber(this._control.value, 0);
    }



    setValue(value, confirm, updateControl = true, dispatchEvents = true, forceChange = false) 
    { 
        this.preSetValue(value, confirm, dispatchEvents);

        if (updateControl)
            this._control.setValue(value, false, false, forceChange); 

        // if (this.output)
        //     this.output._data = dataFromNumber(value);
            
        super.setValue(value, confirm, updateControl, dispatchEvents);
    }    
}


const rgbObject       = hex2rgb('#bee0ff');
const rgbActiveObject = hex2rgb('#18a0fb');
const rgbNumber       = hex2rgb('#ddd');
const rgbActiveNumber = hex2rgb('#787878');
const rgbColor        = hex2rgb('#ddd');//hex2rgb('#cc33cc'); // these are normally
const rgbActiveColor  = hex2rgb('#787878');//hex2rgb('#ff00ff'); // not used



function dataType2rgb(dataType, active)
{
    switch (dataType)
    {
        case 'number': return active ? rgbActiveNumber : rgbNumber;
        case 'color':  return active ? rgbActiveColor  : rgbColor;
        case 'object': return active ? rgbActiveObject : rgbObject;
    }

    return 'magenta';
}



function dataFromNumber(num, dec = -1)
{
    return {
        type:    'number',
        value:    num,
        decimals: dec
    };
}



function dataFromDataColor(color)
{
    return {
        type: 'color',
        color: color
    };
}



function dataFromRectangle(x, y, width, height, angle, round)//, nodeId, opType)
{
    return {
        type: 'object',

        //nodeId: nodeId,
        //opType: opType,

        x:      x,
        y:      y,
        width:  width,
        height: height,
        angle:  angle,
        round:  round
        //color: color
    };
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


class Graph
{
    nodes        = [];
    deferNodeIds = [];
    
    mutex        = false;

    connections  = [];



    clear()
    {
        this.deleteNodes(this.nodes.map(n => n.id));
        this.connections = [];
    }



    getNewNodeName(curName, name)
    {
        if (!this.nodes.find(n => n.name == name))
            return name;
        

        let numLength = this.getNumLength(name);

        if (numLength > 0)
        {
            const len = name.length - numLength;
            let   num = parseInt(name.substring(len));

            let newName = '';
            while (newName == '' || this.nodes.find(n => n.name == newName))
                newName = name.substring(0, len) + (++num);

            return newName;
        }

        else if (numLength == 0)
        {
            const len = name.length;

            let num     = 2;
            let newName = name + num;

            while (this.nodes.find(n => 
                   n.name != curName 
                && n.name == newName))
                newName = name + (++num);

            return newName;
        }

        else
            return name;
    }
    
    
    
    getNumLength(name)
    {
        let numLength = 0;

        for (let i = name.length - 1; i >= 0; i--)
        {
            if (isDigitChar(name[i])) numLength++;
            else break;
        }

        return numLength;
    }
    
    

    createNode(opType, createdNodeId = -1)
    {
        let node;

        switch (opType)
        {
            case 'number':           node = new OpNumber();           break;
            case 'limits':           node = new OpLimits();           break;
            case 'add':              node = new OpAdd();              break;
            case 'subtract':         node = new OpSubtract();         break;
            case 'multiply':         node = new OpMultiply();         break;
            case 'divide':           node = new OpDivide();           break;
            case 'exponent':         node = new OpExponent();         break;
            case 'interpolate':      node = new OpInterpolate();      break;
            // case 'random': node = new OpRandom(); break;
            
            case 'color':            node = new OpColor();            break;
            case 'colorinterpolate': node = new OpColorInterpolate(); break;
            case 'webcontrast':      node = new OpWebContrast();      break;
            case 'colorblind':       node = new OpColorblind();       break;
            
            case 'rectangle':        node = new OpRectangle();        break;
            // case 'row':    node = new OpRow();    break;
            // case 'column': node = new OpColumn(); break;
            //case 'spread': node = new OpSpread(); break;
        }
        
        if (createdNodeId > -1)
        {
            Operator.nextId--;
            node.id = createdNodeId;
        }
        
        return node;
    }



    addNodes(nodes, placeNode = true, createNewName = true)
    {
        for (const node of nodes)
            this.addNode(node, placeNode, createNewName, false);
        
        setTimeout(() =>
        {
            for (const node of nodes)
                updateNodeLabel(node);
        });
    }



    addNode(node, placeNode = true, createNewName = true, updateLabel = true)
    {
        node.graph = this;

        if (createNewName)
            node.setName(this.getNewNodeName(node.name, node.name));
        
        this.nodes.push(node);
        graphView.appendChild(node.div);
        
        if (placeNode)
            graphView.placeNewNode(node);
        
        node.div.style.zIndex = graph.nodes.length-1;

        graphView.putNodeOnTop(node);
        graphView.updateScroll();

        if (updateLabel)
            setTimeout(() => updateNodeLabel(node));
    }
    


    deleteNodes(nodeIds)
    {
        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            for (let i = node.inputs.length-1; i >= 0; i--) // backwards for the sake of variable inputs
            {
                const input = node.inputs[i];
                if (!input.isConnected) continue;

                input.connectedOutput.op.makeActive();
                this.disconnect(input, true);
            }
            
            for (let i = node.outputs.length-1; i >= 0; i--)
            {
                const output = node.outputs[i];
                
                for (const connInput of output.connectedInputs)
                {
                    this.disconnect(connInput, true);
    
                    // if (!activeNodeInTree(connInput.op))
                    //     lastNodesInTreeFrom(connInput.op).forEach(n => n.makeActive());
                    //     connInput.op.lastNodeInTree.makeActive();
                }
            }
            
            node.selected = false;
            node.graph    = null;

            removeFromArray(this.nodes, node);
            graphView.removeChild(node.div);
        }

        graphView.updateScroll();
    }



    connect(output, input, inputIndex = -1)
    {
        //console.log('graph.connect()');
        if (input.connectedOutput == output)
            return false;
            

        if (input.connectedOutput)
        {
            const output = input.connectedOutput;
            this.disconnect(input);
            output.updateControl();
        }


        if (   input.op._variableInputs
            && inputIndex > -1)
        {
            input = lastOf(input.op.inputs);
            
            // move new input back to correct index
            moveIn(input.op.inputs, input.op.inputs.length-1, inputIndex);

            input.op.inputControls.insertBefore(
                lastOf(input.op.inputControls.childNodes), 
                input.op.inputControls.childNodes[inputIndex]);
        }


        output.connectedInputs.push(input);
        input .connectedOutput = output;


        const conn = new Connection(output, input);

        input .connection = conn;
        output.connection = conn;
        
        graphView.addWire(conn.wire);

        this.connections.push(conn);

        
        output.op.makePassive();

        if (!activeNodeInTree(input.op))
            input.op.makeActive();
       
           
        output.updateControl();


        return true;
    }



    disconnect(input)
    {
        //console.log( 'graph.disconnect(' + input.op.name + '.in[' + input.op.inputs.indexOf(input) + '])');
        // first remove the current output

        if (activeNodeInTree(input.op))
            uiDeleteNodeObjects([activeNodeInTree(input.op).id]);


        // then disconnect

        var output = input.connectedOutput;
        if (!output) return false;


        graphView.removeWire(input.connection.wire);

        removeFromArray(this.connections, input.connection);
        removeFromArray(output.connectedInputs, input);

        
        input .connectedOutput = null;
        input .connection      = null;
        output.connection      = null;


        if (input.param)
            input.param.valueText = '';


        if (!activeNodeInTree(output.op))
             output.op.makeActive();
            
        
        output.updateControl();
        input.op.pushUpdate();


        return true;
    }



    nodeFromId(id)
    {
        return this.nodes.find(n => n.id == id);
    }



    toJson()
    {
        const tab = '  ';

        let json = '{\n'
            + tab + '"version": "0",\n'
            + tab + '"zoom": "'      + graphView.zoom  + '",\n'
            + tab + '"panx": "'      + graphView.pan.x + '",\n'
            + tab + '"pany": "'      + graphView.pan.y + '",\n'
            + tab + '"showWires": "' + (graphView.showWires ? 'true' : 'false') + '",\n';

        json += nodesToJson(this.nodes, false);

        json += '\n}';


        return json;
    }
}



function nodesToJson(nodes, encloseBraces = true, connOutputMustBeInNodes = true)
{
    const tab = '  ';

    
    let json = 
          (encloseBraces ? '{\n' : '')
          + tab + '"nodes":\n'
          + tab + '[';


    let first = true;
    for (let i = 0; i < nodes.length; i++)
    {
        if (!first) json += ','; first = false;
        json += '\n' + nodes[i].toJson(4);
    }
    

    json += 
            '\n' + 
          tab + ']';
          
          
    json += this.connectionsToJson(nodes, connOutputMustBeInNodes);


    json += (encloseBraces ? '\n}' :'');


    return json;
}



function connectionsToJson(nodes, connOutputMustBeInNodes)
{
    const connections = [];


    for (let i = 0; i < nodes.length; i++)
    {
        let node = nodes[i];

        for (let j = 0; j < node.inputs.length; j++)
        {
            if (   !node.inputs[j].isConnected
                ||    !nodes.includes(node.inputs[j].connectedOutput.op)
                   && connOutputMustBeInNodes)
                continue;

            connections.push(node.inputs[j].connection);
        }
    }
    

    if (connections.length == 0)
        return '';


    const tab = '  ';

    let json = 
          ',\n'
        + tab + '"connections":\n'
        + tab + '[';

    
    for (let i = 0; i < connections.length; i++)
    {
        if (i > 0) json += ',';
        json += '\n' + connections[i].toJson(4);
    }


    json += '\n'
        + tab + ']';


    return json;
}


function activeNodeInTree(node) 
{ 
    const left  = activeNodeLeft(node);  if (!!left ) return left;
    const right = activeNodeRight(node); if (!!right) return right;

    return null;
}



function activeNodeLeft(node)
{
    if (node.active) return node;

    for (const input of node.inputs)
    {
        if (input.isConnected)
        {
            const left = activeNodeLeft(input.connectedOutput.op);
            if (left) return left;
        }
    }

    return null;
}



function activeNodeRight(node)
{
    if (node.active) return node;

    for (const output of node.outputs)
    {
        for (const connInput of output.connectedInputs)
        {
            const right = activeNodeRight(connInput.op);
            if (right) return right;
        }
    }

    return null;
}



function getNodesBeforeNode(node)
{
    let before = [];

    for (const input of node.inputs.filter(i => i.isConnected))
    {
        if (!before.includes(input.connectedOutput.op)) // avoid including diamond tips twice
            before.push(input.connectedOutput.op);
    
        before.push(...getNodesBeforeNode(input.connectedOutput.op));
    }

    return before;
}



function getNodesAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
        for (const input of output.connectedInputs)
        {
            if (!after.includes(input.op)) // avoid including diamond tips twice
                after.push(input.op);

            after.push(...getNodesAfterNode(input.op));
        }

    return after;
}



function getTerminalsAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
        for (const input of output.connectedInputs)
            after.push(...getTerminalsAfterNode(input.op));

    return after.length > 0 ? after : [node];;
}



function updateTerminalsAfterNodes(nodes, includeNodeInEmpty = true)
{
    const terminals = [];

    for (const node of nodes)
    {
        const tt = getTerminalsAfterNode(node);

        for (const t of tt)
        {
            if (!terminals.includes(t))
                terminals.push(t);
        }
    }

    for (const t of terminals)
        t.update();
}


class   Input
extends EventTarget
{
    _dataType;     
    get dataType() { return this._dataType; }

    get data()
    {
        return (
            this.isConnected
            ? this.connectedOutput.data
            : null);
    }


    _op    = null; get op   () { return this._op;    }
    _param = null; get param() { return this._param; }

    
    color;
    wireColor;

    control;
    hitbox;
    wireBall;
  

    _connectedOutput = null;
    get connectedOutput() { return this._connectedOutput; }
    set connectedOutput(output)
    {
        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'disconnect', 
                { 'input': this }));
        }

        this._connectedOutput = output;

        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'connect', 
                { 
                    'output': output,
                    'input':  this 
                }));
        }
    }


    connection = null;
    
    connecting = false;
    mouseOver  = false;
    

    initialSeed = 0;
    currentSeed = 0;

    get isConnected() { return this.connectedOutput != null; }


    onconnect    = new Event('connect');
    ondisconnect = new Event('disconnect');



    constructor(dataType)
    {
        super();
        
        this._dataType = dataType;

        this.control  = createDiv('input');
        this.hitbox   = createDiv('inputHitbox');
        this.wireBall = createDiv('inputBall');
        
        this.control.input = this;
        

        this.control.appendChild(this.hitbox);
        this.control.appendChild(this.wireBall);

        this.color     = [0, 0, 0, 0.12];
        this.wireColor = dataType2rgb(this.dataType, true);

        
        this.hitbox.addEventListener('pointerdown', e => e.preventDefault());


        this.hitbox.addEventListener('pointerenter', e => 
        {
            if (graphView.headerInput)
            {
                graphView.headerInput.updateControl();
                graphView.headerInput = null;
            }

            this.mouseOver = true;
            this.updateControl();

            if (   graphView.tempConn
                && graphView.tempConn.output
                && graphView.tempConn.output.dataType == this.dataType)
            {
                const rect = boundingRect(this.control);
                const loop = graphView.tempConn.output.op.follows(this.op);

                if (!loop)
                {
                    graphView.tempConn.wire.inputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - controlBar.offsetHeight);
                }

                graphView.overInput = !loop ? this : null;
                this.op.inputs.forEach(i => i.updateControl());
            }
            else
                graphView.overInput = this;
        });


        this.hitbox.addEventListener('pointerleave', e => 
        {
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overInput = null;

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.output)
            graphView.tempConn.wire.inputPos = point_NaN;
    }



    updateControl()
    {
        const mouseOver =
               this.mouseOver
            && !(   graphView.tempConn
                 && graphView.tempConn.input)
            && !(   graphView.tempConn
                 && graphView.tempConn.output
                 && (   graphView.tempConn.output.dataType != this.dataType
                     || graphView.tempConn.output.op.follows(this.op)));

        const colorStyle = 
            graphView.showWires
            ? colorStyleRgba(rgb_a(
                this.color, 
                mouseOver 
                ? Math.min(this.color[3] * 1.8, 1) 
                : this.color[3]))
            : 'transparent';


        const isConnected =
               this.isConnected
            ||     graphView.tempConn
               && (   graphView.tempConn.input == this
                   ||    graphView.overInput == this
                      && !graphView.tempConn.input)
               && !(   graphView.tempConn.output
                    && graphView.tempConn.output.dataType != this.dataType);

        this.control.style.transform = 
              'translateX(' + (isConnected ? -1 : 0) + 'px)'
            + 'translateY(-50%)';
        
        this.control.style.width         = (isConnected ? 8 : 6) + 'px';
        this.control.style.height        = (isConnected ? 8 : 6) + 'px';
        this.control.style.borderRadius  = (isConnected ? 4 : 4) + 'px';
        this.control.style.marginBottom  = (isConnected ? 4 : 6) + 'px';
        this.control.style.boxShadow     = '0 0 0 1px ' + colorStyle;
        this.control.style.pointerEvents = graphView.showWires ? 'auto' : 'none';

        this.hitbox.style.left = isConnected ? -2 : -3;
        this.hitbox.style.top  = isConnected ? -2 : -3;

        this.wireBall.style.backgroundColor = 
            this.isConnected
            ? (   graphView.savedConn
               && graphView.savedConn.input == this
               && graphView.overInput != this
               ? 'transparent'
               : colorStyleRgba(toRgba(this.connectedOutput.wireColor)))
            : (   graphView.tempConn
               && graphView.tempConn.output
               && graphView.tempConn.output.dataType == this.dataType
               && graphView.overInput == this
               ? colorStyleRgba(toRgba(graphView.tempConn.output.wireColor))
               : (   graphView.tempConn
                  && graphView.tempConn.input
                  && graphView.tempConn.input == this)
                  ? (graphView.overOutput
                     ? colorStyleRgba(toRgba(graphView.overOutput.wireColor))
                     : (graphView.headerOutput
                        ? colorStyleRgba(toRgba(graphView.headerOutput.wireColor))
                        : colorStyleRgba(toRgba(graphView.tempConn.input.wireColor))))
                  : colorStyle);

        this.wireBall.style.zIndex = MAX_INT32;
        this.wireBall.style.left   = '1px';
        this.wireBall.style.top    = 'calc(50% - 3px)';


        show(this.wireBall, isConnected); 
    }
}


class Output
{
    _dataType;     
    get dataType() { return this._dataType; }

    _op    = null; get op()    { return this._op;    }
    _param = null; get param() { return this._param; }
    
    
    color;
    wireColor;

    control;
    hitbox;
    wireBall;
    
    
    connectedInputs = [];
    
    mouseOver  = false;
    connecting = false;
    
    
    _data;

    get data() 
    {
        this.op.update();
        return this._data;
    }
    
    set data(value)
    {
        this._data = value;

        // for (const input of this.connectedInputs)
        //     input.op.pushUpdate();
    }



    get isConnected() { return this.connectedInputs.length > 0; }



    constructor(dataType)
    {
        this._dataType = dataType;
        
        this.control  = createDiv('output');
        this.hitbox   = createDiv('outputHitbox');
        this.wireBall = createDiv('outputBall');
        
        this.control.output = this;
        
        
        this.control.appendChild(this.hitbox);
        this.control.appendChild(this.wireBall);

        this.color     = [0, 0, 0, 0.12];
        this.wireColor = dataType2rgb(this._dataType, true);
        
        this.updateControl();

        

        this.hitbox.addEventListener('pointerenter', e => 
        { 
            if (graphView.headerOutput)
            {
                graphView.headerOutput.updateControl();
                graphView.headerOutput = null;
            }


            this.mouseOver = true;
            this.updateControl();


            if (   graphView.tempConn
                && graphView.tempConn.input
                && graphView.tempConn.input.dataType == this.dataType)
            {
                const rect = boundingRect(this.control);
                const loop = this.op.follows(graphView.tempConn.input.op);

                if (!loop)
                {
                    graphView.tempConn.wire.outputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - controlBar.offsetHeight);
                }

                graphView.overOutput = !loop ? this : null;
                this.op.outputs.forEach(o => o.updateControl());
            }
            else
                graphView.overOutput = this; 
        });



        this.hitbox.addEventListener('pointerleave', e => 
        { 
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overOutput = null; 

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.input)
            graphView.tempConn.wire.outputPos = point_NaN;
    }



    updateControl()
    {
        const mouseOver =
               this.mouseOver
            && !(   graphView.tempConn
                 && graphView.tempConn.output)
            && !(   graphView.tempConn
                 && graphView.tempConn.input
                 && (   graphView.tempConn.input.dataType != this.dataType
                     || this.op.follows(graphView.tempConn.input.op)));

        const colorStyle = 
            graphView.showWires
            ? colorStyleRgba(rgb_a(this.color, mouseOver ? Math.min(this.color[3] * 1.4, 1) : this.color[3] / 1.4))
            : 'transparent';

        this.control.style.pointerEvents = graphView.showWires ? 'auto' : 'none';
        this.control.style.backgroundColor = colorStyle;

        this.control.style.boxShadow = 
               this.connectedInputs.length > 0
            ||    graphView.tempConn
               && (   graphView.tempConn.output == this
                   || graphView.overOutput == this)
            ? '0 0 0 1px ' + colorStyle
            : 'none';

        this.wireBall.style.backgroundColor = colorStyleRgba(toRgba(this.wireColor));

        this.wireBall.style.zIndex = MAX_INT32;


        const isConnected =
               this.connectedInputs.length > 0
            ||     graphView.tempConn
               && (   graphView.tempConn.output == this
                   ||     graphView.overOutput == this
                      && !graphView.tempConn.output)
               && !(   graphView.tempConn.input
                    && graphView.tempConn.input.dataType != this.dataType);

        show(this.wireBall, isConnected);
    }
}


class Connection
{
    output;
    input;

    wire;


    constructor(output, input)
    {
        this.output = output;
        this.input  = input;


        this.wire                        = createSvg('svg');
        this.wire.connection             = this;
        this.wire.style.position         = 'absolute';
        this.wire.style.left             = 0;
        this.wire.style.top              = 0;
        this.wire.style.width            = '100%';
        this.wire.style.height           = '100vh';
  
        this.wire.outputPos              = point_NaN;
        this.wire. inputPos              = point_NaN;
  
        this.wire.curve                  = createSvg('path');
        this.wire.curve.style.fill       = 'none';
        this.wire.curve.style.position   = 'absolute';

        this.wire.outBall                = createSvg('circle');
        this.wire.outBall.style.position = 'absolute';

        this.wire.inBall                 = createSvg('circle');
        this.wire.inBall.style.position  = 'absolute';


        this.wire.appendChild(this.wire.curve);
        this.wire.appendChild(this.wire.outBall);
        this.wire.appendChild(this.wire.inBall);

        

        this.wire.update = (x1, y1, x2, y2) =>
        {
            const cw      = graphView.clientWidth;
            const ch      = graphView.clientHeight;
            const yOffset = controlBar.offsetHeight;
        
            // the yOffset is to start wire coords just below the control bar,
            // not at the top of the window

            this.wire.updateCurve  (x1, y1, x2, y2);
            this.wire.updateOutBall(x1, y1        );
            this.wire.updateInBall (        x2, y2);

            this.wire.updateStyle(this.wire.getColor());

            this.wire.setAttribute('width',  cw);
            this.wire.setAttribute('height', ch);
        
            this.wire.setAttribute('viewBox',
                        0
                + ' ' + yOffset/2 // why is only half of yOffset taken???
                + ' ' + cw
                + ' ' + ch);

            
            show(
                this.wire, 
                (   graphView.showWires
                 ||    graphView._soloNode
                       && (   this. input.op == graphView._soloNode
                           || this.output.op == graphView._soloNode)) 
                && this != graphView.savedConn);

            show(
                this.wire.curve, 
                   (   graphView.showWires 
                    || graphView._soloNode) 
                && this != graphView.savedConn);

            show(this.wire.outBall, !graphView.tempConn || graphView.tempConn.output);
            show(this.wire.inBall,  !graphView.tempConn || graphView.tempConn. input);
        };



        this.wire.updateCurve = (x1, y1, x2, y2) =>
        {
            if (!pointIsNaN(this.wire.outputPos))
            {
                x1 = this.wire.outputPos.x;
                y1 = this.wire.outputPos.y;
            }

            if (!pointIsNaN(this.wire.inputPos))
            {
                x2 = this.wire.inputPos.x;
                y2 = this.wire.inputPos.y;
            }

            
            const _x0 = x1;
            const _y0 = y1;

            const _x3 = x2;
            const _y3 = y2;


            const tx  = 600 * graphView.zoom;
            const ty  = 300 * graphView.zoom;
            const ecc = 100 * graphView.zoom;

            const yf  = (0.3 + Math.min(Math.abs(y2 - y1) / ty, 0.8));

            const df  = Math.pow((1 - Math.min(Math.abs(_x3 - _x0) / tx, 0.65)), 0.5)
                      * yf;

            const dx = 
                  (_x3 - _x0) * df 
                * (_x3 < _x0 ? -1 : 1);


            let _x1 = Math.max(_x0 + ecc * Math.pow(0.1 + yf*0.9, 1.5), _x0 + dx);
            let _y1 = _y0;

            let _x2 = Math.min(_x3 - ecc * Math.pow(0.1 + yf*0.9, 1.5), _x3 - dx);
            let _y2 = _y3;


            if (   graphView.tempConn == this
                && graphView.tempConn.output == graphView.overOutput)
            {
                _x1 += (_x0 - _x1) * 5/8;
                _y1 += (_y0 - _y1) * 5/8;
            }

            if (   graphView.tempConn == this
                && graphView.tempConn.input == graphView.overInput)
            {
                _x2 += (_x3 - _x2) * 5/8;
                _y2 += (_y3 - _y2) * 5/8;
            }

            
            this.wire.curve.setAttribute('d',
                   'M ' + _x0 + ',' + _y0
                + ' C ' + _x1 + ',' + _y1
                + ' '   + _x2 + ',' + _y2
                + ' '   + _x3 + ',' + _y3);
        };



        this.wire.getColor = () =>
        {
            if (this.output)
                return this.output.wireColor;

            else if (this.input)
            {
                if (   graphView.overOutput
                    && graphView.overOutput.dataType == this.input.dataType) 
                    return graphView.overOutput.wireColor;
                else
                    return this.input.wireColor;
            }
                
            else 
                return [255, 0, 255];
        };



        this.wire.updateOutBall = (x, y) =>
        {
            this.wire.outBall.setAttribute('cx', x);
            this.wire.outBall.setAttribute('cy', y);
        };



        this.wire.updateInBall = (x, y) =>
        {
            this.wire.inBall.setAttribute('cx', x);
            this.wire.inBall.setAttribute('cy', y);
        };



        this.wire.updateStyle = (color) =>
        {
            const l = rgb2hclokl(color)[2];
            
            const bright       = Math.min(Math.max(0, (l-0.6) / 0.4), 1);
            const innerOpacity = Math.round(bright * 44 * Math.min(graphView.zoom, 1)).toString(16).padStart(2, '0');
            const outerOpacity = Math.round(bright * 60).toString(16).padStart(2, '0');

            this.wire.curve.style.filter = 
                l > 0.6
                ?   'drop-shadow(0px 0px 1px #000000' + innerOpacity + ') '
                  + 'drop-shadow(0px 0px 6px #000000' + outerOpacity + ')'
                : 'none';

            this.wire.curve.style.stroke      = colorStyleRgb(color);
            this.wire. inBall.style.fill      = colorStyleRgb(color);
            this.wire.outBall.style.fill      = colorStyleRgb(color);

            this.wire.curve.style.strokeWidth = (1.2 + 0.3 * bright * (1 + 1/(graphView.zoom/4))) * graphView.zoom;
            this.wire. inBall.style.r         = 3 * graphView.zoom;
            this.wire.outBall.style.r         = 3 * graphView.zoom;

            this.wire.style.zIndex = 0;
        };
    }



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';
        
        let json = 
              pos + '{'
            +  '\n' + pos + tab + '"outputOp": "'    + this.output.op.name + '"'
            + ',\n' + pos + tab + '"outputIndex": "' + this.output.op.outputs.indexOf(this.output) + '"'
            + (this.output.param ? ',\n' + pos + tab + '"outputParam": "' + this.output.param.name + '"' : '')
            + ',\n' + pos + tab + '"inputOp": "'     + this.input.op.name + '"'
            + ',\n' + pos + tab + '"inputIndex": "'  + this.input.op.inputs.indexOf(this.input) + '"'
            + (this.input.param ? ',\n' + pos + tab  + '"inputParam": "' + this.input.param.name + '"' : '')
            +  '\n' + pos + '}';

        return json;
    }



    static parseJson(_conn)
    {
        const outputOp    = graph.nodes.find(n => n.name == _conn.outputOp);
        const outputIndex = parseInt(_conn.outputIndex);

        const inputOp     = graph.nodes.find(n => n.name == _conn.inputOp);
        const inputIndex  = parseInt(_conn.inputIndex);

        uiVariableConnect(outputOp, outputIndex, inputOp, inputIndex);
    }
}



function getConnectionForArrayWithIds(conn)
{
    return {
        outputOpId:  conn.output.op.id,
        outputIndex: conn.output.op.outputs.indexOf(conn.output),
        inputOpId:   conn.input .op.id,
        inputIndex:  conn.input .op. inputs.indexOf(conn. input)};
}



function getConnectionForArrayWithNames(conn)
{
    return {
        outputOpName: conn.output.op.name,
        outputIndex:  conn.output.op.outputs.indexOf(conn.output),
        inputOpName:  conn.input .op.name,
        inputIndex:   conn.input .op. inputs.indexOf(conn. input)};
}


class Operator
{
    #opType;
    get opType() { return this.#opType; }
    
    _dataType;
    get dataType() { return this._dataType; }

    _name;
    get name() { return this._name; }
    set name(name)
    {
        this._name = name;
        this.label.innerHTML = name;
    }

    shortTypeName;
    defaultWidth;

    static nextId = 0;
    id = Operator.nextId++;


    graph = null;
    
    
    inputs  = [];
    outputs = [];
    params  = [];
    
    
    _variableInputs = false;

    alwaysLoadParams;
    loaded;

    labelOffsetFactor;

    
    // node UI

    div;
    inner;
    header;
    paramBack;
    labelWrapper;
    label;
    inputControls;
    outputControls;



    valid; // this is the flag for regeneration



    _selected;
    get selected() { return this._selected; }
    set selected(sel) 
    {
        if (this._selected)
            removeFromArray(graphView.selectedNodes, this);

        this.setSelected(sel);     

        if (this._selected)
            graphView.selectedNodes.push(this);
    }        



    _active = false;
    get active() { return this._active; }
       
    
    get activeColor()
    {
        switch (this._dataType)
        {
            case 'number': return rgbNumber; //activeNumberColor;
            case 'color':  return rgbActiveColor;
            case 'object': return rgbActiveObject;
        }

        return 'magenta';
    }



    get passiveColor()
    {
        switch (this._dataType)
        {
            case 'number': return rgbNumber;
            case 'color':  return rgbColor;
            case 'object': return rgbObject;
        }

        return 'magenta';
    }



    constructor(opType, shortType, dataType, defWidth = 80)
    {
        this.#opType           = opType;   // this is the operator type
        this._dataType         = dataType; // this is the op's main data type
           
        this.shortTypeName     = shortType;
        this._name             = shortType; // this is a temp until the op becomes a graph node
     
        this.valid             = false;

        this.defaultWidth      = defWidth;
        
        this.loaded            = false;
        this.alwaysLoadParams  = false;

        this.labelOffsetFactor = 0;

        createOperatorNode(this);
    }    



    addInput(input)
    {
        input._op = this;
        this.inputs.push(input);
        this.inputControls.appendChild(input.control);
    }



    getAutoInput(dataType)
    {
        const inputs = this.inputs.filter(i => i.dataType == dataType);

        
        if (graphView.overInput)
            return graphView.overInput;

        if (   graphView.savedConn
            && graphView.savedConn.input
            && graphView.savedConn.input.op == this)
            return graphView.savedConn.input;
        
        else if (!graphView.tempConn.output.op.follows(this))
        {
            if (this._variableInputs)
                return lastOf(inputs);

            else
            {
                for (const input of inputs)
                {
                    if (!input.isConnected)
                        return input;
                }
            }

            return null;
        }
    }



    addOutput(output)
    {
        output._op = this;
        this.outputs.push(output);
        this.outputControls.appendChild(output.control);
    }



    getAutoOutput(dataType)
    {
        const outputs = this.outputs.filter(o => o.dataType == dataType);

        return     outputs.length == 1
               && !this.follows(graphView.tempConn.input.op)
               ? outputs[0]
               : null;
    }



    addParam(param)
    {
        this.params.push(param);
        
        param._op = this;

        if (param.input)
        {
            param.input._op = this;
            this.inputs.push(param.input);
        }

        if (param.output)
        {
            param.output._op = this;
            this.outputs.push(param.output);
        }

        param.control.style.display = 'inline-block';
        param.control.style.width   = '100%';
        
        this.inner.appendChild(param.div);
    }
 
    

    reset() // for the entire generation run
    {
        for (const input of this.inputs)
        {
            input.currentSeed = input.initialSeed;
            
            if (input.isConnected)
                input.connectedOutput.op.reset();
        }
    }



    // refresh() // for repeats requests from nodes that duplicate their input, like row and column
    // {
    //     for (const input of this.inputs)
    //     {
    //         if (input.isConnected)
    //             input.connectedOutput.op.refresh();
    //     }
    // }


    
    invalidate()
    {
        if (!this.valid) // stops an op with inputs from same output 
            return;      // from being invalidated more than once
    
        this.valid = false;


        for (const output of this.outputs)
            for (const connInput of output.connectedInputs)
                connInput.op.invalidate();
    }



    pushUpdate()
    {
        //log(this.name + '.Operator.pushUpdate()');

        this.invalidate();
        
        setTimeout(() => { getTerminalsAfterNode(this).forEach(n => n.update()); });
    }



    update()
    {
        if (this.valid) return;
        
        //log(this.name + '.Operator.update()');
    
        this.updateParams(false);
        this.updateData();

        this.valid = true;

        if (graphView.canUpdateNodes)
            this.updateNode();
    }



    updateData()
    {
        //log(this.name + '.Operator.updateData()');

        this.setParamOutputData();
    }



    updateNode() 
    {
        //log(this.name + '.Operator.updateNode()');

        this.updateBorder();
        this.updateHeader();
        this.updateParamControls();

        graphView.updateNodeTransform(this);
    }



    updateBorder()
    {
        this.inner.style.boxShadow = 
              '0 0 0 1px ' 
            + (this.div.over ? colorStyleRgb(rgbActiveObject) : '#0001');
    }



    updateHeader()
    {
        //log(this.name + '.Operator.updateHeader()');
        

        const height = this.updateHeaderInputsAndOutputs();

        this.header.style.height = height;

        this.paramBack.style.height = this.inner.offsetHeight - height;
        this.paramBack.style.top    = height;


        updateNodeLabel(this);
    }



    updateHeaderInputsAndOutputs()
    {
        const headerInputs  = this.inputs .filter(i => !i.param);
        const headerOutputs = this.outputs.filter(o => !o.param);

        const padding  = this.header.connectionPadding;
            
        const [ inputY,  inputHeight] = getHeaderConnY(headerInputs,  padding, 9, 4, 5);
        const [outputY, outputHeight] = getHeaderConnY(headerOutputs, padding, 9, 4, 2);

             if (inputHeight  > outputHeight) for (let i = 0; i < headerOutputs.length; i++) outputY[i] += (inputHeight  - outputHeight)/2;
        else if (outputHeight > inputHeight ) for (let i = 0; i < headerInputs .length; i++)  inputY[i] += (outputHeight - inputHeight )/2;


        for (let i = 0; i < headerInputs .length; i++) 
        {
            headerInputs[i].control.style.top = inputY[i];
            headerInputs[i].updateControl();
        }

        for (let i = 0; i < headerOutputs.length; i++) 
        {
            headerOutputs[i].control.style.top = outputY[i];
            headerOutputs[i].updateControl();
        }


        return Math.max(inputHeight, outputHeight) 
             + this.header.connectionPadding * 2;
    }



    updateParams(dispatchEvents)
    {
        for (const param of this.params)
            param.update(dispatchEvents);
    }



    setParamOutputData()
    {
        for (const param of this.params)
            param.setOutputData();
    }



    updateParamControls()
    {
        this.params.forEach(p => p.updateControls());
    }



    setName(newName)
    {
        // if (this.graph.nodes.find(node => node.id == newName))
        //     return false; // graph already contains a node with this id

        this._name = newName;
        this.label.innerHTML = /*this.id + ': ' +*/newName;

        return true;
    }



    isBefore(node)
    {
        if (!this.outputs.find(o => o.isConnected))
            return false;

        for (const input of output.connectedInputs)
        {
            if (input.op == node)        return true;
            if (input.op.isBefore(node)) return true;
        }

        return false;
    }



    isAfter(node)
    {
        if (this.inputs.length == 0)
            return false;

        for (const input of inputs)
        {
            if (input.connectedOutput.op == node)       return true;
            if (input.connectedOutput.op.isAfter(node)) return true;
        }

        return false;
    }

    

    updateConnectedInputValueText() {}



    setSelected(sel)
    {
        this._selected = sel;

        this.div.style.boxShadow = 
            this._selected
            ? '0 0 0 2px ' + colorStyleRgb(rgbActiveObject)
            : 'none';
    }
    


    makeActive() // only true
    {
        this.makeLeftPassive();
        this.makeRightPassive();        

        this._active = true;
        uiSetActive(this, true);

        //this.header.style.backgroundColor = this.activeColor;
        //this.header.style.boxShadow       = 'none';
        //this.label .style.color           = this.dataType == 'object' ? 'white' : 'black';
        
        // if (this.dataType == 'object')
        //     uiGenerateObjects([this.id]);
    }
        
    

    makeLeftPassive()
    {
        for (const input of this.inputs)
        {
            if (input.isConnected)
            {
                input.connectedOutput.op.makePassive();
                input.connectedOutput.op.makeLeftPassive();            
            }
        }
    }
    


    makeRightPassive()
    {
        for (const output of this.outputs)
        {
            for (const connInput of output.connectedInputs)
            {
                connInput.op.makePassive();
                connInput.op.makeRightPassive();            
            }
        }
    }
    


    makePassive()
    {
        if (this.active)
        {
            // this.header.style.backgroundColor = this.passiveColor;
            // this.header.style.boxShadow       = '0 0 0 1px #0001 inset';
            // this.label .style.color           = 'black';

            uiDeleteNodeObjects([this.id]);
        }

        this._active = false;
        uiSetActive(this, false);
    }



    follows(node)
    {
        for (const input of this.inputs)
        {
            if (input.op == node)
                return true;
                
            else if (input.isConnected
                  && input.connectedOutput.op.follows(node))
                return true;
        }

        return false;
    }



    paramIsConsideredDefault(param)
    {
        return param.isDefault()
            && (   !param.input 
                || !param.input.isConnected);
    }



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';
        
        let json = 
              pos + '{\n'
            + this.toJsonBase(nTab);

        if (this.params.filter(p => !this.paramIsConsideredDefault(p)).length > 0)
        {
            json +=
                ',\n'
                + pos + tab + '"params":\n'
                + pos + tab + '[\n';

            json += this.paramsToJson(nTab);

            json += 
                pos + tab + ']';
        }

        json += '\n' + pos + '}';

        return json;
    }



    toJsonBase(nTab)
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        let json =
              pos + tab + '"type": "'        + this.opType            + '",\n'
            + pos + tab + '"name": "'        + this.name              + '",\n'
            + pos + tab + '"x": "'           + this.div.style.left    + '",\n'
            + pos + tab + '"y": "'           + this.div.style.top     + '",\n'
            + pos + tab + '"labelOffset": "' + this.labelOffsetFactor + '"';

        return json;
    }



    paramsToJson(nTab)
    {
        let pos = ' '.repeat(nTab);

        let json = '';

        let first = true;
        for (const param of this.params)
        {
            if (   !param.isDefault()
                && (   !param.input
                    || !param.input.isConnected))
            {
                if (!first) json += ',\n'; first = false;
                json += pos + param.toJson(nTab);
            }
        }

        if (!first)
            json += '\n';

        return json;
    }



    loadParams(_node)
    {
        if (_node.params)
        {
            for (const _param of _node.params)
            {
                const index = this.params.findIndex(p => p.id == _param[0]);
                
                if (index >= 0) 
                {
                    this.params[index].setValue(parseFloat(_param[1]), true, true, false);
                    //this.params[index].setDecimalsFrom(_param[1]);
                }
            }
        }
    }



    toString() 
    { 
        // create the definition string here

        /*

            A definition string is only to calculate graph results.

            [ ] = optional
            ... = list

            The general format is

                opType [params...] [inputs...]


            #               # of following values
            N               number value
            C               color value


            OpNumber        number [N]

            OpArithmetic    add [onlySymbol] # N...

            OpColor         color [color C] [space N] [c1 N] [c2 N] [c3 N]

            OpWebContrast   webcontrast [wcag N] [1:C] [2:C]

        */
    }
}



function getHeaderConnY(conns, padding, connSize, gap, offset)
{
    const y      = [];
    let   height = 0;
    
    for (let i = 0; i < conns.length; i++)
    {
        if (i > 0) height += gap;
        y.push(offset + padding + height);
        height += connSize;
    }

    return [y, height];
}


class OperatorBase
extends Operator
{
    updateHeader()
    {
        //log(this.name + '.OperatorBase.updateHeader()');

        this.header.style.backgroundColor = colorStyleRgb_a(dataType2rgb(this._dataType, false), 0.95);

        super.updateHeader();
    }
}


function createOperatorNode(node)
{
    node.div                    = createDiv('node');
    node.div.op                 = node;
       
    node.div.style.width        = node.defaultWidth + 'px';
           
    node.div.selectedSet        = false;
    node.div.over               = false;
    node.div.dragging           = false;
    node.div.shiftOnPointerDown = false;
    node.div.moved              = false;
       
    node.inner                  = createDiv('nodeInner');


    node.div.appendChild(node.inner);


    node.div.addEventListener('pointerenter', e =>
    {
        node.div.over      = true;
        graphView.overNode = node;
        
        if (e.altKey) 
            graphView.soloNode(node);
        
        node.updateBorder();
    });

    
    node.div.addEventListener('pointerleave', e =>
    {
        node.div.over      = false;
        graphView.overNode = null;
        
        if (!e.altKey) 
            graphView.unsoloNode();

        node.updateBorder();
    });

    
    node.paramBack = createDiv('nodeParamBack');
    node.inner.appendChild(node.paramBack);
    

    createNodeHeader(node);
}     



function createNodeHeader(node)
{
    node.header = createDiv('nodeHeader');
    
    node.header.connectionPadding = 8;


    createNodeLabel(node);

    
    node. inputControls = createDiv('inputControls');
    node.outputControls = createDiv('outputControls');

    node.header.appendChild(node. inputControls);
    node.header.appendChild(node.outputControls);

    node.inner.appendChild(node.header);



    node.header.addEventListener('pointerleave', e => 
    { 
        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.op != node)
            {
                const input = graphView.headerInput;
                
                graphView.overInput   = null;
                graphView.headerInput = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.op != node)
            {
                const output = graphView.headerOutput;
                
                graphView.overOutput   = null;
                graphView.headerOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    node.header.addEventListener('pointerdown', e =>
    {
        if (graphView.spaceDown)    
            return;


        graphView.lastSelectedNodes = [...graphView.selectedNodes];
        
        graphView.putNodeOnTop(node);


        for (const param of node.params)
        {
            if (param.control.textbox == document.activeElement)
                param.control.textbox.finish(true);
        }


        if (   e.button == 0
            && !graphView.overOutput
            && !graphView.overInput)
        {
            e.stopPropagation();

            node.div.selectedSet        = false;
            node.div.moved              = false;
            node.div.shiftOnPointerDown = e.shiftKey;


            if (!node.selected)
            {
                if (e.shiftKey) node     .selected      = true;
                else            graphView.selectedNodes = [node];

                node.selectedSet = true;
            }
            

            if (getCtrlKey(e))
            {
                graphView.selectedNodes = [
                    node, 
                    ...getNodesAfterNode(node)];

                if (e.shiftKey)
                {
                    graphView.selectedNodes = [
                        ...graphView.selectedNodes, 
                        ...getNodesBeforeNode(node)];
                }

                graphView.selectedNodes.forEach(n => n.selected = true);
            }


            node.div.sx = e.clientX;
            node.div.sy = e.clientY;


            for (const n of graphView.selectedNodes)
            {
                n.div.slx = n.div.offsetLeft;
                n.div.sly = n.div.offsetTop;
            }


            node.div.dragging = true;
            node.header.setPointerCapture(e.pointerId);
        }


        updateGraphNodes();
    });



    node.header.addEventListener('pointermove', e =>
    {
        const toTheRightOfInputs = e.clientX - boundingRect(node.header).x > 12 * graphView.zoom;

        
        if (node.div.dragging)
        {
            setNodePositions(
                graphView.selectedNodes,
                (e.clientX - node.div.sx) / graphView.zoom,
                (e.clientY - node.div.sy) / graphView.zoom);
            
            node.div.moved = true;

            graphView.updateScroll();
        }
        else if (   graphView.tempConn
                 && toTheRightOfInputs)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.op.follows(node))
            {
                const input = node.getAutoInput(graphView.tempConn.output.dataType);
                if (!input) return;

                graphView.overInput   = input;
                graphView.headerInput = input;
                    
                input.mouseOver = true;
                input.updateControl();


                const rect = boundingRect(input.control);

                graphView.tempConn.wire.inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - controlBar.offsetHeight);
            }
            else if (graphView.tempConn.input
                  && !node.follows(graphView.tempConn.input.op))
            {
                const output = node.getAutoOutput(graphView.tempConn.input.dataType);
                if (!output) return;

                graphView.overOutput   = output;
                graphView.headerOutput = output;
                    
                output.mouseOver = true;
                output.updateControl();


                const rect = boundingRect(output.control);

                graphView.tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - controlBar.offsetHeight);


                graphView.tempConn.input.updateControl();
            }
        }
    });



    node.header.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && node.div.dragging)
        {
            if (node.div.moved)
            {
                actionManager.do(new SelectMoveNodesAction(
                    graphView.lastSelectedNodes.map(n => n.id), 
                    graphView.selectedNodes.map(n => n.id), 
                    point(node.div.slx,        node.div.sly      ),
                    point(node.div.offsetLeft, node.div.offsetTop),
                    node.div.shiftOnPointerDown ));
            }
            else
            {
                actionManager.do(new SelectNodesAction(
                    graphView.selectedNodes    .map(n => n.id), 
                    graphView.lastSelectedNodes.map(n => n.id)));
            }


            if (   !node.div.selectedSet
                && !node.div.moved)
            {
                if (e.shiftKey) node.selected           = true;
                else            graphView.selectedNodes = [node];
            }


            node.div.dragging = false;
            node.header.releasePointerCapture(e.pointerId);
        }
        else if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.op.follows(node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overInput.endConnection();
            }
            else if ( graphView.tempConn.input
                  && !node.follows(graphView.tempConn.input.op)
                  &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overOutput.endConnection();
            }
        }


        node.div.shiftOnPointerDown = false;
    });
    
    

    node.header.addEventListener('dblclick', e =>
    {
        var bounds = boundingRect(node.label);

        if (   e.clientX >= bounds.left && e.clientX < bounds.right
            && e.clientY >= bounds.top  && e.clientY < bounds.bottom)
            node.showLabelTextbox();
        else
            node.makeActive();
    });
}



function setNodePositions(nodes, dx, dy, updateTransform = true)
{
    //log('setNodePositions()');

    for (const node of nodes)
    {
        node.div.style.left = node.div.slx + dx;
        node.div.style.top  = node.div.sly + dy;
    }

    if (updateTransform)
        graphView.updateNodeTransforms(nodes);
}



function setNodePosition(node, x, y, updateTransform = true)
{
    //log('setNodePosition()');

    node.div.style.left = x;
    node.div.style.top  = y;

    if (updateTransform)
        graphView.updateNodeTransform(node);
}


function createNodeLabel(node)
{
    node.labelWrapper = createDiv('nodeLabelWrapper');

    node.label        = createDiv('nodeLabel');
    node.label.op     = node;
    
    node.labelWrapper.appendChild(node.label);
    node.header.appendChild(node.labelWrapper);


    node.labelWrapper.addEventListener('pointerdown', e =>
    {
        e.preventDefault();
    });

    node.labelWrapper.addEventListener('pointermove', e =>
    {
        const wrect      = boundingRect(node.labelWrapper);
        const margin     = 14;
        const viewMargin = margin * graphView.zoom;
        
        const x          = e.clientX - wrect.x;

        if (x >= wrect.width - viewMargin)
            updateNodeLabel(node, 1);
        else if (x >= viewMargin
              && x < wrect.width - viewMargin)
            updateNodeLabel(node, (x - viewMargin) / (wrect.width - viewMargin*2));
        else
            updateNodeLabel(node);
    });


    initLabelTextbox(node);
}



function updateNodeLabel(node, f = node.labelOffsetFactor)
{
    node.labelOffsetFactor = Math.min(Math.max(0, f), 1);


    const margin     = 15;
    const viewMargin = margin * graphView.zoom;

    const wrect      = boundingRect(node.labelWrapper);
    const rect       = boundingRect(node.label);

    const rw         = wrect.width - viewMargin*2;
    const sf         = rw / nozero(rect.width);
    const df         = viewMargin / rect.width / 2;
        
    const s1         = node.labelOffsetFactor * (rect.width - rw) / rect.width;
    const s0         = s1 - df;
    const s2         = s1 + sf;
    const s3         = s2 + df;


    if (rect.width > rw)
    {
        node.label.style.left = margin - node.labelOffsetFactor * (rect.width - rw - 1) / graphView.zoom;
        node.label.style.transform = 'translateY(calc(-50% - 0.5px))';
    }
    else
    {
        node.label.style.left = '50%';
        node.label.style.transform = 
              'translateX(-50%) '
            + 'translateY(calc(-50% - 0.5px))';
    }


    const color = 
        node.label.style.color.trim() != ''
        ? node.label.style.color
        : 'black';

    node.label.style.background = 
          'linear-gradient(90deg, '
        + '#0000 ' + (s0 * 100) + '%, '
        + color + ' ' + (s1 * 100) + '%, '
        + color + ' ' + (s2 * 100) + '%, '
        + '#0000 ' + (s3 * 100) + '%)';

    node.label.style.WebkitBackgroundClip = 'text';
    node.label.style.WebkitTextFillColor  = 'transparent';
}


function initLabelTextbox(node)
{
    node.textbox = createTextbox('nodeLabelTextbox');
    node.textbox.spellcheck = false;
    


    node.textbox.addEventListener('keydown', function(e)
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand("copy");
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
        {
            if (!graph.nodes.find(n => n.id == node.textbox.value))
                node.textbox.finish(true);
        }

        else if (e.code == 'Escape')
            node.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.node, .figmaSelect, .menuSelect #hexValue, button');
            var index = node.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'node')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else if (e.key == 'Alt')
            e.preventDefault();
    });


    
    // node.textbox.addEventListener('input', function()
    // {
    //     node.setValue(Number(node.textbox.value));
    // });



    node.textbox.addEventListener('pointerdown', e => e.stopPropagation());
    node.textbox.addEventListener('pointermove', e => node.textbox.style.cursor = 'text');



    node.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(node.min, val), node.max);

        node.textbox.value = isNaN(val) ? '' : val;
    });

    
    
    node.textbox.addEventListener('focusout', function()
    {
        if (node.textbox.value != '')
            node.setName(node.textbox.value); // this is good UX

        node.label.style.display = 'block';

        node.header.removeChild(node.textbox);
        node.clicked = false;
    });
    


    node.textbox.finish = function(success)
    {
        if (success) 
        {
            if (node.textbox.value != '')
            {
                const newName = graph.getNewNodeName(node.name, node.textbox.value);
                setTimeout(() => node.setName(newName));
                actionManager.do(new RenameNodeAction(node.id, newName));
            }
        }
        else
            node.textbox.value = node.textbox.savedValue;

        node.textbox.blur();
        
        node.label.style.display = 'block';

        if (node.inFocus)
            node.focus();

        setTimeout(() => updateNodeLabel(node));
    };    
 
    
    
    node.showLabelTextbox = function()
    {
        node.inFocus = 
                node == document.activeElement
            && !node.clicked;
    
        node.textbox.style.width           = node.header.offsetWidth  - 2;
        node.textbox.style.height          = node.header.offsetHeight - 4;
        node.textbox.style.position        = 'absolute';
        node.textbox.style.left            = '50%';
        node.textbox.style.top             = '50%';
        node.textbox.style.transform       = 'translateX(-50%) translateY(-50%)';
        node.textbox.style.textAlign       = 'center';

        node.textbox.style.backgroundColor = node.header.style.backgroundColor;
        node.textbox.style.color           = node.label.style.color;

        node.textbox.value                 = node.name;
        node.textbox.savedValue            = node.textbox.value;
        
        node.header.appendChild(node.textbox);

        node.label.style.display           = 'none';
        
        node.textbox.focus();
        node.textbox.select();
    }
}


class   OpNumber
extends OperatorBase
{
    #paramValue;



    constructor()
    {
        super('number', 'num', 'number', 70);

        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramValue = new NumberParam('value', '', false, false, false));
        
        this.#paramValue.allowEditDecimals = true;
        this.alwaysLoadParams = true;
    }



    updateData()
    {
        if (this.inputs[0].isConnected)
        {
            this.#paramValue.control.dec = this.inputs[0].data.decimals;
            this.#paramValue.setValue(this.inputs[0].data.value, true, true, false);
        }
        
        this.outputs[0]._data = dataFromNumber(
                  this.#paramValue.value, 
                  this.#paramValue.control.dec);
            
                  
        super.updateData()
    }



    updateNode()
    {
        this.#paramValue.control.readOnly        =  this.inputs[0].isConnected;
        this.#paramValue.control.style.fontStyle = !this.inputs[0].isConnected ? 'normal' : 'italic';
        
        super.updateNode();
    }



    updateParams(dispatchEvents)
    {
        super.updateParams(dispatchEvents);

        this.outputs[0]._value = this.#paramValue.value;
    }



    loadParams(_node)
    {
        if (_node.decimals)
            this.#paramValue.setDecimals(parseInt(_node.decimals));

            
        super.loadParams(_node);
    }



    paramIsConsideredDefault(param)
    {
        return param.isDefault()
            && !this.inputs[0].isConnected;
    }



    toJsonBase(nTab)
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';


        let json = super.toJsonBase(nTab);

        if (this.#paramValue.control.dec != 0)
        {
            json += ',\n'
                + pos + tab + '"decimals": "' + this.#paramValue.control.dec + '"';
        }


        return json;
    }



    toString()
    {
        // let str = opType;

        // if (this.inputs[0].isConnected)
        //     str +=

        // return str;
    }
}


class   OpLimits
extends OperatorBase
{
    #paramMin;
    #paramMax;



    constructor()
    {
        super('limits', 'lim', 'number', 70);

        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramMin = new NumberParam('min', 'min', true, true, true, 0));
        this.addParam(this.#paramMax = new NumberParam('max', 'max', true, true, true));
        
        this.#paramMin.addEventListener('change', () => this.#paramMax.control.setMin(this.#paramMin.value, false));
        this.#paramMax.addEventListener('change', () => this.#paramMin.control.setMax(this.#paramMax.value, false));
    }



    updateData()
    {
        if (this.inputs[0].isConnected)
        {
            this.#paramMin.control.dec = this.inputs[0].data.decimals;
            this.#paramMax.control.dec = this.inputs[0].data.decimals;
            
            this.outputs[0]._data = dataFromNumber(
                Math.min(Math.max(
                    this.#paramMin.value, 
                    this.inputs[0].data.value), 
                    this.#paramMax.value),
                this.inputs[0].data.decimals);
        }
        else
            this.outputs[0]._data = dataFromNumber(Number.Nan, 0);
            
                  
        super.updateData()
    }



    toString()
    {
        // let str = opType;

        // if (this.inputs[0].isConnected)
        //     str +=

        // return str;
    }
}


class   OpArithmetic
extends OperatorBase
{
    #paramValue;

    _symbol;
    _showOnlySymbol;


    constructor(opType, shortType, symbol)
    {
        super(opType, shortType, 'number', 50);

        this._variableInputs  = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output(this.dataType));
        
        this.addParam(this.#paramValue = new NumberParam('value', '', false, false, false));

        this.#paramValue.control.readOnly        = true;
        this.#paramValue.control.style.fontStyle = 'italic';


        this._symbol           = createDiv('arithmeticSymbol');
        this._symbol.innerHTML = symbol;
        this._symbol.clicked0  = false;

        this._symbol.addEventListener('pointerenter', () => this._symbol.style.opacity = this._showOnlySymbol ? 1 : 0.65);
        this._symbol.addEventListener('pointerleave',   () => this._symbol.style.opacity = 1);

        this._symbol.addEventListener('pointerdown', e => 
        { 
            if (e.button == 0)
            {
                if (this._symbol.clicked0)
                {
                    this._symbol.clicked0      = false;
                    this._showOnlySymbol       = true;
                    this._symbol.style.opacity = 1
                    this.updateNode();
                }
                else
                {
                    this._symbol.clicked0 = true;
                    setTimeout(() => this._symbol.clicked0 = false, 250); // seems like a good default guess
                }
            }
        });

        this.header.appendChild(this._symbol);

        this._showOnlySymbol = true;
        this.textbox.addEventListener('focus', () => { this._showOnlySymbol = false; });
    }
    
    
    
    addNewInput()
    {
        const input = new Input(this.dataType);

        input.addEventListener('connect',    () => onConnectInput(this));
        input.addEventListener('disconnect', () => onDisconnectInput(this, input));

        this.addInput(input);

        return input;
    }



    // refresh()
    // {
    //     super.refresh();
        
    //     //this._sampled = Number.NaN;
    // }



    updateData()
    {
        let maxDec = 0;

        for (const input of this.inputs)
        {
            if (input.isConnected)
            {
                //input.connectedOutput.op.updateData();

                // ^ this could have removed one or more inputs and connections
                // in which case abort
                if (!input.isConnected)
                {
                    super.updateData();
                    return;
                }

                maxDec = Math.max(maxDec, input.data.decimals);
            }
        }


        const result = this.getResult();

        this.outputs[0]._data = dataFromNumber(result, maxDec);

        this.#paramValue.setValue(result, false, true, false);
        this.#paramValue.control.dec = maxDec;
        //this.#paramValue.control.update();

        
        super.updateData()
    }



    getResult()
    {
        return Number.NaN;
    }



    updateNode()
    {
        super.updateNode();


        if (this._showOnlySymbol)
        {
            this._symbol.style.fontSize = 17;
            this._symbol.style.left     = 'calc(50% + 1px)';
            this._symbol.style.top      = this.header.offsetHeight/2 - 11;
        }
        else
        {
            this._symbol.style.fontSize = 12;
            this._symbol.style.left     = 'calc(50% + 1px)';
            this._symbol.style.top      = this.header.offsetHeight/2 - 3;
            this.label  .style.top      = 'calc(50% - 3px)';
        }
       
        
        this.label.style.visibility = this._showOnlySymbol ? 'hidden'  : 'visible';
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"showOnlySymbol": "' + (this._showOnlySymbol ? 'true' : 'false') + '"';
    }



    loadParams(_node)
    {
        if (_node.showOnlySymbol)
            this._showOnlySymbol = _node.showOnlySymbol == 'true';

        super.loadParams(_node);
    }
}



function onConnectInput(op)
{
    op.addNewInput();
    op.updateNode();
    graphView.updateNodeTransform(op);
}



function onDisconnectInput(op, input)
{
    removeFromArray(op.inputs, input);
    op.inputControls.removeChild(input.control);
    op.updateNode();
}


class   OpAdd
extends OpArithmetic
{
    constructor()
    {
        super('add', 'add', '+');
    }
    
    
    
    getResult()
    {
        let result = 0;

        for (let i = 0; i < this.inputs.length-1; i++)
            result += this.inputs[i].data.value;

        return result;
    }
}


class   OpSubtract
extends OpArithmetic
{
    constructor()
    {
        super('subtract', 'sub', '−');
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;

        let result = this.inputs[0].data.value;

        for (let i = 1; i < this.inputs.length-1; i++)
            result -= this.inputs[i].data.value;

        return result;
    }
}


class   OpMultiply
extends OpArithmetic
{
    constructor()
    {
        super('multiply', 'mul', '×');
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;

        let result = 1;

        for (let i = 0; i < this.inputs.length-1; i++)
            result *= this.inputs[i].data.value;

        return result;
    }
}


class   OpDivide
extends OpArithmetic
{
    constructor()
    {
        super('divide', 'div', '÷');
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;

        let result = this.inputs[0].data.value;

        for (let i = 1; i < this.inputs.length-1; i++)
        {
            const div = this.inputs[i].data.value;
            if (div == 0) return Number.NaN;
            result /= div;
        }

        return result;
    }
}


class   OpExponent
extends OpArithmetic
{
    constructor()
    {
        super('exponent', 'exp', 'xʸ'); // placeholder symbol, actual symbol set in updateNode()
    }
    
    
    
    getResult()
    {
        if (this.inputs.length-1 == 0)
            return 0;
            
        let result = this.inputs[0].data.value;

        for (let i = 1; i < this.inputs.length-1; i++)
            result = Math.pow(result, this.inputs[i].data.value);

        return result;
    }



    updateNode()
    {
        super.updateNode();

        this._symbol.innerHTML =
            this._showOnlySymbol
            ? '<span style="font-size: 14px;">x</span><span style="position: relative; left: -1px; top: -7px; font-size: 7px; font-weight: bold;">y</span>'
            : '<span style="position: relative; top: -1.5px; font-size: 8px;">x</span><span style="position: relative; left: -0.5px; top: -5.15px; font-size: 3.75px; font-weight: bold;">y</span>';

        this._symbol.style.left = 'calc(50% + ' + (this._showOnlySymbol ? 1.5 : 1) + 'px)';
        this._symbol.style.top  = parseFloat(this._symbol.style.top) + (this._showOnlySymbol ? 1.5 : 6);
    }
}


class   OpInterpolate
extends OperatorBase
{
    #paramValue;
    #paramFactor;



    constructor()
    {
        super('interpolate', 'inter', 'number', 70);

        this.addInput(new Input(this.dataType));
        this.addInput(new Input(this.dataType));

        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramValue  = new NumberParam('value',  '',  false, false, false, 0));
        this.addParam(this.#paramFactor = new NumberParam('factor', '%', true,  true,  true, 0, 0, 1, 2));
      
        this.#paramValue.control.readOnly        = true;
        this.#paramValue.control.style.fontStyle = 'italic';

        this.#paramFactor.control.min = Number.MIN_SAFE_INTEGER;
        this.#paramFactor.control.max = Number.MAX_SAFE_INTEGER;
    }



    updateData()
    {
        let result = Number.NaN;
        let maxDec = 0;

        if (   this.inputs[0].isConnected
            && this.inputs[1].isConnected)
        {
            const a = this.inputs[0].data.value; 
            const b = this.inputs[1].data.value; 

            result = a + (b - a) * this.#paramFactor.value;

            maxDec = Math.max(
                this.inputs[0].data.decimals,
                this.inputs[1].data.decimals);
        }
        else if (this.inputs[0].isConnected)
        {
            result = this.inputs[0].data.value;
            maxDec = this.inputs[0].data.decimals;
        }
        else if (this.inputs[1].isConnected)
        {
            result = this.inputs[1].data.value;
            maxDec = this.inputs[1].data.decimals;
        }


        this.outputs[0]._data = dataFromNumber(result, maxDec);

        this.#paramValue.setValue(result, false, true, false);

        this.#paramValue.control.dec = maxDec;
        this.#paramValue.control.update();


        super.updateData()
    }
}


class OpColorBase
extends Operator
{
    _color = dataColor_NaN;

    _warningOverlay;

    
    forceShowWarning = false;
    warningStyle;
    


    constructor(opType, shortType, dataType, defWidth = 80)
    {
        super(opType, shortType, dataType, defWidth);


        this._warningOverlay = createDiv('colorWarningOverlay');
        this._warningOverlay.style.zIndex = 1;
        this.inner.appendChild(this._warningOverlay);
    }



    // updateNode()
    // {
    //     super.updateNode();


    //     // for (const output of this.outputs)
    //     //     for (const input of output.connectedInputs)
    //     //         if (input.connection)
    //     //             input.connection.wire.updateStyle(input.connection.wire.getColor());
    // }



    updateHeader()
    {
        //log(this.name + '.OpColorBase.updateHeader()');

        const [colBack,, colInput, colOutput,,] = this.getHeaderColors();


        for (const input of this.inputs.filter(i => !i.param))
        {
            input.wireColor = colBack;
            input.color     = colInput;
        }


        for (const output of this.outputs.filter(i => !i.param))
        {
            output.wireColor = colBack;
            output.color     = colOutput;
        }


        this.header.style.background = 
            this.canShowColor()
            ? colorStyleRgb(colBack)
            : '#ead8eaee';


        this.updateHeaderLabel();
        this.updateWarningOverlay();


        super.updateHeader();
    }



    updateHeaderLabel()
    {
        const [,,,,, textStyle] = this.getHeaderColors();
        
        this.label.style.color = textStyle;
    }



    getHeaderColors()
    {
        const colBack  = dataColor2rgb(this._color);
        const darkText = rgb2hclokl(colBack)[2] > 0.71;

        const satBias  = Math.min(Math.max(0, ((rgb2hclokl(invalid2validRgb(colBack))[1] - 0.8) / 0.2), 1));

        const colText = 
            this.canShowColor()
            ? (darkText 
               ? [0, 0, 0, (isValidRgb(colBack) ? 0.06 : 0.22) * (1 + 0*satBias)] 
               : [1, 1, 1, (isValidRgb(colBack) ? 0.06 : 0.14) * (1 + 2*satBias)])
            : [0, 0, 0, 1];
       
        const colInput  = this.canShowColor() ? colText : [0, 0, 0, 0.12];
        const colOutput = this.canShowColor() ? colText : [0, 0, 0, 0.1 ];

        const textStyle = colorStyleRgba(colText);

        return [
            colBack, 
            darkText,
            colInput,
            colOutput, 
            colText,
            textStyle ];
    }



    updateWarningOverlay() 
    {
        //log(this.name + '.OpColorBase.updateWarningOverlay()');
        
        if (this.canShowColor())
        {
            const colBack = dataColor2rgb(this._color);
            
            if (  !isValidRgb(colBack)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = colorStyleRgba(
                        isDark(colBack) 
                        ? [0, 0, 0, 0.12]  
                        : [1, 1, 1, 0.2 ]);

                this.updateWarningOverlayStyle(colBack);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = colorStyleRgba([0.5, 1, 0.5, 0.2]);
            this.updateWarningOverlayStyle(color_NaN);
        }
    }



    canShowColor()
    {
        return !isDataColorNaN(this._color);
    }



    updateWarningOverlayStyle(colBack, height = 38)
    {
        this._warningOverlay.style.height = height;

        this._warningOverlay.style.background =
                isValidRgb(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : 'repeating-linear-gradient('
              + '-45deg, '
              + 'transparent 0 7px,'
              +  this.warningStyle + ' 7px 14px)';

        this._warningOverlay.style.display = 'block';
    }
}


/* 
    the data type 'color' contains four elements: 
        color space 
        component 1
        component 2
        component 3
*/



class   OpColor
extends OpColorBase
{
    paramSpace;
    
    param1;
    param2;
    param3;

    #colorBack;


    hexbox;

    
    _oldSpace;
    _oldSpaceConnections = [];
    

    #init = false;
    


    constructor()
    {
        super('color', 'color', 'color', 80);


        this._color    = ['rgb', 0.5, 0.5, 0.5];
        this._oldSpace =  'rgb';


        this.#colorBack = createDiv('colorBack');
        this.inner.appendChild(this.#colorBack);


        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));


        this.inputs[0].addEventListener('connect', () =>
        {
            this.hexbox.style.cursor = this.isConnected ? 'default' : 'text';
            
            for (let i = 1; i < this.params.length; i++)
                enableSliderText(this.params[i].control, false);
        });
    
        this.inputs[0].addEventListener('disconnect', () =>
        {
            for (let i = 1; i < this.params.length; i++)
                if (!this.params[i].input.isConnected) 
                    enableSliderText(this.params[i].control, true);
        });

        
        this.addParam(this.paramSpace = new SelectParam('space', 'space', true, true, OpColorSpaces.map(s => s[1])));
        this.addParam(this.param1     = new NumberParam('c1',    '',      true, true, true, Math.round(this._color[1] * rgbFactor[0])));
        this.addParam(this.param2     = new NumberParam('c2',    '',      true, true, true, Math.round(this._color[2] * rgbFactor[1])));
        this.addParam(this.param3     = new NumberParam('c3',    '',      true, true, true, Math.round(this._color[3] * rgbFactor[2])));

        
        this.paramSpace.control.barTop  = 0.8;


        // this.paramSpace.addEventListener('beforechange', e => paramSpace_onbeforechange(e.target));
        // this.paramSpace.addEventListener('change',       e => paramSpace_onchange(e.target));


        initHexbox(this);


        for (let i = 1; i < this.params.length; i++)
            this.params[i].input.addEventListener('disconnect', () => { enableSliderText(this.params[i].control, !this.inputs[0].isConnected); });
    }



    getDataColorFromParams()
    {
        const col = getNormalColor_(
            getCurrentDataColorSpace(this),
            this.param1.value,
            this.param2.value,
            this.param3.value);
    
        return [
            getCurrentDataColorSpace(this),
            col[0],
            col[1],
            col[2] ];
    }
    
    
    
    setColorParams(color)
    {
        const col = getDataColor(color);

        this.param1.setValue(col[0], false, true, false);
        this.param2.setValue(col[1], false, true, false);
        this.param3.setValue(col[2], false, true, false);
    }



    isConnected()
    {
        return this.inputs[0].isConnected
            || this.inputs[2].isConnected
            || this.inputs[3].isConnected
            || this.inputs[4].isConnected;
    }



    getHeaderColor() 
    {
        return dataColor2rgb(this._color); 
    }



    updateData()
    {
        //log(this.name + '.OpColor.updateData()');

        if (this.inputs[0].isConnected) 
        {
            const color = convertDataColorToSpace(
                this.inputs[0].data.color, 
                getCurrentDataColorSpace(this));

            if (this.param1.input.isConnected) color[1] = getNormalValue(this.param1.input.data.value, color[0], 0);
            if (this.param2.input.isConnected) color[2] = getNormalValue(this.param2.input.data.value, color[0], 1);
            if (this.param3.input.isConnected) color[3] = getNormalValue(this.param3.input.data.value, color[0], 2);

            setDataColorToSpace(this, color, OpColorSpaces[this.paramSpace.value][0]);
        }
        else
        {
            const toSpace = OpColorSpaces[this.paramSpace.value][0];

            if (  !this.#init
                || this._oldSpace != toSpace)
            {
                this.param1.allowEditDecimals = this.paramSpace.value > 1;
                this.param2.allowEditDecimals = this.paramSpace.value > 1;
                this.param3.allowEditDecimals = this.paramSpace.value > 1;

                const color =
                    this.loaded 
                    ? this.getDataColorFromParams()
                    : this._color;


                switchToSpace(this, toSpace);
                setDataColorToCurrentSpace(this, color);


                for (let i = 2; i < 5; i++)
                {
                    if (this.inputs[i].isConnected) 
                    { 
                        const param = this.inputs[i].param;

                        param.update(); 
                        this._color[i-1] = param.value; 
                    }
                }


                this.#init = true;
            }

            this._color    = this.getDataColorFromParams();
            this._oldSpace = toSpace;
        }

    
        this.outputs[0]._data = dataFromDataColor(this._color);

        for (const param of this.params.filter(p => p.dataType == 'number'))
            param.valueIsValid = !isValidRgb(dataColor2rgb(this._color));


        super.updateData()
    }



    updateNode()
    {
        //log(this.name + '.OpColor.updateNode()');

        
        this.hexbox.style.fontStyle = this.isConnected() ? 'italic' : 'normal';

        if (this.hexbox != document.activeElement)
        {
            const colBack = dataColor2rgb(this._color);

            this.hexbox.value = 
                isValidRgb(colBack)
                ? rgb2hex(colBack)
                : '?';
        }


        super.updateNode();
    }



    updateHeader()
    {
        //log(this.name + '.OpColor.updateHeader()');

        super.updateHeader();
        

        this.header.style.background = 'transparent';
    
    
        const [colBack, darkText,,,, textStyle] = this.getHeaderColors();


        const colSpaceBar = 
            darkText 
            ? [0, 0, 0, isValidRgb(colBack) ? 0.06 : 0.12] 
            : [1, 1, 1, isValidRgb(colBack) ? 0.1  : 0.24];

            
        this.#colorBack.style.background = colorStyleRgb(colBack);
                
        this.paramSpace.control.valueColor = colorStyleRgba(colSpaceBar);
        this.paramSpace.control.textColor  = textStyle;
        this.paramSpace.control.backColor  = 'transparent';
        this.paramSpace.control.update();


        const colWarning = 
            darkText 
            ? [0, 0, 0, 0.12] 
            : [1, 1, 1, 0.2 ];

        this.warningStyle = colorStyleRgba(colWarning);
        super.updateWarningOverlayStyle(colBack, 45);
    }



    updateParamControls()
    {
        const [colBack,,,, colText,] = this.getHeaderColors();

        this.paramSpace.input .color = colText;
        this.paramSpace.output.color = colText;
        this.paramSpace.updateControls();

        this.updateAllSliderRanges();

        this.updateSlider(this.param1.control, isValidRgb(colBack));
        this.updateSlider(this.param2.control, isValidRgb(colBack));
        this.updateSlider(this.param3.control, isValidRgb(colBack));
    }



    updateSlider(slider, isValid)
    {
        slider.valueText = 
               this.inputs[0].isConnected 
            && this.inputs[0].data.color[0] != this._color[0]
            && !isValid 
            ? '?' 
            : '';

        slider.textbox.style.fontStyle = this.inputs[0].isConnected ? 'italic' : 'normal';

        slider.update();
    }



    resetAllControlRanges()
    {
        resetSliderRanges(this.param1.control);
        resetSliderRanges(this.param2.control);
        resetSliderRanges(this.param3.control);
    }



    updateAllSliderRanges()
    {
        if (this.paramSpace.value > 4) // warning ranges
        {
            this.updateSliderRanges(this.param1.control, f =>
                dataColor2rgb([
                    this._color[0],
                    (this.param1.control.displayMin + f * (this.param1.control.displayMax - this.param1.control.displayMin)) / getColorSpaceFactor(this._color[0])[0],
                    this._color[2],
                    this._color[3]]));

            this.updateSliderRanges(this.param2.control, f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    (this.param2.control.displayMin + f * (this.param2.control.displayMax - this.param2.control.displayMin)) / getColorSpaceFactor(this._color[0])[1],
                    this._color[3]]));

            this.updateSliderRanges(this.param3.control, f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    this._color[2],
                    (this.param3.control.displayMin + f * (this.param3.control.displayMax - this.param3.control.displayMin)) / getColorSpaceFactor(this._color[0])[2]]));
        }
        else // no warning ranges
        {
            this.resetAllControlRanges();
        }
    }



    updateSliderRanges(slider, getRgb)
    {
        const ranges    = [];
 
        
        const precision = 0.01;
        let   open      = false;

        for (let f = 0; f <= 1; f += precision)
        {
            const rgb = getRgb(f);

            if (!open && !isValidRgb(rgb))
            {
                ranges.push(new NumberSliderRange(f, f, 'rgba(255, 0, 0, 0.16)', 0.8));
                open = true;
            }
            else if (open && isValidRgb(rgb)) 
            {
                ranges[ranges.length-1].end = f;
                open = false;
            }
        }

        
        if (open)
            lastOf(ranges).end = 1;
        else if (!open
              && ranges.length == 0)
            resetSliderRanges(slider);


        slider.ranges = ranges;
    }



    paramIsConsideredDefault(param)
    {
        return super.paramIsConsideredDefault(param)
            && !this.inputs[0].isConnected
            && (  !this.paramSpace.input.isConnected
                || this.paramSpace.value == 0);
    }



    paramsToJson(nTab = 0) 
    {
        let pos = ' '.repeat(nTab);
        
        let json = '';
        
        let first = true;
        for (let i = 0; i < this.params.length; i++)
        {
            const param = this.params[i];

            if (!this.paramIsConsideredDefault(param))
            {
                if (!first) json += ',\n'; first = false;
                json += pos + param.toJson(nTab, i > 0 ? 'c' + i : '');
            }
        }

        if (!first)
            json += '\n';

        return json;
    }
}



// function paramSpace_onbeforechange(paramSpace)
// {
//     if (   paramSpace.value == 0
//         && paramSpace.oldValue > 0)
//     {
//         for (let i = 2; i < paramSpace.op.inputs.length; i++)
//         {
//             const input = paramSpace.op.inputs[i];

//             if (input.isConnected)
//                 paramSpace.op._oldSpaceConnections.push(getConnectionForArrayWithNames(input.connection));
//         }   

//         for (let i = 2; i < paramSpace.op.outputs.length; i++)
//         {
//             const output = paramSpace.op.outputs[i];

//             for (const input of output.connectedInputs)
//                 paramSpace.op._oldSpaceConnections.push(getConnectionForArrayWithNames(input.connection));
//         }   
//     }
// }



// function paramSpace_onchange(paramSpace)
// {
//     // restore the old connections
    
//     if (   paramSpace.value > 0
//         && paramSpace.oldValue == 0)
//     {
//         for (const conn of paramSpace.op._oldSpaceConnections)
//         {
//             const outputOp = graph.nodes.find(n => n.name == conn.outputOpName);
//             const  inputOp = graph.nodes.find(n => n.name == conn. inputOpName);

//             if (outputOp && inputOp)
//             {
//                 const output = outputOp.outputs[conn.outputIndex];
//                 const  input =  inputOp. inputs[conn. inputIndex];

//                 uiVariableConnect(outputOp, conn.outputIndex, inputOp, conn.inputIndex);
//             }
//         }

//         paramSpace.op._oldSpaceConnections = [];
//     }

//     //paramSpace.op.pushUpdate();
// }


const OpColorSpaces = 
[
    ['hex',    'Hex'    ],
    ['rgbhex', '<span class=\'hash\'>#</span>RGB'],
    ['rgb',    'RGB'    ], 
    ['hsv',    'HSV'    ], 
    ['hsl',    'HSL'    ], 
    ['hclokl', 'HCL OKL'],
    ['hcllab', 'HCL Lab'],
    ['hclluv', 'HCL Luv'],
    ['oklab',  'OKLab'  ],
    ['lab',    'Lab'    ],
    ['luv',    'Luv'    ]
];


const rgbFactor   = [255, 255, 255];
const hs_Factor   = [360, 100, 100];
const hclFactor   = [360, 100, 100];
const oppFactor   = [100, 100, 100];

const rgbScale    = [255, 255, 255];
const hs_Scale    = [360, 100, 100];
const hcloklScale = [360,  51, 100];
const hcllabScale = [360, 400, 100];
const hclluvScale = [360, 330, 100];
const oklabScale  = [100,  30,  30];
const labScale    = [100, 100, 100];
const luvScale    = [100, 150, 150];



function switchToSpace(op, space)
{
    switch (space)
    {
        case 'hex':    switchToHex   (op); break;
        case 'rgbhex': switchToRgbHex(op); break;
        case 'rgb':    switchToRgb   (op); break;
        case 'hsv':    switchToHsv   (op); break;
        case 'hsl':    switchToHsl   (op); break;
        case 'hclokl': switchToHclOkl(op); break;
        case 'hcllab': switchToHclLab(op); break;
        case 'hclluv': switchToHclLuv(op); break;
        case 'oklab':  switchToOklab (op); break;
        case 'lab':    switchToLab   (op); break;
        case 'luv':    switchToLuv   (op); break;
    }

    op.resetAllControlRanges();
}



function switchToHex   (op) { switchToTextbox       (op);           }
function switchToRgbHex(op) { switchToRgbHexControls(op);           }
function switchToRgb   (op) { switchToRgbControls   (op);           }
function switchToHsv   (op) { switchToHs_Controls   (op, 'V');      }
function switchToHsl   (op) { switchToHs_Controls   (op, 'L');      }
function switchToHclOkl(op) { switchToHclOklControls(op);           }
function switchToHclLab(op) { switchToHclLabControls(op);           }
function switchToHclLuv(op) { switchToHclLuvControls(op);           }
function switchToOklab (op) { switchToOklabControls (op, 'a', 'b'); }
function switchToLab   (op) { switchToLabControls   (op, 'a', 'b'); }
function switchToLuv   (op) { switchToLuvControls   (op, 'u', 'v'); }
   


function switchToRgbHexControls(op)
{
    switchToControls(op, 
        '<span class=\'hash\'>#</span>R', 0, rgbScale[0], '', false, 
        '<span class=\'hash\'>#</span>G', 0, rgbScale[1], 
        '<span class=\'hash\'>#</span>B', 0, rgbScale[2]);  

    showRgbControlHex(op, true);
}



function switchToRgbControls(op)
{
    switchToControls(op, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    showRgbControlHex(op, false);    
}



function switchToHs_Controls(op, v_or_l) 
{ 
    switchToControls(op, 
        'H',    0, hs_Scale[0], '°', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToHclControls(op, scale) 
{ 
    switchToControls(op, 
        'H', 0, scale[0], '°', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToHclOklControls(op) { switchToHclControls(op, hcloklScale); }
function switchToHclLabControls(op) { switchToHclControls(op, hcllabScale); }
function switchToHclLuvControls(op) { switchToHclControls(op, hclluvScale); }



function switchToOppControls(op, c2, c3, scale)
{ 
    switchToControls(op, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(op, false); 
}



function switchToOklabControls(op) { switchToOppControls(op, 'a', 'b', oklabScale); }
function switchToLabControls  (op) { switchToOppControls(op, 'a', 'b', labScale  ); }
function switchToLuvControls  (op) { switchToOppControls(op, 'u', 'v', luvScale  ); }



function showRgbControlHex(op, show)
{
    op.param1.control.showHex = show;
    op.param2.control.showHex = show;
    op.param3.control.showHex = show;
}



function switchToControls(op, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(op);

    op.param1.setName(c1, false); 
    op.param2.setName(c2, false); 
    op.param3.setName(c3, false);

    op.param1.control.wrapValue = c1wrap;
    op.param1.control.suffix    = c1suffix;

    op.param1.control.displayMin = c1min; 
    op.param2.control.displayMin = c2min;
    op.param3.control.displayMin = c3min;
    
    op.param1.control.displayMax = c1max; 
    op.param2.control.displayMax = c2max; 
    op.param3.control.displayMax = c3max; 
    
    op.param1.updateControls();
    op.param2.updateControls();
    op.param3.updateControls();
}



function switchToTextbox(op)
{
    if (!op.inner.contains(op.hexbox))
    {
        removeOpColorParamWires(op);

        op.inner.removeChild(op.param1.div);
        op.inner.removeChild(op.param2.div);
        op.inner.removeChild(op.param3.div);
        
        op.inner.appendChild(op.hexbox);

        //graphView.updateNodeTransform(op);
    }
}



function removeOpColorParamWires(op)
{
    for (let i = op.inputs.length-1; i >= 2; i--)
        if (op.inputs[i].isConnected)
            uiDisconnect(op.inputs[i]);

    for (let i = op.outputs.length-1; i >= 2; i--)
        for (const input of op.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(op)
{
    if (op.inner.contains(op.hexbox))
    {
        op.inner.removeChild(op.hexbox);

        op.inner.appendChild(op.param1.div);
        op.inner.appendChild(op.param2.div);
        op.inner.appendChild(op.param3.div);

        graphView.updateNodeTransform(op);
    }
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalValue(value, space, chan)
{
    switch (space)
    {
        case 'rgb':    return getNormalValueRgb_(value, chan);
        case 'hsv':   
        case 'hsl':    return getNormalValueHs_ (value, chan);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalValueHcl (value, chan);
        case 'oklab':  
        case 'lab':    
        case 'luv':    return getNormalValuesOpp(value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'rgb':    return getNormalColorRgb_(c1, c2, c3);
        case 'hsv':   
        case 'hsl':    return getNormalColorHs_(c1, c2, c3);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalColorHcl(c1, c2, c3);
        case 'oklab': 
        case 'lab': 
        case 'luv':    return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getDataColor(color)
{
    switch (color[0])
    {
        case 'rgb':    return getDataColorRgb(color[1], color[2], color[3]);
        case 'hsv':   
        case 'hsl':    return getDataColorHs_(color[1], color[2], color[3]);
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getDataColorHcl(color[1], color[2], color[3]);
        case 'oklab': 
        case 'lab': 
        case 'luv':    return getDataColorOpp(color[1], color[2], color[3]);
    }
}



function getDataColorRgb(c1, c2, c3)
{
    return [
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getDataColorHs_(c1, c2, c3)
{
    return [
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getDataColorOpp(c1, c2, c3)
{
    return [
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function getDataColorHcl(c1, c2, c3)
{
    return [
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function setDataColorToSpace(op, color, toSpace)
{
    op._color    = convertDataColorToSpace(color, toSpace);
    op._oldSpace = op._color[0];

    switchToSpace(op, toSpace);

    op.setColorParams(op._color);//, false);
}



function setDataColorToCurrentSpace(op, color)
{
    const toSpace = OpColorSpaces[op.paramSpace.value][0];

    op._color = convertDataColorToSpace(color, toSpace);
    //op._oldSpace = op._color[0];

    op.setColorParams(op._color);//, false);
}



function getCurrentDataColorSpace(op)
{
    var index = op.paramSpace.value;
    if (index < 2) index = 2;

    return OpColorSpaces[index][0];
}



function getColorSpaceFactor(space)
{
    switch (space)
    {
        case 'rgb':    return rgbFactor;
        case 'hsv':   
        case 'hsl':    return hs_Factor;
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return hclFactor;
        case 'oklab': 
        case 'lab': 
        case 'luv':    return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'rgb':    return rgbScale;
        case 'hsv':   
        case 'hsl':    return hs_Scale;
        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return hclScale;
        case 'oklab': 
        case 'lab': 
        case 'luv':    return oppScale;
    }    
}


function initHexbox(op)
{
    op.hexbox = createTextbox();
       
    op.hexbox.style.textAlign  = 'center';
    op.hexbox.style.width      = '100%';
    op.hexbox.style.height     = 26;
    op.hexbox.style.background = 'transparent';
    op.hexbox.style.cursor     = 'text';
    
    op.hexbox.op      = op;
    op.hexbox.editing = false;
    
    op.hexbox.addEventListener('pointerdown', onHexboxPointerDown);
    op.hexbox.addEventListener('pointerup',   onHexboxPointerUp);
    op.hexbox.addEventListener('focus',       onHexboxFocus);
    op.hexbox.addEventListener('focusout',    onHexboxFocusOut);
    op.hexbox.addEventListener('input',       onHexboxInput);
    op.hexbox.addEventListener('keydown',     onHexboxKeyDown);
}



function onHexboxPointerDown(e)
{
    const hexbox = e.target;

    // if (hexbox.op.inputs[0].isConnected)
    //     e.preventDefault();

    e.stopPropagation();
}



function onHexboxPointerUp(e)
{
    const hexbox = e.target;

    if (   !hexbox.editing)
        //&& !hexbox.op.inputs[0].isConnected)
    {
        e.preventDefault();

        hexbox.savedValue = hexbox.value;

        hexbox.focus();
        hexbox.select();
        hexbox.editing = true;
    }
}



function onHexboxFocus(e)
{
    const hexbox = e.target;
    hexbox.style.cursor = 'text';
}



function onHexboxFocusOut(e)
{
    const hexbox = e.target;
    hexboxFinish(hexbox.op, true);
    hexbox.style.cursor = hexbox.op.isConnected() ? 'default' : 'text';
}



function onHexboxInput(e)
{
    const hexbox = e.target;
    
    let val = hexbox.value;

    if (val.trim() == '')
        return;

         if (   val.length > 7 
             && val[0] == '#') hexbox.value = val.trim().slice(0, 7);
    else if (val.length > 6)   hexbox.value = val.trim().slice(0, 6);
}



function onHexboxKeyDown(e)
{
    e.stopPropagation();

    
    const hexbox = e.target;

    if (   getCtrlKey(e)
        && e.code == 'KeyV'
        && !hexbox.op.isConnected())
    {
        e.preventDefault();
        document.execCommand('paste');
    }

    else if ((   e.code == 'Enter'
              || e.code == 'NumpadEnter')
           && !hexbox.op.isConnected())
        hexboxFinish(hexbox.op, true);

    else if (e.code == 'Escape')
        hexboxFinish(hexbox.op, false);

    else if (   e.key.length == 1
             && !isDigitChar(e.key)
             && !isHexDigitChar(e.key)
         ||     hexbox.op.isConnected()
            && !isArrowKey(e.code))
        e.preventDefault();
}



function hexboxFinish(op, success)
{
    var rgb = hex2rgb(op.hexbox.value);

    if (success) 
    {
        setDataColorToCurrentSpace(op, rgb2dataColor(rgb));
        op.hexbox.op.pushUpdate();
    }
    
    op.hexbox.selectionEnd = op.hexbox.selectionStart;
    op.hexbox.editing = false;
    op.hexbox.blur();
};


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'rgbhex': 
        case 'rgb':    return            col;
        case 'hsv':    return hsv2rgb   (col);
        case 'hsl':    return hsl2rgb   (col);
        case 'hclokl': return hclokl2rgb(col);
        case 'hcllab': return hcllab2rgb(col);
        case 'hclluv': return hclluv2rgb(col);
        case 'oklab':  return oklab2rgb (col);
        case 'lab':    return lab2rgb   (col);
        case 'luv':    return luv2rgb   (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgbhex': 
        case 'rgb':    return convert2rgb   (color);
        case 'hsv':    return convert2hsv   (color);
        case 'hsl':    return convert2hsl   (color);
        case 'hclokl': return convert2hclokl(color);
        case 'hcllab': return convert2hcllab(color);
        case 'hclluv': return convert2hclluv(color);
        case 'oklab':  return convert2oklab (color);
        case 'lab':    return convert2lab   (color);
        case 'luv':    return convert2luv   (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    rgb =            col;  break;
        case 'hsv':    rgb = hsv2rgb   (col); break;
        case 'hsl':    rgb = hsl2rgb   (col); break;
        case 'hclokl': rgb = hclokl2rgb(col); break;
        case 'hcllab': rgb = hcllab2rgb(col); break;
        case 'hclluv': rgb = hclluv2rgb(col); break;
        case 'oklab':  rgb = oklab2rgb (col); break;
        case 'lab':    rgb = lab2rgb   (col); break;
        case 'luv':    rgb = luv2rgb   (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    hsv = rgb2hsv(           col ); break;
        case 'hsv':    hsv =                    col;   break;
        case 'hsl':    hsv = rgb2hsv(hsl2rgb   (col)); break;
        case 'hclokl': hsv = rgb2hsv(hclokl2rgb(col)); break;
        case 'hcllab': hsv = rgb2hsv(hcllab2rgb(col)); break;
        case 'hclluv': hsv = rgb2hsv(hclluv2rgb(col)); break;
        case 'oklab':  hsv = rgb2hsv(oklab2rgb (col)); break;
        case 'lab':    hsv = rgb2hsv(lab2rgb   (col)); break;
        case 'luv':    hsv = rgb2hsv(luv2rgb   (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    hsl = rgb2hsl(           col ); break;
        case 'hsv':    hsl = rgb2hsl(hsv2rgb   (col)); break;
        case 'hsl':    hsl =                    col;   break;
        case 'hclokl': hsl = rgb2hsl(hclokl2rgb(col)); break;
        case 'hcllab': hsl = rgb2hsl(hcllab2rgb(col)); break;
        case 'hclluv': hsl = rgb2hsl(hclluv2rgb(col)); break;
        case 'oklab':  hsl = rgb2hsl(oklab2rgb (col)); break;
        case 'lab':    hsl = rgb2hsl(lab2rgb   (col)); break;
        case 'luv':    hsl = rgb2hsl(luv2rgb   (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function convert2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    lab = rgb2oklab(           col ); break;
        case 'hsv':    lab = rgb2oklab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2oklab(hsl2rgb   (col)); break;
        case 'hclokl': lab = rgb2oklab(hclokl2rgb(col)); break;
        case 'hcllab': lab = rgb2oklab(hcllab2rgb(col)); break;
        case 'hclluv': lab = rgb2oklab(hclluv2rgb(col)); break;
        case 'oklab':  lab =                      col;   break;
        case 'lab':    lab = rgb2oklab(lab2rgb   (col)); break;
        case 'luv':    lab = rgb2oklab(luv2rgb   (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    lab = rgb2lab(           col ); break;
        case 'hsv':    lab = rgb2lab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2lab(hsl2rgb   (col)); break;
        case 'hclokl': lab = rgb2lab(hclokl2rgb(col)); break;
        case 'hcllab': lab = pol2opp           (col);  break;
        case 'hclluv': lab = rgb2lab(hclluv2rgb(col)); break;
        case 'oklab':  lab = rgb2lab(oklab2rgb (col)); break;
        case 'lab':    lab =                    col;   break;
        case 'luv':    lab = rgb2lab(luv2rgb   (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    luv = rgb2luv(           col ); break;
        case 'hsv':    luv = rgb2luv(hsv2rgb   (col)); break;
        case 'hsl':    luv = rgb2luv(hsl2rgb   (col)); break;
        case 'hclokl': luv = rgb2luv(hclokl2rgb(col)); break;
        case 'hcllab': luv = rgb2luv(hcllab2rgb(col)); break;
        case 'hclluv': luv = pol2opp           (col);  break;
        case 'oklab':  luv = rgb2luv(oklab2rgb (col)); break;
        case 'lab':    luv = rgb2luv(lab2rgb   (col)); break;
        case 'luv':    luv =                    col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclokl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hclokl(           col);  break;
        case 'hsv':    hcl = rgb2hclokl(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclokl(hsl2rgb   (col)); break;
        case 'hclokl': hcl =                       col;   break;
        case 'hcllab': hcl = rgb2hclokl(hcllab2rgb(col)); break;
        case 'hclluv': hcl = rgb2hclokl(hclluv2rgb(col)); break;
        case 'oklab':  hcl = rgb2hclokl(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclokl(lab2rgb   (col)); break;
        case 'luv':    hcl = rgb2hclokl(luv2rgb   (col)); break;
    }

    return [
       'hclokl',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcllab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hcllab(           col) ; break;
        case 'hsv':    hcl = rgb2hcllab(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hcllab(hsl2rgb   (col)); break;
        case 'hclokl': hcl = rgb2hcllab(hclokl2rgb(col)); break;
        case 'hcllab': hcl =                       col;   break;
        case 'hclluv': hcl = rgb2hcllab(hclluv2rgb(col)); break;
        case 'oklab':  hcl = rgb2hcllab(oklab2rgb (col)); break;
        case 'lab':    hcl = opp2pol              (col);  break;
        case 'luv':    hcl = rgb2hcllab(luv2rgb   (col)); break;
    }

    return [
       'hcllab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'rgbhex':
        case 'rgb':    hcl = rgb2hclluv(           col );  break;
        case 'hsv':    hcl = rgb2hclluv(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclluv(hsl2rgb   (col)); break;
        case 'hcllab': hcl = rgb2hclluv(hcllab2rgb(col)); break;
        case 'hclluv': hcl =                       col;   break;
        case 'hclokl': hcl = rgb2hclluv(hclokl2rgb(col)); break;
        case 'oklab':  hcl = rgb2hclluv(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclluv(lab2rgb   (col)); break;
        case 'luv':    hcl = opp2pol              (col);  break;
    }

    return [
       'hclluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


class   OpWebContrast
extends OpColorBase
{
    #paramStandard;
    #paramValue;



    constructor()
    {
        super('webcontrast', 'contrast', 'color', 80);


        this.addInput(new Input(this.dataType));
        this.addInput(new Input(this.dataType));


        this.addParam(this.#paramValue    = new NumberParam('value',    '', false, false, true, 0, 0));
        this.addParam(this.#paramStandard = new SelectParam('standard', '', true,  true, ['WCAG 2', 'WCAG 3'], 1));
      

        this.#paramValue.control.readOnly        = true;
        this.#paramValue.control.style.fontStyle = 'italic';
    }



    updateData()
    {
        //log(this.name + '.OpWebContrast.updateData()');

        this._color = 
            this.inputs[1].isConnected
            ? this.inputs[1].data.color
            : dataColor_NaN;


        if (   this.inputs[0].isConnected
            && this.inputs[1].isConnected)
        {
            this.#paramValue.control.valueText = '';


            const rgb0 = dataColor2rgb(this.inputs[0].data.color);
            const rgb1 = dataColor2rgb(this.inputs[1].data.color);
            
            if (   isValidRgb(rgb0)
                && isValidRgb(rgb1))
            {
                if (this.#paramStandard.value == 0)
                {
                    const ratio = getContrastRatio2(
                        dataColor2rgb(this.inputs[0].data.color),
                        dataColor2rgb(this.inputs[1].data.color));

                    let rating = getContrastRating2(ratio);

                    if (rating != '')
                        rating = '&nbsp;&nbsp;' + rating;

                    this.#paramValue.control.min        = 
                    this.#paramValue.control.displayMin = 0;

                    this.#paramValue.control.max        = 
                    this.#paramValue.control.displayMax = 21;

                    this.#paramValue.control.suffix = rating;
                    this.#paramValue.control.setValue(ratio);
                }
                else
                {
                    const ratio = getContrastRatio3(
                        dataColor2rgb(this.inputs[0].data.color),
                        dataColor2rgb(this.inputs[1].data.color));
                        
                    this.#paramValue.control.min        = 
                    this.#paramValue.control.displayMin = 0;

                    this.#paramValue.control.max        = 
                    this.#paramValue.control.displayMax = 108;

                    this.#paramValue.control.suffix = '<span style="font-size: 5; position: relative; top: -7px; left: 2px;">L</span><span style="font-size: 3; font-weight: bold; position: relative; top: -8px; left: 1px;">c</span>';
                    this.#paramValue.control.setValue(Math.abs(ratio));
                }


                this.forceShowWarning = false;

                super.updateData();
                return;
            }

            else if (!isValidRgb(rgb0)
                  &&  isValidRgb(rgb1))
            {
                this.warningStyle = colorStyleRgb_a(invalid2validRgb(rgb0), 0.3);
                this.forceShowWarning = true;
            }
            
            else
                this.forceShowWarning = false;
        }


        this.#paramValue.control.valueText = '?';
        this.#paramValue.setValue(0, false, true, false);

           
        super.updateData();
    }



    updateNode()
    {
        this.setRanges();
        
        super.updateNode();
    }



    setRanges()
    {
        if (this.#paramStandard.value == 0)
            this.#paramValue.control.ranges = [];
        else
        {
            this.#paramValue.control.ranges = [
                new NumberSliderRange( 0/108,  15/108, 'rgba(255,   0,  64, 0.2 )', 0.8),
                new NumberSliderRange(15/108,  30/108, 'rgba(255, 112,   0, 0.2 )', 0.8),
                new NumberSliderRange(30/108,  45/108, 'rgba(255, 185,   0, 0.2 )', 0.8),
                new NumberSliderRange(45/108,  60/108, 'rgba(255, 255,   0, 0.2 )', 0.8),
                new NumberSliderRange(60/108,  75/108, 'rgba(64,  255,  64, 0.2 )', 0.8),
                new NumberSliderRange(75/108,  90/108, 'rgba(0,     0, 255, 0.07)', 0.8),
                new NumberSliderRange(90/108, 108/108, 'transparent')];
        }

        this.#paramValue.control.update();
    }



    // updateHeader()
    // {
    //     const colBack = 
    //         this.inputs[1].isConnected
    //         ? dataColor2rgb(this.inputs[1].data.color)
    //         : dataType2rgb(this._dataType);

    //     const darkText = rgb2hclokl(colBack)[2] > 0.71;
    //     const satBias  = Math.min(Math.max(0, ((rgb2hsv(invalid2validRgb(colBack))[1] - 0.7) / 0.3), 1));
        
    //     const colText = 
    //         darkText 
    //         ? [0, 0, 0, 0.24 * (1 + satBias)] 
    //         : [1, 1, 1, 0.4  * (1 + satBias)];


    //     for (const input of this.inputs.filter(i => !i.param))
    //     {
    //         input.wireColor = colBack;
    //         input.color     = colText;
            
    //         input.updateControl();
    //     }


    //     for (const output of this.outputs.filter(i => !i.param))
    //     {
    //         output.wireColor = colBack;
    //         output.color     = colText;

    //         output.updateControl();
    //     }


    //     if (   this.inputs[0].isConnected 
    //         && this.inputs[1].isConnected)
    //         this.label.style.color = colorStyleRgb(dataColor2rgb(this.inputs[0].data.color));
    //     else if (this.inputs[1].isConnected)
    //         this.label.style.color = colorStyleRgba(colText);
    //     else 
    //         this.label.style.color = 'black';


    //     this.header.style.background = 
    //         this.inputs[1].isConnected 
    //         ? colorStyleRgb(dataColor2rgb(this.inputs[1].data.color))
    //         : '#ead8eaee';//colorStyleRgb_a(dataType2rgb(this._dataType, false), 0.95);


    //     super.updateHeader();
    // }



    canShowColor()
    {
        return this.inputs[1].isConnected;
    }



    updateHeaderLabel()
    {
        if (   this.inputs[0].isConnected 
            && this.inputs[1].isConnected)
            this.label.style.color = colorStyleRgb(dataColor2rgb(this.inputs[0].data.color));
        else if (this.inputs[1].isConnected)
        {
            const [,,,, colText,] = this.getHeaderColors();
            this.label.style.color = colorStyleRgba(colText);
        }
        else 
            this.label.style.color = 'black';
    }



    // updateWarningOverlay()
    // {
    //     if (   this.inputs[0].isConnected
    //         && this.inputs[1].isConnected)
    //     {
    //         const colBack  = dataColor2rgb(this.inputs[1].data.color);

    //         const rgb0 = dataColor2rgb(this.inputs[0].data.color);
    //         const rgb1 = dataColor2rgb(this.inputs[1].data.color);

    //         if (   !isValidRgb(rgb0)
    //             || !isValidRgb(rgb1))
    //         {
    //             const colWarning = 
    //                   !isValidRgb(rgb0)
    //                 && maxRgbDistance(
    //                     rgb2hclokl(invalid2validRgb(rgb0)), 
    //                     rgb2hclokl(invalid2validRgb(rgb1))) > 0.15
    //                 ? rgb_a(invalid2validRgb(rgb0), 0.25)
    //                 : (isDark(colBack)
    //                    ? [0, 0, 0, 0.12] 
    //                    : [1, 1, 1, 0.2]);

    //             this.updateWarningOverlayStyle(colorStyleRgba(colWarning));
    //         }
    //         else
    //         {
    //             this._warningOverlay.style.display = 'none';
    //         }
    //     }
    //     else if (this.inputs[1].isConnected)
    //     {
    //         let colWarning;

    //         const colBack  = dataColor2rgb(this.inputs[1].data.color);
    //         const darkText = rgb2hclokl(colBack)[2] > 0.71;
    //         const satBias  = Math.min(Math.max(0, ((rgb2hsv(invalid2validRgb(colBack))[1] - 0.7) / 0.3), 1));

    //         colWarning = 
    //             darkText 
    //             ? [0, 0, 0, 0.1  * (1 + satBias)] 
    //             : [1, 1, 1, 0.16 * (1 + satBias)];

    //         this.updateWarningOverlayStyle(colorStyleRgba(colWarning));
    //     }
    //     else
    //         this.updateWarningOverlayStyle(color_NaN, colorStyleRgba([0.5, 1, 0.5, 0.2]));
    // }
}


class   OpColorInterpolate
extends OpColorBase
{
    #paramSpace;
    #paramAmount;
    #paramGamma;



    constructor()
    {
        super('colorinterpolate', 'inter', 'color', 80);

        
        this.addInput(new Input(this.dataType));
        this.addInput(new Input(this.dataType));

        this.addOutput(new Output(this.dataType));


        this.addParam(this.#paramSpace  = new SelectParam('space',  '',  true, true, OpColorSpaces.map(s => s[1])));
        this.addParam(this.#paramAmount = new NumberParam('amount', '%', true, true, true, 0, 0,    1, 2));
        this.addParam(this.#paramGamma  = new NumberParam('gamma',  'γ', true, true, true, 1, 0.01, 3, 1));
      
        
        this.#paramSpace.control.min        = 2;
        this.#paramSpace.control.displayMin = 2;
        
        this.#paramAmount.control.min       = Number.MIN_SAFE_INTEGER;
        this.#paramAmount.control.max       = Number.MAX_SAFE_INTEGER;
        this.#paramAmount.allowEditDecimals = true;
        
        this.#paramGamma.control.max        = 10;
        this.#paramGamma.allowEditDecimals  = true;


        this.inputs[0].addEventListener('connect', () => 
        {
            if (   !this.inputs[1].isConnected
                && !graphView.loadingNodes) 
                this.#paramSpace.setValue(
                    OpColorSpaces.findIndex(s => s[0] == this.inputs[0].data.color[0]),
                    true, true, false);
        });

        this.inputs[1].addEventListener('connect', () => 
        {
            if (   !this.inputs[0].isConnected
                && !graphView.loadingNodes) 
                this.#paramSpace.setValue(
                    OpColorSpaces.findIndex(s => s[0] == this.inputs[1].data.color[0]),
                    true, true, false);
        });
    }



    updateData()
    {
        //log(this.name + '.OpColorInterpolate.updateData()');

        if (   this.inputs[0].isConnected
            && this.inputs[1].isConnected)
        {
            const space = OpColorSpaces[this.#paramSpace.value][0];
            const f     = this.#paramAmount.value;
            const gamma = this.#paramGamma .value;
            
            const col   = this.interpolate(
                space,
                dataColor2array(convertDataColorToSpace(this.inputs[0].data.color, space)),
                dataColor2array(convertDataColorToSpace(this.inputs[1].data.color, space)),
                f,
                gamma);

            this._color = [
                space, 
                col[0], 
                col[1], 
                col[2] ];
        }

        else if(this.inputs[0].isConnected) this._color = this.inputs[0].data.color;
        else if(this.inputs[1].isConnected) this._color = this.inputs[1].data.color;
        else                                this._color = dataColor_NaN;

        this.outputs[0]._data = dataFromDataColor(this._color);


        super.updateData()
    }



    interpolate(space, col0, col1, f, gamma)
    {
        const iSpace = OpColorSpaces.findIndex(s => s[0] == space);

        const hasHue = 
               iSpace >= 3
            && iSpace <= 7;

        
        let h0, h1;

        if (hasHue)
        {
            h0 = col0[0] * Tau;
            h1 = col1[0] * Tau;
        }

        col0 = rgbPow(col0, gamma);
        col1 = rgbPow(col1, gamma);

        let col = rgbAdd(col0, rgbMuls(rgbSub(col1, col0), f));
        col = rgbPow(col, 1/gamma);

        if (hasHue)
            col[0] = normalAngle(h0 + angleDiff(h0, h1) * f) / Tau;

        return col;
    }



    canShowColor()
    {
        return this.inputs[0].isConnected
            || this.inputs[1].isConnected;
    }
}


class   OpColorblind
extends OpColorBase
{
    #paramL;
    #paramM;
    #paramS;



    constructor()
    {
        super('colorblind', 'colorblind', 'color', 80);


        this.addInput (new  Input(this.dataType));
        this.addOutput(new Output(this.dataType));


        this.addParam(this.#paramL = new SelectParam('l', 'L', true, true, ['L Blind', 'L Weak', 'L'], 2));
        this.addParam(this.#paramM = new SelectParam('m', 'M', true, true, ['M Blind', 'M Weak', 'M'], 2));
        this.addParam(this.#paramS = new SelectParam('s', 'S', true, true, ['S Blind', 'S Weak', 'S'], 2));
      

        this.header.connectionPadding = 14;
    }



    updateData()
    {
        if (this.inputs[0].isConnected)
        {
            this._color = this.inputs[0].data.color;
        }
        else 
        {
            this._color = dataColor_NaN;
        }

        
        this.outputs[0]._data = dataFromDataColor(this._color);
        
        
        super.updateData()
    }



    updateNode()
    {
        // if (   this.inputs[0].isConnected
        //     && this.inputs[1].isConnected)
        // {
        //     const colBack  = dataColor2rgb(this.inputs[1].data.color);

        //     const rgb0 = dataColor2rgb(this.inputs[0].data.color);
        //     const rgb1 = dataColor2rgb(this.inputs[1].data.color);

        //     if (   !isValidRgb(rgb0)
        //         || !isValidRgb(rgb1))
        //     {
        //         const colWarning = 
        //               !isValidRgb(rgb0)
        //             && maxRgbDistance(
        //                 rgb2hclokl(invalid2validRgb(rgb0)), 
        //                 rgb2hclokl(invalid2validRgb(rgb1))) > 0.15
        //             ? rgb_a(invalid2validRgb(rgb0), 0.25)
        //             : (isDark(colBack)
        //                ? [0, 0, 0, 0.12] 
        //                : [1, 1, 1, 0.2]);

        //         this.updateWarningOverlay(colorStyleRgba(colWarning));
        //     }
        //     else
        //     {
        //         this._warningOverlay.style.display = 'none';
        //     }
        // }
        // else
        // {
        //     let colWarning;

        //     if (this.inputs[1].isConnected)
        //     {
        //         const colBack  = dataColor2rgb(this.inputs[1].data.color);
        //         const darkText = rgb2hclokl(colBack)[2] > 0.71;
        //         const satBias  = Math.min(Math.max(0, ((rgb2hsv(invalid2validRgb(colBack))[1] - 0.7) / 0.3), 1));
    
        //         colWarning = 
        //             darkText 
        //             ? [0, 0, 0, 0.1  * (1 + satBias)] 
        //             : [1, 1, 1, 0.16 * (1 + satBias)];
        //     }
        //     else
        //         colWarning = [0.5, 1, 0.5, 0.2];

            
        //     this.updateWarningOverlay(colorStyleRgba(colWarning));
        // }


        //this.#paramStandard.control.update();


        super.updateNode();
    }



    updateHeader()
    {
        //log(this.name + '.OpColorBlind.updateHeader()');

        // const colBack = 
        //     this.inputs[1].isConnected
        //     ? dataColor2rgb(this.inputs[1].data.color)
        //     : dataType2rgb(this._dataType);

        // const darkText = rgb2hclokl(colBack)[2] > 0.71;
        // const satBias  = Math.min(Math.max(0, ((rgb2hsv(invalid2validRgb(colBack))[1] - 0.7) / 0.3), 1));
        
        // const colText = 
        //     darkText 
        //     ? [0, 0, 0, 0.24 * (1 + satBias)] 
        //     : [1, 1, 1, 0.4  * (1 + satBias)];


        // for (const input of this.inputs.filter(i => !i.param))
        // {
        //     input.wireColor = colBack;
        //     input.color     = colText;
            
        //     input.updateControl();
        // }


        // for (const output of this.outputs.filter(i => !i.param))
        // {
        //     output.wireColor = colBack;
        //     output.color     = colText;

        //     output.updateControl();
        // }


        // if (   this.inputs[0].isConnected 
        //     && this.inputs[1].isConnected)
        //     this.label.style.color = colorStyleRgb(dataColor2rgb(this.inputs[0].data.color));
        // else if (this.inputs[1].isConnected)
        //     this.label.style.color = colorStyleRgba(colText);
        // else 
        //     this.label.style.color = 'black';


        // this.header.style.background = 
        //     this.inputs[1].isConnected 
        //     ? colorStyleRgb(dataColor2rgb(this.inputs[1].data.color))
        //     : '#ead8eaee';//colorStyleRgb_a(dataType2rgb(this._dataType, false), 0.95);


        super.updateHeader();
    }
}


class   OpRectangle
extends OperatorBase
{
    #paramX;
    #paramY;
    #paramWidth;
    #paramHeight;
    #paramAngle;
    #paramRound;
    //#paramColor;

    #btnProportional;

    #oldWidth  = Number.NaN;
    #oldHeight = Number.NaN;


    
    constructor()
    {
        super('rectangle', 'rect', 'object');

        this.addInput (new Input (this.dataType));
        this.addOutput(new Output(this.dataType));

        this.addParam(this.#paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.#paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.#paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.#paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.#paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        this.addParam(this.#paramRound  = new NumberParam('round',  'round',  true, true, true,   0,    0));

        
        this.#paramAngle.control.suffix = '°';
        
        this.updateRound();

        this.#btnProportional = createToggleButton(12, 12);
        this.inner.appendChild(this.#btnProportional);


        this.inputs[0].addEventListener('connect', () =>
        {
            for (const param of this.params)
                enableSliderText(param.control, false);
        });


        this.inputs[0].addEventListener('disconnect', () =>
        {
            for (const param of this.params)
                if (!param.input.isConnected) 
                    enableSliderText(param.control, true);
        });


        this.#btnProportional.addEventListener('click', () =>
        {
            if (this.#btnProportional.enabled)
            {
                this.#oldWidth  = this.#paramWidth .value;
                this.#oldHeight = this.#paramHeight.value;
            }
        });


        this.#paramWidth.addEventListener('change', () =>
        {
            if (this.#btnProportional.enabled)
                this.#paramHeight.setValue(this.#paramWidth.value * this.#oldHeight / this.#oldWidth, false, true, false);
        });


        this.#paramHeight.addEventListener('change', () =>
        {
            if (this.#btnProportional.enabled)
                this.#paramWidth.setValue(this.#paramHeight.value * this.#oldWidth / this.#oldHeight, false, true, false);
        });
    }
    
    
    
    updateRound()
    {
        const min = Math.min(this.#paramWidth.value, this.#paramHeight.value);
        this.setRoundMinMax(0, min/2);
    }

    

    setRoundMinMax(min, max)
    {
        const control = this.#paramRound.control;

        control.min   = min;
        control.max   = max;

        this.#paramRound.control.update();
    }



    updateData()
    {
        if (this.inputs[0].isConnected) 
        {
            const data = this.inputs[0].data;

            this.#paramX     .setValue(this.#paramX     .input.isConnected ? this.#paramX     .input.data.value : data.x,      false, true, false);
            this.#paramY     .setValue(this.#paramY     .input.isConnected ? this.#paramY     .input.data.value : data.y,      false, true, false);
            this.#paramWidth .setValue(this.#paramWidth .input.isConnected ? this.#paramWidth .input.data.value : data.width,  false, true, false);
            this.#paramHeight.setValue(this.#paramHeight.input.isConnected ? this.#paramHeight.input.data.value : data.height, false, true, false);
            this.#paramAngle .setValue(this.#paramAngle .input.isConnected ? this.#paramAngle .input.data.value : data.angle,  false, true, false);
            this.#paramRound .setValue(this.#paramRound .input.isConnected ? this.#paramRound .input.data.value : data.round,  false, true, false);
        }

    
        this.outputs[0]._data = dataFromRectangle(
            this.#paramX     .value,
            this.#paramY     .value,
            this.#paramWidth .value,
            this.#paramHeight.value,
            this.#paramAngle .value,
            this.#paramRound .value);


        super.updateData()
    }



    updateNode()
    {
        this.#btnProportional.style.top = 79;

        super.updateNode();
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';

        let json = super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"proportional": "' + (this.#btnProportional.enabled ? 'true' : 'false') + '"';

        if (this.#btnProportional.enabled)
        {
            json +=
                  ',\n' + pos + tab + '"refWidth": "'    + this.#oldWidth  + '"'
                + ',\n' + pos + tab + '"refHeight": "'   + this.#oldHeight + '"';
        }

        return json;
    }



    loadParams(_node)
    {
        if (_node.proportional)
        {
            this.#btnProportional.enabled = _node.proportional == 'true';
            this.#btnProportional.updateBackground(false);

            if (this.#btnProportional.enabled)
            {
                this.#oldWidth  = parseFloat(_node.propWidth);
                this.#oldHeight = parseFloat(_node.propHeight);
            }
        }


        super.loadParams(_node);
    }
}


class Action
{
    manager;
 
    id;
    name;
  
    prevAction; // these are used to link actions into sequences
    nextAction; 
  
    data;
  
    onBefore;
    onAfter;

    onBeforeUndo;
    onAfterUndo;



    constructor(name)
    {
        this.name = name;

        console.assert(
               this.name != undefined
            && this.name != null
            && this.name != '');
    }



    do() {}



    redo()
    {
        this.do();
    }



    undo() {}
};



function linkActions(prevAction, action)
{
    prevAction.nextAction = action;
    action    .prevAction = prevAction;
}


class ActionManager
{
    actions      = [];
    redoActions  = [];
    
    nextActionId = 0;
   
    
    
    do(action, linkWithPrevious = false)
    {
        // this is a fresh new action so any 
        // old redo queue is no longer relevant
        this.redoActions = [];

        this.actions.push(action);

        action.id      = this.nextActionId++;
        action.manager = this;

        if (   linkWithPrevious
            && this.actions.length > 1)
        {
            linkActions(
                beforeLastOf(this.actions),
                lastOf(this.actions));
        }

        //console.log("DO " + action.name);
        action.do();
    }



    undo()
    {
        if (this.actions.length == 0)
            return;

        for (;;)
        {
            let last = removeLast(this.actions);
            this.redoActions.push(last);

            //console.log("UNDO " + last.name);
            last.undo();

            if (   this.actions.length == 0
                || last.prevAction != lastOf(this.actions))
                break;
        }
    }



    redo()
    {
        if (this.redoActions.length == 0)
            return;

        for (;;)
        {
            let last = removeLast(this.redoActions);
            this.actions.push(last);

            //console.log("REDO " + last.name);
            last.redo();
        
            if (   this.redoActions.length == 0
                || last.nextAction != lastOf(this.redoActions))
                break;
        }
    }
}



const actionManager = new ActionManager();


class ConnectAction
extends Action
{
    outputOpId;
    outputIndex;
    get outputOp() { return graph.nodes.find(n => n.id == this.outputOpId); }

    oldOutputOpId;
    oldOutputIndex;
    get oldOutputOp() { return graph.nodes.find(n => n.id == this.oldOutputOpId); }

    inputOpId;
    inputIndex;
    get inputOp() { return graph.nodes.find(n => n.id == this.inputOpId); }


    constructor(output, input)
    {
        const    outIndex = output.op.outputs.indexOf(output);
        const oldOutIndex = input.isConnected ? input.connectedOutput.op.outputs.indexOf(input.connectedOutput) : -1; 
        const     inIndex = input.op.inputs.indexOf(input); 


        super('connect ' 
            + output.op.name + '.outputs[' + outIndex + ']'
            + ' -> '
            + input.op.name + '.inputs[' + inIndex + ']');


        this.outputOpId     = output.op.id;
        this.outputIndex    = outIndex;

        this.oldOutputOpId  = input.isConnected ? input.connectedOutput.op.id : -1;
        this.oldOutputIndex = oldOutIndex;

        this.inputOpId      = input.op.id;
        this.inputIndex     = inIndex;
    }


    
    do()
    {
        uiConnect(
            this.outputOp.outputs[this.outputIndex], 
            this.inputOp. inputs [this. inputIndex],
            this.inputIndex);

            graphView.updateNodeTransform(this.inputOp);

            this.inputOp.pushUpdate();
    }



    undo()
    {
        uiDisconnect(this.inputOp.inputs[this.inputIndex]);

        if (this.oldOutputOpId > -1)
        {
            uiVariableConnect(
                this.oldOutputOp, 
                this.oldOutputIndex, 
                this.inputOp, 
                this.inputIndex);
        }

        graphView.updateNodeTransform(this.inputOp);

        this.inputOp.pushUpdate();
    }
}


class CreateNodeAction
extends Action
{
    opType;
    createdNodeId;

    prevSelectedIds = []; // currently selected nodes that are deselected as a result of creation



    constructor(opType)
    {
        super('create node \'' + opType + '\'');
        
        this.opType = opType;
    }



    do()
    {
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);

        const node = uiCreateNode(this.opType);

        this.createdNodeId = node.id;

        //node.updateNode();
        graphView.updateNodeTransform(node);
        setTimeout(() => graphView.updateScroll());

        node.pushUpdate();
    }



    undo()
    {
        uiDeleteNodes([this.createdNodeId]);
        graphView.selectByIds(this.prevSelectedIds);
    }



    redo()
    {
        const node = uiCreateNode(this.opType, this.createdNodeId);

        //const node = graph.nodes.find(n => n.id == this.createdNodeId);

        //node.updateNode();
        graphView.updateNodeTransform(node);
        setTimeout(() => graphView.updateScroll());

        node.pushUpdate();
    }
}


class DeleteNodesAction
extends Action
{
    prevSelectedIds = [];
    nodeIds         = [];
    nodes           = [];
    nodePos         = [];
    connections     = []; // [{outputOpId, outputIndex, inputOpId, inputIndex}]



    constructor(nodeIds, prevSelectedIds)
    {
        super('delete ' + nodeIds.length + ' node' + (nodeIds.length == 1 ? '' : 's'));

        this.nodeIds         = [...nodeIds]; // clone the array
        this.nodes           = graph.nodes.filter(n => nodeIds.includes(n.id));
        this.prevSelectedIds = [...prevSelectedIds];
    }



    addConnection(conn)
    {
        const outputIndex = conn.output.op.outputs.indexOf(conn.output);
        const  inputIndex = conn.input .op. inputs.indexOf(conn. input);

        if (!this.connections.find(c => 
                   c.outputOpId  == conn.output.op.id
                && c.outputIndex == outputIndex
                && c.inputOpId   == conn.input.op.id
                && c.inputIndex  == inputIndex))
            this.connections.push(getConnectionForArrayWithIds(conn));
    }



    do()
    {
        for (const nodeId of this.nodeIds)
        {
            const node = graph.nodes.find(n => n.id == nodeId);

            this.nodePos.push(point(
                node.div.offsetLeft, 
                node.div.offsetTop));

            for (const input of node.inputs.filter(i => i.isConnected))
                this.addConnection(input.connection);

            for (const output of node.outputs)
                for (const input of output.connectedInputs)
                    this.addConnection(input.connection);
        }


        for (const nodeId of this.nodeIds)
        {
            const node = graph.nodes.find(n => n.id == nodeId);

            for (const input of node.inputs.filter(i => i.isConnected))
                uiDisconnect(input);

            for (const output of node.outputs)
                for (const input of output.connectedInputs)
                    uiDisconnect(input);
        }


        uiDeleteNodes(this.nodeIds, this.id);
    }



    undo()
    {
        this.undeleteNodes();
        this.undeleteConnections();

        this.nodePos     = [];
        this.connections = [];

        graphView.selectByIds(this.prevSelectedIds);
    }



    undeleteNodes()
    {
        graph.addNodes(this.nodes);
        graphView.selected = this.nodes;
        graphView.putNodeOnTop(lastOf(this.nodes));
    
        for (let i = 0; i < this.nodes.length; i++)
        {
            setNodePosition(
                this.nodes[i], 
                this.nodePos[i].x, 
                this.nodePos[i].y);
        }

        for (let i = 0; i < this.nodes.length; i++)
            this.nodes[i].id = this.nodeIds[i];
    }



    undeleteConnections()
    {
        const connections    = [...this.connections];
        const varConnections = [];
       
        
        // connections going into variable inputs must be treated separately
        for (let i = connections.length-1; i >= 0; i--)
        {
            if (graph.nodes.find(n => n.id == connections[i].inputOpId)._variableInputs)
            {
                varConnections.push(connections[i]);
                removeAt(connections, i);
            }
        }

        
        varConnections.sort((c1, c2) => 
        {
            if (c1.inputOpId  != c2.inputOpId ) return c1.inputOpId  - c2.inputOpId;
            if (c1.inputIndex != c2.inputIndex) return c1.inputIndex - c2.inputIndex;
            return 0;
        });
        
        
        this.connect(connections);
        this.connect(varConnections);
    }



    connect(connections)
    {
        for (const conn of connections)
        {
            const outputOp = graph.nodes.find(n => n.id == conn.outputOpId);
            const inputOp  = graph.nodes.find(n => n.id == conn. inputOpId);

            uiVariableConnect(outputOp, conn.outputIndex, inputOp, conn.inputIndex);
        }
    }
}


class DisconnectAction
extends Action
{
    outputOpId;
    outputIndex;
    get outputOp() { return graph.nodes.find(n => n.id == this.outputOpId); }

    inputOpId;
    inputIndex;
    get inputOp() { return graph.nodes.find(n => n.id == this.inputOpId); }



    constructor(output, input)
    {
        const outputIndex = output.op.outputs.indexOf(output);
        const  inputIndex = input .op. inputs.indexOf( input); 


        super('disconnect ' 
            + output.op.name + '.outputs[' + outputIndex + ']'
            + ' -> '
            + input.op.name + '.inputs[' + inputIndex + ']');


        this.outputOpId  = output.op.id;
        this.outputIndex = outputIndex;

        this.inputOpId   = input.op.id;
        this.inputIndex  = inputIndex;
    }



    do()
    {
        uiDisconnect(this.inputOp.inputs[this.inputIndex]);

        this.inputOp.pushUpdate();
        //graphView.updateNodeTransform(this.inputOp);
    }
    
    
    
    undo()
    {
        uiVariableConnect(
            this.outputOp, 
            this.outputIndex, 
            this.inputOp, 
            this.inputIndex);

        //graphView.updateNodeTransform(this.inputOp);
        this.inputOp.pushUpdate();
    }
}


class DuplicateNodesAction
extends Action
{
    copiedJson;
    pastedNodeIds = [];


    constructor(copiedJson)
    {
        const data = JSON.parse(copiedJson);

        super('paste ' + data.nodes.length + ' node' + (data.nodes.length == 1 ? '' : 's'));

        this.copiedJson = copiedJson;
    }



    do()
    {
        this.pastedNodeIds = uiPasteNodes(this.copiedJson).map(n => n.id);
    }



    undo()
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        Operator.nextId -= this.pastedNodeIds.length;

        pasteOffset[0] -= pasteOffsetDelta[0];
        pasteOffset[1] -= pasteOffsetDelta[1];
    }
}


class PasteNodesAction
extends Action
{
    copiedNodesJson;

    pasteOutsideConnections;

    pastedNodeIds = [];
    pastedNodePos = [];

    prevSelectedNodeIds = [];


    constructor(copiedNodesJson, pasteOutsideConnections)
    {
        const data = JSON.parse(copiedNodesJson);

        super('paste ' + data.nodes.length + ' node' + (data.nodes.length == 1 ? '' : 's'));

        this.copiedNodesJson         = copiedNodesJson;
        this.prevSelectedNodeIds     = graphView.selectedNodes.map(n => n.id);
        this.pasteOutsideConnections = pasteOutsideConnections;
    }



    do()
    {
        const nodes = uiPasteNodes(this.copiedNodesJson, this.pasteOutsideConnections);

        this.pastedNodeIds = nodes.map(n => n.id);
        this.pastedNodePos = nodes.map(n => { return point(n.div.offsetLeft, n.div.offsetTop); });

        updateTerminalsAfterNodes(nodes);

        graphView.updateNodeTransforms(nodes);
    }



    undo()
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        Operator.nextId -= this.pastedNodeIds.length;

        pasteOffset[0] -= pasteOffsetDelta[0];
        pasteOffset[1] -= pasteOffsetDelta[1];

        graphView.selectedNodes = graph.nodes.filter(n => this.prevSelectedNodeIds.includes(n.id));
    }



    redo()
    {
        const nodes = uiPasteNodes(this.copiedNodesJson, this.pasteOutsideConnections);
        
        this.pastedNodeIds = nodes.map(n => n.id);

        for (let i = 0; i < nodes.length; i++)
        {
            setNodePosition(
                nodes[i], 
                this.pastedNodePos[i].x,
                this.pastedNodePos[i].y);
        }

        updateTerminalsAfterNodes(nodes);
    }
}


class ReconnectAction
extends Action
{
    outputOpId;
    outputIndex;
    get outputOp() { return graph.nodes.find(n => n.id == this.outputOpId); }

    oldOutputOpId;
    oldOutputIndex;
    get oldOutputOp() { return graph.nodes.find(n => n.id == this.oldOutputOpId); }

    inputOpId;
    inputIndex;
    get inputOp() { return graph.nodes.find(n => n.id == this.inputOpId); }

    oldInputOpId;
    oldInputIndex;
    get oldInputOp() { return graph.nodes.find(n => n.id == this.oldInputOpId); }
    


    constructor(output, oldInput, input)
    {
        const    outIndex =   output.op.outputs.indexOf(output);
        const oldOutIndex = input.isConnected ? input.connectedOutput.op.outputs.indexOf(input.connectedOutput) : -1; 
        const  oldInIndex = oldInput.op. inputs.indexOf(oldInput); 
        const     inIndex =    input.op. inputs.indexOf(input); 
        

        super(
             'reconnect '
            + output.op.name + '.outputs[' + outIndex + ']'
            + ' ( <- '
            + oldInput.op.name + '.inputs[' + oldInIndex + '])'
            + ' -> '
            + input.op.name + '.inputs[' + inIndex + ']');


        this.outputOpId    = output.op.id;
        this.outputIndex   = outIndex;
        
        this.oldOutputOpId  = input.isConnected ? input.connectedOutput.op.id : -1;
        this.oldOutputIndex = oldOutIndex;

        this.oldInputOpId  = oldInput.op.id;
        this.oldInputIndex = oldInIndex;

        this.inputOpId     = input.op.id;
        this.inputIndex    = inIndex;
    }



    do()
    {
        uiDisconnect(this.oldInputOp.inputs[this.oldInputIndex]);

        graphView.updateNodeTransform(this.oldInputOp);
        
        
        uiConnect(
            this.outputOp.outputs[this.outputIndex], 
            this. inputOp. inputs[this. inputIndex],
            this.inputIndex);
            
        graphView.updateNodeTransform(this.inputOp);

        this.oldInputOp.pushUpdate();
        this.inputOp   .pushUpdate();
    }



    undo()
    {
        uiDisconnect(this.inputOp.inputs[this.inputIndex]);


        uiVariableConnect(
            this.outputOp, 
            this.outputIndex, 
            this.oldInputOp, 
            this.oldInputIndex);

        this.oldInputOp.pushUpdate();
        graphView.updateNodeTransform(this.oldInputOp);
    

        if (this.oldOutputOpId > -1)
        {
            uiVariableConnect(
                this.oldOutputOp, 
                this.oldOutputIndex, 
                this.inputOp, 
                this.inputIndex);

            this.inputOp.pushUpdate();
            graphView.updateNodeTransform(this.inputOp);
        }
    }
}


class RenameNodeAction
extends Action
{
    nodeId;
    get node() { return graph.nodes.find(n => n.id == this.nodeId) } 

    oldName;
    newName;



    constructor(nodeId, name)
    {
        super('rename node');

        this.nodeId  = nodeId;
        this.newName = name;
    }



    do()
    {
        this.oldName = this.node.name;
        this.node.setName(this.newName);
    }



    undo()
    {
        this.node.setName(this.oldName);
    }



    redo()
    {
        this.node.setName(this.newName);
    }
}


class SelectMoveNodesAction
extends Action
{
    newSelectedIds  = [];
    prevSelectedIds = [];

    shiftPressed;

    fromPos;
    toPos;

    from;
    to;



    constructor(prevSelectedIds, newSelectedIds, fromPos, toPos, shiftPressed)
    {
        super(
            'select move ' + newSelectedIds.length 
          + ' node' + (newSelectedIds.length == 1 ? '' : 's') + ', '
          + prevSelectedIds.length + ' selected before');


        this.prevSelectedIds = [...prevSelectedIds];
        this.newSelectedIds  = [...newSelectedIds];
          
        this.shiftPressed    = shiftPressed;

        this.fromPos         = fromPos;
        this.toPos           = toPos;


        
        const dx = this.toPos.x - this.fromPos.x;
        const dy = this.toPos.y - this.fromPos.y;


        this.from = []; // these hold tuples
        this.to   = []; // [id, pos]

        for (const id of this.getMovedIds())
        {
            const node = graph.nodeFromId(id);

            this.from.push([id, point(node.div.slx,      node.div.sly     )]);
            this.to  .push([id, point(node.div.slx + dx, node.div.sly + dy)]);
        }
    }



    getMovedIds()
    {
        const movedIds = [];

        if (this.shiftPressed)
            movedIds.push(...this.prevSelectedIds);
        
        movedIds.push(...this.newSelectedIds);

        return movedIds;
    }



    do()
    {
        const movedIds   = this.getMovedIds();
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (var i = 0; i < movedNodes.length; i++)
        {
            const p = this.to.find(t => t[0] == movedNodes[i].id);
            setNodePosition(movedNodes[i].div.op, p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateBorder();
    }



    undo()
    {
        const movedIds   = this.getMovedIds();
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (var i = 0; i < movedNodes.length; i++)
        {
            const p = this.from.find(t => t[0] == movedNodes[i].id);
            setNodePosition(movedNodes[i].div.op, p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateBorder();

        graphView.selectByIds(this.prevSelectedIds);
    }



    redo()
    {
        this.do();

        graphView.selectByIds(this.getMovedIds());
    }
}


class SelectNodesAction
extends Action
{
    selectedIds     = [];
    prevSelectedIds = [];



    constructor(selectedIds, prevSelectedIds)
    {
        super(
              'select ' + selectedIds.length 
            + ' node' + (selectedIds.length == 1 ? '' : 's') + ', '
            + prevSelectedIds.length + ' selected before');

        this.selectedIds     = [...selectedIds];
        this.prevSelectedIds = [...prevSelectedIds];
    }



    do()
    {
        // this happens in the UI
    }



    undo()
    {
        graphView.selectByIds(this.prevSelectedIds);
    }



    redo()
    {
        graphView.selectByIds(this.selectedIds);
    }
}


class SetParamDecimalsAction
extends Action
{
    nodeId;
    paramIndex;

    get param() { return graph.nodes.find(n => n.id == this.nodeId).params[this.paramIndex]; } 


    newDecimals;
    oldDecimals;



    constructor(param, dec, oldDec)
    {
        super('set param settings');

        this.nodeId      = param.op.id;
        this.paramIndex  = param.op.params.indexOf(param);

        this.newDecimals = dec;
        this.oldDecimals = oldDec;
    }



    do()
    {
        // if (   this.param.allowEditDecimals
        //     && this.param.setDecimals)
            this.param.setDecimals(this.newDecimals);
    }



    undo()
    {
        // if (   this.param.allowEditDecimals
        //     && this.param.setDecimals)
            this.param.setDecimals(this.oldDecimals);
    }
}


class SetParamValueAction
extends Action
{
    nodeId;
    paramIndex;

    get param() { return graph.nodes.find(n => n.id == this.nodeId).params[this.paramIndex]; } 


    oldValue;
    newValue;



    constructor(param, value)
    {
        super('set ' + param.op.name + '.' + param.name + ' = ' + value);

        this.nodeId     = param.op.id;
        this.paramIndex = param.op.params.indexOf(param);

        this.newValue   = value;
    }



    do()
    {
        this.oldValue = this.param.oldValue;
        this.param.op.pushUpdate();
    }



    undo()
    {
        this.param.setValue(this.oldValue, false, true);
        this.param.op.pushUpdate();
    }



    redo()
    {
        this.param.setValue(this.newValue);
        this.param.op.pushUpdate();
    }
}


const panCursor = 
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3Ln'
    + 'czLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzJweCIgaGVpZ2h0PSIzMnB4Ij48aW1hZ2UgeGxpbms6aHJlZj0i'
    + 'ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWE'
    + 'hlQUFBSHFrbEVRVlI0WHUyYWY4aVY1Um5IUDlhbXpjM0tkRERkSDJ2WitpUEQvdEJTSEtLQ1EyVmJaTWdnbDAx'
    + 'TENUUmJ0Q1hLSFA1Z1N1UWZNZGtmZ3lrMkZLTWtjU0wrV0RKbExOU2xwaWtSaEdRU1VTMU4zV2JiYW5OOG50M1'
    + 'h1N3ZIOXpYUE9jOXp3dDczZ3B2M25QT2U4enpQOWIyLzE4Lzc2a1UzbDE3ZFhIOTZBT2hoUURkSG9NY0V1amtC'
    + 'ZXB4Z2p3bTAwUVFFTzFiYzlnSVFxNDJQOHY5YnRZTUIzdU9xdEs0R0JnRTNBdThBYndML1R1cy9nS3V0VWpjQV'
    + 'hsK2x2d0I4RVZnRXpNODBmQkZZRFR3UGZGd0NvaTNNcUJzQWxWZnhQc0R2Z0xFcVAyVElFSTRmUDU3djlGVGdq'
    + 'OEJOd0YrQk54SWJaRWV0ektnRGdMQnphYS95MXdEZkIzNnJ4cHMyYldMS2xDbWNPSEdDdVhQbnNtM2JOai9lQl'
    + 'h3TnVDMmhjaEJZRE93QlBrcnNxTVU4cWdTZ2JPdlMzcDN2Qzh3R2ZqNXk1RWoyN2R2WHNmT3JWNjltOW16LzFh'
    + 'VThEdndhK0ZkZElGUUZRRGc1ZDF6RjF3SERnZXVBVjREWGdBZVhMRm5DNHNWdTdQOWt6NTQ5akI4L3ZuanQ1K1'
    + 'BHamFOZnYzNXMzYm9Wdnd1OEM0d0FQZ0QrbVh5RXZxRXlxUUtBY0hTOTA0NmY3dXJwTGdYQXNXUEhHRHAwYU1k'
    + 'UGUvWHFlTFFKd0NIZ2ZES0hTazJoQ2dEQzBYMEplQWFZcUJaYnRteGgrUERoTEZpd2dIWHJKQVRGcm5iRmdBc1'
    + 'hQcm14TWtPR0FQY0RMd0IvU3l3d1dsVEdnbFlCOFBkU1h1Vy9BdndaK1BxcVZhdVlOMjlleDI0T0dEQ0EwNmRQ'
    + 'Tnd2QVE4bEpHaDFrZ2Y1QUZnaEN5MnhvRlFCdFgrcC9PZGw3RWR2S3U3bDA2ZEpDK1NZWjhDandUV0JrOGlWUE'
    + 'F5K1Y4b2FtR1ZFRkFJYTVmc0FOd0tzMUFOQ1pTM2tTK0VVV0hjd1htcEpXQWREK3BmKzF3SURrOGF0bUFLTkhq'
    + 'MmI1OHVYSXBPUVhWRlpmc3pmNUJYT0ZwbGpRS2dCaC80YTdnY0RMVlROZzJMQmhIRGx5cEdOM1I0MGF4Zjc5Kz'
    + 'MwdkEzNlovRUtFeUlaWlVBVUFKam9CZ09HcVN3WVlBVko4dnlnUDZDb0s3TjY5dThnUFFzS2ZKRDh3SmFYT0g2'
    + 'WVErWmtDOEZYQUZMWmRBSGl2SHdCbmdMOG5mOUN3R1ZURmdPdVRDYlFUQU0zdFhzREV5eHpoSDgzNGdTc1pnTV'
    + 'BBRHhNQTV4SUFEZWNGVnpJQWVzYjdnRk9BQU9nSGFnY2dBSXUvRmorR3dYQ0NCenJ6QVRvK25WZkZUckN0QU9T'
    + 'bGJsUis2aHIxZmlSQ3BzS2RPa0hqOTlpeFl5K0tBZ0tqNk8xektWZUpuVVFCQVpoZVlrRERDZEhsbUVBb2JNen'
    + 'ZiMDBEV0tHNTY2YSttNjE5QUIzaG56b0RvT0hZZElrZlpHR3dMUUJFc2VOT1c2ditDcml6aytjek0xbWJtaGNY'
    + 'TWVCS0JzQlUxMkpITy84TmNJL0tyRnk1a2hFalJuRDQ4T0hDcnMrZDB3Y1ZEUXM3UUxVQ0VQNEVxSjBCN3I3S1'
    + 'creVlkeityY3VYR3hjR0RCMW0wYUJFN2R1em8yT2h5VmxjbEE5b0pnTHZ2amxycVBnQThZVXBhZGxhaDNMSmx5'
    + 'enFhSFo4WEFLTFEwY1BQQVg1V0xrektPN3RyMXk3bXo1L1BvVU5GU1ZDTHRKTUJPajRMSFV2ZE85TGhSY0dBdk'
    + 'RncGEzbisvSG42OXZWbjljaG5CWUNsN25KZ3NtcHQzNzZkU1pNbTFhUGhwMXkxblFEa0ptQ3o0MmJnS2VBYlB1'
    + 'UEdqUnVaT3RVRG5mWktPd0hJbmFCSmp1V3VKemNMMCtFbWE5ZXVaY2FNR1cxRm9BUkExQUkyVEswRktzMEVEWU'
    + '9SNjBlcWE5L3ZGdUNud0xmVXZOd0JyaHVOVWlhWUYwT1d3NVVDb0M2UkNJVXpOQlYyYVFZL0FXNzFTeXRXckdE'
    + 'aFFvbFJ2OHlhTllzMWE5WjRvejhBUDY2N0dveFVPRnJmTWtGekVBUVBNMlhDN1Q2TkFBaEUzYUx6M2JsenA3ZD'
    + 'VEbGlXQUFnVHFLVWN0aGpTSVFxQ1RBZ1FCRUxuS0FpR3llSXdSSk9vVXdZT0hNaXBVN1lBaXFKTUVPd0lDWUFt'
    + 'VUFzQTNxd3pFS3dHZ3cyUEFhUDlvazVSNTFpSDdOMjd0MmlSSi9rZThIbzZPQlVBYTVGYWU0S0NFSkhCNGtnbU'
    + 'NJTG1JQkNQeEFDRTRkRXdXYlZNbno2ZDlldlhlMW1yVCszL0wxbFRWQUFhbHN2cEIrUVhEUkRDSER3UHpFRXda'
    + 'YlpYd01TSkV6OVJJRFg4WktVZmJONjh1UmlzU0xJQStEM3dQbkEyaFVBUFJ4cVdSZ0h3QnJsakRDYVlMa2VFZU'
    + 'JENHJsLzBkUGpBZ2FKTDFwS2NPWE9HL3YyOWZDRk9rM2dvOGw2cEk5eHdDQXhsbW5tNHZGR2lZd3dtaEUvNEVY'
    + 'QjNGVXpJaHlpQXQ0RlppZnA2UW5lLzZUT0JWZ0NJMytZTmt6SUltc0xEZm5ITW1ERkZtSnc4dVNnbExrdk9uaj'
    + 'NMaGcwYm1ETkhxeXJFM244a1BpcnYxRWljQnpnejBKUTBZd0w1amZMcGtKZ1IwQnhrZ2tzUXpKWDlqSmt6WnpK'
    + 'dDJqUW1UQ2pjUktkeTlPalJRbkhYeVpNbjR6c2VoeitSS0cvWVUvbUkvZHArdytFdkx0d3FBRGtUSW0yV0NTcX'
    + 'NjM1E1K25ZWDhKMjRhZS9ldlJrOGVEQ0RCZzJpVDUraWk0WjI3dVNZZnpQeGplMWlSMHg4cmVMU1BzNEJtajRV'
    + 'clJLQU1naTIwT3dpR1NZRndpVW8xZzdmVGtOUGd6K0ZyOGRTejg4dTgxdHB0MVhjSmUxalVxVGxjWmtxR0pDRE'
    + 'dWT2hnaEFtb2ZJdVFmRXp0OXoza1QrWVpTcFdjOUpiKzViV1puWXFxcE9UN2k1Zit6M0haR0tJc2luYnI1b0Ir'
    + 'Zlh5ckZHRlhVYUtlQzBBNWhHQzVYSVRZaXhXcGR4VkZSUUFsUlVFbDYvOVRIQXFVVDZvMnhLQ1hmdzRRTkF2cU'
    + 'd5TTBJWHlmcTd5Zmk5WUdDT3hBcUNTZ3FDTng0cGhTWlZ2T09YdFNza3FUYUI4ajRnUStiQjBERTNudXgvUEVG'
    + 'TmZ3WUlBd3IvNUlIVmx5dGZKZ0J5TU9GcUxORHAvci9JNUFEa0lNaUlmbHE1VThicDh3S1hNS1pUTi8rYWJFQW'
    + '9HQ0orTGNmazYvRXVsMTZ6VEIxVDZvSFZkckFlQXVwQzlVcTdiN1Jud1g2cWNXVzY0MVZ5REFBQUFBRWxGVGtT'
    + 'dVFtQ0MiIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIvPjwvc3ZnPg==) 15 15, auto';


const zoomInCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kKSI+PHBhdGgg'
    + 'ZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC41IDhDMTQuNSAxMS4wMzggMT'
    + 'IuMDM4IDEzLjUgOSAxMy41QzUuOTYyIDEzLjUgMy41IDExLjAzOCAzLjUgOEMzLjUgNC45NjIgNS45NjIgMi41'
    + 'IDkgMi41QzEyLjAzOCAyLjUgMTQuNSA0Ljk2MiAxNC41IDhaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGZpbGwtcn'
    + 'VsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAzOCAx'
    + 'My41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5IDIuNU'
    + 'MxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPjxwYXRoIGZpbGwtcnVsZT0i'
    + 'ZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNTg1NyAxOC4wMDAyTDE4Ljk5OTcgMTYuNTg2Mk'
    + 'wxMy41NTA3IDExLjEzNzJMMTIuMTM2NyAxMi41NTEyTDE3LjU4NTcgMTguMDAwMloiIGZpbGw9ImJsYWNrIi8+'
    + 'PC9nPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0gxMFY1SD'
    + 'hWN0g2VjguOThIOFYxMUgxMFY4Ljk4SDEyVjdaIiBmaWxsPSJibGFjayIvPjxkZWZzPjxmaWx0ZXIgaWQ9ImZp'
    + 'bHRlcjBfZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIxLjk5OTciIGhlaWdodD0iMjIuMDAwMiIgZmlsdGVyVW5pdH'
    + 'M9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPjxmZUZsb29kIGZs'
    + 'b29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQ29sb3JNYXRyaXggaW49Il'
    + 'NvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMTI3IDAiLz48ZmVPZmZzZXQgZHk9IjEiLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLj'
    + 'UiLz48ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMCAwIDAgMC4zNSAwIi8+PGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZU'
    + 'ZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3ciLz48ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3Vy'
    + 'Y2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvdyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjwvZG'
    + 'Vmcz48L3N2Zz4=) 8 8, auto';


const zoomOutCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZCkiPgo8cGF0'
    + 'aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjUgOEMxNC41IDExLjAzOC'
    + 'AxMi4wMzggMTMuNSA5IDEzLjVDNS45NjIgMTMuNSAzLjUgMTEuMDM4IDMuNSA4QzMuNSA0Ljk2MiA1Ljk2MiAy'
    + 'LjUgOSAyLjVDMTIuMDM4IDIuNSAxNC41IDQuOTYyIDE0LjUgOFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGZpbG'
    + 'wtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAz'
    + 'OCAxMy41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5ID'
    + 'IuNUMxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1'
    + 'bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3LjU4NTcgMTguMDAwMkwxOC45OTk3IDE2Lj'
    + 'U4NjJMMTMuNTUwNyAxMS4xMzcyTDEyLjEzNjcgMTIuNTUxMkwxNy41ODU3IDE4LjAwMDJaIiBmaWxsPSJibGFj'
    + 'ayIvPgo8L2c+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0'
    + 'g2VjguOThIMTJWN1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2QiIHg9IjAi'
    + 'IHk9IjAiIHdpZHRoPSIyMS45OTk3IiBoZWlnaHQ9IjIyLjAwMDIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPbl'
    + 'VzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0i'
    + 'MCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIi'
    + 'B0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAi'
    + 'Lz4KPGZlT2Zmc2V0IGR5PSIxIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIvPgo8ZmVDb2'
    + 'xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAw'
    + 'IDAgMC4zNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3'
    + 'VsdD0iZWZmZWN0MV9kcm9wU2hhZG93Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBo'
    + 'aWMiIGluMj0iZWZmZWN0MV9kcm9wU2hhZG93IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cj'
    + 'wvc3ZnPgo=) 8 8, auto';


document.addEventListener('pointerdown', function(e)
{
    if (   e.button == 0
        && (   document.canResizeX
            || document.canResizeY))
    {
        document.startRect = new Rect(
            e.clientX,
            e.clientY,
            window.innerWidth,
            window.innerHeight);

        document.body.setPointerCapture(e.pointerId);

        document.resizingX = document.canResizeX;
        document.resizingY = document.canResizeY;
    }
});



document.addEventListener('pointermove', function(e)
{
    if (   document.resizingX
        && document.resizingY)
    {
        resizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (document.resizingX)
    {
        resizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            window.innerHeight);
    }
    else if (document.resizingY)
    {
        resizeWindow(
            window.innerWidth,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (!graphView.selecting)
        checkResize(e.clientX, e.clientY);
});



document.addEventListener('pointerup', function(e)
{
     if (   document.resizingX
         || document.resizingY)
    {
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }

    document.resizingX = false;
    document.resizingY = false;

    scrollbarX.moving  = false;
    scrollbarY.moving  = false;
});


//uiSaveLocal('state', null);
//uiSaveLocal('windowWidth',  null);
//uiSaveLocal('windowHeight', null);
//uiSaveLocal('productKey', null);


var currentUser = '';

var figMessages = [];


const graph = new Graph();

const generator = new Worker(
    window.URL.createObjectURL(
        new Blob([generatorScript.textContent])));


const buf = new SharedArrayBuffer(1024);


var     copiedNodesJson  = '';
var duplicatedNodesJson  = '';

var pasteOffset      = [ 0,   0];
var pasteOffsetDelta = [40, 100];


clearConsole();


uiPostMessageToFigma({ 
    cmd:    'figLoadState',
    onLoad: 'figLoadState'
});


document.addEventListener('keydown', e =>
{
    let setLastKeyDown = true;


    // copy
    if (   e.code == 'KeyC'
        && getCtrlKey(e))
    {
        pasteOffset     = [0, 0];
        copiedNodesJson = uiCopyNodes(graphView.selectedNodes.map(n => n.id));
    }

    // paste
    else if (e.code == 'KeyV'
          && getCtrlKey(e))
    {
        actionManager.do(new PasteNodesAction(copiedNodesJson, e.shiftKey));
    }

    // duplicate
    else if (e.code == 'KeyD'
          && getCtrlKey(e))
    {
        pasteOffset = [0, 0];
        actionManager.do(new PasteNodesAction(uiCopyNodes(graphView.selectedNodes.map(n => n.id)), e.shiftKey));
    }

    // select all
    else if (e.code == 'KeyA'
          && getCtrlKey(e))
    {
        graphView.selectedNodes = graph.nodes;
    }

    // undo/redo
    else if (e.code == 'KeyZ'
          && getCtrlKey(e))
    {
        if (e.shiftKey) actionManager.redo();
        else            actionManager.undo();

        setLastKeyDown = false;
    }

    // delete
    else if (e.key == 'Delete')
    {
        const nodeIds = graphView.selectedNodes.map(n => n.id);
        actionManager.do(new DeleteNodesAction(nodeIds, nodeIds));
        graphView._selected = [];
    }

    //
    else if (e.code == 'Minus')
    {
        graphView.zoom /= 2;
    }

    else if (e.code == 'Equal')
    {
        graphView.zoom *= 2;
    }

    else if (e.code == 'Digit0'
          && getCtrlKey(e))
    {
        graphView.zoom = 1;
        uiNotify('Zoom to 100%');
    }

    else if (e.code == 'Space'
         && !getCtrlKey(e))
    {
        if (   !graphView.selecting
            && !graphView.spaceDown)
        {
            graphView.spaceDown = true;
            setCursor(panCursor);
        }
    }

    else if (e.key == 'Control'
          && graphView.spaceDown)
    {
        graphView.zoomSelecting = true;

        if (e.altKey) setCursor(zoomOutCursor);
        else          setCursor(zoomInCursor);
    }

    else if (e.key == 'Alt')
    {
        if (   graphView.spaceDown
            && getCtrlKey(e))
            setCursor(zoomOutCursor);
        else if (graphView.overNode)
            graphView.soloNode(graphView.overNode);
    }

    else if (e.code == 'Tab')
        e.preventDefault();

    else if (e.code == 'KeyS'
        && getCtrlKey(e))
        saveGraph();
});



document.addEventListener('keyup', e =>
{
    if (e.code == 'Space')
    {
        if (graphView.spaceDown)
        {
            graphView.spaceDown     = false;
            graphView.zoomSelecting = false;
            setAutoCursor();
        }
    }

    else if (e.key == 'Alt')
    {
        if (graphView.spaceDown)
        {
            if (getCtrlKey(e)) 
                setCursor(zoomInCursor);
            else
            {
                setCursor(panCursor);
                graphView.zoomSelecting = false;
            }
        }
        else if (graphView._soloNode)
            graphView.unsoloNode();
    }

    else if (e.key == 'Control'
          && graphView.spaceDown)
    {
        graphView.zoomSelecting = false;
        setCursor(panCursor);
    }
});


// --> from Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = e =>
{
    let msg = e.data.pluginMessage;

    switch (msg.cmd)
    {
        case 'uiForwardToGen':        uiPostMessageToGenerator(msg.msg); break;
        case 'uiEndLoadState':        uiEndLoadState(msg);               break;
        case 'uiGetPluginDataReturn': uiGetPluginDataReturn(msg);        break;
        case 'uiEndResizeWindow':     uiEndResizeWindow();               break;

        case 'uiEndFigMessage':       uiPostNextMessageToFigma();        break;
    }    
}    
  
///////////////////////////////////////////////////////////////////////////////////////////////////



// from Generator <--
///////////////////////////////////////////////////////////////////////////////////////////////////

generator.onmessage = function(e)
{
    switch (e.data.msg)
    {
        case 'uiMakeActive':      uiMakeActive    (e.data.nodeIds);                            break;
        case 'uiShowParamValue':  uiShowParamValue(e.data.nodeId, e.data.param, e.data.value); break;
        case 'uiUpdateNodes':     uiUpdateNodes   (e.data.nodeIds);                            break;
        case 'uiUpdateGraph':     uiUpdateGraph   ();                                          break;
        case 'uiUpdateObjects':   uiUpdateObjects (e.data.objects);                            break;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////






// <-- to Figma
function uiPostMessageToFigma(msg)
{
    figMessages.push(msg);
    uiPostNextMessageToFigma();
}



function uiPostNextMessageToFigma()
{
    if (figMessages.length > 0)
    {
        let msg = figMessages.shift();

        if (msg.cmd == 'figResizeWindow')
        {
            // move along the queue since only the last message is important
            while (figMessages.length > 0
                && figMessages[0].cmd == msg.cmd)
                msg = figMessages.shift();
        }

        parent.postMessage({pluginMessage: msg}, '*');    
    }
}



///////////////////////////////////////////////////////////////////////////////////////////////////



// to Generator -->
function uiPostMessageToGenerator(msg)
{
    generator.postMessage(msg);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function setCursor(cursor, asyncForce = true)
{
    document.body.style.cursor = cursor;
    if (asyncForce) setTimeout(null, 0);
}



function setAutoCursor()
{
    if (graphView.zoomSelecting)
        setCursor(zoomInCursor);
    else if (graphView.spaceDown
          || graphView.panning)
        setCursor(panCursor);
    else
        setCursor('auto');
};


// menuSelect.addEventListener('change', async function(e) 
// {
//     switch (e.detail.selectedValue)
//     {
//         case 'saveLocal':  saveToLocalFile('graph.json'); break;
//         case 'loadLocal':  loadFromLocalFile();           break;
//         case 'duplicate':  console.log(graph.toJson());     break;
//         case 'productKey': showProductKeyDialog();        break;
//     }
// });



productKeyClose.addEventListener('click', e =>
{
    hideProductKeyDialog();
});



btnToggleWires.addEventListener('pointerenter', () => { btnToggleWires.mouseOver = true;  graphView.updateShowWires(); });
btnToggleWires.addEventListener('pointerleave', () => { btnToggleWires.mouseOver = false; graphView.updateShowWires(); });


function uiCreateNode(opType, createdId = -1, updateUI = true)
{
    let node = graph.createNode(opType, createdId);
    
    graph.addNode(node);
    
    // if (graphView.selectedNodes.length > 0)
    // {
    //     const selNode = graph.nodes.find(n => n.selected);
    //     const inputs  = node.inputs.filter(i => i.dataType == selNode.dataType);

    //     if (   !!selNode
    //         && selNode.output
    //         && inputs.length > 0)
    //         uiConnect(selNode.output, inputs[0]);
    // }
    

    if (updateUI)
    {
        graphView.lastSelectedNodes = graphView.selectedNodes;
        graphView.selectedNodes     = [node];

        //node.pushUpdate();
        
        //graphView.putNodeOnTop(node);
        //graphView.updateNodeTransform(node);

        //updateGraphNodes();
    }


    // uiPostMessageToGenerator({
    //     msg:     'genCreateNode',
    //     opType:   opType,
    //     nodeId:   node.id,
    //     nodeName: node.name
    // });


    return node;
}



function uiDeleteNodes(nodeIds, actionId)
{
    graph.deleteNodes(nodeIds);
    
    // uiPostMessageToGenerator({
    //     msg:     'genDeleteNodes',
    //     nodeIds:  nodeIds,
    //     actionId: actionId
    // });
    
    uiDeleteNodeObjects(nodeIds);
}



// function uiUndeleteNodes(nodes, nodePos, actionId)
// {
//     graph.addNodes(nodes);


//     graphView.selectedNodes = nodes;
    
//     graphView.putNodeOnTop(lastOf(nodes));

//     for (let i = 0; i < nodes.length; i++)
//     {
//         setNodePosition(
//             nodes[i], 
//             nodePos[i].x, 
//             nodePos[i].y);
//     }
        

//     // uiPostMessageToGenerator({
//     //     msg:       'genUndeleteNodes',
//     //     uiActionId: actionId
//     // });
// }



function uiDeleteNodeObjects(nodeIds)
{
    uiPostMessageToFigma({ 
        cmd:    'figDeleteNodeObjects',
        nodeIds: nodeIds
    });

    // uiPostMessageToGenerator({
    //     cmd:    'genDeleteNodeObjects',
    //     nodeIds: nodeIds
    // });
}



function uiSetNodeId(nodeId, newId)
{
    const node = graph.nodeFromId(nodeId);

    node.id = newId;

    // uiPostMessageToGenerator({
    //     msg:   'genSetNodeId', 
    //     nodeId: nodeId,
    //     newId:  newId
    // });
}



function uiVariableConnect(outputOp, outputIndex, inputOp, inputIndex)
{
    //console.log('uiVariableConnect()');
    if (inputOp._variableInputs)
    {
        const input = lastOf(inputOp.inputs);

        uiConnect(
            outputOp.outputs[outputIndex],
            input,
            inputIndex);
    }
    else
    {
        uiConnect(
            outputOp.outputs[outputIndex],
             inputOp. inputs[ inputIndex]);
    }
}



function uiConnect(output, input, inputIndex = -1)
{
    graph.connect(output, input, inputIndex);

    // uiPostMessageToGenerator({
    //     msg:     'genConnect', 
    //     outputId: output.op.id, 
    //     inputs:  
    //     [{
    //         nodeId: input.op.id, 
    //         index:  input.op.inputs.indexOf(input)
    //     }]
    // });
}



function uiDisconnect(input)
{
    graph.disconnect(input);

    // uiPostMessageToGenerator({
    //     msg: 'genDisconnect',
    //     input:
    //     {
    //         nodeId: input.op.id, 
    //         index:  input.op.inputs.indexOf(input)
    //     }
    // });
}



function uiSetParam(param, value)
{
    // uiPostMessageToGenerator({
    //     msg:   'genSetParam', 
    //     nodeId: param.op.id, 
    //     param:  param.name,
    //     value:  value
    // });
}



function uiInvalidate(node)
{
    // uiPostMessageToGenerator({
    //     msg:   'genInvalidate', 
    //     nodeId: node.id
    // });
}



function uiSetActive(node, active)
{
    // uiPostMessageToGenerator({
    //     msg:   'genSetActive', 
    //     nodeId: node.id,
    //     active: active
    // });
}



function uiMakeActive(nodeIds)
{
    for (const nodeId of nodeIds)
    {
        const node = graph.nodeFromId(nodeId);
        node.makeActive();
    }
}



function uiShowParamValue(nodeId, paramName, value)
{
    const node = graph.nodeFromId(nodeId);
            
    if (!!node) // this is for deleted nodes which still exist 
    {           // in genGraph but no longer in graph
        const param = node.params.find(p => p.name == paramName);
        param.control.setValue(value, false);
    }
}



function uiUpdateNodes(nodeIds)
{
    if (graph.mutex)
    {
        for (const nodeId of nodeIds)
            graph.deferNodeIds.push(nodeId);

        return;
    }
    

    graph.mutex = true;


    // uiPostMessageToGenerator({
    //     msg:    'genUpdateObjects',
    //     nodeIds: nodeIds
    // });
}



function uiUpdateGraph()
{
    graph.mutex = false;


    if (graph.deferNodeIds.length > 0)
    {
        let deferNodes = Array.from(graph.deferNodeIds).filter(
            (value, index, self) => self.indexOf(value) === index);
            
        graph.deferNodeIds = [];

        uiUpdateNodes(deferNodes);
    }
}



function uiUpdateObjects(objects)
{
    uiUpdateGraph();
    
    uiPostMessageToFigma({ 
        cmd:    'figUpdateObjects',
        objects: objects
    });    
}



function uiCopyNodes(nodeIds)
{
    const nodes      = graph.nodes.filter(n => nodeIds.includes(n.id));
    const copiedJson = nodesToJson(nodes, true, false);

    //console.log(copiedJson);

    return copiedJson;
}



function uiPasteNodes(nodesJson, pasteOutsideConnections)
{
    graphView.loadingNodes = true;


    pasteOffset[0] += pasteOffsetDelta[0];
    pasteOffset[1] += pasteOffsetDelta[1];


    const data  = JSON.parse(nodesJson);


    // offset new nodes (must be done before loading)
    for (let i = 0; i < data.nodes.length; i++)
    {
        data.nodes[i].x = parseFloat(data.nodes[i].x) + pasteOffset[0] / graphView.zoom;
        data.nodes[i].y = parseFloat(data.nodes[i].y) + pasteOffset[1] / graphView.zoom;
    }

    
    const nodes = loadNodes(data);

    // get the new names of the nodes after they've been added
    for (let i = 0; i < nodes.length; i++)
    {
        graph.addNode(nodes[i], false);
        data.nodes[i].newName = nodes[i].name;
    }
    
    if (data.connections)
    {
        correctNodeNamesInConnections(data);
        loadConnections(data, pasteOutsideConnections);
    }
    
    graphView.selectedNodes = nodes;
    
    graphView.loadingNodes = false;
    return nodes;
}



function correctNodeNamesInConnections(data)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];

        let outputOpIndex = data.nodes.findIndex(n => n.name == _conn.outputOp);
        if (outputOpIndex > -1) data.connections[i].outputOp = data.nodes[outputOpIndex].newName;

        const  inputOpIndex = data.nodes.findIndex(n => n.name == _conn. inputOp);
        data.connections[i]. inputOp = data.nodes[ inputOpIndex].newName;
    }
}



function updateGraphNodes()
{
    for (const node of graphView.selectedNodes)      node.updateNode();
    for (const node of graphView._prevSelectedNodes) node.updateNode();
    for (const node of graphView.lastSelectedNodes)  node.updateNode();
}


function uiEndLoadState(msg)
{
    currentUser = msg.currentUser;
    productKey  = msg.productKey;

    setInterval(autoSave, 5000); // auto save every 5 seconds
    uiGetPluginData('graph'); // load graph from current page

    uiEndResizeWindow();

    window.focus();
}



function checkAddMenuItemProductKey(menuSelectItems)
{
    if (!validateProductKey(currentUser.id, productKey))
        menuSelectItems.push({value: 'productKey', text: 'Enter product key'});
}



function removeMenuItemProductKey()
{
    let index = menuSelect.items.findIndex(item => item.value == 'productKey');
    removeAt(menuSelect.items, index);
    menuSelect.updateItems();
}



function uiNotify(text, prefix = 'Generator: ', delay = 4000)
{
    uiPostMessageToFigma({ 
        cmd:   'figNotify',
        text:   text,
        prefix: prefix,
        delay:  delay
    });        
}


const resizeEdgeWidth = 8;

document.canResizeX    = false;
document.canResizeY    = false;
   
document.resizingX     = false;
document.resizingY     = false;

document.startRect = new Rect();



function resizeWindow(width, height)
{
    uiPostMessageToFigma({ 
        cmd:   'figResizeWindow', 
        width:  width,
        height: height
    });
}



function checkResize(x, y)
{
    document.canResizeX = document.body.clientWidth  - x <= resizeEdgeWidth;
    document.canResizeY = document.body.clientHeight - y <= resizeEdgeWidth;

         if (document.canResizeX
          && document.canResizeY) setCursor('nwse-resize', false); 
    else if (document.canResizeX) setCursor('ew-resize',   false);   
    else if (document.canResizeY) setCursor('ns-resize',   false);   
    else                          setAutoCursor();
}


// function saveToLocalFile(filename, str) 
// {
//     const link = document.createElement('a');
//     link.style.display = 'none';
    
//     link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(str));
//     link.setAttribute('download', filename);
    
//     document.body.appendChild(link);
//     link.click();
//     document.body.removeChild(link);
// }



function saveGraph()
{
    const json = graph.toJson(); 
    //log(json); 
    uiSetPluginData("graph", json);
}



function loadGraph(json)
{
    graphView.loadingNodes   = true;
    graphView.canUpdateNodes = false;


    graph.clear();
    
    const data = JSON.parse(json);
    //log(json);


    const pan = point( 
        parseFloat(data.panx), 
        parseFloat(data.pany));

    const zoom = parseFloat(data.zoom);

    if (isNaN(pan.x)) pan.x = 0;
    if (isNaN(pan.y)) pan.y = 0;

    if (isNaN(zoom))  zoom  = 1;

    graphView.setPanAndZoom(pan, zoom);


    graphView.showWires = data.showWires == 'true';


    loadNodesAsync(data, setLoadingProgress);
}



function setLoadingProgress(progress)
{
    loadingProgress.style.width = (progress * 100) + '%';
}



function loadNodesAsync(data, setProgress)
{
    loadingProgress.style.width   = 0;
    loadingOverlay .style.display = 'block';


    let promise = Promise.resolve([]);


    const chunkSize = 10; // nodes
    for (let i = 0; i < data.nodes.length; i += chunkSize)
    {
        promise = promise.then(nodes => 
        {
            const res = resolveLoadNodes(
                data.nodes, 
                i, 
                Math.min(i + chunkSize, data.nodes.length), // exclusive
                nodes);

            setProgress(i / (data.nodes.length + (data.connections ? data.connections.length : 0)));
            return res;
        });
    }


    promise.then(nodes => 
    {
        graph.addNodes(nodes, false, false);
        loadConnectionsAsync(data, nodes, setProgress);    
    });
}



function loadConnectionsAsync(data, nodes, setProgress)
{
    let promise = Promise.resolve([]);


    if (data.connections)
    {
        const chunkSize = 10; // connections
        for (let i = 0; i < data.connections.length; i += chunkSize)
        {
            promise = promise.then(() => 
            {
                const res = resolveLoadConnections(
                    data.connections, 
                    i, 
                    Math.min(i + chunkSize, data.connections.length), // exclusive
                    data);

                setProgress((data.nodes.length + i) / nozero(data.nodes.length + data.connections.length * 19/20)); // the proportion is arbitrary
                return res;
            });
        }
    }


    promise.then(() => 
    {
        graphView.canUpdateNodes = true;

        //nodes.forEach(n => n.updateNode());
        updateTerminalsAfterNodes(nodes);

        graphView.updateShowWires();
        graphView.updatePanAndZoom();
        graphView.updateNodeTransforms(nodes);
        graphView.updateScroll();

        loadingOverlay.style.display = 'none';

        graphView.loadingNodes = false;
    });
}



function resolveLoadNodes(_nodes, first, last, nodes)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
                nodes.push(loadNode(_nodes[i]));

            resolve(nodes);
        }));
}



function resolveLoadConnections(_connections, first, last, data)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
            {
                const _conn = _connections[i];

                if (   data.nodes.find(n => (n.newName ? n.newName : n.name) == _conn.outputOp)
                    && data.nodes.find(n => (n.newName ? n.newName : n.name) == _conn. inputOp)
                    || loadOutsideConnections)
                    Connection.parseJson(_conn);
            }

            resolve();
        }));
}



function loadNodes(data)
{
    const nodes = [];
    
    for (let i = 0; i < data.nodes.length; i++)
        nodes.push(loadNode(data.nodes[i]));

    return nodes;
}



function loadNode(_node)
{
    const node = graph.createNode(_node.type);

    node.name = _node.name;

    if (_node.labelOffset)
        node.labelOffsetFactor = parseFloat(_node.labelOffset);

    if (  _node.params
        || node.alwaysLoadParams)
        node.loadParams(_node);

    setNodePosition(
        node, 
        parseFloat(_node.x), 
        parseFloat(_node.y),
        false);

    node.loaded = true;

    return node;
}



function loadConnections(data, loadOutsideConnections, setProgress = null)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];
        
        if (      data.nodes.find(n => (n.newName ? n.newName : n.name) == _conn.outputOp)
               && data.nodes.find(n => (n.newName ? n.newName : n.name) == _conn. inputOp)
            || loadOutsideConnections)
            Connection.parseJson(_conn);

        if (setProgress)
            setProgress(((data.nodes.length + i) / (data.nodes.length + data.connections.length)));
    }
}



function autoSave()
{
    uiSetPluginData('graph', graph.toJson());
}


const licenseKeys     = createCryptoKeys();
const licenseHashSize = 4;



function createProductKey(name)
{
    var hash = hashLicenseName(name, licenseHashSize);
    var enc  = sign(hash, licenseKeys.private);
    var key  = arrayToBase32(enc);

    return key;
}



function validateProductKey(name, key, rec = false)
{
    // TODO: check from today until 1 year from now (max license length)
    // 1/day, so 365 max, add end day to name
    // check today against last launch date (in private data) to prevent clock tampering

    var arr  = base32toArray(key.toUpperCase());
    var dec  = verify(arr, licenseKeys.public).subarray(licenseHashSize);
    var trim = dec.subarray(dec.length - licenseHashSize);
    var hash = hashLicenseName(name, licenseHashSize);
    
    var valid = arraysEqual(trim, hash);

    if (valid && !rec)
    {
        var lowerKey  = key;

        var lastChar  = lowerKey[lowerKey.length-1];
        var lastIndex = base32chars.indexOf(lastChar);

        if (lastIndex > 0)
        {
            lowerKey = replaceInStringAt(lowerKey, lowerKey.length-1, base32chars[lastIndex-1]);

            if (validateProductKey(name, lowerKey, true))
                return false; // at this scale of product key the last bit needs to be guarded against
        }
    }

    return valid;
}



function hashLicenseName(name, nBytes)
{
    // XOR wrap name around a given number of bytes

    var bytes = stringToArray(name);

    if (bytes.length > nBytes)
    {
        var pos    = nBytes;
        var length = bytes.length - nBytes;
        
        while (length > 0)
        {
            for (var i = 0; i < nBytes; i++)
                bytes[i] ^= bytes[pos+i];
            
            pos    += nBytes;
            length -= nBytes;
        }
    }
    

    return newSizeArrayFrom(bytes, nBytes);
}


var productKey = '';



function showProductKeyDialog()
{
    productKeyBack  .style.display = 'block';
    productKeyDialog.style.display = 'block';

    productKeyUserInfo.innerHTML = '<span style="user-select: none; color: #aaa;">User ID: </span>' + currentUser.id;

    setDefaultProductKeyInput();
    productKeyInputBack.innerHTML = '•'.repeat(13);
    productKeyInput.value = '';
    
    //menuSelect.setSelectedIndex(0);
    
    window.setTimeout(() => document.getElementById('productKeyInput').focus(), 0);
}



function hideProductKeyDialog()
{
    productKeyBack  .style.display = 'none';
    productKeyDialog.style.display = 'none';
}



productKeyBack.addEventListener('pointerdown', () =>
{
    hideProductKeyDialog();
});



productKeyInput.addEventListener('input', () =>
{
    let val = productKeyInput.value;
    
    val = val.toUpperCase();
    val = val.replace(/[^12345679ABCDEFGHJKLMNPQRSTUVWXYZ]/g, '');
    val = val.substring(0, Math.min(val.length, 13));
    
    productKeyInput.value = val;

    productKeyInputBack.innerHTML = 
          '&nbsp;'.repeat(val.length)
        + '•'.repeat(13 - val.length);

    
    if (val.length == 13)
    {
        if (validateProductKey(currentUser.id, val))
        {
            productKey = val;        
            uiSaveLocal('productKey', productKey);
            
            productKeyInput.blur();
            setGoodProductKeyInput();
            
            window.setTimeout(() => 
            {
                hideProductKeyDialog();
                //updateMenuSelectItems();

                uiNotify('✨ Thank you for subscribing to Generator! ✨', '', 6000);    
            }, 
            1200);
        }
        else
            setBadProductKeyInput();
    }
    else
        setDefaultProductKeyInput();
});



function setBadProductKeyInput()
{
    productKeyInput.style.outline   = '2px dashed #e00';        
    productKeyInput.style.boxShadow = 'none';
}



function setGoodProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px #0b0';
}



function setDefaultProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px ' + colorStyleRgb(rgbActiveObject); 
}




////////////////////////////////////////////////////

</script>
