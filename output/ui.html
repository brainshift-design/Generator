<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<style>


body
{
    margin: 0;
}

#container
{
    display: table-column;
}




</style>

<div id='container'>

    <h1>Generator</h1>

</div>





<script>

////////////////////////////////////////////////////





function loadState(state)
{
    resizeWindow(
        window.innerWidth, 
        state.windowHeight);
}    


function save(key, value)
{
    parent.postMessage({ pluginMessage:
    { 
        cmd:   'save', 
        key:   key,
        value: value
    }}, '*');
}


function saveState()
{
    save('state',
    {
        //windowHeight: window.innerHeight
    });
}


class Input
{
    constructor()
    {
        
    }
}


class Output
{
    constructor()
    {
        
    }
}


class Connection
{
    constructor()
    {
        
    }
}


class Parameter
{
    type;

    constructor(type)
    {
        this.type = type;
    }
}


class   ValueParam
extends Parameter
{
    constructor()
    {
        super('value');
    }
}


class Operator
{
    _type;
    _id;
    
    params  = new Array();
    
    inputs  = new Array();
    outputs = new Array();

    graph   = null;


    constructor(type)
    {
        this._type = type;
        this._id   = type; // this is a temp until the op becomes a graph node
    }

    get type() { return this._type; }
    get id()   { return this._id;   }

    setId(newId)
    {
        if (this.graph.nodes.indexOf(newId) >= 0)
            return false; // graph already contains a node with this id

        this._id = newId;
        return true;
    }

    update()
    {

    }
}


class   OpRect
extends Operator
{
    constructor()
    {
        super('rect');

        var w = new ValueParam('Width',  0, Number.MAX_SAFE_INTEGER);
        var h = new ValueParam('Height', 0, Number.MAX_SAFE_INTEGER);

        this.params.push(w);
        this.params.push(h);
    }

    update()
    {
        // TODO add an "update this rect" instruction to the update list,
        // maybe through super.update('instruction')
        super.update();
    }
}


class   OpSpread 
extends Operator
{
    constructor()
    {
        super('spread');
    }
}


function updateCanvas()
{
    // build updated geometry description, with info about
    // whether to modify or recreate (for example, spread density change = modify,
    // spread count change = recreate, and this might be detailed further)


    // pass this info to the canvas
}


class Graph
{
    nodes       = new Array();
    #activeNode = null;

    add(node)
    {
        this.nodes.push(node);
        
        node._id   = this.getNewId(node.type);
        node.graph = this;
    }


    get activeNode() { return this.#activeNode; }
    set activeNode(node)
    {
        this.#activeNode = node;
        updateCanvas(this); // send this graph to be created in the canvas
    }


    getNewId(type)
    {
        var maxNum = 0;

        for (const node of this.nodes)
        {
            if (   node.id.length < type.length
                || node.id.substring(0, type.length) !== type)
                continue;

            var num = parseInt(node.id.substring(type.length));
            if (num == 0) num = 1;

            maxNum = Math.max(num, maxNum);
        }

        if (maxNum == 0)
            return type;

        maxNum++;

        return type + maxNum;
    }
}


const resizeEdgeWidth = 8;

document.canResizeX = false;
document.canResizeY = false;

document.resizingX  = false;
document.resizingY  = false;

document.startX     = 0;
document.startY     = 0;

document.startH     = 0;
document.startW     = 0;


document.addEventListener('pointerdown', function(e)
{
    if (   document.canResizeX
        || document.canResizeY)
    {
        if (document.canResizeX) document.resizingX = true;
        if (document.canResizeY) document.resizingY = true;

        document.startX   = e.clientX;
        document.startY   = e.clientY;

        document.startW   = window.innerWidth;
        document.startH   = window.innerHeight;

        document.body.setPointerCapture(e.pointerId);
    }
});


document.addEventListener('pointermove', function(e)
{
    if (   document.resizingX
        && document.resizingY)
    {
        resizeWindow(
            document.startW + e.clientX - document.startX,
            document.startH + e.clientY - document.startY);
    }
    else if (document.resizingX)
    {
        resizeWindow(
            document.startW + e.clientX - document.startX,
            document.body.clientHeight);
    }
    else if (document.resizingY)
    {
        resizeWindow(
            document.body.clientWidth,
            document.startH + e.clientY - document.startY);
    }
    else
        checkResize(e.clientX, e.clientY);
});


document.addEventListener('pointerup', function(e)
{
    if (   document.resizingX
        || document.resizingY)
    {
        document.resizingX = false;
        document.resizingY = false;
        
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }
});


function resizeWindow(width, height)
{
    parent.postMessage({ pluginMessage: 
    { 
        cmd:    'resizeWindow', 
        width:  width,
        height: height
    }}, '*');

}


function checkResize(x, y)
{
    document.canResizeX = document.body.clientWidth  - x <= resizeEdgeWidth;
    document.canResizeY = document.body.clientHeight - y <= resizeEdgeWidth;

         if (document.canResizeX
          && document.canResizeY) document.body.style.cursor = 'nwse-resize';
    else if (document.canResizeX) document.body.style.cursor = 'ew-resize';
    else if (document.canResizeY) document.body.style.cursor = 'ns-resize';
    else                          document.body.style.cursor = 'auto';
}


//save('state', null);
//save('windowWidth', null);
//save('windowHeight', null);


parent.postMessage({ pluginMessage: 
{ 
    cmd:    'loadState',
    onLoad: 'loadState'
}}, '*');


onmessage = (e) =>
{
    var msg = e.data.pluginMessage;
}


/////////////////////////////////////////////////////////


var graph = new Graph();

graph.add(new OpRect());

graph.activeNode = graph.nodes[graph.nodes.length-1];
updateCanvas(graph);




////////////////////////////////////////////////////

</script>
