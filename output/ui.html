<link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<style>


.button
{
    font-family:   Inter;
    font-size:     11px;
    width:         30;
    height:        30;
    background:    white;
    min-width:     0;
    min-height:    0;
    border:        none;
    border-radius: 2px;
    position:      relative;
    padding:       0;
}


.button:hover
{
    background: #f0f0f0;
}


.button:active
{
    box-shadow: 0 0 0 2px #18A0FB inset;
    outline:    none;
}


#controlBar
{
    display:          block;
    height:           40px;
    background-color: #2c2c2c;
    /* vertical-align:   middle; */
    padding:          0;
}


body
{
    margin:           0;
    background-color: #eee;
    user-select:      none;
}


div
{
    margin:  0;
    padding: 0;
}


#graphView
{
    display:  block;
    overflow: hidden;
    height:   calc(100% - 40px);
    position: relative;
}


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    height:        28px;
    padding-top:   1;
    border:        none;
    box-shadow:    0px 1px 0px 0px rgba(0, 0, 0, 0.1);
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:hover
{
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}


input[type=text]:focus
{
    box-shadow: 0 0 0 1px #18A0FB;
    outline: none;
}


input[type=text]::selection
{
    background-color: #b9e2fe;
}



#graphView
{
    z-index:  0;
    overflow: hidden;
    /* box-shadow: 0 0 0 1px red inset;
    background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 10 10'> <path d='M0 0 L0 10 L10 10' fill='red' /></svg>");
    background-repeat:no-repeat;
    background-position:center center;
    background-size: 100% 100%, auto; */
 }


.node
{
    display:       block;
    position:      absolute;
    width:         100px;
    height:        auto;
    border-radius: 4px 4px 0 0;
    padding:       0;
}


.nodeInner
{
    display:       block;
    position:      relative;
    width:         100px;
    height:        auto;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    padding:       0;
    box-shadow:    0px 5px 20px #0001;
}    


.nodeHeader
{
    background:    #BEDFFF;
    display:       flex;
    width:         100%;
    position:      relative;
    border-radius: 4px 4px 0 0;
}


.nodeLabel
{
    font-family:    Inter;
    font-size:      11;
    padding:        0;
    margin:         0;
    display:        inline-block;
    height:         14;
    color:          black;
    text-align:     center;
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-50%) translateY(-50%);
    pointer-events: auto;
}


.nodeLabelTextbox
{
    font-family: Inter;
    font-size:   11;
}


.inputControls
{
    width:          20px;
    height:         25px;
    float:          left;
    margin-right:   auto;
    pointer-events: none;
}


.outputControls
{
    width:          20px;
    height:         25px;
    float:          right;
    margin-left:    auto;
    pointer-events: none;
}


.input
{
    width:          10px;
    height:         10px;
    background:     white;
    border-radius:  5px;
    margin:         0;
    position:       absolute;
    top:            50%;
    transform:      translateY(-50%);
    left:           3px;
    pointer-events: auto;
    box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12);
}


.output
{
    width:          10px;
    height:         10px;
    background:     white;
    border-radius:  5px;
    margin:         0;
    position:       absolute;
    top:            50%;
    transform:      translateY(-50%);
    right:          3px;
    pointer-events: auto;
    box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12);
}


#selectBox
{
    outline:          1pt solid #18A0FB;
    background-color: #18A0FB20;
    pointer-events:   none;
    margin:           0;
    padding:          0;
    position:         absolute;
    visibility:       hidden;
}


#scrollbarX
{
    background-color: #969696;
    height:           6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);
}


#scrollbarY
{
    background-color: #969696;
    width:            6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);
}


.menuButton
{
    font-family:     Inter;
    font-size:       11px;
    width:           40px;
    height:          40px;
    background:      #2c2c2c;
    border-radius:   0;
    min-width:       0;
    min-height:      0;
    border:          none;
    position:        relative;
    padding:         0;
    padding-top:     1px;
    padding-bottom: -1px;
    margin-right:   -4px;
    color:          #d5d5d5;
}


.menuButton:hover
{
    background: black;
    color:      white;
}


.menuButton:focus
{
    background:#18A0FB;
    color:     white;
}




.menuSelect
{
    font-family:         Inter;
    font-size:           14;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         1;
    margin-right:        6;
    margin-top:          0;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
    color:               white;
}


.menuSelect:hover
{
    /* box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1); */
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) calc(50% + 3px);
    background-repeat:   no-repeat;
    padding-right:       30;
    transition:          all 0.2s ease;
}


.menuSelect:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px #18A0FB;
    outline:             none;
}


.menuSelectText
{
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
    position:       relative;
    top:            3px;
}


.menuSelectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px  7px rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2 );
    /* overflow:      hidden; */
}


.menuSelectMenu::after 
{
    content:       '';
    position:      absolute;
    top:           -10px;
    left:          65px;
    border-width:  5px;
    border-style:  solid;
    border-color:  transparent transparent #222 transparent;
}



#productKeyBack
{
    display:          none;

    z-index:          1;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;

    background-color: #0002
}


#productKeyDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    top:           60px;
    left:          calc(50% - 130px);
    width:         220px;
    height:        170px;
    
    background:    white;
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);
    box-shadow:    0px 2px 14px rgba(0, 0, 0, 0.15);
    border-radius: 4px;
}


#productKeyTitle
{
    height:        40px;
    border-bottom: 1px solid rgb(0, 0, 0, 0.15);
}


#productKeyText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          rgba(0, 0, 0, 0.8);
}


#productKeyClose
{
    width:    32px;
    height:   32px;
    position: absolute;
    left:     calc(100% - 36px);
    top:      4px;
}

#productKeyClose:active
{
    box-shadow: none;
}


#productKeyUserInfo
{
    font-size:      12px;

    margin-top:     16px;
    margin-bottom:  12px;

    position:       relative;
    left:           21px;

    user-select:    text;
}


#productKeyWebsite
{
    font-size:      12px;
    text-align:     center;

    margin-top:     16px;
    margin-bottom:   8px;
}


#productKeyInput
{
    font-family:  'Roboto Mono';
    font-size:     16px;
     
    width:         calc(9em + 1px);
    padding-left:  10px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-bottom: -3px;

    position:      relative;
    left:          calc(50% - 4.5em);
}



#productKeyInputBack
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    color:          #ddd;
    
    width:           9em;
    padding-left:   10px;
    padding-top:    -2px;
    padding-bottom:  2px;

    position:       absolute;
    left:           calc(calc(50% - 4.5em) + 1px);
    top:            calc(50% + 2px);

    pointer-events: none;
}



.select
{
    font-family:         Inter;
    font-size:           11;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         2;
    margin-right:        6;
    margin-top:          1;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.4"/> </svg>');
    background-position: calc(100% - 17px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
}


.select:hover
{
    box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1);
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 7px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
}


.select:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 6px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px #18A0FB;
    outline:             none;
}


.selectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px 7px  rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2);
    overflow:      hidden;
}


.slider
{
    padding:          0;
    width:            74px;
    height:           26px;
    /* box-shadow:       0 -2px 0 -1px rgba(0, 0, 0, 0.1) inset; */
    /* border-radius:    1px; */
    overflow:         hidden;
    background-color: white;
    text-align:       center;
}    

.sliderName
{
    color: #b3b3b3;
}

.sliderBar
{
    position:       absolute;
    pointer-events: none;
}

.sliderText
{
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
    position:       relative;
    top:            3px;
}

.sliderFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px #18A0FB inset;
    visibility:     hidden;
    opacity:        0;
}

/* .slider:hover
{
    box-shadow: 0 0 0 -1px rgba(0, 0, 0, 0.1);
}     */

/* .slider:focus
{
    outline:    none;
    box-sizing: border-box;
    border:     solid 2px #18A0FB;
    box-shadow: 0 0 0 -2px #18A0FB inset;
}     */


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    height:        28px;
    padding-top:   1;
    border:        none;
    box-shadow:    0px 1px 0px 0px rgba(0, 0, 0, 0.1);
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:hover
{
    box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
}


input[type=text]:focus
{
    box-shadow: 0 0 0 2px #18A0FB;
    outline:    none;
}


input[type=text]::selection
{
    background-color: #b9e2fe;
}


</style>

<div id='controlBar'>
    
    <div id='menuSelect' style='margin-left: 10px;'></div>
    
    <button class='menuButton' id='btnCreateNumber' onclick='actionManager.do(new CreateNodeAction("number")); this.blur();'>NUM</button>
    <button class='menuButton' id='btnCreateRandom' onclick='actionManager.do(new CreateNodeAction("random")); this.blur();'>RND</button>
    <button class='menuButton' id='btnCreateRect'   onclick='actionManager.do(new CreateNodeAction("rect"  )); this.blur();'>RCT</button>
    <button class='menuButton' id='btnCreateRow'    onclick='actionManager.do(new CreateNodeAction("row"   )); this.blur();'>ROW</button>
    <button class='menuButton' id='btnCreateColumn' onclick='actionManager.do(new CreateNodeAction("column")); this.blur();'>COL</button>
    <!-- <button class='button' id='btnCreateSpread' onclick='uiCreateNode("spread"); this.blur();'>Spr</button> -->
    
</div>
    
<div id='selectBox'></div>

<div id='graphView'>
    <div id='scrollbarX'></div>
    <div id='scrollbarY'></div>
</div>

<div id='productKeyBack'></div>

<div id='productKeyDialog'>

    <div id='productKeyTitle'>
        <div id='productKeyText'>Enter product key</div>
        <div class='button' id='productKeyClose' onclick='productKeyClose.blur();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="black" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='productKeyBody'>
        <div id='productKeyUserInfo'></div>
        <input type='text' id='productKeyInput' />
        <div id='productKeyInputBack'></div>
        <div id='productKeyWebsite'>Get product key at<br/><a href='http://www.bourt.com/generator' target='_blank'>bourt.com/generator</a></div>
    </div>

</div>


<script id='generatorScript' type='javascript/worker'>



const objectColor       = '#bee0ff';
const numberColor       = '#ddd';

const activeObjectColor = '#18a0fb';
const activeNumberColor = '#787878';

const inputColor        = 'rgba(0, 0, 0, 0.12)';

const smallScrollGap =  6;
const largeScrollGap = 14;


const R = 0, G = 1, B = 2, A = 3;
const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function getDigitCount(i)
{
    var l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigit(key)
{
    var is = 
           key >= '0' 
        && key <= '9';

    return is;
}



function isHexLetter(key)
{
    var is =
           key.length == 1
        && (   key >= 'A' && key <= 'F'
            || key >= 'a' && key <= 'f');

    return is;
}



function getNumberString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (i < str.length && str[i] !== '.' && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
    str = str.substring(0, i--);
    
    if (   str[i] === '.' 
        || str[i] === ',') // hack because JavaScript
        str = str.substring(0, i--);
    
    return str;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (index > -1)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    var last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function capitalize(str)
{
    var cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    var str = '';

    for (var i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (var i = 0; i < vars.length; i++) 
    {
        var pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618


function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return { 
        x: dist * Math.cos(angle), 
        y: dist * Math.sin(angle) };
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return { x: v.x == 0 ? 0 : v.x / lengthv(v),
             y: v.y == 0 ? 0 : v.y / lengthv(v) };
}



function addv(v1, v2)
{
    return { x: v1.x + v2.x,
             y: v1.y + v2.y };
}	



function subv(v1, v2)
{
    return { x: v1.x - v2.x,
             y: v1.y - v2.y };
}	



function mulv(v1, v2)
{
    return { x: v1.x * v2.x,
             y: v1.y * v2.y };
}	



function mulvs(v, s)
{
    return { x: v.x * s,
             y: v.y * s };
}	



function divvs(v, s)
{
    return { x: v.x / s,
             y: v.y / s };
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return { x:  v.y, 
             y: -v.x };
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        {x:x1, y:y1}, 
        {x:x2, y:y2} ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return {x:NaN, y:NaN}; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return {x:NaN, y:NaN}; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return {x:NaN, y:NaN};
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}


function mulv2m3(v, m)
{
    var r = [0, 0, 0];

    for (var i = 0; i < 3; i++)
    {
        // calculate the dot product of the ith row of m and v
        for (var j = 0; j < 3; j++)
            r[i] += m[i][j] * v[j];
    }

    return {x: r[0], y: r[1]};
}


function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}


function transform(p, xform)
{
    return mulv2m3(p, xform);
}


function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}


function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



var bigBuffer = new Uint8Array(2048);



// function bigPower(a, n, p)
// {
//     var res = 1n;

//     a %= p; // update a if a >= p
 
//     while (n > 0n)
//     {
//         // if n is odd, multiply a by result
//         if (n & 1n)
//             res = (res*a) % p;
 
//         // n must be even now    
//         n >>= 1n;
//         a = (a*a) % p;
//     }    

//     return res;
// }    



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



// multiply BigInt by float 0 <= f <=1
// function bigMult(n, f)
// {
//     var mult = 100000000000000000000000000; // this is the float "precision"
    
//     return n*BigInt(mult) 
//          * BigInt(Math.floor(f*mult))
//          / sqr(BigInt(mult));
// }            



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



// function bigModInvert(n, m)
// {
//     for (var i = 1n; i < BigInt(m); i++)
//         if ((((n % m) * (i % m)) % m) == n)
//             return i;
// }



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}



// function bigModInvert(u, v)
// {
//    var inv, u1, u3, v1, v3, t1, t3, q;
//    var iter;


//    /* Step X1. Initialise */
   
//    u1 = 1n;
//    u3 = u;
//    v1 = 0n;
//    v3 = v;
   

//    /* Remember odd/even iterations */
   
//    iter = 1n;

   
//    /* Step X2. Loop while v3 != 0 */
  
//    while (v3 != 0n)
//    {
//        /* Step X3. Divide and "Subtract" */
//        q  = u3 / v3;
//        t3 = u3 % v3;
//        t1 = u1 + q * v1;

//        /* Swap */
//        u1 = v1; v1 = t1; 
//        u3 = v3; v3 = t3;

//        iter = -iter;
//    }


//    /* Make sure u3 = gcd(u,v) == 1 */
 
//    if (u3 != 1n)
//        return 0n;   /* Error: No inverse exists */


//     /* Ensure a positive result */
//     if (iter < 0n)
//         inv = v - u1;
//     else
//         inv = u1;
//     return inv;
// }


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;

    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return {x: this.l, y: this.t}; }
    get tc() { return {x: this.c, y: this.t}; }
    get tr() { return {x: this.r, y: this.t}; }
    get ml() { return {x: this.l, y: this.m}; }
    get mc() { return {x: this.c, y: this.m}; }
    get cm() { return {x: this.c, y: this.m}; }
    get mr() { return {x: this.r, y: this.m}; }
    get bl() { return {x: this.l, y: this.b}; }
    get bc() { return {x: this.c, y: this.b}; }
    get br() { return {x: this.r, y: this.b}; }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }


    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }

    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }

    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }

	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}

    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }

    expandFromRect(rect)
    {
        if (rect.isNaN  ) return this;
        if (rect.isEmpty) return this;

        if (this.isNaN  ) this.assign(rect);
        if (this.isEmpty) return rect;
        
        const newRect = new AbsRect(
            Math.min(this.t, rect.t),
            Math.min(this.l, rect.l),
            Math.max(this.b, rect.b),
            Math.max(this.r, rect.r));

        this.assign(newRect);
    }
}


class   AbsRect
extends Rect
{
    constructor(t, l, b, r)
    {
        super(l, t, r-l, b-t);
    }
}


function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function removeFromArray(array, obj)
{
    var index = array.indexOf(obj);
    
    if (index > -1)
        array.splice(index, 1);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyle(rgb)
{
    return colorStyle_(rgb[R], rgb[G], rgb[B], 1);
}



function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign({}, obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element) { element.style.visibility = 'visible'; }
function hide(element) { element.style.visibility = 'hidden'; }



function colorFromDataType(dataType, active)
{
    switch (dataType)
    {
        case 'object': return active ? activeObjectColor : objectColor;
        case 'number': return active ? activeNumberColor : numberColor;
    }

    return 'magenta';
}



function position(e)
{
    return {
        x: e.clientX,
        y: e.clientY
    };
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function logVar(x)
{
    console.log(
        Object.keys  (x)[0] + ' =', 
        Object.values(x)[0]);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj, null).getPropertyValue(style);
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;


class NoiseSeed
{
    initial;
    current;

    
    constructor()
    {
        this.reset();
    }
    
    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    
    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    
    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }

    reset()
    {
        this.current = this.initial;
    }
};


class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        var next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


class GParameter
{
    #name;
    get name() { return this.#name; }

    #type; 
    get type() { return this.#type; }
    
    _op; 
    get op() { return this._op; }

    constructor(name, type)
    {
        this.#name = name;
        this.#type = type;
    }
}


class   GNumberParam
extends GParameter
{
    #value;

    #min;
    #max;
    

    
    get value() 
    {
        var value = Math.min(Math.max(this.#min, this.#value), this.#max);

        if (this.input.connected)
        {
            value = Math.min(Math.max(this.#min, this.input.data.value), this.#max);

            genPostMessageToUi({ 
                msg:   'uiShowParamValue',
                nodeId: this.op.id,
                param:  this.name,
                value:  value
            });
        }

        return value;
    }

    
    set value(value) 
    {
        this.#value   = value;
        this.op.valid = false;
    }



    input; 



    constructor(name, 
                value = 0, 
                min   = Number.MIN_SAFE_INTEGER, 
                max   = Number.MAX_SAFE_INTEGER)
    {
        super(name, 'number');

        this.#value    = value;
   
        this.#min      = min;
        this.#max      = max;

        this.input = new GInput('number');
        this.input._param = this;
    }
}


class GGraph
{
    nodes = [];

    mutex = false;

    deferNodes = [];

    

    clear()
    {
        this.notes = [];
    }



    createNode(opType, id, name)
    {
        let node;

        switch (opType)
        {
            case 'number': node = new GOpNumber(); break;
            case 'random': node = new GOpRandom(); break;
            case 'rect':   node = new GOpRect();   break;
            case 'row':    node = new GOpRow();    break;
            case 'column': node = new GOpColumn(); break;
            case 'spread': node = new GOpSpread(); break;
        }
        
        node.id   = id;
        node.name = name;

        this.addNodes([node]);

        return node;
    }



    addNodes(nodes)
    {
        for (const node of nodes)
        {
            node.graph = this;
            this.nodes.push(node);
        }
    }
    


    deleteNodes(nodeIds)
    {
        let deleted = []; // this array of deleted notes will be put in a list for undo


        for (const nodeId of nodeIds)
        {
            const node = this.nodes.find(n => n.id == nodeId);

            for (const input of node.inputs)
                if (input.connected) this.disconnect(input);

            if (!!node.output)
            {
                for (const input of node.output.connectedInputs)
                    this.disconnect(input);
            }

            node.graph = null;
            removeFromArray(this.nodes, node);

            deleted.push(node);
        }


        return deleted;
    }



    connect(output, input)
    {
        if (input.connectedOutput == output)
            return false;
            
        if (input.connectedOutput != null)
            this.disconnect(input);

        output.connect(input);

        input.connectedOutput = output;

        const conn = new GConnection(output, input);

        input .connection = conn;
        output.connection = conn;
        
        input.op.valid = false;

        return true;
    }



    disconnect(input)
    {
        var output = input.connectedOutput;
        if (!output) return false;

        if (!!input.param)
            input.param.value = input.data.value;

        output.disconnect(input);
        
        input .connection     = null;
        output.connection     = null;

        input.connectedOutput = null;

        output.op.valid = false;
        input .op.valid = false;
            
        return true;
    }



    nodeFromId(id)
    {
        return this.nodes.find(n => n.id === id);
    }
}


class GInput
{
    #dataType;     
    get dataType() { return this.#dataType; }

    _op    = null; get op   () { return this._op;    }
    _param = null; get param() { return this._param; }

    connectedOutput = null;
    connection      = null;
    
    connecting      = false;
    

    get connected() { return this.connectedOutput != null; }


    constructor(dataType)
    {
        this.#dataType = dataType;
    }    
    

    get data()
    {
        return (
            this.connected
            ? this.connectedOutput.getData(this)
            : null);
    }
}


class   GOutput
extends EventTarget
{
    #dataType;     
    get dataType() { return this.#dataType; }
    
    _data = []; // output cache

    
    _op    = null; get op   () { return this._op;    }
    _param = null; get param() { return this._param; }

    
    connectedInputs = [];
    
    connecting      = false;
    
    get connected() { return this.connectedInputs.length > 0; }

    
    onconnect    = new Event('connect');
    ondisconnect = new Event('disconnect');


    constructor(dataType)
    {
        super();
        this.#dataType = dataType;
    }
    

    getData(callerInput = null) 
    {
        if (!this.op.valid)
            this.op.generate(callerInput);

        return this._data;
    }


    connect(input)
    {
        this.connectedInputs.push(input);

        this.dispatchEvent(new CustomEvent(
            'connect', 
            { 
                'output': this, 
                'input':  input 
            }));
    }


    disconnect(input)
    {
        removeFromArray(this.connectedInputs, input);

        this.dispatchEvent(new CustomEvent(
            'disconnect', 
            { 'input': input }));
    }
}


class GConnection
{
    output;
    input;


    constructor(output, input)
    {
        this.output = output;
        this.input  = input;
    }
}


function activeNodeInTree(node) 
{ 
    const left  = getActiveNodeLeft(node);  if (!!left ) return left;
    const right = getActiveNodeRight(node); if (!!right) return right;

    return null;
}



function getActiveNodeLeft(node)
{
    if (node.active) return node;

    for (const input of node.inputs)
    {
        if (input.connected)
        {
            const left = getActiveNodeLeft(input.connectedOutput.op);
            if (left) return left;
        }
    }

    return null;
}



function getActiveNodeRight(node)
{
    if (node.active) return node;

    if (!!node.output)
    {
        for (const input of node.output.connectedInputs)
        {
            const right = getActiveNodeRight(input.op);
            if (right) return right;
        }
    }

    return null;
}



function lastNodeInTree(node) 
{ 
    const right = getLastNodeRight(node); 
    return !!right ? right : null;
}



function getLastNodeRight(node)
{
    var right = null;

    if (!!node.output)
    {
        for (const input of node.output.connectedInputs)
        {
            const _right = getLastNodeRight(input.op);
            if (_right && !!right) return node;
            right = _right;
        }
    }

    return !!right ? right : node;
}


/*
    data types:
        OBJ
        number
*/


class GOperator
{
    #opType;
    get opType() { return this.#opType; }
    
    #dataType;
    get dataType() { return this.#dataType; }

    
    _name;
    get name() { return this._name; }
    set name(name) { this._name = name; }
    
    graph = null;
    
    
    params = [];
    
    inputs = [];
    output = null;
    

    _valid = false; // this is the flag for regeneration



    set valid(valid) { this._valid = valid; }
    
    get valid() 
    {
        var valid = this._valid;
        if (!valid) return valid;
        
        for (const input of this.inputs)
        {
            if (input.connected)
                valid &= input.connectedOutput.op.valid;
        }

        return valid;
    }


    
    active = false;


    div;
    inner;
    header;
    label;
    inputControls;
    outputControls;



    constructor(opType, dataType)
    {
        this.#opType   = opType;   // this is the operator type
        this.#dataType = dataType; // this is the op's main data type

        this._name = opType; // this is a temp until the op becomes a graph node
    }    
    
    

    addInput(input)
    {
        input._op = this;
        this.inputs.push(input);
    }



    setOutput(output)
    {
        if (this.output != null)
            this.output._op = null;

        output._op = this;
        this.output = output;
    }



    addParam(param)
    {
        this.params.push(param);

        param._op = this;

        param.input._op = this;
        this.inputs.push(param.input);
    }
 
    

    setId(newId)
    {
        if (this.graph.nodes.find(node => node.id == newId))
            return false; // graph already contains a node with this id

        this._name = newId;

        return true;
    }



    generate(callerInput) 
    { 
        this.valid = true; 
    }



    reset() // for the entire generation run
    {
        for (const input of this.inputs)
        {
            input.currentSeed = input.initialSeed;
            
            if (input.connected)
                input.connectedOutput.op.reset();
        }
    }



    refresh() // for repeats requests from nodes that duplicate their input, like row and column
    {
        for (const input of this.inputs)
        {
            if (input.connected)
                input.connectedOutput.op.refresh();
        }
    }

    

    isBefore(node)
    {
        if (   !this.output
            || !this.output.connected)
            return false;

        for (const input of output.connectedInputs)
        {
            if (input.op == node)        return true;
            if (input.op.isBefore(node)) return true;
        }

        return false;
    }

    

    isAfter(node)
    {
        if (this.inputs.length == 0)
            return false;

        for (const input of inputs)
        {
            if (input.connectedOutput.op == node)       return true;
            if (input.connectedOutput.op.isAfter(node)) return true;
        }

        return false;
    }
}


class   GOpNumber
extends GOperator
{
    _value;

    _sampled = Number.NaN;


    constructor()
    {
        super('number', 'number');
        this.setOutput(new GOutput(this.dataType));
        this.addParam(this._value = new GNumberParam(''));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        if (isNaN(this._sampled))
            this._sampled = this._value.value;

        this.output._data = 
        {
            nodeId: this.id,
            opType: this.opType,

            value:  this._sampled
        };
    }


    refresh()
    {
        super.refresh();
        
        this._sampled = Number.NaN;
    }
}


class   GOpRandom
extends GOperator
{
    #min;
    #max;
    #scale;
    #seed;

    noise = new Noise();



    constructor()
    {
        super('random', 'number');

        this.setOutput(new GOutput(this.dataType));

        this.addParam(this.#min   = new GNumberParam('min',  0));
        this.addParam(this.#max   = new GNumberParam('max', 10));
        this.addParam(this.#scale = new GNumberParam('scale', 1, 1));
        this.addParam(this.#seed  = new GNumberParam('seed',  1, 1));

        // this.output.addEventListener('connect',    () => genPostMessageToUi({msg: 'uiResetNode', nodeId: this.id}));
        // this.output.addEventListener('disconnect', () => genPostMessageToUi({msg: 'uiResetNode', nodeId: this.id}));
    }



    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);

        if (!!callerInput) this.noise.seed.current = callerInput.currentSeed;
        let rnd = this.noise.next(this.#scale.value);
        if (!!callerInput) callerInput.currentSeed = this.noise.seed.current;
        
        let value = this.#min.value + rnd * (this.#max.value - this.#min.value);

        this.output._data = 
        {
            nodeId: this.id,
            opType: this.opType,

            value:  value
        };    

        this.valid = false;
    }



    reset()
    {
        super.reset();

        this.noise.seed.set(this.#seed.value);
        
        for (const input of this.output.connectedInputs)
        {
            input.initialSeed = input.currentSeed = this.noise.seed.current;
            this.noise.next();
        }
    }
}


class   GOpRect
extends GOperator
{
    #width;
    #height;
    #round;
    


    constructor()
    {
        super('rect', 'object');

        this.setOutput(new GOutput(this.dataType));

        this.addParam(this.#width  = new GNumberParam('width',  100, 0.01));
        this.addParam(this.#height = new GNumberParam('height', 100, 0.01));
        this.addParam(this.#round  = new GNumberParam('round',    0, 0));
    }

    

    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        this.output._data =
        [{
            type:   OBJ_RECT,
            id:     0,
            nodeId: this.id,

            x:      0,
            y:      0,
            width:  this.#width .value,
            height: this.#height.value,
            round:  this.#round .value
        }];
    }
}


class   GOpRow
extends GOperator
{
    #count;
    #gap;


    constructor()
    {
        super('row', 'object');

        this.addInput (new GInput (this.dataType));
        this.setOutput(new GOutput(this.dataType));
        
        this.addParam(this.#count = new GNumberParam('count', 7, 1));
        this.addParam(this.#gap   = new GNumberParam('gap',  10, 0));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        const input = this.inputs[0];

        if (!input.connected)
        {
            this.output._data = [];
            return;
        }


        const data = input.data;

        this.output._data = [];

        for (var i = 0, x = 0; i < this.#count.value; i++)
        {
            const bounds = getObjectBounds(data);
            const gap    = this.#gap.value;

            for (var j = 0; j < data.length; j++)
            {
                const obj = shallowCopy(data[j]);

                obj.id     = this.output._data.length;
                obj.nodeId = this.id;
                
                obj.x += x;

                this.output._data.push(obj);
            }    

            x += bounds.w + gap;

            // as this node duplicates its input, everything like
            // OpNumber upstream that does S&H needs to be refresheds
            this.refresh();
        }
    }
}


class   GOpColumn
extends GOperator
{
    #count;
    #gap;


    constructor()
    {
        super('column', 'object');

        this.addInput (new GInput (this.dataType));
        this.setOutput(new GOutput(this.dataType));
        
        this.addParam(this.#count = new GNumberParam('count', 7, 1));
        this.addParam(this.#gap   = new GNumberParam('gap',  10, 0));
    }


    generate(callerInput)
    {
        if (this.valid) return;
        super.generate(callerInput);


        const input = this.inputs[0];

        if (!input.connected)
        {
            this.output._data = [];
            return;
        }


        const data = input.data;

        this.output._data = [];

        for (var i = 0, y = 0; i < this.#count.value; i++)
        {
            const bounds = getObjectBounds(data);
            const gap    = this.#gap.value;

            for (var j = 0; j < data.length; j++)
            {
                const obj = shallowCopy(data[j]);

                obj[1] = this.output._data.length;
                obj[2] = this.id;
                
                obj[4] += y;

                this.output._data.push(obj);
            }    

            y += bounds.h + gap;

            // as this node duplicates its input, everything like
            // OpNumber upstream that does S&H needs to be refresheds
            this.refresh();
        }
    }
}


const OBJ_RECT = 1;


const genGraph          = new GGraph();
const deletedNodeArrays = []; // array of [id,nodeArray,actionId] tuples



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = function(e)
{
    switch (e.data.msg)
    {
        case 'genCreateNode':      genCreateNode     (e.data.opType,   e.data.nodeId, e.data.nodeId); break; 
        case 'genDeleteNodes':     genDeleteNodes    (e.data.nodeIds,  e.data.uiActionId);            break;             
        case 'genUndeleteNodes':   genUndeleteNodes  (e.data.uiActionId);                             break;             
        case 'genSetNodeId':       genSetNodeId      (e.data.nodeId,   e.data.newId);                 break; 
        case 'genSetActive':       genSetActive      (e.data.nodeId,   e.data.active);                break;  // only state, no regeneration
        case 'genConnect':         genConnect        (e.data.outputId, e.data.inputs);                break; 
        case 'genDisconnect':      genDisconnect     (e.data.input);                                  break;
        case 'genSetParam':        genSetParam       (e.data.nodeId,   e.data.param, e.data.value);   break;
        case 'genInvalidate':      genInvalidate     (e.data.nodeId);                                 break;
        case 'genGenerateObjects': genGenerateObjects(e.data.nodeIds);                                break;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////



function genPostMessageToUi(msg)
{
    postMessage(msg); // this call is too ambiguous to understand when reading code
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function genClearGraph()
{
    genGraph.clear();
}



function genCreateNode(type, id, name)
{
    const node = genGraph.createNode(type, id, name);

    // on the UI side the node has already been created by this point

    genPostMessageToUi({
        msg:     'uiMakeActive',
        nodeIds: [node.id]
    });
}



function genDeleteNodes(nodeIds, uiActionId)
{
    var deleted = genGraph.deleteNodes(nodeIds);
    deletedNodeArrays.push([uiActionId, deleted]);
}



function genUndeleteNodes(uiActionId)
{
    var deleted = deletedNodeArrays.find(n => n[0] == uiActionId);
    var nodeIds = [];


    for (const node of deleted[1])
    {
        genGraph.addNode(node);
        nodeIds.push(node.id);
    }

    
    genPostMessageToUi({ 
        msg:    'uiMakeActive',
        nodeIds: nodeIds
    });

    
    removeFromArray(deletedNodeArrays, deleted);
}



function genSetNodeId(id, newId)
{
    const node = genGraph.nodeFromId(id);
    node.id    = newId;
}



function genSetActive(nodeId, active)
{
    const node  = genGraph.nodeFromId(nodeId);
    node.active = active;
}



function genConnect(outputId, inputs)
{
    const outNode = genGraph.nodeFromId(outputId);

    for (const input of inputs)
    {
        const inNode = genGraph.nodeFromId(input.nodeId);

        genGraph.connect(
            outNode.output, 
            input.index >= 0
            ? inNode.inputs[input.index]
            : inNode.params.find(p => p.name == input.param).input);

        genGenerateObjects([input.nodeId]);
    }
}



function genDisconnect(input)
{
    const node = genGraph.nodeFromId(input.nodeId);
    genGraph.disconnect(node.inputs[input.index]);
}



function genSetParam(nodeId, name, value)
{
    const node  = genGraph.nodeFromId(nodeId);
    const param = node.params.find(p => p.name == name);
    param.value = value;

    const activeId = activeNodeInTree(genGraph.nodes.find(n => n.id == node.id)).id;

    if (activeId > -1)
    {
        genPostMessageToUi({ 
            msg:    'uiGenerateObjects',
            nodeIds: [activeId]
        });
    }

    //genGenerateObjects([activeId]);
}



function genInvalidate(nodeId)
{
    const node = genGraph.nodes.find(n => n.id == nodeId);
    node.valid = false;
}



function genGenerateObjects(nodeIds)
{
    for (const node of genGraph.nodes)
        node.reset();


    // first determine number of objects

    let nObjects = 0;

    for (const nodeId of nodeIds)
    {
        const node = genGraph.nodeFromId(nodeId);
        const data = node.output.getData();
        nObjects  += data.length;
    }    

    
    // now create the objects

    const objects = new Array(nObjects);

    let i = 0;
    for (const nodeId of nodeIds)
    {
        const node = genGraph.nodeFromId(nodeId);
        const data = node.output.getData();
        
        for (const obj of data)
            objects[i++] = obj;
    }    
    
    
    genPostMessageToUi({ 
        msg:    'uiUpdateObjects',
        objects: objects
    });
}



function getObjectBounds(objects)
{
    var boundsL = Number.MAX_SAFE_INTEGER;
    var boundsT = Number.MAX_SAFE_INTEGER;
    var boundsR = Number.MIN_SAFE_INTEGER;
    var boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const obj of objects)
    {
        switch (obj[0])
        {
            case OBJ_RECT:
                boundsL = Math.min(boundsL, obj[3]);
                boundsT = Math.min(boundsT, obj[4]);
                boundsR = Math.max(boundsR, obj[3] + obj[5]);
                boundsB = Math.max(boundsB, obj[4] + obj[6]);
                break;
        }
    }

    return {
        x: boundsL, 
        y: boundsT,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
}


</script>


<script>

////////////////////////////////////////////////////


const objectColor       = '#bee0ff';
const numberColor       = '#ddd';

const activeObjectColor = '#18a0fb';
const activeNumberColor = '#787878';

const inputColor        = 'rgba(0, 0, 0, 0.12)';

const smallScrollGap =  6;
const largeScrollGap = 14;


const R = 0, G = 1, B = 2, A = 3;
const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function getDigitCount(i)
{
    var l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigit(key)
{
    var is = 
           key >= '0' 
        && key <= '9';

    return is;
}



function isHexLetter(key)
{
    var is =
           key.length == 1
        && (   key >= 'A' && key <= 'F'
            || key >= 'a' && key <= 'f');

    return is;
}



function getNumberString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (i < str.length && str[i] !== '.' && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
    str = str.substring(0, i--);
    
    if (   str[i] === '.' 
        || str[i] === ',') // hack because JavaScript
        str = str.substring(0, i--);
    
    return str;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (index > -1)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    var last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function capitalize(str)
{
    var cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    var str = '';

    for (var i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (var i = 0; i < vars.length; i++) 
    {
        var pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618


function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return { 
        x: dist * Math.cos(angle), 
        y: dist * Math.sin(angle) };
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return { x: v.x == 0 ? 0 : v.x / lengthv(v),
             y: v.y == 0 ? 0 : v.y / lengthv(v) };
}



function addv(v1, v2)
{
    return { x: v1.x + v2.x,
             y: v1.y + v2.y };
}	



function subv(v1, v2)
{
    return { x: v1.x - v2.x,
             y: v1.y - v2.y };
}	



function mulv(v1, v2)
{
    return { x: v1.x * v2.x,
             y: v1.y * v2.y };
}	



function mulvs(v, s)
{
    return { x: v.x * s,
             y: v.y * s };
}	



function divvs(v, s)
{
    return { x: v.x / s,
             y: v.y / s };
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return { x:  v.y, 
             y: -v.x };
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1×v2 = ‖v1‖‖v2‖sinθ "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 2×2 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        {x:x1, y:y1}, 
        {x:x2, y:y2} ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return {x:NaN, y:NaN}; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return {x:NaN, y:NaN}; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return {x:NaN, y:NaN};
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}


function mulv2m3(v, m)
{
    var r = [0, 0, 0];

    for (var i = 0; i < 3; i++)
    {
        // calculate the dot product of the ith row of m and v
        for (var j = 0; j < 3; j++)
            r[i] += m[i][j] * v[j];
    }

    return {x: r[0], y: r[1]};
}


function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}


function transform(p, xform)
{
    return mulv2m3(p, xform);
}


function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}


function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



var bigBuffer = new Uint8Array(2048);



// function bigPower(a, n, p)
// {
//     var res = 1n;

//     a %= p; // update a if a >= p
 
//     while (n > 0n)
//     {
//         // if n is odd, multiply a by result
//         if (n & 1n)
//             res = (res*a) % p;
 
//         // n must be even now    
//         n >>= 1n;
//         a = (a*a) % p;
//     }    

//     return res;
// }    



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



// multiply BigInt by float 0 <= f <=1
// function bigMult(n, f)
// {
//     var mult = 100000000000000000000000000; // this is the float "precision"
    
//     return n*BigInt(mult) 
//          * BigInt(Math.floor(f*mult))
//          / sqr(BigInt(mult));
// }            



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



// function bigModInvert(n, m)
// {
//     for (var i = 1n; i < BigInt(m); i++)
//         if ((((n % m) * (i % m)) % m) == n)
//             return i;
// }



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}



// function bigModInvert(u, v)
// {
//    var inv, u1, u3, v1, v3, t1, t3, q;
//    var iter;


//    /* Step X1. Initialise */
   
//    u1 = 1n;
//    u3 = u;
//    v1 = 0n;
//    v3 = v;
   

//    /* Remember odd/even iterations */
   
//    iter = 1n;

   
//    /* Step X2. Loop while v3 != 0 */
  
//    while (v3 != 0n)
//    {
//        /* Step X3. Divide and "Subtract" */
//        q  = u3 / v3;
//        t3 = u3 % v3;
//        t1 = u1 + q * v1;

//        /* Swap */
//        u1 = v1; v1 = t1; 
//        u3 = v3; v3 = t3;

//        iter = -iter;
//    }


//    /* Make sure u3 = gcd(u,v) == 1 */
 
//    if (u3 != 1n)
//        return 0n;   /* Error: No inverse exists */


//     /* Ensure a positive result */
//     if (iter < 0n)
//         inv = v - u1;
//     else
//         inv = u1;
//     return inv;
// }


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;

    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return {x: this.l, y: this.t}; }
    get tc() { return {x: this.c, y: this.t}; }
    get tr() { return {x: this.r, y: this.t}; }
    get ml() { return {x: this.l, y: this.m}; }
    get mc() { return {x: this.c, y: this.m}; }
    get cm() { return {x: this.c, y: this.m}; }
    get mr() { return {x: this.r, y: this.m}; }
    get bl() { return {x: this.l, y: this.b}; }
    get bc() { return {x: this.c, y: this.b}; }
    get br() { return {x: this.r, y: this.b}; }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }


    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }

    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }

    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }

	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}

    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }

    expandFromRect(rect)
    {
        if (rect.isNaN  ) return this;
        if (rect.isEmpty) return this;

        if (this.isNaN  ) this.assign(rect);
        if (this.isEmpty) return rect;
        
        const newRect = new AbsRect(
            Math.min(this.t, rect.t),
            Math.min(this.l, rect.l),
            Math.max(this.b, rect.b),
            Math.max(this.r, rect.r));

        this.assign(newRect);
    }
}


class   AbsRect
extends Rect
{
    constructor(t, l, b, r)
    {
        super(l, t, r-l, b-t);
    }
}


function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function removeFromArray(array, obj)
{
    var index = array.indexOf(obj);
    
    if (index > -1)
        array.splice(index, 1);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyle(rgb)
{
    return colorStyle_(rgb[R], rgb[G], rgb[B], 1);
}



function numToString(num, dec)
{
    var str = Number(num).toFixed(dec).toString();

    var i = 0;

    // find decimal place

    while (   i < str.length 
           && str[i] !== '.' 
           && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

    i = str.length-1;

    while (i >= 0 && str[i] === '0')
        str = str.substring(0, i--);

    if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
        str = str.substring(0, i--);

    return str;
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign({}, obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element) { element.style.visibility = 'visible'; }
function hide(element) { element.style.visibility = 'hidden'; }



function colorFromDataType(dataType, active)
{
    switch (dataType)
    {
        case 'object': return active ? activeObjectColor : objectColor;
        case 'number': return active ? activeNumberColor : numberColor;
    }

    return 'magenta';
}



function position(e)
{
    return {
        x: e.clientX,
        y: e.clientY
    };
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function logVar(x)
{
    console.log(
        Object.keys  (x)[0] + ' =', 
        Object.values(x)[0]);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj, null).getPropertyValue(style);
}


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function uiLoadState(state)
{
    uiResizeWindow(
        window.innerWidth, 
        state.windowHeight);
}    



function uiSetPluginData(key, value)
{
    uiPostMessageToFigma({ 
        cmd:  'figSetPluginData', 
        key:   key,
        value: value
    });
}



function uiSaveLocal(key, value)
{
    uiPostMessageToFigma({ 
        cmd:  'figSaveLocal', 
        key:   key,
        value: value
    });
}



// function uiSaveState()
// {
//     uiSetPluginData('state',
//     {
//         //windowHeight: window.innerHeight
//     });
// }


const cryptoModulusSize     = 64; // to keep the keys short
const millerRabinIterations = 40;

const cryptoBufferSize      = cryptoModulusSize/8;
const cryptoPrimeBufferSize = cryptoBufferSize /2;
     
const cryptoBuffer          = new Uint8Array(cryptoPrimeBufferSize);


function bigCryptoRandom()
{
    for (var i = 0; i < cryptoPrimeBufferSize; i++)
        cryptoBuffer[i] = toInt(Math.random() * 0x100);

    cryptoBuffer[0]                       |= 0xC0; // set the top bit to ensure a relatively large number
    cryptoBuffer[cryptoPrimeBufferSize-1] |= 0x01; // set low bit to ensure the number is odd

    return bigFromBuffer(cryptoBuffer);
}



function bigNextCryptoPrime(n) 
{
    while (!bigIsPrime(n))
        n += 2n;
    
    return n;
}



function bigCryptoPrime(e)
{
    // set p so that gcd(e, p-1) = 1
    
    var p;

    do
    {
        var rnd = bigCryptoRandom();
        p       = bigNextCryptoPrime(rnd);
    }
    while (gcd(p-1n, e) != 1n); 
        
    return p;
}



function createCryptoKeys()
{
    var e = 65537n; // 0x10001


    // var p = bigCryptoPrime(e);
    
    // var q;
    // do { q = bigCryptoPrime(e); } 
    // while (q == p);

    
    // if (p < q)
    //     [p,q] = [q,p];

    
    // console.log('p: ' + p);
    // console.log('q: ' + q);


    var p = 4131437551n,
        q = 3567532051n;
    

    var n   = p * q;
    var phi = (p-1n) * (q-1n);

    var d = bigModInvert(e, phi);


    return {
        public:  {n:n, e:e },
        private: {n:n, d:d, p:p, q:q} };
}                        



function encryptBlock(n, key, sign  ) { return bigPowMod(n, (sign   ? key.d : key.e), key.n); }        
function decryptBlock(n, key, verify) { return bigPowMod(n, (verify ? key.e : key.d), key.n); }        



function encrypt(data, key) { return encryptData(data, key, false); }
function decrypt(data, key) { return decryptData(data, key, false); }

function sign   (data, key) { return encryptData(data, key, true); } // yes I know real sign/verify uses a hash,
function verify (data, key) { return decryptData(data, key, true); } // but I prefer it this way for what I need



function encryptData(data, key, sign)
{
    // prep array should be a multiple of cryptoBufferSize
    var prep   = new Uint8Array(Math.ceil((data.length) / cryptoBufferSize) * cryptoBufferSize); 
    var cipher = new Uint8Array(prep.length);


    var start = prep.length - data.length;
    for (var i = 0; i < data.length; i++)
        prep[start+i] = data[i];


    var length = prep.length;
    var nBlock = 0;

    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);
        
        var block = bigFromBufferAt(prep, blockStart, cryptoBufferSize);
        var enc   = encryptBlock(block, key, sign);
        bigToBufferAt(enc, cipher, blockStart, cryptoBufferSize);
        
        nBlock++;
        length -= blockSize;
    }
    
    
    return cipher;
}



function decryptData(cipher, key, verify)
{
    var data = new Uint8Array(cipher.length);
    
    
    var length = cipher.length;
    var nBlock = 0;
    
    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);

        var block = bigFromBufferAt(cipher, blockStart, cryptoBufferSize);
        var dec   = decryptBlock(block, key, verify);
        bigToBufferAt(dec, data, blockStart, cryptoBufferSize); 

        nBlock++;
        length -= blockSize;
    }    


    return data;    
}


const base32chars = '12345679ABCDEFGHJKLMNPQRSTUVWXYZ';



function arrayToBase32(array, chars = base32chars)
{
    var base32 = '';

    
    var len = array.length;
    var i   = 0;

    while (len > 0)
    {
        if (len >= 5)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3],
                a4 = array[i+4];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[(a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) << 3) | ((a4 & 0xE0) >>> 5)];
            base32 += chars[(a4 & 0x1F)];
        }
        else if (len == 4)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[(a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) << 3)];
        }
        else if (len == 3)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) << 1)];
        }
        else if (len == 2)
        {
            var a0 = array[i  ],
                a1 = array[i+1];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[(a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) << 4)];
        }
        else if (len == 1)
        {
            var a0 = array[i];
            
            base32 += chars[(a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) << 2)];
        }


        i   += 5;
        len -= 5;
    }


    return base32;
}



function base32toArray(base32, chars = base32chars)
{
    var array = [];


    var len = base32.length;
    var c   = 0;

    while (len > 0)
    {
        if (len >= 8)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]),
                c7 = chars.indexOf(base32[c+7]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
            array.push(((c6 & 0x07) << 5) | c7);
        }
        else if (len == 7)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
        }
        else if (len == 5)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
        }
        else if (len == 4)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
        }
        else if (len == 2)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
        }


        c   += 8;
        len -= 8;
    }


    return array;
}


const licenseKeys     = createCryptoKeys();
const licenseHashSize = 4;



function createProductKey(name)
{
    var hash = hashLicenseName(name, licenseHashSize);
    var enc  = sign(hash, licenseKeys.private);
    var key  = arrayToBase32(enc);

    return key;
}



function validateProductKey(name, key, rec = false)
{
    var arr  = base32toArray(key.toUpperCase());
    var dec  = verify(arr, licenseKeys.public).subarray(licenseHashSize);
    var trim = dec.subarray(dec.length - licenseHashSize);
    var hash = hashLicenseName(name, licenseHashSize);
    
    var valid = arraysEqual(trim, hash);

    if (valid && !rec)
    {
        var lowerKey  = key;

        var lastChar  = lowerKey[lowerKey.length-1];
        var lastIndex = base32chars.indexOf(lastChar);

        if (lastIndex > 0)
        {
            lowerKey = replaceInStringAt(lowerKey, lowerKey.length-1, base32chars[lastIndex-1]);

            if (validateProductKey(name, lowerKey, true))
                return false; // at this scale of product key the last bit needs to be guarded against
        }
    }

    return valid;
}



function hashLicenseName(name, nBytes)
{
    name = name.trim();


    var bytes = stringToArray(name);

    if (bytes.length > nBytes)
    {
        var pos    = nBytes;
        var length = bytes.length - nBytes;
        
        while (length > 0)
        {
            for (var i = 0; i < nBytes; i++)
                bytes[i] ^= bytes[pos+i];
            
            pos    += nBytes;
            length -= nBytes;
        }
    }
    

    return newSizeArrayFrom(bytes, nBytes);
}


var productKey = '';



function showProductKeyDialog()
{
    productKeyBack  .style.display = 'block';
    productKeyDialog.style.display = 'block';

    productKeyUserInfo.innerHTML = '<span style="user-select: none; color: #aaa;">User ID: </span>' + currentUser.id;

    setDefaultProductKeyInput();
    productKeyInputBack.innerHTML = '•'.repeat(13);
    productKeyInput.value = '';
    
    menuSelect.setSelectedIndex(0);
    
    window.setTimeout(() => document.getElementById('productKeyInput').focus(), 0);
}



function hideProductKeyDialog()
{
    productKeyBack  .style.display = 'none';
    productKeyDialog.style.display = 'none';
}



productKeyBack.addEventListener('pointerdown', () =>
{
    hideProductKeyDialog();
});



productKeyInput.addEventListener('input', () =>
{
    let val = productKeyInput.value;
    
    val = val.toUpperCase();
    val = val.replace(/[^12345679ABCDEFGHJKLMNPQRSTUVWXYZ]/g, '');
    val = val.substring(0, Math.min(val.length, 13));
    
    productKeyInput.value = val;

    productKeyInputBack.innerHTML = 
          '&nbsp;'.repeat(val.length)
        + '•'.repeat(13 - val.length);

    
    if (val.length == 13)
    {
        if (validateProductKey(currentUser.id, val))
        {
            productKey = val;        
            uiSaveLocal('productKey', productKey);
            
            productKeyInput.blur();
            setGoodProductKeyInput();
            
            window.setTimeout(() => 
            {
                hideProductKeyDialog();
                updateMenuSelectItems();
                uiNotify('✨ Thank you for subscribing to Generator! ✨', '', 6000);    
            }, 
            1200);
        }
        else
            setBadProductKeyInput();
    }
    else
        setDefaultProductKeyInput();
});



function setBadProductKeyInput()
{
    productKeyInput.style.outline   = '2px dashed #e00';        
    productKeyInput.style.boxShadow = 'none';
}



function setGoodProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px #0b0';
}



function setDefaultProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px #18A0FB'; 
}


class UParameter
{
    #type;
    get type() { return this.#type; }
    
    #name;
    get name() { return this.#name; }


    _operator; get operator() { return this._operator; }
    _control;  get control()  { return this._control;  }
    _div;      get div()      { return this._div;      }


    
    constructor(name, type)
    {
        this.#type = type;
        this.#name = name;

        this._div = document.createElement('div');

        this.div.style.position = 'relative';
        this.div.style.padding  = 0;
        this.div.style.width    = '100%';
    }



    isDefault() { return false; }


    
    save(nTab) {}
}


class   UNumberParam
extends UParameter
{
    defaultValue;
    
    
    get value()      { return this._control.value;    }
    set value(value) { this._control.setValue(value); }
    
    get oldValue()   { return this._control.oldValue; }

    
    setValue(value, fireChangeEvent = true, confirm = true) 
    { 
        this._control.setValue(value, fireChangeEvent, confirm); 
    }


    input; 

    

    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    constructor(name, 
                value     = 0, 
                min       = Number.MIN_SAFE_INTEGER, 
                max       = Number.MAX_SAFE_INTEGER,
                decimals  = 0,
                dragScale = 0.01)
    {
        super(name, 'number');

        this._control = document.createElement('div');
        this.control.param  = this;
        this.control.zIndex = 0;

        this.defaultValue = value;

        initSlider(
            this.control,
            100,       // width
            20,        // height
            this.name, 
            min,
            max,
            value,     // default
            dragScale, // drag scale
            1,         // wheel step
            decimals,  // decimals
            0,         // acceleration
            '');       // suffix

        this.div.appendChild(this.control);

        this.input = new UInput('number');
        this.input._param = this;
        this.input.control.style.float     = 'left';
        this.input.control.style.position  = 'absolute';
        this.input.control.style.top       = '50%';
        this.input.control.style.transform = 'translateY(-50%)';
        this.div.appendChild(this.input.control);



        this.control.addEventListener('change', e =>
        {
            this.op.valid = false;
            uiSetParam(this, this.value);
        });



        this.control.addEventListener('confirm', e =>
        {
            this.op.valid = false;
            actionManager.do(new SetValueAction(this, this.value));
        });



        this.input.addEventListener('connect', e =>
        {
            this.control.style.fontStyle = 'italic';
            this.control.inputConnected  = true;
        });


        
        this.input.addEventListener('disconnect', e =>
        {
            this.control.style.fontStyle = 'normal';
            this.control.inputConnected  = false;
        });
    }



    isDefault()
    {
        return this.value == this.defaultValue;
    }



    save(nTab)
    {
        let pos = ' '.repeat(nTab);
        return pos + '"' + this.name  + '": "' + this.value + '"';
    }
}


class UGraph
{
    name         = 'Untitled';
    nodes        = [];
           
    mutex        = false;

    deferNodeIds = [];


    
    clear()
    {
        this.notes = [];
    }



    getNewNodeName(_node)
    {
        let opType = _node.opType;

        let maxNum = 0;
        
        for (const node of this.nodes)
        {
            if (node == _node)
                continue;
                
            if (   node.name.length < opType.length
                || node.name.substring(0, opType.length) !== opType)
                continue;
                
            let num = parseInt(node.name.substring(opType.length));
            
            if (isNaN(num) || num == 0) 
                num = 1;
            
            maxNum = Math.max(num, maxNum);
        }

        // if (maxNum == 0)
        //     return opType;

        maxNum++;

        return opType + maxNum;
    }
    
    

    createNode(opType, createdNodeId = -1)
    {
        let node;

        switch (opType)
        {
            case 'number': node = new UOpNumber(); break;
            case 'random': node = new UOpRandom(); break;
            case 'rect':   node = new UOpRect();   break;
            case 'row':    node = new UOpRow();    break;
            case 'column': node = new UOpColumn(); break;
            //case 'spread': node = new UOpSpread(); break;
        }
        
        if (createdNodeId > -1)
        {
            UOperator.nextId--;
            node.id = createdNodeId;
        }
        
        this.addNode(node);

        return node;
    }



    addNode(node)
    {
        node.graph = this;
        node.setId(this.getNewNodeName(node)); // TODO: not checking return value here
            
        if (this.nodes.length > 0)
        {
            const bounds = graphView.getNodeBounds();

            bounds.x /= graphView.zoom;
            bounds.y /= graphView.zoom;
            bounds.w /= graphView.zoom;
            bounds.h /= graphView.zoom;

            this.nodes.push(node);
            graphView.appendChild(node.div);

            const gap = 30;
            node.div.style.left = bounds.x + bounds.w + gap;
            node.div.style.top  = bounds.y;
        }
        else // 0
        {
            this.nodes.push(node);
            graphView.appendChild(node.div);

            node.div.style.zIndex = uiGraph.nodes.length-1;
            node.div.style.left = 100;

            // I subtract the full height of the node here as they grow down, so this
            // gives a nice random-ish offset for the first line of nodes
            node.div.style.top = graphView.offsetHeight/2 - node.div.offsetHeight;
        }

        graphView.putNodeOnTop(node);
        graphView.updateScroll();
    }
    

    
    deleteNodes(nodeIds)
    {
        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            for (const input of node.inputs)
            {
                if (!input.connected) continue;

                input.connectedOutput.op.makeActive();
                this.disconnect(input, true);
            }
            
            if (!!node.output)
            {
                for (const input of node.output.connectedInputs)
                {
                    this.disconnect(input, true);
                    
                    if (!activeNodeInTree(input.op))
                    input.op.lastNodeInTree.makeActive();
                }
            }
            
            node.selected = false;
            node.graph    = null;

            removeFromArray(this.nodes, node);
            graphView.removeChild(node.div);
        }

        graphView.updateScroll();
    }



    connect(output, input)
    {
        if (input.connectedOutput == output)
            return false;
            
        if (input.connectedOutput != null)
            this.disconnect(input);

        output.connectedInputs.push(input);
        input .connectedOutput = output;

        const conn = new UConnection(output, input);

        input .connection = conn;
        output.connection = conn;
        
        graphView.addWire(conn.wire);

        output.op.makePassive();
        
        //invalidate(input.op);
    
        if (!activeNodeInTree(input.op))
            input.op.makeActive();
            
        output.op.updateConnectedInputValueText();
        conn.wire.style.zIndex = Number.MAX_SAFE_INTEGER;

        return true;
    }



    disconnect(input)//, deletingOutput = false)
    {
        // first remove the current output

        //if (input.op)
        if (!!activeNodeInTree(input.op))
            uiDeleteNodeObjects([activeNodeInTree(input.op).id]);

        // then disconnect

        var output = input.connectedOutput;
        if (!output) return false;

        graphView.removeWire(input.connection.wire);

        removeFromArray(output.connectedInputs, input);
        
        input .connection     = null;
        output.connection     = null;

        input.connectedOutput = null;

        if (input.param)
            input.param.valueText = '';


        // invalidate(input.op);
        // invalidate(output.op);

        if (!activeNodeInTree(output.op))
           // && !deletingOutput)
             output.op.makeActive();
            
        return true;
    }



    nodeFromId(id)
    {
        return this.nodes.find(n => n.id == id);
    }



    save()
    {
        const tab = '  ';

        let save = 
              '{\n'
            + tab + '"name" : "' + this.name       + '",\n'
            + tab + '"zoom" : "' + graphView.zoom  + '",\n'
            + tab + '"pan-x": "' + graphView.pan.x + '",\n'
            + tab + '"pan-y": "' + graphView.pan.y + '",\n'
            + tab + '"nodes":\n'
            + tab + '[';
            

        for (let i = 0; i < this.nodes.length; i++)
        {
            save += '\n' + this.nodes[i].save(4);
            
            if (i < this.nodes.length-1)
                save += ',';
        }
        

        save += 
              '\n' + 
              tab + '],\n'
            + tab + '"connections":\n'
            + tab + '[';

            
        for (let i = 0; i < this.nodes.length; i++)
        {
            let node = this.nodes[i];

            for (let j = 0; j < node.inputs.length; j++)
            {
                if (!node.inputs[j].connected)
                    continue;

                save += '\n' + node.inputs[j].connection.save(4);
                
                if (i < node.inputs.length-1)
                    save += ',';
            }
        }
        

        save += 
                '\n' + 
                tab + ']\n'
            + '}';


        return save;
    }
}


class   UInput
extends EventTarget
{
    #dataType;     
    get dataType() { return this.#dataType; }

    get data()
    {
        return (
            this.connected
            ? this.connectedOutput.data
            : null);
    }


    _op    = null; get op   () { return this._op;    }
    _param = null; get param() { return this._param; }

    control;
  

    _connectedOutput = null;
    get connectedOutput() { return this._connectedOutput; }
    set connectedOutput(output)
    {
        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'disconnect', 
                { 'input': this }));
        }

        this._connectedOutput = output;

        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'connect', 
                { 
                    'output': output,
                    'input':  this 
                }));
        }
    }


    connection      = null;
    
    connecting      = false;
    
    initialSeed     = 0;
    currentSeed     = 0;

    get connected() { return this.connectedOutput != null; }


    onconnect    = new Event('connect');
    ondisconnect = new Event('disconnect');


    constructor(dataType)
    {
        super();
        
        this.#dataType = dataType;

        this.control = document.createElement('div');
        this.control.className = 'input';
        this.control.input = this;
    
        this.control.addEventListener('pointerdown', e => e.preventDefault());

        this.control.addEventListener('pointerenter', e => 
        {
            graphView.overInput = this;
            e.target.style.boxShadow = '0 0 0 1px ' + colorFromDataType(e.target.input.dataType, true);
        });

        this.control.addEventListener('pointerleave', e => 
        {
            graphView.overInput = null;
            e.target.style.boxShadow = '0 0 0 1px ' + inputColor;
        });
    }



    save()
    {
        let save = this.op.name;

        if (this.op.param != null)
            save += '.' + this.op.param.name;

        return save;
    }
}


class UOutput
{
    #dataType;     
    get dataType() { return this.#dataType; }

    _op = null; get op() { return this._op; }
    
    
    _data = {};
    get data() 
    {
        if (!this.op.valid)
            this.op.generate();

        return this._data;
    }


    control;
    
    connectedInputs = [];
    
    connecting      = false;
    
    get connected() { return this.connectedInputs.length > 0; }



    constructor(dataType)
    {
        this.#dataType = dataType;
        
        this.control = document.createElement('div');
        this.control.className = 'output';
        this.control.output    = this;



        this.control.addEventListener('pointerenter', e => 
        {
            graphView.overOutput = this;
            e.target.style.boxShadow = '0 0 0 1px ' + colorFromDataType(e.target.output.dataType, true);
        });



        this.control.addEventListener('pointerleave', e => 
        {
            graphView.overOutput = null;
            e.target.style.boxShadow = '0 0 0 1px ' + inputColor;
        });
    }



    save()
    {
        return this.op.name;
    }
}


class UConnection
{
    output;
    input;

    savedInput = null;

    wire;


    constructor(output, input)
    {
        this.output = output;
        this.input  = input;

        this.wire = createSvg('svg');
        this.wire.style.position = 'absolute';
        this.wire.style.left     = 0;
        this.wire.style.top      = 0;
        this.wire.style.width    = '100%';
        this.wire.style.height   = '100vh';
        this.wire.scale          = 1;

        this.wire.curve = createSvg('path');
        this.wire.curve.style.fill        = 'none';
        //this.wire.curve.style.stroke    = '#18A0FB';
        this.wire.curve.style.strokeWidth = 1.2 * this.wire.scale;
        this.wire.curve.style.position    = 'absolute';
        this.wire.appendChild(this.wire.curve);

        this.wire.outBall = createSvg('circle');
        //this.wire.outBall.style.fill   = '#18A0FB';
        this.wire.outBall.style.position = 'absolute';
        this.wire.outBall.style.r        = 3 * this.wire.scale;

        this.wire.inBall = createSvg('circle');
        //this.wire.inBall.style.fill   = '#18A0FB';
        this.wire.inBall.style.position = 'absolute';
        this.wire.inBall.style.r        = 3 * this.wire.scale;

        this.wire.appendChild(this.wire.curve);
        this.wire.appendChild(this.wire.outBall);
        this.wire.appendChild(this.wire.inBall);



        this.wire.update = () =>
        {
            let outRect = this.output.control.getBoundingClientRect();
            let inRect  = this.input .control.getBoundingClientRect();


            let x1 = (outRect.left + outRect.width /2) / graphView.zoom;
            let y1 = (outRect.top  + outRect.height/2) / graphView.zoom;
            let x2 = (inRect .left + inRect .width /2) / graphView.zoom;
            let y2 = (inRect .top  + inRect .height/2) / graphView.zoom;

            y1 -= 40 / graphView.zoom;
            y2 -= 40 / graphView.zoom;


            let color;
            
            switch (this.output.dataType)
            {
                case 'object': color = activeObjectColor; break;
                case 'number': color = activeNumberColor; break;
            }


            this.wire.updateCurve  (x1, y1, x2, y2);
            this.wire.updateOutBall(x1, y1        );
            this.wire.updateInBall (        x2, y2);
            this.wire.updateStyle(color);


            show(this.wire.outBall);
            show(this.wire.inBall);
        };



        this.wire.updateFromOutput = (x, y) =>
        {
            let outRect = this.output.control.getBoundingClientRect();

            let x1 = outRect.left + outRect.width /2;
            let y1 = outRect.top  + outRect.height/2;

            y1 -= 40;
            y  -= 40;

            this.wire.updateCurve  (x1, y1, x, y);
            this.wire.updateOutBall(x1, y1      );
            this.wire.updateStyle(colorFromDataType(this.output.dataType, true));

            hide(this.wire.inBall);
        };



        this.wire.updateFromInput = (x, y) =>
        {
            let inRect = this.input.control.getBoundingClientRect();

            let x2 = inRect.left + inRect.width /2;
            let y2 = inRect.top  + inRect.height/2;

            y  -= 40;
            y2 -= 40;

            this.wire.updateCurve (x, y, x2, y2);
            this.wire.updateInBall(      x2, y2);
            this.wire.updateStyle(colorFromDataType(this.input.dataType, true));

            hide(this.wire.outBall);
        };



        this.wire.updateCurve = (x1, y1, x2, y2) =>
        {
            this.wire.curve.setAttribute('d',
                   'M ' +  (x1                ) + ',' + y1
                + ' C ' +  (x1 + (x2 - x1)*2/5) + ',' + y1
                + ' '   +  (x1 + (x2 - x1)*3/5) + ',' + y2
                + ' '   +  (x2                ) + ',' + y2);
        };



        this.wire.updateOutBall = (x, y) =>
        {
            this.wire.outBall.setAttribute('cx', x);
            this.wire.outBall.setAttribute('cy', y);
        };



        this.wire.updateInBall = (x, y) =>
        {
            this.wire.inBall.setAttribute('cx', x);
            this.wire.inBall.setAttribute('cy', y);
        };



        this.wire.updateStyle = (color) =>
        {
            this.wire.curve  .style.stroke = color;
            this.wire. inBall.style.fill   = color;
            this.wire.outBall.style.fill   = color;

            this.wire.curve  .style.strokeWidth = 1.2 * this.wire.scale;
            this.wire. inBall.style.r           = 3   * this.wire.scale;
            this.wire.outBall.style.r           = 3   * this.wire.scale;
        };
    }



    save(nTab) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';
        
        let save = 
              pos + '{\n'
            + pos + tab + '"output": "' + this.output.save() + '",\n'
            + pos + tab + '"input" : "'  + this.input .save() + '"\n'
            + pos + '}';

        return save;
    }
}


function activeNodeInTree(node) 
{ 
    const left  = getActiveNodeLeft(node);  if (!!left ) return left;
    const right = getActiveNodeRight(node); if (!!right) return right;

    return null;
}



function getActiveNodeLeft(node)
{
    if (node.active) return node;

    for (const input of node.inputs)
    {
        if (input.connected)
        {
            const left = getActiveNodeLeft(input.connectedOutput.op);
            if (left) return left;
        }
    }

    return null;
}



function getActiveNodeRight(node)
{
    if (node.active) return node;

    if (!!node.output)
    {
        for (const input of node.output.connectedInputs)
        {
            const right = getActiveNodeRight(input.op);
            if (right) return right;
        }
    }

    return null;
}



function lastNodeInTree(node) 
{ 
    const right = getLastNodeRight(node); 
    return !!right ? right : null;
}



function getLastNodeRight(node)
{
    var right = null;

    if (!!node.output)
    {
        for (const input of node.output.connectedInputs)
        {
            const _right = getLastNodeRight(input.op);
            if (_right && !!right) return node;
            right = _right;
        }
    }

    return !!right ? right : node;
}


/*
    data types:
        OBJ
        number
*/

class UOperator
{
    #opType;
    get opType() { return this.#opType; }
    
    #dataType;
    get dataType() { return this.#dataType; }

    _name;
    get name() { return this._name; }
    set name(name)
    {
        this._name = name;
        this.label.innerHTML = name;
    }
    

    static nextId = 0;
    id = UOperator.nextId++;


    graph = null;
    
    
    params = [];
    
    inputs = [];
    output = null;
    

    //#valid = false; // this is the flag for regeneration



    _selected;
    get selected() { return this._selected; }
    set selected(sel) 
    {
        if (this._selected)
            removeFromArray(graphView.selected, this);

        this.setSelected(sel); 

        if (this._selected)
            graphView.selected.push(this);
    }



    setSelected(sel)
    {
        this._selected = sel;

        this.div.style.boxShadow = 
            this._selected
            ? '0 0 0 2px ' + activeObjectColor
            : 'none';
    }
    


    _active = false;
    get active() { return this._active; }



    makeActive() // only true
    {
        this.makeLeftPassive();
        this.makeRightPassive();        

        this._active = true;
        uiSetActive(this, true);

        this.header.style.backgroundColor = this.activeColor;
        this.header.style.boxShadow       = 'none';
        this.label .style.color           = this.dataType == 'object' ? 'white' : 'black';
        
        if (this.dataType == 'object')
            uiGenerateObjects([this.id]);
    }
        
    

    makeLeftPassive()
    {
        for (const input of this.inputs)
        {
            if (input.connected)
            {
                input.connectedOutput.op.makePassive();
                input.connectedOutput.op.makeLeftPassive();            
            }
        }
    }
    


    makeRightPassive()
    {
        if (this.output)
        {
            for (const input of this.output.connectedInputs)
            {
                input.op.makePassive();
                input.op.makeRightPassive();            
            }
        }
    }
    


    makePassive()
    {
        if (this.active)
        {
            this.header.style.backgroundColor = this.passiveColor;
            this.header.style.boxShadow       = '0 0 0 1px #0001 inset';
            this.label .style.color           = 'black';

            uiDeleteNodeObjects([this.id]);
        }

        this._active = false;
        uiSetActive(this, false);
    }



    // set valid(val) { this.#valid = val; }
    // get valid() 
    // {
    //     var valid = this.#valid;
        
    //     for (const input of this.inputs)
    //     {
    //         if (input.connected)
    //             valid &= input.connectedOutput.op.valid;
    //     }

    //     return valid;
    // }


    get activeColor()
    {
        switch (this.#dataType)
        {
            case 'object': return activeObjectColor;
            case 'number': return numberColor; //activeNumberColor;
        }

        return 'magenta';
    }

    get passiveColor()
    {
        switch (this.#dataType)
        {
            case 'object': return objectColor;
            case 'number': return numberColor;
        }

        return 'magenta';
    }



    div;
    inner;
    header;
    label;
    inputControls;
    outputControls;



    constructor(opType, dataType)
    {
        this.#opType   = opType;   // this is the operator type
        this.#dataType = dataType; // this is the op's main data type

        this._name = opType; // this is a temp until the op becomes a graph node
        
        var headerColor = colorFromDataType(dataType, false);
        createNode(this, headerColor);
    }    
    
    

    addInput(input)
    {
        input._op = this;
        this.inputs.push(input);
        this.inputControls.appendChild(input.control);
    }



    setOutput(output)
    {
        if (this.output != null)
        {
            this.outputControls.removeChild(this.output.control);
            this.output._op = null;
        }

        output._op = this;
        this.output = output;
        this.outputControls.appendChild(output.control);
    }



    addParam(param)
    {
        this.params.push(param);
        
        param._op = this;

        param.input._op = this;
        this.inputs.push(param.input);
        
        param.control.style.display = 'inline-block';
        
        this.inner.appendChild(param.div);
    }
 
    

    setId(newId)
    {
        if (this.graph.nodes.find(node => node.id == newId))
            return false; // graph already contains a node with this id

        this._name = newId;
        this.label.innerHTML = this.id + ': ' + newId;

        return true;
    }



    generate() 
    { 
        this.valid = true; 
    }



    isBefore(node)
    {
        if (   !this.output
            || !this.output.connected)
            return false;

        for (const input of output.connectedInputs)
        {
            if (input.op == node)        return true;
            if (input.op.isBefore(node)) return true;
        }

        return false;
    }



    isAfter(node)
    {
        if (this.inputs.length == 0)
            return false;

        for (const input of inputs)
        {
            if (input.connectedOutput.op == node)       return true;
            if (input.connectedOutput.op.isAfter(node)) return true;
        }

        return false;
    }

    

    updateConnectedInputValueText() {}



    save(nTab) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = '  ';
        
        let save = 
              pos + '{\n'
            + pos + tab + '"type": "' + this.opType         + '",\n'
            + pos + tab + '"name": "' + this.name           + '",\n'
            + pos + tab + '"x"   : "' + this.div.style.left + '",\n'
            + pos + tab + '"y"   : "' + this.div.style.top  + '"';
        
        for (const param of this.params)
        {
            if (!param.isDefault())
                save += ',\n' + param.save(nTab + 2);
        }

        save += '\n' + pos + '}';

        return save;
    }
}


function createNode(node, headerColor)
{
    node.div = document.createElement('div');

    node.div.className = 'node';
    node.div.op        = node;
    
    node.div.selectedSet = false;
    node.div.dragging    = false;
    node.div.moved       = false;

    node.inner           = document.createElement('div');
    node.inner.className = 'nodeInner';

    node.div.appendChild(node.inner);



    node.div.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.zoomSelecting
            && !graphView.spaceDown)
            e.target.op.inner.style.boxShadow = '0px 5px 20px #0001, 0 0 0 1px #18A0FB';
    });



    node.div.addEventListener('pointerleave', function(e)
    {
        if (   !graphView.zoomSelecting
            && !graphView.spaceDown)
            e.target.op.inner.style.boxShadow = '0px 5px 20px #0001';
    });

    

    createNodeHeader(node, headerColor);
}     



function createNodeHeader(node, headerColor)
{
    node.header = document.createElement('div');
    node.header.className = 'nodeHeader';
    node.header.style.backgroundColor = headerColor;

    node.inputControls = document.createElement('div');
    node.inputControls.className = 'inputControls';
    node.header.appendChild(node.inputControls);

    createNodeLabel(node);

    node.outputControls = document.createElement('div');
    node.outputControls.className = 'outputControls';
    node.header.appendChild(node.outputControls);

    node.inner.appendChild(node.header);



    node.header.addEventListener('pointerdown', e =>
    {
        if (graphView.spaceDown)    
            return;


        graphView.putNodeOnTop(node);


        if (   e.button == 0
            && !graphView.overOutput
            && !graphView.overInput)
        {
            e.stopPropagation();

            node.div.selectedSet = false;
            node.div.moved       = false;


            if (!node.selected)
            {
                if (e.shiftKey) node     .selected = true;
                else            graphView.selected = [node];

                node.selectedSet = true;
            }


            node.div.sx = e.clientX;
            node.div.sy = e.clientY;


            for (const n of graphView.selected)
            {
                n.div.slx = n.div.offsetLeft;
                n.div.sly = n.div.offsetTop;
            }


            node.div.dragging = true;
            node.header.setPointerCapture(e.pointerId);
        }
    });



    node.header.addEventListener('pointermove', e =>
    {
        if (node.div.dragging)
        {
            const dx = (e.clientX - node.div.sx) / graphView.zoom;
            const dy = (e.clientY - node.div.sy) / graphView.zoom;
            
            for (const n of graphView.selected)
            {
                setNodePosition(
                    n.div.op,
                    n.div.slx + dx,
                    n.div.sly + dy);
            }

            node.div.moved = true;

            graphView.updateScroll();
        };
    });



    node.header.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && node.div.dragging)
        {
            actionManager.do(new MoveNodesAction(
                graphView.selectedIds(), 
                { x: node.div.slx,        y: node.div.sly       },
                { x: node.div.offsetLeft, y: node.div.offsetTop }));


            if (   !node.div.selectedSet
                && !node.div.moved)
            {
                if (e.shiftKey) node.selected      = true;
                else            graphView.selected = [node];
            }

            node.div.dragging = false;
            node.header.releasePointerCapture(e.pointerId);
        }
    });
    
    

    node.header.addEventListener('dblclick', e =>
    {
        var bounds = node.label.getBoundingClientRect();

        if (   e.clientX >= bounds.left && e.clientX < bounds.right
            && e.clientY >= bounds.top  && e.clientY < bounds.bottom)
            node.showLabelTextbox();
        else
            node.makeActive();
    });



    node.updateInputs = () =>
    {
        for (const input of node.inputs)
        {
            if (input.connected) 
                input.connection.wire.update(true);
        }
    };



    node.updateOutput = () =>
    {
        if (   node.output 
            && node.output.connected)
        {
            for (const input of node.output.connectedInputs)
                input.connection.wire.update(true);
        }
    };



    node.updateParams = () =>
    {
        for (const param of node.params)
        {
            if (param.input.connected) 
                param.input.connection.wire.update(true);
        }
    };
}



function createNodeLabel(node)
{
    node.label           = document.createElement('div');
    node.label.className = 'nodeLabel';
    node.label.op        = node;
    
    node.header.appendChild(node.label);

    initLabelTextbox(node);
}



function setNodePosition(node, x, y)
{
    node.div.style.left = x;
    node.div.style.top  = y;

    node.updateInputs();
    node.updateOutput();
    node.updateParams();

    graphView.updateNodeTransform(node);
}


function initLabelTextbox(node)
{
    node.textbox = document.createElement('INPUT');
    node.textbox.setAttribute('type', 'text'); 
    node.textbox.className  = 'nodeLabelTextbox';
    node.textbox.spellcheck = false;
    


    node.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
        {
            if (!graph.nodes.find(n => n.id == node.textbox.value))
                node.textbox.finish(true);
        }

        else if (e.code == 'Escape')
            node.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.node, .figmaSelect, .menuSelect #hexValue, button');
            var index = node.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'node')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        // else 
        // {
        //     if (   e.key.length == 1
        //         && !isDigit(e.key)
        //         && e.key != '.'
        //         && !(   (   e.code == 'Minus'
        //                  || e.code == 'NumpadSubtract')
        //              && node.min < 0))
        //         e.preventDefault();

        //     var t = node.textbox;

        //     var curVal = t.value;

        //     curVal = 
        //           curVal.substring(0, t.selectionStart) 
        //         + curVal.substring(t.selectionEnd, curVal.length);

        //     var nextVal = parseFloat(curVal + e.key);

        //     if (   nextVal < node.min - 0.001
        //         || nextVal > node.max)
        //         e.preventDefault();            
        // }
    });


    
    // node.textbox.addEventListener('input', function()
    // {
    //     node.setValue(Number(node.textbox.value));
    // });



    node.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(node.min, val), node.max);

        node.textbox.value = isNaN(val) ? '' : val;
    });

    
    
    node.textbox.addEventListener('focusout', function()
    {
        node.header.removeChild(node.textbox);
        node.clicked = false;
    });
    


    node.textbox.finish = function(success)
    {
        if (success) 
        {
            if (node.textbox.value != '')
                setNodeId(node.id, node.textbox.value);
        }

        node.textbox.blur();

        if (node.inFocus)
            node.focus();
    };    
 
    
    
    node.showLabelTextbox = function()
    {
        node.inFocus = 
                node == document.activeElement
            && !node.clicked;
    
        node.textbox.style.width     = node.header.offsetWidth  - 2;
        node.textbox.style.height    = node.header.offsetHeight - 4;
        node.textbox.style.position  = 'absolute';
        node.textbox.style.left      = '50%';
        node.textbox.style.top       = '50%';
        node.textbox.style.transform = 'translateX(-50%) translateY(-50%)';
        node.textbox.style.textAlign = 'center';
    
        node.textbox.value      = node.name;
        node.textbox.savedValue = node.textbox.value;
        
        node.header.appendChild(node.textbox);
        
        node.textbox.focus();
        node.textbox.select();
    }
}


class   UOpNumber
extends UOperator
{
    #value;

    constructor()
    {
        super('number', 'number');

        this.setOutput(new UOutput(this.dataType));

        this.addParam(this.#value = new UNumberParam(''));
    }
}


class   UOpRandom
extends UOperator
{
    #min;
    #max;
    #scale;
    #seed;

    

    constructor()
    {
        super('random', 'number');

        this.setOutput(new UOutput(this.dataType));

        this.addParam(this.#min   = new UNumberParam('min',  0));
        this.addParam(this.#max   = new UNumberParam('max', 10));
        this.addParam(this.#scale = new UNumberParam('scale', 1, 1));
        this.addParam(this.#seed  = new UNumberParam('seed', 1, 1));

        this.#max.control.min = this.#min.value;
        this.#min.control.max = this.#max.value;

        this.#min.control.addEventListener('change', () =>
        {
            // if (this.#min.value > this.#max.value)
            //     this.#min.value = this.#max.value;

            this.#max.control.min = this.#min.value;
            this.updateConnectedInputValueText();
        });

        this.#max.control.addEventListener('change', () =>
        {
            // if (this.#max.value < this.#min.value)
            //     this.#max.value = this.#min.value;

            this.#min.control.max = this.#max.value;
            this.updateConnectedInputValueText();
        });
    }



    updateConnectedInputValueText()
    {
        const val =
            this.#min.value == this.#max.value
            ? this.#min.value
            : this.#min.value + '~' + this.#max.value;

        if (this.output)
        {
            for (const input of this.output.connectedInputs)
                input.param.valueText = val;
        }
    }
}





// class   UOpRandom
// extends UOperator
// {
//     #min;
//     #max;
//     #scale;
//     #seed;


//     constructor()
//     {
//         super('random', 'number');

//         this.setOutput(new UOutput(this.dataType));

//         this.addParam(this.#min   = new NumberParam('min'));
//         this.addParam(this.#max   = new NumberParam('max'));
//         this.addParam(this.#scale = new NumberParam('scale', 1, 1));
//         this.addParam(this.#seed  = new NumberParam('seed'));

//         this.#min.control.addEventListener('change', () =>
//         {
//             if (this.#min.control.value > this.#max.control.value)
//                 this.#max.control.setValue(this.#min.control.value, false);
//         });

//         this.#max.control.addEventListener('change', () =>
//         {
//             if (this.#max.control.value < this.#min.control.value)
//                 this.#min.control.setValue(this.#max.control.value, false);
//         });
//     }


//     generate()
//     {
//         if (this.valid) return;

//         this.output._data = 
//         {
//             id:    this.id,
//             type:  this.opType,
            
//             min:   this.#min  .value,
//             max:   this.#max  .value,
//             scale: this.#scale.value,
//             seed:  this.#seed .value
//         };

//         super.generate();
//     }
// }


class   UOpRect
extends UOperator
{
    #width;
    #height;
    #round;


    constructor()
    {
        super('rect', 'object');

        this.setOutput(new UOutput(this.dataType));

        this.addParam(this.#width  = new UNumberParam('width',  100, 0.01));
        this.addParam(this.#height = new UNumberParam('height', 100, 0.01));
        this.addParam(this.#round  = new UNumberParam('round',    0, 0));
        
        this.#width ._control.addEventListener('change', () => this.updateRound());
        this.#height._control.addEventListener('change', () => this.updateRound());

        this.updateRound();
    }
    
    
    updateRound()
    {
        const min = Math.min(this.#width.value, this.#height.value);
        this.setRoundMinMax(0, min/2);
    }

    
    setRoundMinMax(min, max)
    {
        const control = this.#round._control;

        control.min   = min;
        control.max   = max;
        //control.value = Math.min(control.value, control.max);

        this.#round._control.update();
    }


    // generate()
    // {
    //     if (this.valid) return;

    //     this.output._data = 
    //     {
    //         nodeId: this.id,
    //         opType: this.opType,

    //         x:      0,
    //         y:      0,
    //         width:  this.#width .value,
    //         height: this.#height.value
    //     };

    //     super.generate();
    // }
}


class   UOpRow
extends UOperator
{
    #count;
    #gap;


    constructor()
    {
        super('row', 'object');

        this.addInput (new UInput (this.dataType));
        this.setOutput(new UOutput(this.dataType));
        
        this.addParam(this.#count = new UNumberParam('count', 7, 1));
        this.addParam(this.#gap   = new UNumberParam('gap',  10, 0));
    }
}




// class   UOpRow
// extends UOperator
// {
//     #count;
//     #gap;


//     constructor()
//     {
//         super('row', 'object');

//         this.addInput (new UInput (this.dataType));
//         this.setOutput(new UOutput(this.dataType));
        
//         this.addParam(this.#count = new NumberParam('count',  4, 1));
//         this.addParam(this.#gap   = new NumberParam('gap',   10, 0));
//     }


//     generate()
//     {
//         if (this.valid) return;

//         const input  = this.inputs[0];
//         const output = this.output;

//         if (!input.connected)
//         {
//             output._data = {};
//             return;
//         }

    
//         const objects = input.data;
//         const bounds = getObjectBounds(objects);


//         output._data = [];
    
//         for (var i = 0, x = 0; i < this.#count.value; i++)
//         {
//             for (var j = 0; j < objects.length; j++)
//             {
//                 const obj = shallowCopy(objects[j]);
//                 obj.itemId = 'row_' + i + '_' + j;
   
//                 obj.x += x;
                
//                 output._data.push(obj);
//             }
            
//             x += bounds.w + this.#gap.value;
//         }

        
//         super.generate();
//     }
// }


class   UOpColumn
extends UOperator
{
    #count;
    #gap;


    constructor()
    {
        super('column', 'object');

        this.addInput (new UInput (this.dataType));
        this.setOutput(new UOutput(this.dataType));
        
        this.addParam(this.#count = new UNumberParam('count', 7, 1));
        this.addParam(this.#gap   = new UNumberParam('gap',  10, 0));
    }
}



// class   UOpColumn
// extends UOperator
// {
//     #count;
//     #gap;


//     constructor()
//     {
//         super('row', 'object');

//         this.addInput (new UInput (this.dataType));
//         this.setOutput(new UOutput(this.dataType));
        
//         this.addParam(this.#count = new NumberParam('count',  4, 1));
//         this.addParam(this.#gap   = new NumberParam('gap',   10, 0));
//     }


//     generate()
//     {
//         if (this.valid) return;

//         const input  = this.inputs[0];
//         const output = this.output;

//         if (!input.connected)
//         {
//             output._data = {};
//             return;
//         }

    
//         const objects = input.data;
//         const bounds = getObjectBounds(objects);


//         output._data = [];
    
//         for (var i = 0, y = 0; i < this.#count.value; i++)
//         {
//             for (var j = 0; j < objects.length; j++)
//             {
//                 const obj = shallowCopy(objects[j]);
//                 obj.itemId = 'column_' + i + '_' + j;
   
//                 obj.y += y;
                
//                 output._data.push(obj);
//             }
            
//             y += bounds.h + this.#gap.value;
//         }

        
//         super.generate();
//     }
// }


class Action
{
    manager;
 
    id;
    name;
  
    prevAction; // these are used to link actions into sequences
    nextAction; 
  
    data;
  
    onBefore;
    onAfter;

    onBeforeUndo;
    onAfterUndo;



    constructor(name)
    {
        this.name = name;

        console.assert(
               this.name != undefined
            && this.name != null
            && this.name != '');
    }



    do() {}



    redo()
    {
        this.do();
    }



    undo() {}



	link(prevAction, action)
	{
		prevAction.nextAction = action;
		action    .prevAction = prevAction;
	}



    // checkForPrevLink(condition)
    // {
    //     var index = manager.actions.indexOf(this);

    //     if (manager.actions[index-1].)
    //         && !PrevAction)
    //     {
    //         auto before = std::static_pointer_cast<T>((*Manager)[index-1]);

    //         if (condition(before))
    //             link(before, shared_from_this());
    //     }
    // }
};



class ActionManager
{
    actions      = [];
    redoActions  = [];
    
    nextActionId = 0;
   
    
    
    do(action)
    {
        // this is a fresh new action so any 
        // old redo queue is no longer relevant
        this.redoActions = [];

        this.actions.push(action);

        action.id      = this.nextActionId++;
        action.manager = this;
        
        console.log("DO " + action.name);
        action.do();
    }



    undo()
    {
        if (this.actions.length == 0)
            return;

        var last = removeLast(this.actions);
        this.redoActions.push(last);

        console.log("UNDO " + last.name);
        last.undo();
    }



    redo()
    {
        if (this.redoActions.length == 0)
            return;

        var last = removeLast(this.redoActions);
        this.actions.push(last);

        console.log("REDO " + last.name);
        last.redo();
    }
}



const actionManager = new ActionManager();





class CreateNodeAction
extends Action
{
    opType;
    createdNodeId;    

    prevSelectedIds = []; // currently selected nodes that are deselected as a result of creation



    constructor(opType)
    {
        super('Create ' + capitalize(opType) + ' node');
        
        this.opType = opType;
    }



    do()
    {
        this.prevSelectedIds = graphView.selectedIds();
        this.createdNodeId   = uiCreateNode(this.opType).id;
    }



    undo()
    {
        uiDeleteNodes([this.createdNodeId]);

        console.log("undo prevSelectedIds = " + this.prevSelectedIds);
        graphView.selectFromIds(this.prevSelectedIds);
    }



    redo()
    {
        uiCreateNode(this.opType, this.createdNodeId);
    }
}


class DeleteNodesAction
extends Action
{
    nodeIds     = [];
    connections = [];



    constructor(nodeIds)
    {
        super('Delete nodes');
        
        this.nodeIds = [...nodeIds]; // clone the array
    }



    do()
    {
        // TODO remember and remove the connections
        uiDeleteNodes(this.nodeIds, this.id);
    }



    undo()
    {
        uiUndeleteNodes(this.nodeIds);
        // TODO restore connections
    }
}





class MoveNodesAction
extends Action
{
    nodeIds;

    fromPos;
    toPos;

    from;
    to;



    constructor(nodeIds, fromPos, toPos)
    {
        super('Move nodes');


        this.nodeIds = [...nodeIds];

        this.fromPos = fromPos;
        this.toPos   = toPos;

        const dx = this.toPos.x - this.fromPos.x;
        const dy = this.toPos.y - this.fromPos.y;


        this.from = [];
        this.to   = [];

        for (const id of this.nodeIds)
        {
            const node = uiGraph.nodeFromId(id);

            this.from.push({ x: node.div.slx,      y: node.div.sly      });
            this.to  .push({ x: node.div.slx + dx, y: node.div.sly + dy });
        }
    }



    do()
    {
        for (var i = 0; i < this.nodeIds.length; i++)
        {
            const node = uiGraph.nodeFromId(this.nodeIds[i]);

            setNodePosition(
                node.div.op,
                this.to[i].x,
                this.to[i].y);
        }
    }



    undo()
    {
        for (var i = 0; i < this.nodeIds.length; i++)
        {
            const node = uiGraph.nodeFromId(this.nodeIds[i]);

            setNodePosition(
                node.div.op,
                this.from[i].x,
                this.from[i].y);
        }
    }
}





class SelectNodesAction
extends Action
{
    selectedIds     = [];
    prevSelectedIds = [];



    constructor(selectedIds, prevSelectedIds)
    {
        super('Select nodes');

        this.selectedIds     = [...selectedIds];
        this.prevSelectedIds = [...prevSelectedIds];
    }



    do()
    {
        // this happens in the UI
    }



    undo()
    {
        console.log('select undo prevSelectedIds');
        console.log(this.prevSelectedIds);
        graphView.selectFromIds(this.prevSelectedIds);
        console.log(graphView.selected);
    }



    redo()
    {
        graphView.selectFromIds(this.selectedIds);
        console.log(graphView.selected);
    }
}


class SetValueAction
extends Action
{
    param;

    oldValue;
    newValue;



    constructor(param, newValue)
    {
        super('Set Value');

        this.param    = param;
        this.newValue = newValue;
    }



    do()
    {
        this.oldValue = this.param.oldValue;
        uiSetParam(this.param, this.newValue);
    }



    undo()
    {
        this.param.setValue(this.oldValue, true, false);
    }



    redo()
    {
        uiSetParam(this.param, this.newValue);
        this.param.setValue(this.newValue, false, false);
    }
}


//save('state', null);
//save('windowWidth', null);
//save('windowHeight', null);
//uiSaveLocal('productKey', null);


var currentUser = '';


const uiGraph = new UGraph();

const generator = new Worker(
    window.URL.createObjectURL(
        new Blob([generatorScript.textContent])));


const buf = new SharedArrayBuffer(1024);

        
uiPostMessageToFigma({ 
    cmd:    'figLoadState',
    onLoad: 'figLoadState'
});


// --> from Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = e =>
{
    var msg = e.data.pluginMessage;

    switch (msg.cmd)
    {
        case 'uiForwardToGen': uiPostMessageToGenerator(msg.msg); break;
        case 'uiEndLoadState': uiEndLoadState          (msg);     break;
        //case 'uiUpdatePanAndZoom': graphView.updatePanAndZoom(); break;
    }    
}    
  
///////////////////////////////////////////////////////////////////////////////////////////////////



// from Generator <--
///////////////////////////////////////////////////////////////////////////////////////////////////

generator.onmessage = function(e)
{
    switch (e.data.msg)
    {
        case 'uiMakeActive':      uiMakeActive     (e.data.nodeIds);                            break;
        case 'uiShowParamValue':  uiShowParamValue (e.data.nodeId, e.data.param, e.data.value); break;
        case 'uiGenerateObjects': uiGenerateObjects(e.data.nodeIds);                            break;
        case 'uiUpdateObjects':   uiUpdateObjects  (e.data.objects);                            break;
    }
};

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to Figma
function uiPostMessageToFigma(msg)
{
    parent.postMessage({ pluginMessage: msg }, '*');    
}



// to Generator -->
function uiPostMessageToGenerator(msg)
{
    generator.postMessage(msg);
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function uiEndLoadState(msg)
{
    currentUser = msg.currentUser;
    productKey  = msg.productKey;

    initMenuSelect(menuSelect);
    menuSelect.initMenu();

    updateMenuSelectItems();
}



function updateMenuSelectItems()
{
    let items = 
    [
        {value: 'graph0',     text: 'Untitled'      },
        {value: 'new',        text: 'New graph'     },
        {value: 'loadLocal',  text: 'Load from file'}
    ];

    checkAddMenuItemsSave     (items);
    checkAddMenuItemProductKey(items);

    menuSelect.updateItems(items);
}



function checkAddMenuItemsSave(menuSelectItems)
{
    if (validateProductKey(currentUser.id, productKey))
    {
        menuSelectItems.push(...
        [
            {value: 'duplicate',  text: 'Duplicate'      },
            {value: 'saveLocal',  text: 'Save local copy'},
            {value: 'delete',     text: 'Delete'         } 
        ]);
    }
}



function checkAddMenuItemProductKey(menuSelectItems)
{
    if (!validateProductKey(currentUser.id, productKey))
        menuSelectItems.push({value: 'productKey', text: 'Enter product key'});
}



function removeMenuItemProductKey()
{
    let index = menuSelect.items.findIndex(item => item.value == 'productKey');
    removeAt(menuSelect.items, index);
    menuSelect.updateItems();
}



function uiNotify(text, prefix = 'Generator: ', delay = 4000)
{
    uiPostMessageToFigma({ 
        cmd:   'notify',
        text:   text,
        prefix: prefix,
        delay:  delay
    });        
}    


function uiCreateNode(opType, updateUI = true, createdId = -1)
{
    let node = uiGraph.createNode(opType, createdId);

    
    // if (graphView.selected.length > 0)
    // {
    //     const selNode = uiGraph.nodes.find(n => n.selected);
    //     const inputs  = node.inputs.filter(i => i.dataType == selNode.dataType);

    //     if (   !!selNode
    //         && selNode.output
    //         && inputs.length > 0)
    //         uiConnect(selNode.output, inputs[0]);
    // }
    

    if (updateUI)
    {
        graphView.selected = [node];
        graphView.putNodeOnTop(node);

        graphView.updateNodeTransform(node);
    }


    uiPostMessageToGenerator({
        msg:     'genCreateNode', 
        opType:   opType,
        nodeId:   node.id,
        nodeName: node.name
    });


    return node;
}



function uiDeleteNodes(nodeIds, actionId)
{
    uiGraph.deleteNodes(nodeIds);
    
    uiPostMessageToGenerator({
        msg:     'genDeleteNodes',
        nodeIds:  nodeIds,
        actionId: actionId
    });
    
    uiDeleteNodeObjects(nodeIds);
}



function uiUndeleteNodes(nodes, actionId)
{
    uiGraph.addNodes(nodes);


    graphView.selected = nodes;
    
    for (const node of nodes)
        graphView.updateNodeTransform(node);
    
    graphView.putNodeOnTop(lastOf(nodes));


    uiPostMessageToGenerator({
        msg:       'genUndeleteNodes',
        uiActionId: actionId
    });
}



function uiDeleteNodeObjects(nodeIds)
{
    uiPostMessageToFigma({ 
        cmd:    'figDeleteNodeObjects',
        nodeIds: nodeIds
    });

    uiPostMessageToGenerator({
        cmd:    'genDeleteNodeObjects',
        nodeIds: nodeIds
    });
}



function uiSetNodeId(nodeId, newId)
{
    const node = uiGraph.nodeFromId(nodeId);

    node.id = newId;

    uiPostMessageToGenerator({
        msg:   'genSetNodeId', 
        nodeId: nodeId,
        newId:  newId
    });
}



function uiConnect(output, input)
{
    uiGraph.connect(output, input);

    uiPostMessageToGenerator({
        msg:     'genConnect', 
        outputId: output.op.id, 
        inputs:  
        [{
            nodeId: input.op.id, 
            index:  input.op.inputs.indexOf(input)
        }]
    });
}



function uiDisconnect(input)
{
    uiGraph.disconnect(input);

    uiPostMessageToGenerator({
        msg: 'genDisconnect',
        input:
        {
            nodeId: input.op.id, 
            index:  input.op.inputs.indexOf(input)
        }
    });
}



function uiSetParam(param, value)
{
    uiPostMessageToGenerator({
        msg:   'genSetParam', 
        nodeId: param.op.id, 
        param:  param.name,
        value:  value
    });
}



function uiInvalidate(node)
{
    uiPostMessageToGenerator({
        msg:   'genInvalidate', 
        nodeId: node.id
    });
}



function uiSetActive(node, active)
{
    uiPostMessageToGenerator({
        msg:   'genSetActive', 
        nodeId: node.id,
        active: active
    });
}



function uiMakeActive(nodeIds)
{
    for (const nodeId in nodeIds)
    {
        const node = uiGraph.nodeFromId(nodeId);
        node.makeActive();
    }
}



function uiShowParamValue(nodeId, paramName, value)
{
    const node = uiGraph.nodeFromId(nodeId);
            
    if (!!node) // this is for deleted nodes which still exist 
    {           // in genGraph but no longer in uiGraph
        const param = node.params.find(p => p.name == paramName);
        param.control.setValue(value, false);
    }
}



function uiGenerateObjects(nodeIds)
{
    if (uiGraph.mutex)
    {
        for (const nodeId of nodeIds)
            uiGraph.deferNodeIds.push(nodeId);

        return;
    }
    
    uiGraph.mutex = true;


    uiPostMessageToGenerator({
        msg:    'genGenerateObjects',
        nodeIds: nodeIds
    });
}



function uiUpdateObjects(objects)
{
    uiGraph.mutex = false;
    

    if (uiGraph.deferNodeIds.length > 0)
    {
        let deferNodes = Array.from(uiGraph.deferNodeIds).filter(
            (value, index, self) => self.indexOf(value) === index);
            
        uiGraph.deferNodeIds = [];

        uiGenerateObjects(deferNodes);
    }


    uiPostMessageToFigma({ 
        cmd:    'figUpdateObjects',
        objects: objects
    });    
}


menuSelect.addEventListener('change', async function(e) 
{
    switch (e.detail.selectedValue)
    {
        case 'saveLocal':  saveToLocalFile('graph.json'); break;
        case 'loadLocal':  loadFromLocalFile();           break;
        case 'duplicate':  console.log(uiGraph.save());   break;
        case 'productKey': showProductKeyDialog();        break;
    }
});



productKeyClose.addEventListener('click', e =>
{
    hideProductKeyDialog();
});


const resizeEdgeWidth = 8;

document.canResizeX = false;
document.canResizeY = false;

document.resizingX  = false;
document.resizingY  = false;

document.startRect = new Rect();



function resizeWindow(width, height)
{
    graphView.updatePanAndZoom();

    uiPostMessageToFigma({ 
        cmd:   'resizeWindow', 
        width:  width,
        height: height
    });
}



function checkResize(x, y)
{
    document.canResizeX = document.body.clientWidth  - x <= resizeEdgeWidth;
    document.canResizeY = document.body.clientHeight - y <= resizeEdgeWidth;

         if (document.canResizeX
          && document.canResizeY) document.body.style.cursor = 'nwse-resize';
    else if (document.canResizeX) document.body.style.cursor = 'ew-resize';
    else if (document.canResizeY) document.body.style.cursor = 'ns-resize';
    else                          document.body.style.cursor = 'auto';
}


document.addEventListener('pointerdown', function(e)
{
    if (   document.canResizeX
        || document.canResizeY)
    {
        if (document.canResizeX) document.resizingX = true;
        if (document.canResizeY) document.resizingY = true;

        document.startRect = new Rect(
            e.clientX,
            e.clientY,
            window.innerWidth,
            window.innerHeight);

        document.body.setPointerCapture(e.pointerId);
    }
});



document.addEventListener('pointermove', function(e)
{
    if (   document.resizingX
        && document.resizingY)
    {
        resizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (document.resizingX)
    {
        resizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            document.body.clientHeight);
    }
    else if (document.resizingY)
    {
        resizeWindow(
            document.body.clientWidth,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else
        checkResize(e.clientX, e.clientY);
});



document.addEventListener('pointerup', function(e)
{
    if (   document.resizingX
        || document.resizingY)
    {
        document.resizingX = false;
        document.resizingY = false;
        
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }
});





document.addEventListener('keydown', e =>
{
    // delete
    if (e.key == 'Delete')
    {
        actionManager.do(new DeleteNodesAction(graphView.selected));
        graphView._selected = [];
    }

    // select all
    else if (e.code == 'KeyA'
          && e.ctrlKey)
    {
        graphView.selected = uiGraph.nodes;
    }

    // undo/redo
    else if (e.code == 'KeyZ'
          && e.ctrlKey)
    {
        if (e.shiftKey) actionManager.redo();
        else            actionManager.undo();
    }

    //
    else if (e.code == 'Minus')
    {
        graphView.zoom /= 2;
    }

    else if (e.code == 'Equal')
    {
        graphView.zoom *= 2;
    }

    else if (e.code == 'Digit0'
          && e.shiftKey)
    {
        graphView.zoom = 1;
        uiNotify('Zoom to 100%');
    }

    else if (e.code == 'Space'
         && !e.ctrlKey)
    {
        if (!graphView.selecting)
        {
            graphView.spaceDown = true;
            graphView.setPanCursor();
        }
    }

    else if (e.key == 'Control'
          && graphView.spaceDown)
    {
        graphView.zoomSelecting = true;

        if (e.altKey) graphView.setZoomOutCursor();
        else          graphView.setZoomInCursor();
    }

    else if (e.key == 'Alt'
          && graphView.spaceDown
          && e.ctrlKey)
    {
        graphView.setZoomOutCursor();
    }
});



document.addEventListener('keyup', e =>
{
    if (e.code == 'Space')
    {
        if (graphView.spaceDown)
        {
            graphView.style.cursor  = 'auto';
            graphView.spaceDown     = false;
            graphView.zoomSelecting = false;
        }
    }

    else if (e.key == 'Alt'
          && graphView.spaceDown)
    {
        if (e.ctrlKey) 
            graphView.setZoomInCursor();
        else
        {
            graphView.setPanCursor();
            graphView.zoomSelecting = false;
        }
    }

    else if (e.key == 'Control'
          && graphView.spaceDown)
    {
        graphView.zoomSelecting = false;
        graphView.setPanCursor();
    }
});






function initSliderTextbox(slider)
{
    slider.textbox = document.createElement('INPUT');
    slider.textbox.setAttribute('type', 'text'); 
    slider.textbox.className = 'sliderText';
    
    slider.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            slider.textbox.finish(true);

        else if (e.code == 'Escape')
            slider.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.slider, .select, .menuSelect, button, .menuButton');
            var index = slider.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && slider.min < 0))
                e.preventDefault();

            var t = slider.textbox;

            var curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            var nextVal = parseFloat(curVal + e.key);

            if (   nextVal < slider.min - 0.001
                || nextVal > slider.max)
                e.preventDefault();            
        }
    });


    // slider.textbox.addEventListener('input', function()
    // {
    //     slider.setValue(Number(slider.textbox.value));
    // });

    slider.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(slider.min, val), slider.max);

        slider.textbox.value = isNaN(val) ? '' : val;
    });

    slider.textbox.addEventListener('focusout', function()
    {
        slider.parentNode.removeChild(slider.textbox);
        slider.clicked = false;
    });
    
    slider.textbox.finish = function(success)
    {
        if (success) slider.setValue(Number(slider.textbox.value     ));
        else         slider.setValue(Number(slider.textbox.savedValue));

        slider.textbox.blur();

        if (slider.inFocus)
            slider.focus();
    };    
    
    
    slider.showTextbox = function()
    {
        slider.inFocus = 
                slider == document.activeElement
            && !slider.clicked;
    
        slider.textbox.style.position = 'absolute';
    
        slider.textbox.style.left      = slider.offsetLeft   + 1;
        slider.textbox.style.top       = slider.offsetTop    + 1;
        slider.textbox.style.width     = slider.offsetWidth  - 2;
        slider.textbox.style.height    = slider.offsetHeight - 2;
        slider.textbox.style.boxShadow = '0 0 0 1px #18A0FB';
        slider.textbox.style.outline   = 'none';
    
        slider.textbox.style.textAlign = 'center';
    
        slider.textbox.value = numToString(slider.value, slider.editDec);
        slider.textbox.savedValue = slider.textbox.value;
        
        slider.parentNode.appendChild(slider.textbox);
        
        slider.textbox.focus();
        slider.textbox.select();
    }
}


function initSliderChildren(slider)
{
    slider.bar = document.createElement('div');
    slider.bar.className = 'sliderBar';

    slider.text = document.createElement('div');
    slider.text.className = 'sliderText';

    slider.focus = document.createElement('div');
    slider.focus.className = 'sliderFocus';

    slider.appendChild(slider.bar);
    slider.appendChild(slider.text);
    slider.appendChild(slider.focus);
}



function initSlider(slider, width, height, name, min, max, def, dragScale, wheelStep, dec, acc, suffix = '', log = false, backColor = '#fff', valueColor = '#eee', fontSize = 11)
{
    slider.className         = 'slider';

    slider.width             = width;
    slider.height            = height;
        
    slider.style.width       = width;
    slider.style.height      = height;
        
    slider.min               = min;
    slider.max               = max;
    slider.value             = def;
    slider.dec               = dec;
    slider.editDec           = dec;
    slider.acc               = acc;
               
    slider.name              = name;
    slider.suffix            = suffix;
    slider.log               = log;

    slider.dragScale         = dragScale;
    slider.wheelStep         = wheelStep;
        
    slider.backColor         = backColor;
    slider.valueColor        = valueColor;
           
    slider.fontSize          = fontSize;
        
    slider.style.display     = 'inline';
        
    slider.mouseOver         = false;
    slider.buttonDown0       = false;
    slider.buttonDown1       = false;
        
    slider.clickSize         = 4;
    slider.moved             = false;
    
    slider.tabIndex          = 0;
    slider.inFocus           = false;
    slider.clicked           = false;

    slider.oldValue;

    slider.wrapValue         = false;
    
    slider.enableChangeEvent = true;

    slider.inputConnected    = false;

    slider.valueText         = '';



    initSliderChildren(slider);    
    initSliderTextbox(slider);

    

    //

    slider.onchange  = new Event('change');
    slider.onconfirm = new Event('confirm');



    //

    slider.addEventListener('pointerdown', function(e)
    {
        if (graphView.spaceDown)
            return;

        if (e.button == 0)
        {
            if (slider.inputConnected)
            {
                e.stopPropagation();
                return;
            }
    
            var opDiv = 
                   slider.parentNode
                && slider.parentNode.parentNode
                && slider.parentNode.parentNode.parentNode
                ? slider.parentNode.parentNode.parentNode
                : null;

            if (opDiv && opDiv.className == 'node') 
                graphView.putNodeOnTop(opDiv.op);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();

            slider.buttonDown0  = true;
            slider.buttonDown0_ = true;
            slider.moved        = false;
            slider.clientX      = 0;
            slider.oldValue     = slider.value;

            slider.prevValue    = slider.value;
            slider.sx           = e.clientX;

            slider.focus.style.boxShadow = '0 0 0 1px #18A0FB inset';
            
            


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();

            slider.clickTimer = setTimeout(function() 
            {
                onSliderClickTimer(slider); 
            }, 500);
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            slider.buttonDown1 = true;
        }
    });



    slider.addEventListener('pointermove', function(e)
    {
        if (slider.inputConnected)
            return;
        

        var rect = slider.getBoundingClientRect();
        
        slider.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;
        
        slider.clientX = e.clientX;

        
        if (slider.buttonDown0)
        {
            //slider.style.boxShadow = '0 0 0 1px #18A0FB';
            
            if (slider.isPointerLocked())
            {
                slider.movedX += e.movementX;
                
                var dx       = slider.sx - slider.movedX;             
                var adaptive = 10 * Math.pow(Math.abs(dx), slider.acc);
                
                // TODO: if (log) do log scaling
                var val = slider.oldValue - dx*slider.dragScale*adaptive;
                
                const grain = Math.pow(10, this.editDec);
                val = Math.floor(val / grain) * grain;
                
                slider.setValue(val, true, false);

                slider.prevValue = slider.value;
            }
            else
            {
                if (Math.abs(e.clientX - slider.sx) > slider.clickSize/2)
                {
                    slider.moved = true;
                    slider.lockPointer();
                }
            }
        }
        //else
        //    slider.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
        
        // slider.update();
    });
    
    
    
    slider.addEventListener('losecapture', function()
    {
        slider.buttonDown0 = false;
        slider.mouseOver   = false;
        slider.update();
    });



    slider.addEventListener('pointerup', function(e)
    {
        clearTimeout(slider.clickTimer);

        if (   slider.moved
            || document.menuHadFocus)
        {
            slider.unlockPointer(e.pointerId);
            return;            
        }    

        if (slider.buttonDown0_)
        {
            slider.clicked = true;
            slider.showTextbox();
        }
        
        if (slider.buttonDown1)
            slider.buttonDown1 = false;

        slider.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && slider.buttonDown0)
        {
            slider.buttonDown0 = false;
            slider.unlockPointer(e.pointerId);

            slider.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            if (slider.value != slider.oldValue)
                slider.dispatchEvent(slider.onconfirm);
        }
        if (   e.button == 1
            && slider.buttonDown1)
        {
            slider.buttonDown1 = false;            
        }
    });


    
    slider.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.spaceDown
            && !slider.inputConnected)
        {
            slider.style.cursor           = 'ew-resize';
            
            slider.focus.style.boxShadow  = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
            slider.focus.style.visibility = 'visible';
            slider.focus.style.opacity    = '100%';
    
            slider.update();
        }
    });



    slider.addEventListener('pointerout', function(e)
    {
        slider.style.cursor     = 'default';
        
        slider.focus.style.visibility = 'hidden';
        slider.focus.style.opacity    = 0;

        slider.update();
    });



    slider.addEventListener('wheel', e =>
    {
        if (   !e.ctrlKey
            && !slider.buttonDown1)
        {
            e.stopPropagation();

            slider.oldValue = slider.value;
            slider.setValue(slider.value + (e.deltaY > 0 ? -1 : 1) * slider.wheelStep);
            // TODO conform after a delay and/or another action, same with key changes 
        }
    });



    slider.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            slider.showTextbox();

        // else if (e.code == 'Space')
        //     graphView.setPanCursor();
    });



    slider.addEventListener('focus', function()
    {
        if (   !graphView.spaceDown
            && !slider.buttonDown1
            && !slider.inputConnected)
            slider.showTextbox();
    });


    
    slider.setValue = function(value, fireChangeEvent = true, confirm = true)
    {
        const oldValue = slider.value;

        if (slider.wrapValue)
        {
            while (value < slider.min) value += slider.max - slider.min;
            while (value > slider.max) value -= slider.max - slider.min;
        }
        else
            value = Math.min(Math.max(slider.min, value), slider.max);
        
        if (  !confirm
            || value != oldValue)
            slider.value = value;


        slider.update();


        if (   fireChangeEvent
            && slider.enableChangeEvent
            && value != slider.prevValue)
            slider.dispatchEvent(slider.onchange);


        if (   confirm
            && slider.enableChangeEvent
            && value != oldValue)
            slider.dispatchEvent(slider.onconfirm);
    };




    slider.update = function()
    {
        var v  =  slider.value / (slider.max - slider.min);
        var cx = -slider.min / (slider.max - slider.min) * slider.clientWidth;

        slider.bar.style.background = slider.valueColor;

        slider.bar.style.top    = 0;//slider.mouseOver ? 1 : 0;
        slider.bar.style.height = slider.clientHeight;// - (slider.mouseOver ? 2 : 0);

        slider.focus.style.left   = 0;
        slider.focus.style.top    = 0;
        slider.focus.style.width  = slider.clientWidth;
        slider.focus.style.height = slider.clientHeight;

        if (v >= 0)
        {
            slider.bar.style.left  = slider.offsetLeft + Math.round(cx);
            slider.bar.style.width = Math.round(v * slider.clientWidth);
        }
        else
        {
            slider.bar.style.left  = slider.offsetLeft + cx + v * slider.clientWidth;
            slider.bar.style.width = -v * slider.clientWidth;
        }

        slider.bar.style.background =
            slider.value >= 0
            ? slider.valueColor
            : 'repeating-linear-gradient(-60deg, #fff, #fff 1px, #e5e5e5 2px, #e5e5e5 3px, #fff 4px)';

        slider.text.innerHTML = '';
        
        if (slider.name.length > 0)
            slider.text.innerHTML += '<span class="sliderName">' + slider.name + "</span>&nbsp;&nbsp;";
        
        var valueText = 
            slider.valueText != ''
            ? slider.valueText
            : getNumberString(slider.value, slider.dec);

        slider.text.innerHTML += valueText + slider.suffix;
    };



    slider.lockPointer = function()
    {
        slider.requestPointerLock =    
               slider.requestPointerLock 
            || slider.mozRequestPointerLock;

        slider.requestPointerLock();
        clearTimeout(slider.clickTimer);

        slider.movedX = 0;
        slider.sx     = 0;
    };



    slider.unlockPointer = function()
    {
        document.exitPointerLock =    
               document.exitPointerLock    
            || document.mozExitPointerLock;

        document.exitPointerLock();
    };



    slider.isPointerLocked = function()
    {
        return (document.pointerLockElement    === slider 
             || document.mozPointerLockElement === slider);
    }
    


    slider.update();
}



function onSliderClickTimer(slider)
{
    if (!document.menuHadFocus)
    {
        slider.moved = true;
        slider.lockPointer();
    }
}


function initSelectMenu(select)
{
    select.menu = document.createElement('DIV');

    select.menu.className    = 'selectMenu';
    select.menu.hoverIndex   = 0;
    select.menu.tabIndex     = 0;

    select.menu.style.left   = select.offsetLeft;
    select.menu.style.zIndex = Number.MAX_SAFE_INTEGER;

    select.menu.addEventListener('focus', function() { select.menu.style.outline = 'none'; });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });
    

    
    select.menu.tabIndex = 0;
    
    select.menu.style.height     = 'auto';
    select.menu.style.textAlign  = 'center';
    select.menu.style.background = '#222222';
    select.menu.style.zIndex     = Number.MAX_SAFE_INTEGER;

    select.menu.hoverIndex       = 0;


    select.selectBox = document.createElement('DIV');
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = 'calc(100% + 1px)';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = '#18A0FB';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = -1; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = document.createElement('DIV');
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();
        select.dispatchChangeEvent();
        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initSelect(select, items)
{
    select.className = 'menuSelect';
    select.tabIndex = 0;    
    
    initSelectMenu(select);

    select.holding  = false;
    

    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = document.createElement('DIV');
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function()
    {
        select.resetMenu();
        
        for (let i = 0; i < select.items.length; i++)
        {
            let item = document.createElement('DIV');
            let sub  = document.createElement('DIV');
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            if (select.items[i].value == '-')
            {
                item.style.borderTop = '1px solid white';
                item.style.marginTop = '6px';
                item.style.height    = '4px';
                item.style.position  = 'relative';
                item.style.left      = '6px';
                
                item.disabled = true;
            }
            else
            {
                item.style.border = 'none';
                item.style.height = 24;

                item.disabled = false;

                sub.innerHTML = select.items[i].text;
            }

            item.appendChild(sub);
            select.menuWrap.appendChild(item);
        }


        let options = select.getElementsByTagName('option');
        for (const op of options) op.disabled = op.value == '-';
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();
            
            select.buttonDown0 = true;        
            select.setPointerCapture(e.pointerId);
            
            select.holding = false;
            setTimeout(function() { onSelectClickTimer(select); }, 200);
            
            select.menu.hoverIndex = select.getSelectedIndex();

            select.showMenu();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        let menuTop =
            select.offsetTop 
            - 3 // paddingTop
            - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
            - iy * 24;
        
        menuTop = Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
        iy = Math.min(Math.max(0, iy), select.items.length-1);
        return iy;
    };        
    

    
    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    }



    select.dispatchChangeEvent = function()
    {
        const onchange = new Event('change', 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        });

        select.dispatchEvent(onchange);
    };


    //////////////////////////////////////////////////////////////////////////////////

    
    select.items = items;
    
    select.update(0);
    select.updateItems();
}



function onSelectClickTimer(select)
{
    select.holding = true;
}


function initMenuSelectMenu(select)
{
    select.menu = document.createElement('DIV');

    select.menu.className    = 'menuSelectMenu';
    select.menu.hoverIndex   = 0;
    select.menu.tabIndex     = 0;

    select.menu.style.left   = select.offsetLeft;
    select.menu.style.zIndex = Number.MAX_SAFE_INTEGER;

    select.menu.addEventListener('focus', function() 
    {
         select.menu.style.outline = 'none'; 
    });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });
    
    

    select.selectBox = document.createElement('DIV');
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = '100%';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = '#18A0FB';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = 0; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = document.createElement('DIV');
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();

        const onchange = new CustomEvent('change', { detail: 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        }});

        select.dispatchEvent(onchange);

        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initMenuSelectTextbox(select)
{
    select.textbox = document.createElement('INPUT');
    select.textbox.setAttribute('type', 'text'); 
    select.textbox.className = 'menuSelectText';
    
    select.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("copy");
        }
        else if (e.code == 'KeyV'
              && e.ctrlKey)
        {
            e.preventDefault();
            document.execCommand("paste");
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            select.textbox.finish(true);

        else if (e.code == 'Escape')
            select.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            let tabs  = document.querySelectorAll('.slider, .menuSelect, .select, button, .menuButton');
            let index = select.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && select.min < 0))
                e.preventDefault();

            let t = select.textbox;

            let curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            let nextVal = parseFloat(curVal + e.key);

            if (   nextVal < select.min - 0.001
                || nextVal > select.max)
                e.preventDefault();            
        }
    });


    // slider.textbox.addEventListener('input', function()
    // {
    //     slider.setValue(Number(slider.textbox.value));
    // });


    select.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        let val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(select.min, val), select.max);

        select.textbox.value = isNaN(val) ? '' : val;
    });


    select.textbox.addEventListener('focusout', function()
    {
        select.parentNode.removeChild(select.textbox);
        select.clicked = false;
    });
    

    select.textbox.finish = function(success)
    {
        if (success) select.setValue(Number(select.textbox.value     ));
        else         select.setValue(Number(select.textbox.savedValue));

        select.textbox.blur();

        if (select.inFocus)
            select.focus();
    };    
    
    
    select.showTextbox = function()
    {
        select.inFocus = 
                select == document.activeElement
            && !select.clicked;
    
        select.textbox.style.position = 'absolute';
    
        select.textbox.style.left      = select.offsetLeft   + 1;
        select.textbox.style.top       = select.offsetTop    + 1;
        select.textbox.style.width     = select.offsetWidth  - 2;
        select.textbox.style.height    = select.offsetHeight - 2;
        select.textbox.style.boxShadow = '0 0 0 1px #18A0FB';
        select.textbox.style.outline   = 'none';
    
        select.textbox.style.textAlign = 'center';
    
        select.textbox.value = numToString(select.value, select.editDec);
        select.textbox.savedValue = select.textbox.value;
        
        select.parentNode.appendChild(select.textbox);
        
        select.textbox.focus();
        select.textbox.select();
    }
}


function initMenuSelect(select)
{
    select.className = 'menuSelect';
    select.tabIndex  = 0;    
    
    initMenuSelectMenu   (select);
    initMenuSelectTextbox(select);

    select.holding = false;

    select.enableChangeEvent = true;


    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = document.createElement('DIV');
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function(items)
    {
        select.resetMenu();
        
        
        select.items = items;
        select.update(0);


        for (let i = 0; i < select.items.length; i++)
        {
            let item = document.createElement('DIV');
            let sub  = document.createElement('DIV');
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            item.style.border      = 'none';
            item.style.height      = 24;

            item.disabled = false;

            sub.innerHTML = select.items[i].text;

            item.appendChild(sub);

            select.menuWrap.appendChild(item);
        }
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();

            var rect = select.getBoundingClientRect();

            if (e.clientX > rect.width - 20)
            {
                select.buttonDown0 = true;        
                select.setPointerCapture(e.pointerId);
                
                select.holding = false;
                setTimeout(function() { onSelectClickTimer(select); }, 200);
                
                select.menu.hoverIndex = select.getSelectedIndex();

                select.showMenu();
            }
            else
                select.showTextbox();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        // let menuTop =
        //     select.offsetTop; 
        //     - 3 // paddingTop
        //     - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
        //     - iy * 24;
        
        menuTop = select.offsetTop + select.offsetHeight + 11;//Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
            iy = Math.min(Math.max(0, iy), select.items.length-1);

        return iy;
    };        
    

    
    select.getSelectedValue = function()
    {
        return select.items[select.getSelectedIndex()].value;
    };        



    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    };



    select.setSelectedIndex = function(index)
    {
        select.value = select.items[index].value;
        select.update(select.getSelectedIndex());
        
        select.enableChangeEvent = false;
        select.dispatchChangeEvent();
        select.enableChangeEvent = true;
    };



    select.dispatchChangeEvent = function()
    {
        if (!select.enableChangeEvent)
            return;
    
        let index = select.getSelectedIndex();
    
        const onchange = new Event('change', 
        {
            selectedIndex: index,
            selectedValue: select.items[index].value
        });

        select.dispatchEvent(onchange);
    };
}



graphView._pan = {x:0, y:0};
  
Object.defineProperty(graphView, 'pan',
{
    get: () => graphView._pan,
    set: pan =>
    {
        if (graphView._pan == pan) return;
        graphView._pan = pan;
        graphView.updatePanAndZoom();
    }
});



graphView.panning = false;
graphView.panStart;

graphView.spaceDown = false;


graphView._zoom   = 1;
graphView.oldZoom = 1;

Object.defineProperty(graphView, 'zoom',
{
    get: () => graphView._zoom,
    set: zoom =>
    {
        if (graphView._zoom == zoom) return;

        graphView.oldZoom = graphView.zoom;
        graphView._zoom   = zoom;

        graphView.updatePanAndZoom();
    }
});



graphView.zooming   = false;
graphView.zoomStart = 1;

graphView.zoomSelecting = false;



graphView.setZoomAndPan = (zoom, pan) =>
{
    if (   graphView._zoom == zoom
        && graphView._pan  == pan) 
        return;

    graphView.oldZoom = graphView.zoom;

    graphView._zoom = zoom;
    graphView._pan  = pan;

    graphView.updatePanAndZoom();
};



graphView.updatePanAndZoom = () =>
{
    for (const node of uiGraph.nodes)
        graphView.updateNodeTransform(node);

    graphView.updateScroll();
};



graphView.startPan = pointerId =>
{
    graphView.panning  = true;
    graphView.panStart = graphView.pan;
    graphView.setPointerCapture(pointerId);
    graphView.setPanCursor();
};



graphView.endPan = (pointerId, changeCursor) =>
{
    graphView.panning = false;
    graphView.releasePointerCapture(pointerId);

    if (changeCursor)
        graphView.style.cursor = 'auto';
};



graphView.startZoomSelection = (x, y) =>
{
    graphView.zoomSelecting = true;
    graphView.selectBox = new Rect(x, y, 0, 0);
    
    selectBox.style.visibility = 'visible';
    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelection = (x, y) =>
{
    if (!graphView.zoomSelecting) return;

    graphView.selectBox.w = x - graphView.selectBox.x;
    graphView.selectBox.h = y - graphView.selectBox.y;

    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelectBox = () =>
{
    var selection = graphView.getValidSelection();

    selectBox.style.left   = selection.x + Math.min(selection.w, 0);
    selectBox.style.top    = selection.y + Math.min(selection.h, 0);
    selectBox.style.width  = Math.abs(selection.w);
    selectBox.style.height = Math.abs(selection.h);
};



graphView.endZoomSelection = (zoom) =>
{
    graphView.zoomSelecting    = false;
    selectBox.style.visibility = 'hidden';

    if (zoom)
    {
        // graphView.oldZoom = graphView.zoom;
        
        const box = {
            x: graphView.selectBox.x,
            y: graphView.selectBox.y,
            w: graphView.selectBox.w,
            h: graphView.selectBox.h };
            
        box.x = (box.x - graphView.pan.x) / graphView.zoom;
        box.y = (box.y - graphView.pan.y) / graphView.zoom;
        box.w =  box.w                    / graphView.zoom;
        box.h =  box.h                    / graphView.zoom;
        
        const diff = { w: (window.innerWidth  / graphView.zoom - box.w)/2,
                       h: (window.innerHeight / graphView.zoom - box.h)/2 };

        graphView.setZoomAndPan(
            graphView.zoom * Math.min(
                window.innerWidth  / graphView.selectBox.w,
                window.innerHeight / graphView.selectBox.h),
            { x: -(box.x - diff.w) * graphView.zoom,
              y: -(box.y - diff.h) * graphView.zoom });
    }

    graphView.selectBox = Rect.NaN;
};



graphView.setPanCursor = () =>
{
    graphView.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzJweCIgaGVpZ2h0PSIzMnB4Ij48aW1hZ2UgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWEhlQUFBSHFrbEVRVlI0WHUyYWY4aVY1Um5IUDlhbXpjM0tkRERkSDJ2WitpUEQvdEJTSEtLQ1EyVmJaTWdnbDAxTENUUmJ0Q1hLSFA1Z1N1UWZNZGtmZ3lrMkZLTWtjU0wrV0RKbExOU2xwaWtSaEdRU1VTMU4zV2JiYW5OOG50M1h1N3ZIOXpYUE9jOXp3dDczZ3B2M25QT2U4enpQOWIyLzE4Lzc2a1UzbDE3ZFhIOTZBT2hoUURkSG9NY0V1amtCZXB4Z2p3bTAwUVFFTzFiYzlnSVFxNDJQOHY5YnRZTUIzdU9xdEs0R0JnRTNBdThBYndML1R1cy9nS3V0VWpjQVhsK2x2d0I4RVZnRXpNODBmQkZZRFR3UGZGd0NvaTNNcUJzQWxWZnhQc0R2Z0xFcVAyVElFSTRmUDU3djlGVGdqOEJOd0YrQk54SWJaRWV0ektnRGdMQnphYS95MXdEZkIzNnJ4cHMyYldMS2xDbWNPSEdDdVhQbnNtM2JOai9lQlh3TnVDMmhjaEJZRE93QlBrcnNxTVU4cWdTZ2JPdlMzcDN2Qzh3R2ZqNXk1RWoyN2R2WHNmT3JWNjltOW16LzFhVThEdndhK0ZkZElGUUZRRGc1ZDF6RjF3SERnZXVBVjREWGdBZVhMRm5DNHNWdTdQOWt6NTQ5akI4L3ZuanQ1K1BHamFOZnYzNXMzYm9Wdnd1OEM0d0FQZ0QrbVh5RXZxRXlxUUtBY0hTOTA0NmY3dXJwTGdYQXNXUEhHRHAwYU1kUGUvWHFlTFFKd0NIZ2ZES0hTazJoQ2dEQzBYMEplQWFZcUJaYnRteGgrUERoTEZpd2dIWHJKQVRGcm5iRmdBc1hQcm14TWtPR0FQY0RMd0IvU3l3d1dsVEdnbFlCOFBkU1h1Vy9BdndaK1BxcVZhdVlOMjlleDI0T0dEQ0EwNmRQTnd2QVE4bEpHaDFrZ2Y1QUZnaEN5MnhvRlFCdFgrcC9PZGw3RWR2S3U3bDA2ZEpDK1NZWjhDandUV0JrOGlWUEF5K1Y4b2FtR1ZFRkFJYTVmc0FOd0tzMUFOQ1pTM2tTK0VVV0hjd1htcEpXQWREK3BmKzF3SURrOGF0bUFLTkhqMmI1OHVYSXBPUVhWRlpmc3pmNUJYT0ZwbGpRS2dCaC80YTdnY0RMVlROZzJMQmhIRGx5cEdOM1I0MGF4Zjc5KzMwdkEzNlovRUtFeUlaWlVBVUFKam9CZ09HcVN3WVlBVko4dnlnUDZDb0s3TjY5dThnUFFzS2ZKRDh3SmFYT0g2WVErWmtDOEZYQUZMWmRBSGl2SHdCbmdMOG5mOUN3R1ZURmdPdVRDYlFUQU0zdFhzREV5eHpoSDgzNGdTc1pnTVBBRHhNQTV4SUFEZWNGVnpJQWVzYjdnRk9BQU9nSGFnY2dBSXUvRmorR3dYQ0NCenJ6QVRvK25WZkZUckN0QU9TbGJsUis2aHIxZmlSQ3BzS2RPa0hqOTlpeFl5K0tBZ0tqNk8xektWZUpuVVFCQVpoZVlrRERDZEhsbUVBb2JNenZiMDBEV0tHNTY2YSttNjE5QUIzaG56b0RvT0hZZElrZlpHR3dMUUJFc2VOT1c2ditDcml6aytjek0xbWJtaGNYTWVCS0JzQlUxMkpITy84TmNJL0tyRnk1a2hFalJuRDQ4T0hDcnMrZDB3Y1ZEUXM3UUxVQ0VQNEVxSjBCN3I3S1creVlkeityY3VYR3hjR0RCMW0wYUJFN2R1em8yT2h5VmxjbEE5b0pnTHZ2amxycVBnQThZVXBhZGxhaDNMSmx5enFhSFo4WEFLTFEwY1BQQVg1V0xrektPN3RyMXk3bXo1L1BvVU5GU1ZDTHRKTUJPajRMSFV2ZE85TGhSY0dBdkRncGEzbisvSG42OXZWbjljaG5CWUNsN25KZ3NtcHQzNzZkU1pNbTFhUGhwMXkxblFEa0ptQ3o0MmJnS2VBYlB1UEdqUnVaT3RVRG5mWktPd0hJbmFCSmp1V3VKemNMMCtFbWE5ZXVaY2FNR1cxRm9BUkExQUkyVEswRktzMEVEWU9SNjBlcWE5L3ZGdUNud0xmVXZOd0JyaHVOVWlhWUYwT1d3NVVDb0M2UkNJVXpOQlYyYVFZL0FXNzFTeXRXckdEaFFvbFJ2OHlhTllzMWE5WjRvejhBUDY2N0dveFVPRnJmTWtGekVBUVBNMlhDN1Q2TkFBaEUzYUx6M2JsenA3ZDVEbGlXQUFnVHFLVWN0aGpTSVFxQ1RBZ1FCRUxuS0FpR3llSXdSSk9vVXdZT0hNaXBVN1lBaXFKTUVPd0lDWUFtVUFzQTNxd3pFS3dHZ3cyUEFhUDlvazVSNTFpSDdOMjd0MmlSSi9rZThIbzZPQlVBYTVGYWU0S0NFSkhCNGtnbUNJTG1JQkNQeEFDRTRkRXdXYlZNbno2ZDlldlhlMW1yVCszL0wxbFRWQUFhbHN2cEIrUVhEUkRDSER3UHpFRXdaYlpYd01TSkV6OVJJRFg4WktVZmJONjh1UmlzU0xJQStEM3dQbkEyaFVBUFJ4cVdSZ0h3QnJsakRDYVlMa2VFZUJENHJsLzBkUGpBZ2FKTDFwS2NPWE9HL3YyOWZDRk9rM2dvOGw2cEk5eHdDQXhsbW5tNHZGR2lZd3dtaEUvNEVYQjNGVXpJaHlpQXQ0RlppZnA2UW5lLzZUT0JWZ0NJMytZTmt6SUltc0xEZm5ITW1ERkZtSnc4dVNnbExrdk9uajNMaGcwYm1ETkhxeXJFM244a1BpcnYxRWljQnpnejBKUTBZd0w1amZMcGtKZ1IwQnhrZ2tzUXpKWDlqSmt6WnpKdDJqUW1UQ2pjUktkeTlPalJRbkhYeVpNbjR6c2VoeitSS0cvWVUvbUkvZHArdytFdkx0d3FBRGtUSW0yV0NTcXNjM1E1K25ZWDhKMjRhZS9ldlJrOGVEQ0RCZzJpVDUraWk0WjI3dVNZZnpQeGplMWlSMHg4cmVMU1BzNEJtajRVclJLQU1naTIwT3dpR1NZRndpVW8xZzdmVGtOUGd6K0ZyOGRTejg4dTgxdHB0MVhjSmUxalVxVGxjWmtxR0pDREdWT2hnaEFtb2ZJdVFmRXp0OXoza1QrWVpTcFdjOUpiKzViV1puWXFxcE9UN2k1Zit6M0haR0tJc2luYnI1b0IrZlh5ckZHRlhVYUtlQzBBNWhHQzVYSVRZaXhXcGR4VkZSUUFsUlVFbDYvOVRIQXFVVDZvMnhLQ1hmdzRRTkF2cUd5TTBJWHlmcTd5Zmk5WUdDT3hBcUNTZ3FDTng0cGhTWlZ2T09YdFNza3FUYUI4ajRnUStiQjBERTNudXgvUEVGTmZ3WUlBd3IvNUlIVmx5dGZKZ0J5TU9GcUxORHAvci9JNUFEa0lNaUlmbHE1VThicDh3S1hNS1pUTi8rYWJFQW9HQ0orTGNmazYvRXVsMTZ6VEIxVDZvSFZkckFlQXVwQzlVcTdiN1Jud1g2cWNXVzY0MVZ5REFBQUFBRWxGVGtTdVFtQ0MiIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIvPjwvc3ZnPg==) 15 15, auto';
};



graphView.setZoomInCursor = () =>
{
    graphView.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kKSI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC41IDhDMTQuNSAxMS4wMzggMTIuMDM4IDEzLjUgOSAxMy41QzUuOTYyIDEzLjUgMy41IDExLjAzOCAzLjUgOEMzLjUgNC45NjIgNS45NjIgMi41IDkgMi41QzEyLjAzOCAyLjUgMTQuNSA0Ljk2MiAxNC41IDhaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAzOCAxMy41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5IDIuNUMxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNTg1NyAxOC4wMDAyTDE4Ljk5OTcgMTYuNTg2MkwxMy41NTA3IDExLjEzNzJMMTIuMTM2NyAxMi41NTEyTDE3LjU4NTcgMTguMDAwMloiIGZpbGw9ImJsYWNrIi8+PC9nPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0gxMFY1SDhWN0g2VjguOThIOFYxMUgxMFY4Ljk4SDEyVjdaIiBmaWxsPSJibGFjayIvPjxkZWZzPjxmaWx0ZXIgaWQ9ImZpbHRlcjBfZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIxLjk5OTciIGhlaWdodD0iMjIuMDAwMiIgZmlsdGVyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPjxmZUZsb29kIGZsb29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiLz48ZmVPZmZzZXQgZHk9IjEiLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLjUiLz48ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4zNSAwIi8+PGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZUZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3ciLz48ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3VyY2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvdyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjwvZGVmcz48L3N2Zz4=) 8 8, auto';
};



graphView.setZoomOutCursor = () =>
{
    graphView.style.cursor = 'url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZCkiPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjUgOEMxNC41IDExLjAzOCAxMi4wMzggMTMuNSA5IDEzLjVDNS45NjIgMTMuNSAzLjUgMTEuMDM4IDMuNSA4QzMuNSA0Ljk2MiA1Ljk2MiAyLjUgOSAyLjVDMTIuMDM4IDIuNSAxNC41IDQuOTYyIDE0LjUgOFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAzOCAxMy41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5IDIuNUMxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3LjU4NTcgMTguMDAwMkwxOC45OTk3IDE2LjU4NjJMMTMuNTUwNyAxMS4xMzcyTDEyLjEzNjcgMTIuNTUxMkwxNy41ODU3IDE4LjAwMDJaIiBmaWxsPSJibGFjayIvPgo8L2c+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0g2VjguOThIMTJWN1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2QiIHg9IjAiIHk9IjAiIHdpZHRoPSIyMS45OTk3IiBoZWlnaHQ9IjIyLjAwMDIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0iMCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAiLz4KPGZlT2Zmc2V0IGR5PSIxIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIvPgo8ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4zNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3VsdD0iZWZmZWN0MV9kcm9wU2hhZG93Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBoaWMiIGluMj0iZWZmZWN0MV9kcm9wU2hhZG93IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cjwvc3ZnPgo=) 8 8, auto';
};



scrollbarX.moving = false;
scrollbarY.moving = false;



graphView.updateScroll = () =>
{
    const bounds = graphView.getAllNodeBounds();

    graphView.updateScrollX(bounds);
    graphView.updateScrollY(bounds);
};



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollX = bounds =>
{
    if (bounds.l < 0)
    {
        const widthX = sqr(graphView.clientWidth) / (graphView.clientWidth - bounds.l) - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  widthX;
        scrollbarX.style.left    =  graphView.clientWidth - largeScrollGap - widthX;
        scrollbarX.style.top     =  graphView.offsetTop + graphView.clientHeight - smallScrollGap - 6;
    }
    else if (bounds.r >= graphView.clientWidth)
    {
        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  sqr(graphView.clientWidth) / bounds.r - (smallScrollGap + largeScrollGap);
        scrollbarX.style.left    =  smallScrollGap;
        scrollbarX.style.top     =  graphView.offsetTop + graphView.clientHeight - smallScrollGap - 6;
    }
    else
        scrollbarX.style.display = 'none';
};



scrollbarX.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarX.moving = true;
        scrollbarX.xStart = scrollbarX.offsetLeft;
        scrollbarX.wStart = scrollbarX.offsetWidth;
        scrollbarX.pStart = e.clientX;
        scrollbarX.setPointerCapture(e.pointerId);

        graphView.panStart = graphView.pan;

        for (const node of uiGraph.nodes)
            node.div.slx = node.div.offsetLeft;
    }
});



scrollbarX.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarX.moving)
    {
        scrollbarX.moving = false;
        scrollbarX.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of uiGraph.nodes)
            bounds.expandFromRect(Rect.fromTypical(node.div.getBoundingClientRect()));

        if (bounds.l >= 0 && bounds.r < graphView.clientWidth)
            scrollbarX.style.display = 'none';
    }
});



scrollbarX.addEventListener('pointermove', e =>
{
    if (scrollbarX.moving)
    {
        var x = scrollbarX.xStart + e.clientX - scrollbarX.pStart;

        var l = x;
        var r = l + scrollbarX.wStart;

        l = Math.max(smallScrollGap, l);
        r = Math.min(r, graphView.clientWidth - largeScrollGap);

        l = Math.max(smallScrollGap, Math.min(l, r - smallScrollGap));
        r = Math.max(l + smallScrollGap, r);

        scrollbarX.style.left  = l;
        scrollbarX.style.width = r-l;

        graphView.pan = {
            x: graphView.panStart.x - (e.clientX - scrollbarX.pStart) / scrollbarX.wStart * graphView.clientWidth,
            y: graphView.panStart.y 
        };
    }
});



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollY = bounds =>
{
    if (bounds.t < controlBar.offsetHeight)
    {
        const ot     = bounds.t - controlBar.offsetHeight;
        const height = sqr(graphView.clientHeight) / (graphView.clientHeight - ot) - (smallScrollGap + largeScrollGap);

        scrollbarY.style.height  = height;
        scrollbarY.style.left    = graphView.clientLeft + graphView.clientWidth - smallScrollGap - 6;
        scrollbarY.style.top     = graphView.clientHeight - largeScrollGap - height;
        scrollbarY.style.display = 'inline-block';
    }
    else if (bounds.b >= controlBar.offsetHeight + graphView.clientHeight)
    {
        const ob     = bounds.b - controlBar.offsetHeight;
        const height = sqr(graphView.clientHeight) / ob - (smallScrollGap + largeScrollGap);

        scrollbarY.style.height  = height;
        scrollbarY.style.left    = graphView.clientLeft + graphView.clientWidth - smallScrollGap - 6;
        scrollbarY.style.top     = smallScrollGap;
        scrollbarY.style.display = 'inline-block';
    }
    else
        scrollbarY.style.display = 'none';
};



scrollbarY.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarY.moving = true;
        scrollbarY.yStart = scrollbarY.offsetTop;
        scrollbarY.hStart = scrollbarY.offsetHeight;
        scrollbarY.pStart = e.clientY;
        scrollbarY.setPointerCapture(e.pointerId);

        for (const node of uiGraph.nodes)
            node.div.sly = node.div.offsetTop;

        graphView.panStart = graphView.pan;
    }
});



scrollbarY.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarY.moving)
    {
        scrollbarY.moving = false;
        scrollbarY.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of uiGraph.nodes)
            bounds.expandFromRect(Rect.fromTypical(node.div.getBoundingClientRect()));

        if (bounds.t >= 0 && bounds.b < graphView.clientHeight)
            scrollbarY.style.display = 'none';
    }
});



scrollbarY.addEventListener('pointermove', e =>
{
    if (scrollbarY.moving)
    {
        var y = scrollbarY.yStart + e.clientY - scrollbarY.pStart;

        var t = y;
        var b = t + scrollbarY.hStart;

        t = Math.max(smallScrollGap, t);
        b = Math.min(b, graphView.clientHeight - largeScrollGap);

        t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
        b = Math.max(t + smallScrollGap, b);

        scrollbarY.style.top    = t;
        scrollbarY.style.height = b-t;

        graphView.pan = {
            x: graphView.panStart.x, 
            y: graphView.panStart.y - (e.clientY - scrollbarY.pStart) / scrollbarY.hStart * graphView.clientHeight
        };
    }
});


graphView._selected     = [];
graphView._prevSelected = [];



Object.defineProperty(graphView, 'selected',
{
    get: () => graphView._selected,
    set: selected =>
    {
        graphView.deselectAll();

        graphView._selected = [...selected];
    
        for (const node of graphView._selected)
            node.setSelected(true);
    }
});



graphView.deselectAll = () =>
{
    for (const node of graphView._selected)            
        node.setSelected(false);

    graphView._selected = [];
};



graphView.selectedIds = () =>
{
    return graphView._selected.map(n => n.id);
};



graphView.selectFromIds = (nodeIds) =>
{
    graphView.deselectAll();

    console.log('graphView.selectFromIds');
    console.log(nodeIds);

    for (const id of nodeIds)
    {
        var node = uiGraph.nodes.find(n => n.id == id);
        console.log('id = ' + id);
        console.log('node = ' + node);
        
        graphView._selected.push(node);
        node.setSelected(true);
    }
};



graphView.getValidSelection = () =>
{
    return new Rect(
        graphView.selectBox.x + Math.min(graphView.selectBox.w, 0),
        graphView.selectBox.y + Math.min(graphView.selectBox.h, 0),
        Math.abs(graphView.selectBox.w),
        Math.abs(graphView.selectBox.h));
};



graphView.startSelection = (x, y) =>
{
    graphView.selecting = true;

    graphView.selectBox = new Rect(x, y, 0, 0);
    selectBox.style.visibility = 'visible';

    graphView.updateSelectBox();
};



graphView.updateSelection = (x, y) =>
{
    if (!graphView.selecting) return;

    graphView.selectBox.w = x - graphView.selectBox.x;
    graphView.selectBox.h = y - graphView.selectBox.y;

    graphView.updateSelectBox();
};



graphView.updateSelectBox = () =>
{
    var selection = graphView.getValidSelection();

    selectBox.style.left   = selection.x + Math.min(selection.w, 0);
    selectBox.style.top    = selection.y + Math.min(selection.h, 0);
    selectBox.style.width  = Math.abs(selection.w);
    selectBox.style.height = Math.abs(selection.h);

    const selected = [];

    for (const node of uiGraph.nodes)
    {
        if (rectsIntersect(
                Rect.fromTypical(node.div.getBoundingClientRect()), 
                graphView.getValidSelection()))
            selected.push(node);
    }

    graphView.selected = selected;
};



graphView.endSelection = () =>
{
    graphView.selecting = false;
    graphView.selectBox = Rect.NaN;

    selectBox.style.visibility = 'hidden';

    actionManager.do(new SelectNodesAction(
        graphView.selected     .map(n => n.id), 
        graphView._prevSelected.map(n => n.id)));
};


graphView.wires      = [];


graphView.overInput  = null;
graphView.overOutput = null;
   
graphView.tempConn   = null;
   
   
graphView.selecting  = false;
graphView.selectBox  = Rect.NaN;

graphView.btn1down   = false;



graphView.pStart = {x:0, y:0};



graphView.addEventListener('pointerdown', e =>
{
    graphView.pStart = { x: e.clientX, 
                         y: e.clientY };

    if (    e.button == 0
        && !graphView.panning)
    {
        if (graphView.spaceDown)
        {
            if (e.ctrlKey) graphView.startZoomSelection(e.clientX, e.clientY);
            else           graphView.startPan(e.pointerId);
        }
        else if (graphView.overOutput)
        {
            graphView.overOutput.connecting = true;
            graphView.startConnectionFromOutput(graphView.overOutput);
            graphView.tempConn.wire.updateFromOutput(e.clientX, e.clientY);
        }
        else if (graphView.overInput)
        {
            if (graphView.overInput.connectedOutput) // pretend to disconnect
            {
                graphView.startConnectionFromOutput(graphView.overInput.connectedOutput);
                graphView.tempConn.wire.updateFromOutput(e.clientX, e.clientY);
                graphView.tempConn.savedInput = graphView.overInput;
                hide(graphView.overInput.connection.wire);
                hide(graphView.overInput.connection.wire.outBall);
            }
            else
            {
                graphView.overInput.connecting = true;
                graphView.startConnectionFromInput(graphView.overInput);
                graphView.tempConn.wire.updateFromInput(e.clientX, e.clientY)
            }
        }
        else // selection
        {
            graphView._prevSelected = [...graphView.selected];

            if (!e.shiftKey)
                graphView.startSelection(e.clientX, e.clientY);
        }
    }
    
    else if (e.button == 1)
    {
        graphView.btn1down = true;
        graphView.startPan(e.pointerId);
    }
});



graphView.addEventListener('pointermove', e =>
{
    graphView.p = { 
        x: e.clientX, 
        y: e.clientY };

    if (graphView.panning)
    {
        const dp = subv(graphView.p, graphView.pStart);
        graphView.pan = addv(graphView.panStart, dp);
    }
    
    else if (graphView.selecting)
        graphView.updateSelection(e.clientX, e.clientY);
    
    else if (graphView.zoomSelecting)
        graphView.updateZoomSelection(e.clientX, e.clientY);
    
    else if (graphView.tempConn)
    {
             if (graphView.tempConn.output) graphView.tempConn.wire.updateFromOutput(e.clientX, e.clientY);
        else if (graphView.tempConn.input ) graphView.tempConn.wire.updateFromInput (e.clientX, e.clientY);
    }
});



graphView.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && graphView.spaceDown)
    {
        if (e.ctrlKey)
        {
            if (   graphView.selectBox.w > 0
                && graphView.selectBox.h > 0)
            {
                graphView.endZoomSelection(true);
            }
            else
            {
                graphView.endZoomSelection(false);

                graphView.oldZoom = graphView.zoom;

                if (e.altKey) graphView.zoom /= 2;
                else          graphView.zoom *= 2;

                graphView.pan = subv(graphView.pan, mulvs(subv(position(e), graphView.pan), graphView.zoom / graphView.oldZoom - 1));
            }
        }
        
        graphView.endPan(e.pointerId, false);
    }

    else if (e.button == 0
         && !graphView.selectBox.isNaN)
        graphView.endSelection();

    else if (e.button == 0
          && graphView.tempConn)
    {
        if (graphView.tempConn.output) // FROM OUTPUT
        {
            var output     = graphView.tempConn.output;
            var input      = graphView.overInput;
            var savedInput = graphView.tempConn.savedInput;
            
            output.connecting = false;
            
            if (   input
                && input.dataType == output.dataType) // TO INPUT
            {
                if (input == savedInput) // reconnect old
                {
                    show(input.connection.wire);
                    show(input.connection.wire.outBall);
                }
                else if (savedInput) // disconnect old, connect new
                {
                    uiDisconnect(savedInput);
                    uiConnect(output, input);
                }
                else // connect new
                    uiConnect(output, input);
            }
            else if (savedInput) // disconnect old
            {
                uiDisconnect(savedInput)
            }
            
            graphView.cancelConnection();
        }
        
        else if (graphView.tempConn.input) // FROM INPUT
        {
            var input  = graphView.tempConn.input;
            var output = graphView.overOutput;

            input.connecting = false;
            
            if (   output
                && output.dataType == input.dataType) // TO OUTPUT
                uiGraph.connect(output, input); // connect new

            graphView.cancelConnection();
        }
    }

    else if (e.button == 1
          && graphView.panning)
    {
        graphView.endPan(e.pointerId, true);
        graphView.btn1down = false;
    }
});



graphView.addEventListener('wheel', e =>
{
    if (graphView.btn1down)
        return;


    const dZoom = Math.log(graphView.zoom) / Math.log(2);

    const dWheelX = e.deltaX/120;
    const dWheelY = e.deltaY/120;

    if (e.ctrlKey)
    {
        const zoom = Math.max(0.0001, Math.pow(2, dZoom - dWheelY / 10));
        const pan  = subv(graphView.pan, mulvs(subv(position(e), graphView.pan), zoom / graphView.zoom - 1));

        graphView.setZoomAndPan(zoom, pan);
    }
    else
    {
        const dPanX = dWheelX * 20 / Math.pow(graphView.zoom, 0.1);
        const dPanY = dWheelY * 20 / Math.pow(graphView.zoom, 0.1);

        graphView.pan = 
            dWheelX != 0
            ? { x:  e.shiftKey ? graphView.pan.x : graphView.pan.x - dPanX,
                y: !e.shiftKey ? graphView.pan.y : graphView.pan.y - dPanX }
            : { x: !e.shiftKey ? graphView.pan.x : graphView.pan.x - dPanY,
                y:  e.shiftKey ? graphView.pan.y : graphView.pan.y - dPanY };

        if (graphView.selecting)
            graphView.updateSelection(e.clientX, e.clientY);
    }
});



graphView.startConnectionFromOutput = output =>
{
    graphView.tempConn = new UConnection(output, null);
    graphView.addWireFromOutput(graphView.tempConn.wire, output);
    graphView.tempConn.wire.style.zIndex = Number.MAX_SAFE_INTEGER;
    graphView.tempConn.wire.scale        = graphView.zoom;
    graphView.tempConn.wire.output       = output;
    graphView.tempConn.wire.updateFromOutput(graphView.pStart.x, graphView.pStart.y);
};



graphView.startConnectionFromInput = input =>
{
    graphView.tempConn = new UConnection(null, input);
    graphView.addWireFromInput(graphView.tempConn.wire, input);    
    graphView.tempConn.wire.style.zIndex = Number.MAX_SAFE_INTEGER;
    graphView.tempConn.wire.scale        = graphView.zoom;
    graphView.tempConn.wire.input        = input;
    graphView.tempConn.wire.updateFromInput(graphView.pStart.x, graphView.pStart.y);
};



graphView.cancelConnection = () =>
{
    graphView.removeWire(graphView.tempConn.wire);    
    graphView.tempConn = null;
};



graphView.getAllNodeBounds = () =>
{
    const bounds = Rect.NaN;

    for (const node of uiGraph.nodes)
        bounds.expandFromRect(Rect.fromTypical(node.div.getBoundingClientRect()));

    return bounds;
};



graphView.getNodeBounds = () =>
{
    var boundsL = Number.MAX_SAFE_INTEGER;
    var boundsT = Number.MAX_SAFE_INTEGER;
    var boundsR = Number.MIN_SAFE_INTEGER;
    var boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const node of uiGraph.nodes)
    {
        var bounds = node.div.getBoundingClientRect();

        boundsL = Math.min(boundsL, bounds.left  );
        boundsT = Math.min(boundsT, bounds.top   );
        boundsR = Math.max(boundsR, bounds.right );
        boundsB = Math.max(boundsB, bounds.bottom);
    }

    return {
        x: boundsL - graphView.pan.x, 
        y: boundsT - graphView.pan.y,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
};



graphView.putNodeOnTop = node =>
{
    const topIndices = 
          1 
        + node.inputs.filter(i => i.connected).length 
        + (!!node.output && node.output.connected ? 1 : 0);
        
    for (const n of uiGraph.nodes)
        n.div.style.zIndex = Math.max(0, Number(n.div.style.zIndex) - topIndices);
        
    var z = Number.MAX_SAFE_INTEGER;

    for (const input of node.inputs.filter(i => i.connected))
        input.connection.wire.style.zIndex = z--;
        
    if (!!node.output)
    {
        for (const input of node.output.connectedInputs)
        input.connection.wire.style.zIndex = z--;
    }
    
    node.div.style.zIndex = z;
};



graphView.updateNodeTransform = function(node)
{
    node.div.style.transform =
          'translate(' 
        + (graphView.pan.x * graphView.zoom) + 'px, '
        + (graphView.pan.y * graphView.zoom) + 'px) '
        + 'scale(' + graphView.zoom + ')';
    

    const nodeRect = graphView.getNodeOffsetRect(node.div);

    node.div.style.transformOrigin = 
          ((graphView.pan.x - node.div.offsetLeft) / nodeRect.width  * 100) + '% ' 
        + ((graphView.pan.y - node.div.offsetTop ) / nodeRect.height * 100) + '%';  

   
    for (const input of node.inputs)
    {
        if (input.connected)
            graphView.updateWireTransform(input.connection.wire);        
    }


    if (node.output)
    {
        for (const input of node.output.connectedInputs)
            graphView.updateWireTransform(input.connection.wire);        
    }
};



graphView.updateWireTransform = function(wire)
{
    wire.setAttribute('width',  graphView.clientWidth  / graphView.zoom);
    wire.setAttribute('height', graphView.clientHeight / graphView.zoom);

    wire.setAttribute('viewBox',
                0
        + ' ' + 20                     / graphView.zoom // 20 seems to be the plugin title bar
        + ' ' + graphView.clientWidth  / graphView.zoom
        + ' ' + graphView.clientHeight / graphView.zoom);

    wire.update();
};



graphView.addWire = wire =>
{
    graphView.wires.push(wire);
    graphView.appendChild(wire);  
    graphView.updateWireTransform(wire);
    wire.update();
};



graphView.addWireFromOutput = (wire, output) =>
{
    graphView.wires.push(wire);
    graphView.appendChild(wire);
    //wire.updateFromOutput(output);  
};



graphView.addWireFromInput = (wire, input) =>
{
    graphView.wires.push(wire);
    graphView.appendChild(wire);  
    //wire.updateFromInput(input);  
};



graphView.removeWire = wire =>
{
    graphView.removeChild(wire);    
    removeFromArray(graphView.wires, wire);
};



graphView.getNodeOffsetRect = (node) =>
{
    const ox   = -graphView.pan.x / graphView.zoom;
    const oy   = -graphView.pan.y / graphView.zoom;

    const rect = node.getBoundingClientRect();

    return new DOMRect(
        ox + (rect.left / graphView.zoom),
        oy + (rect.top  / graphView.zoom), 
        rect.width      / graphView.zoom, 
        rect.height     / graphView.zoom);
}


function saveToLocalFile(filename, str) 
{
    const link = document.createElement('a');
    link.style.display = 'none';
    
    link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(str));
    link.setAttribute('download', filename);
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}



function loadFromLocalFile()
{
    const input = document.createElement('input');

    input.type          = 'file';
    input.style.display = 'none';

    input.addEventListener('change', e =>
    {
        const files = e.target.files;

        if (files.length > 0)
            loadGraphFromFile(files[0]);
    },
    false);

    //document.body.appendChild(input);
    input.click();
    //document.body.removeChild(input);
}



function loadGraphFromFile(file, graph)
{
    const reader = new FileReader();

    reader.onload = () =>
    {
        uiGraph.clear();

        
        // load file contents
        
        let load = JSON.parse(reader.result);

        for (const nodeInfo of load.nodes)
        {
            let node = uiCreateNode(nodeInfo.type, false);
            node.name = nodeInfo.name;
        }
    };

    reader.readAsText(file);
}




////////////////////////////////////////////////////

</script>
