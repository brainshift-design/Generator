<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<!-- <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet"> -->
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>


.button
{
    font-family:   Inter;
    font-size:     11px;
    width:         30;
    height:        30;
    background:    white;
    min-width:     0;
    min-height:    0;
    border:        none;
    border-radius: 2px;
    position:      relative;
    padding:       0;
}


.button:hover
{
    background: #f0f0f0;
}


.button:active
{
    box-shadow: 0 0 0 2px var(--activeObjectColor) inset;
    outline:    none;
}


:root
{
    /* --colFigmaBlue: #0c8ce9; */
}


#loadingOverlay
{
    position:   absolute;
    left:       0;
    top:        0;
    width:      100%;
    height:     100%;
    display:    none;
}


.figma-light #loadingOverlay { background: #f0f0f0; } /* my tuning of bg-tertiary */
.figma-dark  #loadingOverlay { background: #1e1e1e; }


#loadingGraphic
{
    font-family: Inter;
    font-size:   26;
    font-weight: 800;
    color:       var(--figma-color-text);/*#333;*/
    position:    absolute;
    left:        50%;
    top:         50%;
    width:       184px;
    height:       64px;
    transform:   translateX(-50%)
                 translateY(-50%);
    /* box-shadow:  0 0 0 1px red inset; */
}


.figma-light #loadingGraphic { font-weight: 800; }
.figma-dark  #loadingGraphic { font-weight: 600; }


#loadingG 
{
    position:  absolute;
    left:      50%;
    top:       40%;
    transform: translateX(-50%)
               translateY(-50%);
}

#loadingEmpty, #loadingFull
{
    position:  absolute;
    left:      calc(50% - 4px);
    top:       calc(40% - 4px);
}

#loadingG     > path { fill: var(--figma-color-text);            }

#loadingEmpty        { animation: emptyOrbit 3s linear infinite; }
#loadingEmpty > path { fill:var(--figma-color-text);             }

#loadingFull         { animation: fullOrbit 3s linear infinite;  }
#loadingFull  > path { fill: var(--figma-color-text);            }


@keyframes emptyOrbit
{
      0%   { transform: rotate(  0deg) translate(-20px) scale(100%);  opacity: 100%; }
     15%   { transform: rotate(170deg) translate(-20px) scale(100%);  opacity: 100%; }
     17%   { transform: rotate(180deg) translate(-20px) scale(130%);  opacity: 100%; }
     23%   { transform: rotate(180deg) translate(-20px) scale(130%);  opacity: 100%; }
     30%   { transform: rotate(180deg) translate(-20px) scale( 50%);  opacity:   0%; }
     35.1% { transform: rotate(360deg) translate(-20px) scale(150%);  opacity:   0%; }
     40%   { transform: rotate(360deg) translate(-20px) scale(100%);  opacity: 100%; }
     50%   { transform: rotate(360deg) translate(-20px) scale(100%);  opacity: 100%; }
     68%   { transform: rotate(360deg) translate(-20px) scale(100%);  opacity: 100%; }
     70%   { transform: rotate(360deg) translate(-20px) scale(130%);  opacity: 100%; }
     73%   { transform: rotate(360deg) translate(-20px) scale(130%);  opacity: 100%; }
     77%   { transform: rotate(360deg) translate(-20px) scale(100%);  opacity: 100%; }
     85%   { transform: rotate(360deg) translate(-20px) scale(100%);  opacity: 100%; }
     95%   { transform: rotate(360deg) translate(-20px) scale(100%);  opacity: 100%; }
    100%   { transform: rotate(360deg) translate(-20px) scale(100%);  opacity: 100%; }
}


@keyframes fullOrbit
{
      0%   { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
     18%   { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
     19%   { transform: rotate(  0deg) translate(20px) scale( 75%);  opacity: 100%; }
     20%   { transform: rotate(  0deg) translate(20px) scale( 75%);  opacity: 100%; }
     33%   { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
     35.1% { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
     45%   { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
     50%   { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
     68%   { transform: rotate(170deg) translate(20px) scale(100%);  opacity: 100%; }
     70%   { transform: rotate(180deg) translate(20px) scale( 50%);  opacity: 100%; }
     73%   { transform: rotate(180deg) translate(20px) scale( 50%);  opacity: 100%; }
     77%   { transform: rotate(180deg) translate(20px) scale(  0%);  opacity:   0%; }
     85.1% { transform: rotate(  0deg) translate(20px) scale( 80%);  opacity:   0%; }
     90%   { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
    100%   { transform: rotate(  0deg) translate(20px) scale(100%);  opacity: 100%; }
}


#loadingBar
{
    position:      absolute;
    left:          50%;
    bottom:           0;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         180px;
    height:        5px;
    border-radius: 2.5px;
    overflow:      hidden;
    /* box-shadow:    0 0 0 1px yellow inset; */
}


.figma-light #loadingBar { background: white; }
.figma-dark  #loadingBar { background: var(--figma-color-bg-tertiary); }


#loadingProgress
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         0;
    height:        5px;
    background:    var(--figma-color-text);/*#333;*/
}


#productKeyBack
{
    display:          none;

    z-index:          1;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;

    background-color: #0002
}


#productKeyDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    top:           60px;
    left:          calc(50% - 130px);
    width:         220px;
    height:        170px;
    
    background:    white;
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);
    box-shadow:    0px 2px 14px rgba(0, 0, 0, 0.15);
    border-radius: 4px;
}


#productKeyTitle
{
    height:        40px;
    border-bottom: 1px solid rgb(0, 0, 0, 0.15);
}


#productKeyText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          rgba(0, 0, 0, 0.8);
}


#productKeyClose
{
    width:    32px;
    height:   32px;
    position: absolute;
    left:     calc(100% - 36px);
    top:      4px;
}

#productKeyClose:active
{
    box-shadow: none;
}


#productKeyUserInfo
{
    font-size:      12px;

    margin-top:     16px;
    margin-bottom:  12px;

    position:       relative;
    left:           21px;

    user-select:    text;
}


#productKeyWebsite
{
    font-size:      12px;
    text-align:     center;

    margin-top:     16px;
    margin-bottom:   8px;
}


#productKeyInput
{
    font-family:  'Roboto Mono';
    font-size:     16px;
     
    width:         calc(9em + 1px);
    padding-left:  10px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-bottom: -3px;

    position:      relative;
    left:          calc(50% - 4.5em);
}



#productKeyInputBack
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    color:          #ddd;
    
    width:           9em;
    padding-left:   10px;
    padding-top:    -2px;
    padding-bottom:  2px;

    position:       absolute;
    left:           calc(calc(50% - 4.5em) + 1px);
    top:            calc(50% + 2px);

    pointer-events: none;
}


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    padding-top:   1px; 
    height:        20px;
    line-height:   14px;
    border:        none;
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:focus
{
    box-shadow: 0 0 0 1px var(--activeObjectColor) inset;
    outline:    none;
}


input[type=text]::selection
{
    background-color: var(--figma-color-bg-brand);
    color:            white;
}


@import url('https://rsms.me/inter/inter.css');
html { font-family: 'Inter', sans-serif; }

@supports (font-variation-settings: normal) 
{
  html { font-family: 'Inter var', sans-serif; } 
}


body
{
    margin:           0;
    background-color: var(--figma-color-bg);/*#f4f4f4;*/
    user-select:      none;
    font-family:      Inter;

    -webkit-touch-callout: none; 
      -webkit-user-select: none; 
       -khtml-user-select: none; 
         -moz-user-select: none; 
          -ms-user-select: none; 
              user-select: none; 

    overflow:         hidden;
}


.figma-light body { background: var(--figma-color-bg-secondary); }
.figma-dark  body { background: var(--figma-color-bg);           }


div
{
    margin:  0;
    padding: 0;
}


.tooltip
{
    display:          none;
    opacity:          0;
    width:            auto;
    height:           15px;
    background-color: #1e1e1e;
    color:            #eee;
    border-radius:    2px;
    padding:          5px 10px 5px 10px;
    position:         absolute;
    z-index:          10000;
    bottom:           125%;
    left:             13px;
    top:              44px;
    font-family:      Inter;
    font-size:        11px;
}


.figma-light .tooltip
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.15),
                      0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark .tooltip
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.35),
                      0px 5px 22px rgba(0, 0, 0, 0.35),
                      0 0px 2px 0px #fff3 inset;
}


#tooltipArrow
{
    content:      '';
    position:     absolute;
    margin-left:  -6px;
    border-width: 6px;
    border-style: solid;
    border-color: transparent transparent #1e1e1e transparent;
    display:      none;
    opacity:      0%;
}


#ttCreateColorblind
{
    width:  200px; 
    height: 310px;
}


#ttInterpolationSpace
{
    width:  200px;
    height: 178px;
}


#ttWcag2
{
    width:  240px;
    height: 146px;
}



.wcag2description
{
    text-align:       left;
    position:         absolute;
    top:              70px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag2value
{
    position:  absolute;
    top:       109px;
    transform: translateX(-50%);
}


#wcag2info
{
    position:  absolute;
    left:      50%;
    top:       130px;
    transform: translateX(-50%);
}


#wcag2info a
{
    color: #6eb8e9
}


#ttWcag3
{
    width:  240px;
    height: 140px;
}


.wcag3description
{
    text-align:       left;
    position:         absolute;
    top:              62px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag3value
{
    position:  absolute;
    top:       101px;
    transform: translateX(-50%);
}


#wcag3info
{
    position:  absolute;
    left:      50%;
    top:       124px;
    transform: translateX(-50%);
}


#wcag3info a
{
    color: #6eb8e9
}


#selectBox
{
    outline:          1pt solid var(--figma-color-bg-brand);
    background-color: #18A0FB20;
    pointer-events:   none;
    margin:           0;
    padding:          0;
    position:         absolute;
    visibility:       hidden;
}


#scrollbarX
{
    background-color: var(--figma-color-text-tertiary);
    height:           6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    /* box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); */
}


#scrollbarY
{
    background-color: var(--figma-color-text-tertiary);
    width:            6px;
    border-radius:    3px;
    position:         absolute;
    display:          none;
    /* box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); */
}


.figma-light #scrollbarX { box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.25); }
.figma-dark  #scrollbarX { box-shadow: 0 0 0 1px rgba( 60,  60,  60, 0.25); }

.figma-light #scrollbarY { box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.25); }
.figma-dark  #scrollbarY { box-shadow: 0 0 0 1px rgba( 60,  60,  60, 0.25); }


:root
{
    --arithmeticSymbolSize: 26;
    --colorBackSize:        45px;
}


#graphView
{
    z-index:  0;
    display:  block;
    overflow: hidden;
    height:   calc(100% - 40px);
    position: relative;
}


#wireContainer
{
    position:       absolute;
    width:          100%;
    height:         calc(100% - 1px);
    z-index:        0;
    pointer-events: none;
    overflow:       hidden;
    /* box-shadow: 0 0 0 1px red inset; */
}


.menuButton
{
    display:       inline-block;
    font-family:   Inter;
    font-size:     11px;
    width:         50px;
    height:        40px;
    background:    #2c2c2c;
    border-radius: 0;
    min-width:     0;
    min-height:    0;
    border:        none;
    position:      relative;
    padding:       0;
    color:         #fff;
    overflow:      hidden;
    cursor:        default;
    /* box-shadow:    0 0 0 1px red inset; */
}


.menuButton:hover
{
    /* background: black; */
    color:      white;
}


/* .menuButton:focus
{
    background: var(--activeObjectColor);
    color:      white;
} */


.menuButtonIcon
{
    display:             inline-block;
    width:               30px;
    height:              40px;
    /* box-shadow: 0 0 0 1px yellow inset; */
}


.menuButtonArrow
{
    display:             inline-block;
    width:               20px;
    height:              40px;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="5" viewBox="0 0 8 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.507593 1.22627L1.2469 0.498783L4.01388 3.22151L6.78084 0.498783L7.52015 1.22627L4.01388 4.67648L0.507593 1.22627Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    transition:          0.25s;
    /* box-shadow:          0 0 0 1px magenta inset; */
}


.menu
{
    display:          none;
    opacity:          0;
    min-width:        200px;
    width:            auto;
    height:           fit-content;
    background-color: #1e1e1e;
    color:            #eee;
    padding:          8px 0 8px 0;
    border-radius:    2px;
    position:         absolute;
    z-index:          10000;
    bottom:           125%;
    left:             13px;
    top:              44px;
    font-family:      Inter;
    font-size:        11px;
}


.figma-light .menu
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.15),
                      0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark .menu
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.45),
                      0px 5px 25px rgba(0, 0, 0, 0.45),
                      0 0px 2px 0px #fff3 inset;
}


.menuArrow
{
    content:      '';
    position:     absolute;
    margin-left:  -5px;
    border-width: 5px;
    border-style: solid;
    border-color: transparent transparent #1e1e1e transparent;
    display:      none;
    opacity:      0%;
    z-index:      11000;
    box-shadow:   0 0px 2px 0px #fff3 inset;
}


.menuItem
{
    display:     inline-block;
    width:       100%;
    height:      auto;
    font-family: Inter;
    font-size:   12px;
    /* box-shadow:  0 0 0 1px red inset; */
}


.menuItemCheck
{
    display:             inline-block;
    width:               32px;
    height:              22px;
    background:          url('data:image/svg+xml;utf8,<svg width="9" height="9" viewBox="0 -2 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.31749 2.4477L3.42546 4.55569L7.64142 0.339716L8.9589 1.65721L3.42546 7.19067L0 3.76519L1.31749 2.4477Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    visibility:          hidden;
    /* box-shadow:          0 0 0 1px blue inset; */
}



.menuItemIcon
{
    display:             inline-block;
    width:               32px;
    height:              22px;
    /* box-shadow:          0 0 0 1px orange inset; */
    transform:           translateY(1px);
}


.menuItemName
{
    display:     inline-block;
    position:    relative;
    font-weight: 500;
    top:        -5px;
    /* box-shadow: 0 0 0 1px yellow inset; */
}


.menuItemExpand
{
    display:             inline-block;
    width:               48px;
    height:              22px;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="9" viewBox="0 -1 6 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 4L0 0V8L6 4Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    visibility:          hidden;
    position:            absolute;
    right:               0;
    /* box-shadow:          0 0 0 1px green inset; */
}


.menuItemShortcut
{
    display:               inline-block;
    position:              absolute;
    right:                 16px;
    transform:             translateY(5px);
    /* font-feature-settings: normal;*/
    font-variant-alternates:  stylistic(), styleset();
    font-feature-settings: 'salt' on, 'ss02' on;
    /* box-shadow: 0 0 0 1px green inset; */
}


.menuSeparator
{
    display:    inline-block;
    width:      100%;
    height:     1px;
    background: #383838;
    margin:     8px 0 8px 0;
}


#menuBar
{
    display:          flex;
    height:           40px;
    background-color: #2c2c2c;
    border-bottom:    1px solid var(--figma-color-bg-tertiary);
    padding:          0;
    cursor:           default;
    /* vertical-align:   middle; */
}



#btnCreateNumber
{
    padding-left:  15px;
    padding-right: 35px;
}


#btnZoom
{
    position:      absolute;
    padding-left:  15px;
    padding-right: 45px;
}


#btnToggleWires
{
    position:            absolute;
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="%23d5d5d5" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="%23d5d5d5"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnToggleWires:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="white" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="white"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}



#btnCreateInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.3"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="%23d5d5d5"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="white"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="white"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.5"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="white"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateValidateColor
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="%23d5d5d5"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateValidateColor:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorContrast
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="%23d5d5d5" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorContrast:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="white" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorBlind
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_603_2)"><path d="M9.33666 18.2036C14.1602 18.2036 18.0705 14.2933 18.0705 9.46972C18.0705 4.64614 14.1602 0.735851 9.33666 0.735851C4.51308 0.735851 0.60279 4.64614 0.60279 9.46972C0.60279 14.2933 4.51308 18.2036 9.33666 18.2036Z" stroke="black" stroke-width="0.919355" stroke-dasharray="1.84 1.84"/><path d="M9.33666 14.1487C11.9208 14.1487 14.0156 12.0538 14.0156 9.46972C14.0156 6.88562 11.9208 4.79079 9.33666 4.79079C6.75256 4.79079 4.65773 6.88562 4.65773 9.46972C4.65773 12.0538 6.75256 14.1487 9.33666 14.1487Z" stroke="black" stroke-width="0.919355"/><path d="M9.33666 10.5448C9.93043 10.5448 10.4118 10.0635 10.4118 9.46972C10.4118 8.87595 9.93043 8.39461 9.33666 8.39461C8.74289 8.39461 8.26155 8.87595 8.26155 9.46972C8.26155 10.0635 8.74289 10.5448 9.33666 10.5448Z" fill="black"/></g><defs><clipPath id="clip0_603_2"><rect width="19" height="19" fill="white"/></clipPath></defs></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorBlind:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15.2335" cy="15.4506" r="14.25" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="7.63405" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="1.75413" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateComment
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="18" height="16" viewBox="0 0 18 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5266L3.6897 11.0341C3.24801 10.1174 3 9.08908 3 8C3 4.13401 6.13401 1 10 1C13.866 1 17 4.13401 17 8C17 11.866 13.866 15 10 15C8.89526 15 7.85296 14.7448 6.92628 14.2911L6.65842 14.1599L6.36249 14.1969L1.94388 14.7492L3.64047 11.9923L3.92701 11.5266ZM0.671856 14.9082L0 16L1.27203 15.841L6.48652 15.1892C7.5471 15.7085 8.73951 16 10 16C14.4183 16 18 12.4183 18 8C18 3.58172 14.4183 0 10 0C5.58172 0 2 3.58172 2 8C2 9.24258 2.28329 10.419 2.78881 11.4682L0.671856 14.9082Z" fill="white" fill-opacity="1"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateComment:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="18" height="16" viewBox="0 0 18 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5266L3.6897 11.0341C3.24801 10.1174 3 9.08908 3 8C3 4.13401 6.13401 1 10 1C13.866 1 17 4.13401 17 8C17 11.866 13.866 15 10 15C8.89526 15 7.85296 14.7448 6.92628 14.2911L6.65842 14.1599L6.36249 14.1969L1.94388 14.7492L3.64047 11.9923L3.92701 11.5266ZM0.671856 14.9082L0 16L1.27203 15.841L6.48652 15.1892C7.5471 15.7085 8.73951 16 10 16C14.4183 16 18 12.4183 18 8C18 3.58172 14.4183 0 10 0C5.58172 0 2 3.58172 2 8C2 9.24258 2.28329 10.419 2.78881 11.4682L0.671856 14.9082Z" fill="white" fill-opacity="1"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


.figma-light .toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="black"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="black"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.figma-light .toggleButton:hover
{
    box-shadow: 0 0 0 1px #e6e6e6
}


.figma-light .toggleButton:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
}


.figma-dark .toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="white"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    color:               #ddd;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.figma-dark .toggleButton:hover
{
    box-shadow: 0 0 0 1px #777;
}


.figma-dark .toggleButton:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
}


.numberControl
{
    padding:          0;
    width:            74px;
    height:           20px;
    overflow:         hidden;
    background-color: var(--figma-color-bg);/*white;*/
    text-align:       center;
    touch-action:     none;
    /* box-shadow: 0 0 0 1px inset red;; */
}    


/* .figma-light .numberControlName
{
    color: #0006;
}


.figma-dark .numberControlName
{
    color: #fff6;
} */


.numberControlBar
{
    position:       absolute;
    pointer-events: none;
}


.numberControlText
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    pointer-events:       none;
    letter-spacing:       -0.35px;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    top:                  3px;
    white-space:          nowrap;
}


.numberControlText .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
}


.numberControlTextbox
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    width:                100%;
    white-space:          nowrap;
    background-color:     transparent;
}


.numberControlFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px var(--activeObjectColor) inset;
    visibility:     hidden;
    opacity:        0;
}


.numberControlRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}



.colorControl
{
    padding:          0;
    width:            74px;
    height:           26px;
    overflow:         hidden;
    background-color: var(--figma-color-bg);/*white;*/
    text-align:       center;
    touch-action:     none;
}    


.figma-light .colorControlName
{
    color: #0006;
}


.figma-dark .colorControlName
{
    color: #fff6;
}


.colorControlBar
{
    position:       absolute;
    pointer-events: none;
}


.colorControlText
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    pointer-events:       none;
    letter-spacing:       -0.35px;
    position:             relative;
    left:                 50%;
    transform:            translateX(-50%);
    top:                  3px;
    white-space:          nowrap;
}


.colorControlText .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
}


.colorControlTextbox
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    width:                100%;
    white-space:          nowrap;
    background-color:     transparent;
}


.colorControlFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px var(--activeObjectColor) inset;
    visibility:     hidden;
    opacity:        0;
}


.colorControlRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}




.menuSelect
{
    font-family:         Inter;
    font-size:           14;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         1;
    margin-right:        6;
    margin-top:          0;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
    color:               white;
}


.menuSelect:hover
{
    /* box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1); */
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) calc(50% + 3px);
    background-repeat:   no-repeat;
    padding-right:       30;
    transition:          all 0.2s ease;
}


.menuSelect:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.menuSelectText
{
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
    position:       relative;
    top:            3px;
}


.menuSelectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px  7px rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2 );
    /* overflow:      hidden; */
}


.menuSelectMenu::after 
{
    content:       '';
    position:      absolute;
    top:           -10px;
    left:          65px;
    border-width:  5px;
    border-style:  solid;
    border-color:  transparent transparent #222 transparent;
}




.select
{
    font-family:         Inter;
    font-size:           11;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         2;
    margin-right:        6;
    margin-top:          1;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.4"/> </svg>');
    background-position: calc(100% - 17px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
}


.select:hover
{
    box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1);
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 7px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
}


.select:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 6px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.selectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px 7px  rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2);
    overflow:      hidden;
}


.inputControls
{
    width:          12px;
    height:         auto;
    float:          left;
    margin-right:   auto;
    padding-top:    13px;
    /* box-shadow:     0 0 0 1px red inset; */
    pointer-events: none;
}


.input
{
    width:          6px;
    height:         6px;
    background:     transparent;
    border-radius:  3px;
    margin:         0;
    /* margin-left:    0px; */
    position:       absolute;
    left:           3px;
    pointer-events: none;
    box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12);
    z-index:        10;
}


.inputBall
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    top:            50%;
    left:           50%;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.inputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: auto;
}


.node
{
    display:       block;
    position:      absolute;
    height:        auto;
    border-radius: 4px 4px 0 0;
    padding:       0;
    /* overflow:      visible; */
    /* box-shadow:    0 0 0 1px orange inset; */
}


.nodeInner
{
    display:       block;
    position:      relative;
    width:         100%;
    height:        auto;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    padding:       0;
    box-shadow:    0 0 0 1px #0001;
    overflow:      visible;
}    


.nodeHeader
{
    background:    'magenta';
    display:       flex;
    width:         100%;
    position:      relative;
    border-radius: 4px 4px 0 0;
    z-index:       1;
    /* overflow:      visible; */
    /* box-shadow:    0 0 0 1px red inset; */
}


.nodeHeaderCheckers
{
    display:             inline-block;
    width:               100%;
    position:            absolute;
    left:                0;
    top:                 0; 
    border-radius:       4px 4px 0 0;
    z-index:             1;
    /* overflow:      visible; */
    /* box-shadow:    0 0 0 1px red inset; */
}


.nodeParamBack
{
    display:    block;
    position:   absolute;
    width:      100%;
    background: #fffe;
    z-index:    -1;
    /* box-shadow:    0 0 0 1px green inset; */
}


.nodeHiddenParamBack
{
    display:    block;
    position:   absolute;
    width:      100%;
    background: #fffe;
    z-index:    -1;
    /* box-shadow:    0 0 0 1px green inset; */
}


/* .paramSeparator
{
    display:    inline-block;
    width:      100%;
    height:     10;
    background: #fffe;
    /* box-shadow:    0 0 0 1px green inset;
} */


.nodeLabelWrapper
{
    position:   absolute;
    width:      100%;
    height:     100%;   
    /* box-shadow: 0 0 0 1px blue inset; */
}


.nodeLabel
{
    font-family:    Inter;
    font-size:      11;
    padding:        0;
    margin:         0;
    display:        block;
    width:          auto;
    height:         14;
    text-align:     center;
    position:       absolute;
    /* left:           50%;
    top:            50%; */
    /* transform:      translateX(-50%) 
                    translateY(calc(-50% - 0.5px)); */
    pointer-events: none;
    z-index:        10;
    white-space:    nowrap;
    /* box-shadow:     0 0 0 1px magenta inset; */
}


.nodeLabelTextbox
{
    font-family: Inter;
    font-size:   11;
    /* box-shadow:  0 0 0 1px #a0a inset; */
    overflow:    visible;
}


.nodeLabelTextbox::selection
{
    background-color: white;
}


.arithmeticSymbol
{
    font-family:    Inter;
    font-size:      20px;
    width:          auto;/*var(--arithmeticSymbolSize);*/
    height:         auto;/*var(--arithmeticSymbolSize);*/
    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);
    /* pointer-events: none; */
    /* box-shadow:     0 0 0 1px red inset; */
}


.colorWarningOverlay
{
    width:            100%;
    height:           var(--colorBackSize);
    z-index:          10;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.colorValueWarningOverlay
{
    width:            100%;
    z-index:          1000;
    position:         absolute;
    top:              var(--colorBackSize);
    pointer-events:   none;
}


.colorBack
{
    width:            100%;
    height:           var(--colorBackSize);
    z-index:          0;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


/* .hexbox
{
    text-align:  center;
    width:       100%;
    background:  transparent;
    cursor:      default;
}


.hexbox:hover
{
    box-shadow: 0 1px 0 0 rgba(0, 0, 0, 0.1) inset;
} */


.txtOrder
{
    text-align:  center;
    width:       100%;
    background:  transparent;
    cursor:      default;
}


.txtOrder:hover
{
    box-shadow: 0  1px 0 0 rgba(0, 0, 0, 0.1) inset,
                0 -1px 0 0 rgba(0, 0, 0, 0.1) inset;
}


/* .paramLock
{
    width:               11px;
    height:              11px;
    position:            absolute;
    display:             none;
} */


.findColorCorrection
{
    display:             block;
    width:               10px;
    height:              10px;
    position:            absolute;
    left:                50%;
    top:                 50%;
    transform:           translateX(-50%)
                         translateY(-50%);
    /* box-shadow:          0 0 0 1 red inset; */
    background:          url('data:image/svg+xml;utf8,<svg width="10" height="10" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.10345 5.05172C8.10345 7.01329 6.51329 8.60345 4.55172 8.60345C2.59016 8.60345 1 7.01329 1 5.05172C1 3.09016 2.59016 1.5 4.55172 1.5C6.51329 1.5 8.10345 3.09016 8.10345 5.05172ZM7.39723 8.60458C6.61787 9.22958 5.62846 9.60345 4.55172 9.60345C2.03788 9.60345 0 7.56557 0 5.05172C0 2.53788 2.03788 0.5 4.55172 0.5C7.06557 0.5 9.10345 2.53788 9.10345 5.05172C9.10345 6.12858 8.72949 7.1181 8.10436 7.8975L11.3535 11.1467L10.6464 11.8538L7.39723 8.60458Z" fill="black" fill-opacity="0.8"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


.findBar
{
    position:      absolute;
    left:          50%;
    top:           66%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         46px;
    height:        3px;   
    background:    transparent;
    border-radius: 2.5px;
    overflow:      hidden;
    display:       none;
}


.findProgress
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         0;
    height:        5px;   
    background:    #333;
}


.asterisk
{
    font-size: 8px;
    position:  relative;
    top:       -2px;
}


.outputControls
{
    width:          12px;
    height:         auto;
    float:          right;
    margin-left:    auto;
    padding-top:    10px;
    /* box-shadow:     0 0 0 1px green inset; */
    pointer-events: none;
}


.output
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    /* margin-left:    3px; */
    position: absolute;
    right:          3px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
    z-index:        10;
}


.outputBall
{
    width:          6px;
    height:         6px;
    border-radius:  6px;
    margin:         0;
    position:       relative;
    top:            -12px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.outputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: auto;
}


</style>

<div id='menuBar'>
    <!-- <div id='menuSelect' style='margin-left: 10px;'></div> -->
    
    <!-- &nbsp;
    <button class='menuButton' id='btnLoad'                   onclick='graph.clear(); Operator.nextId = 0; uiGetPageData("graph"); this.blur();'>LOAD</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    <button class='menuButton' id='btnSave'                   onclick='saveGraph(); this.blur();'>SAVE</button>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnCreateNumber'           onclick='actionManager.do(new CreateNodeAction(NUMBER,             btnCreateNumber          ));  this.blur();'><span style='font-size: 13px; letter-spacing: -0.05em;'>123</span></button> -->
    <!-- <button class='menuButton' id='btnCreateLimits'           onclick='actionManager.do(new CreateNodeAction(NUMBER_LIMITS,      btnCreateLimits          ));  this.blur();'><span style='font-size: 8px;'>MAX<br/>MIN</span></button> -->
    <!-- <button class='menuButton' id='btnCreateAdd'              onclick='actionManager.do(new CreateNodeAction(NUMBER_ADD,         btnCreateAdd             ));  this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'>+</span></button> -->
    <!-- <button class='menuButton' id='btnCreateSubtract'         onclick='actionManager.do(new CreateNodeAction(NUMBER_SUBTRACT,    btnCreateSubtract        ));  this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'></span></button> -->
    <!-- <button class='menuButton' id='btnCreateMultiply'         onclick='actionManager.do(new CreateNodeAction(NUMBER_MULTIPLY,    btnCreateMultiply        ));  this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'></span></button> -->
    <!-- <button class='menuButton' id='btnCreateDivide'           onclick='actionManager.do(new CreateNodeAction(NUMBER_DIVIDE,      btnCreateDivide          ));  this.blur();'><span style='font-size: 22px; position: relative; top: -1px;'></span></button> -->
    <!-- <button class='menuButton' id='btnCreateModulo'           onclick='actionManager.do(new CreateNodeAction(NUMBER_MODULO,      btnCreateModulo          ));  this.blur();'><span style='font-size: 15px;'>%</span></button> -->
    <!-- <button class='menuButton' id='btnCreateExponent'         onclick='actionManager.do(new CreateNodeAction(NUMBER_EXPONENT,    btnCreateExponent        ));  this.blur();'><span style='font-size: 16px;'>x<sup><sub><sup>y</sup></sub></sup></span></button> -->
    <!-- <button class='menuButton' id='btnCreateInterpolate'      onclick='actionManager.do(new CreateNodeAction(NUMBER_INTERPOLATE, btnCreateInterpolate     ));  this.blur();'></button> -->
    <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnCreateColor'            onclick='actionManager.do(new CreateNodeAction(COLOR,              btnCreateColor           ));  this.blur();'><span style='font-size: 17px;'></span></button> -->
    <!-- <button class='menuButton' id='btnCreateColorInterpolate' onclick='actionManager.do(new CreateNodeAction(COLOR_INTERPOLATE,  btnCreateColorInterpolate));  this.blur();'></button> -->
    <!-- <button class='menuButton' id='btnCreateValidateColor'    onclick='actionManager.do(new CreateNodeAction(COLOR_VALIDATE,     btnCreateValidateColor   ));  this.blur();'></span></button> -->
    <!-- <button class='menuButton' id='btnCreateColorContrast'    onclick='actionManager.do(new CreateNodeAction(COLOR_CONTRAST,     btnCreateColorContrast   ));  this.blur();'></button> -->
    <!-- <button class='menuButton' id='btnCreateColorblind'       onclick='actionManager.do(new CreateNodeAction(COLORBLIND,         btnCreateColorblind      ));  this.blur();'></button> -->
    <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnCreateFill'             onclick='actionManager.do(new CreateNodeAction(FILL,               btnCreateFill            ));  this.blur();'>FILL</button> -->
    <!-- <button class='menuButton' id='btnCreateStroke'           onclick='actionManager.do(new CreateNodeAction(STROKE,             btnCreateStroke          ));  this.blur();'>STRK</button> -->
    <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnCreateRectangle'        onclick='actionManager.do(new CreateNodeAction(RECTANGLE,          btnCreateRectangle       ));  this.blur();'>RECT</button> -->
    <!-- <button class='menuButton' id='btnCreateLine'             onclick='actionManager.do(new CreateNodeAction(LINE,               btnCreateLine            ));  this.blur();'>LINE</button> -->
    <!-- <button class='menuButton' id='btnCreateEllipse'          onclick='actionManager.do(new CreateNodeAction(ELLIPSE,            btnCreateEllipse         ));  this.blur();'>ELPS</button> -->
    <!-- <button class='menuButton' id='btnCreatePolygon'          onclick='actionManager.do(new CreateNodeAction(POLYGON,            btnCreatePolygon         ));  this.blur();'>POLY</button> -->
    <!-- <button class='menuButton' id='btnCreateStar'             onclick='actionManager.do(new CreateNodeAction(STAR,               btnCreateStar            ));  this.blur();'>STAR</button> -->
    <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnCreateColorStop'        onclick='actionManager.do(new CreateNodeAction(COLOR_STOP,         btnCreateColorStop       ));  this.blur();'>STP</button> -->
    <!-- <button class='menuButton' id='btnCreateGradient'         onclick='actionManager.do(new CreateNodeAction(GRADIENT,           btnCreateGradient        ));  this.blur();'>GRD</button> -->
    <!-- <button class='menuButton' id='btnCreateColorStroke' onclick='actionManager.do(new CreateNodeAction(COLOR_STROKE,       btnCreateColorStroke));  this.blur();'>CSTK</button> -->
    <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnCreateComment'          onclick='actionManager.do(new CreateNodeAction(COMMENT,            btnCreateComment         ));  this.blur();'></button> -->
    <!-- <button class='menuButton' id='btnCreateRow'              onclick='actionManager.do(new CreateNodeAction("row",              btnCreateRow        ));  this.blur();'>ROW</button> -->
    <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -->
    <!-- <button class='menuButton' id='btnToggleWires'            onclick='graphView.toggleShowWires(); this.blur();'></button> -->

    <!-- <button class='menuButton' id='btnZoom'                   onclick='graphView.zoom = 1; this.blur();'></button> -->
    
</div>
    


<div id='graphView'>
    <div id="wireContainer"></div>
    <div id='scrollbarX'></div>
    <div id='scrollbarY'></div>
</div>

<div id='selectBox'></div>



<div id='loadingOverlay'>
    <div id='loadingGraphic'>
        <svg id="loadingEmpty" width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 7C5.65685 7 7 5.65685 7 4C7 2.34315 5.65685 1 4 1C2.34315 1 1 2.34315 1 4C1 5.65685 2.34315 7 4 7ZM8 4C8 6.20914 6.20914 8 4 8C1.79086 8 0 6.20914 0 4C0 1.79086 1.79086 0 4 0C6.20914 0 8 1.79086 8 4Z" fill="white"/></svg>
        <svg id="loadingG"     width="21" height="24" viewBox="0 0 21 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M16.4398 7.77947C16.2474 7.1635 15.9819 6.61217 15.6432 6.12548C15.3123 5.63118 14.912 5.20913 14.4426 4.85932C13.9808 4.50951 13.4497 4.24715 12.8494 4.07224C12.249 3.88973 11.5948 3.79848 10.8868 3.79848C9.61682 3.79848 8.48543 4.11407 7.49258 4.74525C6.49973 5.37643 5.71853 6.30418 5.14898 7.52852C4.58714 8.74525 4.30621 10.2281 4.30621 11.9772C4.30621 13.7414 4.58714 15.2357 5.14898 16.4601C5.71083 17.6844 6.49203 18.616 7.49258 19.2548C8.49313 19.8859 9.65531 20.2015 10.9791 20.2015C12.1798 20.2015 13.2188 19.9734 14.0962 19.5171C14.9813 19.0608 15.6625 18.4144 16.1396 17.5779C16.6168 16.7338 16.8554 15.7452 16.8554 14.6122L17.8252 14.7605H11.4063V11.4525H21V14.2586C21 16.2586 20.569 17.9886 19.707 19.4487C18.845 20.9087 17.6597 22.0342 16.1512 22.8251C14.6427 23.6084 12.9109 24 10.956 24C8.7779 24 6.86531 23.5171 5.21825 22.5513C3.57889 21.5779 2.29742 20.1977 1.37383 18.4106C0.457944 16.616 0 14.4867 0 12.0228C0 10.1369 0.269379 8.45247 0.808136 6.96958C1.35459 5.48669 2.11655 4.22814 3.09401 3.19392C4.07147 2.15209 5.21825 1.36122 6.53436 0.821293C7.85047 0.273764 9.28202 0 10.829 0C12.1374 0 13.3573 0.190114 14.4887 0.570342C15.6201 0.942966 16.6245 1.47529 17.5019 2.1673C18.387 2.85932 19.1143 3.68061 19.6839 4.63118C20.2534 5.58175 20.6267 6.63118 20.8037 7.77947H16.4398Z" fill="white"/></svg>
        <svg id="loadingFull"  width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 4C8 6.20914 6.20914 8 4 8C1.79086 8 0 6.20914 0 4C0 1.79086 1.79086 0 4 0C6.20914 0 8 1.79086 8 4Z" fill="white"/></svg>

        <div id='loadingBar'>
            <div id='loadingProgress'></div>
        </div>
    </div>
</div>


<div id='productKeyBack'></div>

<div id='productKeyDialog'>

    <div id='productKeyTitle'>
        <div id='productKeyText'>Enter product key</div>
        <div class='button' id='productKeyClose' onclick='productKeyClose.blur();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="black" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='productKeyBody'>
        <div id='productKeyUserInfo'></div>
        <input type='text' id='productKeyInput' />
        <div id='productKeyInputBack'></div>
        <div id='productKeyWebsite'>Get product key at<br/><a href='http://www.bourt.com/generator' target='_blank'>bourt.com/generator</a></div>
    </div>

</div>


<span id='tooltipArrow'></span>


<div id='ttCreateNumber'      class='tooltip'>Number</div>
<div id='ttCreateLimits'      class='tooltip'>Limits</div>
<div id='ttCreateAdd'         class='tooltip'>Add</div>
<div id='ttCreateSubtract'    class='tooltip'>Subtract</div>
<div id='ttCreateMultiply'    class='tooltip'>Multiply</div>
<div id='ttCreateDivide'      class='tooltip'>Divide</div>
<div id='ttCreateModulo'      class='tooltip'>Remainder</div>
<div id='ttCreateExponent'    class='tooltip'>Power</div>
<div id='ttCreateInterpolate' class='tooltip'>Interpolate</div>


<div id='ttCreateColor' class='tooltip'>Color</div>
<div id='ttCreateColorInterpolate' class='tooltip'>Interpolate color</div>
<div id='ttCreateValidateColor' class='tooltip'>Validate color</div>
<div id='ttCreateColorContrast' class='tooltip'>Web contrast</div>

<div id='ttCreateColorblind' class='tooltip'>

    <div style="text-align: center;">Colorblind</div>
    
    <div style='margin-top: 14px; margin-bottom: 10px;'>
        Three receptor cone types in our eyes<br/>
        see <i>three calibers of light</i>&ThinSpace;:<br/><br/>
        <p style='margin-top: 4px; margin-bottom: 20px;'><b>S</b>mall, <b>M</b>edium and <b>L</b>arge.</p>
    </div>

    <svg width="189" height="97" viewBox="0 0 189 97" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: relative; left: 5px">
        <path d="M64.3525 17.3547C63.1278 17.3547 62.0721 1.13879 60.8053 1.13879C59.5384 1.13879 58.4827 17.3547 57.258 17.3547" stroke="white"/>
        <path d="M84.3644 10.4618C83.8577 8.49826 82.9076 1.13879 82.0886 1.13879C80.8217 1.13879 79.766 17.3547 78.5414 17.3547" stroke="white"/>
        <path d="M78.5414 17.3547C77.3167 17.3547 76.261 1.13879 74.9942 1.13879C73.7273 1.13879 72.6716 17.3547 71.4469 17.3547" stroke="white"/>
        <path d="M71.4469 17.3547C70.2223 17.3547 69.1666 1.13879 67.8997 1.13879C66.6328 1.13879 65.5771 17.3547 64.3525 17.3547" stroke="white"/>
        <path d="M35.9747 17.3547C34.75 17.3547 33.6943 1.13879 32.4274 1.13879C31.1606 1.13879 30.1049 17.3547 28.8802 17.3547" stroke="white"/>
        <path d="M57.258 17.3547C56.0334 17.3547 54.9776 1.13879 53.7108 1.13879C52.4439 1.13879 51.3882 17.3547 50.1635 17.3547" stroke="white"/>
        <path d="M50.1636 17.3547C48.9389 17.3547 47.8832 1.13879 46.6163 1.13879C45.3495 1.13879 44.2938 17.3547 43.0691 17.3547" stroke="white"/>
        <path d="M43.0691 17.3547C41.8445 17.3547 40.7887 1.13879 39.5219 1.13879C38.255 1.13879 37.1993 17.3547 35.9746 17.3547" stroke="white"/>
        <path d="M7.59684 17.3547C6.3722 17.3547 5.31647 1.13879 4.04961 1.13879C2.78274 1.13879 1.72702 17.3547 0.50238 17.3547" stroke="white"/>
        <path d="M28.8802 17.3547C27.6556 17.3547 26.5998 1.13879 25.333 1.13879C24.0661 1.13879 23.0104 17.3547 21.7857 17.3547" stroke="white"/>
        <path d="M21.7857 17.3547C20.5611 17.3547 19.5054 1.13879 18.2385 1.13879C16.9716 1.13879 15.9159 17.3547 14.6913 17.3547" stroke="white"/>
        <path d="M14.6913 17.3547C13.4666 17.3547 12.4109 1.13879 11.144 1.13879C9.87716 1.13879 8.82144 17.3547 7.5968 17.3547" stroke="white"/>
        <path d="M26.1023 49.8573C21.6833 49.8573 17.8738 28.2361 13.3023 28.2361C8.73093 28.2361 4.92142 49.8573 0.50238 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M97.2868 40.4082C95.3801 36.1644 93.2103 28.2361 90.1022 28.2361C85.5307 28.2361 81.7212 49.8573 77.3022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M77.3021 49.8573C72.8831 49.8573 69.0736 28.2361 64.5022 28.2361C59.9308 28.2361 56.1212 49.8573 51.7022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M51.7022 49.8573C47.2832 49.8573 43.4737 28.2361 38.9023 28.2361C34.3308 28.2361 30.5213 49.8573 26.1023 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M130.23 95.5318C119.033 95.5318 109.381 65.8027 97.7978 65.8027C86.215 65.8027 76.5627 95.5318 65.366 95.5318" stroke="white" stroke-width="2"/>
        <path d="M65.366 95.5318C54.1693 95.5318 44.517 65.8027 32.9342 65.8027C21.3514 65.8027 11.6991 95.5318 0.50238 95.5318" stroke="white" stroke-width="2"/>
        <circle cx="133.608" cy="79.9916" r="15.8916" stroke="white" stroke-width="2"/>
        <circle cx="133.608" cy="79.9916" r="15.8916" stroke="white" stroke-width="2"/>
        <circle cx="133.608" cy="79.9916" r="15.8916" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="14.3697" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="14.3697" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="14.3697" stroke="white" stroke-width="2"/>
        <circle cx="105.364" cy="39.0467" r="7.78361" stroke="white" stroke-width="2"/>
        <circle cx="105.364" cy="39.0467" r="7.78361" stroke="white" stroke-width="2"/>
        <circle cx="105.364" cy="39.0467" r="7.78361" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0468" r="8.38539" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0468" r="8.38539" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0468" r="8.38539" stroke="white" stroke-width="2"/>
        <circle cx="87.3593" cy="9.85939" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="87.3593" cy="9.85939" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="87.3593" cy="9.85939" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="2.37831" stroke="white" stroke-width="2"/>
        <circle cx="173.156" cy="39.0467" r="2.37831" stroke="white" stroke-width="2"/>
    </svg>
                                                                      
    <div style='margin-top: 20px; margin-bottom: -5px;'>
        If one or more are defective or absent,<br/>
        we call that <i>color blindness</i>.
    </div>
       
    <div style='margin-top: 16;'>
        Set the condition of each cone type<br/>
        to simulate all types of color vision deficiency.
    </div>

</div>


<div id='ttToggleWires' class='tooltip'>Show&thinsp;/&thinsp;hide wires</div>


<div id='ttInterpolationSpace' class='tooltip'>

    <div>
        The color space determines<br/>the path of interpolation.
    </div>
    <div style="margin-top: 14px;">
        Through RGB it goes in a straight line,<br/>through spaces with Hue &mdash; in a circle.
    </div>

    <div style="position: absolute; left:  47px; top: 110px;">RGB</div>
    <div style="position: absolute; left: 152px; top: 110px;">HCL</div>

    <svg width="192" height="88" viewBox="0 0 192 88" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-top: 13px; margin-left: 4px;">
        <circle cx="43.945" cy="43.6699" r="42.9129" transform="rotate(164.053 43.945 43.6699)" stroke="white"/>
        <circle cx="148.459" cy="43.6699" r="42.9129" transform="rotate(164.053 148.459 43.6699)" stroke="white"/>
        <path d="M177.161 53.8683C175.042 59.8328 171.117 64.9889 165.932 68.6199C160.747 72.2509 154.56 74.1764 148.23 74.1287C141.9 74.081 135.743 72.0626 130.613 68.3539C125.484 64.6453 121.637 59.4307 119.607 53.4349" stroke="white" stroke-width="0.8" stroke-dasharray="2 2"/>
        <circle cx="16.6584" cy="54.5167" r="2.79505" transform="rotate(164.053 16.1584 54.5167)" fill="white"/>
        <circle cx="71.0077" cy="54.5167" r="2.79505" transform="rotate(164.053 71.5077 54.4231)" fill="white"/>
        <circle cx="121.173" cy="54.5167" r="2.79505" transform="rotate(164.053 120.673 54.5167)" fill="white"/>
        <circle cx="175.522" cy="54.5167" r="2.79505" transform="rotate(164.053 176.022 54.4231)" fill="white"/>
        <line x1="72.3693" y1="54.0053" x2="15.8716" y2="54.0053" stroke="white" stroke-dasharray="2 2"/>
    </svg>

</div>


<!-- <div id='ttInterpolationGamma' class='tooltip'>
    <div style="text-align: center;">Gamma correction</div>              
    <div style="margin-top: 14px;">How linearly the lightness is interpolated.</div>
</div> -->


<div id='ttWcag2' class='tooltip'>

    <div style='text-align: center;'>Contrast ratio</div>
    
    <div class='wcag2description' style='left: 50px;'>min. normal  </div>
    <div class='wcag2description' style='left: 71px;'>min. reduced </div>
    <div class='wcag2description' style='left: 93px;'>min. assisted</div>
    <div class='wcag2description' style='left: 115px;'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vision</div>

    <svg width="221" height="21" viewBox="0 0 221 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 20px; top: 86px">
        <path d="M220.452 20.2466H70.0214V10.7924H220.452V20.2466Z" fill="white" fill-opacity="0.4"/>
        <path d="M30.0214 0V20.2466" stroke="white"/>
        <path d="M45.0214 0V20.2466" stroke="white"/>
        <path d="M70.0214 0V20.2466" stroke="white"/>
        <rect x="0.0214233" y="10.7924" width="30" height="9.45416" fill="#FF7048" fill-opacity="0.5"/>
        <rect x="30.0214" y="10.7924" width="15" height="9.45416" fill="#FFFF36" fill-opacity="0.5"/>
        <rect x="45.0214" y="10.7924" width="25" height="9.45416" fill="#4FFE15" fill-opacity="0.5"/>
    </svg>
        
    <div class='wcag2value' style='left:  18px;'> 0  </div>
    <div class='wcag2value' style='left:  48px;'> 3  </div>
    <div class='wcag2value' style='left:  68px;'> 4.5</div>
    <div class='wcag2value' style='left:  90px;'> 7  </div>
    <div class='wcag2value' style='left: 239px;'>21  </div>

    <div id='wcag2info'><a href='https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html#visual-audio-contrast7-87-head' target='_blank'>More details</a></div>
</div>


<div id='ttWcag3' class='tooltip'>

    <div style='text-align: center;'>APCA visual contrast</div>
    
    <div class='wcag3description' style='left:  52px;'>discernible</div>
    <div class='wcag3description' style='left:  84px;'>minimum</div>
    <div class='wcag3description' style='left: 117px;'>large text</div>
    <div class='wcag3description' style='left: 148px;'>other text</div>
    <div class='wcag3description' style='left: 179px;'>body text</div>
    <div class='wcag3description' style='left: 211px;'>all text</div>

    <svg width="222" height="21" viewBox="0 0 222 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 19px; top: 78px">
        <rect x="0.854492" y="10.7924" width="31.5139" height="9.45416" fill="#FF0040" fill-opacity="0.5"/>
        <rect x="32.3684" y="10.7924" width="31.5139" height="9.45416" fill="#FF7048" fill-opacity="0.5"/>
        <rect x="63.8822" y="10.7924" width="31.5139" height="9.45416" fill="#FFB92F" fill-opacity="0.5"/>
        <rect x="95.3961" y="10.7924" width="31.5139" height="9.45416" fill="#FFFF36" fill-opacity="0.5"/>
        <rect x="126.91" y="10.7924" width="31.5139" height="9.45416" fill="#4FFE15" fill-opacity="0.5"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 158.424 20.2466)" fill="#7070FF" fill-opacity="0.7"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 189.938 20.2466)" fill="white" fill-opacity="0.4"/>
        <line x1="32.8684" x2="32.8684" y2="20.2466" stroke="white"/>
        <line x1="64.3822" x2="64.3822" y2="20.2466" stroke="white"/>
        <line x1="95.8961" x2="95.8961" y2="20.2466" stroke="white"/>
        <line x1="127.41" x2="127.41" y2="20.2466" stroke="white"/>
        <line x1="158.924" x2="158.924" y2="20.2466" stroke="white"/>
        <line x1="190.438" x2="190.438" y2="20.2466" stroke="white"/>
    </svg>

    <div class='wcag3value' style='left:  20px;'>  0</div>
    <div class='wcag3value' style='left:  52px;'> 15</div>
    <div class='wcag3value' style='left:  84px;'> 30</div>
    <div class='wcag3value' style='left: 114px;'> 45</div>
    <div class='wcag3value' style='left: 147px;'> 60</div>
    <div class='wcag3value' style='left: 179px;'> 75</div>
    <div class='wcag3value' style='left: 210px;'> 90</div>
    <div class='wcag3value' style='left: 239px;'>105</div>

    <div id='wcag3info'><a href='https://www.myndex.com/APCA/#font-size-and-weight' target='_blank'>More details</a></div>
</div>


<script id='generatorScript' type='javascript/worker'>



const smallScrollGap =  6;
const largeScrollGap = 14;

const MAX_INT32      = 2147483647;

const NULL           = '';

const TAB            = '  ';
const NL             = '\n';

const GEN_LOGO       = 'G';


function rgbFromType(type, active)
{
    switch (type)
    {
        case NUMBER_VALUE:    
        case NUMBER:    
        case NUMBER_LIMITS:
        case NUMBER_ADD:
        case NUMBER_SUBTRACT:
        case NUMBER_MULTIPLY:
        case NUMBER_DIVIDE:
        case NUMBER_MODULO:
        case NUMBER_EXPONENT:
        case NUMBER_INTERPOLATE: 
            return active 
                ? (isDarkMode() ? rgbActiveNumberDark : rgbActiveNumberLight)
                : (isDarkMode() ? rgbNumberDark       : rgbNumberLight      );

        case COLOR_VALUE:           

        case COLOR:           
        case COLOR_INTERPOLATE:
        case COLOR_VALIDATE:
        case COLOR_CONTRAST:
        case COLORBLIND:
            return active 
                 ? rgbActiveColor  
                 : rgbColor;

        case SHAPE_VALUE:
        case RECTANGLE_VALUE: 
        case LINE_VALUE: 
        case ELLIPSE_VALUE: 
        case POLYGON_VALUE: 
        case STAR_VALUE: 
        
        case RECTANGLE: 
        case LINE: 
        case ELLIPSE: 
        case POLYGON: 
        case STAR: 
        
        case FILL_VALUE:
        case STROKE_VALUE:
            
        case FILL:
        case STROKE:
            return active 
                ? (isDarkMode() ? rgbActiveObjectDark : rgbActiveObjectLight)
                : (isDarkMode() ? rgbObjectDark       : rgbObjectLight      );
    }

    return 'magenta';
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     var str = Number(num).toFixed(dec).toString();

//     var i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    let last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function beforeLastOf(array)
{
    return array.length > 1 
         ? array[array.length-2]
         : null;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}


function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function equal(a, b)
{
    return Math.abs(b - a) < Eps;
}



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1v2 = v1v2sin "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 22 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return point(this.l, this.t); }
    get tc() { return point(this.c, this.t); }
    get tr() { return point(this.r, this.t); }
    get ml() { return point(this.l, this.m); }
    get mc() { return point(this.c, this.m); }
    get cm() { return point(this.c, this.m); }
    get mr() { return point(this.r, this.m); }
    get bl() { return point(this.l, this.b); }
    get bc() { return point(this.c, this.b); }
    get br() { return point(this.r, this.b); }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function countToString(items, itemName)
{
    return itemName + (items.length == 1 ? '' : 's');
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');//getUserDecimalSeparator());
    const commaIndex = strValue.indexOf(',');//getUserDecimalSeparator());

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hide(element)              
{ 
    show(element, false); 
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function isEmpty(array)
{
    return array.length == 0;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function removeFromArray(array, item)
{
    var index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeFromArrayWhere(array, where)
{
    var index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function boolString(bool)
{
    return bool ? 'true' : 'false';
}



function printNum(num)
{
    return !isNaN(num) ? num : INVALID;
}



function parseNum(str)
{
    return str == '?' ? Number.NaN : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return '';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return ' ';
    }
}



function parseBool(str)
{
    return str === 'true';
}



function osCtrl()  { return isMac ? '' : 'Ctrl+';  }
function osAlt()   { return isMac ? '' : 'Alt+';   }
function osShift() { return isMac ? ''  : 'Shift+'; }


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function enableElementText(elem, enable)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 
    elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



// function readTextFromClipboard() 
// {
//     if (   navigator.clipboard 
//         && window.isSecureContext) 
//         return navigator.clipboard.readText();

//     else 
//     {
//         let textArea = document.createElement('textarea');

//         textArea.style.position = 'fixed';
//         textArea.style.left     = '-999999px';
//         textArea.style.top      = '-999999px';
        
//         document.body.appendChild(textArea);
        
//         textArea.focus();
//         textArea.select();
        
//         return new Promise((res, rej) => 
//         {
//             document.execCommand('paste') ? res(textArea.value) : rej();
//             textArea.remove();
//         });
//     }
// }


const nodeTag = 'G_NODE';
const connTag = 'G_CONN';



function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


function nodeArrayToString(nodes)
{
    let str = '';

    for (let i = 0; i < nodes.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodes[i] ? nodes[i].id : 'undefined';
    }

    return str;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + TAB.repeat(Math.max(0, this.nTab)); 
    }
}



function logFunction(funcName)
{
    console.log(
        '%c ' + funcName + ' ', 
        'background: #09f; color: white;');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = ' ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nValues = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + TAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nValues;

        newLine = true;

        nTab++;

        for (let j = 0; j < nValues; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + TAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'background: #ddeeff');
}


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = ' ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReqNodeId(node)
{
    return ' ' 
         + logReqId(node.nodeId)
         + logReqOptions(node);
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if (node.options.active)
        log += ' ' + ACTIVE;

    if (node.options.beforeActive)
        log += ' ' + BEFORE_ACTIVE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}


function logReqNumberValue(val, parse)
{
    parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
}



function logReqNumber(num, parse)
{
    parse.log += parse.tab + NUMBER;
    parse.log += logReqNodeId(num);
}



function logReqLimits(lim, nValues, parse)
{
    parse.log += parse.tab + NUMBER_LIMITS;
    parse.log += logReqNodeId(lim);

    if (nValues > -1)
        parse.log += ' ' + nValues;
}



function logReqArithmetic(arith, type, nValues, parse)
{
    parse.log += parse.tab + type;
    parse.log += logReqNodeId(arith);
    parse.log += ' ' + nValues;
}



function logReqInterpolate(lerp, nValues, parse)
{
    parse.log += parse.tab + NUMBER_INTERPOLATE;
    parse.log += logReqNodeId(lerp);
    parse.log += ' ' + nValues;
}


function logReqColorValue(val, parse)
{
    parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
}



function logReqColor(col, parse) 
{
    logReqNode(col, parse); 
}



function logReqColorInterpolate(lerp, nValues, parse)
{
    parse.log += parse.tab + COLOR_INTERPOLATE;
    parse.log += logReqNodeId(lerp);
    parse.log += ' ' + nValues;
}



function logReqColorContrast(lerp, nValues, valueIndex, parse)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp);
    parse.log += ' ' + nValues;

    if (nValues == 1)
        parse.log += ' ' + valueIndex;
}



function logReqColorBlind(cb, parse)
{
    parse.log += parse.tab + COLORBLIND;
    parse.log += logReqNodeId(cb);
}



function logReqColorValidate(val, parse)
{
    parse.log += parse.tab + COLOR_VALIDATE;
    parse.log += logReqNodeId(val);
}


function logReqFillValue(fill, parse)
{
    parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
}



function logReqFill(fill, parse)
{
    parse.log += parse.tab + fill.type;
    parse.log += logReqNodeId(fill);
}



function logReqStrokeValue(stroke, parse)
{
    parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
}



function logReqStroke(stroke, parse)
{
    parse.log += parse.tab + stroke.type;
    parse.log += logReqNodeId(stroke);
}



function logReqColorStopValue(stop, parse)
{
    parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
}



function logReqColorStop(stop, parse)
{
    parse.log += parse.tab + stop.type;
    parse.log += logReqNodeId(stop);
}


function logReqShape(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;


class NoiseSeed
{
    initial;
    current;

    
    constructor()
    {
        this.reset();
    }
    
    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    
    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    
    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }

    reset()
    {
        this.current = this.initial;
    }
};


class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        var next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


const INVALID             = '?';
const DISPLAY_INVALID     = INVALID;//'';


const NUMBER_VALUE        = 'N';     // value (s) (with significant decimals)

const NUMBER              = 'NUM';   // N | n
const NUMBER_LIMITS       = 'LIM';   // N:min N:max
const NUMBER_ADD          = 'ADD';   // count N...
const NUMBER_SUBTRACT     = 'SUB';   // count N...
const NUMBER_MULTIPLY     = 'MUL';   // count N...
const NUMBER_DIVIDE       = 'DIV';   // count N...
const NUMBER_MODULO       = 'MOD';   // count N...
const NUMBER_EXPONENT     = 'EXP';   // count N...
const NUMBER_MATH         = 'MATH';  // op count N...
const NUMBER_INTERPOLATE  = 'LERP';  // count N... N:amount


const NUMBER_TYPES =
[
    NUMBER_VALUE,

    NUMBER,
    NUMBER_LIMITS,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT,
    NUMBER_MATH,
    NUMBER_INTERPOLATE 
];


const STRING_VALUE        = 'S';     // "..." (s) (escape \\ and \")

const STRING              = 'STR';   // S | s
const STRING_ADD          = 'SADD';  // S S
const STRING_REPLACE      = 'SREPL'; // S S:what S:with


const COLOR_VALUE         = 'C';     // color value

const COLOR               = 'COL';   // C | N:space N:c1 N:c2 N:c3
const COLOR_INTERPOLATE   = 'CLERP'; // C C N:amount
const COLOR_VALIDATE      = 'CVLD';  // C
const COLOR_CONTRAST      = 'CCNT';  // C:text C:background
const COLORBLIND          = 'BLND';  // C


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    COLOR_INTERPOLATE,
    COLOR_VALIDATE,
    COLORBLIND
];


const FILL_VALUE = 'FL';
const FILL       = 'FILL';

const FILL_TYPES =
[
    FILL_VALUE,
    FILL
];


const STROKE_VALUE    = 'SK';
const STROKE          = 'STRK';

const STROKE_TYPES =
[
    STROKE_VALUE,
    STROKE
];


const COLOR_STOP_VALUE    = 'CS';
const COLOR_STOP          = 'CSTOP';

const GRADIENT_VALUE      = 'GR';
const GRADIENT            = 'GRAD';


const SHAPE_VALUE      = 'G0';    // abstract placeholder

const RECTANGLE_VALUE     = 'R';
const LINE_VALUE          = 'L';
const ELLIPSE_VALUE       = 'E';
const POLYGON_VALUE       = 'P';
const STAR_VALUE          = 'ST';

const RECTANGLE           = 'RECT';  // N:x N:y N:width N:height N:angle N:roundTL N:roundTR N:roundBL N:roundBR
const LINE                = 'LINE';  // N:x N:y N:width N:height N:angle
const ELLIPSE             = 'ELPS';  // N:x N:y N:width N:height N:angle
const POLYGON             = 'POLY';  // N:x N:y N:width N:height N:angle N:corners
const STAR                = 'STAR';  // N:x N:y N:width N:height N:angle N:points N:convex


const SHAPE_VALUES =
[
    SHAPE_VALUE,

    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    RECTANGLE,
    LINE,
    ELLIPSE,
    POLYGON,
    STAR//,
    //TEXT
];


const GROUP               = 'GRP';   // ???? count O...


const COMMENT             = 'CMNT';


const ACTIVE              = 'ACT';
const BEFORE_ACTIVE       = 'BEF';
const PARAM               = 'PARAM'; // nodeId paramId


const LOG                 = 'LOG';



/*

FRAME       F
IMAGE       I
SLICE       /
TEXT        T
VECTOR      V

*/


class GType
{
    type;

    result;
    valid; // has been evaluated

    topLevel;


    data = {}; // for type conversion info


    constructor(type) 
    {
        this.type     = type;

        this.result   = null;
        this.valid    = false;

        this.topLevel = false;
    }



    copy()
    {
        return null;
    }



    copyBaseData(obj)
    {
        this.data = clone(obj.data);
    }



    isValid() // is a valid value
    {
        return false;
    }



    equalChans(c1, c2)
    {
        return !c1 && !c2
            ||  c1 && c2 && c1.equals(c2);
    }


    eval(parse)
    {
        // calculate and add value update here

        return null;
    }



    toString() 
    { 
        return this.type; 
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case NUMBER_VALUE:    return parseNumberValue   (value)[0].toDisplayString();
        case COLOR_VALUE:     return parseColorValue    (value)[0].toDisplayString();
        case FILL_VALUE:      return parseFillValue     (value)[0].toDisplayString()
        case STROKE_VALUE:    return parseStrokeValue   (value)[0].toDisplayString()
        case RECTANGLE_VALUE: return parseRectangleValue(value)[0].toDisplayString()
    }


    console.assert(false, 'cannot display value of type \'' + type + '\'');
}


class GOperator
extends GType
{
    nodeId;
    options;



    constructor(type, nodeId, options)
    {
        super(type);

        this.nodeId  = nodeId;
        this.options = options;
    }



    toValue()
    {
        return null;
    }
}



class GParam
extends GOperator
{
    paramId;



    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    copy()
    {
        return new GParam(this.nodeId, this.paramId);
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const node = parse.parsedNodes.find(v => v.nodeId == this.nodeId).result;
            console.assert(node, 'can\'t find parameter node \'' + this.nodeId + '\'');


            this.result = node[this.paramId].eval(parse).copy();

            
            this.result.valid = true;
            this.valid        = true;
        }


        return this.result;
    }
}


class NumberValue
extends GType
{
    value;
    decimals;



    constructor(val, dec = 0)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
        { 
            console.trace();
            console.assert(false, 'NumberValue(value) is ' + typeof val + ', must be a number');
        }


        this.value    = val;
        this.decimals = dec;

        this.result   = null;
        this.valid    = true;
    }



    copy()
    {
        return new NumberValue(
            this.value, 
            this.decimals);
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    eval(parse)
    {
        return this;
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals); // only NumberValue can do this, other _Values have to list all members
    }



    toSimpleString()
    {
        return !isNaN(this.value)
            ? numToString(this.value, this.decimals)
            : INVALID; // only NumberValue can do this, other _Values have to list all members
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? subscriptNumber(this.decimals)
                : '');
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
    {
        //console.trace();
        console.assert(false, 'number value missing \',\'');
    }
    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == INVALID
        ? NumberValue.NaN
        : new NumberValue(
              parseFloat(str),
              decCount(str));

    return [num, 1];
}


class ColorValue
extends GType
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.result = null;
        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        console.assert(typeof space == 'number', 'ColorValue.create() space must be a number');
        console.assert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        console.assert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        console.assert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    copy()
    {
        const color = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        color.copyBaseData(this);

        return color;
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        return makeDataColor(
            this.space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toRgbString()
    {
        if (!this.isValid())
            return INVALID;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    // if (   i <  0 && str    == INVALID
    //     || i >= 0 && str[i] == INVALID)
    //     return [ColorValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart];
}


class FillValue
extends GType
{
    color;
    opacity;



    constructor(color   = ColorValue .NaN, 
                opacity = new NumberValue(100))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();

        this.result  = null;
        this.valid   = true;
    }


    
    static create(r, g, b, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity));
    }



    static fromRgb(rgb, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity));
    }



    copy()
    {
        const fill = new FillValue(
            this.color  .copy(),
            this.opacity.copy());

        fill.copyBaseData(this);

        return fill;
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    equals(fill)
    {
        return fill
            && this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity);
    }



    eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    toFigma()
    {
        return [['SOLID', this.toString()]];
    }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString();
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r = parseNumberValue(str[i]); i += r[1];
    const g = parseNumberValue(str[i]); i += g[1];
    const b = parseNumberValue(str[i]); i += b[1];
    const a = parseNumberValue(str[i]); i += a[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0]),
        i - iStart ];
}






function evalFillValue(value, parse)
{
    const fill = value.eval(parse).copy();

         if ( FILL_TYPES.includes(fill.type)) return fill;
    else if (COLOR_TYPES.includes(fill.type)) return new FillValue(fill, value.data.opacity);

    else console.assert(false, 'fill must have type');
}


class StrokeValue
extends GType
{
    fill;
    weight;
    fit;
    join;
    miter;



    constructor(fill   = FillValue  .NaN, 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2))
    {
        if (fill.type != FILL_VALUE)
        {
            console.trace();
            console.assert(false, 'fill.type must be FILL_VALUE');
        }


        super(STROKE_VALUE);

        this.fill   = fill  .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();

        this.result  = null;
        this.valid   = true;
    }


    
    // static create(r, g, b, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.create(1, r, g, b),
    //         new NumberValue(opacity));
    // }



    // static fromRgb(rgb, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.fromRgb(rgb),
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const stroke = new StrokeValue(
            this.fill  .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy());

        stroke.copyBaseData(this);

        return stroke;
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fill  .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter );
    }



    eval(parse)
    {
        return this;
    }



    toFigma()
    {
        let align, join;

        
        switch (this.fit.value)
        {
            case 0: align = 'INSIDE';  break;
            case 1: align = 'CENTER';  break;
            case 2: align = 'OUTSIDE'; break;
        }
        
        switch (this.join.value)
        {
            case 0: join = 'MITER'; break;
            case 1: join = 'BEVEL'; break;
            case 2: join = 'ROUND'; break;
        }

        
        return this.isValid()
            ? {
                  strokes:          this.fill.toFigma(),
                  strokeWeight:     this.weight.value,
                  strokeAlign:      align,
                  strokeJoin:       join,
                  strokeMiterLimit: this.miter.value
              }
            : {
                  strokes: []
              };
    }



    toString()
    {
        return      this.fill  .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString();
    }



    toDisplayString()
    {
        return      this.fill  .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString();
    }



    static NaN = Object.freeze(new StrokeValue(
        FillValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(new StrokeValue(
        FillValue.create(0, 0, 0, 100),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96)));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == INVALID
        || i >= 0 && str[i] == INVALID)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill   = parseFillValue  (str, i); i += fill  [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];


    return [
        new StrokeValue(fill[0], weight[0], fit[0], join[0], miter[0]),
        i - iStart ];
}



function evalStrokeValue(value, parse)
{
    const stroke = value.eval(parse).copy();

         if (STROKE_TYPES.includes(stroke.type)) return stroke;
    else if (  FILL_TYPES.includes(stroke.type)) return new StrokeValue(stroke, value.data.weight);
    else if ( COLOR_TYPES.includes(stroke.type)) return new StrokeValue(new FillValue(stroke), value.data.weight);

    else console.assert(false, 'stroke must have type');
}


/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeBaseValue
extends GType
{
    nodeId;

    // fill;
    // stroke;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 

        // this.fill   = FillValue.default.copy();
        // this.stroke = StrokeValue.NaN  .copy();
    }



    copyBase(base)
    {
        this.nodeId = base.nodeId;

        // this.fill   = base.fill  .copy();
        // this.stroke = base.stroke.copy();
    }



    isValid()
    {
        return true;
        // return this.fill  .isValid()
        //    && !this.stroke.isValid();
    }



    toFigmaObject()
    {
        return {
            nodeId: this.nodeId//,

            // fills:  this.fill.isValid() 
            //         ? this.fill.toFigma() 
            //         : [],
            
            // ...this.stroke.toFigma()
        }
    }



    // toString()
    // {
    //     return      this.fill  .toString()
    //         + ' ' + this.stroke.toString();
    // }



    // toDisplayString()
    // {
    //     return      this.fill  .toDisplayString()
    //         + ' ' + this.stroke.toDisplayString();
    // }
}



// function parseShapeBaseValue(str, i, obj)
// {
//     const fill   = parseFillValue  (str, i); i += fill  [1];
//     const stroke = parseStrokeValue(str, i); i += stroke[1];

//     obj.fill   = fill  [0];
//     obj.stroke = stroke[0];

//     return i;
// }


class RectangleValue
extends ShapeBaseValue
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        const rect = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy());

        // rect.copyBase(this);
        // rect.copyData(this);

        return rect;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid();

            //&& super      .isValid();
    }


    eval(parse)
    {
        return this.result = this.copy();
    }



    toFigmaObject()
    {
        return {
            type:   RECTANGLE,
            id:     0,
            x:      this.x     .value,
            y:      this.y     .value,
            width:  this.width .value,
            height: this.height.value,
            angle:  this.angle .value,
            round:  Math.max(0, this.round.value)//,
            //...super.toFigmaObject()
        };
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString();
            
            //+ ' ' + super.toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString();
            
            // + ' ' + super.toDisplayString();
    }



    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == INVALID
        || i >= 0 && str[i] == INVALID)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0],
        round [0]);


    // i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends GType
{
    x;
    y;
    width;
    angle;



    constructor(x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(LINE_VALUE);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.angle  = angle;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new LineValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.angle .copy());
    }



    isValid()
    {
        return !isNaN(this.x    )
            && !isNaN(this.y    )
            && !isNaN(this.width)
            && !isNaN(this.angle);
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.angle .toString();
    }



    static NaN = new LineValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str)
{
    if (str == INVALID)
        return LineValue.NaN;

    const rect = str.split(' ');

    return new LineValue(
        new NumberValue(parseNumberValue(rect[0])),
        new NumberValue(parseNumberValue(rect[1])),
        new NumberValue(parseNumberValue(rect[2])),
        new NumberValue(parseNumberValue(rect[3])));
}



class EllipseValue
extends GType
{
    x;
    y;
    width;
    height;
    angle;



    constructor(x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(ELLIPSE_VALUE);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new EllipseValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy());
    }



    isValid()
    {
        return !isNaN(this.x     )
            && !isNaN(this.y     )
            && !isNaN(this.width )
            && !isNaN(this.height)
            && !isNaN(this.angle );
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString();
    }



    static NaN = new EllipseValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str)
{
    if (str == INVALID)
        return EllipseValue.NaN;

    const rect = str.split(' ');

    return new EllipseValue(
        new NumberValue(parseNumberValue(rect[0])[0]),
        new NumberValue(parseNumberValue(rect[1])[0]),
        new NumberValue(parseNumberValue(rect[2])[0]),
        new NumberValue(parseNumberValue(rect[3])[0]),
        new NumberValue(parseNumberValue(rect[4])[0]));
}



class PolygonValue
extends GType
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                width   = new NumberValue(0), 
                height  = new NumberValue(0), 
                angle   = new NumberValue(0), 
                round   = new NumberValue(0), 
                corners = new NumberValue(0))
    {
        super(POLYGON_VALUE);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new PolygonValue(
            this.x      .copy(), 
            this.y      .copy(), 
            this.width  .copy(), 
            this.height .copy(), 
            this.angle  .copy(), 
            this.round  .copy(), 
            this.corners.copy());
    }



    isValid()
    {
        return !isNaN(this.x      )
            && !isNaN(this.y      )
            && !isNaN(this.width  )
            && !isNaN(this.height )
            && !isNaN(this.angle  )
            && !isNaN(this.round  )
            && !isNaN(this.corners);
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x      .toString()
            + ' ' + this.y      .toString()
            + ' ' + this.width  .toString()
            + ' ' + this.height .toString()
            + ' ' + this.angle  .toString()
            + ' ' + this.round  .toString()
            + ' ' + this.corners.toString();
    }



    static NaN = new PolygonValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str)
{
    if (str == INVALID)
        return PolygonValue.NaN;

    const rect = str.split(' ');

    return new PolygonValue(
        new NumberValue(parseNumberValue(rect[0])),
        new NumberValue(parseNumberValue(rect[1])),
        new NumberValue(parseNumberValue(rect[2])),
        new NumberValue(parseNumberValue(rect[3])),
        new NumberValue(parseNumberValue(rect[4])),
        new NumberValue(parseNumberValue(rect[5])),
        new NumberValue(parseNumberValue(rect[6])));
}



class StarValue
extends GType
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0), 
                points = new NumberValue(0),
                convex = new NumberValue(0))
    {
        super(STAR_VALUE);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new StarValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy(), 
            this.points.copy(),
            this.convex.copy());
    }



    isValid()
    {
        return !isNaN(this.x     )
            && !isNaN(this.y     )
            && !isNaN(this.width )
            && !isNaN(this.height)
            && !isNaN(this.angle )
            && !isNaN(this.round )
            && !isNaN(this.points)
            && !isNaN(this.convex);
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString()
            + ' ' + this.points.toString()
            + ' ' + this.convex.toString();
    }



    static NaN = new StarValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str)
{
    if (str == INVALID)
        return StarValue.NaN;

    const rect = str.split(' ');

    return new StarValue(
        new NumberValue(parseNumberValue(rect[0])),
        new NumberValue(parseNumberValue(rect[1])),
        new NumberValue(parseNumberValue(rect[2])),
        new NumberValue(parseNumberValue(rect[3])),
        new NumberValue(parseNumberValue(rect[4])),
        new NumberValue(parseNumberValue(rect[5])),
        new NumberValue(parseNumberValue(rect[6])),
        new NumberValue(parseNumberValue(rect[7])));
}



class GNumber
extends GOperator
{
    input = null;
    value;
    


    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const num = new GNumber(this.nodeId, this.options);
        
        num.value = this.value;

        if (this.input) 
            num.input = this.input.copy();
        
        return num;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = 
                this.input
                ? this.input.eval(parse).copy()
                : this.value.copy();

            this.valid = true;

            console.assert(this.result.valid, 'this.result must be valid');
            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}


class GLimits
extends GOperator
{
    input = null;

    min;
    max;

    minMaxPriority = -1; 


    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const lim = new GLimits(this.nodeId, this.options);

        if (this.input) 
            lim.input = this.input.copy();

        lim.min = this.min.copy();
        lim.max = this.max.copy();

        lim.minMaxPriority = this.minMaxPriority;

        return lim;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.input)
                this.result = this.input.eval(parse).copy();


            const min = this.min.eval(parse).copy();
            const max = this.max.eval(parse).copy();


            // min.value = Math.min(min.value, max.value);
            // max.value = Math.max(min.value, max.value);


            this.result.value = Math.min(Math.max(
                min.value,
                this.result.value),
                max.value);


            this.valid        = true;
            this.result.valid = true;


            genPushUpdateValue(parse, this.nodeId, 'min',   min);
            genPushUpdateValue(parse, this.nodeId, 'max',   max);
            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GAdd
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const add = new GAdd(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return add;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            for (const _input of this.inputs)
            {
                const input = _input.eval(parse).copy();

                console.assert(
                    input.type == NUMBER_VALUE, 
                    'this.result.type must be NUMBER_VALUE');

                this.result.value   += input.value;
                this.result.decimals = Math.max(this.result.decimals, input.decimals);
            }
            
            
            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GSubtract
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const sub = new GSubtract(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return sub;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();

                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse);

                    console.assert(
                        input.type == NUMBER_VALUE, 
                        'this.result.type must be NUMBER_VALUE');
                        
                    this.result.value   -= input.value;
                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GMultiply
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }


    
    copy()
    {
        const mul = new GMultiply(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return mul;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.inputs.length > 0)
            {
                this.result.value = 1;

                for (const _input of this.inputs)
                {
                    const input = _input.eval(parse).copy();

                    this.result.value   *= input.value;
                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GDivide
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const div = new GDivide(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return div;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);

            
            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();


                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse).copy();

                    if (input.value == 0) 
                    { 
                        this.result.value    = Number.NaN; 
                        this.result.decimals = 0;
                        break; 
                    }

                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                    this.result.value    = floorTo(this.result.value / input.value, this.result.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GModulo
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const mod = new GModulo(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return mod;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);

            
            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();


                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse).copy();

                    if (input.value == 0) 
                    { 
                        this.result.value    = Number.NaN; 
                        this.result.decimals = 0;
                        break; 
                    }

                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                    this.result.value    = floorTo(this.result.value % input.value, this.result.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GExponent
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const exp = new GExponent(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return exp;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();

                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse);

                    console.assert(
                        input.type == NUMBER_VALUE, 
                        'this.result.type must be NUMBER_VALUE');
                        
                    this.result.value    = Math.pow(this.result.value, input.value);
                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GInterpolate
extends GOperator
{
    input0 = null;
    input1 = null;

    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const lerp = new GInterpolate(this.nodeId, this.options);

        if (this.input0) lerp.input0 = this.input0.copy();
        if (this.input1) lerp.input1 = this.input1.copy();

        lerp.amount = this.amount.copy();

        return lerp;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const amount = this.amount.eval(parse).copy();

            if (   this.input0 
                && this.input1)
            {
                const input0 = this.input0.eval(parse).copy();
                const input1 = this.input1.eval(parse).copy();

                const maxDec = Math.max(input0.decimals, input1.decimals);

                this.result = new NumberValue(
                    floorTo(input0.value + amount.value * (input1.value - input0.value) / 100, maxDec),
                    maxDec);
            }

            else if (this.input0) this.result = this.input0.eval(parse).copy();
            else if (this.input1) this.result = this.input1.eval(parse).copy();
            else                  this.result = new NumberValue(0);


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value',  this.result);
            genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        }


        return this.result;
    }
}



class GColor
extends GOperator
{
    input   = null;

    space   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }


    
    copy()
    {
        const col = new GColor(this.nodeId, this.options);

        if (this.input) 
            col.input = this.input.copy();

        col.space = this.space.copy();

        if (this.convert) 
            col.convert = this.convert.copy();

        if (this.c1) col.c1 = this.c1.copy();
        if (this.c2) col.c2 = this.c2.copy();
        if (this.c3) col.c3 = this.c3.copy();

        return col;
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    eval(parse)
    {
        if (this.valid)
            return;


        if (this.space) this.space.eval(parse);
        if (this.c1   ) this.c1   .eval(parse);
        if (this.c2   ) this.c2   .eval(parse);
        if (this.c3   ) this.c3   .eval(parse);


        let color;


        if (this.input)
        {
            this.input.eval(parse);

            
            if (this.input.isValid())
            {
                color = new ColorValue(
                    this.input.convert, 
                    this.input.c1, 
                    this.input.c2, 
                    this.input.c3);

                const fromSpaceIndex = color.space.value;

                color.space = this.space;

                const toSpaceIndex = Math.min(Math.max(
                    0,
                    color.space.value),
                    colorSpaceCount(parse)-1);

                this.convertColor(
                    color,
                    colorSpace(fromSpaceIndex), 
                    colorSpace(  toSpaceIndex));

                color.space.value = toSpaceIndex;

                
                if (this.c1) color.c1 = this.c1;
                if (this.c2) color.c2 = this.c2;
                if (this.c3) color.c3 = this.c3;
            }
        }
        else
        {
            color = new ColorValue(
                this.space, 
                this.c1, 
                this.c2, 
                this.c3);

            const toSpaceIndex = Math.min(Math.max(
                0,
                color.space.value),
                colorSpaceCount(parse)-1);

            color.space.value = toSpaceIndex;

            
            if (    this.convert
                && !isNaN(this.convert.value)
                &&  color.isValid())
            {
                this.convert.eval(parse);

                this.convertColor(
                    color,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }
        }


        console.assert(
            color.space.type == NUMBER_VALUE, 
            'this.result.type must be NUMBER_VALUE');


        genPushUpdateValue(parse, this.nodeId, 'space', color.space);
        genPushUpdateValue(parse, this.nodeId, 'c1',    color.c1   );
        genPushUpdateValue(parse, this.nodeId, 'c2',    color.c2   );
        genPushUpdateValue(parse, this.nodeId, 'c3',    color.c3   );


        this.valid = true;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2)];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    toColorValue()
    {
        return new ColorValue(
            this.space,
            this.c1,
            this.c2,
            this.c3);
    }



    // toDataColor()
    // {
    //     if (!this.isValid())
    //         return dataColor_NaN;

    //     return makeDataColor(
    //         this.space,
    //         this.c1,
    //         this.c2,
    //         this.c3);
    // }



    // toRgb()
    // {
    //     return dataColor2rgb(this.toDataColor());
    // }



    // toDisplayString()
    // {
    //     // console.log('this.space =', this.space);
    //     // console.log('this.c1 =', this.c1);
    //     // console.log('this.c2 =', this.c2);
    //     // console.log('this.c3 =', this.c3);
    //     return      this.space.toDisplayString()
    //         + ' ' + this.c1   .toDisplayString()
    //         + ' ' + this.c2   .toDisplayString()
    //         + ' ' + this.c3   .toDisplayString();
    // }
}


class GColorInterpolate
extends GOperator
{
    input0 = null;
    input1 = null;

    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const lerp = new GColorInterpolate(this.nodeId, this.options);

        if (this.input0) lerp.input0 = this.input0.copy();
        if (this.input1) lerp.input1 = this.input1.copy();

        lerp.space  = this.space .copy();
        lerp.amount = this.amount.copy();
        lerp.gamma  = this.gamma .copy();

        return lerp;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const space  = this.space .eval(parse).copy();
            const amount = this.amount.eval(parse).copy();
            const gamma  = this.gamma .eval(parse).copy();


            if (   this.input0 
                && this.input1)
            {
                const input0 = this.input0.eval(parse).copy();
                const input1 = this.input1.eval(parse).copy();


                console.assert(
                    amount.type == NUMBER_VALUE, 
                    'this.result.type must be NUMBER_VALUE');

                const f = amount.value / 100;

                const _space = colorSpace(space.value);

                const col0 = input0.toDataColor();
                const col1 = input1.toDataColor();

                const col = this.interpolate(
                    space.value,
                    convertDataColorToSpace(col0, _space),
                    convertDataColorToSpace(col1, _space),
                    f,
                    gamma.value);


                // allow interpolating invalid colors,
                // so no valid color check here

                const factor = getColorSpaceFactor(_space);

                this.result = ColorValue.create(
                    space.value,
                    col[1] * factor[0],
                    col[2] * factor[1],
                    col[3] * factor[2]);
            }

            else if (this.input0) this.result = this.input0.eval(parse).copy();
            else if (this.input1) this.result = this.input1.eval(parse).copy();

            else 
                this.result = ColorValue.NaN;


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value',  this.result);

            genPushUpdateValue(parse, this.nodeId, 'space',  space );
            genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        }


        return this.result;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (space <= 1) // hex, rgb
        {
            const r0 = Math.pow(col0[1], gamma);  const r1 = Math.pow(col1[1], gamma);
            const g0 = Math.pow(col0[2], gamma);  const g1 = Math.pow(col1[2], gamma);
            const b0 = Math.pow(col0[3], gamma);  const b1 = Math.pow(col1[3], gamma);

            gamma = Math.max(0.01, gamma);

            return [
                colorSpace(space),
                Math.pow(lerp(r0, r1, f), 1/gamma),
                Math.pow(lerp(g0, g1, f), 1/gamma),
                Math.pow(lerp(b0, b1, f), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }
}



class GColorContrast
extends GOperator
{
    input0 = null;
    input1 = null;

    standard;
    value;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }


    
    copy()
    {
        const cnt = new GColorContrast(this.nodeId, this.options);

        if (this.input0) cnt.input0 = this.input0.copy();
        if (this.input1) cnt.input1 = this.input1.copy();

        cnt.standard = this.standard.copy();
        cnt.value    = this.value   .copy();

        return cnt;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new ColorValue();

            const standard = this.standard.eval(parse).copy();


            if (   this.input0 
                && this.input1)
            {
                const input0 = this.input0.eval(parse).copy();
                const input1 = this.input1.eval(parse).copy();


                if (   input0.isValid()
                    && input1.isValid())
                {
                    this.result = input1;
                    
                    if (   dataColorIsValid(input0.toDataColor())
                        && dataColorIsValid(input1.toDataColor()))
                    {
                        if (standard.value == 0)
                        {
                            const value = getContrastRatio2(
                                input0.toRgb(),
                                input1.toRgb());

                            this.value = new NumberValue(value, 2);
                        }
                        else
                        {
                            const value = getContrastRatio3(
                                input0.toRgb(),
                                input1.toRgb());

                            this.value = new NumberValue(Math.abs(value), 1);
                        }
                    }
                    else
                        this.value = NumberValue.NaN;
                }
                else
                {
                    this.result = CGolorValue.NaN;
                    this.value  = NumberValue.NaN;
                }


                genPushUpdateValue(parse, this.nodeId, 'text', input0);
            }

            else if (this.input0) 
            {
                const input0 = this.input0.eval(parse).copy();

                if (input0.isValid())
                    genPushUpdateValue(parse, this.nodeId, 'text', input0);

                this.result = ColorValue.NaN;
                this.value  = NumberValue.NaN;
            }
            else if (this.input1) 
            {
                const input1 = this.input1.eval(parse).copy();

                if (input1.isValid())
                {
                    this.result = input1;
                    genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
                }
                else
                    this.result = ColorValue.NaN;
    
                this.value = NumberValue.NaN;
            }
            else
            {
                this.result = ColorValue.NaN;
                this.value  = NumberValue.NaN;

                genPushUpdateValue(parse, this.nodeId, 'text',  ColorValue.NaN);
            }
            

            genPushUpdateValue(parse, this.nodeId, 'back',  this.result);
            genPushUpdateValue(parse, this.nodeId, 'value', this.value);


            this.result.valid = true;
            this.valid        = true;
        }


        return this.result;
    }
}



class GColorBlind
extends GOperator
{
    input = null;

    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    copy()
    {
        const cb = new GColorBlind(this.nodeId, this.options);

        if (this.input) cb.input = this.input.copy();

        cb.l = this.l.copy();
        cb.m = this.m.copy();
        cb.s = this.s.copy();

        return cb;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const l = this.l.eval(parse).copy();
            const m = this.m.eval(parse).copy();
            const s = this.s.eval(parse).copy();


            if (this.input)
            {
                const input = this.input.eval(parse).copy();

                const rgb = input.toRgb();

                //const validRgb = invalid2validRgb(rgb);

                const rgbCb = rgb2colorblind(
                    rgb,
                    this.l.value / 2,
                    this.m.value / 2,
                    this.s.value / 2);

                if (   rgbIsOk(rgb)
                    && rgbIsOk(rgbCb))
                {
                    const validRgbCb = rgbCb;//invalid2validRgb(cb);
                
                    const validCol = convertDataColorToSpace(
                        rgb2dataColor(validRgbCb), 
                        colorSpace(input.space.value));
    
                    const factor = getColorSpaceFactor(validCol[0]);
    
                    this.result = ColorValue.create(
                        input.space.value,
                        validCol[1] * factor[0],
                        validCol[2] * factor[1],
                        validCol[3] * factor[2]);
                }
                else
                    this.result = ColorValue.NaN;
            }
            else
                this.result = ColorValue.NaN;


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);

            genPushUpdateValue(parse, this.nodeId, 'l', l);
            genPushUpdateValue(parse, this.nodeId, 'm', m);
            genPushUpdateValue(parse, this.nodeId, 's', s);
        }


        return this.result;
    }
}



class GColorValidate
extends GOperator
{
    input = null;

    order;
    
    margin1;
    margin2;
    margin3;


    constructor(nodeId, options)
    {
        super(COLOR_VALIDATE, nodeId, options);
    }


    
    copy()
    {
        const val = new GColorBlind(this.nodeId, this.options);

        if (this.input) val.input = this.input.copy();

        val.order   = this.order  .copy();
        val.margin1 = this.margin1.copy();
        val.margin2 = this.margin2.copy();
        val.margin3 = this.margin3.copy();

        return val;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const order   = this.order  .eval(parse).copy();
            const margin1 = this.margin1.eval(parse).copy();
            const margin2 = this.margin2.eval(parse).copy();
            const margin3 = this.margin3.eval(parse).copy();

            
            if (this.input)
            {
                const input = this.input.eval(parse).copy();

                const rgb = input.toRgb();


                if (rgbIsOk(rgb))
                {
                    // this._color = 
                    //     col
                    //     ? [...validateColor(
                    //         col.toDataColor(),
                    //         this.order  .value, 
                    //         this.margin1.value,
                    //         this.margin2.value,
                    //         this.margin3.value)]
                    //     : dataColor_NaN;


                    const factor = getColorSpaceFactor('rgb');
    
                    this.result = ColorValue.create(
                        1,
                        rgb[0] * factor[0],
                        rgb[1] * factor[1],
                        rgb[2] * factor[2]);
                }
                else
                    this.result = ColorValue.NaN;
            }
            else
                this.result = ColorValue.NaN;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'order',   order  );
            genPushUpdateValue(parse, this.nodeId, 'margin1', margin1);
            genPushUpdateValue(parse, this.nodeId, 'margin2', margin2);
            genPushUpdateValue(parse, this.nodeId, 'margin3', margin3);
        }


        return this.result;
    }
}



class GColorStop
extends GOperator
{
    input    = null;

    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }


    
    copy()
    {
        const stop = new GColorStop(this.nodeId, this.options);

        if (this.input) 
            stop.input = this.input.copy();

        if (this.fill    ) stop.fill     = this.fill    .copy();
        if (this.position) stop.position = this.position.copy();

        return stop;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new ColorStopValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == COLOR_STOP_VALUE, 
                    'this.result.type must be COLOR_STOP_VALUE');

                if (this.result.isValid())
                {
                    if (this.fill    ) this.result.fill     = this.fill    .eval(parse).copy();
                    if (this.position) this.result.position = this.position.eval(parse).copy();
                }
            }
            else
            {
                this.result.fill     = this.fill    .eval(parse).copy();
                this.result.position = this.position.eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}


class GShapeBase
extends GOperator
{
    // fill    = null;
    // stroke  = null;
    

    objects = [];



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyFromBase(base)
    {
        // if (base.fill  ) this.fill   = base.fill  .copy();
        // if (base.stroke) this.stroke = base.stroke.copy();

        this.objects = [...base.objects];
    }



    // addUpdateObject(parse, nodeId, objects)
    // {
    //     if (this.options.active) 
    //         genPushUpdateObject(parse, nodeId, objects);
    //     else 
    //         this.objects.push(...objects);
    // }



    evalBase(parse, input)
    {
    //     if (!this.valid)
    //     {
    //         const fill   = evalFillValue  (this.fill,   parse);
    //         const stroke = evalStrokeValue(this.stroke, parse);
            
    //         if (input)
    //         {
    //             if (this.fill  ) this.result.fill   = fill;
    //             if (this.stroke) this.result.stroke = stroke;
    //         }
    //         else
    //         {
    //             this.result.fill   = fill;
    //             this.result.stroke = stroke;
    //         }


    //         genPushUpdateValue(parse, this.nodeId, 'fill',   this.result.fill  );
    //         genPushUpdateValue(parse, this.nodeId, 'stroke', this.result.stroke);
    //     }
    }



    evalObjects()
    {
        for (const obj of this.objects)
            obj.nodeId = this.nodeId;
    }
}


class GRectangle
extends GShapeBase
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    copy()
    {
        const rect = new GRectangle(this.nodeId, this.options);

        if (this.input) 
            rect.input = this.input.copy();

        if (this.x     ) rect.x      = this.x     .copy();
        if (this.y     ) rect.y      = this.y     .copy();
        if (this.width ) rect.width  = this.width .copy();
        if (this.height) rect.height = this.height.copy();
        if (this.angle ) rect.angle  = this.angle .copy();
        if (this.round ) rect.round  = this.round .copy();

        rect.copyFromBase(this);

        return rect;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid();
    }



    eval(parse)
    {
        if (this.valid)
            return;


        if (this.x     ) this.x     .eval(parse);
        if (this.y     ) this.y     .eval(parse);
        if (this.width ) this.width .eval(parse);
        if (this.height) this.height.eval(parse);
        if (this.angle ) this.angle .eval(parse);
        if (this.round ) this.round .eval(parse);


        if (this.input)
            this.input.eval(parse);


        const x      = this.x      ? this.x      : this.input ? this.input.x      : null;
        const y      = this.y      ? this.y      : this.input ? this.input.y      : null;
        const width  = this.width  ? this.width  : this.input ? this.input.width  : null;
        const height = this.height ? this.height : this.input ? this.input.height : null;
        const angle  = this.angle  ? this.angle  : this.input ? this.input.angle  : null;
        const round  = this.round  ? this.round  : this.input ? this.input.round  : null;


        if (x     ) genPushUpdateValue(parse, this.nodeId, 'x',      x     );
        if (y     ) genPushUpdateValue(parse, this.nodeId, 'y',      y     );
        if (width ) genPushUpdateValue(parse, this.nodeId, 'width',  width );
        if (height) genPushUpdateValue(parse, this.nodeId, 'height', height);
        if (angle ) genPushUpdateValue(parse, this.nodeId, 'angle',  angle );
        if (round ) genPushUpdateValue(parse, this.nodeId, 'round',  round );


        if (    this.input
            && !this.options) this.objects = this.input.objects;
        else                  this.evalObjects();


        this.valid = true;
    }



    evalObjects()
    {
        this.objects = 
        [{
            type:   RECTANGLE,
            id:     0,
            x:                  (this.input ? this.input.x      : this.x     ).value,
            y:                  (this.input ? this.input.y      : this.y     ).value,
            width:              (this.input ? this.input.width  : this.width ).value,
            height:             (this.input ? this.input.height : this.height).value,
            angle:              (this.input ? this.input.angle  : this.angle ).value,
            round:  Math.max(0, (this.input ? this.input.round  : this.round ).value)
        }];

        
        super.evalObjects();
    }
}


class GLine
extends GOperator
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const line = new GLine(this.nodeId, this.options);

        if (this.input) 
            line.input = this.input.copy();

        if (this.x     ) line.x      = this.x     .copy();
        if (this.y     ) line.y      = this.y     .copy();
        if (this.width ) line.width  = this.width .copy();
        if (this.angle ) line.angle  = this.angle .copy();

        line.copyBase(this);

        return line;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x     .isValid()
                  && this.y     .isValid()
                  && this.width .isValid()
                  && this.angle .isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new LineValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == LINE_VALUE, 
                    'this.result.type must be LINE_VALUE');

                if (this.x     ) this.result.x      = this.x     .eval(parse).copy();
                if (this.y     ) this.result.y      = this.y     .eval(parse).copy();
                if (this.width ) this.result.width  = this.width .eval(parse).copy();
                if (this.angle ) this.result.angle  = this.angle .eval(parse).copy();
            }
            else
            {
                this.result.x      = this.x     .eval(parse).copy();
                this.result.y      = this.y     .eval(parse).copy();
                this.result.width  = this.width .eval(parse).copy();
                this.result.angle  = this.angle .eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, LINE_VALUE, this.result);


            if (this.options)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId: this.nodeId,          
                        type:   LINE,
                        id:     0,
                        x:      this.result.x     .value,
                        y:      this.result.y     .value,
                        width:  this.result.width .value,
                        angle:  this.result.angle .value
                    });
            }
        }


        return this.result;
    }
}


class GEllipse
extends GOperator
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    copy()
    {
        const elps = new GEllipse(this.nodeId, this.options);

        if (this.input) 
            elps.input = this.input.copy();

        if (this.x     ) elps.x      = this.x     .copy();
        if (this.y     ) elps.y      = this.y     .copy();
        if (this.width ) elps.width  = this.width .copy();
        if (this.height) elps.height = this.height.copy();
        if (this.angle ) elps.angle  = this.angle .copy();

        elps.copyBase(this);
        
        return elps;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x     .isValid()
                  && this.y     .isValid()
                  && this.width .isValid()
                  && this.height.isValid()
                  && this.angle .isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new EllipseValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == ELLIPSE_VALUE, 
                    'this.result.type must be ELLIPSE_VALUE');

                if (this.x     ) this.result.x      = this.x     .eval(parse).copy();
                if (this.y     ) this.result.y      = this.y     .eval(parse).copy();
                if (this.width ) this.result.width  = this.width .eval(parse).copy();
                if (this.height) this.result.height = this.height.eval(parse).copy();
                if (this.angle ) this.result.angle  = this.angle .eval(parse).copy();
            }
            else
            {
                this.result.x      = this.x     .eval(parse).copy();
                this.result.y      = this.y     .eval(parse).copy();
                this.result.width  = this.width .eval(parse).copy();
                this.result.height = this.height.eval(parse).copy();
                this.result.angle  = this.angle .eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, ELLIPSE_VALUE, this.result);


            if (this.options)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId: this.nodeId,          
                        type:   ELLIPSE,
                        id:     0,
                        x:      this.result.x     .value,
                        y:      this.result.y     .value,
                        width:  this.result.width .value,
                        height: this.result.height.value,
                        angle:  this.result.angle .value
                    });
            }
        }


        return this.result;
    }
}


class GPolygon
extends GOperator
{
    input   = null;

    x       = null;
    y       = null;
    width   = null;
    height  = null;
    angle   = null;
    round   = null;
    corners = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    copy()
    {
        const poly = new GPolygon(this.nodeId, this.options);

        if (this.input) 
            poly.input = this.input.copy();

        if (this.x      ) poly.x       = this.x      .copy();
        if (this.y      ) poly.y       = this.y      .copy();
        if (this.width  ) poly.width   = this.width  .copy();
        if (this.height ) poly.height  = this.height .copy();
        if (this.angle  ) poly.angle   = this.angle  .copy();
        if (this.round  ) poly.round   = this.round  .copy();
        if (this.corners) poly.corners = this.corners.copy();

        poly.copyBase(this);

        return poly;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x      .isValid()
                  && this.y      .isValid()
                  && this.width  .isValid()
                  && this.height .isValid()
                  && this.angle  .isValid()
                  && this.round  .isValid()
                  && this.corners.isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new PolygonValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();
                
                console.assert(
                    this.result.type == POLYGON_VALUE, 
                    'this.result.type must be POLYGON_VALUE');

                if (this.x      ) this.result.x       = this.x      .eval(parse).copy();
                if (this.y      ) this.result.y       = this.y      .eval(parse).copy();
                if (this.width  ) this.result.width   = this.width  .eval(parse).copy();
                if (this.height ) this.result.height  = this.height .eval(parse).copy();
                if (this.angle  ) this.result.angle   = this.angle  .eval(parse).copy();
                if (this.round  ) this.result.round   = this.round  .eval(parse).copy();
                if (this.corners) this.result.corners = this.corners.eval(parse).copy();
            }
            else
            {
                this.result.x       = this.x      .eval(parse).copy();
                this.result.y       = this.y      .eval(parse).copy();
                this.result.width   = this.width  .eval(parse).copy();
                this.result.height  = this.height .eval(parse).copy();
                this.result.angle   = this.angle  .eval(parse).copy();
                this.result.round   = this.round  .eval(parse).copy();
                this.result.corners = this.corners.eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, POLYGON_VALUE, this.result);


            if (this.options)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId:  this.nodeId,          
                        type:    POLYGON,
                        id:      0,
                        x:       this.result.x     .value,
                        y:       this.result.y     .value,
                        width:   this.result.width .value,
                        height:  this.result.height.value,
                        angle:   this.result.angle .value,
                        round:   Math.max(0, this.result.round.value),
                        corners: this.result.corners.value
                    });
            }
        }


        return this.result;
    }
}


class GStar
extends GOperator
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;
    points = null;
    convex = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    copy()
    {
        const star = new GStar(this.nodeId, this.options);

        if (this.input) 
            star.input = this.input.copy();

        if (this.x     ) star.x      = this.x     .copy();
        if (this.y     ) star.y      = this.y     .copy();
        if (this.width ) star.width  = this.width .copy();
        if (this.height) star.height = this.height.copy();
        if (this.angle ) star.angle  = this.angle .copy();
        if (this.round ) star.round  = this.round .copy();
        if (this.points) star.points = this.points.copy();
        if (this.convex) star.convex = this.convex.copy();

        star.copyBase(this);

        return star;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x     .isValid()
                  && this.y     .isValid()
                  && this.width .isValid()
                  && this.height.isValid()
                  && this.angle .isValid()
                  && this.round .isValid()
                  && this.points.isValid()
                  && this.convex.isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new StarValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == STAR_VALUE, 
                    'this.result.type must be STAR_VALUE');

                if (this.x     ) this.result.x      = this.x     .eval(parse).copy();
                if (this.y     ) this.result.y      = this.y     .eval(parse).copy();
                if (this.width ) this.result.width  = this.width .eval(parse).copy();
                if (this.height) this.result.height = this.height.eval(parse).copy();
                if (this.angle ) this.result.angle  = this.angle .eval(parse).copy();
                if (this.round ) this.result.round  = this.round .eval(parse).copy();
                if (this.points) this.result.points = this.points.eval(parse).copy();
                if (this.convex) this.result.convex = this.convex.eval(parse).copy();
            }
            else
            {
                this.result.x      = this.x     .eval(parse).copy();
                this.result.y      = this.y     .eval(parse).copy();
                this.result.width  = this.width .eval(parse).copy();
                this.result.height = this.height.eval(parse).copy();
                this.result.angle  = this.angle .eval(parse).copy();
                this.result.round  = this.round .eval(parse).copy();
                this.result.points = this.points.eval(parse).copy();
                this.result.convex = this.convex.eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, STAR_VALUE, this.result);


            if (this.options.active)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId: this.nodeId,          
                        type:   STAR,
                        id:     0,
                        x:      this.result.x     .value,
                        y:      this.result.y     .value,
                        width:  this.result.width .value,
                        height: this.result.height.value,
                        angle:  this.result.angle .value,
                        round:  Math.max(0, this.result.round.value),
                        points: this.result.points.value,
                        convex: this.result.convex.value
                    });
            }
        }


        return this.result;
    }
}


class GFill
extends GShapeBase
{
    input   = null;

    color   = null;
    opacity = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    copy()
    {
        const fill = new GFill(this.nodeId, this.options);

        if (this.input) 
            fill.input = this.input.copy();

        if (this.color  ) fill.color   = this.color  .copy();
        if (this.opacity) fill.opacity = this.opacity.copy();

        rect.copyFromBase(this);

        return fill;
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    eval(parse)
    {
        if (this.valid)
            return;


        if (this.color  ) this.color  .eval(parse);
        if (this.opacity) this.opacity.eval(parse);

        
        if (this.input)
        {
            this.input.eval(parse);
            this.objects = this.input.objects;
        }


        const color   = this.color   ? this.color   : this.input ? this.input.color   : null;
        const opacity = this.opacity ? this.opacity : this.input ? this.input.opacity : null;

        if (color  ) genPushUpdateValue(parse, this.nodeId, 'color',   color.type == COLOR ? color.toColorValue() : color);
        if (opacity) genPushUpdateValue(parse, this.nodeId, 'opacity', opacity);


        if (   this.options.active
            || this.options.beforeActive)
            this.evalObjects();


        this.valid = true;
    }



    evalObjects()
    {
        const color   = this.color   ? this.color   : this.input ? this.input.color   : null;
        const opacity = this.opacity ? this.opacity : this.input ? this.input.opacity : null;

        if (   !color
            || !opacity)
            return;


        const rgb = scaleRgb((color.type == COLOR ? color.toColorValue() : color).toRgb());


        for (const obj of this.objects)
        {
            if (!obj.fills) 
                obj.fills = [];

            obj.fills.push([
                'SOLID', 
                        rgb[0]
                + ' ' + rgb[1]
                + ' ' + rgb[2]
                + ' ' + this.opacity.toNumber()]);
        }

        
        super.evalObjects();
    }
}


class GStroke
extends GOperator
{
    fill   = null;
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;



    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }



    copy()
    {
        const stroke = new GStroke(this.nodeId, this.options);

        if (this.input) 
            stroke.input = this.input.copy();

        if (this.fill  ) stroke.fill   = this.fill  .copy();
        if (this.weight) stroke.weight = this.weight.copy();
        if (this.fit   ) stroke.fit    = this.fit   .copy();
        if (this.join  ) stroke.join   = this.join  .copy();
        if (this.miter ) stroke.miter  = this.miter .copy();

        return stroke;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const fill   = this.fill   ? evalFillValue(this.fill, parse) : null;
            const weight = this.weight ? this.weight.eval(parse).copy()  : null;
            const fit    = this.fit    ? this.fit   .eval(parse).copy()  : null;
            const join   = this.join   ? this.join  .eval(parse).copy()  : null;
            const miter  = this.miter  ? this.miter .eval(parse).copy()  : null;            

            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == STROKE_VALUE,
                    'GStroke this.result.type must be STROKE_VALUE');

                if (this.fill  ) this.result.fill   = fill;
                if (this.weight) this.result.weight = weight;
                if (this.fit   ) this.result.fit    = fit;
                if (this.join  ) this.result.join   = join;
                if (this.miter ) this.result.miter  = miter;
            }
            else
            {
                this.result = new StrokeValue(fill, weight, fit, join, miter);
            }
        

            genPushUpdateValue(parse, this.nodeId, 'fill',   this.result.fill  );
            genPushUpdateValue(parse, this.nodeId, 'weight', this.result.weight);
            genPushUpdateValue(parse, this.nodeId, 'fit',    this.result.fit   );
            genPushUpdateValue(parse, this.nodeId, 'join',   this.result.join  );
            genPushUpdateValue(parse, this.nodeId, 'miter',  this.result.miter );


            this.result.valid = true;
            this.valid        = true;
        }


        return this.result;
    }
}


const settings =
{
    enableLxxColorSpaces: false,

    showNodeId:           false, // instead of name
    showWires:            true,
    
    logMessages:          false,
    logActions:           false, 
    
    logLoading:           false, 
    logRequests:          false, 
    logValueUpdates:      false, 
    logObjectUpdates:     false,
    
    logRawLoading:        false, 
    logRawSaving:         false, 
    logRawRequests:       false, 
    logRawValues:         false    
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'enableLxxColorSpaces': settings.enableLxxColorSpaces = value;  break;

        case 'showNodeId':           settings.showNodeId           = value;  break;
        case 'showWires':            settings.showWires            = value;  break;

        case 'logMessages':          settings.logMessages          = value;  break;
        case 'logActions':           settings.logActions           = value;  break;
        case 'logLoading':           settings.logLoading           = value;  break;
        case 'logRequests':          settings.logRequests          = value;  break;
        case 'logValueUpdates':      settings.logValueUpdates      = value;  break;
        case 'logObjectUpdates':     settings.logObjectUpdates     = value;  break;

        case 'logRawLoading':        settings.logRawLoading        = value;  break;
        case 'logRawSaving':         settings.logRawSaving         = value;  break;
        case 'logRawRequests':       settings.logRawRequests       = value;  break;
        case 'logRawValues':         settings.logRawValues         = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'enableLxxColorSpaces': updateSettingAndMenu_(valid, settingName, value, menuItemEnableLxxColorSpaces);  break;

        case 'showNodeId':           updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId          );  break;
        case 'showWires':            updateSettingAndMenu_(valid, settingName, value, menuItemShowWires           );  break;

        case 'logMessages':          updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages         );  break;
        case 'logActions':           updateSettingAndMenu_(valid, settingName, value, menuItemLogActions          );  break;
        case 'logLoading':           updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading          );  break;
        case 'logRequests':          updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests         );  break;
        case 'logValueUpdates':      updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates     );  break;
        case 'logObjectUpdates':     updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates    );  break;

        case 'logRawLoading':        updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoading       );  break;
        case 'logRawSaving':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaving        );  break;
        case 'logRawRequests':       updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests      );  break;
        case 'logRawValues':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues        );  break;
    } 

    if (save)
        uiSetLocalData(settingName, boolString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  

    menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemEnableLxxColorSpaces.setChecked(settings.enableLxxColorSpaces);

    menuItemShowNodeId          .setChecked(settings.showNodeId          );
    menuItemShowWires           .setChecked(settings.showWires           );

    menuItemLogMessages         .setChecked(settings.logMessages         );
    menuItemLogActions          .setChecked(settings.logActions          );

    menuItemLogLoading          .setChecked(settings.logLoading          );
    menuItemLogRequests         .setChecked(settings.logRequests         );
    menuItemLogValueUpdates     .setChecked(settings.logValueUpdates     );
    menuItemLogObjectUpdates    .setChecked(settings.logObjectUpdates    );

    menuItemLogRawLoading       .setChecked(settings.logRawLoading       );
    menuItemLogRawSaving        .setChecked(settings.logRawSaving        );
    menuItemLogRawRequests      .setChecked(settings.logRawRequests      );
    menuItemLogRawValues        .setChecked(settings.logRawValues        );
}



function updateEnableLxxColorSpace()
{
    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}


var genFigMessagePosted = false;



var uiMessages = [];



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = function(e)
{
    const msg = JSON.parse(e.data);


    switch (msg.cmd)
    {
        case 'genFindCorrection':
            genFindCorrection(
                msg.nodeId, 
                msg.inputColor, 
                msg.param1,  msg.param2,  msg.param3,
                msg.locked1, msg.locked2, msg.locked3);  
        
            break;
        
        case 'genRequest':        genRequest(msg.request);     break;

        case 'genEndUiMessage':   genEndUiMessage(msg.msgCmd); break;
        case 'genEndFigMessage':  genEndFigMessage();          break;
    }


    genPostMessageToUI({
        cmd:   'uiEndGenMessage',
        msgCmd: msg.cmd
    });
};

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to UI
///////////////////////////////////////////////////////////////////////////////////////////////////

function genPostMessageToUI(msg)
{
    postMessage(JSON.stringify(msg));
}



function genQueueMessageToUI(msg)
{
    // console.log('genQueueMessageToUI()');
    // console.trace();

    uiMessages.push(msg);
    genPostNextMessageToUI();
}



function genPostNextMessageToUI(msg)
{
    // console.log('genPostNextMessageToUI()');
    // console.trace();

    //console.log('gen.uiMessages.length = ', uiMessages.length);

    
    if (uiMessages.length > 0)
        //&& !genFigMessagePosted)
    {
        //console.log('yes');
        let msg = uiMessages.shift();

        // while (   uiMessages.length > 0
        //        && uiMessages[0].cmd     == 'uiUpdateValuesAndObjects'
        //        && uiMessages[0].chunkId == 0)
        // {
        //     const nextFirst = uiMessages.find(m => 
        //            m.cmd     == msg.cmd 
        //         && m.chunkId == 0);

        //     if (nextFirst)
        //     {
        //         while (uiMessages.length > 0
        //             && uiMessages[0].cmd           == msg.cmd
        //             && uiMessages[0].updateNodeId  == msg.updateNodeId
        //             && uiMessages[0].updateParamId == msg.updateParamId
        //             && uiMessages[0].cmd.chunkId   >  0)
        //             msg = uiMessages.shift();

        //         msg = uiMessages.shift();
        //     }
        // }

        genPostMessageToUI(msg);
    }
}



function genEndUiMessage(msgCmd)
{
    //console.log('next UI message');
    genPostNextMessageToUI();
}



function genEndFigMessage()
{
    //console.log('next FIG message');

    genFigMessagePosted = false;
    
    if (   lastUpdateValues .length > 0
        || lastUpdateObjects.length > 0)
        genUpdateValuesAndObjects('', '', [], []);

    genPostNextMessageToUI();
}

///////////////////////////////////////////////////////////////////////////////////////////////////


var lastUpdateNodeId  = NULL;
var lastUpdateParamId = NULL;
var lastUpdateValues  = [];
var lastUpdateObjects = [];


function genRequest(request)
{
    // console.log('genRequest()');
    // console.trace();


    const set = parseInt(request[0]);

    const enableLxxColorSpaces = (set >> 0) & 1 != 0;
    const logRequests          = (set >> 1) & 1 != 0;


    const updateNodeId  = request[1];
    const updateParamId = request[2];


    const parse = new Parse(
        request, 
        updateNodeId, 
        updateParamId, 
        enableLxxColorSpaces,
        logRequests);


    const stackOverflowProtect = 100;

    while (   parse.pos < parse.request.length
           && parse.so  < stackOverflowProtect)
        genParse(parse);


    if (logRequests)
        logRequest(parse);


    const    paramNodes = parse.paramNodeIds.map(id => parse.parsedNodes.find(n => n.nodeId == id));
    const topLevelNodes = parse.parsedNodes.filter(n => n.topLevel);

    for (const node of    paramNodes) node.eval(parse);
    for (const node of topLevelNodes) node.eval(parse);


    for (const node of parse.parsedNodes)
    {
        if (   node instanceof GShapeBase
            && node.options.active)
            node.objects.forEach(o => genPushUpdateObject(parse, o));
    }


    genUpdateValuesAndObjects(
        parse.updateNodeId,
        parse.updateParamId,
        parse.updateValues,
        parse.updateObjects);
}



function genPushUpdateValue(parse, nodeId, paramId, value)
{
    const found = parse.updateValues.find(v =>
           v.nodeId     == nodeId
        && v.paramId    == paramId
        && v.value.type == value.type);

    if (!found)
    {
        parse.updateValues.push(
        {
            nodeId:  nodeId,
            paramId: paramId,
            type:    value.type, // needed to correctly parse INVALID
            value:   value
        });
    }
}



function genPushUpdateObject(parse, object)
{
    pushUniqueExcept(
        parse.updateObjects,
        object,
        o => o.nodeId == object.nodeId);
}



function clearLastUpdate()
{
    lastUpdateNodeId  = NULL;
    lastUpdateParamId = NULL;

    lastUpdateValues  = [];
    lastUpdateObjects = [];
}



function genUpdateValuesAndObjects(updateNodeId, updateParamId, updateValues, updateObjects)
{
    //console.log('genUpdateValuesAndObjects()');
    //console.log('updateValues =', updateValues);

    if (   updateValues .length == 0
        && updateObjects.length == 0)
    {
        //console.log('restoring');
        updateNodeId  = lastUpdateNodeId;
        updateParamId = lastUpdateParamId;
        updateValues  = lastUpdateValues;
        updateObjects = lastUpdateObjects;

        clearLastUpdate();
    }
    else if (genFigMessagePosted)
    {
        //console.log('saving');
        lastUpdateNodeId  = updateNodeId;
        lastUpdateParamId = updateParamId;
        lastUpdateValues  = updateValues;
        lastUpdateObjects = updateObjects;

        return;
    }


    const nodeIds = filterUnique(updateValues.map(v => v.nodeId));
    const counts  = nodeIds.map(id => updateValues.filter(v => v.nodeId == id).length);


    // send value updates in chunks

    const approxNodeChunkSize = 20;
    const objChunkSize        = 100;

    
    let n  = 0;
    let o  = 0; // object

    let nc = 0; // node cunk count
    let oc = 0; // objectchunk counts


    let nodeValChunk   = [],
        objChunk       = [];

    let nodeValChunkId = 0;
        

    while (   n < nodeIds.length
           || o < updateObjects.length)
    {
        if (n < nodeIds.length)
        {
            nodeValChunk.push(nodeIds[n], counts[n]);

            const values = updateValues.filter(v => v.nodeId == nodeIds[n]);
            values.sort((a, b) => a.paramId - b.paramId);

            for (const v of values)
                nodeValChunk.push(v.paramId, v.type, v.value);

            n++, nc++;
        }


        if (o < updateObjects.length)
        {
            objChunk.push(updateObjects[o]);
            o++, oc++;
        }


        if (   nc >= approxNodeChunkSize
            || oc == objChunkSize)
        {
            genQueueChunk(
                updateNodeId,
                updateParamId,
                nodeValChunkId++,
                nodeValChunk,
                objChunk);

            nodeValChunk = [];  nc = 0;
            objChunk     = [];  oc = 0;
        }
    }


    if (   nodeValChunk.length > 0
        || objChunk.length > 0)
    {
        genQueueChunk(
            updateNodeId,
            updateParamId,
            nodeValChunkId++,
            nodeValChunk,
            objChunk);
    }
}



function genQueueChunk(updateNodeId, updateParamId, nodeValChunkId, nodeValChunk, objChunk)
{
    genQueueMessageToUI({
        cmd:          'uiUpdateValuesAndObjects',
        updateNodeId:  updateNodeId,
        updateParamId: updateParamId,
        chunkId:       nodeValChunkId,
        values:        [...nodeValChunk].map(v => v ? v.toString() : INVALID),
        objects:       [...objChunk]
    });

    genFigMessagePosted = true;
}


function getObjectBounds(objects)
{
    var boundsL = Number.MAX_SAFE_INTEGER;
    var boundsT = Number.MAX_SAFE_INTEGER;
    var boundsR = Number.MIN_SAFE_INTEGER;
    var boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const obj of objects)
    {
        switch (obj[0])
        {
            case RECTANGLE:
                boundsL = Math.min(boundsL, obj[3]);
                boundsT = Math.min(boundsT, obj[4]);
                boundsR = Math.max(boundsR, obj[3] + obj[5]);
                boundsB = Math.max(boundsB, obj[4] + obj[6]);
                break;
        }
    }

    return {
        x: boundsL, 
        y: boundsT,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
}


function genParseColorValue(parse)
{
    parse.pos++; // COLOR_VALUE

    const col = parse.move();

    if (parse.settings.logRequests) 
        logReqColorValue(col, parse);

    return parseColorValue(col)[0];
}



function genParseColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col = new GColor(nodeId, options);

  
    if (parse.settings.logRequests) 
        logReqColor(col, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    let paramIds;

    if (   COLOR_TYPES.includes(parse.next)
        ||    parse.next == PARAM
           && COLOR_TYPES.includes(parse.afterNext))
    {
        col.input = genParse(parse);
        paramIds  = parse.move().split(',');
    }
    else
        paramIds = ['space', 'convert', 'c1', 'c2', 'c3'];

    
    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'space':   col.space   = genParse(parse); break;
        case 'convert': col.convert = genParse(parse); break;
        case 'c1':      col.c1      = genParse(parse); break;
        case 'c2':      col.c2      = genParse(parse); break;
        case 'c3':      col.c3      = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, col);
    return col;
}



function genParseColorInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GColorInterpolate(nodeId, options);


    let nValues = -1;

    if (!ignore)
    {
        nValues = parse.move();
        console.assert(nValues => 0 && nValues <= 2, 'nValues must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReqColorInterpolate(lerp, nValues, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nValues == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }

    else if (nValues == 1)
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nValues != 0)
        console.assert(false, 'nValues must be [0, 2]');


    lerp.space  = genParse(parse);
    lerp.amount = genParse(parse);
    lerp.gamma  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseColorContrast(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cnt = new GColorContrast(nodeId, options);


    let nValues = -1;

    if (!ignore)
    {
        nValues = parse.move();
        console.assert(nValues => 0 && nValues <= 2, 'nValues must be [0, 2]');
    }


    const valueIndex = 
        nValues == 1
        ? parseInt(parse.move())
        : -1;

    
        if (parse.settings.logRequests) 
        logReqColorContrast(cnt, nValues, valueIndex, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, cnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nValues == 2)
    {
        cnt.input0   = genParse(parse);
        cnt.input1   = genParse(parse);
        cnt.standard = genParse(parse);
    }
    else if (nValues == 1)
    {
             if (valueIndex == 0) cnt.input0 = genParse(parse); 
        else if (valueIndex == 1) cnt.input1 = genParse(parse); 

        cnt.standard = genParse(parse);
    }
    else if (nValues == 0)
    {
        cnt.standard = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, cnt);
    return cnt;
}



function genParseColorBlind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cb = new GColorBlind(nodeId, options);


    if (parse.settings.logRequests) 
        logReqColorBlind(cb, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, cb);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (COLOR_TYPES.includes(parse.next))
        cb.input = genParse(parse);

    cb.l = genParse(parse);
    cb.m = genParse(parse);
    cb.s = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, cb);
    return cb;
}



function genParseColorValidate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const val = new GColorValidate(nodeId, options);


    if (parse.settings.logRequests) 
        logReqColorValidate(val, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, val);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (COLOR_TYPES.includes(parse.next))
        val.input = genParse(parse);

    val.order   = genParse(parse);

    val.margin1 = genParse(parse);
    val.margin2 = genParse(parse);
    val.margin3 = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, val);
    return val;
}


function genParseNumValue(parse)
{
    parse.pos++; // N

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqNumberValue(val, parse);

    return val.indexOf(',') >= 0
         ? parseNumberValue      (val)[0]
         : parseSimpleNumberValue(val)[0];
}



function genParseNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num = new GNumber(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReqNumber(num, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (parse.next == NUMBER_VALUE) num.value = genParse(parse);
    else                            num.input = genParse(parse);

    parse.nTab--;


    genParseNodeEnd(parse, num);
    return num;
}



function genParseLimits(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lim = new GLimits(nodeId, options);
   

    let nValues = -1;
    
    if (!ignore)
    {
        nValues = parse.move();
        console.assert(nValues == 0 || nValues == 1, 'nValues must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReqLimits(lim, nValues, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, lim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nValues == 1)
        lim.input = genParse(parse);

    lim.min = genParse(parse);
    lim.max = genParse(parse);
    
    parse.nTab--;


    genParseNodeEnd(parse, lim);
    return lim;
}



function genParseArithmetic(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const arith = newNode(nodeId, options);


    let nValues = 0;
    
    if (!ignore)
        nValues = parse.move();


        if (parse.settings.logRequests) 
        logReqArithmetic(arith, type, nValues, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, arith);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nValues; i++)
        arith.inputs.push(genParse(parse));

    parse.nTab--;

        
    genParseNodeEnd(parse, arith);
    return arith;
}



function genParseInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolate(nodeId, options);


    let nValues = -1;

    if (!ignore)
    {
        nValues = parse.move();
        console.assert(nValues => 0 && nValues <= 2, 'nValues must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReqInterpolate(lerp, nValues, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nValues == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
        lerp.amount = genParse(parse);
    }
    else if (nValues == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        lerp.amount = genParse(parse);
    }
    else if (nValues == 0)
    {
        lerp.amount = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}


// function genParseShapeBase(parse, obj, paramId)
// {
//     switch (paramId)
//     {
//     case 'fill':   obj.fill   = genParseFillParam  (parse); break;
//     case 'stroke': obj.stroke = genParseStrokeParam(parse); break;
//     }
// }



function genParseRectangle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rect = new GRectangle(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(rect, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (   parse.next == RECTANGLE
        || parse.next == RECTANGLE_VALUE)
        rect.input = genParse(parse); // not genParseRectangle() because genParse() handles stack overflow


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.nTab++;
        parse.inParam = true;


        switch (paramId)
        {
        case 'x':      rect.x      = genParse(parse); break;
        case 'y':      rect.y      = genParse(parse); break;
        case 'width':  rect.width  = genParse(parse); break;
        case 'height': rect.height = genParse(parse); break;
        case 'angle':  rect.angle  = genParse(parse); break;
        case 'round':  rect.round  = genParse(parse); break;
        }


        parse.nTab--;
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rect);
    return rect;
}



function genParseLine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);

  
    let line = new GLine(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(line, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;
    
    if (   parse.next == LINE_VALUE
        || parse.next == LINE)
    {
        line.input = genParse(parse); // not genParseLine() because genParse() handles stack overflow
        paramIds   = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'width', 'angle'];


    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':     line.x     = genParse(parse); break;
        case 'y':     line.y     = genParse(parse); break;
        case 'width': line.width = genParse(parse); break;
        case 'angle': line.angle = genParse(parse); break;
        }
    }


    parse.nTab--;


    genParseNodeEnd(parse, line);
    return line;
}



function genParseEllipse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const elps = new GEllipse(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(elps, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, elps);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (   parse.next == ELLIPSE_VALUE
        || parse.next == ELLIPSE)
    {
        elps.input = genParse(parse); // not genParseEllipse() because genParse() handles stack overflow
        paramIds   = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'width', 'height', 'angle'];


    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      elps.x      = genParse(parse); break;
        case 'y':      elps.y      = genParse(parse); break;
        case 'width':  elps.width  = genParse(parse); break;
        case 'height': elps.height = genParse(parse); break;
        case 'angle':  elps.angle  = genParse(parse); break;
        }
    }


    parse.nTab--;


    genParseNodeEnd(parse, elps);
    return elps;
}



function genParsePolygon(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const poly = new GPolygon(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(poly, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, poly);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (   parse.next == POLYGON_VALUE
        || parse.next == POLYGON)
    {
        poly.input = genParse(parse); // not genParsePolygon() because genParse() handles stack overflow
        paramIds   = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'width', 'height', 'angle', 'round', 'corners'];


    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':       poly.x       = genParse(parse); break;
        case 'y':       poly.y       = genParse(parse); break;
        case 'width':   poly.width   = genParse(parse); break;
        case 'height':  poly.height  = genParse(parse); break;
        case 'angle':   poly.angle   = genParse(parse); break;
        case 'round':   poly.round   = genParse(parse); break;
        case 'corners': poly.corners = genParse(parse); break;
        }
    }


    parse.nTab--;


    genParseNodeEnd(parse, poly);
    return poly;
}



function genParseStar(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const star = new GStar(nodeId, options);


    if (parse.settings.logRequests) 
        logReqShape(star, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, star);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (   parse.next == STAR_VALUE
        || parse.next == STAR)
    {
        star.input = genParse(parse); // not genParseStar() because genParse() handles stack overflow
        paramIds   = parse.move().split(',');
    }
    else
        paramIds = ['x', 'y', 'width', 'height', 'angle', 'round', 'points', 'convex'];


    for (const id of paramIds)
    {
        switch (id)
        {
        case 'x':      star.x      = genParse(parse); break;
        case 'y':      star.y      = genParse(parse); break;
        case 'width':  star.width  = genParse(parse); break;
        case 'height': star.height = genParse(parse); break;
        case 'angle':  star.angle  = genParse(parse); break;
        case 'round':  star.round  = genParse(parse); break;
        case 'points': star.points = genParse(parse); break;
        case 'convex': star.convex = genParse(parse); break;
        }
    }


    parse.nTab--;


    genParseNodeEnd(parse, star);
    return star;
}


function genParseFillValue(parse)
{
    parse.pos++; // FILL_VALUE

    const fill = parse.move();

    if (parse.settings.logRequests) 
        logReqFillValue(fill, parse);

    return parseFillValue(fill)[0];
}



function genParseFill(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fill = new GFill(nodeId, options);


    if (parse.settings.logRequests) 
        logReqFill(fill, parse);


    if (ignore)
    {
        genParseNodeEnd(parse, fill);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (   parse.next == FILL
        || parse.next == FILL_VALUE
        || SHAPE_TYPES.includes(parse.next))
        fill.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.nTab++;
        parse.inParam = true;

        
        switch (paramId)
        {
        case 'color'  : fill.color   = genParse(parse); break;
        case 'opacity': fill.opacity = genParse(parse); break;
        }

        parse.nTab--;
    }

    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, fill);
    return fill;
}



function genParseFillParam(parse)
{
    const fill = genParse(parse); 

    if (COLOR_TYPES.includes(fill.type))
        fill.data.opacity = genParse(parse);

    return fill;
}



function genParseStrokeValue(parse)
{
    parse.pos++; // STROKE_VALUE

    const stroke = parse.move();

    if (parse.settings.logRequests) 
        logReqStrokeValue(stroke, parse);

    return parseStrokeValue(stroke)[0];
}



function genParseStroke(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stroke = new GStroke(nodeId, options);


    if (parse.settings.logRequests) 
        logReqStroke(stroke, parse);


    if (ignore)
    {
        genParseNodeEnd(parse, stroke);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (   STROKE_TYPES.includes(parse.next)
        ||    parse.next == PARAM
           && STROKE_TYPES.includes(parse.afterNext))
    {
        stroke.input = genParse(parse);
        paramIds     = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'weight', 'fit', 'join', 'miter'];

        
    for (const id of paramIds)
    {
        parse.inParam = false;

        switch (id)
        {
        case 'fill':   stroke.fill   = genParseFillParam(parse); break;
        case 'weight': stroke.weight = genParse(parse);          break;
        case 'fit':    stroke.fit    = genParse(parse);          break;
        case 'join':   stroke.join   = genParse(parse);          break;
        case 'miter':  stroke.miter  = genParse(parse);          break;
        }
    }

    
    parse.nTab--;


    genParseNodeEnd(parse, stroke);
    return stroke;
}



function genParseStrokeParam(parse)
{
    const stroke = genParse(parse); 

    if (    FILL_TYPES.includes(stroke.type)
        || COLOR_TYPES.includes(stroke.type))
        stroke.data.weight = genParse(parse);

    return stroke;
}



function genParseColorStopValue(parse)
{
    parse.pos++; // COLOR_STOP_VALUE

    const stop = parse.move();

    if (parse.settings.logRequests) 
        logReqColorStopValue(stop, parse);

    return parseColorStopValue(stop);
}



function genParseColorStop(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stop = new GColorStop(nodeId, options);


    if (parse.settings.logRequests) 
        logReqColorStop(stop, parse);


    if (ignore)
    {
        genParseNodeEnd(parse, stop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (   parse.next == COLOR_STOP
        || parse.next == COLOR_STOP_VALUE)
        stop.input = genParse(parse);


    stop.fill     = genParse(parse);
    stop.position = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, stop);
    return stop;
}


// some parse functions return values
// some parse functions update values
// some parse functions update objects



class Parse
{
    request;
    
    pos; 
    so;

    settings = {};


    log  = '';
    
    nTab = 0;

    get tab() { return this.inParam ? ' ' : (NL + TAB.repeat(Math.max(0, this.nTab))); }

    
    inParam = false;

    
    updateNodeId;
    updateParamId;

    scope         = []; // current parse stack
    parsedNodes   = []; // must be evaluated to create the value updates

    paramNodeIds  = [];

    updateParams  = [];
    updateValues  = [];
    updateObjects = [];

    
    get next() { return this.request[this.pos]; }

    get afterNext() 
    { 
        return this.pos+1 < this.request.length 
             ? this.request[this.pos+1]
             : null;
    }



    constructor(request, updateNodeId, updateParamId, enableLxxColorSpaces, logRequests)
    {
        this.request       = request;
          
        this.pos           = 3; 
        this.so            = 0;
        
        this.updateNodeId  = updateNodeId; 
        this.updateParamId = updateParamId;
   
        
        this.settings.enableLxxColorSpaces = enableLxxColorSpaces;
        this.settings.logRequests          = logRequests;
    }



    move()
    {
        return this.request[this.pos++];
    }
}



function genParse(parse, inParam = true)
{
    //console.log('parse.next', parse.next);

    if (!inParam)
        parse.inParam = false;


    let result = null;


         if (parse.next == PARAM             ) result = genParseParam           (parse);

    else if (parse.next == NUMBER_VALUE      ) result = genParseNumValue        (parse);
    else if (parse.next == NUMBER            ) result = genParseNumber          (parse);
    else if (parse.next == NUMBER_LIMITS     ) result = genParseLimits          (parse);
    else if (parse.next == NUMBER_ADD        ) result = genParseArithmetic      (parse, (nodeId, options) => new GAdd     (nodeId, options));
    else if (parse.next == NUMBER_SUBTRACT   ) result = genParseArithmetic      (parse, (nodeId, options) => new GSubtract(nodeId, options));
    else if (parse.next == NUMBER_MULTIPLY   ) result = genParseArithmetic      (parse, (nodeId, options) => new GMultiply(nodeId, options));
    else if (parse.next == NUMBER_DIVIDE     ) result = genParseArithmetic      (parse, (nodeId, options) => new GDivide  (nodeId, options));
    else if (parse.next == NUMBER_MODULO     ) result = genParseArithmetic      (parse, (nodeId, options) => new GModulo  (nodeId, options));
    else if (parse.next == NUMBER_EXPONENT   ) result = genParseArithmetic      (parse, (nodeId, options) => new GExponent(nodeId, options));
    else if (parse.next == NUMBER_INTERPOLATE) result = genParseInterpolate     (parse);

    else if (parse.next == COLOR_VALUE       ) result = genParseColorValue      (parse);
    else if (parse.next == COLOR             ) result = genParseColor           (parse);
    else if (parse.next == COLOR_INTERPOLATE ) result = genParseColorInterpolate(parse);
    else if (parse.next == COLOR_CONTRAST    ) result = genParseColorContrast   (parse);
    else if (parse.next == COLORBLIND        ) result = genParseColorBlind      (parse);
    else if (parse.next == COLOR_VALIDATE    ) result = genParseColorValidate   (parse);

    else if (parse.next == FILL_VALUE        ) result = genParseFillValue       (parse);
    else if (parse.next == FILL              ) result = genParseFill            (parse);

    else if (parse.next == STROKE_VALUE      ) result = genParseStrokeValue     (parse);
    else if (parse.next == STROKE            ) result = genParseStroke          (parse);

    else if (parse.next == COLOR_STOP_VALUE  ) result = genParseColorStopValue  (parse);
    else if (parse.next == COLOR_STOP        ) result = genParseColorStop       (parse);

    else if (parse.next == RECTANGLE         ) result = genParseRectangle       (parse);
    else if (parse.next == LINE              ) result = genParseLine            (parse);
    else if (parse.next == ELLIPSE           ) result = genParseEllipse         (parse);
    else if (parse.next == POLYGON           ) result = genParsePolygon         (parse);
    else if (parse.next == STAR              ) result = genParseStar            (parse);

    else                                       console.assert(false, 'unknown parse token \'' + parse.next + '\'');


    parse.inParam = false;


    if (result)
        return result;
    else
    {
        parse.so++;
        return null;
    }
}



function genParseNodeStart(parse)
{
    const type   = parse.move();
    const nodeId = parse.move();

    parse.scope.push(nodeId);

    if (parse.parsedNodes.find(n => n.nodeId == nodeId))
        return [type, nodeId, false, true];

    const options = genParseNodeOptions(parse);

    return [type, nodeId, options, false];
}



function genParseNodeEnd(parse, node = null)
{
    parse.scope.pop();

    if (node)
    {
        if (parse.scope.length == 0)
            node.topLevel = true;

        pushUnique(parse.parsedNodes, node);
    }
}



function genParseNodeOptions(parse)
{
    const opt = parseInt(parse.move());

    const options = 
    {
        active:       ((opt >> 0) & 1) != 0,
        beforeActive: ((opt >> 1) & 1) != 0,
    };

    return options;
}



function genParseParamCount(parse)
{
    const nParamIds = parseInt(parse.move());

    if (parse.settings.logRequests) 
        parse.log += parse.tab + nParamIds;

    return nParamIds;
}



function genParseParam(parse)
{
    if (parse.next != PARAM) 
        return null;
        
    parse.move(); // PARAMw
    const type = parse.move(); // type

    
    const nodeId  = parse.move();
    const paramId = parse.move();
    

    const param = new GParam(nodeId, paramId);
    

    pushUnique(parse.paramNodeIds, nodeId);


    if (parse.settings.logRequests) 
        logReqParam(param, type, parse);


    return param;
}



function genParseParamId(parse)
{
    const paramId = parse.move();

    if (parse.settings.logRequests)
        parse.log += parse.tab + paramId;

    return paramId;
}


// Observer = 2

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v > 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h += 1;
    while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k * xw + 0.16)/1.16;
    yw = yw > e ? Math.cbrt(yw) : (k * yw + 0.16)/1.16;
    zw = zw > e ? Math.cbrt(zw) : (k * zw + 0.16)/1.16;

    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = cube(6/29) / 100;
    const k = cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16)/k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16)/k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16)/k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


const okLabScale = 5.8209716167;



function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l_, a_, b_) 
{
    return [
        l_ + 0.3963377774 * a_ + 0.2158037573 * b_,
        l_ - 0.1055613458 * a_ - 0.0638541728 * b_,
        l_ - 0.0894841775 * a_ - 1.2914855480 * b_ ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclokl2rgb(hcl, cs = sRGB)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 
    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclokl2rgb_(h, c, l, cs = sRGB)
{
    return hclokl2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclokl(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));
    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);
    return hcl;
}



function rgb2hclokl_(r, g, b, cs = sRGB)
{
    return rgb2hclokl([r, g, b], cs);
}



function hcllab2lab(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hcllab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hcllab2lab(hcl), cs);
}



function lab2hcllab(lab)
{
    let hcl = opp2pol(lab);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hcllab(rgb, cs = sRGB)
{
    return lab2hcllab(rgb2lab(rgb, cs));
}



function hclluv2luv(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hclluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hclluv2luv(hcl), cs);
}



function luv2hclluv(luv)
{
    let hcl = opp2pol(luv);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hclluv(rgb, cs = sRGB)
{
    return luv2hclluv(rgb2luv(rgb, cs));
}


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);



// function colorIsNaN(c)
// {
//     return isNaN(c[0])
//         || isNaN(c[1])
//         || isNaN(c[2]);
// }



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = Eps)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbIsOk(rgb, lim = Eps)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = Eps)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const dataColor_NaN = [
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ];


var style2rgba_canvas;
var style2rgba_context;
    


function initColor()
{
    style2rgba_canvas  = document.createElement('canvas');
    style2rgba_context = style2rgba_canvas.getContext('2d');
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclokl(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < Eps
        && Math.abs(rgb1[1] - rgb2[1]) < Eps
        && Math.abs(rgb1[2] - rgb2[2]) < Eps;        
}



function style2rgba(style) 
{
    style2rgba_context.fillStyle = style;
    style2rgba_context.fillRect(0, 0, 1, 1);

    return rgbaDiv(style2rgba_context.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) 
{
    style2rgba_context.fillStyle = getStyleValue(obj, style);
    style2rgba_context.fillRect(0, 0, 1, 1);

    return rgbaDiv(style2rgba_context.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb)  ? [1, 1, 1, 1] : [0, 0, 0, 0.92])
               : (isDarkMode() ? [1, 1, 1, 1] : [0, 0, 0, 0.92]))
           : (isDarkMode() ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningStyle(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? '#ffffff29' : '#00000022')
         : (isDarkMode() ? '#ffffff08' : '#00000006'); 
}


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '?'
{
    return hex.indexOf(INVALID) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }

    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    return rgb;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const OpColorSpaces = 
[
    ['hex',    'Hex'   ],
    ['rgb',    'RGB'   ], 
    ['hsv',    'HSV'   ], 
    ['hsl',    'HSL'   ], 
    ['hclokl', 'HCL/ok'],
    ['hcllab', 'HCL/ab'],
    ['hclluv', 'HCL/uv'],
    ['oklab',  'okLab' ],
    ['lab',    'Lab'   ],
    ['luv',    'Luv'   ]
];



function colorSpace     (index) { return OpColorSpaces[index][0]; }
function colorSpaceIndex(space) { return OpColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.enableLxxColorSpaces 
           ? OpColorSpaces.length
           : OpColorSpaces.length - 3; 
}



const rgbFactor   = [255, 255, 255];
const hs_Factor   = [360, 100, 100];
const hclFactor   = [360, 100, 100];
const oppFactor   = [100, 100, 100];


const rgbScale    = [255, 255, 255];

const hs_Scale    = [360, 100, 100];

const hcloklScale = [360,  51, 100];
const hcllabScale = [360, 400, 100];
const hclluvScale = [360, 330, 100];

const oklabScale  = [100,  30,  30];
const labScale    = [100, 100, 100];
const luvScale    = [100, 150, 150];



function colorFactor(space)
{
    switch (space)
    {
        case 'hex':    return rgbFactor;   
        case 'rgb':    return rgbFactor;

        case 'hsv':    return hs_Factor;   
        case 'hsl':    return hs_Factor;

        case 'hclokl': return hclFactor;
        case 'hcllab': return hclFactor;
        case 'hclluv': return hclFactor;

        case 'oklab':  return oppFactor; 
        case 'lab':    return oppFactor;   
        case 'luv':    return oppFactor;   
        
        default:       console.assert(false, 'invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    scale = rgbScale;    break;
        case 'rgb':    scale = rgbScale;    break;

        case 'hsv':    scale = hs_Scale;    break;
        case 'hsl':    scale = hs_Scale;    break;

        case 'hclokl': scale = hcloklScale; break;
        case 'hcllab': scale = hcllabScale; break;
        case 'hclluv': scale = hclluvScale; break;

        case 'oklab':  scale = oklabScale;  break;
        case 'lab':    scale = labScale;    break;
        case 'luv':    scale = luvScale;    break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function scaleRgb(rgb)
{
    return scaleColor(rgb, 'rgb');
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':    switchToHex   (node); break;
        case 'rgb':    switchToRgb   (node); break;

        case 'hsv':    switchToHsv   (node); break;
        case 'hsl':    switchToHsl   (node); break;

        case 'hclokl': switchToHclOkl(node); break;
        case 'hcllab': switchToHclLab(node); break;
        case 'hclluv': switchToHclLuv(node); break;

        case 'oklab':  switchToOklab (node); break;
        case 'lab':    switchToLab   (node); break;
        case 'luv':    switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex   (node) { switchToTextbox       (node);           }
function switchToRgb   (node) { switchToRgbControls   (node);           }

function switchToHsv   (node) { switchToHs_Controls   (node, 'V');      }
function switchToHsl   (node) { switchToHs_Controls   (node, 'L');      }

function switchToHclOkl(node) { switchToHclOklControls(node);           }
function switchToHclLab(node) { switchToHclLabControls(node);           }
function switchToHclLuv(node) { switchToHclLuvControls(node);           }

function switchToOklab (node) { switchToOklabControls (node, 'a', 'b'); }
function switchToLab   (node) { switchToLabControls   (node, 'a', 'b'); }
function switchToLuv   (node) { switchToLuvControls   (node, 'u', 'v'); }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.control.min = 
    node.param2.control.min = 
    node.param3.control.min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.control.max = 
    node.param2.control.max = 
    node.param3.control.max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param2.control.min = 
    node.param3.control.min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.control.max = 
    node.param3.control.max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hcloklScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hcllabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hclluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.control.showHex = show;
    node.param2.control.showHex = show;
    node.param3.control.showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.control.wrapValue = c1wrap;
    node.param1.control.setSuffix(c1suffix, c1suffix != '');

    node.param1.control.setMin(c1min, false); 
    node.param2.control.setMin(c2min, false);
    node.param3.control.setMin(c3min, false);
    
    node.param1.control.setMax(c1max, false); 
    node.param2.control.setMax(c2max, false); 
    node.param3.control.setMax(c3max, false); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();
}



function switchToTextbox(node)
{
    if (!node.inner.contains(node.paramColor.div))
    {
        removeOpColorParamWires(node);

        node.inner.removeChild(node.param1.div);
        node.inner.removeChild(node.param2.div);
        node.inner.removeChild(node.param3.div);
        
        node.inner.appendChild(node.paramColor.div);
    }
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    if (node.inner.contains(node.paramColor.div))
    {
        node.inner.removeChild(node.paramColor.div);

        node.inner.appendChild(node.param1.div);
        node.inner.appendChild(node.param2.div);
        node.inner.appendChild(node.param3.div);

        node.updateNode();
    }
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':    return getNormalValueHs_ (value, chan);

        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':    return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':    return getNormalColorHs_(c1, c2, c3);

        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':    return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':    return getScaledDataColorRgb(          color[1], color[2], color[3]);

        case 'hsv':    return getScaledDataColorHs_('hsv',    color[1], color[2], color[3]);
        case 'hsl':    return getScaledDataColorHs_('hsl',    color[1], color[2], color[3]);

        case 'hclokl': return getScaledDataColorHcl('hclokl', color[1], color[2], color[3]);
        case 'hcllab': return getScaledDataColorHcl('hcllab', color[1], color[2], color[3]);
        case 'hclluv': return getScaledDataColorHcl('hclluv', color[1], color[2], color[3]);

        case 'oklab':  return getScaledDataColorOpp('oklab',  color[1], color[2], color[3]);
        case 'lab':    return getScaledDataColorOpp('lab',    color[1], color[2], color[3]);
        case 'luv':    return getScaledDataColorOpp('luv',    color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function getColorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return rgbFactor;

        case 'hsv':   
        case 'hsl':    return hs_Factor;

        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':    return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return rgbScale;

        case 'hsv':   
        case 'hsl':    return hs_Scale;

        case 'hclokl': return hcloklScale;
        case 'hcllab': return hcllabScale;
        case 'hclluv': return hclluvScale;

        case 'oklab':  return oklabScale;
        case 'lab':    return labScale;
        case 'luv':    return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':    return            col;

        case 'hsv':    return hsv2rgb   (col);
        case 'hsl':    return hsl2rgb   (col);

        case 'hclokl': return hclokl2rgb(col);
        case 'hcllab': return hcllab2rgb(col);
        case 'hclluv': return hclluv2rgb(col);

        case 'oklab':  return oklab2rgb (col);
        case 'lab':    return lab2rgb   (col);
        case 'luv':    return luv2rgb   (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':    return convert2rgb   (color);

        case 'hsv':    return convert2hsv   (color);
        case 'hsl':    return convert2hsl   (color);

        case 'hclokl': return convert2hclokl(color);
        case 'hcllab': return convert2hcllab(color);
        case 'hclluv': return convert2hclluv(color);

        case 'oklab':  return convert2oklab (color);
        case 'lab':    return convert2lab   (color);
        case 'luv':    return convert2luv   (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    rgb =            col;  break;

        case 'hsv':    rgb = hsv2rgb   (col); break;
        case 'hsl':    rgb = hsl2rgb   (col); break;

        case 'hclokl': rgb = hclokl2rgb(col); break;
        case 'hcllab': rgb = hcllab2rgb(col); break;
        case 'hclluv': rgb = hclluv2rgb(col); break;

        case 'oklab':  rgb = oklab2rgb (col); break;
        case 'lab':    rgb = lab2rgb   (col); break;
        case 'luv':    rgb = luv2rgb   (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hsv = rgb2hsv(           col ); break;

        case 'hsv':    hsv =                    col;   break;
        case 'hsl':    hsv = rgb2hsv(hsl2rgb   (col)); break;

        case 'hclokl': hsv = rgb2hsv(hclokl2rgb(col)); break;
        case 'hcllab': hsv = rgb2hsv(hcllab2rgb(col)); break;
        case 'hclluv': hsv = rgb2hsv(hclluv2rgb(col)); break;

        case 'oklab':  hsv = rgb2hsv(oklab2rgb (col)); break;
        case 'lab':    hsv = rgb2hsv(lab2rgb   (col)); break;
        case 'luv':    hsv = rgb2hsv(luv2rgb   (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hsl = rgb2hsl(           col ); break;

        case 'hsv':    hsl = rgb2hsl(hsv2rgb   (col)); break;
        case 'hsl':    hsl =                    col;   break;

        case 'hclokl': hsl = rgb2hsl(hclokl2rgb(col)); break;
        case 'hcllab': hsl = rgb2hsl(hcllab2rgb(col)); break;
        case 'hclluv': hsl = rgb2hsl(hclluv2rgb(col)); break;

        case 'oklab':  hsl = rgb2hsl(oklab2rgb (col)); break;
        case 'lab':    hsl = rgb2hsl(lab2rgb   (col)); break;
        case 'luv':    hsl = rgb2hsl(luv2rgb   (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function convert2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    lab = rgb2oklab(           col ); break;

        case 'hsv':    lab = rgb2oklab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2oklab(hsl2rgb   (col)); break;

        case 'hclokl': lab = rgb2oklab(hclokl2rgb(col)); break;
        case 'hcllab': lab = rgb2oklab(hcllab2rgb(col)); break;
        case 'hclluv': lab = rgb2oklab(hclluv2rgb(col)); break;

        case 'oklab':  lab =                      col;   break;
        case 'lab':    lab = rgb2oklab(lab2rgb   (col)); break;
        case 'luv':    lab = rgb2oklab(luv2rgb   (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    lab = rgb2lab(           col ); break;

        case 'hsv':    lab = rgb2lab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2lab(hsl2rgb   (col)); break;

        case 'hclokl': lab = rgb2lab(hclokl2rgb(col)); break;
        case 'hcllab': lab =         hcllab2lab(col);  break;
        case 'hclluv': lab = rgb2lab(hclluv2rgb(col)); break;

        case 'oklab':  lab = rgb2lab(oklab2rgb (col)); break;
        case 'lab':    lab =                    col;   break;
        case 'luv':    lab = rgb2lab(luv2rgb   (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    luv = rgb2luv(           col ); break;

        case 'hsv':    luv = rgb2luv(hsv2rgb   (col)); break;
        case 'hsl':    luv = rgb2luv(hsl2rgb   (col)); break;

        case 'hclokl': luv = rgb2luv(hclokl2rgb(col)); break;
        case 'hcllab': luv = rgb2luv(hcllab2rgb(col)); break;
        case 'hclluv': luv =         hclluv2luv(col);  break;

        case 'oklab':  luv = rgb2luv(oklab2rgb (col)); break;
        case 'lab':    luv = rgb2luv(lab2rgb   (col)); break;
        case 'luv':    luv =                    col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclokl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hcl = rgb2hclokl(           col);  break;

        case 'hsv':    hcl = rgb2hclokl(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclokl(hsl2rgb   (col)); break;

        case 'hclokl': hcl =                       col;   break;
        case 'hcllab': hcl = rgb2hclokl(hcllab2rgb(col)); break;
        case 'hclluv': hcl = rgb2hclokl(hclluv2rgb(col)); break;

        case 'oklab':  hcl = rgb2hclokl(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclokl(lab2rgb   (col)); break;
        case 'luv':    hcl = rgb2hclokl(luv2rgb   (col)); break;
    }

    return [
       'hclokl',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcllab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hcl = rgb2hcllab(           col) ; break;
        
        case 'hsv':    hcl = rgb2hcllab(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hcllab(hsl2rgb   (col)); break;
        
        case 'hclokl': hcl = rgb2hcllab(hclokl2rgb(col)); break;
        case 'hcllab': hcl =                       col;   break;
        case 'hclluv': hcl = rgb2hcllab(hclluv2rgb(col)); break;
        
        case 'oklab':  hcl = rgb2hcllab(oklab2rgb (col)); break;
        case 'lab':    hcl = lab2hcllab(           col ); break;
        case 'luv':    hcl = rgb2hcllab(luv2rgb   (col)); break;
    }

    return [
       'hcllab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hcl = rgb2hclluv(           col ); break;

        case 'hsv':    hcl = rgb2hclluv(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclluv(hsl2rgb   (col)); break;

        case 'hcllab': hcl = rgb2hclluv(hcllab2rgb(col)); break;
        case 'hclluv': hcl =                       col;   break;
        case 'hclokl': hcl = rgb2hclluv(hclokl2rgb(col)); break;

        case 'oklab':  hcl = rgb2hclluv(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclluv(lab2rgb   (col)); break;
        case 'luv':    hcl = luv2hclluv(           col ); break;
    }

    return [
       'hclluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


function validateColor(color, order, margin1, margin2, margin3)
{
    let i1, i2, i3;
    
         if (order == 0) { i1 = 0; i2 = 1; i3 = 2; } // HCL
    else if (order == 1) { i1 = 1; i2 = 0; i3 = 2; } // CHL
    else if (order == 2) { i1 = 1; i2 = 2; i3 = 0; } // CLH
    else if (order == 3) { i1 = 0; i2 = 2; i3 = 1; } // HLC
    else if (order == 4) { i1 = 2; i2 = 0; i3 = 1; } // LHC
    else if (order == 5) { i1 = 2; i2 = 1; i3 = 0; } // LCH
 
                                  color = validateChannel(color, i1, margin1);
    if (!dataColorIsValid(color)) color = validateChannel(color, i2, margin2);
    if (!dataColorIsValid(color)) color = validateChannel(color, i3, margin3);

    return color;
}



function validateChannel(color, iChan, margin)
{
    const factor = getColorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsValid(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorValid(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorValid( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsValid(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorValid(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsValid(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorValid(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorValid(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsValid(color);
}



function getValidateMax(order)
{
    switch (order)
    {
        case 0: return [180, 100, 100]; // HCL
        case 1: return [100, 180, 100]; // CHL
        case 2: return [100, 100, 180]; // CLH
        case 3: return [180, 100, 100]; // HLC
        case 4: return [100, 180, 100]; // LHC
        case 5: return [100, 100, 180]; // LCH
    }

    // should never get here
    return [0, 0, 0];
}



function genFindCorrection(nodeId, 
                           inputColor, 
                           param1,  param2,  param3, 
                           locked1, locked2, locked3)
{
    const refOklab = dataColor2array(convert2oklab(inputColor));

    let
  [ closestOklab,
    closestOrder,
    closest1,
    closest2,
    closest3 ] = findCorrection(
                     nodeId, 
                     inputColor, 
                     refOklab, 
                     param1,  param2,  param3, 
                     locked1, locked2, locked3); 

//   [ closestOrder,
//     closest1, closest2, closest3,
//     locked1,  locked2,  locked3 ] = reorderCorrection(
//                                         closestOrder,
//                                         closest1, closest2, closest3,
//                                         locked1,  locked2,  locked3);

    genQueueMessageToUI(
    {
        cmd:         'uiEndFindCorrection',
        nodeId:       nodeId,
        success:      closestOklab != null,
        closestOrder: closestOrder,
        closest1:     closest1,
        closest2:     closest2,
        closest3:     closest3
    });
}



function findCorrection(nodeId, 
                        color, 
                        refOklab, 
                        param1,  param2,  param3, 
                        locked1, locked2, locked3) 
{
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);


    let d = 1;

    while (d > 1/1024)
    {
        let _closestColor = [...closestColor];


        for (let order = 0; order < 6; order++)
        {
            closestColor = [..._closestColor];

            const [max1, max2, max3] = getValidateMax(order);

            let start1 = lerp(0, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(0, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(0, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = param1; start1 = closest1; end1 = start1+Eps; }
            if (locked2) { closest2 = param2; start2 = closest2; end2 = start2+Eps; }
            if (locked3) { closest3 = param3; start3 = closest3; end3 = start3+Eps; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = findCorrectionInOrder(
                nodeId,
                refOklab,
                order, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }

        
        d /= 2;
    }


    // reduce closest to necessary minimums

    const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

    let c1 = closest1;
    let c2 = closest2;
    let c3 = closest3;

    // console.log('closest1', closest1);
    // console.log('closest2', closest2);
    // console.log('closest3', closest3);
    // console.log('');

    while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
    while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
    while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

    closest1 = Math.max(0, c1);
    closest2 = Math.max(0, c2);
    closest3 = Math.max(0, c3);

    // console.log('closest1', closest1);
    // console.log('closest2', closest2);
    // console.log('closest3', closest3);
    // console.log('');

    
    return [
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



function findCorrectionInOrder(nodeId,
                               refOklab,
                               order, 
                               locked1,  locked2,  locked3,
                               closest1, closest2, closest3,
                               start1,   start2,   start3, 
                               end1,     end2,     end3,
                               closestColor,
                               closestOklab,
                               closestOrder,
                               progress,
                               total)
{
    const color = [...closestColor];

    // console.log('order', order);
    // console.log('-------------------')

    // console.log('locked1',  locked1);
    // console.log('start1',   start1);
    // console.log('end1',     end1);
    
    // console.log('locked2',  locked2);
    // console.log('start2',   start2);
    // console.log('end2',     end2);
    
    // console.log('locked3',  locked3);
    // console.log('start3',   start3);
    // console.log('end3',     end3);

    // console.log('-------------------')
    // console.log('')

    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsValid(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    closestOrder = order;
                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;

                    console.log('order', order);
                    console.log('closest1', closest1);
                    console.log('closest2', closest2);
                    console.log('closest3', closest3);
                    console.log('');
                }

                progress++;
            }
        }

        genQueueMessageToUI(
        {
            cmd:     'uiUpdateFindCorrection',
            nodeId:   nodeId,
            progress: progress / total
        });
    }


    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = validateColor(color, order, m1, m2, m3);
    const _oklab = dataColor2array(convert2oklab(_color));
    const _rgb   = oklab2rgb(_oklab);

    return [_color, _oklab, _rgb];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Eps
        && c2.closest <  Eps
        && c3.closest >= Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Eps
          && c2.closest <  Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



</script>


<script>
'use strict';

////////////////////////////////////////////////////


const smallScrollGap =  6;
const largeScrollGap = 14;

const MAX_INT32      = 2147483647;

const NULL           = '';

const TAB            = '  ';
const NL             = '\n';

const GEN_LOGO       = 'G';


function rgbFromType(type, active)
{
    switch (type)
    {
        case NUMBER_VALUE:    
        case NUMBER:    
        case NUMBER_LIMITS:
        case NUMBER_ADD:
        case NUMBER_SUBTRACT:
        case NUMBER_MULTIPLY:
        case NUMBER_DIVIDE:
        case NUMBER_MODULO:
        case NUMBER_EXPONENT:
        case NUMBER_INTERPOLATE: 
            return active 
                ? (isDarkMode() ? rgbActiveNumberDark : rgbActiveNumberLight)
                : (isDarkMode() ? rgbNumberDark       : rgbNumberLight      );

        case COLOR_VALUE:           

        case COLOR:           
        case COLOR_INTERPOLATE:
        case COLOR_VALIDATE:
        case COLOR_CONTRAST:
        case COLORBLIND:
            return active 
                 ? rgbActiveColor  
                 : rgbColor;

        case SHAPE_VALUE:
        case RECTANGLE_VALUE: 
        case LINE_VALUE: 
        case ELLIPSE_VALUE: 
        case POLYGON_VALUE: 
        case STAR_VALUE: 
        
        case RECTANGLE: 
        case LINE: 
        case ELLIPSE: 
        case POLYGON: 
        case STAR: 
        
        case FILL_VALUE:
        case STROKE_VALUE:
            
        case FILL:
        case STROKE:
            return active 
                ? (isDarkMode() ? rgbActiveObjectDark : rgbActiveObjectLight)
                : (isDarkMode() ? rgbObjectDark       : rgbObjectLight      );
    }

    return 'magenta';
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


const Eps = 0.0000001;



function toInt(f)
{
    return Math.floor(f) | 0;
}



function nozero(x)
{
    return x != 0 ? x : Eps;
}



function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     var str = Number(num).toFixed(dec).toString();

//     var i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (array.length == 0)
        return null;

    let last = lastOf(array);
    array.splice(array.length-1, 1)

    return last;
}



function beforeLastOf(array)
{
    return array.length > 1 
         ? array[array.length-2]
         : null;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}


function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function stringToArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function arrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function getQueryVariable(strVar)
{
    var query = window.location.search.substring(1);
    var vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function equal(a, b)
{
    return Math.abs(b - a) < Eps;
}



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function distance(p1, p2)
{
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1v2 = v1v2sin "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 22 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    var dx = x2 - x1;
    var dy = y2 - y1;

    var angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    var m = [[0, 0, 0],
             [0, 0, 0],
             [0, 0, 0]];

    for (var i = 0; i < 3; i++)
    {
        for (var j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (var k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function gcd(a, b)
{
    var temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



// function ipow(n, e)
// {
//     var res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    var carry = 0n;
    
    // multiply individual digits of res[] by n
    for (var i = 0; i < resSize; i++) 
    {
        var prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    var num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    var d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (var i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    var val = 0;
    var mul = 1;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        var r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        var r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    var t0 = 0;
    var t1 = 1;

    var dx = x2 - x1;
    var dy = y2 - y1;

    var cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    var cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    var ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    var cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    var v1 = subv(p2, p1);
    var v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    var t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    var t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    var d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    var cp = closestPointOnLine(p0, p1, p, false);

    var xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    var size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (var i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    var rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    var c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    var d = x - 1n;
    var s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (var i = 0; i < k; i++)    
    {
        var a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    var x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (var j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    var val = 0n;
    var mul = 1n;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    var size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (var i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    var gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    var gcd = bigGcdExtended(m % n, n);

    var x = gcd[1];
    var y = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l() { return this.x;            }
    get c() { return this.x + this.w/2; }
    get r() { return this.x + this.w;   }

    get t() { return this.y;            }
    get m() { return this.y + this.h/2  }
    get b() { return this.y + this.h;   }

    get tl() { return point(this.l, this.t); }
    get tc() { return point(this.c, this.t); }
    get tr() { return point(this.r, this.t); }
    get ml() { return point(this.l, this.m); }
    get mc() { return point(this.c, this.m); }
    get cm() { return point(this.c, this.m); }
    get mr() { return point(this.r, this.m); }
    get bl() { return point(this.l, this.b); }
    get bc() { return point(this.c, this.b); }
    get br() { return point(this.r, this.b); }


    get width()  { return this.w; }
    get height() { return this.h; }

    get left()   { return this.l; }
    get center() { return this.c; }
    get right()  { return this.r; }
    
    get top()    { return this.t; }
    get middle() { return this.m; }
    get bottom() { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;


    constructor(seed = 0xb9ef7ca4) { this.seed = seed; }


    next()
    {
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

	/*	Using Thomas Wang's 64-bit int hashing algorithm to generate
		predictable pseudo-random values that work with clip regions.  */

	//#define HASH(x)	\
	//	(x) = (~(x)) + ((x) << 21); \
	//	(x) = (x) ^ ((x) >> 24); \
	//	(x) = ((x) + ((x) << 3)) + ((x) << 8); \
	//	(x) = (x) ^ ((x) >> 14); \
	//	(x) = ((x) + ((x) << 2)) + ((x) << 4); \
	//	(x) = (x) ^ ((x) >> 28); \
	//	(x) = (x) + ((x) << 31);
}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function countToString(items, itemName)
{
    return itemName + (items.length == 1 ? '' : 's');
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');//getUserDecimalSeparator());
    const commaIndex = strValue.indexOf(',');//getUserDecimalSeparator());

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    var svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function show(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hide(element)              
{ 
    show(element, false); 
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    var size = Math.min(srcSize, dstSize);

    for (var i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    var newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function isEmpty(array)
{
    return array.length == 0;
}



function arraysEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (var i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function removeFromArray(array, item)
{
    var index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeFromArrayWhere(array, where)
{
    var index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    var str = '';

    for (var i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function boolString(bool)
{
    return bool ? 'true' : 'false';
}



function printNum(num)
{
    return !isNaN(num) ? num : INVALID;
}



function parseNum(str)
{
    return str == '?' ? Number.NaN : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return '';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return ' ';
    }
}



function parseBool(str)
{
    return str === 'true';
}



function osCtrl()  { return isMac ? '' : 'Ctrl+';  }
function osAlt()   { return isMac ? '' : 'Alt+';   }
function osShift() { return isMac ? ''  : 'Shift+'; }


"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    var base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    var inLen  = base64.length;

    var outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    var bytes = new Uint8Array(outLen);

    for (var mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    var mod3   = 2, 
        base64 = "";

    var length = bytes.length;

    for (var i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    var str    = "";
    var length = bytes.length;

    for (var i = 0; i < length; i++) 
    {
        var byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    var strLen = str.length, 
        arrLen = 0;


    // mapping

    for (var i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    var bytes = new Uint8Array(arrLen);


    // transcription

    for (var i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        var chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function enableElementText(elem, enable)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 
    elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    var elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    var e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



// function readTextFromClipboard() 
// {
//     if (   navigator.clipboard 
//         && window.isSecureContext) 
//         return navigator.clipboard.readText();

//     else 
//     {
//         let textArea = document.createElement('textarea');

//         textArea.style.position = 'fixed';
//         textArea.style.left     = '-999999px';
//         textArea.style.top      = '-999999px';
        
//         document.body.appendChild(textArea);
        
//         textArea.focus();
//         textArea.select();
        
//         return new Promise((res, rej) => 
//         {
//             document.execCommand('paste') ? res(textArea.value) : rej();
//             textArea.remove();
//         });
//     }
// }


const nodeTag = 'G_NODE';
const connTag = 'G_CONN';



function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


function nodeArrayToString(nodes)
{
    let str = '';

    for (let i = 0; i < nodes.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodes[i] ? nodes[i].id : 'undefined';
    }

    return str;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + TAB.repeat(Math.max(0, this.nTab)); 
    }
}



function logFunction(funcName)
{
    console.log(
        '%c ' + funcName + ' ', 
        'background: #09f; color: white;');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = ' ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nValues = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + TAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nValues;

        newLine = true;

        nTab++;

        for (let j = 0; j < nValues; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + TAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'background: #ddeeff');
}


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = ' ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReqNodeId(node)
{
    return ' ' 
         + logReqId(node.nodeId)
         + logReqOptions(node);
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if (node.options.active)
        log += ' ' + ACTIVE;

    if (node.options.beforeActive)
        log += ' ' + BEFORE_ACTIVE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}


function logReqNumberValue(val, parse)
{
    parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
}



function logReqNumber(num, parse)
{
    parse.log += parse.tab + NUMBER;
    parse.log += logReqNodeId(num);
}



function logReqLimits(lim, nValues, parse)
{
    parse.log += parse.tab + NUMBER_LIMITS;
    parse.log += logReqNodeId(lim);

    if (nValues > -1)
        parse.log += ' ' + nValues;
}



function logReqArithmetic(arith, type, nValues, parse)
{
    parse.log += parse.tab + type;
    parse.log += logReqNodeId(arith);
    parse.log += ' ' + nValues;
}



function logReqInterpolate(lerp, nValues, parse)
{
    parse.log += parse.tab + NUMBER_INTERPOLATE;
    parse.log += logReqNodeId(lerp);
    parse.log += ' ' + nValues;
}


function logReqColorValue(val, parse)
{
    parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
}



function logReqColor(col, parse) 
{
    logReqNode(col, parse); 
}



function logReqColorInterpolate(lerp, nValues, parse)
{
    parse.log += parse.tab + COLOR_INTERPOLATE;
    parse.log += logReqNodeId(lerp);
    parse.log += ' ' + nValues;
}



function logReqColorContrast(lerp, nValues, valueIndex, parse)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp);
    parse.log += ' ' + nValues;

    if (nValues == 1)
        parse.log += ' ' + valueIndex;
}



function logReqColorBlind(cb, parse)
{
    parse.log += parse.tab + COLORBLIND;
    parse.log += logReqNodeId(cb);
}



function logReqColorValidate(val, parse)
{
    parse.log += parse.tab + COLOR_VALIDATE;
    parse.log += logReqNodeId(val);
}


function logReqFillValue(fill, parse)
{
    parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
}



function logReqFill(fill, parse)
{
    parse.log += parse.tab + fill.type;
    parse.log += logReqNodeId(fill);
}



function logReqStrokeValue(stroke, parse)
{
    parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
}



function logReqStroke(stroke, parse)
{
    parse.log += parse.tab + stroke.type;
    parse.log += logReqNodeId(stroke);
}



function logReqColorStopValue(stop, parse)
{
    parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
}



function logReqColorStop(stop, parse)
{
    parse.log += parse.tab + stop.type;
    parse.log += logReqNodeId(stop);
}


function logReqShape(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



// Observer = 2

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v > 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    while (h < 0) h += 1;
    while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k * xw + 0.16)/1.16;
    yw = yw > e ? Math.cbrt(yw) : (k * yw + 0.16)/1.16;
    zw = zw > e ? Math.cbrt(zw) : (k * zw + 0.16)/1.16;

    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = cube(6/29) / 100;
    const k = cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16)/k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16)/k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16)/k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


const okLabScale = 5.8209716167;



function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l_, a_, b_) 
{
    return [
        l_ + 0.3963377774 * a_ + 0.2158037573 * b_,
        l_ - 0.1055613458 * a_ - 0.0638541728 * b_,
        l_ - 0.0894841775 * a_ - 1.2914855480 * b_ ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclokl2rgb(hcl, cs = sRGB)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 
    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclokl2rgb_(h, c, l, cs = sRGB)
{
    return hclokl2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclokl(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));
    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);
    return hcl;
}



function rgb2hclokl_(r, g, b, cs = sRGB)
{
    return rgb2hclokl([r, g, b], cs);
}



function hcllab2lab(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hcllab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hcllab2lab(hcl), cs);
}



function lab2hcllab(lab)
{
    let hcl = opp2pol(lab);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hcllab(rgb, cs = sRGB)
{
    return lab2hcllab(rgb2lab(rgb, cs));
}



function hclluv2luv(hcl)
{
    hcl[0] *= Tau;
    hcl[1] *= hcl[2];
    return pol2opp(hcl);
}



function hclluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hclluv2luv(hcl), cs);
}



function luv2hclluv(luv)
{
    let hcl = opp2pol(luv);
    hcl[0] /= Tau;
    hcl[1] /= hcl[2];
    return hcl;
}



function rgb2hclluv(rgb, cs = sRGB)
{
    return luv2hclluv(rgb2luv(rgb, cs));
}


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);



// function colorIsNaN(c)
// {
//     return isNaN(c[0])
//         || isNaN(c[1])
//         || isNaN(c[2]);
// }



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = Eps)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbIsOk(rgb, lim = Eps)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = Eps)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const dataColor_NaN = [
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ];


var style2rgba_canvas;
var style2rgba_context;
    


function initColor()
{
    style2rgba_canvas  = document.createElement('canvas');
    style2rgba_context = style2rgba_canvas.getContext('2d');
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclokl(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < Eps
        && Math.abs(rgb1[1] - rgb2[1]) < Eps
        && Math.abs(rgb1[2] - rgb2[2]) < Eps;        
}



function style2rgba(style) 
{
    style2rgba_context.fillStyle = style;
    style2rgba_context.fillRect(0, 0, 1, 1);

    return rgbaDiv(style2rgba_context.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) 
{
    style2rgba_context.fillStyle = getStyleValue(obj, style);
    style2rgba_context.fillRect(0, 0, 1, 1);

    return rgbaDiv(style2rgba_context.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb)  ? [1, 1, 1, 1] : [0, 0, 0, 0.92])
               : (isDarkMode() ? [1, 1, 1, 1] : [0, 0, 0, 0.92]))
           : (isDarkMode() ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningStyle(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? '#ffffff29' : '#00000022')
         : (isDarkMode() ? '#ffffff08' : '#00000006'); 
}


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '?'
{
    return hex.indexOf(INVALID) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }

    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    return rgb;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const cryptoModulusSize     = 64; // to keep the keys short
const millerRabinIterations = 40;

const cryptoBufferSize      = cryptoModulusSize/8;
const cryptoPrimeBufferSize = cryptoBufferSize /2;
     
const cryptoBuffer          = new Uint8Array(cryptoPrimeBufferSize);


function bigCryptoRandom()
{
    for (var i = 0; i < cryptoPrimeBufferSize; i++)
        cryptoBuffer[i] = toInt(Math.random() * 0x100);

    cryptoBuffer[0]                       |= 0xC0; // set the top bit to ensure a relatively large number
    cryptoBuffer[cryptoPrimeBufferSize-1] |= 0x01; // set low bit to ensure the number is odd

    return bigFromBuffer(cryptoBuffer);
}



function bigNextCryptoPrime(n) 
{
    while (!bigIsPrime(n))
        n += 2n;
    
    return n;
}



function bigCryptoPrime(e)
{
    // set p so that gcd(e, p-1) = 1
    
    var p;

    do
    {
        var rnd = bigCryptoRandom();
        p       = bigNextCryptoPrime(rnd);
    }
    while (gcd(p-1n, e) != 1n); 
        
    return p;
}



function createCryptoKeys()
{
    var e = 65537n; // 0x10001


    // var p = bigCryptoPrime(e);
    
    // var q;
    // do { q = bigCryptoPrime(e); } 
    // while (q == p);

    
    // if (p < q)
    //     [p,q] = [q,p];

    
    // console.log('p: ' + p);
    // console.log('q: ' + q);


    var p = 4131437551n,
        q = 3567532051n;
    

    var n   = p * q;
    var phi = (p-1n) * (q-1n);

    var d = bigModInvert(e, phi);


    return {
        public:  {n:n, e:e },
        private: {n:n, d:d, p:p, q:q} };
}                        



function encryptBlock(n, key, sign  ) { return bigPowMod(n, (sign   ? key.d : key.e), key.n); }        
function decryptBlock(n, key, verify) { return bigPowMod(n, (verify ? key.e : key.d), key.n); }        



function encrypt(data, key) { return encryptData(data, key, false); }
function decrypt(data, key) { return decryptData(data, key, false); }

function sign   (data, key) { return encryptData(data, key, true); } // yes I know real sign/verify uses a hash,
function verify (data, key) { return decryptData(data, key, true); } // but I prefer it this way for what I need



function encryptData(data, key, sign)
{
    // prep array should be a multiple of cryptoBufferSize
    var prep   = new Uint8Array(Math.ceil((data.length) / cryptoBufferSize) * cryptoBufferSize); 
    var cipher = new Uint8Array(prep.length);


    var start = prep.length - data.length;
    for (var i = 0; i < data.length; i++)
        prep[start+i] = data[i];


    var length = prep.length;
    var nBlock = 0;

    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);
        
        var block = bigFromBufferAt(prep, blockStart, cryptoBufferSize);
        var enc   = encryptBlock(block, key, sign);
        
        bigToBufferAt(enc, cipher, blockStart, cryptoBufferSize);
        
        nBlock++;
        length -= blockSize;
    }
    
    
    return cipher;
}



function decryptData(cipher, key, verify)
{
    var data = new Uint8Array(cipher.length);
    
    
    var length = cipher.length;
    var nBlock = 0;
    
    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);

        var block = bigFromBufferAt(cipher, blockStart, cryptoBufferSize);
        var dec   = decryptBlock(block, key, verify);
        bigToBufferAt(dec, data, blockStart, cryptoBufferSize); 

        nBlock++;
        length -= blockSize;
    }    


    return data;    
}


const base32chars = '12345679ABCDEFGHJKLMNPQRSTUVWXYZ';



function arrayToBase32(array, chars = base32chars)
{
    var base32 = '';

    
    var len = array.length;
    var i   = 0;

    while (len > 0)
    {
        if (len >= 5)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3],
                a4 = array[i+4];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[ (a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) <<  3) | ((a4 & 0xE0) >>> 5)];
            base32 += chars[ (a4 & 0x1F)];
        }
        else if (len == 4)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2],
                a3 = array[i+3];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[ (a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) <<  3)];
        }
        else if (len == 3)
        {
            var a0 = array[i  ],
                a1 = array[i+1],
                a2 = array[i+2];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1)];
        }
        else if (len == 2)
        {
            var a0 = array[i  ],
                a1 = array[i+1];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4)];
        }
        else if (len == 1)
        {
            var a0 = array[i];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2)];
        }


        i   += 5;
        len -= 5;
    }


    return base32;
}



function base32toArray(base32, chars = base32chars)
{
    var array = [];


    var len = base32.length;
    var c   = 0;

    while (len > 0)
    {
        if (len >= 8)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]),
                c7 = chars.indexOf(base32[c+7]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
            array.push(((c6 & 0x07) << 5) | c7);
        }
        else if (len == 7)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]),
                c5 = chars.indexOf(base32[c+5]),
                c6 = chars.indexOf(base32[c+6]);

            array.push(( c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
        }
        else if (len == 5)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]),
                c4 = chars.indexOf(base32[c+4]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
        }
        else if (len == 4)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]),
                c2 = chars.indexOf(base32[c+2]),
                c3 = chars.indexOf(base32[c+3]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
        }
        else if (len == 2)
        {
            var c0 = chars.indexOf(base32[c  ]),
                c1 = chars.indexOf(base32[c+1]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
        }


        c   += 8;
        len -= 8;
    }


    return array;
}


const INVALID             = '?';
const DISPLAY_INVALID     = INVALID;//'';


const NUMBER_VALUE        = 'N';     // value (s) (with significant decimals)

const NUMBER              = 'NUM';   // N | n
const NUMBER_LIMITS       = 'LIM';   // N:min N:max
const NUMBER_ADD          = 'ADD';   // count N...
const NUMBER_SUBTRACT     = 'SUB';   // count N...
const NUMBER_MULTIPLY     = 'MUL';   // count N...
const NUMBER_DIVIDE       = 'DIV';   // count N...
const NUMBER_MODULO       = 'MOD';   // count N...
const NUMBER_EXPONENT     = 'EXP';   // count N...
const NUMBER_MATH         = 'MATH';  // op count N...
const NUMBER_INTERPOLATE  = 'LERP';  // count N... N:amount


const NUMBER_TYPES =
[
    NUMBER_VALUE,

    NUMBER,
    NUMBER_LIMITS,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT,
    NUMBER_MATH,
    NUMBER_INTERPOLATE 
];


const STRING_VALUE        = 'S';     // "..." (s) (escape \\ and \")

const STRING              = 'STR';   // S | s
const STRING_ADD          = 'SADD';  // S S
const STRING_REPLACE      = 'SREPL'; // S S:what S:with


const COLOR_VALUE         = 'C';     // color value

const COLOR               = 'COL';   // C | N:space N:c1 N:c2 N:c3
const COLOR_INTERPOLATE   = 'CLERP'; // C C N:amount
const COLOR_VALIDATE      = 'CVLD';  // C
const COLOR_CONTRAST      = 'CCNT';  // C:text C:background
const COLORBLIND          = 'BLND';  // C


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    COLOR_INTERPOLATE,
    COLOR_VALIDATE,
    COLORBLIND
];


const FILL_VALUE = 'FL';
const FILL       = 'FILL';

const FILL_TYPES =
[
    FILL_VALUE,
    FILL
];


const STROKE_VALUE    = 'SK';
const STROKE          = 'STRK';

const STROKE_TYPES =
[
    STROKE_VALUE,
    STROKE
];


const COLOR_STOP_VALUE    = 'CS';
const COLOR_STOP          = 'CSTOP';

const GRADIENT_VALUE      = 'GR';
const GRADIENT            = 'GRAD';


const SHAPE_VALUE      = 'G0';    // abstract placeholder

const RECTANGLE_VALUE     = 'R';
const LINE_VALUE          = 'L';
const ELLIPSE_VALUE       = 'E';
const POLYGON_VALUE       = 'P';
const STAR_VALUE          = 'ST';

const RECTANGLE           = 'RECT';  // N:x N:y N:width N:height N:angle N:roundTL N:roundTR N:roundBL N:roundBR
const LINE                = 'LINE';  // N:x N:y N:width N:height N:angle
const ELLIPSE             = 'ELPS';  // N:x N:y N:width N:height N:angle
const POLYGON             = 'POLY';  // N:x N:y N:width N:height N:angle N:corners
const STAR                = 'STAR';  // N:x N:y N:width N:height N:angle N:points N:convex


const SHAPE_VALUES =
[
    SHAPE_VALUE,

    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    RECTANGLE,
    LINE,
    ELLIPSE,
    POLYGON,
    STAR//,
    //TEXT
];


const GROUP               = 'GRP';   // ???? count O...


const COMMENT             = 'CMNT';


const ACTIVE              = 'ACT';
const BEFORE_ACTIVE       = 'BEF';
const PARAM               = 'PARAM'; // nodeId paramId


const LOG                 = 'LOG';



/*

FRAME       F
IMAGE       I
SLICE       /
TEXT        T
VECTOR      V

*/


class GType
{
    type;

    result;
    valid; // has been evaluated

    topLevel;


    data = {}; // for type conversion info


    constructor(type) 
    {
        this.type     = type;

        this.result   = null;
        this.valid    = false;

        this.topLevel = false;
    }



    copy()
    {
        return null;
    }



    copyBaseData(obj)
    {
        this.data = clone(obj.data);
    }



    isValid() // is a valid value
    {
        return false;
    }



    equalChans(c1, c2)
    {
        return !c1 && !c2
            ||  c1 && c2 && c1.equals(c2);
    }


    eval(parse)
    {
        // calculate and add value update here

        return null;
    }



    toString() 
    { 
        return this.type; 
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case NUMBER_VALUE:    return parseNumberValue   (value)[0].toDisplayString();
        case COLOR_VALUE:     return parseColorValue    (value)[0].toDisplayString();
        case FILL_VALUE:      return parseFillValue     (value)[0].toDisplayString()
        case STROKE_VALUE:    return parseStrokeValue   (value)[0].toDisplayString()
        case RECTANGLE_VALUE: return parseRectangleValue(value)[0].toDisplayString()
    }


    console.assert(false, 'cannot display value of type \'' + type + '\'');
}


class GOperator
extends GType
{
    nodeId;
    options;



    constructor(type, nodeId, options)
    {
        super(type);

        this.nodeId  = nodeId;
        this.options = options;
    }



    toValue()
    {
        return null;
    }
}



class GParam
extends GOperator
{
    paramId;



    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    copy()
    {
        return new GParam(this.nodeId, this.paramId);
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const node = parse.parsedNodes.find(v => v.nodeId == this.nodeId).result;
            console.assert(node, 'can\'t find parameter node \'' + this.nodeId + '\'');


            this.result = node[this.paramId].eval(parse).copy();

            
            this.result.valid = true;
            this.valid        = true;
        }


        return this.result;
    }
}


class NumberValue
extends GType
{
    value;
    decimals;



    constructor(val, dec = 0)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
        { 
            console.trace();
            console.assert(false, 'NumberValue(value) is ' + typeof val + ', must be a number');
        }


        this.value    = val;
        this.decimals = dec;

        this.result   = null;
        this.valid    = true;
    }



    copy()
    {
        return new NumberValue(
            this.value, 
            this.decimals);
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    eval(parse)
    {
        return this;
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals); // only NumberValue can do this, other _Values have to list all members
    }



    toSimpleString()
    {
        return !isNaN(this.value)
            ? numToString(this.value, this.decimals)
            : INVALID; // only NumberValue can do this, other _Values have to list all members
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? subscriptNumber(this.decimals)
                : '');
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
    {
        //console.trace();
        console.assert(false, 'number value missing \',\'');
    }
    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == INVALID
        ? NumberValue.NaN
        : new NumberValue(
              parseFloat(str),
              decCount(str));

    return [num, 1];
}


class ColorValue
extends GType
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.result = null;
        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        console.assert(typeof space == 'number', 'ColorValue.create() space must be a number');
        console.assert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        console.assert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        console.assert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    copy()
    {
        const color = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        color.copyBaseData(this);

        return color;
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        return makeDataColor(
            this.space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toRgbString()
    {
        if (!this.isValid())
            return INVALID;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    // if (   i <  0 && str    == INVALID
    //     || i >= 0 && str[i] == INVALID)
    //     return [ColorValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart];
}


class FillValue
extends GType
{
    color;
    opacity;



    constructor(color   = ColorValue .NaN, 
                opacity = new NumberValue(100))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();

        this.result  = null;
        this.valid   = true;
    }


    
    static create(r, g, b, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity));
    }



    static fromRgb(rgb, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity));
    }



    copy()
    {
        const fill = new FillValue(
            this.color  .copy(),
            this.opacity.copy());

        fill.copyBaseData(this);

        return fill;
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    equals(fill)
    {
        return fill
            && this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity);
    }



    eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    toFigma()
    {
        return [['SOLID', this.toString()]];
    }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString();
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r = parseNumberValue(str[i]); i += r[1];
    const g = parseNumberValue(str[i]); i += g[1];
    const b = parseNumberValue(str[i]); i += b[1];
    const a = parseNumberValue(str[i]); i += a[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0]),
        i - iStart ];
}






function evalFillValue(value, parse)
{
    const fill = value.eval(parse).copy();

         if ( FILL_TYPES.includes(fill.type)) return fill;
    else if (COLOR_TYPES.includes(fill.type)) return new FillValue(fill, value.data.opacity);

    else console.assert(false, 'fill must have type');
}


class StrokeValue
extends GType
{
    fill;
    weight;
    fit;
    join;
    miter;



    constructor(fill   = FillValue  .NaN, 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2))
    {
        if (fill.type != FILL_VALUE)
        {
            console.trace();
            console.assert(false, 'fill.type must be FILL_VALUE');
        }


        super(STROKE_VALUE);

        this.fill   = fill  .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();

        this.result  = null;
        this.valid   = true;
    }


    
    // static create(r, g, b, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.create(1, r, g, b),
    //         new NumberValue(opacity));
    // }



    // static fromRgb(rgb, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.fromRgb(rgb),
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const stroke = new StrokeValue(
            this.fill  .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy());

        stroke.copyBaseData(this);

        return stroke;
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fill  .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter );
    }



    eval(parse)
    {
        return this;
    }



    toFigma()
    {
        let align, join;

        
        switch (this.fit.value)
        {
            case 0: align = 'INSIDE';  break;
            case 1: align = 'CENTER';  break;
            case 2: align = 'OUTSIDE'; break;
        }
        
        switch (this.join.value)
        {
            case 0: join = 'MITER'; break;
            case 1: join = 'BEVEL'; break;
            case 2: join = 'ROUND'; break;
        }

        
        return this.isValid()
            ? {
                  strokes:          this.fill.toFigma(),
                  strokeWeight:     this.weight.value,
                  strokeAlign:      align,
                  strokeJoin:       join,
                  strokeMiterLimit: this.miter.value
              }
            : {
                  strokes: []
              };
    }



    toString()
    {
        return      this.fill  .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString();
    }



    toDisplayString()
    {
        return      this.fill  .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString();
    }



    static NaN = Object.freeze(new StrokeValue(
        FillValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(new StrokeValue(
        FillValue.create(0, 0, 0, 100),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96)));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == INVALID
        || i >= 0 && str[i] == INVALID)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill   = parseFillValue  (str, i); i += fill  [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];


    return [
        new StrokeValue(fill[0], weight[0], fit[0], join[0], miter[0]),
        i - iStart ];
}



function evalStrokeValue(value, parse)
{
    const stroke = value.eval(parse).copy();

         if (STROKE_TYPES.includes(stroke.type)) return stroke;
    else if (  FILL_TYPES.includes(stroke.type)) return new StrokeValue(stroke, value.data.weight);
    else if ( COLOR_TYPES.includes(stroke.type)) return new StrokeValue(new FillValue(stroke), value.data.weight);

    else console.assert(false, 'stroke must have type');
}


/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeBaseValue
extends GType
{
    nodeId;

    // fill;
    // stroke;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 

        // this.fill   = FillValue.default.copy();
        // this.stroke = StrokeValue.NaN  .copy();
    }



    copyBase(base)
    {
        this.nodeId = base.nodeId;

        // this.fill   = base.fill  .copy();
        // this.stroke = base.stroke.copy();
    }



    isValid()
    {
        return true;
        // return this.fill  .isValid()
        //    && !this.stroke.isValid();
    }



    toFigmaObject()
    {
        return {
            nodeId: this.nodeId//,

            // fills:  this.fill.isValid() 
            //         ? this.fill.toFigma() 
            //         : [],
            
            // ...this.stroke.toFigma()
        }
    }



    // toString()
    // {
    //     return      this.fill  .toString()
    //         + ' ' + this.stroke.toString();
    // }



    // toDisplayString()
    // {
    //     return      this.fill  .toDisplayString()
    //         + ' ' + this.stroke.toDisplayString();
    // }
}



// function parseShapeBaseValue(str, i, obj)
// {
//     const fill   = parseFillValue  (str, i); i += fill  [1];
//     const stroke = parseStrokeValue(str, i); i += stroke[1];

//     obj.fill   = fill  [0];
//     obj.stroke = stroke[0];

//     return i;
// }


class RectangleValue
extends ShapeBaseValue
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        const rect = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy());

        // rect.copyBase(this);
        // rect.copyData(this);

        return rect;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid();

            //&& super      .isValid();
    }


    eval(parse)
    {
        return this.result = this.copy();
    }



    toFigmaObject()
    {
        return {
            type:   RECTANGLE,
            id:     0,
            x:      this.x     .value,
            y:      this.y     .value,
            width:  this.width .value,
            height: this.height.value,
            angle:  this.angle .value,
            round:  Math.max(0, this.round.value)//,
            //...super.toFigmaObject()
        };
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString();
            
            //+ ' ' + super.toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString();
            
            // + ' ' + super.toDisplayString();
    }



    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == INVALID
        || i >= 0 && str[i] == INVALID)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0],
        round [0]);


    // i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends GType
{
    x;
    y;
    width;
    angle;



    constructor(x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(LINE_VALUE);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.angle  = angle;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new LineValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.angle .copy());
    }



    isValid()
    {
        return !isNaN(this.x    )
            && !isNaN(this.y    )
            && !isNaN(this.width)
            && !isNaN(this.angle);
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.angle .toString();
    }



    static NaN = new LineValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str)
{
    if (str == INVALID)
        return LineValue.NaN;

    const rect = str.split(' ');

    return new LineValue(
        new NumberValue(parseNumberValue(rect[0])),
        new NumberValue(parseNumberValue(rect[1])),
        new NumberValue(parseNumberValue(rect[2])),
        new NumberValue(parseNumberValue(rect[3])));
}



class EllipseValue
extends GType
{
    x;
    y;
    width;
    height;
    angle;



    constructor(x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(ELLIPSE_VALUE);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new EllipseValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy());
    }



    isValid()
    {
        return !isNaN(this.x     )
            && !isNaN(this.y     )
            && !isNaN(this.width )
            && !isNaN(this.height)
            && !isNaN(this.angle );
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString();
    }



    static NaN = new EllipseValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str)
{
    if (str == INVALID)
        return EllipseValue.NaN;

    const rect = str.split(' ');

    return new EllipseValue(
        new NumberValue(parseNumberValue(rect[0])[0]),
        new NumberValue(parseNumberValue(rect[1])[0]),
        new NumberValue(parseNumberValue(rect[2])[0]),
        new NumberValue(parseNumberValue(rect[3])[0]),
        new NumberValue(parseNumberValue(rect[4])[0]));
}



class PolygonValue
extends GType
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                width   = new NumberValue(0), 
                height  = new NumberValue(0), 
                angle   = new NumberValue(0), 
                round   = new NumberValue(0), 
                corners = new NumberValue(0))
    {
        super(POLYGON_VALUE);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new PolygonValue(
            this.x      .copy(), 
            this.y      .copy(), 
            this.width  .copy(), 
            this.height .copy(), 
            this.angle  .copy(), 
            this.round  .copy(), 
            this.corners.copy());
    }



    isValid()
    {
        return !isNaN(this.x      )
            && !isNaN(this.y      )
            && !isNaN(this.width  )
            && !isNaN(this.height )
            && !isNaN(this.angle  )
            && !isNaN(this.round  )
            && !isNaN(this.corners);
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x      .toString()
            + ' ' + this.y      .toString()
            + ' ' + this.width  .toString()
            + ' ' + this.height .toString()
            + ' ' + this.angle  .toString()
            + ' ' + this.round  .toString()
            + ' ' + this.corners.toString();
    }



    static NaN = new PolygonValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str)
{
    if (str == INVALID)
        return PolygonValue.NaN;

    const rect = str.split(' ');

    return new PolygonValue(
        new NumberValue(parseNumberValue(rect[0])),
        new NumberValue(parseNumberValue(rect[1])),
        new NumberValue(parseNumberValue(rect[2])),
        new NumberValue(parseNumberValue(rect[3])),
        new NumberValue(parseNumberValue(rect[4])),
        new NumberValue(parseNumberValue(rect[5])),
        new NumberValue(parseNumberValue(rect[6])));
}



class StarValue
extends GType
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0), 
                points = new NumberValue(0),
                convex = new NumberValue(0))
    {
        super(STAR_VALUE);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;

        this.result = this;
        this.valid  = true;
    }



    copy()
    {
        return new StarValue(
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy(), 
            this.points.copy(),
            this.convex.copy());
    }



    isValid()
    {
        return !isNaN(this.x     )
            && !isNaN(this.y     )
            && !isNaN(this.width )
            && !isNaN(this.height)
            && !isNaN(this.angle )
            && !isNaN(this.round )
            && !isNaN(this.points)
            && !isNaN(this.convex);
    }



    eval(parse)
    {
        return this.result = this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString()
            + ' ' + this.points.toString()
            + ' ' + this.convex.toString();
    }



    static NaN = new StarValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str)
{
    if (str == INVALID)
        return StarValue.NaN;

    const rect = str.split(' ');

    return new StarValue(
        new NumberValue(parseNumberValue(rect[0])),
        new NumberValue(parseNumberValue(rect[1])),
        new NumberValue(parseNumberValue(rect[2])),
        new NumberValue(parseNumberValue(rect[3])),
        new NumberValue(parseNumberValue(rect[4])),
        new NumberValue(parseNumberValue(rect[5])),
        new NumberValue(parseNumberValue(rect[6])),
        new NumberValue(parseNumberValue(rect[7])));
}



class GNumber
extends GOperator
{
    input = null;
    value;
    


    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const num = new GNumber(this.nodeId, this.options);
        
        num.value = this.value;

        if (this.input) 
            num.input = this.input.copy();
        
        return num;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = 
                this.input
                ? this.input.eval(parse).copy()
                : this.value.copy();

            this.valid = true;

            console.assert(this.result.valid, 'this.result must be valid');
            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}


class GLimits
extends GOperator
{
    input = null;

    min;
    max;

    minMaxPriority = -1; 


    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const lim = new GLimits(this.nodeId, this.options);

        if (this.input) 
            lim.input = this.input.copy();

        lim.min = this.min.copy();
        lim.max = this.max.copy();

        lim.minMaxPriority = this.minMaxPriority;

        return lim;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.input)
                this.result = this.input.eval(parse).copy();


            const min = this.min.eval(parse).copy();
            const max = this.max.eval(parse).copy();


            // min.value = Math.min(min.value, max.value);
            // max.value = Math.max(min.value, max.value);


            this.result.value = Math.min(Math.max(
                min.value,
                this.result.value),
                max.value);


            this.valid        = true;
            this.result.valid = true;


            genPushUpdateValue(parse, this.nodeId, 'min',   min);
            genPushUpdateValue(parse, this.nodeId, 'max',   max);
            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GAdd
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const add = new GAdd(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return add;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            for (const _input of this.inputs)
            {
                const input = _input.eval(parse).copy();

                console.assert(
                    input.type == NUMBER_VALUE, 
                    'this.result.type must be NUMBER_VALUE');

                this.result.value   += input.value;
                this.result.decimals = Math.max(this.result.decimals, input.decimals);
            }
            
            
            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GSubtract
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const sub = new GSubtract(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return sub;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();

                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse);

                    console.assert(
                        input.type == NUMBER_VALUE, 
                        'this.result.type must be NUMBER_VALUE');
                        
                    this.result.value   -= input.value;
                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GMultiply
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }


    
    copy()
    {
        const mul = new GMultiply(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return mul;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.inputs.length > 0)
            {
                this.result.value = 1;

                for (const _input of this.inputs)
                {
                    const input = _input.eval(parse).copy();

                    this.result.value   *= input.value;
                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GDivide
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const div = new GDivide(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return div;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);

            
            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();


                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse).copy();

                    if (input.value == 0) 
                    { 
                        this.result.value    = Number.NaN; 
                        this.result.decimals = 0;
                        break; 
                    }

                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                    this.result.value    = floorTo(this.result.value / input.value, this.result.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GModulo
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const mod = new GModulo(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return mod;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);

            
            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();


                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse).copy();

                    if (input.value == 0) 
                    { 
                        this.result.value    = Number.NaN; 
                        this.result.decimals = 0;
                        break; 
                    }

                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                    this.result.value    = floorTo(this.result.value % input.value, this.result.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GExponent
extends GOperator
{
    inputs = [];



    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const exp = new GExponent(this.nodeId, this.options);
        add.inputs = this.inputs.map(i => i.copy());
        return exp;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new NumberValue(0);


            if (this.inputs.length > 0)
            {
                this.result = this.inputs[0].eval(parse).copy();

                for (let i = 1; i < this.inputs.length; i++)
                {
                    const input = this.inputs[i].eval(parse);

                    console.assert(
                        input.type == NUMBER_VALUE, 
                        'this.result.type must be NUMBER_VALUE');
                        
                    this.result.value    = Math.pow(this.result.value, input.value);
                    this.result.decimals = Math.max(this.result.decimals, input.decimals);
                }
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}



class GInterpolate
extends GOperator
{
    input0 = null;
    input1 = null;

    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const lerp = new GInterpolate(this.nodeId, this.options);

        if (this.input0) lerp.input0 = this.input0.copy();
        if (this.input1) lerp.input1 = this.input1.copy();

        lerp.amount = this.amount.copy();

        return lerp;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const amount = this.amount.eval(parse).copy();

            if (   this.input0 
                && this.input1)
            {
                const input0 = this.input0.eval(parse).copy();
                const input1 = this.input1.eval(parse).copy();

                const maxDec = Math.max(input0.decimals, input1.decimals);

                this.result = new NumberValue(
                    floorTo(input0.value + amount.value * (input1.value - input0.value) / 100, maxDec),
                    maxDec);
            }

            else if (this.input0) this.result = this.input0.eval(parse).copy();
            else if (this.input1) this.result = this.input1.eval(parse).copy();
            else                  this.result = new NumberValue(0);


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value',  this.result);
            genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        }


        return this.result;
    }
}



class GColor
extends GOperator
{
    input   = null;

    space   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }


    
    copy()
    {
        const col = new GColor(this.nodeId, this.options);

        if (this.input) 
            col.input = this.input.copy();

        col.space = this.space.copy();

        if (this.convert) 
            col.convert = this.convert.copy();

        if (this.c1) col.c1 = this.c1.copy();
        if (this.c2) col.c2 = this.c2.copy();
        if (this.c3) col.c3 = this.c3.copy();

        return col;
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    eval(parse)
    {
        if (this.valid)
            return;


        if (this.space) this.space.eval(parse);
        if (this.c1   ) this.c1   .eval(parse);
        if (this.c2   ) this.c2   .eval(parse);
        if (this.c3   ) this.c3   .eval(parse);


        let color;


        if (this.input)
        {
            this.input.eval(parse);

            
            if (this.input.isValid())
            {
                color = new ColorValue(
                    this.input.convert, 
                    this.input.c1, 
                    this.input.c2, 
                    this.input.c3);

                const fromSpaceIndex = color.space.value;

                color.space = this.space;

                const toSpaceIndex = Math.min(Math.max(
                    0,
                    color.space.value),
                    colorSpaceCount(parse)-1);

                this.convertColor(
                    color,
                    colorSpace(fromSpaceIndex), 
                    colorSpace(  toSpaceIndex));

                color.space.value = toSpaceIndex;

                
                if (this.c1) color.c1 = this.c1;
                if (this.c2) color.c2 = this.c2;
                if (this.c3) color.c3 = this.c3;
            }
        }
        else
        {
            color = new ColorValue(
                this.space, 
                this.c1, 
                this.c2, 
                this.c3);

            const toSpaceIndex = Math.min(Math.max(
                0,
                color.space.value),
                colorSpaceCount(parse)-1);

            color.space.value = toSpaceIndex;

            
            if (    this.convert
                && !isNaN(this.convert.value)
                &&  color.isValid())
            {
                this.convert.eval(parse);

                this.convertColor(
                    color,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }
        }


        console.assert(
            color.space.type == NUMBER_VALUE, 
            'this.result.type must be NUMBER_VALUE');


        genPushUpdateValue(parse, this.nodeId, 'space', color.space);
        genPushUpdateValue(parse, this.nodeId, 'c1',    color.c1   );
        genPushUpdateValue(parse, this.nodeId, 'c2',    color.c2   );
        genPushUpdateValue(parse, this.nodeId, 'c3',    color.c3   );


        this.valid = true;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2)];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    toColorValue()
    {
        return new ColorValue(
            this.space,
            this.c1,
            this.c2,
            this.c3);
    }



    // toDataColor()
    // {
    //     if (!this.isValid())
    //         return dataColor_NaN;

    //     return makeDataColor(
    //         this.space,
    //         this.c1,
    //         this.c2,
    //         this.c3);
    // }



    // toRgb()
    // {
    //     return dataColor2rgb(this.toDataColor());
    // }



    // toDisplayString()
    // {
    //     // console.log('this.space =', this.space);
    //     // console.log('this.c1 =', this.c1);
    //     // console.log('this.c2 =', this.c2);
    //     // console.log('this.c3 =', this.c3);
    //     return      this.space.toDisplayString()
    //         + ' ' + this.c1   .toDisplayString()
    //         + ' ' + this.c2   .toDisplayString()
    //         + ' ' + this.c3   .toDisplayString();
    // }
}


class GColorInterpolate
extends GOperator
{
    input0 = null;
    input1 = null;

    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const lerp = new GColorInterpolate(this.nodeId, this.options);

        if (this.input0) lerp.input0 = this.input0.copy();
        if (this.input1) lerp.input1 = this.input1.copy();

        lerp.space  = this.space .copy();
        lerp.amount = this.amount.copy();
        lerp.gamma  = this.gamma .copy();

        return lerp;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const space  = this.space .eval(parse).copy();
            const amount = this.amount.eval(parse).copy();
            const gamma  = this.gamma .eval(parse).copy();


            if (   this.input0 
                && this.input1)
            {
                const input0 = this.input0.eval(parse).copy();
                const input1 = this.input1.eval(parse).copy();


                console.assert(
                    amount.type == NUMBER_VALUE, 
                    'this.result.type must be NUMBER_VALUE');

                const f = amount.value / 100;

                const _space = colorSpace(space.value);

                const col0 = input0.toDataColor();
                const col1 = input1.toDataColor();

                const col = this.interpolate(
                    space.value,
                    convertDataColorToSpace(col0, _space),
                    convertDataColorToSpace(col1, _space),
                    f,
                    gamma.value);


                // allow interpolating invalid colors,
                // so no valid color check here

                const factor = getColorSpaceFactor(_space);

                this.result = ColorValue.create(
                    space.value,
                    col[1] * factor[0],
                    col[2] * factor[1],
                    col[3] * factor[2]);
            }

            else if (this.input0) this.result = this.input0.eval(parse).copy();
            else if (this.input1) this.result = this.input1.eval(parse).copy();

            else 
                this.result = ColorValue.NaN;


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value',  this.result);

            genPushUpdateValue(parse, this.nodeId, 'space',  space );
            genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        }


        return this.result;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (space <= 1) // hex, rgb
        {
            const r0 = Math.pow(col0[1], gamma);  const r1 = Math.pow(col1[1], gamma);
            const g0 = Math.pow(col0[2], gamma);  const g1 = Math.pow(col1[2], gamma);
            const b0 = Math.pow(col0[3], gamma);  const b1 = Math.pow(col1[3], gamma);

            gamma = Math.max(0.01, gamma);

            return [
                colorSpace(space),
                Math.pow(lerp(r0, r1, f), 1/gamma),
                Math.pow(lerp(g0, g1, f), 1/gamma),
                Math.pow(lerp(b0, b1, f), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }
}



class GColorContrast
extends GOperator
{
    input0 = null;
    input1 = null;

    standard;
    value;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }


    
    copy()
    {
        const cnt = new GColorContrast(this.nodeId, this.options);

        if (this.input0) cnt.input0 = this.input0.copy();
        if (this.input1) cnt.input1 = this.input1.copy();

        cnt.standard = this.standard.copy();
        cnt.value    = this.value   .copy();

        return cnt;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new ColorValue();

            const standard = this.standard.eval(parse).copy();


            if (   this.input0 
                && this.input1)
            {
                const input0 = this.input0.eval(parse).copy();
                const input1 = this.input1.eval(parse).copy();


                if (   input0.isValid()
                    && input1.isValid())
                {
                    this.result = input1;
                    
                    if (   dataColorIsValid(input0.toDataColor())
                        && dataColorIsValid(input1.toDataColor()))
                    {
                        if (standard.value == 0)
                        {
                            const value = getContrastRatio2(
                                input0.toRgb(),
                                input1.toRgb());

                            this.value = new NumberValue(value, 2);
                        }
                        else
                        {
                            const value = getContrastRatio3(
                                input0.toRgb(),
                                input1.toRgb());

                            this.value = new NumberValue(Math.abs(value), 1);
                        }
                    }
                    else
                        this.value = NumberValue.NaN;
                }
                else
                {
                    this.result = CGolorValue.NaN;
                    this.value  = NumberValue.NaN;
                }


                genPushUpdateValue(parse, this.nodeId, 'text', input0);
            }

            else if (this.input0) 
            {
                const input0 = this.input0.eval(parse).copy();

                if (input0.isValid())
                    genPushUpdateValue(parse, this.nodeId, 'text', input0);

                this.result = ColorValue.NaN;
                this.value  = NumberValue.NaN;
            }
            else if (this.input1) 
            {
                const input1 = this.input1.eval(parse).copy();

                if (input1.isValid())
                {
                    this.result = input1;
                    genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
                }
                else
                    this.result = ColorValue.NaN;
    
                this.value = NumberValue.NaN;
            }
            else
            {
                this.result = ColorValue.NaN;
                this.value  = NumberValue.NaN;

                genPushUpdateValue(parse, this.nodeId, 'text',  ColorValue.NaN);
            }
            

            genPushUpdateValue(parse, this.nodeId, 'back',  this.result);
            genPushUpdateValue(parse, this.nodeId, 'value', this.value);


            this.result.valid = true;
            this.valid        = true;
        }


        return this.result;
    }
}



class GColorBlind
extends GOperator
{
    input = null;

    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    copy()
    {
        const cb = new GColorBlind(this.nodeId, this.options);

        if (this.input) cb.input = this.input.copy();

        cb.l = this.l.copy();
        cb.m = this.m.copy();
        cb.s = this.s.copy();

        return cb;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const l = this.l.eval(parse).copy();
            const m = this.m.eval(parse).copy();
            const s = this.s.eval(parse).copy();


            if (this.input)
            {
                const input = this.input.eval(parse).copy();

                const rgb = input.toRgb();

                //const validRgb = invalid2validRgb(rgb);

                const rgbCb = rgb2colorblind(
                    rgb,
                    this.l.value / 2,
                    this.m.value / 2,
                    this.s.value / 2);

                if (   rgbIsOk(rgb)
                    && rgbIsOk(rgbCb))
                {
                    const validRgbCb = rgbCb;//invalid2validRgb(cb);
                
                    const validCol = convertDataColorToSpace(
                        rgb2dataColor(validRgbCb), 
                        colorSpace(input.space.value));
    
                    const factor = getColorSpaceFactor(validCol[0]);
    
                    this.result = ColorValue.create(
                        input.space.value,
                        validCol[1] * factor[0],
                        validCol[2] * factor[1],
                        validCol[3] * factor[2]);
                }
                else
                    this.result = ColorValue.NaN;
            }
            else
                this.result = ColorValue.NaN;


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);

            genPushUpdateValue(parse, this.nodeId, 'l', l);
            genPushUpdateValue(parse, this.nodeId, 'm', m);
            genPushUpdateValue(parse, this.nodeId, 's', s);
        }


        return this.result;
    }
}



class GColorValidate
extends GOperator
{
    input = null;

    order;
    
    margin1;
    margin2;
    margin3;


    constructor(nodeId, options)
    {
        super(COLOR_VALIDATE, nodeId, options);
    }


    
    copy()
    {
        const val = new GColorBlind(this.nodeId, this.options);

        if (this.input) val.input = this.input.copy();

        val.order   = this.order  .copy();
        val.margin1 = this.margin1.copy();
        val.margin2 = this.margin2.copy();
        val.margin3 = this.margin3.copy();

        return val;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const order   = this.order  .eval(parse).copy();
            const margin1 = this.margin1.eval(parse).copy();
            const margin2 = this.margin2.eval(parse).copy();
            const margin3 = this.margin3.eval(parse).copy();

            
            if (this.input)
            {
                const input = this.input.eval(parse).copy();

                const rgb = input.toRgb();


                if (rgbIsOk(rgb))
                {
                    // this._color = 
                    //     col
                    //     ? [...validateColor(
                    //         col.toDataColor(),
                    //         this.order  .value, 
                    //         this.margin1.value,
                    //         this.margin2.value,
                    //         this.margin3.value)]
                    //     : dataColor_NaN;


                    const factor = getColorSpaceFactor('rgb');
    
                    this.result = ColorValue.create(
                        1,
                        rgb[0] * factor[0],
                        rgb[1] * factor[1],
                        rgb[2] * factor[2]);
                }
                else
                    this.result = ColorValue.NaN;
            }
            else
                this.result = ColorValue.NaN;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'order',   order  );
            genPushUpdateValue(parse, this.nodeId, 'margin1', margin1);
            genPushUpdateValue(parse, this.nodeId, 'margin2', margin2);
            genPushUpdateValue(parse, this.nodeId, 'margin3', margin3);
        }


        return this.result;
    }
}



class GColorStop
extends GOperator
{
    input    = null;

    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }


    
    copy()
    {
        const stop = new GColorStop(this.nodeId, this.options);

        if (this.input) 
            stop.input = this.input.copy();

        if (this.fill    ) stop.fill     = this.fill    .copy();
        if (this.position) stop.position = this.position.copy();

        return stop;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new ColorStopValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == COLOR_STOP_VALUE, 
                    'this.result.type must be COLOR_STOP_VALUE');

                if (this.result.isValid())
                {
                    if (this.fill    ) this.result.fill     = this.fill    .eval(parse).copy();
                    if (this.position) this.result.position = this.position.eval(parse).copy();
                }
            }
            else
            {
                this.result.fill     = this.fill    .eval(parse).copy();
                this.result.position = this.position.eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this.result;
    }
}


class GShapeBase
extends GOperator
{
    // fill    = null;
    // stroke  = null;
    

    objects = [];



    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyFromBase(base)
    {
        // if (base.fill  ) this.fill   = base.fill  .copy();
        // if (base.stroke) this.stroke = base.stroke.copy();

        this.objects = [...base.objects];
    }



    // addUpdateObject(parse, nodeId, objects)
    // {
    //     if (this.options.active) 
    //         genPushUpdateObject(parse, nodeId, objects);
    //     else 
    //         this.objects.push(...objects);
    // }



    evalBase(parse, input)
    {
    //     if (!this.valid)
    //     {
    //         const fill   = evalFillValue  (this.fill,   parse);
    //         const stroke = evalStrokeValue(this.stroke, parse);
            
    //         if (input)
    //         {
    //             if (this.fill  ) this.result.fill   = fill;
    //             if (this.stroke) this.result.stroke = stroke;
    //         }
    //         else
    //         {
    //             this.result.fill   = fill;
    //             this.result.stroke = stroke;
    //         }


    //         genPushUpdateValue(parse, this.nodeId, 'fill',   this.result.fill  );
    //         genPushUpdateValue(parse, this.nodeId, 'stroke', this.result.stroke);
    //     }
    }



    evalObjects()
    {
        for (const obj of this.objects)
            obj.nodeId = this.nodeId;
    }
}


class GRectangle
extends GShapeBase
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    copy()
    {
        const rect = new GRectangle(this.nodeId, this.options);

        if (this.input) 
            rect.input = this.input.copy();

        if (this.x     ) rect.x      = this.x     .copy();
        if (this.y     ) rect.y      = this.y     .copy();
        if (this.width ) rect.width  = this.width .copy();
        if (this.height) rect.height = this.height.copy();
        if (this.angle ) rect.angle  = this.angle .copy();
        if (this.round ) rect.round  = this.round .copy();

        rect.copyFromBase(this);

        return rect;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid();
    }



    eval(parse)
    {
        if (this.valid)
            return;


        if (this.x     ) this.x     .eval(parse);
        if (this.y     ) this.y     .eval(parse);
        if (this.width ) this.width .eval(parse);
        if (this.height) this.height.eval(parse);
        if (this.angle ) this.angle .eval(parse);
        if (this.round ) this.round .eval(parse);


        if (this.input)
            this.input.eval(parse);


        const x      = this.x      ? this.x      : this.input ? this.input.x      : null;
        const y      = this.y      ? this.y      : this.input ? this.input.y      : null;
        const width  = this.width  ? this.width  : this.input ? this.input.width  : null;
        const height = this.height ? this.height : this.input ? this.input.height : null;
        const angle  = this.angle  ? this.angle  : this.input ? this.input.angle  : null;
        const round  = this.round  ? this.round  : this.input ? this.input.round  : null;


        if (x     ) genPushUpdateValue(parse, this.nodeId, 'x',      x     );
        if (y     ) genPushUpdateValue(parse, this.nodeId, 'y',      y     );
        if (width ) genPushUpdateValue(parse, this.nodeId, 'width',  width );
        if (height) genPushUpdateValue(parse, this.nodeId, 'height', height);
        if (angle ) genPushUpdateValue(parse, this.nodeId, 'angle',  angle );
        if (round ) genPushUpdateValue(parse, this.nodeId, 'round',  round );


        if (    this.input
            && !this.options) this.objects = this.input.objects;
        else                  this.evalObjects();


        this.valid = true;
    }



    evalObjects()
    {
        this.objects = 
        [{
            type:   RECTANGLE,
            id:     0,
            x:                  (this.input ? this.input.x      : this.x     ).value,
            y:                  (this.input ? this.input.y      : this.y     ).value,
            width:              (this.input ? this.input.width  : this.width ).value,
            height:             (this.input ? this.input.height : this.height).value,
            angle:              (this.input ? this.input.angle  : this.angle ).value,
            round:  Math.max(0, (this.input ? this.input.round  : this.round ).value)
        }];

        
        super.evalObjects();
    }
}


class GLine
extends GOperator
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const line = new GLine(this.nodeId, this.options);

        if (this.input) 
            line.input = this.input.copy();

        if (this.x     ) line.x      = this.x     .copy();
        if (this.y     ) line.y      = this.y     .copy();
        if (this.width ) line.width  = this.width .copy();
        if (this.angle ) line.angle  = this.angle .copy();

        line.copyBase(this);

        return line;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x     .isValid()
                  && this.y     .isValid()
                  && this.width .isValid()
                  && this.angle .isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new LineValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == LINE_VALUE, 
                    'this.result.type must be LINE_VALUE');

                if (this.x     ) this.result.x      = this.x     .eval(parse).copy();
                if (this.y     ) this.result.y      = this.y     .eval(parse).copy();
                if (this.width ) this.result.width  = this.width .eval(parse).copy();
                if (this.angle ) this.result.angle  = this.angle .eval(parse).copy();
            }
            else
            {
                this.result.x      = this.x     .eval(parse).copy();
                this.result.y      = this.y     .eval(parse).copy();
                this.result.width  = this.width .eval(parse).copy();
                this.result.angle  = this.angle .eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, LINE_VALUE, this.result);


            if (this.options)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId: this.nodeId,          
                        type:   LINE,
                        id:     0,
                        x:      this.result.x     .value,
                        y:      this.result.y     .value,
                        width:  this.result.width .value,
                        angle:  this.result.angle .value
                    });
            }
        }


        return this.result;
    }
}


class GEllipse
extends GOperator
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    copy()
    {
        const elps = new GEllipse(this.nodeId, this.options);

        if (this.input) 
            elps.input = this.input.copy();

        if (this.x     ) elps.x      = this.x     .copy();
        if (this.y     ) elps.y      = this.y     .copy();
        if (this.width ) elps.width  = this.width .copy();
        if (this.height) elps.height = this.height.copy();
        if (this.angle ) elps.angle  = this.angle .copy();

        elps.copyBase(this);
        
        return elps;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x     .isValid()
                  && this.y     .isValid()
                  && this.width .isValid()
                  && this.height.isValid()
                  && this.angle .isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new EllipseValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == ELLIPSE_VALUE, 
                    'this.result.type must be ELLIPSE_VALUE');

                if (this.x     ) this.result.x      = this.x     .eval(parse).copy();
                if (this.y     ) this.result.y      = this.y     .eval(parse).copy();
                if (this.width ) this.result.width  = this.width .eval(parse).copy();
                if (this.height) this.result.height = this.height.eval(parse).copy();
                if (this.angle ) this.result.angle  = this.angle .eval(parse).copy();
            }
            else
            {
                this.result.x      = this.x     .eval(parse).copy();
                this.result.y      = this.y     .eval(parse).copy();
                this.result.width  = this.width .eval(parse).copy();
                this.result.height = this.height.eval(parse).copy();
                this.result.angle  = this.angle .eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, ELLIPSE_VALUE, this.result);


            if (this.options)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId: this.nodeId,          
                        type:   ELLIPSE,
                        id:     0,
                        x:      this.result.x     .value,
                        y:      this.result.y     .value,
                        width:  this.result.width .value,
                        height: this.result.height.value,
                        angle:  this.result.angle .value
                    });
            }
        }


        return this.result;
    }
}


class GPolygon
extends GOperator
{
    input   = null;

    x       = null;
    y       = null;
    width   = null;
    height  = null;
    angle   = null;
    round   = null;
    corners = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    copy()
    {
        const poly = new GPolygon(this.nodeId, this.options);

        if (this.input) 
            poly.input = this.input.copy();

        if (this.x      ) poly.x       = this.x      .copy();
        if (this.y      ) poly.y       = this.y      .copy();
        if (this.width  ) poly.width   = this.width  .copy();
        if (this.height ) poly.height  = this.height .copy();
        if (this.angle  ) poly.angle   = this.angle  .copy();
        if (this.round  ) poly.round   = this.round  .copy();
        if (this.corners) poly.corners = this.corners.copy();

        poly.copyBase(this);

        return poly;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x      .isValid()
                  && this.y      .isValid()
                  && this.width  .isValid()
                  && this.height .isValid()
                  && this.angle  .isValid()
                  && this.round  .isValid()
                  && this.corners.isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new PolygonValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();
                
                console.assert(
                    this.result.type == POLYGON_VALUE, 
                    'this.result.type must be POLYGON_VALUE');

                if (this.x      ) this.result.x       = this.x      .eval(parse).copy();
                if (this.y      ) this.result.y       = this.y      .eval(parse).copy();
                if (this.width  ) this.result.width   = this.width  .eval(parse).copy();
                if (this.height ) this.result.height  = this.height .eval(parse).copy();
                if (this.angle  ) this.result.angle   = this.angle  .eval(parse).copy();
                if (this.round  ) this.result.round   = this.round  .eval(parse).copy();
                if (this.corners) this.result.corners = this.corners.eval(parse).copy();
            }
            else
            {
                this.result.x       = this.x      .eval(parse).copy();
                this.result.y       = this.y      .eval(parse).copy();
                this.result.width   = this.width  .eval(parse).copy();
                this.result.height  = this.height .eval(parse).copy();
                this.result.angle   = this.angle  .eval(parse).copy();
                this.result.round   = this.round  .eval(parse).copy();
                this.result.corners = this.corners.eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, POLYGON_VALUE, this.result);


            if (this.options)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId:  this.nodeId,          
                        type:    POLYGON,
                        id:      0,
                        x:       this.result.x     .value,
                        y:       this.result.y     .value,
                        width:   this.result.width .value,
                        height:  this.result.height.value,
                        angle:   this.result.angle .value,
                        round:   Math.max(0, this.result.round.value),
                        corners: this.result.corners.value
                    });
            }
        }


        return this.result;
    }
}


class GStar
extends GOperator
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;
    points = null;
    convex = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    copy()
    {
        const star = new GStar(this.nodeId, this.options);

        if (this.input) 
            star.input = this.input.copy();

        if (this.x     ) star.x      = this.x     .copy();
        if (this.y     ) star.y      = this.y     .copy();
        if (this.width ) star.width  = this.width .copy();
        if (this.height) star.height = this.height.copy();
        if (this.angle ) star.angle  = this.angle .copy();
        if (this.round ) star.round  = this.round .copy();
        if (this.points) star.points = this.points.copy();
        if (this.convex) star.convex = this.convex.copy();

        star.copyBase(this);

        return star;
    }



    isValid()
    {
        return this.input
               ? this.input.isValid()
               : (   this.x     .isValid()
                  && this.y     .isValid()
                  && this.width .isValid()
                  && this.height.isValid()
                  && this.angle .isValid()
                  && this.round .isValid()
                  && this.points.isValid()
                  && this.convex.isValid());
    }

    

    eval(parse)
    {
        if (!this.valid)
        {
            this.result = new StarValue();


            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == STAR_VALUE, 
                    'this.result.type must be STAR_VALUE');

                if (this.x     ) this.result.x      = this.x     .eval(parse).copy();
                if (this.y     ) this.result.y      = this.y     .eval(parse).copy();
                if (this.width ) this.result.width  = this.width .eval(parse).copy();
                if (this.height) this.result.height = this.height.eval(parse).copy();
                if (this.angle ) this.result.angle  = this.angle .eval(parse).copy();
                if (this.round ) this.result.round  = this.round .eval(parse).copy();
                if (this.points) this.result.points = this.points.eval(parse).copy();
                if (this.convex) this.result.convex = this.convex.eval(parse).copy();
            }
            else
            {
                this.result.x      = this.x     .eval(parse).copy();
                this.result.y      = this.y     .eval(parse).copy();
                this.result.width  = this.width .eval(parse).copy();
                this.result.height = this.height.eval(parse).copy();
                this.result.angle  = this.angle .eval(parse).copy();
                this.result.round  = this.round .eval(parse).copy();
                this.result.points = this.points.eval(parse).copy();
                this.result.convex = this.convex.eval(parse).copy();
            }


            this.result.valid = true;
            this.valid        = true;
           
            
            genPushUpdateValue(parse, this.nodeId, STAR_VALUE, this.result);


            if (this.options.active)
            {
                genPushUpdateObject(
                    parse,
                    this.nodeId,
                    { 
                        nodeId: this.nodeId,          
                        type:   STAR,
                        id:     0,
                        x:      this.result.x     .value,
                        y:      this.result.y     .value,
                        width:  this.result.width .value,
                        height: this.result.height.value,
                        angle:  this.result.angle .value,
                        round:  Math.max(0, this.result.round.value),
                        points: this.result.points.value,
                        convex: this.result.convex.value
                    });
            }
        }


        return this.result;
    }
}


class GFill
extends GShapeBase
{
    input   = null;

    color   = null;
    opacity = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    copy()
    {
        const fill = new GFill(this.nodeId, this.options);

        if (this.input) 
            fill.input = this.input.copy();

        if (this.color  ) fill.color   = this.color  .copy();
        if (this.opacity) fill.opacity = this.opacity.copy();

        rect.copyFromBase(this);

        return fill;
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    eval(parse)
    {
        if (this.valid)
            return;


        if (this.color  ) this.color  .eval(parse);
        if (this.opacity) this.opacity.eval(parse);

        
        if (this.input)
        {
            this.input.eval(parse);
            this.objects = this.input.objects;
        }


        const color   = this.color   ? this.color   : this.input ? this.input.color   : null;
        const opacity = this.opacity ? this.opacity : this.input ? this.input.opacity : null;

        if (color  ) genPushUpdateValue(parse, this.nodeId, 'color',   color.type == COLOR ? color.toColorValue() : color);
        if (opacity) genPushUpdateValue(parse, this.nodeId, 'opacity', opacity);


        if (   this.options.active
            || this.options.beforeActive)
            this.evalObjects();


        this.valid = true;
    }



    evalObjects()
    {
        const color   = this.color   ? this.color   : this.input ? this.input.color   : null;
        const opacity = this.opacity ? this.opacity : this.input ? this.input.opacity : null;

        if (   !color
            || !opacity)
            return;


        const rgb = scaleRgb((color.type == COLOR ? color.toColorValue() : color).toRgb());


        for (const obj of this.objects)
        {
            if (!obj.fills) 
                obj.fills = [];

            obj.fills.push([
                'SOLID', 
                        rgb[0]
                + ' ' + rgb[1]
                + ' ' + rgb[2]
                + ' ' + this.opacity.toNumber()]);
        }

        
        super.evalObjects();
    }
}


class GStroke
extends GOperator
{
    fill   = null;
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;



    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }



    copy()
    {
        const stroke = new GStroke(this.nodeId, this.options);

        if (this.input) 
            stroke.input = this.input.copy();

        if (this.fill  ) stroke.fill   = this.fill  .copy();
        if (this.weight) stroke.weight = this.weight.copy();
        if (this.fit   ) stroke.fit    = this.fit   .copy();
        if (this.join  ) stroke.join   = this.join  .copy();
        if (this.miter ) stroke.miter  = this.miter .copy();

        return stroke;
    }



    eval(parse)
    {
        if (!this.valid)
        {
            const fill   = this.fill   ? evalFillValue(this.fill, parse) : null;
            const weight = this.weight ? this.weight.eval(parse).copy()  : null;
            const fit    = this.fit    ? this.fit   .eval(parse).copy()  : null;
            const join   = this.join   ? this.join  .eval(parse).copy()  : null;
            const miter  = this.miter  ? this.miter .eval(parse).copy()  : null;            

            if (this.input)
            {
                this.result = this.input.eval(parse).copy();

                console.assert(
                    this.result.type == STROKE_VALUE,
                    'GStroke this.result.type must be STROKE_VALUE');

                if (this.fill  ) this.result.fill   = fill;
                if (this.weight) this.result.weight = weight;
                if (this.fit   ) this.result.fit    = fit;
                if (this.join  ) this.result.join   = join;
                if (this.miter ) this.result.miter  = miter;
            }
            else
            {
                this.result = new StrokeValue(fill, weight, fit, join, miter);
            }
        

            genPushUpdateValue(parse, this.nodeId, 'fill',   this.result.fill  );
            genPushUpdateValue(parse, this.nodeId, 'weight', this.result.weight);
            genPushUpdateValue(parse, this.nodeId, 'fit',    this.result.fit   );
            genPushUpdateValue(parse, this.nodeId, 'join',   this.result.join  );
            genPushUpdateValue(parse, this.nodeId, 'miter',  this.result.miter );


            this.result.valid = true;
            this.valid        = true;
        }


        return this.result;
    }
}


const settings =
{
    enableLxxColorSpaces: false,

    showNodeId:           false, // instead of name
    showWires:            true,
    
    logMessages:          false,
    logActions:           false, 
    
    logLoading:           false, 
    logRequests:          false, 
    logValueUpdates:      false, 
    logObjectUpdates:     false,
    
    logRawLoading:        false, 
    logRawSaving:         false, 
    logRawRequests:       false, 
    logRawValues:         false    
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'enableLxxColorSpaces': settings.enableLxxColorSpaces = value;  break;

        case 'showNodeId':           settings.showNodeId           = value;  break;
        case 'showWires':            settings.showWires            = value;  break;

        case 'logMessages':          settings.logMessages          = value;  break;
        case 'logActions':           settings.logActions           = value;  break;
        case 'logLoading':           settings.logLoading           = value;  break;
        case 'logRequests':          settings.logRequests          = value;  break;
        case 'logValueUpdates':      settings.logValueUpdates      = value;  break;
        case 'logObjectUpdates':     settings.logObjectUpdates     = value;  break;

        case 'logRawLoading':        settings.logRawLoading        = value;  break;
        case 'logRawSaving':         settings.logRawSaving         = value;  break;
        case 'logRawRequests':       settings.logRawRequests       = value;  break;
        case 'logRawValues':         settings.logRawValues         = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'enableLxxColorSpaces': updateSettingAndMenu_(valid, settingName, value, menuItemEnableLxxColorSpaces);  break;

        case 'showNodeId':           updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId          );  break;
        case 'showWires':            updateSettingAndMenu_(valid, settingName, value, menuItemShowWires           );  break;

        case 'logMessages':          updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages         );  break;
        case 'logActions':           updateSettingAndMenu_(valid, settingName, value, menuItemLogActions          );  break;
        case 'logLoading':           updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading          );  break;
        case 'logRequests':          updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests         );  break;
        case 'logValueUpdates':      updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates     );  break;
        case 'logObjectUpdates':     updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates    );  break;

        case 'logRawLoading':        updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoading       );  break;
        case 'logRawSaving':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaving        );  break;
        case 'logRawRequests':       updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests      );  break;
        case 'logRawValues':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues        );  break;
    } 

    if (save)
        uiSetLocalData(settingName, boolString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  

    menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemEnableLxxColorSpaces.setChecked(settings.enableLxxColorSpaces);

    menuItemShowNodeId          .setChecked(settings.showNodeId          );
    menuItemShowWires           .setChecked(settings.showWires           );

    menuItemLogMessages         .setChecked(settings.logMessages         );
    menuItemLogActions          .setChecked(settings.logActions          );

    menuItemLogLoading          .setChecked(settings.logLoading          );
    menuItemLogRequests         .setChecked(settings.logRequests         );
    menuItemLogValueUpdates     .setChecked(settings.logValueUpdates     );
    menuItemLogObjectUpdates    .setChecked(settings.logObjectUpdates    );

    menuItemLogRawLoading       .setChecked(settings.logRawLoading       );
    menuItemLogRawSaving        .setChecked(settings.logRawSaving        );
    menuItemLogRawRequests      .setChecked(settings.logRawRequests      );
    menuItemLogRawValues        .setChecked(settings.logRawValues        );
}



function updateEnableLxxColorSpace()
{
    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}


var currentMenus      = [];
var currentMenuButton = null;



class Menu
{
    parentMenu = null;
    
    name;
    button   = null;

    div;
    divArrow;

    showIcons;

    overMenu   = false;
    
    items      = [];
    lastItem   = null;



    constructor(name, showIcons = true)
    {
        this.name       = name;

        this.showIcons  = showIcons;

        this.div        = createDiv('menu');
        this.divArrow   = createDiv('menuArrow');

        this.div.addEventListener('pointerenter', e => this.overMenu = true );
        this.div.addEventListener('pointerleave', e => this.overMenu = false);
    }



    addItems(items)
    {
        this.items = [...items];


        for (let i = 0; i < this.items.length; i++)
        {
            if (i > 0) 
                this.div.appendChild(document.createElement('br'));

            if (!this.showIcons)
                this.items[i].divIcon.style.display = 'none';

            this.items[i].parentMenu = this;
            this.items[i].index      = i;

            this.div.appendChild(this.items[i].div);
        }


        if (  !this.lastItem
            && this.items.length > 0)
            this.lastItem = this.items[0];


        if (this.button)
            this.button.update();
    }



    show(srcDiv, right = false)
    {
        //hideAllMenusAfter(this.parentMenu);

            
        this.div.style.display = 'block';
        this.div.style.opacity = '100%';
    

        if (!right)
        {
            this.divArrow.style.display = 'block';
            this.divArrow.style.opacity = '100%';
        }


        document.body.appendChild(this.div);
        document.body.appendChild(this.divArrow);

    
        let srcRect = srcDiv.getBoundingClientRect();
    
        srcRect.y -= 5;
    
    
        const margin = 8;
     
        this.div.style.left = Math.min(Math.max(
            margin, 
            right
            ? srcRect.x + srcRect.width 
            : srcRect.x + srcRect.width/2 - this.div.offsetWidth/2),
            graphView.offsetWidth - this.div.offsetWidth - margin);
    
        this.div.style.top = 
            right
            ? srcRect.y - 3
            : srcRect.y + srcRect.height + this.divArrow.offsetHeight;

        
        this.divArrow.style.left = srcRect.x + srcRect.width/2;
        
    
        const menuRect = this.div.getBoundingClientRect();
    
        this.divArrow.style.top = menuRect.y - this.divArrow.offsetHeight;
    
    
        currentMenus.push(this);


        if (this.button)
            this.button.update();
    }
    
    
    
    hide()
    {
        this.div     .style.display = 'none';
        this.div     .style.opacity = '0%';
    
        this.divArrow.style.display = 'none';
        this.divArrow.style.opacity = '0%';


        if (    this.button
            && !this.button.overArrow)
        {
            this.button.divArrow.style.transform  = 'translateY(0)';
            this.button.div     .style.background = 'transparent';
        }


        removeFrom(currentMenus, this);
    }
}



function hideAllMenus()
{
    for (let i = currentMenus.length-1; i >= 0; i--)
        currentMenus[i].hide();
}



function hideAllMenusAfter(menu)
{
    const index = currentMenus.indexOf(menu);

    for (let i = currentMenus.length-1; i > index; i--)
        currentMenus[i].hide();
}



function disableCurrentMenuButton()
{
    if (currentMenuButton)
    {
        const curMenuButton = currentMenuButton;
        currentMenuButton = null;
        curMenuButton.update();
    }
}


const iconGenerator        = '<svg width="19" height="10" viewBox="0 0 19 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.7074 3.74745C11.6364 3.51733 11.5384 3.31137 11.4134 3.12955C11.2912 2.94489 11.1435 2.78722 10.9702 2.65654C10.7997 2.52586 10.6037 2.42784 10.3821 2.3625C10.1605 2.29432 9.91903 2.26023 9.65767 2.26023C9.18892 2.26023 8.77131 2.37813 8.40483 2.61392C8.03835 2.84972 7.75 3.19631 7.53977 3.6537C7.33239 4.10824 7.22869 4.66222 7.22869 5.31563C7.22869 5.97472 7.33239 6.53296 7.53977 6.99034C7.74716 7.44773 8.03551 7.79574 8.40483 8.03438C8.77415 8.27017 9.20313 8.38807 9.69176 8.38807C10.1349 8.38807 10.5185 8.30284 10.8423 8.13239C11.169 7.96194 11.4205 7.72046 11.5966 7.40796C11.7727 7.09262 11.8608 6.7233 11.8608 6.3L12.2188 6.3554H9.84943V5.11961H13.3906V6.1679C13.3906 6.91506 13.2315 7.56137 12.9134 8.10682C12.5952 8.65228 12.1577 9.07273 11.6009 9.36819C11.044 9.6608 10.4048 9.80711 9.68324 9.80711C8.87926 9.80711 8.1733 9.62671 7.56534 9.26591C6.96023 8.90228 6.48722 8.38665 6.14631 7.71904C5.80824 7.04858 5.6392 6.25313 5.6392 5.33267C5.6392 4.62813 5.73864 3.99887 5.9375 3.44489C6.1392 2.89091 6.42045 2.42074 6.78125 2.03438C7.14205 1.64517 7.56534 1.34972 8.05114 1.14802C8.53693 0.94347 9.06534 0.841197 9.63636 0.841197C10.1193 0.841197 10.5696 0.91222 10.9872 1.05427C11.4048 1.19347 11.7756 1.39233 12.0994 1.65086C12.4261 1.90938 12.6946 2.2162 12.9048 2.57131C13.1151 2.92642 13.2528 3.31847 13.3182 3.74745H11.7074Z" fill="white"/><circle cx="2" cy="5" r="1.5" stroke="white"/><circle cx="17" cy="5" r="2" fill="white"/></svg>';

const iconNumber           = '<svg width="18" height="7" viewBox="0 0 18 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.91122 0.0931559V6.90684H1.96124V0.958175H1.91528L0 2.06274V1.22433L1.96124 0.0931559H2.91122Z" fill="white"/><path d="M5.16742 6.90684V6.30798L7.75687 3.84601C8.06076 3.55767 8.31102 3.30703 8.50766 3.09411C8.7043 2.87896 8.84986 2.67712 8.94434 2.48859C9.04138 2.29785 9.0899 2.09823 9.0899 1.88973C9.0899 1.65019 9.02351 1.44281 8.89072 1.26759C8.76048 1.09236 8.58172 0.957066 8.35444 0.861692C8.12716 0.766318 7.87179 0.718631 7.58833 0.718631C7.28699 0.718631 7.02396 0.772972 6.79923 0.881654C6.57706 0.988118 6.40469 1.13783 6.28211 1.3308C6.16208 1.52376 6.10207 1.75 6.10207 2.00951H5.19806C5.19806 1.61027 5.30404 1.25982 5.516 0.958175C5.72796 0.656527 6.01652 0.421419 6.3817 0.252852C6.74944 0.0842839 7.16186 0 7.61897 0C8.07864 0 8.48595 0.0842839 8.84092 0.252852C9.19588 0.421419 9.47424 0.648764 9.67598 0.934886C9.87772 1.22101 9.97859 1.53929 9.97859 1.88973C9.97859 2.14037 9.92624 2.38546 9.82154 2.625C9.71939 2.86233 9.54063 3.12738 9.28526 3.42015C9.03245 3.71071 8.68131 4.06559 8.23186 4.48479L6.46981 6.12167V6.1749H10.1165V6.90684H5.16742Z" fill="white"/><path d="M14.5755 6.95327C14.0766 6.95327 13.6319 6.87886 13.2413 6.73005C12.8533 6.58124 12.5447 6.37444 12.3154 6.10965C12.0886 5.84266 11.9652 5.53301 11.945 5.18068H12.8974C12.9176 5.39733 13.0032 5.58443 13.1544 5.742C13.3056 5.89737 13.5034 6.01773 13.7478 6.10308C13.9922 6.18843 14.263 6.2311 14.5603 6.2311C14.8929 6.2311 15.1877 6.18077 15.4447 6.0801C15.7017 5.97944 15.9033 5.83938 16.0494 5.65993C16.1956 5.48049 16.2686 5.27259 16.2686 5.03624C16.2686 4.78896 16.1981 4.57121 16.057 4.38301C15.9159 4.19262 15.7093 4.04381 15.4372 3.93658C15.1651 3.82935 14.8325 3.77574 14.4394 3.77574H13.8196V3.05357H14.4394C14.7468 3.05357 15.0164 3.00543 15.2482 2.90914C15.4825 2.81285 15.6652 2.67717 15.7962 2.5021C15.9298 2.32703 15.9965 2.12132 15.9965 1.88497C15.9965 1.65738 15.9386 1.45933 15.8227 1.29083C15.7068 1.12232 15.543 0.991021 15.3313 0.89692C15.1222 0.80282 14.8753 0.75577 14.5906 0.75577C14.3235 0.75577 14.0715 0.798443 13.8347 0.88379C13.6004 0.966949 13.4089 1.0884 13.2602 1.24816C13.1116 1.40572 13.0309 1.59611 13.0184 1.81932H12.1113C12.1264 1.46699 12.2486 1.15843 12.4779 0.893638C12.7072 0.626655 13.007 0.418759 13.3774 0.269949C13.7503 0.121139 14.1597 0.0467339 14.6057 0.0467339C15.0844 0.0467339 15.4951 0.130986 15.8378 0.299492C16.1805 0.465809 16.4438 0.685741 16.6277 0.959289C16.8116 1.23284 16.9036 1.52827 16.9036 1.84558C16.9036 2.22417 16.7889 2.54696 16.5597 2.81394C16.3329 3.08093 16.0242 3.26584 15.6337 3.3687V3.42122C16.1225 3.49125 16.5042 3.67179 16.7789 3.96284C17.0535 4.25171 17.1908 4.60951 17.1908 5.03624C17.1908 5.4017 17.0762 5.72996 16.8469 6.02102C16.6201 6.30988 16.3102 6.53748 15.9172 6.70379C15.5241 6.87011 15.0769 6.95327 14.5755 6.95327Z" fill="white"/></svg>';
const iconLimits           = '<svg width="18" height="14" viewBox="0 0 18 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 0H0.904239L3.03042 5.81055H3.10374L5.22992 0H6.13416V7H5.42543V1.68164H5.36434L3.40922 7H2.72494L0.769825 1.68164H0.708728V7H0V0Z" fill="white"/><path d="M7.9098 7H7.11553L9.41279 0H10.1948L12.4921 7H11.6978L9.82825 1.10742H9.77937L7.9098 7ZM8.20306 4.26563H11.4046V5.01758H8.20306V4.26563Z" fill="white"/><path d="M13.8332 0L15.4461 2.91211H15.495L17.108 0H18L16.0327 3.5L18 7H17.108L15.495 4.14258H15.4461L13.8332 7H12.9412L14.9574 3.5L12.9412 0H13.8332Z" fill="white"/><path d="M1 8H1.85014L3.84911 12.9805H3.91804L5.91702 8H6.76716V14H6.10083V9.44141H6.04339L4.20525 14H3.5619L1.72377 9.44141H1.66632V14H1V8Z" fill="white"/><path d="M9.90758 8V14H9.1953V8H9.90758Z" fill="white"/><path d="M17 8V14H16.3107L13.1054 9.28906H13.048V14H12.3357V8H13.025L16.2418 12.7227H16.2992V8H17Z" fill="white"/></svg>';
const iconMath             = '<svg width="17" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.138 6.57967V0.485922H13.1039V6.57967H14.138ZM16.6678 4.04984V3.01575H10.5741V4.04984H16.6678Z" fill="white"/><path d="M11.3681 15.5004L16.5755 10.293L15.8738 9.59129L10.6664 14.7987L11.3681 15.5004ZM15.8738 15.5004L16.5755 14.7987L11.3681 9.59129L10.6664 10.293L15.8738 15.5004Z" fill="white"/><path d="M0.576652 12.0288V13.0629H6.48574V12.0288H0.576652ZM3.5312 15.7589C3.76202 15.7589 3.95899 15.6789 4.12211 15.5188C4.28214 15.3557 4.36216 15.1588 4.36216 14.9279C4.36216 14.7063 4.28214 14.5155 4.12211 14.3555C3.95899 14.1955 3.76202 14.1154 3.5312 14.1154C3.30961 14.1154 3.11879 14.1955 2.95875 14.3555C2.79872 14.5155 2.7187 14.7063 2.7187 14.9279C2.7187 15.1588 2.79872 15.3557 2.95875 15.5188C3.11879 15.6789 3.30961 15.7589 3.5312 15.7589ZM3.5312 10.9762C3.68508 10.9762 3.82511 10.9393 3.9513 10.8654C4.07748 10.7916 4.1775 10.6915 4.25137 10.5654C4.32523 10.4392 4.36216 10.2991 4.36216 10.1453C4.36216 9.92367 4.28214 9.73286 4.12211 9.57282C3.95899 9.41278 3.76202 9.33276 3.5312 9.33276C3.30961 9.33276 3.11879 9.41278 2.95875 9.57282C2.79872 9.73286 2.7187 9.92367 2.7187 10.1453C2.7187 10.3761 2.79872 10.5731 2.95875 10.7362C3.11879 10.8962 3.30961 10.9762 3.5312 10.9762Z" fill="white"/><path d="M0.576652 3.01575V4.04984H6.48574V3.01575H0.576652Z" fill="white"/></svg>';
const iconAdd              = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.78932 10.1318V0.756822H6.38023V10.1318H4.78932ZM0.897271 6.23978V4.64887H10.2723V6.23978H0.897271Z" fill="white"/></svg>';
const iconSubtract         = '<svg width="10" height="3" viewBox="0 0 10 3" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.13023 0.648867V2.23978H0.0393206V0.648867H9.13023Z" fill="white"/></svg>';
const iconMultiply         = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.05068 9.98978L0.0393206 1.97841L1.11887 0.898868L9.13023 8.91023L8.05068 9.98978ZM1.11887 9.98978L0.0393206 8.91023L8.05068 0.898868L9.13023 1.97841L1.11887 9.98978Z" fill="white"/></svg>';
const iconDivide           = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.13023 4.64887V6.23978H0.0393206V4.64887H9.13023ZM4.58478 10.3875C4.22966 10.3875 3.92663 10.2644 3.67568 10.0182C3.42947 9.76724 3.30637 9.46421 3.30637 9.1091C3.30637 8.76819 3.42947 8.47463 3.67568 8.22841C3.92663 7.9822 4.22966 7.85909 4.58478 7.85909C4.92568 7.85909 5.21925 7.9822 5.46546 8.22841C5.71167 8.47463 5.83478 8.76819 5.83478 9.1091C5.83478 9.46421 5.71167 9.76724 5.46546 10.0182C5.21925 10.2644 4.92568 10.3875 4.58478 10.3875ZM4.58478 3.02955C4.34803 3.02955 4.1326 2.97273 3.93847 2.85909C3.74434 2.74546 3.59046 2.59158 3.47682 2.39745C3.36318 2.20332 3.30637 1.98788 3.30637 1.75114C3.30637 1.41023 3.42947 1.11667 3.67568 0.870458C3.92663 0.624246 4.22966 0.501141 4.58478 0.501141C4.92568 0.501141 5.21925 0.624246 5.46546 0.870458C5.71167 1.11667 5.83478 1.41023 5.83478 1.75114C5.83478 2.10625 5.71167 2.40928 5.46546 2.66023C5.21925 2.90644 4.92568 3.02955 4.58478 3.02955Z" fill="white"/></svg>';
const iconExponent         = '<svg width="15" height="15" viewBox="-1 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.58665 4.77273L3.67756 8.34091L5.76847 4.77273H7.31392L4.49574 9.13636L7.31392 13.5H5.76847L3.67756 10.1136L1.58665 13.5H0.0411932L2.81392 9.13636L0.0411932 4.77273H1.58665Z" fill="white"/><path d="M9.30682 8.04545C9.16477 8.04545 9.03812 8.03362 8.92685 8.00994C8.81558 7.98864 8.73864 7.96733 8.69602 7.94602L8.90909 7.20739C9.11269 7.25947 9.29261 7.27841 9.44886 7.2642C9.60511 7.25 9.74361 7.18016 9.86435 7.05469C9.98745 6.93158 10.0999 6.73153 10.2017 6.45455L10.358 6.02841L8.34091 0.545454H9.25L10.7557 4.89205H10.8125L12.3182 0.545454H13.2273L10.9119 6.79545C10.8078 7.07718 10.6787 7.31037 10.5249 7.49503C10.371 7.68205 10.1922 7.82055 9.98864 7.91051C9.78741 8.00047 9.56013 8.04545 9.30682 8.04545Z" fill="white"/></svg>';
const iconModulo           = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.07556 8.75853V8.21776C6.07556 7.8439 6.15233 7.50175 6.30588 7.19131C6.46277 6.87753 6.68976 6.62718 6.98685 6.44024C7.28728 6.24997 7.65113 6.15484 8.0784 6.15484C8.51235 6.15484 8.8762 6.24997 9.16995 6.44024C9.4637 6.62718 9.68568 6.87753 9.83589 7.19131C9.9861 7.50175 10.0612 7.8439 10.0612 8.21776V8.75853C10.0612 9.1324 9.98444 9.47622 9.83088 9.78999C9.68067 10.1004 9.45702 10.3508 9.15993 10.5411C8.86618 10.728 8.50567 10.8215 8.0784 10.8215C7.64445 10.8215 7.27893 10.728 6.98184 10.5411C6.68475 10.3508 6.45943 10.1004 6.30588 9.78999C6.15233 9.47622 6.07556 9.1324 6.07556 8.75853ZM7.09701 8.21776V8.75853C7.09701 9.06897 7.17044 9.3477 7.31732 9.59472C7.46419 9.8384 7.71789 9.96024 8.0784 9.96024C8.4289 9.96024 8.67591 9.8384 8.81945 9.59472C8.96632 9.3477 9.03976 9.06897 9.03976 8.75853V8.21776C9.03976 7.90732 8.96966 7.63026 8.82946 7.38659C8.68926 7.13957 8.43891 7.01606 8.0784 7.01606C7.7279 7.01606 7.47588 7.13957 7.32233 7.38659C7.17211 7.63026 7.09701 7.90732 7.09701 8.21776ZM0.968313 2.89021V2.34944C0.968313 1.97558 1.04509 1.63342 1.19864 1.32298C1.35553 1.00921 1.58252 0.758851 1.87961 0.571919C2.18003 0.381649 2.54388 0.286514 2.97115 0.286514C3.4051 0.286514 3.76895 0.381649 4.0627 0.571919C4.35645 0.758851 4.57843 1.00921 4.72865 1.32298C4.87886 1.63342 4.95397 1.97558 4.95397 2.34944V2.89021C4.95397 3.26407 4.87719 3.60789 4.72364 3.92167C4.57343 4.23211 4.34978 4.48247 4.05269 4.67274C3.75894 4.85967 3.39843 4.95313 2.97115 4.95313C2.5372 4.95313 2.17169 4.85967 1.8746 4.67274C1.57751 4.48247 1.35219 4.23211 1.19864 3.92167C1.04509 3.60789 0.968313 3.26407 0.968313 2.89021ZM1.98976 2.34944V2.89021C1.98976 3.20065 2.0632 3.47938 2.21007 3.72639C2.35695 3.97007 2.61064 4.09191 2.97115 4.09191C3.32165 4.09191 3.56867 3.97007 3.7122 3.72639C3.85908 3.47938 3.93252 3.20065 3.93252 2.89021V2.34944C3.93252 2.039 3.86242 1.76194 3.72222 1.51826C3.58202 1.27124 3.33167 1.14774 2.97115 1.14774C2.62066 1.14774 2.36863 1.27124 2.21508 1.51826C2.06487 1.76194 1.98976 2.039 1.98976 2.34944ZM1.34885 10.6813L8.39885 0.426713H9.54047L2.49047 10.6813H1.34885Z" fill="white"/></svg>';
const iconInterpolate      = '<svg width="20" height="10" viewBox="0 0 20 10" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="-0.150566" y1="8.52321" x2="18.8494" y2="2.52321" stroke="white"/><ellipse cx="3.07097" cy="7.5" rx="0.732794" ry="3.23269" transform="rotate(-12.7132 3.07097 7.5)" fill="white"/><ellipse cx="11.3613" cy="4.88962" rx="0.732794" ry="3.23269" transform="rotate(-12.7132 11.3613 4.88962)" fill="white"/><ellipse cx="15.9295" cy="3.65694" rx="0.732794" ry="3.23269" transform="rotate(-12.7132 15.9295 3.65694)" fill="white"/></svg>';

const iconString           = '<svg width="20" height="7" viewBox="0 0 20 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.888729 6.90684H0L2.57048 0.0931559H3.44553L6.01601 6.90684H5.12728L3.03535 1.1711H2.98066L0.888729 6.90684ZM1.21687 4.24525H4.79914V4.97719H1.21687V4.24525Z" fill="white"/><path d="M7.10641 6.90684V0.0931559H9.55384C10.0415 0.0931559 10.4437 0.175222 10.7605 0.339354C11.0772 0.501267 11.3131 0.71974 11.468 0.994772C11.623 1.26759 11.7005 1.57034 11.7005 1.90304C11.7005 2.19582 11.6469 2.43758 11.5398 2.62833C11.435 2.81907 11.296 2.9699 11.1228 3.0808C10.9519 3.1917 10.7662 3.27376 10.5656 3.327V3.39354C10.7798 3.40684 10.9952 3.48004 11.2117 3.61312C11.4281 3.7462 11.6093 3.93695 11.7551 4.18536C11.901 4.43378 11.9739 4.73764 11.9739 5.09696C11.9739 5.43853 11.8942 5.74572 11.7346 6.01854C11.5751 6.29135 11.3233 6.5076 10.9792 6.6673C10.6351 6.827 10.1873 6.90684 9.63587 6.90684H7.10641ZM7.95412 6.1749H9.63587C10.1896 6.1749 10.5827 6.07066 10.8151 5.86217C11.0499 5.65146 11.1672 5.39639 11.1672 5.09696C11.1672 4.86629 11.1068 4.65336 10.9861 4.45818C10.8653 4.26077 10.6932 4.1033 10.4699 3.98574C10.2466 3.86597 9.98225 3.80608 9.67689 3.80608H7.95412V6.1749ZM7.95412 3.08745H9.52649C9.78172 3.08745 10.0119 3.03866 10.217 2.94106C10.4243 2.84347 10.5884 2.70596 10.7092 2.52852C10.8322 2.35108 10.8938 2.14259 10.8938 1.90304C10.8938 1.60361 10.7867 1.34965 10.5725 1.14116C10.3582 0.93045 10.0187 0.825095 9.55384 0.825095H7.95412V3.08745Z" fill="white"/><path d="M19.2496 2.22243H18.366C18.3138 1.98511 18.2224 1.77662 18.0917 1.59696C17.9635 1.4173 17.8067 1.26648 17.6215 1.14449C17.4386 1.02028 17.2355 0.927123 17.0123 0.865019C16.789 0.802915 16.5562 0.771863 16.314 0.771863C15.8722 0.771863 15.472 0.876109 15.1134 1.0846C14.7571 1.29309 14.4733 1.60029 14.2619 2.00618C14.0529 2.41207 13.9484 2.91001 13.9484 3.5C13.9484 4.08999 14.0529 4.58793 14.2619 4.99382C14.4733 5.39971 14.7571 5.70691 15.1134 5.9154C15.472 6.12389 15.8722 6.22814 16.314 6.22814C16.5562 6.22814 16.789 6.19709 17.0123 6.13498C17.2355 6.07288 17.4386 5.98083 17.6215 5.85884C17.8067 5.73463 17.9635 5.5827 18.0917 5.40304C18.2224 5.22117 18.3138 5.01267 18.366 4.77757H19.2496C19.1831 5.12579 19.0619 5.43742 18.8862 5.71245C18.7104 5.98748 18.4919 6.22148 18.2307 6.41445C17.9694 6.6052 17.6761 6.75048 17.3507 6.85029C17.0277 6.95009 16.6821 7 16.314 7C15.6917 7 15.1383 6.85805 14.6538 6.57414C14.1693 6.29024 13.7881 5.88657 13.5102 5.36312C13.2323 4.83967 13.0934 4.21863 13.0934 3.5C13.0934 2.78137 13.2323 2.16033 13.5102 1.63688C13.7881 1.11343 14.1693 0.709759 14.6538 0.425856C15.1383 0.141952 15.6917 0 16.314 0C16.6821 0 17.0277 0.049905 17.3507 0.149715C17.6761 0.249525 17.9694 0.395913 18.2307 0.588878C18.4919 0.779626 18.7104 1.01252 18.8862 1.28755C19.0619 1.56036 19.1831 1.87199 19.2496 2.22243Z" fill="white"/></svg>';
const iconStringJoin       = '<svg width="20" height="7" viewBox="0 0 20 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.962017 7H0.0941198L2.60435 0.163636H3.45889L5.96912 7H5.10122L3.05832 1.24517H3.00492L0.962017 7ZM1.28247 4.32955H4.78077V5.06392H1.28247V4.32955ZM8.92999 5.7983V1.39205H9.67771V5.7983H8.92999ZM7.10072 3.96903V3.22131H11.507V3.96903H7.10072ZM13.2303 7V0.163636H15.6203C16.0965 0.163636 16.4893 0.245976 16.7986 0.410654C17.108 0.573106 17.3383 0.792306 17.4896 1.06825C17.641 1.34197 17.7166 1.64574 17.7166 1.97955C17.7166 2.2733 17.6643 2.51586 17.5597 2.70724C17.4574 2.89863 17.3216 3.04995 17.1525 3.16122C16.9856 3.27249 16.8042 3.35483 16.6084 3.40824V3.475C16.8176 3.48835 17.0279 3.56179 17.2393 3.69531C17.4507 3.82884 17.6276 4.02022 17.77 4.26946C17.9124 4.5187 17.9837 4.82358 17.9837 5.18409C17.9837 5.5268 17.9058 5.83501 17.75 6.10874C17.5942 6.38246 17.3483 6.59943 17.0123 6.75966C16.6763 6.91989 16.239 7 15.7004 7H13.2303ZM14.0581 6.26563H15.7004C16.2412 6.26563 16.6251 6.16103 16.8521 5.95185C17.0813 5.74044 17.1959 5.48452 17.1959 5.18409C17.1959 4.95265 17.1369 4.73902 17.019 4.54318C16.901 4.34512 16.733 4.18712 16.5149 4.06918C16.2968 3.94901 16.0387 3.88892 15.7405 3.88892H14.0581V6.26563ZM14.0581 3.1679H15.5936C15.8428 3.1679 16.0676 3.11894 16.2679 3.02102C16.4704 2.92311 16.6306 2.78513 16.7486 2.6071C16.8687 2.42907 16.9288 2.21989 16.9288 1.97955C16.9288 1.67912 16.8242 1.42431 16.6151 1.21513C16.4059 1.00372 16.0743 0.898011 15.6203 0.898011H14.0581V3.1679Z" fill="white"/></svg>';
const iconSubstring        = '<svg width="20" height="16" viewBox="0 0 20 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.884233 5.99355H0.191761L2.1946 0.539H2.87642L4.87926 5.99355H4.18679L2.55682 1.40193H2.5142L0.884233 5.99355ZM1.13991 3.86286H3.93111V4.4488H1.13991V3.86286ZM19.2367 2.24355H18.5762C18.5372 2.05356 18.4688 1.88666 18.3711 1.74284C18.2753 1.59901 18.1581 1.47828 18.0196 1.38062C17.8829 1.28119 17.731 1.20661 17.5641 1.1569C17.3972 1.10718 17.2232 1.08232 17.0421 1.08232C16.7119 1.08232 16.4127 1.16578 16.1446 1.33268C15.8782 1.49958 15.6661 1.7455 15.508 2.07043C15.3518 2.39536 15.2737 2.79397 15.2737 3.26627C15.2737 3.73857 15.3518 4.13719 15.508 4.46212C15.6661 4.78705 15.8782 5.03296 16.1446 5.19987C16.4127 5.36677 16.7119 5.45022 17.0421 5.45022C17.2232 5.45022 17.3972 5.42536 17.5641 5.37565C17.731 5.32593 17.8829 5.25225 18.0196 5.15459C18.1581 5.05516 18.2753 4.93353 18.3711 4.78971C18.4688 4.64411 18.5372 4.47721 18.5762 4.289H19.2367C19.187 4.56776 19.0965 4.81723 18.9651 5.0374C18.8337 5.25757 18.6703 5.44489 18.475 5.59937C18.2797 5.75207 18.0604 5.86837 17.8172 5.94827C17.5757 6.02817 17.3173 6.06812 17.0421 6.06812C16.5769 6.06812 16.1632 5.95448 15.801 5.72721C15.4388 5.49994 15.1538 5.17678 14.9461 4.75775C14.7383 4.33872 14.6345 3.84156 14.6345 3.26627C14.6345 2.69099 14.7383 2.19383 14.9461 1.7748C15.1538 1.35576 15.4388 1.03261 15.801 0.805335C16.1632 0.578062 16.5769 0.464426 17.0421 0.464426C17.3173 0.464426 17.5757 0.504376 17.8172 0.584277C18.0604 0.664178 18.2797 0.781365 18.475 0.935839C18.6703 1.08854 18.8337 1.27497 18.9651 1.49514C19.0965 1.71354 19.187 1.96301 19.2367 2.24355Z" fill="white"/><path d="M4.21673 10.3V9.69915C4.21673 9.51667 4.249 9.32306 4.31353 9.11832C4.3803 8.91136 4.47599 8.71219 4.60061 8.52081C4.72745 8.3272 4.87989 8.15919 5.05792 8.01676L5.4852 8.36392C5.345 8.5642 5.2226 8.77339 5.11801 8.99148C5.01564 9.20734 4.96446 9.43878 4.96446 9.6858V10.3H4.21673ZM5.92582 10.3V9.69915C5.92582 9.51667 5.95809 9.32306 6.02262 9.11832C6.08939 8.91136 6.18508 8.71219 6.3097 8.52081C6.43655 8.3272 6.58898 8.15919 6.76701 8.01676L7.19429 8.36392C7.05409 8.5642 6.93169 8.77339 6.8271 8.99148C6.72473 9.20734 6.67355 9.43878 6.67355 9.6858V10.3H5.92582ZM8.17067 15V8.16364H10.5607C11.037 8.16364 11.4297 8.24598 11.7391 8.41065C12.0484 8.57311 12.2787 8.79231 12.43 9.06825C12.5814 9.34197 12.657 9.64574 12.657 9.97955C12.657 10.2733 12.6047 10.5159 12.5001 10.7072C12.3978 10.8986 12.262 11.05 12.0929 11.1612C11.926 11.2725 11.7446 11.3548 11.5488 11.4082V11.475C11.758 11.4884 11.9683 11.5618 12.1797 11.6953C12.3911 11.8288 12.568 12.0202 12.7104 12.2695C12.8529 12.5187 12.9241 12.8236 12.9241 13.1841C12.9241 13.5268 12.8462 13.835 12.6904 14.1087C12.5346 14.3825 12.2887 14.5994 11.9527 14.7597C11.6167 14.9199 11.1794 15 10.6408 15H8.17067ZM8.99851 14.2656H10.6408C11.1816 14.2656 11.5655 14.161 11.7925 13.9518C12.0217 13.7404 12.1363 13.4845 12.1363 13.1841C12.1363 12.9527 12.0773 12.739 11.9594 12.5432C11.8414 12.3451 11.6734 12.1871 11.4553 12.0692C11.2372 11.949 10.9791 11.8889 10.6809 11.8889H8.99851V14.2656ZM8.99851 11.1679H10.534C10.7833 11.1679 11.008 11.1189 11.2083 11.021C11.4108 10.9231 11.5711 10.7851 11.689 10.6071C11.8092 10.4291 11.8693 10.2199 11.8693 9.97955C11.8693 9.67912 11.7647 9.42431 11.5555 9.21513C11.3463 9.00372 11.0147 8.89801 10.5607 8.89801H8.99851V11.1679ZM14.8718 8.16364V8.76449C14.8718 8.94697 14.8385 9.14169 14.7717 9.34865C14.7072 9.55339 14.6115 9.75256 14.4846 9.94616C14.36 10.1375 14.2087 10.3045 14.0306 10.4469L13.6034 10.0997C13.7436 9.89943 13.8649 9.69136 13.9672 9.4755C14.0718 9.25741 14.1241 9.02486 14.1241 8.77784V8.16364H14.8718ZM16.5809 8.16364V8.76449C16.5809 8.94697 16.5476 9.14169 16.4808 9.34865C16.4163 9.55339 16.3206 9.75256 16.1937 9.94616C16.0691 10.1375 15.9178 10.3045 15.7397 10.4469L15.3125 10.0997C15.4527 9.89943 15.5739 9.69136 15.6763 9.4755C15.7809 9.25741 15.8332 9.02486 15.8332 8.77784V8.16364H16.5809Z" fill="white"/></svg>';
const iconStringReplace    = '<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.962017 16H0.0941198L2.60435 9.16364H3.45889L5.96912 16H5.10122L3.05832 10.2452H3.00492L0.962017 16ZM1.28247 13.3295H4.78077V14.0639H1.28247V13.3295ZM18.6763 11.3H17.8485C17.7995 11.0619 17.7138 10.8527 17.5914 10.6724C17.4713 10.4922 17.3244 10.3409 17.1508 10.2185C16.9795 10.0938 16.7892 10.0004 16.58 9.93807C16.3708 9.87576 16.1527 9.8446 15.9257 9.8446C15.5118 9.8446 15.1368 9.9492 14.8008 10.1584C14.467 10.3676 14.2011 10.6758 14.003 11.083C13.8072 11.4903 13.7093 11.9899 13.7093 12.5818C13.7093 13.1738 13.8072 13.6734 14.003 14.0806C14.2011 14.4879 14.467 14.7961 14.8008 15.0053C15.1368 15.2144 15.5118 15.319 15.9257 15.319C16.1527 15.319 16.3708 15.2879 16.58 15.2256C16.7892 15.1633 16.9795 15.0709 17.1508 14.9485C17.3244 14.8239 17.4713 14.6714 17.5914 14.4912C17.7138 14.3087 17.7995 14.0995 17.8485 13.8636H18.6763C18.614 14.213 18.5005 14.5257 18.3358 14.8016C18.1711 15.0776 17.9664 15.3124 17.7216 15.506C17.4768 15.6973 17.202 15.8431 16.8971 15.9433C16.5945 16.0434 16.2707 16.0935 15.9257 16.0935C15.3427 16.0935 14.8242 15.951 14.3702 15.6662C13.9162 15.3813 13.5591 14.9763 13.2987 14.4511C13.0383 13.9259 12.9081 13.3028 12.9081 12.5818C12.9081 11.8608 13.0383 11.2377 13.2987 10.7125C13.5591 10.1873 13.9162 9.78229 14.3702 9.49744C14.8242 9.21259 15.3427 9.07017 15.9257 9.07017C16.2707 9.07017 16.5945 9.12024 16.8971 9.22038C17.202 9.32053 17.4768 9.4674 17.7216 9.66101C17.9664 9.85239 18.1711 10.0861 18.3358 10.362C18.5005 10.6357 18.614 10.9484 18.6763 11.3Z" fill="white"/><path d="M0.275672 6V0.909091H1.99584C2.39357 0.909091 2.72004 0.977036 2.97525 1.11293C3.23045 1.24716 3.41938 1.43194 3.54201 1.66726C3.66464 1.90258 3.72596 2.17022 3.72596 2.47017C3.72596 2.77012 3.66464 3.0361 3.54201 3.26811C3.41938 3.50012 3.23128 3.68241 2.97773 3.81499C2.72418 3.9459 2.4002 4.01136 2.00579 4.01136H0.61374V3.45455H1.9859C2.25768 3.45455 2.47643 3.41477 2.64215 3.33523C2.80953 3.25568 2.9305 3.14299 3.00508 2.99716C3.08131 2.84967 3.11942 2.67401 3.11942 2.47017C3.11942 2.26634 3.08131 2.08819 3.00508 1.93572C2.92884 1.78326 2.80704 1.6656 2.63966 1.58274C2.47229 1.49822 2.25105 1.45597 1.97596 1.45597H0.89215V6H0.275672ZM2.67198 3.71307L3.92482 6H3.20891L1.97596 3.71307H2.67198Z" fill="white"/><path d="M7.93402 18V12.9091H9.71385C10.0685 12.9091 10.361 12.9704 10.5913 13.093C10.8217 13.214 10.9932 13.3772 11.1059 13.5827C11.2186 13.7866 11.2749 14.0128 11.2749 14.2614C11.2749 14.4801 11.236 14.6607 11.1581 14.8033C11.0819 14.9458 10.9808 15.0585 10.8548 15.1413C10.7305 15.2242 10.5955 15.2855 10.4496 15.3253V15.375C10.6054 15.3849 10.762 15.4396 10.9195 15.5391C11.0769 15.6385 11.2086 15.781 11.3147 15.9666C11.4208 16.1522 11.4738 16.3793 11.4738 16.6477C11.4738 16.9029 11.4158 17.1325 11.2998 17.3363C11.1838 17.5401 11.0007 17.7017 10.7504 17.821C10.5002 17.9403 10.1746 18 9.77351 18H7.93402ZM8.5505 17.4531H9.77351C10.1762 17.4531 10.4621 17.3752 10.6311 17.2195C10.8018 17.062 10.8871 16.8714 10.8871 16.6477C10.8871 16.4754 10.8432 16.3163 10.7554 16.1705C10.6676 16.023 10.5425 15.9053 10.38 15.8175C10.2176 15.728 10.0254 15.6832 9.80334 15.6832H8.5505V17.4531ZM8.5505 15.1463H9.69397C9.87957 15.1463 10.047 15.1098 10.1961 15.0369C10.3469 14.964 10.4662 14.8613 10.5541 14.7287C10.6435 14.5961 10.6883 14.4403 10.6883 14.2614C10.6883 14.0376 10.6104 13.8479 10.4546 13.6921C10.2988 13.5347 10.0519 13.456 9.71385 13.456H8.5505V15.1463Z" fill="white"/><path d="M8.72684 10.4314C8.8411 8.38532 8.18851 5.28547 4.9663 4.51052" stroke="white"/><line x1="10.518" y1="9.5204" x2="8.07839" y2="11.6097" stroke="white"/><line x1="6.81449" y1="9.59341" x2="9.27206" y2="11.3618" stroke="white"/><line x1="2.44721" y1="3.77639" x2="3.44721" y2="5.77639" stroke="white"/></svg>';

const iconColor            = '<svg width="14" height="13" viewBox="0 0 14 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.8409 2.43384C10.7465 1.2502 9.18038 0.509092 7.44118 0.509092C4.13249 0.509092 1.45027 3.19131 1.45027 6.5C1.45027 9.80869 4.13249 12.4909 7.44118 12.4909C9.18038 12.4909 10.7465 11.7498 11.8409 10.5662" stroke="white"/><path d="M7.5 7.57511C8.09377 7.57511 8.57511 7.09377 8.57511 6.5C8.57511 5.90623 8.09377 5.42489 7.5 5.42489C6.90623 5.42489 6.42489 5.90623 6.42489 6.5C6.42489 7.09377 6.90623 7.57511 7.5 7.57511Z" fill="white"/></svg>';
const iconColorRandom      = '<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.8409 2.43385C10.7465 1.2502 9.18038 0.509094 7.44118 0.509094C4.13249 0.509094 1.45027 3.19132 1.45027 6.5C1.45027 9.80869 4.13249 12.4909 7.44118 12.4909C9.18038 12.4909 10.7465 11.7498 11.8409 10.5662" stroke="white"/><path d="M6.70419 7.80159V7.71763C6.70634 7.32795 6.74294 7.01793 6.81399 6.78757C6.88719 6.55721 6.99053 6.37206 7.12401 6.23212C7.25749 6.09003 7.42003 5.95978 7.61164 5.84137C7.74297 5.75956 7.8603 5.67021 7.96364 5.57333C8.06913 5.4743 8.15202 5.3645 8.2123 5.24393C8.27258 5.12122 8.30273 4.98451 8.30273 4.8338C8.30273 4.66372 8.2629 4.51625 8.18324 4.39138C8.10358 4.26651 7.99594 4.16963 7.8603 4.10074C7.72682 4.03184 7.57719 3.9974 7.41142 3.9974C7.25856 3.9974 7.11324 4.03077 6.97546 4.09751C6.83982 4.16209 6.72679 4.26113 6.63637 4.39461C6.5481 4.52594 6.49859 4.69279 6.48782 4.89516H5.33817C5.34893 4.48611 5.44796 4.14379 5.63527 3.86822C5.82472 3.59265 6.07446 3.38597 6.38448 3.24818C6.69665 3.1104 7.04112 3.0415 7.41788 3.0415C7.82908 3.0415 8.19077 3.11363 8.50295 3.25787C8.81727 3.40212 9.06163 3.60772 9.23601 3.87468C9.41255 4.13949 9.50082 4.45381 9.50082 4.81766C9.50082 5.06309 9.46099 5.28269 9.38133 5.47645C9.30383 5.67021 9.19296 5.84244 9.04871 5.99315C8.90446 6.14385 8.73331 6.27841 8.53524 6.39682C8.36085 6.50446 8.21769 6.61642 8.10573 6.73267C7.99594 6.84893 7.91413 6.98564 7.8603 7.1428C7.80863 7.29781 7.78172 7.48942 7.77957 7.71763V7.80159H6.70419Z" fill="white"/><path d="M6.70947 9.81362C6.8745 9.97612 7.07127 10.0574 7.29978 10.0574C7.45212 10.0574 7.59049 10.0205 7.7149 9.94692C7.84185 9.87075 7.94341 9.76919 8.01958 9.64224C8.09829 9.51529 8.13764 9.37438 8.13764 9.2195C8.13764 8.99099 8.05386 8.79549 7.88629 8.63299C7.72125 8.4705 7.52575 8.38925 7.29978 8.38925C7.07127 8.38925 6.8745 8.4705 6.70947 8.63299C6.54443 8.79549 6.46191 8.99099 6.46191 9.2195C6.46191 9.45309 6.54443 9.65113 6.70947 9.81362Z" fill="white"/></svg>';
const iconColorValidate    = '<svg width="19" height="16" viewBox="-2 -1 19 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.37676 4.0162 0.140352 5.43241C-0.0960661 6.84862 0.146576 8.30322 0.829882 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="white"/></svg>';
const iconColorInterpolate = '<svg width="18" height="20" viewBox="0 0 18 20" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="2.5" r="2.5" fill="white" fill-opacity="0.1"/><circle cx="9.5" cy="2.5" r="2" stroke="white" stroke-opacity="0.4"/><circle cx="2.5" cy="9.5" r="2.5" fill="white" fill-opacity="0.4"/><circle cx="2.5" cy="9.5" r="2" stroke="white" stroke-opacity="0.7"/><circle cx="9.5" cy="16.5" r="2.5" fill="white" fill-opacity="0.8"/><circle cx="9.5" cy="16.5" r="2" stroke="white" stroke-opacity="0.9"/><circle cx="14.5" cy="14.5" r="2" fill="white" stroke="white"/><circle cx="14.5" cy="4.5" r="2" stroke="white" stroke-opacity="0.4"/><circle cx="4.5" cy="14.5" r="2.5" fill="white" fill-opacity="0.6"/><circle cx="4.5" cy="14.5" r="2" stroke="white" stroke-opacity="0.8"/><circle cx="4.5" cy="4.5" r="2.5" fill="white" fill-opacity="0.2"/><circle cx="4.5" cy="4.5" r="2" stroke="white" stroke-opacity="0.6"/></svg>';
const iconColorContrast    = '<svg width="17" height="17" viewBox="0 0 17 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.49866 15.5233C12.3783 15.5233 15.5233 12.3783 15.5233 8.49867C15.5233 4.61906 12.3783 1.47401 8.49866 1.47401C4.61906 1.47401 1.47401 4.61906 1.47401 8.49867C1.47401 12.3783 4.61906 15.5233 8.49866 15.5233Z" stroke="white"/><path d="M8.01022 15.1997C6.14349 15.1997 4.3532 14.494 3.03321 13.2377C1.71321 11.9814 0.971649 10.2775 0.971649 8.50083C0.971649 6.72416 1.71321 5.02026 3.03321 3.76397C4.3532 2.50768 6.14349 1.8019 8.01022 1.8019V8.50083V15.1997Z" fill="white"/></svg>';
const iconColorblind       = '<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 18.4807C14.4599 18.4807 18.4807 14.4599 18.4807 9.5C18.4807 4.54009 14.4599 0.519287 9.5 0.519287C4.54009 0.519287 0.519283 4.54009 0.519283 9.5C0.519283 14.4599 4.54009 18.4807 9.5 18.4807Z" stroke="white" stroke-width="0.919355" stroke-dasharray="1.84 1.84"/><path d="M9.5 14.5417C12.2844 14.5417 14.5417 12.2844 14.5417 9.5C14.5417 6.71557 12.2844 4.45834 9.5 4.45834C6.71557 4.45834 4.45834 6.71557 4.45834 9.5C4.45834 12.2844 6.71557 14.5417 9.5 14.5417Z" stroke="white" stroke-width="0.919355"/><path d="M9.5 10.918C10.2831 10.918 10.918 10.2831 10.918 9.5C10.918 8.71686 10.2831 8.08199 9.5 8.08199C8.71686 8.08199 8.08199 8.71686 8.08199 9.5C8.08199 10.2831 8.71686 10.918 9.5 10.918Z" fill="white"/></svg>';
const iconFill             = '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13 7C13 10.3137 10.3137 13 7 13C3.68629 13 1 10.3137 1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7Z" stroke="white" stroke-opacity="0.5" stroke-width="2"/><path d="M7 12C9.76142 12 12 9.76142 12 7C12 4.23858 9.76142 2 7 2C4.23858 2 2 4.23858 2 7C2 9.76142 4.23858 12 7 12Z" fill="white"/></svg>';
const iconStroke           = '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13 7C13 10.3137 10.3137 13 7 13C3.68629 13 1 10.3137 1 7C1 3.68629 3.68629 1 7 1C10.3137 1 13 3.68629 13 7Z" stroke="white" stroke-width="2"/><path d="M7 12C9.76142 12 12 9.76142 12 7C12 4.23858 9.76142 2 7 2C4.23858 2 2 4.23858 2 7C2 9.76142 4.23858 12 7 12Z" fill="white" fill-opacity="0.35"/></svg>';

const iconRectangle        = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="15" height="15" stroke="white"/></svg>';
const iconLine             = '<svg width="17" height="17" viewBox="0 1 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="0.772299" y1="15.9778" x2="15.6598" y2="1.09027" stroke="white" stroke-width="1.3"/></svg>';
const iconEllipse          = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="7.5" stroke="white"/></svg>';
const iconPolygon          = '<svg width="20" height="16" viewBox="0 0 20 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.82238 15.4885L10.0496 1.23853L18.2769 15.4885H1.82238Z" stroke="white"/></svg>';
const iconStar             = '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.8156 2.24924L10.4021 7.13198L10.5144 7.47747H10.8776H16.0116L11.8581 10.4952L11.5642 10.7087L11.6765 11.0542L13.263 15.9369L9.10949 12.9192L8.8156 12.7057L8.5217 12.9192L4.3682 15.9369L5.9547 11.0542L6.06695 10.7087L5.77306 10.4952L1.61955 7.47747H6.75357H7.11684L7.2291 7.13198L8.8156 2.24924Z" stroke="white"/></svg>';

const iconHand             = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.85653 12.2494L1.8554 12.2484C1.32015 11.771 1.2929 10.8911 1.7976 10.3815C2.3023 9.87193 3.1824 9.89065 3.665 10.4213L3.67129 10.4282L3.67773 10.435L4.27294 11.0653L5.99999 12.8943V10.3788V4C5.99999 3.46423 6.46423 3 6.99999 3C7.16906 3 7.33572 3.04789 7.48718 3.13836L7.99999 3.44469V9H8.99999V4.04203V3V2.27986V2C8.99999 1.46423 9.46423 1 9.99999 1C10.4142 1 10.807 1.27942 10.9437 1.66905L11.0597 2H11V9H12V2.4661L12.4437 2.16905C12.6058 2.06052 12.804 2 13 2C13.5358 2 14 2.46423 14 3V4V4.27549V6.02711V9H15V5.43676L15.5084 5.13662C15.6583 5.04814 15.8261 5 16 5C16.5358 5 17 5.46423 17 6V13.5C17 15.6001 15.7227 17.6052 13.812 18.4904C11.8955 19.3783 9.56768 19.0654 7.95351 17.7039L1.85653 12.2494ZM15 4.27549V4V3.17508V3C15 1.91195 14.088 1 13 1C12.9434 1 12.8868 1.00246 12.8304 1.00733C12.4943 1.03638 12.1668 1.15099 11.8873 1.3381C11.7759 1.02046 11.5846 0.741833 11.341 0.522228C10.9792 0.195965 10.5019 0 9.99999 0C9.18005 0 8.46014 0.517876 8.15511 1.23874C8.05538 1.47446 7.99999 1.73188 7.99999 2V2.27986C7.70403 2.10307 7.36184 2.00018 7.00094 2H6.99999C5.91195 2 4.99999 2.91195 4.99999 4V8.92652V9.18641V9.20713V10.3788L4.40481 9.74846C4.2821 9.61355 4.14593 9.49706 3.99999 9.39906C3.11355 8.80379 1.86654 8.89082 1.08709 9.67785C0.179345 10.5944 0.227074 12.136 1.18978 12.9947L7.2972 18.4585C9.20886 20.0788 11.9586 20.4512 14.2324 19.3978C16.4971 18.3486 18 15.989 18 13.5V6C18 4.91195 17.088 4 16 4C15.6382 4 15.2958 4.10085 15 4.27549Z" fill="white"/></svg>';

const iconComment          = '<svg width="18" height="17" viewBox="0 0 18 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5375L3.6897 11.045C3.24801 10.1283 3 9.09994 3 8.01086C3 4.14487 6.13401 1.01086 10 1.01086C13.866 1.01086 17 4.14487 17 8.01086C17 11.8769 13.866 15.0109 10 15.0109C8.89526 15.0109 7.85296 14.7557 6.92628 14.302L6.65842 14.1708L6.36249 14.2078L1.94388 14.7601L3.64047 12.0032L3.92701 11.5375ZM0.671856 14.9191L0 16.0109L1.27203 15.8519L6.48652 15.2001C7.5471 15.7194 8.73951 16.0109 10 16.0109C14.4183 16.0109 18 12.4292 18 8.01086C18 3.59258 14.4183 0.0108643 10 0.0108643C5.58172 0.0108643 2 3.59258 2 8.01086C2 9.25344 2.28329 10.4299 2.78881 11.4791L0.671856 14.9191Z" fill="white"/></svg>';



var btnMain;
var btnNumber;
var btnString;
var btnColor;
var btnStyle;
var btnShape;
var btnHand;
var btnComment;

var btnZoom;


var menuMain;
var menuMainPreferences;
var menuMainDebug;
var menuMainDebugLogging;
var menuMainDebugLoggingRaw;
var menuMainHelp;

var menuNumber;
var menuString;
var menuColor;
var menuStyle;
var menuShape;

var menuZoom;


var menuItemEnableLxxColorSpaces;

var menuItemShowNodeId;
var menuItemShowWires;

var menuItemLogMessages;
var menuItemLogActions;
var menuItemLogRawLoading;
var menuItemLogRawSaving;
var menuItemLogLoading;
var menuItemLogRawRequests;
var menuItemLogRawValues;
var menuItemLogRequests;
var menuItemLogValueUpdates
var menuItemLogObjectUpdates;

var menuItemZoomTo100;



function initMenuBar()
{
    menuMainPreferences = new Menu('Preferences', false);
    menuMainPreferences.addItems([ 
        menuItemEnableLxxColorSpaces = new MenuItem('Enable Lxx color spaces', {checkCallback: () => settings.enableLxxColorSpaces, callback: () => updateSettingAndMenu('enableLxxColorSpaces', true, !settings.enableLxxColorSpaces)})]);


    menuMainDebugLoggingRaw = new Menu('Raw', false);
    menuMainDebugLoggingRaw.addItems([
        menuItemLogRawLoading    = new MenuItem('Raw loading',  {checkCallback: () => settings.logRawLoading   , callback: () => { updateSettingAndMenu('logRawLoading',    true, !settings.logRawLoading );  updateEnableLxxColorSpace(); }}),
        menuItemLogRawSaving     = new MenuItem('Raw saving',   {checkCallback: () => settings.logRawSaving    , callback: () =>   updateSettingAndMenu('logRawSaving',     true, !settings.logRawSaving  )}),
                                   new MenuItem('',             {separator: true}),
        menuItemLogRawRequests   = new MenuItem('Raw requests', {checkCallback: () => settings.logRawRequests  , callback: () =>   updateSettingAndMenu('logRawRequests',   true, !settings.logRawRequests)}),
        menuItemLogRawValues     = new MenuItem('Raw values',   {checkCallback: () => settings.logRawValues    , callback: () =>   updateSettingAndMenu('logRawValues',     true, !settings.logRawValues  )})]);


    menuMainDebugLogging = new Menu('Logging', false);
    menuMainDebugLogging.addItems([
        menuItemLogMessages      = new MenuItem('Messages', {checkCallback: () => settings.logMessages     , callback: () => updateSettingAndMenu('logMessages',      true, !settings.logMessages     )}),
        menuItemLogActions       = new MenuItem('Actions',  {checkCallback: () => settings.logActions      , callback: () => updateSettingAndMenu('logActions',       true, !settings.logActions      )}),
                                   new MenuItem('',         {separator: true}),
        menuItemLogLoading       = new MenuItem('Loading',  {checkCallback: () => settings.logLoading      , callback: () => updateSettingAndMenu('logLoading',       true, !settings.logLoading      )}),
                                   new MenuItem('',         {separator: true}),
        menuItemLogRequests      = new MenuItem('Requests', {checkCallback: () => settings.logRequests     , callback: () => updateSettingAndMenu('logRequests',      true, !settings.logRequests     )}),
        menuItemLogValueUpdates  = new MenuItem('Values',   {checkCallback: () => settings.logValueUpdates , callback: () => updateSettingAndMenu('logValueUpdates',  true, !settings.logValueUpdates )}),
        menuItemLogObjectUpdates = new MenuItem('Objects',  {checkCallback: () => settings.logObjectUpdates, callback: () => updateSettingAndMenu('logObjectUpdates', true, !settings.logObjectUpdates)}),
                                   new MenuItem('',         {separator: true}),
                                   new MenuItem('Raw',      {childMenu: menuMainDebugLoggingRaw})]);


    menuMainDebug = new Menu('Debug', false);
    menuMainDebug.addItems([
        menuItemShowNodeId = new MenuItem('Show node IDs',
        {
            checkCallback: () => settings.showNodeId, 
            callback:      () => 
            {
                updateSettingAndMenu('showNodeId', true, !settings.showNodeId);
                graph.nodes.forEach(n => n.updateNode());
            }
        }),
        menuItemShowWires = new MenuItem('Show wires',
        {
            checkCallback: () => settings.showWires, 
            callback:      () => 
            {
                updateSettingAndMenu('showWires', true, !settings.showWires);
                graphView.updateShowWires(settings.showWires);  
            }
        }),
        new MenuItem('',        {separator: true}),
        new MenuItem('Logging', {childMenu: menuMainDebugLogging})]);


    menuMainHelp = new Menu('Help and activation', false);
    menuMainHelp.addItems([
        new MenuItem('Help page',            {callback: () => window.open('http://www.bourt.com/generator/help', '_blank')}),
        new MenuItem('',                     {separator: true}),
        new MenuItem('Enter product key...', {callback: () => showProductKeyDialog()})]);


    menuMain = new Menu('Main menu', false);
    menuMain.addItems([
                       new MenuItem('Preferences',         {childMenu: menuMainPreferences}),
                       new MenuItem('Debug',               {childMenu: menuMainDebug}),
                       new MenuItem('',                    {separator: true}),
        menuMainHelp = new MenuItem('Help and activation', {childMenu: menuMainHelp })]);
  
        
    menuNumber = new Menu('Number nodes');
    menuNumber.addItems([
        new MenuItem('Number',      {icon: iconNumber,    callback: () => actionManager.do(new CreateNodeAction(NUMBER, btnNumber.div))}),
        new MenuItem('Limits',      {icon: iconLimits     , enabled: false}),
        new MenuItem('Math',        {icon: iconMath       , enabled: false}),
        new MenuItem('Add',         {icon: iconAdd        , enabled: false}),
        new MenuItem('Subtract',    {icon: iconSubtract   , enabled: false}),
        new MenuItem('Multiply',    {icon: iconMultiply   , enabled: false}),
        new MenuItem('Divide',      {icon: iconDivide     , enabled: false}),
        new MenuItem('Exponent',    {icon: iconExponent   , enabled: false}),
        new MenuItem('Modulo',      {icon: iconModulo     , enabled: false}),
        new MenuItem('Interpolate', {icon: iconInterpolate, enabled: false})]);
    
    
    menuString = new Menu('String nodes');
    menuString.addItems([
        new MenuItem('String',      {icon: iconString       , enabled: false}),
        new MenuItem('Join',        {icon: iconStringJoin   , enabled: false}),
        new MenuItem('Substring',   {icon: iconSubstring    , enabled: false}),
        new MenuItem('Replace',     {icon: iconStringReplace, enabled: false})]);
    
    
    menuColor = new Menu('Color nodes');
    menuColor.addItems([
        new MenuItem('Color',        {icon: iconColor           , callback: () => actionManager.do(new CreateNodeAction(COLOR, btnColor.div))}),
        //new MenuItem('Random color', {icon: iconColorRandom     , callback: () => actionManager.do(new CreateNodeAction(COLOR, btnColor.div, {random: true}))}),
        //new MenuItem('',             {separator: true}),
        new MenuItem('Interpolate',  {icon: iconColorInterpolate, enabled: false}),
        new MenuItem('Validate',     {icon: iconColorValidate   , enabled: false}),
        new MenuItem('Contrast',     {icon: iconColorContrast   , enabled: false}),
        new MenuItem('Colorblind',   {icon: iconColorblind      , enabled: false})]);
    
    
    menuStyle = new Menu('Style nodes');
    menuStyle.addItems([
        new MenuItem('Solid fill', {icon: iconFill,   callback: () => actionManager.do(new CreateNodeAction(FILL,   btnColor.div))}),
        //new MenuItem('',           {separator: true}),
        new MenuItem('Stroke',     {icon: iconStroke, callback: () => actionManager.do(new CreateNodeAction(STROKE, btnColor.div))})]);
    
    
    menuShape = new Menu('Shape nodes');
    menuShape.addItems([
        new MenuItem('Rectangle',   {icon: iconRectangle, callback: () => actionManager.do(new CreateNodeAction(RECTANGLE, btnShape.div))}),
        new MenuItem('Line',        {icon: iconLine   , enabled: false}),
        new MenuItem('Ellipse',     {icon: iconEllipse, enabled: false}),
        new MenuItem('Polygon',     {icon: iconPolygon, enabled: false}),
        new MenuItem('Star',        {icon: iconStar   , enabled: false})]);


    menuZoom = new Menu('Zoom/view options', false);
    menuZoom.addItems([
                            new MenuItem('Zoom in',      {shortcut: osCtrl()  + '+', callback: () => graphView.zoom *= Math.pow(2, 1/2)}),
                            new MenuItem('Zoom out',     {shortcut: osCtrl()  + '-', callback: () => graphView.zoom /= Math.pow(2, 1/2)}),
                            new MenuItem('Zoom to fit',  {shortcut: osShift() + '1', enabled:  false}),
        menuItemZoomTo100 = new MenuItem('Zoom to 100%', {shortcut: osCtrl()  + '0', callback: () => graphView.zoom = 1})]);


    btnMain    = new MenuButton('', menuMain, {useMenuName: true, highlight: () => currentMenus.includes(menuMain)});
    btnNumber  = new MenuButton('', menuNumber);
    btnString  = new MenuButton('', menuString);
    btnColor   = new MenuButton('', menuColor );
    btnStyle   = new MenuButton('', menuStyle );
    btnShape   = new MenuButton('', menuShape );
    btnHand    = new MenuButton('Hand tool', null, {callback: () => 
        { 
            panMode = !panMode;  
            currentMenuButton = panMode ? btnHand : null;
            btnHand.update();
        }});
    btnComment = new MenuButton('Add comment', null, {callback: () => actionManager.do(new CreateNodeAction(COMMENT, btnComment.div))});


    btnZoom = new MenuButton('', menuZoom, 
        {
            useMenuName: true, 
            selectLast:  false,
            highlight:   () => currentMenus.includes(menuZoom)
        });

        
    btnZoom.div.style.position     = 'absolute';
    btnZoom.div.style.right        = '0px';
    btnZoom.div.style.paddingRight = '5px';
    btnZoom.div.style.paddingLeft  = '11px';
    // btnZoom.div.style.boxShadow = '0 0 0 1px red inset';


    btnMain   .setIcon(iconGenerator);
    btnHand   .setIcon(iconHand);
    btnComment.setIcon(iconComment);
}


class MenuButton
{
    name;
    menu;

    icon     = '';

    callback;
    highlight;
    useMenuName;

    selectLast;


    div;

    divIcon;
    divArrow;

    over      = false;
    overArrow = false;

    tooltipIcon;
    tooltipArrow;



    constructor(name, menu, options = {})
    {
        this.name = name;
        this.menu = menu;

        if (this.menu)
            this.menu.button = this;

        this.initOptions(options);
        
        this.createControls();
        this.createTooltips();

        this.update();
    }



    initOptions(options)
    {
        this.callback    = options.callback    != undefined ? options.callback    : null;
        this.highlight   = options.highlight   != undefined ? options.highlight   : null;
        this.useMenuName = options.useMenuName != undefined ? options.useMenuName : false;
        this.selectLast  = options.selectLast  != undefined ? options.selectLast  : true;
    }



    createControls()
    {
        this.div      = createDiv('menuButton');

        this.divIcon  = createDiv('menuButtonIcon');
        this.divArrow = createDiv('menuButtonArrow');


        this.div.addEventListener('pointerenter', () => 
        {
            this.over = true;
            this.update();
        });
   

        this.div.addEventListener('pointerleave', () => 
        {
            // if (   (    currentMenus.length == 0
            //     || !currentMenus.includes(this.menu))
            //     && currentMenuButton != this) 
            //     this.div.style.background = 'transparent';
                
            this.over = false;
            this.update();
        });


        if (this.menu) 
        {
            this.div.addEventListener('pointerdown', e => 
            {
                if (e.button == 0)
                {
                    disableCurrentMenuButton();


                    if (this.useMenuName)
                    {
                        e.stopPropagation();
                        this.showMenu();
                    }
                    else if (this.selectLast
                          && this.menu.lastItem)
                        this.menu.lastItem.select();

                    
                    this.update();
                }
            });


            if (this.useMenuName) this.createArrowEvents(this.div);
            else                  this.createArrowEvents(this.divArrow);
            

            this.divArrow.addEventListener('pointerdown', e => 
            {
                if (e.button == 0)
                {
                    e.stopPropagation();
                    this.showMenu();
                    this.update();
                }
            });
        }
        else if (this.callback) 
        {
            this.div.addEventListener('click', () =>
            {
                disableCurrentMenuButton();
                this.callback();
            });
        }


        this.div.appendChild(this.divIcon);

        if (this.menu)
            this.div.appendChild(this.divArrow);

        menuBar.appendChild(this.div);
    }



    createTooltips()
    {
        const ttName = 
            this.menu 
            ? this.menu.name 
            : this.name;

        this.tooltipIcon  = createDiv('tooltip', 'ttMenuButtonIcon'  + ttName);
        this.tooltipArrow = createDiv('tooltip', 'ttMenuButtonArrow' + ttName);

        document.body.appendChild(this.tooltipIcon);
        document.body.appendChild(this.tooltipArrow);
        

        createTooltip(this.tooltipIcon);
        createTooltip(this.tooltipArrow);

        createTooltipSrc(this.divIcon,  this.div,      () => document.getElementById('ttMenuButtonIcon'  + ttName));
        createTooltipSrc(this.divArrow, this.divArrow, () => document.getElementById('ttMenuButtonArrow' + ttName));
    }



    createArrowEvents(div)
    {
        div.addEventListener('pointerenter', e =>
        {
            this.overArrow = true;
            this.divArrow.style.transform = 'translateY(3px)';
        });


        div.addEventListener('pointerleave', e =>
        {
            if (!currentMenus.includes(this.menu))
                this.divArrow.style.transform = 'translateY(0)';

            this.overArrow = false;
        });
    }



    setIcon(icon)
    {
        this.icon = icon;
        this.update();
    }



    showMenu()
    {
        const curMenus = [...currentMenus];

        hideAllMenus()
        
        if (!curMenus.includes(this.menu))
            this.menu.show(this.div);

            // else
            // this.div.style.background = '#111';
    }



    update()
    {
        this.div.style.width = this.menu ? 50 : 40;


        this.div.style.background =
               currentMenuButton == this
            ||    this.highlight 
               && this.highlight()
                ? 'var(--figma-color-bg-brand)'
                : this.over
                    ? '#111'
                    : 'transparent';


        const icon = 
            this.icon != ''
            ? this.icon
            : this.menu
                ? this.menu.lastItem.icon
                : '';

        if (icon != '')
        {
            this.divIcon.style.background         = 'url(\'data:image/svg+xml;utf8,' + icon + '\')';
            this.divIcon.style.backgroundPosition = '100% 50%';
            this.divIcon.style.backgroundRepeat   = 'no-repeat';
        }


        if (this.menu)
            this.tooltipArrow.innerHTML = this.menu.name;


        if (this.useMenuName)
            this.tooltipIcon.innerHTML = 
                this.menu 
                ? this.menu.name 
                : this.name;
        else
            this.tooltipIcon.innerHTML = 
                   this.menu
                && this.menu.lastItem
                ? this.menu.lastItem.name
                : this.name;        
    }
}


class MenuItem
{
    parentMenu    = null;
    index         = -1;

    enabled       = true;

    checked       = false;
    icon          = ''; // svg
    name          = '';
    shortcut      = '';

    callback      = null;
    checkCallback = null;

    childMenu     = null;

    separator   = false;


    div;

    divCheck;
    divIcon;
    divName;
    divExpand;
    divShortcut;

    divSeparator;



    constructor(name, options = {})
    {
        this.name = name;

        this.initOptions(options);
        this.createControls();

        this.update();
    }



    initOptions(options)
    {
        if (options.icon          != undefined)   this.icon          = options.icon;
        if (options.callback      != undefined)   this.callback      = options.callback;
        if (options.checkCallback != undefined)   this.checkCallback = options.checkCallback;
        if (options.childMenu     != undefined) 
        { 
            this.childMenu = options.childMenu;  
            
            if (this.childMenu)
            this.childMenu.parentMenu = this.parentMenu; 
        }
        if (options.separator   != undefined)   this.separator   = options.separator;
        if (options.shortcut      != undefined)   this.shortcut      = options.shortcut;
        if (options.enabled       != undefined)   this.enabled       = options.enabled;
    }



    createControls()
    {
        this.div          = createDiv('menuItem');

        this.divCheck     = createDiv('menuItemCheck'   );
        this.divIcon      = createDiv('menuItemIcon'    );
        this.divName      = createDiv('menuItemName'    );
        this.divExpand    = createDiv('menuItemExpand'  );
        this.divShortcut  = createDiv('menuItemShortcut');

        this.divSeparator = createDiv('menuSeparator'   );


        this.div.style.pointerEvents = this.separator ? 'none' : 'all';


        this.divName.innerHTML = this.name;

        this.divCheck.visibility = 
               this.checkCallback 
            && this.checkCallback() 
            ? 'visible' 
            : 'hidden';


        if (this.childMenu)
            this.divExpand.style.visibility = 'visible';


        if (this.icon != '')
        {
            this.divIcon.style.background         = 'url(\'data:image/svg+xml;utf8,' + this.icon + '\')';
            this.divIcon.style.backgroundPosition = '50% 50%';
            this.divIcon.style.backgroundRepeat   = 'no-repeat';
        }        

        
        this.divShortcut.innerHTML = this.shortcut;

        
        if (!this.separator)
        {
            this.div.appendChild(this.divCheck   );
            this.div.appendChild(this.divIcon    );
            this.div.appendChild(this.divName    );
            this.div.appendChild(this.divExpand  );
            this.div.appendChild(this.divShortcut);
        }
        else
            this.div.appendChild(this.divSeparator);


        this.div.addEventListener('pointerdown', e => e.stopPropagation());
        this.div.addEventListener('pointerup', e => { if (!this.childMenu) this.select(!e.shiftKey); });


        this.div.addEventListener('pointerenter', () =>
        {
            if (this.enabled)
                this.div.style.background = 'var(--figma-color-bg-brand)';

            if (this.childMenu)
            {
                if (!currentMenus.includes(this.childMenu))
                {
                    hideAllMenusAfter(this.parentMenu);
                    this.childMenu.show(this.div, true);
                }
            }
            else
                hideAllMenusAfter(this.parentMenu);
        });
        
        
        this.div.addEventListener('pointerleave', () =>
        {
            this.div.style.background = 'transparent';
        });
        
        
        // this.div.addEventListener('pointerleave', e =>
        // {
        //     const menuRect = this.div.getBoundingClientRect();

        //     if (    this.childMenu
        //         && !this.childMenu.overMenu
        //         && e.clientX < menuRect.right)
        //         this.childMenu.hide();
        // });
    }



    select(hideCurrent = true)
    {
        if (!this.enabled)
            return;

        if (currentMenus.length > 0) // this lets the item be selected without its parent menu being involved
        {
            currentMenus[0].lastItem = this;
            currentMenus[0].button.update();
        }

        if (hideCurrent)
            hideAllMenus();

        if (this.callback) 
            this.callback(); 
    }



    setChecked(checked)
    {
        this.checked = checked;
        this.update();
    }



    setEnabled(enabled)
    {
        this.enabled = enabled;
        this.update();
    }
    
    
    update()
    {
        this.divCheck.style.visibility = this.checked ? 'visible' : 'hidden';

        this.div     .style.opacity    = this.enabled ? '100%' : '40%';
    }
}


function createToggleButton(width, height)
{
    const btn = createDiv('toggleButton');
    btn.enabled = false;

    btn.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();

        btn.setPointerCapture(e.pointerId);
        btn.enabled = !btn.enabled;
        btn.updateBackground(true);
    });


    btn.addEventListener('pointerup', e =>
    {
        btn.releasePointerCapture(e.pointerId);
        btn.updateBackground(false);
    });


    btn.updateBackground = (enabled) =>
    {
        const col = isDarkMode() ? 'white' : 'black';

        btn.style.background = 
            btn.enabled 
            ? 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 1C4.10457 1 5 1.89543 5 3V5H6V3C6 1.34315 4.65685 0 3 0C1.34315 0 0 1.34315 0 3V5H1V3C1 1.89543 1.89543 1 3 1Z" fill="'+col+'"/><path d="M5 9H6V11C6 12.6569 4.65685 14 3 14C1.34315 14 0 12.6569 0 11V9H1V11C1 12.1046 1.89543 13 3 13C4.10457 13 5 12.1046 5 11V9Z" fill="'+col+'"/><path d="M2.5 4V10H3.5V4H2.5Z" fill="'+col+'"/></svg>\')'
            : 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="'+col+'"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="'+col+'"/></svg>\')';

        btn.style.backgroundPosition = '50% 50%';
        btn.style.backgroundRepeat   = 'no-repeat';

        btn.style.backgroundColor = 
               btn.enabled 
            && enabled 
            ? (isDarkMode() ? '#444' : '#e6e6e6') 
            : 'transparent';
    };


    return btn;
}


function initNumberControlEvents(control)
{
    control.addEventListener('pointerdown', function(e)
    {
        if (graphView.spaceDown)
            return;

        if (e.button == 0)
        {
            if (!control.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let nodeDiv = 
                   control.parentNode
                && control.parentNode.parentNode
                && control.parentNode.parentNode.parentNode
                ? control.parentNode.parentNode.parentNode
                : null;

            if (   nodeDiv 
                && nodeDiv.className == 'node') 
                graphView.putNodeOnTop(nodeDiv.node);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();
                
            control.buttonDown0  = true;
            control.buttonDown0_ = true;
            control.moved        = false;
            control.clientX      = e.clientX;
            control.movedX       = 0;


            if (!control.readOnly)
            {
                control.oldValue   = control.value;
                control.startValue = control.value;
                control.prevValue  = control.value;
                control.sx         = e.clientX;

                control.clickTimer = setTimeout(() => 
                {
                    if (!document.menuHadFocus)
                    {
                        control.moved = true;
                        control.lockPointer(e.pointerId);
                    }
                }, 
                500);
            }


            if (   !control.param
                || !control.param.node.selected)
                control.focus.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand) inset';

            else
            {
                control.focus.style.boxShadow = '0 1px 0 0 var(--figma-color-bg-brand) inset';
                    
                if (control.param.index < control.param.node.params.length-1)
                    control.focus.style.boxShadow += ', 0 -1px 0 0 var(--figma-color-bg-brand) inset';
            }


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();


            if (control.param)
                control.param.noUpdate = true;  
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            control.buttonDown1 = true;
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            control.buttonDown2 = true;
        }
    });



    control.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.spaceDown
            && control.pointerEvents)
        {
            if (graphView.tempConn)
                control.style.cursor = 'default';
            
            else
                control.style.cursor = 
                       control.readOnly 
                    || containsChild(control, control.textbox) 
                    ? 'default'
                    : 'ew-resize';

                    
            const colShadow = 
                isDarkMode()
                ? 'rgba(255, 255, 255, 0.1)'
                : 'rgba(0, 0, 0, 0.1)';

            if (control.param)
            {
                control.focus.style.boxShadow = '0 1px 0 0 ' + colShadow + ' inset';

                if (    control.param.node
                    &&  control.param.node.params.includes(control.param)
                    && !isLastInArray(control.param.node.params, control.param))
                    control.focus.style.boxShadow += ', 0 -1px 0 0 ' + colShadow + ' inset';
            }
            else
            {
                control.focus.style.boxShadow  = '0 0 0 1px ' + colShadow + ' inset ';
            }


            control.focus.style.visibility = 'visible';
            control.focus.style.opacity    = '100%';
    
            control.update();
        }
    });



    control.addEventListener('pointermove', e =>
    {
        if (!control.pointerEvents)
            return;
        

        let rect = boundingRect(control);
        
        control.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        control.clientX = e.clientX;

        
        if (    control.buttonDown0
            && !control.readOnly)
        {
            if (control.isPointerLocked())
            {
                control.movedX += e.movementX;
                
                if (!isNaN(control.value))
                {
                    const dx       = control.movedX * (control.dragReverse ? -1 : 1);
                    const adaptive = 10 * Math.pow(Math.abs(dx), control.acc);
                    const grain    = Math.pow(10, -control.dec);
                    const drag     = grain * sqr(control.dragScale);

                    const val      = control.startValue + dx * drag * adaptive;

                    
                    // reset control movement at the limits for better UX
                    const min = getCtrlKey(e) ? control.min : control.displayMin;
                    const max = getCtrlKey(e) ? control.max : control.displayMax;

                    control.setValue(
                        Math.round(val / grain) * grain, 
                        true, 
                        true,
                        getCtrlKey(e));


                    if (   val <= min
                        || val >= max)
                    {
                        control.movedX     = 0;
                        control.startValue = control.value;
                        control.sx         = e.clientX;
                    }


                    if (control.value != control.prevValue)
                        pushUpdateFromParam([control.param.node], control.param);

                    control.prevValue = control.value;
                }
            }
            else
            {
                if (Math.abs(e.clientX - control.sx) > control.clickSize/2)
                {
                    control.moved = true;
                    control.lockPointer(e.pointerId);

                    control.dispatchEvent(control.onstartchange);
                }
            }
        }
        else if (graphView.tempConn
              && control.param)
        {
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

            if (    graphView.tempConn.output
                &&  control.param.input
                &&  control.param.input.types.includes(graphView.tempConn.output.type)
                && !graphView.tempConn.output.node.isOrFollows(control.param.node)
                && (  !control.param.input.connected // not already connected to this input
                    || control.param.input.connectedOutput != graphView.tempConn.output
                    || control.param.input == savedInput))
            {
                graphView.overInput = control.param.input;
                    
                control.param.input.mouseOver = true;
                control.param.input.updateControl();

                const rect = boundingRect(control.param.input.control);

                graphView.tempConn.wire.inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - menuBar.offsetHeight);
            }
            else if ( graphView.tempConn.input
                  &&  control.param.output
                  &&  graphView.tempConn.input.types.includes(control.param.output.type)
                  && !control.param.node.isOrFollows(graphView.tempConn.input.node))
            {
                graphView.overOutput = control.param.output;
                    
                control.param.output.mouseOver = true;
                control.param.output.updateControl();


                const rect = boundingRect(control.param.output.control);

                graphView.tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - menuBar.offsetHeight);


                graphView.tempConn.input.updateControl();
            }
        }
        else if (control.readOnly)
        {
            control.moved = true;
        }
    });
    
    
    
    control.addEventListener('pointerleave', function(e)
    {
        control.style.cursor           = 'default';
        
        control.focus.style.visibility = 'hidden';
        control.focus.style.opacity    = 0;

        control.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != control.param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != control.param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    control.addEventListener('losecapture', function()
    {
        control.buttonDown0 = false;
        control.buttonDown1 = false;
        control.buttonDown2 = false;
        control.mouseOver   = false;
        control.update();
    });



    control.addEventListener('pointerup', function(e)
    {
        clearTimeout(control.clickTimer);


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(control.param.node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !control.param.node.isOrFollows(graphView.tempConn.input.node)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overOutput.endConnection();
            }
        }
        
        else if (   control.moved
            || document.menuHadFocus)
        {
            control.unlockPointer(e.pointerId);

            if (control.param)
                control.param.noUpdate = false;  

            return;            
        }

        else if (control.buttonDown0_)
        {
            control.clicked = true;
            control.showTextbox();
        }

             if (e.button == 0) control.buttonDown0 = false;
        else if (e.button == 1) control.buttonDown1 = false;
        else if (e.button == 2) control.buttonDown2 = false;

        control.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && control.buttonDown0)
        {
            control.buttonDown0 = false;
            control.unlockPointer(e.pointerId);

            control.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            // if (    control.value != control.oldValue
            //     && !control.readOnly)
            //     control.dispatchEvent(control.onconfirm);
        }
        // else if (   e.button == 1
        //     && control.buttonDown1)
        // {
        //     control.buttonDown1 = false;            
        // }
    });


    
    control.addEventListener('wheel', e =>
    {
        if (!control.pointerEvents)
            return;


        const isTouchpad = 
               Math.abs(e.deltaX) < 100
            && Math.abs(e.deltaY) < 100;


        if (isTouchpad)
        {
            e.preventDefault();
            return;
        }


        const dWheelX = e.deltaX /  20 * (control.dragReverse ? -1 : 1);
        const dWheelY = e.deltaY / 100 * (control.dragReverse ? -1 : 1);


        if (   !getCtrlKey(e)
            && !control.buttonDown1)
        {
            e.stopPropagation();

            if (!control.readOnly)
            {
                if (   document.activeElement
                    && document.activeElement.tagName.toLowerCase() == 'input'
                    && document.activeElement.control)
                    document.activeElement.control.textbox.finish(true, false);

                control.oldValue = control.value;

                const dec = Math.pow(10, -control.dec);

                const val =
                    isTouchpad
                    ? control.value -  dWheelX               * control.wheelScale * dec
                    : control.value + (dWheelY > 0 ? -1 : 1) * control.wheelScale * dec;

                control.setValue(val, true, true, false);
            }
        }
    });



    // graphView.addEventListener('touchstart', e =>
    // {
    //     graphView.touches.push(e);
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchmove', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches[i] = e;
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchend', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchcancel', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    control.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            control.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    control.addEventListener('focus', function()
    {
        if (   !graphView.spaceDown
            && !control.buttonDown1
            && control.pointerEvents)
            control.showTextbox();
    });
}


class NumberControlRange
{
    start;
    end;

    background;

    top;
    bottom;


    constructor(start, end = start, background = 'magenta', top = 0, bottom = 1)
    {
        this.start      = start;
        this.end        = end;

        this.background = background;

        this.top        = top;
        this.bottom     = bottom;
    }
}



function updateControlRanges(control, controlWidth, controlHeight)
{
    if (control.ranges.length == control.rangeDivs.length) // update
    {
        for (let i = 0; i < control.ranges.length; i++)
        {
            updateControlRangeDiv(
                control.ranges   [i],
                control.rangeDivs[i],
                controlWidth,
                controlHeight);
        }
    }
    else // recreate
    {
        resetControlRangeDivs(control);

        for (let i = 0; i < control.ranges.length; i++)
        {
            const range = control.ranges[i];

            const div = createDiv('numberControlRange');
            div.style.zIndex = 0;
            control.rangeDivs.push(div);
            control.appendChild(div);
        
            updateControlRangeDiv(range, div, controlWidth, controlHeight);
        }
    }
};



function updateControlRangeDiv(range, div, controlWidth, controlHeight)
{
    if (range.start == range.end)
        div.style.display = 'none';
    else
    {
        div.style.display    = 'block';
        div.style.left       = controlWidth * range.start;  
        div.style.top        = range.top * controlHeight;
        div.style.width      = controlWidth * (range.end - range.start);
        div.style.height     = (range.bottom - range.top) * controlHeight;
        div.style.background = range.background;
    }
};



function resetControlRanges(control)
{
    control.ranges = [];
    resetControlRangeDivs(control);        
};



function resetControlRangeDivs(control)
{
    for (const div of control.rangeDivs)
        if (control.contains(div))
            control.removeChild(div);

    control.rangeDivs = [];
}


function initNumberControlTextbox(control)
{
    control.textbox = createTextbox('numberControlTextbox');
    control.textbox.control = control;
    


    control.textbox.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();
    });



    control.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();
        control.textbox.style.cursor = 'default';
    });



    control.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !control.readOnly)
        {
            // let the OS do its thing here
        }
        
        else if (   (   e.code == 'Enter'
                     || e.code == 'NumpadEnter')
                 && !control.readOnly)
        {
            control.textbox.keyBlur = true;
            control.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            control.textbox.keyBlur = true;
            control.textbox.finish(false);
        }
        else if (e.code == 'Tab')
        {
            e.preventDefault();
            e.stopPropagation();
            
            if (control.param)
            {
                const params = control.param.node.params;
                let   index  = control.param.index;

                control.textbox.keyBlur = true;
                control.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (params[--index].control.readOnly);
                    params[index].control.showTextbox();
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (params[++index].control.readOnly);
                    params[index].control.showTextbox();
                }
            }

            // let tabs  = document.querySelectorAll('.numberControl, .selectControl, .select, .menuSelect, button, .menuButton');
            // let index = control.tabIndex;

            // for (let i = 0; i < tabs.length; i++) 
            // {
            //     if (   e.shiftKey && tabs[i].tabIndex == index - 1
            //         ||               tabs[i].tabIndex == index + 1) 
            //     {
            //         if (tabs[i].className == 'slider')
            //             tabs[i].showTextbox();
            //         else 
            //         {
            //             document.activeElement.blur();
            //             tabs[i].focus();
            //         }

            //         break;
            //     }
            // }
        }

        else if ((   e.key == 'ArrowUp'
                  || e.key == 'ArrowDown')
              && !control.readOnly)
        {
            e.preventDefault();

            let text = control.textbox.value;

            if (   control.valueCanContainSuffix   
                && text.length >= control.suffix.length
                && text.substring(text.length - control.suffix.length) == control.suffix)
                text = text.substring(0, text.length - control.suffix.length);


            if (control.textbox.selectionStart != control.textbox.selectionEnd)
                control.textbox.selectionStart =  control.textbox.selectionEnd;

            const pos = Math.min(
                control.textbox.selectionStart,
                text.length);

            const revPos = text.length - pos;

            const val  = parseFloat(text);
            const sign = e.key == 'ArrowUp' ? 1 : -1;

            let decIndex = text.indexOf('.');
            if (decIndex < 0) decIndex = text.indexOf(',');
            
            if (   text[0] != '-'
                || pos > 0)
            {
                if (decIndex < 0) // integer
                {
                    let dec = Math.pow(10, revPos);

                    if (e.shiftKey) 
                        dec *= 10;

                    control.setValue((val + sign * dec) / control.valueScale);
                    control.updateTextbox();
                }
                else // floating point
                {
                    const _edit = pos - decIndex - 1;

                    let  dec  = 
                        _edit < 0
                        ?     Math.pow(10, -_edit - 1)
                        : 1 / Math.pow(10,  _edit    );

                    if (e.shiftKey) 
                        dec *= 10;

                    control.displayDec = text.length-1 - decIndex;
                    control.setValue((val + sign * dec) / control.valueScale);
                    control.updateTextbox();
                }

                control.textbox.selectionStart =
                control.textbox.selectionEnd   = control.textbox.savedValue.length - revPos - control.suffix.length;
            }
        }
        else 
        {
            let curVal = control.textbox.value;

            if (      e.key.length == 1
                   && !isDigit(e.key)
                   && e.key != '?'
                   && (   !control.valueCanContainSuffix
                       || !control.suffix.includes(e.key))
                   && (   !control.showHex 
                       || !isHexDigit(e.key))
                   && (   control.showHex
                       ||    e.key != '.'
                          && e.key != ',')
                   && !(   ((      e.code == 'Minus'
                                || e.code == 'NumpadSubtract')
                             && !curVal.includes('-'))
                        && control.min < 0)
                ||     control.readOnly
                   && !isArrowKey(e.code))
                e.preventDefault();

            curVal =
                curVal == INVALID
                ? ''
                :   curVal.substring(0, control.textbox.selectionStart) 
                  + curVal.substring(control.textbox.selectionEnd, curVal.length);

                  
            const nextVal = parseFloat(curVal + e.key);

            if (   nextVal < control.min - 0.001
                || nextVal > control.max)
                e.preventDefault();            
        }
    });



    control.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        const str = e.clipboardData.getData('text/plain');

        let val = 
            control.showHex
            ? parseInt(str, 16)
            : parseFloat(str);

        val = Math.min(Math.max(control.min, val), control.max);

        control.textbox.value = isNaN(val) ? '' : val;
    });



    control.textbox.addEventListener('focusout', function()
    {
        //console.log('control.successOnFocusOut', control.successOnFocusOut);

        if (!control.textbox.keyBlur) control.textbox.finish(true);
        else                         control.textbox.keyBlur = false;

        if (control.savedSuccessOnFocusOut != null)
        {
            control.successOnFocusOut      = control.savedSuccessOnFocusOut;
            control.savedSuccessOnFocusOut = null;
        }

        control.parentNode.removeChild(control.textbox);
        control.clicked = false;
    });
    


    control.textbox.finish = function(success, focusControl = true)
    {
        let   value      = control.textbox.value;
        const savedValue = control.textbox.savedValue;

        value = value.replace(control.suffix, '');
        
        
        let val      = value     .indexOf(INVALID) > -1 ? Number.NaN : (control.showHex ? parseInt(value,      16) : parseFloat(value     ));
        let savedVal = savedValue.indexOf(INVALID) > -1 ? Number.NaN : (control.showHex ? parseInt(savedValue, 16) : parseFloat(savedValue));

        if (!isNaN(val))
            val /= control.valueScale;

       
        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           value,
            'oldValue':        savedValue,
            'preventSetValue': false }});

        control.dispatchEvent(e);


        if (!e.preventSetValue)
        {
            if (success) 
            {
                control.setValue(
                       value.trim() != '' 
                    && value.trim() != '-'
                    ? val 
                    : savedVal);
            }
            else
                control.setValue(savedVal);
        }
         
        
        control.textbox.blur();

        control.text.style.display = 'block';

        if (   control.inFocus
            && focusControl)
            control.focus();
    };    
    
    

    control.showTextbox = function()
    {
        control.text.style.display = 'none';

        control.inFocus = 
               hasFocus(control)
            && !control.clicked;
    
        // control.textbox.style.position  = 'absolute';
        // control.textbox.style.left      = '50%';
        // control.textbox.style.transform = 'translate(-50%)';
        // control.textbox.style.top       = control.offsetTop    + 1;
        // control.textbox.style.width     = control.offsetWidth  - 2;
        // control.textbox.style.height    = control.offsetHeight - 2;
        control.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
        control.textbox.style.outline   = 'none';
        control.textbox.style.textAlign = 'center';
        //control.textbox.style.color     = control.text.style.color;


        const isConnected =    
               control.param != null
            && control.param.input
            && control.param.input.connected;

        // enableElementText(
        //     control.textbox, 
        //        !control.readOnly
        //     && !isConnected);

        control.updateTextbox();
        
        control.parentNode.appendChild(control.textbox);
        
        control.textbox.focus();
        control.textbox.select();

        control.textbox.style.cursor = 'default';
    }



    control.updateTextbox = function()
    {
        control.textbox.value =
            (isNaN(control.value)
             ? DISPLAY_INVALID
             : numToString(
                   control.value * control.valueScale, 
                   control.displayDec, 
                   control.showHex
               ).toUpperCase())
            + (control.valueCanContainSuffix ? control.suffix : '');
            
        control.textbox.savedValue = control.textbox.value;
    };
}


function initNumberControlChildren(control)
{
    control.bar   = createDiv('numberControlBar');
    control.text  = createDiv('numberControlText');
    control.focus = createDiv('numberControlFocus');

    control.appendChild(control.bar);
    control.appendChild(control.text);
    control.appendChild(control.focus);
}



function initNumberControl(param, control, width, height, id, name, showName, defaultValue, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER, dec = 0, dragScale = 0.05, wheelScale = 1, acc = 0, suffix = '')
{
    control.param                  = param;
     
    control.width                  = width;
    control.height                 = height;
             
    control.style.width            = width;
    control.style.height           = height;
             
    control.value                  = defaultValue;

    control.min                    = min;
    control.max                    = max;

    control.displayMin             = min;
    control.displayMax             = max;

    control.acc                    = acc;
     
    control.dec                    =
    control.displayDec             = dec;
         
    control.valueScale             = 1;
                
    control.id                     = id;
    control.name                   = name;
    control.suffix                 = suffix;
    control.valueCanContainSuffix  = false;
     
    control.dragReverse            = false;
    control.dragScale              = dragScale;
    control.wheelScale             = wheelScale;
             
    control.backStyleLight         = 'rgba(255, 255, 255, 0.95)';
    control.valueStyleLight        = '#7772';
    control.textStyleLight         = '#000';
                
    control.backStyleDark          = 'rgba(56, 56, 56, 0.95)';
    control.valueStyleDark         = '#ffffff20';
    control.textStyleDark          = '#eee';
                
    control.fontSize               = 11;
             
    control.style.display          = 'inline';
             
    control.mouseOver              = false;
    control.buttonDown0            = false;
    control.buttonDown1            = false;
             
    control.clickSize              = 4;
    control.moved                  = false;
         
    control.tabIndex               = 0;
    control.inFocus                = false;
    control.clicked                = false;
 
    control.startValue             = 0;
    control.oldValue; 
 
    control.wrapValue              = false;
     
    control.showName               = showName;
    control.showHex                = false;
         
    control.enableChangeEvent      = true;
    
    control.successOnFocusOut      = false;
    control.keyBlur                = false;
    
    control.pointerEvents          = true;
    control.readOnly               = false;
     
    control.valueText              = '';
     
    control.barTop                 = 0;
    control.barBottom              = 1;
     
    control.ranges                 = [];
    control.rangeDivs              = [];
     
    control.options                = []; // if dec == 0, show named choices instead of a value
 
     
    control.onstartchange          = new Event('startchange');
    control.onchange               = new Event('change');
    control.onconfirm              = new Event('confirm');


    initNumberControlChildren(control);    
    initNumberControlTextbox (control);
    initNumberControlEvents  (control);



    control.setName = function(name)
    {
        control.name = name;
        control.update();
    };



    control.setValue = function(value, fireChangeEvent = true, confirm = true, fullRange = true)
    {
        if (typeof value != 'number')
        {
            console.trace();
            console.assert(false, 'numberControl.setValue(value) is ' + typeof value + ', must be a number');
        }


        const oldValue = control.value;


        const dec = Math.pow(10, Math.abs(control.dec));

        //value = Math.round(value * dec) / dec;


        if (control.wrapValue)
        {
            while (value < control.displayMin) value += control.displayMax - control.displayMin;
            while (value > control.displayMax) value -= control.displayMax - control.displayMin;
        }
        else if (fullRange)
            value = Math.min(Math.max(control.min, value), control.max);
        else
            value = Math.min(Math.max(control.displayMin, value), control.displayMax);

            
        if (    isNaN(value) && !isNaN(oldValue)
            || !isNaN(value) &&  isNaN(oldValue)
            || Math.abs(value - oldValue) > Number.EPSILON)
        {
            control.value = value;

            control.update();

            if (   fireChangeEvent
                && control.enableChangeEvent
                && value != control.prevValue)
                control.dispatchEvent(control.onchange);

            if (   confirm
                && control.enableChangeEvent
                && value != oldValue)
                control.dispatchEvent(control.onconfirm);
        }
    };




    control.setSuffix = function(suffix, valueCanContainSuffix = false)
    {
        control.suffix                = suffix;
        control.valueCanContainSuffix = valueCanContainSuffix;
    };
    


    control.setMin = (min, dispatchEvents = true) =>
    {
        control.min        = min;
        control.displayMin = min;

        // if (control.value < min) 
        //     control.setValue(min, true, true, dispatchEvents);
    };



    control.setMax = (max, dispatchEvents = true) =>
    {
        control.max        = max;
        control.displayMax = max;

        // if (max < control.value) 
        //     control.setValue(max, true, true, dispatchEvents);
    };



    control.setDecimals = (dec, dspDec = dec) =>
    {
        control.dec        = dec;
        control.displayDec = dspDec;
    };



    control.update = function()
    {
        if (typeof control.value !== 'number')
            console.assert(false, 'numberControl.update() value is ' + typeof control.value + ', must be a number');


        const sx =  control.getOffsetLeft();
        const sw =  control.getClientWidth();
        const sh =  control.getClientHeight();

        const cx = -control.displayMin / (control.displayMax - control.displayMin) * sw;
        const v  =  control.value      / (control.displayMax - control.displayMin);

        control.updateBar(sx, cx, v, sw, sh);
        control.updateColors();
        control.updateText();
        control.updateFocus(sw, sh);
        
        updateControlRanges(control, sw, sh);


        control.cachedOffsetLeft   = null;
        control.cachedClientWidth  = null;
        control.cachedClientHeight = null;
    };



    control.updateBar = function(sx, cx, v, sw, sh)
    {
        if (control.dragReverse)
            v *= -1;

            
        if (isNaN(control.value))
            control.bar.style.display = 'none';

        else
        {
            control.bar.style.display = 'block';

            const x = 
                v >= 0
                ? cx
                : cx + v * sw;

            control.bar.style.left   = Math.max(0, x);
            control.bar.style.width  = Math.min(Math.max(0, Math.round(Math.abs(v) * sw) + Math.min(0, x)), control.offsetWidth);

            control.bar.style.top    = sh * control.barTop;
            control.bar.style.height = sh * (control.barBottom - control.barTop);
        }
    };



    control.updateColors = function()
    {
        control        .style.background = isDarkMode() ? control. backStyleDark : control. backStyleLight;
        control.bar    .style.background = isDarkMode() ? control.valueStyleDark : control.valueStyleLight;
        control.text   .style.color      = 
        control.textbox.style.color      = isDarkMode() ? control. textStyleDark : control. textStyleLight;
    };



    control.updateText = function()
    {
        control.text.innerHTML = '';
        
        if (   control.name.length > 0
            && control.showName)
        {
            const nameStyle = 
                isDarkMode() 
                ? rgba2style(rgb_a(style2rgba(control.textStyleDark),  0.4))
                : rgba2style(rgb_a(style2rgba(control.textStyleLight), 0.6));

            control.text.innerHTML += '<span style="color: '+nameStyle+';">' + control.name + "</span>&nbsp;&nbsp;";
        }
        
        control.text.innerHTML += control.getValueText() + control.suffix;
    };



    control.updateFocus = function(sw, sh)
    {
        control.focus.style.left   = 0;
        control.focus.style.top    = 0;
        control.focus.style.width  = sw;
        control.focus.style.height = sh;
    };



    control.getValueText = function()
    {
        if (   control.options.length > 0
            && control.displayDec == 0)
        {
            if (   control.value <  0 
                || control.value >= control.options.length)
                return DISPLAY_INVALID;
            else
                return control.options[Math.round(control.value)];
        }
        else if (control.valueText != '')
        {
            return control.valueText;
        }
        else
        {
            return isNaN(control.value)
                   ? DISPLAY_INVALID
                   : Math.abs(control.value * control.valueScale) > 999999
                     ? (control.value * control.valueScale).toExponential(1)
                     : numToString(
                           control.value * control.valueScale, 
                           control.displayDec, 
                           control.showHex
                       ).toUpperCase();
        }
    };



    control.lockPointer = function(pointerId)
    {
        clearTimeout(control.clickTimer);

        control.requestPointerLock =    
               control.      requestPointerLock 
            || control.   mozRequestPointerLock
            || control.webkitRequestPointerLock;

        control.requestPointerLock();
    };



    control.unlockPointer = function(pointerId)
    {
        document.exitPointerLock =    
               document.      exitPointerLock    
            || document.   mozExitPointerLock
            || document.webkitExitPointerLock;

        document.exitPointerLock();
    };



    control.isPointerLocked = function()
    {
        return (document.      pointerLockElement === control 
             || document.   mozPointerLockElement === control
             || document.webkitPointerLockElement === control);
    }



    control.getOffsetLeft   = () => control.cachedOffsetLeft   = control.cachedOffsetLeft   || control.offsetLeft;
    control.getClientWidth  = () => control.cachedClientWidth  = control.cachedClientWidth  || control.clientWidth;
    control.getClientHeight = () => control.cachedClientHeight = control.cachedClientHeight || control.clientHeight;
}


function initColorControlEvents(control)
{
    control.addEventListener('pointerdown', function(e)
    {
        if (graphView.spaceDown)
            return;

        if (e.button == 0)
        {
            if (!control.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let nodeDiv = 
                   control.parentNode
                && control.parentNode.parentNode
                && control.parentNode.parentNode.parentNode
                ? control.parentNode.parentNode.parentNode
                : null;

            if (nodeDiv && nodeDiv.className == 'node') 
                graphView.putNodeOnTop(nodeDiv.node);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();
                
            control.buttonDown0  = true;
            control.buttonDown0_ = true;
            control.moved        = false;
            control.clientX      = e.clientX;
            control.movedX       = 0;


            if (!control.readOnly)
            {
                control.oldValue   = control.value;
                control.startValue = control.value;
                control.prevValue  = control.value;
                control.sx         = e.clientX;

                control.clickTimer = setTimeout(() => 
                {
                    if (!document.menuHadFocus)
                    {
                        control.moved = true;
                        control.lockPointer(e.pointerId);
                    }
                }, 
                500);
            }


            if (   !control.param
                || !control.param.node.selected)
                control.focus.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand) inset';

            else
            {
                control.focus.style.boxShadow = '0 1px 0 0 var(--figma-color-bg-brand) inset';
                    
                if (control.param.index < control.param.node.params.length-1)
                    control.focus.style.boxShadow += ', 0 -1px 0 0 var(--figma-color-bg-brand) inset';
            }


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();


            if (control.param)
                control.param.noUpdate = true;  
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            control.buttonDown1 = true;
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            control.buttonDown2 = true;
        }
    });



    control.addEventListener('pointerenter', function(e)
    {
        if (   !graphView.spaceDown
            && control.pointerEvents)
        {
            // if (graphView.tempConn)
            //     control.style.cursor = 'default';
            
            // else
            //     control.style.cursor = 
            //            control.readOnly 
            //         || containsChild(control, control.textbox) 
            //         ? 'default'
            //         : 'ew-resize';

                    
            const colShadow = 
                isDarkMode()
                ? 'rgba(255, 255, 255, 0.1)'
                : 'rgba(0, 0, 0, 0.1)';

            if (control.param)
            {
                control.focus.style.boxShadow = '0  1px 0 0 ' + colShadow + ' inset';

                if (    control.param.node
                    &&  control.param.node.params.includes(control.param)
                    && !isLastInArray(control.param.node.params, control.param))
                    control.focus.style.boxShadow += ', 0 -1px 0 0 ' + colShadow + ' inset';
            }
            else
            {
                control.focus.style.boxShadow  = '0 0 0 1px ' + colShadow + ' inset ';
            }


            control.focus.style.visibility = 'visible';
            control.focus.style.opacity    = '100%';
    
            control.update();
        }
    });



    control.addEventListener('pointermove', e =>
    {
        if (!control.pointerEvents)
            return;
        

        let rect = boundingRect(control);
        
        control.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        control.clientX = e.clientX;

        
        if (    control.buttonDown0
            && !control.readOnly)
        {
            // if (control.isPointerLocked())
            // {
            //     control.movedX += e.movementX;
                
            //     if (!isNaN(control.value))
            //     {
            //         const dx       = control.movedX * (control.dragReverse ? -1 : 1);
            //         const adaptive = 10 * Math.pow(Math.abs(dx), control.acc);
            //         const grain    = Math.pow(10, -control.dec);
            //         const drag     = grain * sqr(control.dragScale);

            //         const val      = control.startValue + dx * drag * adaptive;

                    
            //         // reset control movement at the limits for better UX
            //         const min = getCtrlKey(e) ? control.min : control.displayMin;
            //         const max = getCtrlKey(e) ? control.max : control.displayMax;

            //         control.setValue(
            //             Math.round(val / grain) * grain, 
            //             true, 
            //             false);


            //         if (   val <= min
            //             || val >= max)
            //         {
            //             control.movedX     = 0;
            //             control.startValue = control.value;
            //             control.sx         = e.clientX;
            //         }


            //         if (control.value != control.prevValue)
            //             pushUpdateFromParam([control.param.node], control.param);

            //         control.prevValue = control.value;
            //     }
            // }
            // else
            // {
            //     if (Math.abs(e.clientX - control.sx) > control.clickSize/2)
            //     {
            //         control.moved = true;
            //         control.lockPointer(e.pointerId);

            //         control.dispatchEvent(control.onstartchange);
            //     }
            // }
        }
        else if (graphView.tempConn
              && control.param)
        {
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

            if (    graphView.tempConn.output
                &&  control.param.input
                &&  control.param.input.types.includes(graphView.tempConn.output.type)
                && !graphView.tempConn.output.node.isOrFollows(control.param.node)
                && (  !control.param.input.connected // not already connected to this input
                    || control.param.input.connectedOutput != graphView.tempConn.output
                    || control.param.input == savedInput))
            {
                graphView.overInput = control.param.input;
                    
                control.param.input.mouseOver = true;
                control.param.input.updateControl();

                const rect = boundingRect(control.param.input.control);

                graphView.tempConn.wire.inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - menuBar.offsetHeight);
            }
            else if ( graphView.tempConn.input
                  &&  control.param.output
                  &&  graphView.tempConn.input.types.includes(control.param.output.type)
                  && !control.param.node.isOrFollows(graphView.tempConn.input.node))
            {
                graphView.overOutput = control.param.output;
                    
                control.param.output.mouseOver = true;
                control.param.output.updateControl();


                const rect = boundingRect(control.param.output.control);

                graphView.tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - menuBar.offsetHeight);


                graphView.tempConn.input.updateControl();
            }
        }
        else if (control.readOnly)
        {
            control.moved = true;
        }
    });
    
    
    
    control.addEventListener('pointerleave', function(e)
    {
        control.style.cursor           = 'default';
        
        control.focus.style.visibility = 'hidden';
        control.focus.style.opacity    = 0;

        control.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != control.param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != control.param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    control.addEventListener('losecapture', function()
    {
        control.buttonDown0 = false;
        control.buttonDown1 = false;
        control.buttonDown2 = false;
        control.mouseOver   = false;
        control.update();
    });



    control.addEventListener('pointerup', function(e)
    {
        clearTimeout(control.clickTimer);


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(control.param.node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !control.param.node.isOrFollows(graphView.tempConn.input.node)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId);
                graphView.overOutput.endConnection();
            }
        }
        
        else if (   control.moved
            || document.menuHadFocus)
        {
            control.unlockPointer(e.pointerId);

            if (control.param)
                control.param.noUpdate = false;  

            return;            
        }

        else if (control.buttonDown0_)
        {
            control.clicked = true;
            control.showTextbox();
        }

             if (e.button == 0) control.buttonDown0 = false;
        else if (e.button == 1) control.buttonDown1 = false;
        else if (e.button == 2) control.buttonDown2 = false;

        control.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', function(e)
    {
        if (   e.button == 0 
            && control.buttonDown0)
        {
            control.buttonDown0 = false;
            control.unlockPointer(e.pointerId);

            control.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            // if (    control.value != control.oldValue
            //     && !control.readOnly)
            //     control.dispatchEvent(control.onconfirm);
        }
        // else if (   e.button == 1
        //     && control.buttonDown1)
        // {
        //     control.buttonDown1 = false;            
        // }
    });


    
    control.addEventListener('wheel', e =>
    {
        if (!control.pointerEvents)
            return;


        const isTouchpad = 
               Math.abs(e.deltaX) < 100
            && Math.abs(e.deltaY) < 100;


        if (isTouchpad)
        {
            e.preventDefault();
            return;
        }


        const dWheelX = e.deltaX /  20 * (control.dragReverse ? -1 : 1);
        const dWheelY = e.deltaY / 100 * (control.dragReverse ? -1 : 1);


        if (   !getCtrlKey(e)
            && !control.buttonDown1)
        {
            e.stopPropagation();

            if (!control.readOnly)
            {
                // if (   document.activeElement
                //     && document.activeElement.tagName.toLowerCase() == 'input'
                //     && document.activeElement.control)
                //     document.activeElement.control.textbox.finish(true, false);

                // control.oldValue = control.value;

                // const dec = Math.pow(10, -control.dec);

                // const val =
                //     isTouchpad
                //     ? control.value -  dWheelX               * control.wheelScale * dec
                //     : control.value + (dWheelY > 0 ? -1 : 1) * control.wheelScale * dec;
                
                // control.setValue(val, true, true, false, false);
            }
        }
    });



    // graphView.addEventListener('touchstart', e =>
    // {
    //     graphView.touches.push(e);
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchmove', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches[i] = e;
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchend', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.addEventListener('touchcancel', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    control.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            control.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    control.addEventListener('focus', function()
    {
        if (   !graphView.spaceDown
            && !control.buttonDown1
            && control.pointerEvents)
            control.showTextbox();
    });
}


function initColorControlTextbox(control)
{
    control.textbox = createTextbox('colorControlTextbox');
    control.textbox.control = control;
    


    control.textbox.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();
    });



    control.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();
        control.textbox.style.cursor = 'default';
    });



    control.textbox.addEventListener('focus', e =>
    {
        if (control.textbox.value == DISPLAY_INVALID)
            control.textbox.value = INVALID;
    });



    control.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !control.readOnly)
        {
            // let the OS do its thing here
        }
        
        else if (   (   e.code == 'Enter'
                     || e.code == 'NumpadEnter')
                 && !control.readOnly)
        {
            control.textbox.keyBlur = true;
            control.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            control.textbox.keyBlur = true;
            control.textbox.finish(false);
        }
        else if (e.code == 'Tab')
        {
            e.preventDefault();
            e.stopPropagation();
            
            if (control.param)
            {
                const params = control.param.node.params;
                let   index  = control.param.index;

                control.textbox.keyBlur = true;
                control.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (params[--index].control.readOnly);
                    params[index].control.showTextbox();
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (params[++index].control.readOnly);
                    params[index].control.showTextbox();
                }
            }
        }

        else if ((   e.key == 'ArrowUp'
                  || e.key == 'ArrowDown')
              && !control.readOnly)
        {
            e.preventDefault();

            // let text = control.textbox.value;

            if (   control.textbox.selectionStart == control.textbox.selectionEnd
                && control.textbox.selectionStart % 2 == 0)
                control.textbox.selectionStart--;

            const iStart =  Math.floor(control.textbox.selectionStart / 2);
            let   iEnd   =  Math.ceil (control.textbox.selectionEnd   / 2);

            if (iStart == iEnd) iEnd++;


            const rgb = scaleRgb(validHex2rgb(control.textbox.value));
            
            for (let i = iStart; i < iEnd; i++)
                rgb[i] = Math.min(Math.max(0, rgb[i] + (e.key == 'ArrowUp' ? 1 : -1)), 0xff);


            control.setValue(ColorValue.fromRgb(rgb));
            control.updateTextbox();


            control.textbox.selectionStart = iStart * 2;
            control.textbox.selectionEnd   = iEnd   * 2;

        }
        else 
        {
            let curVal = control.textbox.value;

            if (      e.key.length == 1
                   && e.key != '?'
                   && !isDigit(e.key)
                   && !isHexDigit(e.key)
                ||     control.readOnly
                   && !isArrowKey(e.code))
                e.preventDefault();

            curVal =
                curVal == INVALID
                ? ''
                :   curVal.substring(0, control.textbox.selectionStart) 
                  + curVal.substring(control.textbox.selectionEnd, curVal.length);

                  
            const nextVal = parseFloat(curVal + e.key);

            if (   nextVal < control.min - 0.001
                || nextVal > control.max)
                e.preventDefault();            
        }
    });



    control.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        const str = e.clipboardData.getData('text/plain');

        let val = 
            control.showHex
            ? parseInt(str, 16)
            : parseFloat(str);

        val = Math.min(Math.max(control.min, val), control.max);

        control.textbox.value = isNaN(val) ? '' : val;
    });



    control.textbox.addEventListener('focusout', function()
    {
        //console.log('control.successOnFocusOut', control.successOnFocusOut);

        if (!control.textbox.keyBlur) control.textbox.finish(true);
        else                          control.textbox.keyBlur = false;

        if (control.savedSuccessOnFocusOut != null)
        {
            control.successOnFocusOut      = control.savedSuccessOnFocusOut;
            control.savedSuccessOnFocusOut = null;
        }

        control.parentNode.removeChild(control.textbox);
        control.clicked = false;
    });
    


    control.textbox.finish = function(success, focusControl = true)
    {
        let   value      = control.textbox.value;
        const savedValue = control.textbox.savedValue;

        let rgb      = validHex2rgb(value     );
        let savedRgb = validHex2rgb(savedValue);

        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           value,
            'oldValue':        savedValue,
            'preventSetValue': false }});

        control.dispatchEvent(e);

        
        if (!e.preventSetValue)
        {
            if (success) 
            {
                control.setValue(
                      value.trim() != '' 
                    ? ColorValue.fromRgb(scaleRgb(rgb     )) 
                    : ColorValue.fromRgb(scaleRgb(savedRgb)));
            }
            else
                control.setValue(ColorValue.fromRgb(scaleRgb(savedRgb)));
        }
         
        
        control.textbox.blur();

        control.text.style.display = 'block';

        if (   control.inFocus
            && focusControl)
            control.focus();
    };    
    
    

    control.showTextbox = function()
    {
        control.text.style.display = 'none';

        control.inFocus = 
               hasFocus(control)
            && !control.clicked;
    
        // control.textbox.style.position  = 'absolute';
        // control.textbox.style.left      = '50%';
        // control.textbox.style.transform = 'translate(-50%)';
        // control.textbox.style.top       = control.offsetTop    + 1;
        // control.textbox.style.width     = control.offsetWidth  - 2;
        // control.textbox.style.height    = control.offsetHeight - 2;
        control.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
        control.textbox.style.outline   = 'none';
        control.textbox.style.textAlign = 'center';

        const isConnected =    
               control.param != null
            && control.param.input
            && control.param.input.connected;

        // enableElementText(
        //     control.textbox, 
        //        !control.readOnly
        //     && !isConnected);

        control.updateTextbox();
        
        control.parentNode.appendChild(control.textbox);
        
        control.textbox.focus();
        control.textbox.select();

        control.textbox.style.cursor = 'default';
    }



    control.updateTextbox = function()
    {
        const rgb = control.value.toRgb();

        control.textbox.value =
            !control.value.isValid()
            ? DISPLAY_INVALID
            : rgb2hex(rgb).toUpperCase();
                           
        control.textbox.savedValue  = control.textbox.value;
        //control.textbox.style.color = control.text.style.color;
    };
}


function initColorControlChildren(control)
{
    control.text  = createDiv('colorControlText');
    control.focus = createDiv('colorControlFocus');

    control.appendChild(control.text);
    control.appendChild(control.focus);
}



function initColorControl(param, control, width, height, id, name, showName, defaultValue, dragScale = 0.05, wheelScale = 1, acc = 0)
{
    control.param                  = param;
     
    control.className              = 'colorControl';
     
    control.width                  = width;
    control.height                 = height;
             
    control.style.width            = width;
    control.style.height           = height;
             
    control.showColor              = true;

    control.value                  = defaultValue;
    control.acc                    = acc;
     
    control.id                     = id;
    control.name                   = name;
     
    control.dragReverse            = false;
    control.dragScale              = dragScale;
    control.wheelScale             = wheelScale;
             
    control.backStyleLight         = 'rgba(255, 255, 255, 0.95)';
    control.valueStyleLight        = 'transparent';
    control.textStyleLight         = '#000';
                
    control.backStyleDark          = 'rgba(56, 56, 56, 0.95)';
    control.valueStyleDark         = 'transparent';
    control.textStyleDark          = '#eee';

    control.fontSize               = 11;
             
    control.style.display          = 'inline';
             
    control.mouseOver              = false;
    control.buttonDown0            = false;
    control.buttonDown1            = false;
             
    control.clickSize              = 4;
    control.moved                  = false;
         
    control.tabIndex               = 0;
    control.inFocus                = false;
    control.clicked                = false;
 
    control.startValue             = 0;
    control.oldValue; 
 
    control.wrapValue              = false;
     
    control.showName               = showName;
    control.showHex                = false;
         
    control.enableChangeEvent      = true;
    
    control.successOnFocusOut      = false;
    control.keyBlur                = false;
    
    control.pointerEvents          = true;
    control.readOnly               = false;
     
    control.valueText              = '';
     
    control.onstartchange          = new Event('startchange');
    control.onchange               = new Event('change');
    control.onconfirm              = new Event('confirm');


    initColorControlChildren(control);    
    initColorControlTextbox (control);
    initColorControlEvents  (control);



    control.setName = function(name)
    {
        control.name = name;
        control.update();
    };



    control.setValue = function(value, fireChangeEvent = true, confirm = true)
    {
        if (!(value instanceof ColorValue))
        {
            console.trace();
            console.assert(false, 'colorControl.setValue(value) is ' + typeof value + ', must be a ColorValue');
        }


        const oldValue = control.value.copy();

        control.value = value.copy();


        if (control.showColor)
        {
            const rgb = control.value.toRgb();

            if (!rgbIsNaN(rgb))
            {
                control.valueStyleLight =
                control.valueStyleDark  = rgb2style(rgb);

                control.textStyleLight  = 
                control.textStyleDark   = rgba2style(getTextColorFromBackColor(rgb));
            }
            else
            {
                control.valueStyleLight =
                control.valueStyleDark  = 'transparent';
                
                control. textStyleLight = 'black';
                control. textStyleDark  = 'white';
            }
        }
        // else
        // {
        //     control.textStyleDark = '#000';
        //     control.textStyleDark = '#fff';
        // }


        control.update();


        if (   fireChangeEvent
            && control.enableChangeEvent
            && !value.equals(control.prevValue))
            control.dispatchEvent(control.onchange);

        if (   confirm
            && control.enableChangeEvent
            && !value.equals(oldValue))
            control.dispatchEvent(control.onconfirm);
    };




    control.update = function()
    {
        const sw = control.getClientWidth();
        const sh = control.getClientHeight();


        control.updateColors();
        control.updateText();
        control.updateFocus(sw, sh);
        

        control.cachedOffsetLeft   = null;
        control.cachedClientWidth  = null;
        control.cachedClientHeight = null;
    };



    control.updateColors = function()
    {
        control.style.background = 
            control.showColor
            ? (isDarkMode() 
               ? control.valueStyleDark 
               : control.valueStyleLight)
            : (isDarkMode() 
               ? control.backStyleDark 
               : control.backStyleLight);

        control.text   .style.color = 
        control.textbox.style.color = 
            isDarkMode() 
            ? control.textStyleDark 
            : control.textStyleLight;
    };



    control.updateText = function()
    {
        control.text.innerHTML = '';
        
        if (   control.name.length > 0
            && control.showName)
            control.text.innerHTML += (control.name.trim() != '' ? '<span class="colorControlName">' + control.name + '</span>&nbsp;&nbsp;' : '');

        control.text.innerHTML += 
               control.value.isValid()
            && rgbIsValid(control.value.toRgb())
            ? rgb2hex(control.value.toRgb())
            : DISPLAY_INVALID;
    };



    control.updateFocus = function(sw, sh)
    {
        control.focus.style.left   = 0;
        control.focus.style.top    = 0;
        control.focus.style.width  = sw;
        control.focus.style.height = sh;
    };



    control.lockPointer = function(pointerId)
    {
        clearTimeout(control.clickTimer);

        control.requestPointerLock =    
               control.      requestPointerLock 
            || control.   mozRequestPointerLock
            || control.webkitRequestPointerLock;

        control.requestPointerLock();
    };



    control.unlockPointer = function(pointerId)
    {
        document.exitPointerLock =    
               document.      exitPointerLock    
            || document.   mozExitPointerLock
            || document.webkitExitPointerLock;

        document.exitPointerLock();
    };



    control.isPointerLocked = function()
    {
        return (document.      pointerLockElement === control 
             || document.   mozPointerLockElement === control
             || document.webkitPointerLockElement === control);
    }



    control.getOffsetLeft   = () => control.cachedOffsetLeft   = control.cachedOffsetLeft   || control.offsetLeft;
    control.getClientWidth  = () => control.cachedClientWidth  = control.cachedClientWidth  || control.clientWidth;
    control.getClientHeight = () => control.cachedClientHeight = control.cachedClientHeight || control.clientHeight;
}


function initSelectMenu(select)
{
    select.menu = createDiv('selectMenu');

    select.menu.hoverIndex       =  0;
    select.menu.tabIndex         =  0;

    select.menu.style.left       =  select.offsetLeft;
    select.menu.style.height     = 'auto';
    select.menu.style.textAlign  = 'center';
    select.menu.style.background = '#222';
    select.menu.style.zIndex     =  MAX_INT32-3;
    


    select.menu.addEventListener('focus', function() { select.menu.style.outline = 'none'; });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });        
    

    
    select.menu.tabIndex   = 0;
    
    select.menu.hoverIndex = 0;


    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = 'calc(100% + 1px)';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = 'var(--figma-color-bg-brand)';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = -1; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();
        select.dispatchChangeEvent();
        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initSelect(select, items)
{
    select.className = 'menuSelect';
    select.tabIndex = 0;    
    
    initSelectMenu(select);

    select.holding  = false;
    

    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function()
    {
        select.resetMenu();
        
        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            if (select.items[i].value == '-')
            {
                item.style.borderTop = '1px solid white';
                item.style.marginTop = '6px';
                item.style.height    = '4px';
                item.style.position  = 'relative';
                item.style.left      = '6px';
                
                item.disabled = true;
            }
            else
            {
                item.style.border = 'none';
                item.style.height = 24;

                item.disabled = false;

                sub.innerHTML = select.items[i].text;
            }

            item.appendChild(sub);
            select.menuWrap.appendChild(item);
        }


        let options = select.getElementsByTagName('option');

        for (const node of options) 
            node.disabled = node.value == '-';
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();
            
            select.buttonDown0 = true;        
            select.setPointerCapture(e.pointerId);
            
            select.holding = false;
            setTimeout(function() { onSelectClickTimer(select); }, 200);
            
            select.menu.hoverIndex = select.getSelectedIndex();

            select.showMenu();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        let menuTop =
            select.offsetTop 
            - 3 // paddingTop
            - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
            - iy * 24;
        
        menuTop = Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
        iy = Math.min(Math.max(0, iy), select.items.length-1);
        return iy;
    };        
    

    
    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    }



    select.dispatchChangeEvent = function()
    {
        const onchange = new Event('change', 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        });

        select.dispatchEvent(onchange);
    };


    //////////////////////////////////////////////////////////////////////////////////

    
    select.items = items;
    
    select.update(0);
    select.updateItems();
}



function onSelectClickTimer(select)
{
    select.holding = true;
}


function initMenuSelectMenu(select)
{
    select.menu = createDiv('menuSelectMenu');

    select.menu.hoverIndex   = 0;
    select.menu.tabIndex     = 0;

    select.menu.style.left   = select.offsetLeft;
    select.menu.style.zIndex = MAX_INT32;

    select.menu.addEventListener('focus', function() 
    {
         select.menu.style.outline = 'none'; 
    });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });
    
    

    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = '100%';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = 'var(--figma-color-bg-brand)';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = 0; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();

        const onchange = new CustomEvent('change', { detail: 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        }});

        select.dispatchEvent(onchange);

        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initMenuSelectTextbox(select)
{
    select.textbox = createTextbox('menuSelectText');
    
    
    select.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            select.textbox.finish(true);

        else if (e.code == 'Escape')
            select.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            let tabs  = document.querySelectorAll('.control, .menuSelect, .select, button, .menuButton');
            let index = select.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && select.min < 0))
                e.preventDefault();

            let t = select.textbox;

            let curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            let nextVal = parseFloat(curVal + e.key);

            if (   nextVal < select.min - 0.001
                || nextVal > select.max)
                e.preventDefault();            
        }
    });


    // control.textbox.addEventListener('input', function()
    // {
    //     control.setValue(Number(control.textbox.value));
    // });


    select.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        let val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(select.min, val), select.max);

        select.textbox.value = isNaN(val) ? '' : val;
    });


    select.textbox.addEventListener('focusout', function()
    {
        select.parentNode.removeChild(select.textbox);
        select.clicked = false;
    });
    

    select.textbox.finish = function(success)
    {
        if (success) select.setValue(Number(select.textbox.value     ));
        else         select.setValue(Number(select.textbox.savedValue));

        select.textbox.blur();

        if (select.inFocus)
            select.focus();
    };    
    
    
    select.showTextbox = function()
    {
        select.inFocus = 
               hasFocus(select)
            && !select.clicked;
    
        // select.textbox.style.position = 'absolute';
    
        // select.textbox.style.left      = select.offsetLeft   + 1;
        // select.textbox.style.top       = select.offsetTop    + 1;
        // select.textbox.style.width     = select.offsetWidth  - 2;
        // select.textbox.style.height    = select.offsetHeight - 2;
        select.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
        select.textbox.style.outline   = 'none';
    
        select.textbox.style.textAlign = 'center';
    
        select.textbox.value = numToString(select.value, select.dec);
        select.textbox.savedValue = select.textbox.value;
        
        select.parentNode.appendChild(select.textbox);
        
        select.textbox.focus();
        select.textbox.select();
    }
}


function initMenuSelect(select)
{
    select.className = 'menuSelect';
    select.tabIndex  = 0;    
    
    initMenuSelectMenu   (select);
    initMenuSelectTextbox(select);

    select.holding = false;

    select.enableChangeEvent = true;


    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function(items)
    {
        select.resetMenu();
        
        
        select.items = items;
        select.update(0);


        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            item.style.border      = 'none';
            item.style.height      = 24;

            item.disabled = false;

            sub.innerHTML = select.items[i].text;

            item.appendChild(sub);

            select.menuWrap.appendChild(item);
        }
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();

            var rect = boundingRect(select);

            if (e.clientX > rect.width - 20)
            {
                select.buttonDown0 = true;        
                select.setPointerCapture(e.pointerId);
                
                select.holding = false;
                setTimeout(function() { onSelectClickTimer(select); }, 200);
                
                select.menu.hoverIndex = select.getSelectedIndex();

                select.showMenu();
            }
            else
                select.showTextbox();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        // let menuTop =
        //     select.offsetTop; 
        //     - 3 // paddingTop
        //     - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
        //     - iy * 24;
        
        menuTop = select.offsetTop + select.offsetHeight + 11;//Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
            iy = Math.min(Math.max(0, iy), select.items.length-1);

        return iy;
    };        
    

    
    select.getSelectedValue = function()
    {
        return select.items[select.getSelectedIndex()].value;
    };        



    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    };



    select.setSelectedIndex = function(index)
    {
        select.value = select.items[index].value;
        select.update(select.getSelectedIndex());
        
        select.enableChangeEvent = false;
        select.dispatchChangeEvent();
        select.enableChangeEvent = true;
    };



    select.dispatchChangeEvent = function()
    {
        if (!select.enableChangeEvent)
            return;
    
        let index = select.getSelectedIndex();
    
        const onchange = new Event('change', 
        {
            selectedIndex: index,
            selectedValue: select.items[index].value
        });

        select.dispatchEvent(onchange);
    };
}



graphView.wires           = [];
 
graphView.loadingNodes    = false;
graphView.canUpdateNodes  = true;


graphView.activeNodes     = [];


graphView.overNode        = null;
graphView.overInput       = null;
graphView.overOutput      = null;
    
graphView.headerInput     = null; // same as overInput, but when snapping from a header
graphView.headerOutput    = null; // same as overOutput, but when snapping from a header
    
graphView.tempConn        = null;
graphView.savedConn       = null;
graphView.savedInputIndex = -1;

graphView.connPointerId   = -1;

graphView._soloNode       = null;
   
graphView.selecting       = false;
graphView.selectionRect   = Rect.NaN;

graphView.btn1down        = false; // this is to help deal with mouse wheels that send X values as
                                   // sometimes a MMB press is followed by wheelX as a "deeper" middle-click

graphView.pan             = point(0, 0);
graphView.zoom            = 1;
 
graphView.panning         = false;
 
graphView.pViewport; 
graphView.pStart          = point(0, 0);
graphView.zoomStart;


scrollbarX.style.zIndex   = MAX_INT32-1;
scrollbarY.style.zIndex   = MAX_INT32-2;


graphView.touches         = [];



graphView.getAllNodeBounds = function()
{
    let bounds = Rect.NaN;

    for (const node of graph.nodes)
        bounds = expandRect(bounds, boundingRect(node.div));

    return bounds;
};



graphView.getNodeBounds = node =>
{
    const bounds = boundingRect(node.div);

    return new Rect(
        parseFloat(node.div.style.left ),
        parseFloat(node.div.style.top  ),
        parseFloat(node.div.style.width),
        bounds.h / graphView.zoom); // node height isn't defined
}



graphView.getZoomedNodeBounds = node =>
{
    const bounds = graphView.getNodeBounds(node);

    bounds.x += graphView.pan.x / graphView.zoom;
    bounds.y += graphView.pan.y / graphView.zoom;
    bounds.w /= graphView.zoom;
    bounds.h /= graphView.zoom;

    return bounds;
};



graphView.getIntersectingNodes = node =>
{
    const nodeBounds = graphView.getZoomedNodeBounds(node);

    const intersecting = [];
    
    for (const n of graph.nodes)
    {
        const nBounds = graphView.getZoomedNodeBounds(n);
        
        if (   n != node
            && rectsIntersect(nBounds, nodeBounds))
        {
            intersecting.push(n);
        }
    }

    return intersecting;
}



graphView.placeNewNode = function(node)
{
    //console.log('graphView.placeNewNode()');

    const nodeRect = boundingRect(node.div);
    
    const btn = node._creatingButton;

    if (btn)
    {
        node.div.style.left = (btn.offsetLeft + btn.offsetWidth/2 - graphView.pan.x) / graphView.zoom - nodeRect.width/2;
        node.div.style.top  = (20 - graphView.pan.y) / graphView.zoom;
    }
    else
    {
        node.div.style.left = (graphView.offsetWidth /2 - graphView.pan.x                          ) / graphView.zoom - nodeRect.width/2;
        node.div.style.top  = (graphView.offsetHeight/2 - graphView.pan.y - menuBar.offsetHeight) / graphView.zoom - nodeRect.height/2;
    }


    // const nodeRect = boundingRect(node.div);

    // const defx = (graphView.offsetWidth /2 - graphView.pan.x) / graphView.zoom - nodeRect.width /2,
    //       defy = (graphView.offsetHeight/2 - graphView.pan.y - menuBar.offsetHeight) / graphView.zoom - nodeRect.height/2;

    // node.div.style.left = (graphView.offsetWidth  / 6 - graphView.pan.x) / graphView.zoom;
    // node.div.style.top  = (graphView.offsetHeight / 4 - graphView.pan.y) / graphView.zoom;


    // const dx = 30,
    //       dy = 20;

    // let   ox = defx,
    //       oy = defy;

        
    // let maxIter = 100; // stack overflow safeguard
    
    // let intersecting;
    // while (   maxIter-- > 0
    //        && (intersecting = graphView.getIntersectingNodes(node)).length > 0)
    // {
    //     let bounds = Rect.NaN;
        
    //     for (const n of intersecting)
    //         bounds = expandRect(bounds, graphView.getNodeBounds(n));

    //     const right = intersecting.reduce((a, b) => 
    //         graphView.getNodeBounds(a).r > graphView.getNodeBounds(b).r ? a : b);

    //     if (   right.type == node.type
    //         && node.type != 'color'
    //         && node.type != 'webcontrast') ox = bounds.b + dy;
    //     else                                 oy = bounds.r + dx;
    // }

    
    // const margin = 100;

    // node.div.style.left = (ox > margin && ox < window.clientWidth  - margin) ? ox : defx;
    // node.div.style.top  = (oy > margin && oy < window.clientHeight - margin) ? oy : defy;
};



graphView.putNodeOnTop = function(node)
{
    const topIndices = 
          1 
        + node.inputs.filter(i => i.connected).length 
        + (node.outputs.find(o => o.connected) ? 1 : 0);
        
    for (const n of graph.nodes)
        n.div.style.zIndex = Math.max(0, Number(n.div.style.zIndex) - topIndices);
        
    node.div.style.zIndex = MAX_INT32-3; // -3 is for scrollbars;

    graphView.putWiresOnTop(node);
};



graphView.putWiresOnTop = function(node)
{
    // changing z-index doesn't work so easily with SVG,
    // so reinsert the wires on top instead 

    let z = MAX_INT32;

    for (const input of node.inputs.filter(i => i.connected))
    {
        wireContainer.removeChild(input.connection.wire);
        wireContainer.appendChild(input.connection.wire);
    }
        
    for (const output of node.outputs)
    {
        for (const connInput of output.connectedInputs)
        {
            wireContainer.removeChild(connInput.connection.wire);
            wireContainer.appendChild(connInput.connection.wire);
        }
    }
};



graphView.updateNodeTransforms = function(nodes, _updateWires = true)
{
    const nodeLeft = nodes.map(n => n.div.offsetLeft);
    const nodeTop  = nodes.map(n => n.div.offsetTop);
    const nodeRect = nodes.map(n => graphView.getNodeOffsetRect(n.div));
    

    const wires = [];

    for (const node of nodes)
    {
        for (const input of node.inputs)
            if (   input.connected
                && input.connection
                && !wires.includes(input.connection.wire))
                wires.push(input.connection.wire);        

        for (const output of node.outputs)
            for (const connInput of output.connectedInputs)
                if (   connInput.connection
                    && !wires.includes(connInput.connection.wire))
                    wires.push(connInput.connection.wire);
    }


    for (let i = 0; i < nodes.length; i++)
        graphView.setNodeTransform(nodes[i], nodeLeft[i], nodeTop[i], nodeRect[i]);


    if (_updateWires)
        updateWires(wires);
};



graphView.updateNodeTransform = function(node)
{
    const nodeLeft = node.div.offsetLeft;
    const nodeTop  = node.div.offsetTop;
    const nodeRect = graphView.getNodeOffsetRect(node.div);
    

    const wires = [];

    for (const input of node.inputs)
        if (   input.connected
            && input.connection)
            wires.push(input.connection.wire);        

    for (const output of node.outputs)
        for (const connInput of output.connectedInputs)
            if (connInput.connection)
                wires.push(connInput.connection.wire);


    graphView.setNodeTransform(node, nodeLeft, nodeTop, nodeRect);

    updateWires(wires);
};



graphView.setNodeTransform = function(node, nodeLeft, nodeTop, nodeRect)
{
    node.div.style.transform =
          'translate(' 
        + (graphView.pan.x * graphView.zoom) + 'px, '  
        + (graphView.pan.y * graphView.zoom) + 'px) '
        + 'scale(' + graphView.zoom + ')';
    
    node.div.style.transformOrigin = 
          ((graphView.pan.x - nodeLeft) / nodeRect.width  * 100) + '% ' 
        + ((graphView.pan.y - nodeTop ) / nodeRect.height * 100) + '%';  
};



graphView.getNodeOffsetRect = function(node)
{
    const ox   = -graphView.pan.x / graphView.zoom;
    const oy   = -graphView.pan.y / graphView.zoom;

    const rect = boundingRect(node);

    return new DOMRect(
        ox + (rect.left / graphView.zoom),
        oy + (rect.top  / graphView.zoom), 
        rect.width      / graphView.zoom, 
        rect.height     / graphView.zoom);
};



graphView.soloNode = function(node)
{
    graphView._soloNode = node;

    graph.nodes.forEach(n => 
        n.div.style.opacity = 
            graphView._soloNode == n 
            ? 1 
            : 0.12);

    graph.connections.forEach(c =>
    { 
        c.wire.style.opacity = 
               c.input  && graphView._soloNode == c.input .node
            || c.output && graphView._soloNode == c.output.node
            ? 1 
            : 0.09;
    });

    updateWires(graph.connections.map(c => c.wire));
};



graphView.unsoloNode = function()
{
    graphView._soloNode = null;

    graph.nodes.forEach(n => n.div .style.opacity = 1);

    graph.connections.forEach(c => c.wire.style.opacity = 1);
    updateWires(graph.connections.map(c => c.wire));
};



graphView.updateShowWires = function(updateNodes = true)
{
    graph.connections.forEach(c => show(c.wire, settings.showWires));

    if (updateNodes) 
        graph.nodes.forEach(n => n.updateNode());
};



graphView.toJson = function()
{
    const tab = '\n' + TAB;

    return '{'
        + tab + '"zoom": "'      + graphView.zoom  + '",'
        + tab + '"panx": "'      + graphView.pan.x + '",'
        + tab + '"pany": "'      + graphView.pan.y + '"'
        + '\n}';
};


graphView.addEventListener('pointerenter', e => 
{
    if (    graphView.hasPointerCapture(e.pointerId)
        && !graphView.tempConn)
        graphView.releasePointerCapture(e.pointerId);
});



graphView.addEventListener('pointerleave', e => 
{
    if (graphView.tempConn)
        graphView.setPointerCapture(e.pointerId);
});



graphView.addEventListener('pointerdown', e =>
{
    //e.preventDefault();
    
    graphView.pStart = point(e.clientX, e.clientY);

    const sx = e.clientX;
    const sy = e.clientY;

    if (   e.button == 0                 
        && !graphView.panning
        && !document.canResizeX
        && !document.canResizeY
        && !scrollbarX.moving
        && !scrollbarY.moving)
    {
        if (   graphView.spaceDown
            || panMode)
        {
            if (getCtrlKey(e)) graphView.startZoomSelection(e.pointerId, e.clientX, e.clientY);
            else               graphView.startPan(e.pointerId);
        }
        else if (graphView.overOutput)
        {
            graphView.overOutput.connecting = true;
            graphView.startConnectionFromOutput(e.pointerId, graphView.overOutput);
            updateWire(graphView.tempConn.wire, sx, sy);
        }
        else if (graphView.overInput)
        {
            if (graphView.overInput.connectedOutput) // pretend to disconnect
            {
                oldReorderIndex = graphView.overInput.index;

                graphView.startConnectionFromOutput(e.pointerId, graphView.overInput.connectedOutput, false);
                updateWire(graphView.tempConn.wire, sx, sy);
                
                graphView.savedConn       = graphView.overInput.connection;
                graphView.savedInputIndex = graphView.overInput.index;

                hide(graphView.savedConn.wire);
            }
            else
            {
                graphView.overInput.connecting = true;
                graphView.startConnectionFromInput(e.pointerId, graphView.overInput);
                updateWire(graphView.tempConn.wire, sx, sy);
            }
        }
        else if (document.activeElement.type != 'text') // selection, unless a textbox is in focus
        {
            graphView.lastSelectedNodes = [...graphView.selectedNodes];

            graphView.startSelection(
                e.pointerId, 
                e.clientX, 
                e.clientY, 
                e.shiftKey,
                getCtrlKey(e));
        }
    }
    
    else if (e.button == 1)
    {
        graphView.btn1down = true;
        setCursor(panCursor);
        graphView.startPan(e.pointerId);
    }
});



graphView.addEventListener('pointermove', graphView_onpointermove);



function graphView_onpointermove(e)
{
    graphView.p = point(e.clientX, e.clientY);


    if (   (   graphView.panning
            || panMode)
        && graphView.hasPointerCapture(e.pointerId))
    {
        // TODO this is where the last extra pan step probably comes from on complicated graphs
        //setTimeout(() =>
        //{
            setCursor(panCursor);

            const dp = subv(graphView.p, graphView.pStart);

            graphView.setPanAndZoom(
                addv(graphView.panStart, dp), 
                graphView.zoom);
        //});
    }
    
    else if (graphView.selecting)
        graphView.updateSelection(e.clientX, e.clientY, e.shiftKey, getCtrlKey(e));
    
    else if (graphView.zoomSelecting)
        graphView.updateZoomSelection(e.clientX, e.clientY);
    
    else if (graphView.tempConn)
    {
        updateWire(
            graphView.tempConn.wire, 
            e.clientX, 
            e.clientY);
    }
}



graphView.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && (   graphView.spaceDown
            || panMode))
    {
        if (getCtrlKey(e))
        {
            if (   graphView.selectionRect.w > 0
                && graphView.selectionRect.h > 0)
            {
                graphView.endZoomSelection(e.pointerId, true);
            }
            else
            {
                graphView.endZoomSelection(e.pointerId, false);

                graphView.oldZoom = graphView.zoom;

                if (e.altKey) graphView.zoom /= 2;
                else          graphView.zoom *= 2;

                graphView.pan = subv(
                    graphView.pan, 
                    mulvs(
                        subv(
                            point(e.clientX, e.clientY), 
                            graphView.pan), 
                        graphView.zoom / graphView.oldZoom - 1));
            }
        }
        
        graphView.endPan(e.pointerId, false);
    }

    else if (e.button == 0
         && !graphView.selectionRect.isNaN)
        graphView.endSelection(e.pointerId);

    else if (e.button == 0
          && graphView.tempConn)
        graphView.endConnection(e.pointerId);

    else if (e.button == 1
          && graphView.panning)
    {
        graphView.btn1down = false;
        graphView.endPan(e.pointerId, true);
    }
});



graphView.addEventListener('wheel', e =>
{
    if (graphView.btn1down)
        return;


    e.preventDefault();


    const dZoom = Math.log(graphView.zoom) / Math.log(2);


    const isTouchpad = 
           Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;


    const dWheelX = e.deltaX / (isTouchpad ? 20 : 100);
    const dWheelY = e.deltaY / (isTouchpad ? 20 : 100);


    if (   e.ctrlKey
        || panMode)
    {
        let pos = point(e.clientX, e.clientY);
        pos.y -= menuBar.offsetHeight;

        const zoom = Math.max(0.0001, Math.pow(2, dZoom - dWheelY / (isTouchpad ? 5 : 10)));
        const pan  = subv(graphView.pan, mulvs(subv(pos, graphView.pan), zoom / graphView.zoom - 1));

        graphView.setPanAndZoom(pan, zoom);
    }
    else
    {
        const dPanX = (e.shiftKey ? dWheelY : dWheelX) * 20 / Math.pow(graphView.zoom, 0.1);
        const dPanY = (e.shiftKey ? dWheelX : dWheelY) * 20 / Math.pow(graphView.zoom, 0.1);

        graphView.pan = point(
            graphView.pan.x - dPanX,
            graphView.pan.y - dPanY);

        if (graphView.selecting)
        {
            graphView.selectionRect.x -= dPanX;
            graphView.selectionRect.w += dPanX;
            
            graphView.selectionRect.y -= dPanY;
            graphView.selectionRect.h += dPanY;

            graphView.updateSelection(
                e.clientX, 
                e.clientY, 
                e.shiftKey);
        }
    }


    if (graphView.tempConn)
        graphView_onpointermove(e);
});



graphView.addEventListener('gesturestart', e => { graphView.zoomStart = graphView.zoom; });



graphView.addEventListener('gesturechange', e => 
{
    const p = point(
        graphView.p.x,
        graphView.p.y - menuBar.offsetHeight);

    const zoom = graphView.zoomStart * e.scale;
    const pan  = subv(graphView.pan, mulvs(subv(p, graphView.pan), zoom / graphView.zoom - 1));

    graphView.setPanAndZoom(pan, zoom);
});



graphView.addEventListener('touchstart', e =>
{
    graphView.touches.push(e);
    e.preventDefault();
});



graphView.addEventListener('touchmove', e =>
{
    for (let i = 0; i < graphView.touches.length; i++)
        if (graphView.touches[i].pointerId == e.pointerId)
        {
            graphView.touches[i] = e;
            break;
        }

    e.preventDefault();
});



graphView.addEventListener('touchend', e =>
{
    for (let i = 0; i < graphView.touches.length; i++)
        if (graphView.touches[i].pointerId == e.pointerId)
        {
            graphView.touches.splice(i, 1);
            break;
        }

    e.preventDefault();
});



graphView.addEventListener('touchcancel', e =>
{
    for (let i = 0; i < graphView.touches.length; i++)
        if (graphView.touches[i].pointerId == e.pointerId)
        {
            graphView.touches.splice(i, 1);
            break;
        }

    e.preventDefault();
});


graphView._pan = point(0, 0);
  
Object.defineProperty(graphView, 'pan',
{
    get: () => graphView._pan,
    set: pan =>
    {
        if (graphView._pan == pan) return;

        graphView._pan = pan;
        
        uiSaveGraphView();
        graphView.updatePanAndZoom();
    }
});



graphView.panning = false;
graphView.panStart;

graphView.spaceDown = false;


graphView._zoom   = 1;
graphView.oldZoom = 1;

Object.defineProperty(graphView, 'zoom',
{
    get: () => graphView._zoom,
    set: zoom =>
    {
        if (graphView._zoom == zoom) return;

        let pos = point(
            window.innerWidth /2,
            window.innerHeight/2);

        pos.y -= menuBar.offsetHeight;

        const pan = subv(graphView.pan, mulvs(subv(pos, graphView.pan), zoom / graphView.zoom - 1));

        graphView.setPanAndZoom(pan, zoom);
    }
});



graphView.zooming   = false;
graphView.zoomStart = 1;

graphView.zoomSelecting = false;



graphView.setPanAndZoom = (pan, zoom) =>
{
    if ((   pan  != graphView._pan
         || zoom != graphView._zoom)
        && zoom >=  0.02
        && zoom <= 50   ) 
    {
        graphView.oldZoom = graphView.zoom;

        graphView._zoom = zoom;
        graphView._pan  = pan;

        graphView.updatePanAndZoom();

        uiSaveGraphView();
    }
};



graphView.updatePanAndZoom = () =>
{
    graphView.update(graph.nodes);

    btnZoom.divIcon.innerHTML       = Math.round(graphView.zoom * 100) + '%';
    btnZoom.divIcon.style.transform = 'translateX(2px) translateY(-16px)';

    menuItemZoomTo100.setChecked(equal(graphView.zoom, 1));
};



graphView.update = function(nodes = null)
{
    if (!nodes)
        node = graph.nodes;
        
    graphView.updateNodeTransforms(nodes, false);
    
    const x       = graphView.clientLeft;
    const w       = graphView.clientWidth;
    const h       = graphView.clientHeight;
    const yOffset = menuBar.offsetHeight;
    //let   bounds  = graphView.getAllNodeBounds();
    
    graphView.updateNodeTransforms(nodes); // this has to be done twice //because getAllNodeBounds() forces a reflow

    const bounds = graphView.getAllNodeBounds();
    graphView.updateScroll(x, w, h, bounds, yOffset);
};



graphView.startPan = pointerId =>
{
    graphView.panning  = true;
    graphView.panStart = graphView.pan;
    graphView.setPointerCapture(pointerId);
    setCursor(panCursor);
};



graphView.endPan = (pointerId, changeCursor) =>
{
    graphView.panning = false;
    graphView.releasePointerCapture(pointerId);

    if (changeCursor)
        setAutoCursor();
};



graphView.startZoomSelection = (pointerId, x, y) =>
{
    graphView.setPointerCapture(pointerId);

    graphView.zoomSelecting = true;
    graphView.selectionRect = new Rect(x, y, 0, 0);
    
    selectBox.style.visibility = 'visible';
    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelection = (x, y) =>
{
    if (!graphView.zoomSelecting) return;

    graphView.selectionRect.w = x - graphView.selectionRect.x;
    graphView.selectionRect.h = y - graphView.selectionRect.y;

    graphView.updateZoomSelectBox();
};



graphView.updateZoomSelectBox = () =>
{
    const selection = graphView.selectionRect;

    selectBox.style.left   = selection.x + Math.min(selection.w, 0);
    selectBox.style.top    = selection.y + Math.min(selection.h, 0);
    selectBox.style.width  = Math.abs(selection.w);
    selectBox.style.height = Math.abs(selection.h);

    selectBox.style.zIndex = MAX_INT32-3;
};



graphView.endZoomSelection = (pointerId, zoom) =>
{
    graphView.releasePointerCapture(pointerId);

    graphView.zoomSelecting    = false;
    selectBox.style.visibility = 'hidden';

    const selection = graphView.selectionRect;

    if (zoom)
    {
        // graphView.oldZoom = graphView.zoom;
        
        let box = {
            x: selection.x,
            y: selection.y - menuBar.offsetHeight,
            w: selection.w,
            h: selection.h };
            
        const wndHeight = graphView.offsetHeight; 

        const diff = { w: (window.innerWidth - box.w) / 2,
                       h: (wndHeight         - box.h) / 2 };

        graphView.setPanAndZoom(
            point(
                -(box.x - diff.w) * graphView.zoom,
                -(box.y - diff.h) * graphView.zoom),
            graphView.zoom * Math.min(
                window.innerWidth / box.w,
                wndHeight         / box.h));
    }

    graphView.selectionRect = Rect.NaN;
};


graphView._selectedNodes     = [];
graphView._prevSelectedNodes = [];
graphView.lastSelectedNodes  = [];


Object.defineProperty(graphView, 'selectedNodes',
{
    get: () => graphView._selectedNodes,
    set: selectedNodes =>
    {
        graphView.deselectAll();

        graphView._selectedNodes = [...selectedNodes];
    
        for (const node of graphView._selectedNodes)
            node.setSelected(true);
    }
});



graphView.deselectAll = () =>
{
    for (const node of graphView._selectedNodes)            
        node.setSelected(false);

    graphView._selectedNodes = [];
};



graphView.selectByIds = (nodeIds) =>
{
    graphView.deselectAll();

    for (const id of nodeIds)
    {
        const node = nodeFromId(id);
        graphView._selectedNodes.push(node);
        node.setSelected(true);
    }
};



graphView.startSelection = (pointerId, x, y, shiftKey, ctrlKey) =>
{
    graphView.setPointerCapture(pointerId);

    graphView.selecting = true;

    graphView.selectionRect = new Rect(x, y, 0, 0);
    graphView._prevSelectedNodes = [];
   
    selectBox.style.visibility = 'visible';

    graphView.updateSelectBox(shiftKey, ctrlKey);
};



graphView.updateSelection = (x, y, shiftKey, ctrlKey) =>
{
    if (!graphView.selecting) return;

    graphView.selectionRect.w = x - graphView.selectionRect.x;
    graphView.selectionRect.h = y - graphView.selectionRect.y;

    graphView.updateSelectBox(shiftKey, ctrlKey);
};



graphView.updateSelectBox = (shiftKey, ctrlKey) =>
{
    const wndRect = new Rect(
        1,
        menuBar  .offsetHeight + 1,
        graphView.offsetWidth  - 2,
        graphView.offsetHeight - 5);

    
    let selection = validateRect(graphView.selectionRect);
    
    selection = clipRect(selection, wndRect);


    selectBox.style.left   = selection.x;
    selectBox.style.top    = selection.y;
    selectBox.style.width  = selection.width;
    selectBox.style.height = selection.height;


    const selected = [];

    for (const node of graph.nodes)
    {
        if (rectsIntersect(
                boundingRect(node.div), 
                selection))
            selected.push(node);
    }


    if (ctrlKey)
        graphView.selectedNodes = graphView.lastSelectedNodes.concat(selected);
    else if (shiftKey)
        graphView.selectedNodes = graphView.lastSelectedNodes
                             .filter(node => !selected.includes(node))
                             .concat(selected.filter(node => !graphView.lastSelectedNodes.includes(node)));
    else
        graphView.selectedNodes = selected;
    
        
    selectBox.style.zIndex = MAX_INT32-3;
        
        
    selected.forEach(n => n.updateNode());
    graphView._prevSelectedNodes.forEach(n => n.updateNode());
    graphView.lastSelectedNodes.forEach(n => n.updateNode());


    graphView._prevSelectedNodes = selected;
};



graphView.endSelection = pointerId =>
{
    if (   graphView.selectedNodes    .length > 0
        || graphView.lastSelectedNodes.length > 0)
    {
        actionManager.do(new SelectNodesAction(
            graphView.selectedNodes    .map(n => n.id), 
            graphView.lastSelectedNodes.map(n => n.id)));
    }


    graphView.releasePointerCapture(pointerId);

    graphView.selecting     = false;
    graphView.selectionRect = Rect.NaN;
    graphView._prevSelectedNodes = [];

    selectBox.style.visibility = 'hidden';
};


graphView.startConnectionFromOutput = (pointerId, output, updateTempWire = true) =>
{
    graphView.connPointerId = pointerId;

    graphView.tempConn = new Connection(output, null);
    graphView.tempConn.wire.output = output;

    graphView.addWire(graphView.tempConn.wire, false);

    if (updateTempWire)
    {
        updateWire(
            graphView.tempConn.wire,
            graphView.pStart.x, 
            graphView.pStart.y);
    }
        
    output.updateControl();
};



graphView.startConnectionFromInput = (pointerId, input) =>
{
    graphView.connPointerId = pointerId;

    graphView.tempConn = new Connection(null, input);
    graphView.tempConn.wire.input = input;
    
    graphView.addWire(graphView.tempConn.wire, false);

    updateWire(
        graphView.tempConn.wire,
        graphView.pStart.x, 
        graphView.pStart.y);

    input.updateControl();
};



graphView.cancelConnection = pointerId =>
{
    const output = graphView.tempConn.output;
    const input  = graphView.tempConn.input;

    graphView.removeWire(graphView.tempConn.wire);    

    graphView.savedConn = null;
    graphView.tempConn  = null;

    if (output) output.updateControl();
    if (input ) input .updateControl();

    if (graphView.overInput ) graphView.overInput .updateControl();
    if (graphView.overOutput) graphView.overOutput.updateControl();


    if (graphView.hasPointerCapture(pointerId))
        graphView.releasePointerCapture(pointerId);

    graphView.connPointerId = -1;

     newReorderIndex = Number.NaN;
    prevReorderIndex = Number.NaN;
     oldReorderIndex = Number.NaN;
};



graphView.endConnection = pointerId =>
{
    if (graphView.tempConn.output) // FROM OUTPUT
    {
        let output = graphView.tempConn.output;
        let input  = graphView.overInput;

        let savedConnInput = 
            graphView.savedConn
            ? graphView.savedConn.input
            : null;
        
        output.connecting = false;
        
        if (   input
            && input.types.includes(output.type)) // TO INPUT
        {
            if (   !isNaN(newReorderIndex)
                && !isNaN(oldReorderIndex)
                &&  newReorderIndex >= 0
                &&  input.node.variableInputs
                && !isLastInArray(input.node.inputs, input))
                actionManager.do(new ReorderInputAction(input.node.id, oldReorderIndex, newReorderIndex));

            else if (input == savedConnInput) // reconnect old
            {
                graphView.savedConn = null; // done here to redraw the saved wire correctly
                updateWire(input.connection.wire);
            }

            else if (savedConnInput)
            {
                if (savedConnInput.connectedOutput != output)
                    actionManager.do(new ReconnectAction(output, savedConnInput, input));
            }
            else if (   !savedConnInput
                     && (  !input.connected
                         || input.connectedOutput != graphView.tempConn.output)) // connect new
                actionManager.do(new ConnectAction(output, input));
        }
        else if (savedConnInput) // disconnect old
            actionManager.do(new DisconnectAction(output, savedConnInput));
        
        graphView.cancelConnection(pointerId);
    }
    
    else if (graphView.tempConn.input) // FROM INPUT
    {
        let input  = graphView.tempConn.input;
        let output = graphView.overOutput;

        input.connecting = false;
        
        if (   output
            && input.types.includes(output.type)) // TO OUTPUT
            actionManager.do(new ConnectAction(output, input));

        graphView.cancelConnection(pointerId);
    }
}


scrollbarX.moving = false;
scrollbarY.moving = false;



graphView.updateScrollWithBounds = () =>
{
    const bounds = graphView.getAllNodeBounds();

    graphView.updateScroll(
        graphView.clientLeft,
        graphView.clientWidth,
        graphView.clientHeight,
        bounds,
        menuBar.offsetHeight);
};



graphView.updateScroll = (x, w, h, bounds, yOffset) =>
{
    graphView.updateScrollX(   w, h, bounds);
    graphView.updateScrollY(x, w, h, bounds, yOffset);

    scrollbarX.style.zIndex = MAX_INT32-1;
    scrollbarY.style.zIndex = MAX_INT32-2;
};



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollX = (w, h, bounds) =>
{
    if (   bounds.l < 0
        && bounds.r >= w)
    {
        const width = sqr(w) / bounds.width - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  width;
        scrollbarX.style.left    =  smallScrollGap + (w - smallScrollGap - largeScrollGap - width) * -bounds.l / (-bounds.l + bounds.r - w);
        scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else if (bounds.l < 0)
    {
        const width = sqr(w) / (w - bounds.l) - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  width;
        scrollbarX.style.left    =  w - largeScrollGap - width;
        scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else if (bounds.r >= w)
    {
        const width = sqr(w) / bounds.r - (smallScrollGap + largeScrollGap);

        scrollbarX.style.display = 'inline-block';
        scrollbarX.style.width   =  width;
        scrollbarX.style.left    =  smallScrollGap;
        scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else
        scrollbarX.style.display = 'none';
};



scrollbarX.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarX.moving = true;
        scrollbarX.xStart = scrollbarX.offsetLeft;
        scrollbarX.wStart = scrollbarX.offsetWidth;
        scrollbarX.pStart = e.clientX;
        scrollbarX.setPointerCapture(e.pointerId);

        graphView.panStart = graphView.pan;

        for (const node of graph.nodes)
            node.div.slx = node.div.offsetLeft;
    }
});



scrollbarX.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarX.moving)
    {
        scrollbarX.moving = false;
        scrollbarX.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of graph.nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        if (bounds.l >= 0 && bounds.r < graphView.clientWidth)
            scrollbarX.style.display = 'none';
    }
});



scrollbarX.addEventListener('pointermove', e =>
{
    if (scrollbarX.moving)
    {
        var x = scrollbarX.xStart + e.clientX - scrollbarX.pStart;

        var l = x;
        var r = l + scrollbarX.wStart;

        l = Math.max(smallScrollGap, l);
        r = Math.min(r, graphView.clientWidth - largeScrollGap);

        l = Math.max(smallScrollGap, Math.min(l, r - smallScrollGap));
        r = Math.max(l + smallScrollGap, r);

        scrollbarX.style.left  = l;
        scrollbarX.style.width = r-l;

        graphView.pan = point(
            graphView.panStart.x - (e.clientX - scrollbarX.pStart) / scrollbarX.wStart * graphView.clientWidth,
            graphView.panStart.y);
    }
});



/////////////////////////////////////////////////////////////////////////////////////



graphView.updateScrollY = (x, w, h, bounds, yOffset) =>
{
    if (   bounds.t <  yOffset
        && bounds.b >= h + yOffset)
    {
        const height = sqr(h) / bounds.height - (smallScrollGap + largeScrollGap);

        scrollbarY.style.display = 'inline-block';
        scrollbarY.style.height  =  height;
        scrollbarY.style.top     =  smallScrollGap + (h - height + smallScrollGap) * (yOffset - bounds.t) / (yOffset - bounds.t + bounds.b - h);
        scrollbarY.style.left    =  x + w - smallScrollGap - 6;
    }
    else if (bounds.t < yOffset)
    {
        const height = sqr(h) / (h - (bounds.t - yOffset)) - (smallScrollGap + largeScrollGap);

        scrollbarY.style.display = 'inline-block';
        scrollbarY.style.height  = height;
        scrollbarY.style.top     = h - largeScrollGap - height;
        scrollbarY.style.left    = x + w - smallScrollGap - 6;
    }
    else if (bounds.b >= h + yOffset)
    {
        const height = sqr(h) / (bounds.b - yOffset) - (smallScrollGap + largeScrollGap);

        scrollbarY.style.display = 'inline-block';
        scrollbarY.style.height  = height;
        scrollbarY.style.top     = smallScrollGap;
        scrollbarY.style.left    = x + w - smallScrollGap - 6;
    }
    else
        scrollbarY.style.display = 'none';
};



scrollbarY.addEventListener('pointerdown', e =>
{
    if (e.button == 0)
    {
        scrollbarY.moving = true;
        scrollbarY.yStart = scrollbarY.offsetTop;
        scrollbarY.hStart = scrollbarY.offsetHeight;
        scrollbarY.pStart = e.clientY;
        scrollbarY.setPointerCapture(e.pointerId);

        for (const node of graph.nodes)
            node.div.sly = node.div.offsetTop;

        graphView.panStart = graphView.pan;
    }
});



scrollbarY.addEventListener('pointerup', e =>
{
    if (   e.button == 0
        && scrollbarY.moving)
    {
        scrollbarY.moving = false;
        scrollbarY.releasePointerCapture(e.pointerId);

        var bounds = Rect.NaN;

        for (const node of graph.nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        if (bounds.t >= 0 && bounds.b < graphView.clientHeight)
            scrollbarY.style.display = 'none';
    }
});



scrollbarY.addEventListener('pointermove', e =>
{
    if (scrollbarY.moving)
    {
        var y = scrollbarY.yStart + e.clientY - scrollbarY.pStart;

        var t = y;
        var b = t + scrollbarY.hStart;

        t = Math.max(smallScrollGap, t);
        b = Math.min(b, graphView.clientHeight - largeScrollGap);

        t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
        b = Math.max(t + smallScrollGap, b);

        scrollbarY.style.top    = t;
        scrollbarY.style.height = b-t;

        graphView.pan = point(
            graphView.panStart.x, 
            graphView.panStart.y - (e.clientY - scrollbarY.pStart) / scrollbarY.hStart * graphView.clientHeight);
    }
});


graphView.addWire = function(wire, updateTransform = true)
{
    graphView.wires.push(wire);
    wireContainer.appendChild(wire);

    if (updateTransform)
        updateWire(wire);
};



graphView.removeWire = function(wire)
{
    wireContainer.removeChild(wire);    
    removeFromArray(graphView.wires, wire);
};



function updateWire(wire, x = 0, y = 0)
{
    const yOffset = menuBar.offsetHeight;

    let pOut = point(0, 0),
        pIn  = point(0, 0);


    if (wire.connection.output)
    {
        const ro = boundingRect(wire.connection.output.control);
        pOut = point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset);
    }
    else
        pOut = point(x, y - yOffset);


    if (wire.connection.input)
    {
        const ri = boundingRect(wire.connection.input .control);
        pIn = point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset);
    }
    else
        pIn = point(x, y - yOffset);


    wire.update(
        pOut.x, 
        pOut.y, 
        pIn.x, 
        pIn.y);        
}



function updateWires(wires)
{
    //logFunction('updateWires()');


    const pOut    = [];
    const pIn     = [];
    
    const cw      = graphView.clientWidth;
    const ch      = graphView.clientHeight;
    const yOffset = menuBar  .offsetHeight;


    wires.forEach(w => 
    {
        const ro = boundingRect(w.connection.output.control);
        const ri = boundingRect(w.connection.input .control);

        pOut.push(point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset));
        pIn .push(point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset));
    });

    
    for (let i = 0; i < wires.length; i++)
    {
        const wire = wires[i];

        // the yOffset is to start wire coords just below the control bar,
        // not at the top of the window

        wire.updateCurve  (pOut[i].x, pOut[i].y, pIn[i].x, pIn[i].y);
        wire.updateOutBall(pOut[i].x, pOut[i].y                    );
        wire.updateInBall (                      pIn[i].x, pIn[i].y);

        wire.updateStyle(wire.getColor());

        wire.setAttribute('width',  cw);
        wire.setAttribute('height', ch);
        wire.setAttribute('stroke-width', 1.6 * graphView.zoom);
    
        wire.setAttribute('viewBox',
                    0
            + ' ' + 0
            + ' ' + cw
            + ' ' + ch);
    }


    for (let i = 0; i < wires.length; i++)
    {
        const conn   = wires[i].connection;
        const input  = conn.input;
        const output = conn.output;

        const isSolo = 
                graphView._soloNode
            && (    input.node == graphView._soloNode
                || output.node == graphView._soloNode);

        show(wires[i],         (settings.showWires || isSolo) && conn != graphView.savedConn);
        show(wires[i].curve,   (settings.showWires || isSolo) && conn != graphView.savedConn);
        show(wires[i].xp1,     (settings.showWires || isSolo) && conn != graphView.savedConn);
        show(wires[i].xp2,     (settings.showWires || isSolo) && conn != graphView.savedConn);
        show(wires[i].outBall, !graphView.tempConn || graphView.tempConn.output);
        show(wires[i]. inBall, !graphView.tempConn || graphView.tempConn. input);
    }
}


class Parameter
extends EventTarget
{
    #type;     get type()    { return this.#type;    }
    #id;       get id()      { return this.#id;      }
    #name;     get name()    { return this.#name;    }
    _node;     get node()    { return this._node;    }
    _div;      get div()     { return this._div;     }


    get index() { return this.node.params.indexOf(this); }


    input;
    output;

    
    onbeforechange = new Event('beforechange');
    onchange       = new Event('change');
    onconfirm      = new Event('confirm');
    onchangelock   = new Event('changelock');


    noUpdate = false;



    show = () => true;



    constructor(type, id, name)
    {
        super();


        this.#id                = id;
        this.#name              = name;
        this.#type              = type;

        this._div               = createDiv();

        this.div.style.position = 'relative';
        this.div.style.padding  = 0;
        this.div.style.width    = '100%';

        this.input              = null;
        this.output             = null;

        enableElementText(this.div, true);
    }



    setName(name, dispatchEvents = true)
    {
        this.#name = name; 
        this.update(dispatchEvents);
    }



    initInput(types)
    {
        this.input = new Input(types, this.input_getValuesForUndo);
        this.input._param = this;

        this.input.control.style.float     = 'left';
        this.input.control.style.position  = 'absolute';
        this.input.control.style.top       = '50%';
        this.input.control.style.transform = 'translateY(-50%)';

        this.input .colorLight = [0, 0, 0, 0.12];
        this.input .colorDark  = [1, 1, 1, 0.12];
        this.input .overFactor = 3;
        
        this.div.appendChild(this.input.control);

        this.input.addEventListener('connect',    () => this.enableControlText(false));
        this.input.addEventListener('disconnect', () => this.enableControlText(true ));
    }



    initOutput(type, toString)
    {
        this.output = new Output(type, toString);
        this.output._param = this;

        this.output.control.style.float     = 'right';
        this.output.control.style.position  = 'absolute';
        this.output.control.style.top       = '50%';
        this.output.control.style.transform = 'translateY(-50%)';
        
        this.output.colorLight = [0, 0, 0, 0.12];
        this.output.colorDark  = [1, 1, 1, 0.12];
        this.output.overFactor = 3;

        this.div.appendChild(this.output.control);
    }



    isDefault() { return false; }


    
    input_getValuesForUndo()
    {
        return [[
            this.param.id, 
            this.param.value]];
    }



    update(dispatchEvents)
    {

    }    



    updateControls()
    {
        this.control.update();
        
        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    preSetValue(value, createAction, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (!value.equals(this.oldValue))
                this.dispatchEvent(this.onbeforechange);
        }
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (   !this.oldValue
                || !value.equals(this.oldValue))
            {
                this.dispatchEvent(this.onchange);
                
                if (createAction)
                {
                    actionManager.do(new SetParamValueAction(this, value));
                    this.dispatchEvent(this.onconfirm);
                }
            }
        }
    }



    textboxHasFocus()
    {
        return false;
    }



    enableControlText()
    {
        return true;
    }



    toString()
    {
        // parameter outputs call this method
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);

        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + this.value + '"]';
    }



    loadParam(param)
    {
        
    }
}



function setParamValue(param, value, updateParamId = '')
{
    if (param.id != updateParamId)
        param.setValue(value, false, true, false);
}


class   NumberParamBase
extends Parameter
{
    control;

    
    get value() 
    { 
        return new NumberValue(
            this.control.value, 
            this.control.displayDec); 
    }

    oldValue = null;


    defaultValue;


    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }


    
    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        // console.log(this.id + '.setValue() value =', value);
        // console.trace();

        console.assert(
            value instanceof NumberValue,
            'value must be a NumberValue');


        this.preSetValue(value, createAction, dispatchEvents);

        
        if (updateControl)
        {
            this.control.setDecimals(value.decimals, value.decimals);
            this.control.setValue(value.value, false, false); 
        }


        super.setValue(value, createAction, updateControl, dispatchEvents);

        
        this.oldValue = this.value.copy();
    }    



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else request.push( 
            NUMBER_VALUE, 
            new NumberValue(
                this.control.value, 
                this.control.displayDec).toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    textboxHasFocus()
    {
        return hasFocus(this.control.textbox);
    }



    enableControlText(enable)
    {
        enableElementText(this.control, enable);
        this.control.readOnly = !enable;
    }
    
    
    
    isDefault()
    {
        return this.value.equals(this.defaultValue);
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + this.value.toString() + '"]';
    }



    loadParam(param)
    {
        this.setValue(parseNumberValue(param)[0], true, true, false);
    }
}


class   NumberParam
extends NumberParamBase
{
    allowEditDecimals = true;
    
    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = 0, 
                min          = Number.MIN_SAFE_INTEGER, 
                max          = Number.MAX_SAFE_INTEGER,
                decimals     = 0,
                dragScale    = 0.05)
    {
        super(NUMBER, id, name);

        
        this.control        = createDiv('numberControl');
        
        this.control.param  = this;
        this.control.zIndex = 0;
   
        this.defaultValue   = new NumberValue(defaultValue);


        initNumberControl(
            this,
            this.control,
            120, // width
            20,  // height
            this.id,
            this.name, 
            showName,
            defaultValue,
            min,
            max,
            decimals,   
            dragScale); 

        this.control.successOnFocusOut = true;

        this.control.style.display = 'inline-block';
        this.control.style.width   = '100%';

        this.div.appendChild(this.control);

       
        if (hasInput)  this.initInput(NUMBER_TYPES);
        if (hasOutput) this.initOutput(NUMBER_VALUE, this.output_genRequest);


        this.control.addEventListener('confirm', () => { this.setValue(this.value, true, false, true); });


        this.control.addEventListener('finishedit', e =>
        { 
            let   dec    = decCount(e.detail.value); 
            const oldDec = decCount(e.detail.oldValue);

            
            if (!e.detail.success)
                return;


            if (   Math.abs(e.detail.value - e.detail.oldValue) > Number.EPSILON
                && dec >= oldDec)
            {
                this.setValue(new NumberValue(parseFloat(e.detail.value), dec), true);
                e.preventSetValue = true;
            }
            else if (this.allowEditDecimals)
            {
                if (Math.abs(parseFloat(e.detail.value) - parseFloat(e.detail.oldValue)) <= Number.EPSILON)
                    dec += Math.log10(this.control.valueScale);
                else 
                    dec = oldDec;

                this.setValue(new NumberValue(parseFloat(e.detail.value), dec), true);
                e.preventSetValue = true;
            }
        });
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.control.setName(name);
    }



    toString()
    {
        return this.value.toString();
    }
}


class   SelectParam
extends NumberParamBase
{
    options = [];
    

    constructor(id,
                name,
                showName,
                hasInput,
                hasOutput,
                options,
                defaultValue = 0)
    {
        super(NUMBER, id, name);

        this.control        = createDiv();
        
        this.control.param  = this;
        this.control.zIndex = 0;

        this.options        = options;
        
        this.defaultValue   = new NumberValue(defaultValue);


        initNumberControl(
            this,
            this.control,
            120, // width
            20,  // height
            this.id,
            this.name, 
            showName,
            defaultValue,
            0,
            options.length-1,
            0,   // decimals
            0.02);


        this.control.options           = [...options];
        this.control.successOnFocusOut = true;
        this.control.barTop            = 0.8;

        this.control.style.display     = 'inline-block';
        this.control.style.width       = '100%';

        this.div.appendChild(this.control);


        if (hasInput)  this.initInput(NUMBER_TYPES);
        if (hasOutput) this.initOutput(NUMBER_VALUE, this.output_genRequest);

            
        this.control.addEventListener('confirm', () => { this.setValue(this.value, true, true); });
    }



    toString()
    {
        return this.input
            && this.input.connected 

            ? [ ...this.input.connectedOutput.genRequest(createGenObject()) ]

            : [ NUMBER, 
                this.value.toString(), 
                this.control.displayDec.toString() ];
    }
}


class   ColorParam
extends Parameter
{
    defaultValue;

    oldValue = null;

    
    checkers;
    
    control;
    

    
    get valueText() { return this.control.valueText; }
    set valueText(text) 
    {
        this.control.valueText = text;
        this.control.update();
    }

    
    get value() { return this.control.value; }
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = ColorValue.fromRgb([0x80, 0x80, 0x80]),
                dragScale    = 0.05)
    {
        super(COLOR, id, name);

        this.checkers       = createDiv();
        this.control        = createDiv();
        
        this.control.param  = this;
        this.control.zIndex = 0;
   
        this.defaultValue   = defaultValue;


        initColorControl(
            this,
            this.control,
            120, // width
            20,  // height
            this.id,
            this.name, 
            showName,
            defaultValue,   
            dragScale); 

        this.control.successOnFocusOut = true;


        this.checkers.style.position      = 'absolute';
        this.checkers.style.width         = '100%';
        this.checkers.style.height        = '20px';
        this.checkers.style.pointerEvents = 'none';


        this.control .style.display       = 'inline-block';
        this.control .style.width         = '100%';


        this.div.appendChild(this.checkers);
        this.div.appendChild(this.control );

       
        if (hasInput)  this.initInput(COLOR_TYPES);
        if (hasOutput) this.initOutput(COLOR_VALUE, this.output_genRequest);


        this.control.addEventListener('confirm', () => 
        {
            this.setValue(this.control.value, true, false); 
        });


        this.control.addEventListener('finishedit', e =>
        { 
            if (!e.detail.success)
                return;


            if (e.detail.value != e.detail.oldValue)
            {
                const rgb = validHex2rgb(e.detail.value);

                this.setValue(ColorValue.fromRgb(scaleRgb(rgb)), true);
                e.preventSetValue = true;
            }
        });
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.control.setName(name);
    }



    isDefault()
    {
        return this.value.equals(this.defaultValue);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        console.assert(
               value.type 
            && value.type == COLOR_VALUE, 
            'value.type must be COLOR_VALUE');
            
        this.preSetValue(value, createAction, dispatchEvents);

        this.control.value = value.copy();

        if (updateControl)
            this.control.setValue(this.control.value, false, true); 

        super.setValue(value, createAction, updateControl, dispatchEvents);

        this.oldValue = this.value.copy();
    }    



    updateControls()
    {
        // const rgb = this.value.toRgb();

        // const col = 
        //     !rgbIsNaN(rgb)
        //     ? (isDark(rgb)
        //        ? [1, 1, 1]
        //        : [0, 0, 0])
        //     : (isDarkMode()
        //        ? [1, 1, 1]
        //        : [0, 0, 0]);


        // const noColor = 
        //     isDarkMode()
        //     ? rgbNoColorDark
        //     : rgbNoColorLight;

        // this.input.wireColor   = !rgbIsNaN(rgb) ? rgb : noColor;
        // this.input.colorLight  = 
        // this.input.colorDark   = rgb_a(col, 0.2);

        // this.output.wireColor  = !rgbIsNaN(rgb) ? rgb : noColor;
        // this.output.colorLight =
        // this.output.colorDark  = rgb_a(col, 0.2);


        this.checkers.style.background = 
            isDarkMode()
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = this.value.isValid() ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = isDarkMode() ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '20px 20px';
        this.checkers.style.backgroundPosition = '0 0, 10px 10px';


        super.updateControls();
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else request.push( 
            COLOR_VALUE, 
            this.value.toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    textboxHasFocus()
    {
        return hasFocus(this.control.textbox);
    }



    enableControlText(enable)
    {
        enableElementText(this.control, enable);
        this.control.readOnly = !enable;
    }
    
    
    
    toString()
    {
        return this.value.toString();
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + this.value.toString() + '"]';
    }


    
    loadParam(param)
    {
        this.setValue(parseColorValue(param)[0], true, true, false);
    }
}


class   FillParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;


    checkers;
    controlWrapper;

    colorControl;
    opacityControl;
    
    
    get valueText() { return this.colorControl.valueText; }
    set valueText(text) 
    {
        this.colorControl.valueText = text;
        this.colorControl.update();
    }

    
    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = FillValue.NaN,
                dragScale    = 0.05)
    {
        super(FILL, id, name);

        this.checkers              = createDiv();
        this.controlWrapper        = createDiv();

        this.colorControl          = createDiv();
        this.opacityControl        = createDiv();
        
        this.  colorControl.param  = this;
        this.opacityControl.param  = this;

        this.  colorControl.zIndex = 0;
        this.opacityControl.zIndex = 0;
   
        this.defaultValue          = defaultValue;
        this.value                 = defaultValue;

        
        this._warningOverlay = createDiv('colorWarningOverlay');
        this._warningOverlay.style.zIndex = 21;
        this.div.appendChild(this._warningOverlay);


        initColorControl(
            this,
            this.colorControl,
            120, // width
            20,  // height
            this.id,
            'color', 
            showName,
            defaultValue.color,   
            dragScale); 

        this.colorControl.showColor = false;


        initNumberControl(
            this,
            this.opacityControl,
            120, // width
            20,  // height
            this.id,
            'opacity', 
            false,
            defaultValue.opacity.value,
            0,
            100,
            0);

        this.opacityControl.setSuffix('%', true);


        this.checkers.style.position                   = 'absolute';
        this.checkers.style.width                      = '100%';
        this.checkers.style.height                     = '20px';


        this.controlWrapper.style.position             = 'relative';
        this.controlWrapper.style.display              = 'inline-block';
        this.controlWrapper.style.width                = '100%';
        this.controlWrapper.style.height               = '20px';
        this.controlWrapper.style.zIndex               = 1;


        this.  colorControl.successOnFocusOut          = true;
        this.  colorControl.style.display              = 'inline';
        this.  colorControl.style.width                = '60%';
        this.  colorControl.style.position             = 'absolute';
        this.  colorControl.style.left                 = 0;

    
        this.opacityControl.successOnFocusOut          = true;
        this.opacityControl.style.display              = 'inline';
        this.opacityControl.style.width                = '40%';
        this.opacityControl.style.position             = 'absolute';
        this.opacityControl.style.right                = 0;


        this.  colorControl.text.style.transform       = 'translateX(-45%)';
        this.opacityControl.text.style.transform       = 'translateX(-70%)';


        this.  colorControl.textbox.style.position     = 'absolute';
        this.  colorControl.textbox.style.left         =  0;
        this.  colorControl.textbox.style.width        = '60%';
        this.  colorControl.textbox.style.transform    = 'translateX(0)';
        this.  colorControl.textbox.style.textAlign    = 'right';
        this.  colorControl.textbox.style.paddingLeft  =  11;
        
        this.opacityControl.textbox.style.position     = 'absolute';
        this.opacityControl.textbox.style.right        =  0;
        this.opacityControl.textbox.style.width        = '40%';
        this.opacityControl.textbox.style.transform    = 'translateX(25%)';
        this.opacityControl.textbox.style.textAlign    = 'left';
        this.opacityControl.textbox.style.paddingRight =  10;


        this.controlWrapper.appendChild(this.  colorControl);
        this.controlWrapper.appendChild(this.opacityControl);
        
        this.div.appendChild(this.checkers);
        this.div.appendChild(this.controlWrapper);

       
        if (hasInput)  this.initInput([...FILL_TYPES, ...COLOR_TYPES]);
        if (hasOutput) this.initOutput(FILL_VALUE, this.output_genRequest);


        this.colorControl.addEventListener('confirm', () =>
        { 
            this.setValue(new FillValue(
                this.colorControl.value, 
                new NumberValue(this.opacityControl.value, this.opacityControl.dec)), 
                true, false);
        });


        this.opacityControl.addEventListener('confirm', () =>
        {
            this.setValue(new FillValue(
                this.colorControl.value, 
                new NumberValue(this.opacityControl.value, this.opacityControl.dec)), 
                true, false);
        });


        this.colorControl.addEventListener('finishedit', e =>
        { 
            if (!e.detail.success)
                return;

            if (e.detail.value != e.detail.oldValue)
            {
                const  rgb = validHex2rgb(e.detail.value);
                const _rgb = scaleRgb(rgb);

                this.setValue(FillValue.fromRgb(_rgb, this.opacityControl.value), true);
                
                e.preventSetValue = true;
            }
        });
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof FillValue))
            console.assert(false, 'FillParam.setValue(value) is ' + typeof value + ', must be a FillValue');

        console.assert(
               value.type 
            && value.type == FILL_VALUE, 
            'FillParam value.type must be FILL_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        if (updateControl)
        {
            this.  colorControl.setValue(this.value.color,         false, false); 
            this.opacityControl.setValue(this.value.opacity.value, false, false, false); 
        }


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            request.push(...pushInputOrParam(this.input, gen));

            if (COLOR_TYPES.includes(this.input.connectedOutput.type))
            {
                request.push(
                    NUMBER_VALUE, 
                    new NumberValue(
                        this.opacityControl.value, 
                        this.opacityControl.displayDec).toString());
            }
        }

        else request.push( 
            FILL_VALUE, 
            this.value.toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        const noColor = 
            isDarkMode()
            ? rgbNoColorDark
            : rgbNoColorLight;

        const rgbaVal  = this.value.toRgba();
        const rgbaText = getTextColorFromBackColor(rgbaVal, rgbaVal[3]);


        const fillStyle = rgba2style(rgb_a(rgbaVal, this.opacityControl.value/100));

        this.controlWrapper.style.background = 
              !rgbaIsNaN(rgbaVal) 
            && this.value.opacity.isValid()
            ? fillStyle 
            : 'transparent'; 


        this.updateWarningOverlay();


        if (!rgbaIsNaN(rgbaVal))
            this.div.style.background = 'transparent';
        else
        {
            this.div.style.background =
                isDarkMode()
                ? 'rgba(56, 56, 56, 0.95)'
                : 'rgba(255, 255, 255, 0.95)';

        }


        this.input.wireColor   = !rgbIsNaN(rgbaVal) ? rgbaVal : noColor;
        this.input.colorLight  = 
        this.input.colorDark   = rgb_a(rgbaText, 0.2);

        this.output.wireColor  = !rgbIsNaN(rgbaVal) ? rgbaVal : noColor;
        this.output.colorLight =
        this.output.colorDark  = rgb_a(rgbaText, 0.2);


        this.checkers.style.background = 
            isDarkMode()
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = this.value.isValid() ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = isDarkMode() ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '20px 20px';
        this.checkers.style.backgroundPosition = '0 0, 10px 10px';

        
        this.colorControl. backStyleLight   = 
        this.colorControl. backStyleDark    = 
        this.colorControl.valueStyleLight   = 
        this.colorControl.valueStyleDark    = 'transparent';

        this.colorControl.textStyleLight    = 
        this.colorControl.textStyleDark     = rgba2style(rgbaText);


        this.opacityControl. backStyleLight = 
        this.opacityControl. backStyleDark  = 
        this.opacityControl.valueStyleLight = 
        this.opacityControl.valueStyleDark  = 'transparent';

        this.opacityControl.textStyleLight  = 
        this.opacityControl.textStyleDark   = rgba2style(rgbaText);

        this.  colorControl.update();
        this.opacityControl.update();


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.colorControl.setName(name);
    }



    isDefault()
    {
        return this.value.equals(this.defaultValue);
    }



    // textboxHasFocus()
    // {
    //     return hasFocus(this.  colorControl.textbox)
    //         || hasFocus(this.opacityControl.textbox);
    // }



    enableControlText(enable)
    {
        const opEnable = 
                enable 
            || !this.input 
            || !this.input.connected 
            ||  COLOR_TYPES.includes(this.input.connectedOutput.type);

        enableElementText(this.  colorControl, enable);
        enableElementText(this.opacityControl, opEnable);
        
        this.  colorControl.readOnly = !enable;
        this.opacityControl.readOnly = !opEnable;
    }
    
    
    
    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgba = this.value.toRgba();

        if (!rgbIsNaN(rgba))
        {
            if (  !rgbIsValid(rgba)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgba);

                this.updateWarningOverlayStyle(rgba);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgba);
            this.updateWarningOverlayStyle(rgba);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? this.div.offsetHeight
            : height;

        this._warningOverlay.style.background =
               rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : 'repeating-linear-gradient('
               + '-45deg, '
               + 'transparent 0 7px,'
               +  this.warningStyle + ' 7px 14px)';

        this._warningOverlay.style.display = 'block';
    }
    
    
    
    toString()
    {
        return this.value.toString();
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + this.value.toString() + '"]';
    }


    
    loadParam(param)
    {
        this.setValue(parseFillValue(param)[0], true, true, false);
    }
}


class   StrokeParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;


    checkers;

    textControl;
    control;

    
    // get valueText() { return this.colorControl.valueText; }

    
    value;
    

    
    constructor(id,
                name, 
                hasInput,
                hasOutput,
                defaultValue = StrokeValue.NaN)
    {
        super(STROKE, id, name);


        this.checkers                     = createDiv();

        this.textControl                  = createDiv('colorControlText');
        this.control                      = createDiv();

        this.defaultValue                 = defaultValue;
        this.value                        = defaultValue;

        
        this.checkers.style.position      = 'absolute';
        this.checkers.style.width         = '100%';
        this.checkers.style.height        = '20px';

        this.textControl.style.width      = '100%';
        this.textControl.style.textAlign  = 'center';

        this._warningOverlay = createDiv('colorWarningOverlay');
        this._warningOverlay.style.zIndex = 21;
        this.div.appendChild(this._warningOverlay);


        initNumberControl(
            this,
            this.control,
            100, // width
            20,  // height
            this.id,
            'stroke', 
            true,
            defaultValue.weight.value,
            0);


        this.control.style.position       = 'absolute';
        this.control.style.display        = 'block';
        this.control.style.width          = '100%';
        this.control.style.height         = '20px';


        this.div.appendChild(this.checkers);

        this.div.appendChild(this.textControl);
        this.div.appendChild(this.control);

       
        if (hasInput)  this.initInput([...STROKE_TYPES, ...FILL_TYPES, ...COLOR_TYPES]);
        if (hasOutput) this.initOutput(STROKE_VALUE, this.output_genRequest);


        this.control.addEventListener('confirm', () => 
        { 
            const value = this.value.copy();

            value.weight = new NumberValue(
                this.control.value, 
                this.control.dec);

            this.setValue(value, true, false);
        });
    }



    // setName(name, dispatchEvents = true)
    // {
    //     super.setName(name, dispatchEvents);
    //     this.colorControl.setName(name);
    // }



    isDefault()
    {
        return this.value.equals(this.defaultValue);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        //console.log('value =', value);
        
        if (!(value instanceof StrokeValue))
        {
            //console.trace();
            console.assert(false, 'StrokeParam.setValue(value) is ' + typeof value + ', must be a StrokeValue');
        }


        console.assert(
               value.type 
            && value.type == STROKE_VALUE, 
            'StrokeParam value.type must be STROKE_VALUE');

        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        if (updateControl)
        {
            this.control.setDecimals(
                this.value.weight.decimals, 
                this.value.weight.decimals);
                
            this.control.setValue(this.value.weight.value, false, false); 
        }


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            request.push(...pushInputOrParam(this.input, gen));

            if (    FILL_TYPES.includes(this.input.connectedOutput.type)
                || COLOR_TYPES.includes(this.input.connectedOutput.type))
            {
                const val = noNaN(this.control.value,      1);
                const dec = noNaN(this.control.displayDec, 0);
                
                request.push(
                    NUMBER_VALUE, 
                    new NumberValue(val, dec).toString());
            }
        }

        else request.push( 
            STROKE_VALUE, 
            this.value.toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        if (   this.input.connected
            && this.value.isValid())
        {
            const noColor = 
                isDarkMode()
                ? rgbNoColorDark
                : rgbNoColorLight;

            const rgbaVal = this.value.fill.toRgba();
            const rgbaText = getTextColorFromBackColor(rgbaVal, rgbaVal[3]);


            this.input.wireColor   = !rgbIsNaN(rgbaVal) ? rgbaVal : noColor;
            this.input.colorLight  = 
            this.input.colorDark   = rgb_a(rgbaText, 0.2);

            this.output.wireColor  = !rgbIsNaN(rgbaVal) ? rgbaVal : noColor;
            this.output.colorLight =
            this.output.colorDark  = rgb_a(rgbaText, 0.2);


            this.checkers.style.background =
                isDarkMode()
                ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
                  + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
                :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
                  + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

            this.checkers.style.display            = 'inline-block';
            this.checkers.style.backgroundColor    = isDarkMode() ? '#444' : '#fff';

            this.checkers.style.backgroundSize     = '20px 20px';
            this.checkers.style.backgroundPosition = '0 0, 10px 10px';

            
            this.control.style.display     = 'inline-block';
            
            this.control. backStyleLight   = 
            this.control. backStyleDark    = 
            this.control.valueStyleLight   = 
            this.control.valueStyleDark    = rgba2style(rgbaVal);

            this.control.textStyleLight    = 
            this.control.textStyleDark     = rgba2style(rgbaText);

            this.control.update();
            

            this.textControl.style.display = 'none';

            this.updateWarningOverlay();
        }
        else
        {
            const noColor  = isDarkMode() ? rgbNoColorDark      : rgbNoColorLight;
            const rgbaText = isDarkMode() ? rgbaNoColorTextDark : rgbaNoColorTextLight;


            this.input.wireColor           = noColor;
            this.input.colorLight          = 
            this.input.colorDark           = rgb_a(rgbaText, 0.12);
        
            this.output.wireColor          = noColor;
            this.output.colorLight         =
            this.output.colorDark          = rgb_a(rgbaText, 0.12);


            this.checkers.style.display    = 'none';
            this.control .style.display    = 'none';
            
            this.textControl.style.display = 'inline-block';
            this.textControl.style.color   = rgba2style(rgbaText);

            this.textControl.innerHTML     = 'no stroke';
            
            this.div.style.background =
                isDarkMode()
                ? 'rgba(56, 56, 56, 0.95)'
                : 'rgba(255, 255, 255, 0.95)';
        }


        this.div.style.height = '20px';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    // textboxHasFocus()
    // {
    //     return hasFocus(this.weightControl.textbox)
    //         || hasFocus(this.   fitControl.textbox)
    //         || hasFocus(this.  joinControl.textbox);
    // }



    enableControlText(enable)
    {
        const opEnable = 
                enable 
            || !this.input 
            || !this.input.connected 
            ||   FILL_TYPES.includes(this.input.connectedOutput.type)
            ||  COLOR_TYPES.includes(this.input.connectedOutput.type);

        enableElementText(this.textControl, enable);
        enableElementText(this.control,     opEnable);

        this.textControl.readOnly = !enable;
        this.control    .readOnly = !opEnable;
    }
    
    
    
    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgba = this.value.fill.toRgba();

        if (!rgbIsNaN(rgba))
        {
            if (  !rgbIsValid(rgba)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgba);

                this.updateWarningOverlayStyle(rgba);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgba);
            this.updateWarningOverlayStyle(rgba);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? this.div.offsetHeight
            : height;

        this._warningOverlay.style.background =
               rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : 'repeating-linear-gradient('
               + '-45deg, '
               + 'transparent 0 7px,'
               +  this.warningStyle + ' 7px 14px)';

        this._warningOverlay.style.display = 'block';
    }
    
    
    
    toString()
    {
        return this.value.toString();
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + id  + '", "' + this.value.toString() + '"]';
    }


    
    loadParam(param)
    {
        this.setValue(parseStrokeValue(param)[0], true, true, false);
    }
}


class Graph
{
    nodes        = [];
    deferNodeIds = [];
    
    mutex        = false;

    connections  = [];



    clear()
    {
        this.deleteNodes(this.nodes.map(n => n.id));
        this.connections = [];
    }



    getNewNodeId(curId, id)
    {
        if (!this.nodes.find(n => n.id == id))
            return id;
        

        let numLength = this.getNumLength(id);

        if (numLength > 0)
        {
            const len = id.length - numLength;
            let   num = parseInt(id.substring(len));

            let newId = '';
            while (newId == '' || this.nodes.find(n => n.id == newId))
                newId = id.substring(0, len) + (++num);

            return newId;
        }

        else if (numLength == 0)
        {
            let num   = 2;
            let newId = id + num;

            while (this.nodes.find(n => 
                   n.id != curId 
                && n.id == newId))
                newId = id + (++num);

            return newId;
        }

        else
            return id;
    }
    
    
    
    getNumLength(name)
    {
        let numLength = 0;

        for (let i = name.length - 1; i >= 0; i--)
        {
            if (isDigit(name[i])) numLength++;
            else break;
        }

        return numLength;
    }
    
    

    addNodes(nodes, placeNode = true)
    {
        for (const node of nodes)
            this.addNode(node, placeNode);
    }



    addNode(node, placeNode = true, updateLabel = true)
    {
        node.graph = this;

        node.id = this.getNewNodeId(node.id, node.id);
        
        this.nodes.push(node);
        graphView.appendChild(node.div);
        
        if (placeNode)
            graphView.placeNewNode(node);
        
        node.div.style.zIndex = graph.nodes.length-1;


        graphView.putNodeOnTop(node);
        graphView.updateScrollWithBounds();
    }
    


    deleteNodes(nodeIds)
    {
        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            for (let i = node.inputs.length-1; i >= 0; i--) // backwards for the sake of variable inputs
            {
                const input = node.inputs[i];
                if (!input.connected) continue;

                uiMakeNodeActive(input.connectedOutput.node);
                this.disconnect(input, true);
            }
            
            for (let i = node.outputs.length-1; i >= 0; i--)
            {
                const output = node.outputs[i];
                
                for (const connInput of output.connectedInputs)
                    this.disconnect(connInput, true);
            }
            
            node.selected = false;
            node.graph    = null;

            removeFromArray(this.nodes, node);
            graphView.removeChild(node.div);
        }

        graphView.updateScrollWithBounds();
    }



    connect(output, input, inputIndex = -1)
    {
        //console.log('graph.connect()');

        if (input.connectedOutput == output)
            return null;
            

        if (input.connectedOutput)
        {
            const output = input.connectedOutput;
            this.disconnect(input);
            output.updateControl();
        }


        if (   input.node.variableInputs
            && inputIndex > -1)
        {
            input = lastOf(input.node.inputs);
            
            // move new input back to correct index
            moveInArray(
                input.node.inputs, 
                input.node.inputs.length-1, 
                inputIndex);

            input.node.inputControls.insertBefore(
                lastOf(input.node.inputControls.childNodes), 
                input.node.inputControls.childNodes[inputIndex]);
        }


        output.connectedInputs.push(input);
        input .connectedOutput = output;


        const conn = new Connection(output, input);

        input .connection = conn;
        output.connection = conn;
        
        graphView.addWire(conn.wire);

        this.connections.push(conn);

        
        output.updateControl();


        return conn;
    }



    disconnect(input)
    {
        var output = input.connectedOutput;
        if (!output) return false;


        graphView.removeWire(input.connection.wire);

        removeFromArray(this.connections, input.connection);
        removeFromArray(output.connectedInputs, input);

        
        input .connectedOutput = null;
        input .connection      = null;
        output.connection      = null;


        if (input.param)
            input.param.valueText = '';


        return true;
    }
}



function nodesToJson(nodes, encloseBraces = true, connOutputMustBeInNodes = true)
{
    const tab = TAB;
    
    let json = 
          (encloseBraces ? '{\n' : '')
          + tab + '"nodes":\n'
          + tab + '[';

    let first = true;
    for (let i = 0; i < nodes.length; i++)
    {
        if (!first) json += ','; first = false;
        json += NL + nodes[i].toJson(4);
    }

    json += NL + tab + ']';
    json += connectionsToJson(nodes, connOutputMustBeInNodes);
    json += (encloseBraces ? '\n}' :'');

    return json;
}



function connectionsToJson(nodes, connOutputMustBeInNodes)
{
    const connections = [];


    for (let i = 0; i < nodes.length; i++)
    {
        let node = nodes[i];

        for (let j = 0; j < node.inputs.length; j++)
        {
            if (   !node.inputs[j].connected
                ||    !nodes.includes(node.inputs[j].connectedOutput.node)
                   && connOutputMustBeInNodes)
                continue;

            connections.push(node.inputs[j].connection);
        }
    }
    

    if (connections.length == 0)
        return '';


    const tab = TAB;

    let json = 
          ',\n'
        + tab + '"connections":\n'
        + tab + '[';
    
    for (let i = 0; i < connections.length; i++)
    {
        if (i > 0) json += ',';
        json += NL + connections[i].toJson(4);
    }

    json += NL + tab + ']';

    return json;
}



function createNode(nodeType, creatingButton = null, createdNodeId = -1, options = {})
{
    let node;

    switch (nodeType)
    {
        case NUMBER:             node = new OpNumber();           break;
        case NUMBER_LIMITS:      node = new OpLimits();           break;
        case NUMBER_ADD:         node = new OpAdd();              break;
        case NUMBER_SUBTRACT:    node = new OpSubtract();         break;
        case NUMBER_MULTIPLY:    node = new OpMultiply();         break;
        case NUMBER_DIVIDE:      node = new OpDivide();           break;
        case NUMBER_MODULO:      node = new OpModulo();           break;
        case NUMBER_EXPONENT:    node = new OpExponent();         break;
        case NUMBER_INTERPOLATE: node = new OpInterpolate();      break;
        // case NUMBER_RANDOM:   node = new OpRandom(); break;
        
        case COLOR:              node = new OpColor(options);     break;
        case COLOR_INTERPOLATE:  node = new OpColorInterpolate(); break;
        case COLOR_VALIDATE:     node = new OpColorValidate();    break;
        case COLOR_CONTRAST:     node = new OpColorContrast();    break;
        case COLORBLIND:         node = new OpColorBlind();       break;
        
        case COLOR_STOP:         node = new OpColorStop();        break;
        case GRADIENT:           node = new OpGradient();         break;

        case FILL:               node = new OpFill();             break;
        case STROKE:             node = new OpStroke();           break;

        case RECTANGLE:          node = new OpRectangle();        break;
        case LINE:               node = new OpLine();             break;
        case ELLIPSE:            node = new OpEllipse();          break;
        case POLYGON:            node = new OpPolygon();          break;
        case STAR:               node = new OpStar();             break;

        case COMMENT:            node = new OpComment();          break;

        default:                 console.assert(false, 'Graph.js/createNode() cannot create type ' + nodeType);
    }
    
    node._creatingButton = creatingButton;

    return node;
}



function idFromNode(node)
{
    return node ? node.id : '';
}



function nodeFromId(id)
{
    return graph.nodes.find(n => n.id == id);
}



function nodesFromIds(ids)
{
    return ids.map(id => nodeFromId(id));
}


// function activeNodeInTree(node) 
// { 
//     const left  = activeNodeLeft(node);  if (!!left ) return left;
//     const right = activeNodeRight(node); if (!!right) return right;

//     return null;
// }



// function activeNodeLeft(node)
// {
//     if (node.active) return node;

//     for (const input of node.inputs)
//     {
//         if (input.connected)
//         {
//             const left = activeNodeLeft(input.connectedOutput.node);
//             if (left) return left;
//         }
//     }

//     return null;
// }



// function activeNodeRight(node)
// {
//     if (node.active) return node;

//     for (const output of node.outputs)
//     {
//         for (const connInput of output.connectedInputs)
//         {
//             const right = activeNodeRight(connInput.node);
//             if (right) return right;
//         }
//     }

//     return null;
// }



function getAllNodesFromNode(node, ignore = [])
{
    const nodes = [node];

    if (!ignore.includes(node)) 
        ignore.push(node);


    for (const input of node.inputs)
    {
        const node = input.connectedOutput.node;
        if (ignore.includes(node)) continue;

        nodes.push(...getAllNodesFromNode(node, ignore));
    }


    for (const output of node.outputs)
    {
        for (const _input of output.connectedInputs)
        {
            const node = _input.node;
            if (ignore.includes(node)) continue;

            nodes.push(...getAllNodesFromNode(node, ignore));
        }
    }


    return nodes;
}



function getNodesAcrossNode(node)
{
    let nodes = [];

    nodes = [...nodes, ...getNodesBeforeNode(node)];
    nodes = [...nodes, ...getNodesAfterNode (node)];

    return nodes;
}


function getNodesBeforeNode(node)
{
    let before = [];

    for (const input of node.inputs)
    {
        if (!before.includes(input.connectedOutput.node)) // avoid including diamond tips twice
            before.push(input.connectedOutput.node);
    
        before.push(...getNodesBeforeNode(input.connectedOutput.node));
    }

    return before;
}



function getNodesAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
        for (const input of output.connectedInputs)
        {
            if (!after.includes(input.node)) // avoid including diamond tips twice
                after.push(input.node);

            after.push(...getNodesAfterNode(input.node));
        }

    return after;
}



function getTerminalsAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
    {
        for (const input of output.connectedInputs)
        {
            if (   input.param 
                && (   !input.param.output
                    || !input.param.output.connected))
                pushUnique(after, input.node);

            pushUnique(after, getTerminalsAfterNode(input.node));
        }
    }

    return after.length > 0 ? after : [node];
}



function getTerminalsAfterParam(param)
{
    if (!param.output)
        return getTerminalsAfterNode(param.node);


    let after = [];

    for (const input of param.output.connectedInputs)
    {
        if (   input.param 
            && (   !input.param.output
                || !input.param.output.connected))
            pushUnique(after, input.node);

        pushUnique(after, getTerminalsAfterNode(input.node));
    }

    return after.length > 0 ? after : [];
}



function updateTerminalsAfterNodes(nodes)
{
    const terminals = [];

    for (const node of nodes)
        pushUnique(terminals, getTerminalsAfterNode(node));

    pushUpdate(terminals);
}



function getActiveNodeInBranchFrom(node, alreadyChecked = [])
{
    if (node.active) return node;


    const nodeInputs = [...node.inputs.filter(i => i.connected)];

    if (    nodeInputs.length == 1
        && !nodeInputs[0].connectedOutput.param
        && !alreadyChecked.includes(nodeInputs[0].connectedOutput.node))
    {
        const leftActive = getActiveNodeInBranchFrom(
            nodeInputs[0].connectedOutput.node, 
            [...alreadyChecked, node]);

        if (leftActive) return leftActive;
    }


    const nodeOutputs = node.outputs
        .filter(o => o.connectedInputs.length == 1)
        .filter(o => !o.param);

    if (    nodeOutputs.length == 1
        && !nodeOutputs[0].connectedInputs[0].param
        && !alreadyChecked.includes(nodeOutputs[0].connectedInputs[0].node))
    {
        const rightActive = getActiveNodeInBranchFrom(
            nodeOutputs[0].connectedInputs[0].node, 
            [...alreadyChecked, node]);

        if (rightActive) return rightActive;
    }


    return null;
}



function getActiveNodeInTreeFromNodeId(nodeId, alreadyChecked = [])
{
    return getActiveNodeInTreeFromNode(nodeFromId(nodeId), alreadyChecked);
}



function getActiveNodeInTreeFromNode(node, alreadyChecked = [])
{
    if (node.active) return node;


    const leftActive = getActiveNodeLeftInTreeFromNode(node, [...alreadyChecked]);
    if (leftActive) return leftActive;


    for (const output of node.outputs.filter(o => !o.param))
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                const rightActive = getActiveNodeInTreeFromNode(
                    input.node, 
                    [...alreadyChecked, node]);

                if (rightActive) return rightActive;
            }
        }
    }


    return null;
}



function getActiveNodeLeftInTreeFromNode(node, alreadyChecked = [])
{
    /*  This is different from LeftOnly in that it will check the left node, 
        but then it will also check the right nodes of that left node. */

    if (node.active) return node;


    for (const input of node.inputs.filter(i => !i.param))
    {
        if (    input.connected
            && !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
        {
            const leftActive = getActiveNodeInTreeFromNode(
                input.connectedOutput.node, 
                [...alreadyChecked, node]);

            if (leftActive) return leftActive;
        }
    }


    return null;
}



function getActiveNodeLeftOnlyInTreeFromNode(node, alreadyChecked = [])
{
    /*  This is different from Left in that it will only check left nodes. */

    if (node.active) return node;


    for (const input of node.inputs.filter(i => !i.param))
    {
        if (    input.connected
            && !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
        {
            const leftActive = getActiveNodeLeftOnlyInTreeFromNode(
                input.connectedOutput.node, 
                [...alreadyChecked, node]);

            if (leftActive) return leftActive;
        }
    }


    return null;
}



function getActiveNodeRightInTreeFromNode(node, alreadyChecked = [])
{
    if (node.active) return node;


    for (const output of node.outputs.filter(o => !o.param))
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                const rightActive = getActiveNodeRightInTreeFromNode(
                    input.node, 
                    [...alreadyChecked, node]);

                if (rightActive) return rightActive;
            }
        }
    }


    return null;
}



function getActiveNodesRightInTreeFromNodeId(nodeId, alreadyChecked = [])
{
    const rightActive = [];
    
   
    const node = nodeFromId(nodeId);
    
    if (node.active) 
        rightActive.push(node);


    for (const output of node.outputs.filter(o => !o.param))
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                rightActive.push(...getActiveNodesRightInTreeFromNodeId(
                    input.node.id, 
                    [...alreadyChecked, node]));
            }
        }
    }


    return rightActive;
}



function getActiveNodesInTreeFromNodeId(nodeId, alreadyChecked = [])
{
    return getActiveNodesInTreeFromNode(nodeFromId(nodeId), alreadyChecked);
}



function getActiveNodesInTreeFromNode(node, alreadyChecked = [])
{
    const activeNodes = [];


    if (node.active)
        activeNodes.push(node);


    for (const input of node.inputs.filter(i => !i.param))
    {
        if (    input.connected
            && !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
            pushUnique(activeNodes, getActiveNodesInTreeFromNode(input.connectedOutput.node, [...alreadyChecked, node]));
    }


    for (const output of node.outputs.filter(o => !o.param))
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
                pushUnique(activeNodes, getActiveNodesInTreeFromNode(input.node, [...alreadyChecked, node]));
        }
    }


    return activeNodes;
}


class   Input
extends EventTarget
{
    types = []; // an input can accept multiple types


    get data()
    {
        return (
            this.connected
            ? this.connectedOutput.data
            : null);
    }


    _node  = null; get node () { return this._node;  }
    _param = null; get param() { return this._param; }


    get index() { return this.node.inputs.indexOf(this); }

    
    colorLight;
    colorDark;

    wireColor;


    control;
    hitbox;
    wireBall;
  

    _connectedOutput = null;
    get connectedOutput() { return this._connectedOutput; }
    set connectedOutput(output)
    {
        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'disconnect', 
                { 'input': this }));
        }

        this._connectedOutput = output;

        if (this._connectedOutput)
        {
            this.dispatchEvent(new CustomEvent(
                'connect', 
                { 
                    'output': output,
                    'input':  this 
                }));
        }
    }


    get connected() { return this.connectedOutput != null; }


    connection   = null;
    
    connecting   = false;
    mouseOver    = false;
    
    overFactor   = 1.7;
    

    initialSeed  = 0;
    currentSeed  = 0;


    isNew        = false; // this indicates that the input is the empty "new" input of a variable node


    onconnect    = new Event('connect');
    ondisconnect = new Event('disconnect');


    getValuesForUndo; // function pointer, return array of [index,value] tuples



    constructor(types, getValuesForUndo = null)
    {
        super();
        
        this.types            = [...types];
        this.getValuesForUndo = getValuesForUndo;

        this.control          = createDiv('input');
        this.hitbox           = createDiv('inputHitbox');
        this.wireBall         = createDiv('inputBall');
        
        this.control.input    = this;
        
        this.colorLight       = [0, 0, 0, 1];
        this.colorDark        = [1, 1, 1, 1];

        this.wireColor        = rgbFromType(this.types[0], true);

        
        this.control.appendChild(this.hitbox);
        this.control.appendChild(this.wireBall);

                
        //this.hitbox.addEventListener('pointerdown', e => e.preventDefault());


        this.hitbox.addEventListener('pointerenter', e => 
        {
            if (graphView.headerInput)
            {
                graphView.headerInput.updateControl();
                graphView.headerInput = null;
            }

            this.mouseOver = true;
            this.updateControl();


            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

            if (   graphView.tempConn
                && graphView.tempConn.output
                && this.types.includes(graphView.tempConn.output.type)
                && (  !this.connected
                    || this.connectedOutput != graphView.tempConn.output
                    || this == savedInput))
            {
                const rect = boundingRect(this.control);
                const loop = graphView.tempConn.output.node.isOrFollows(this.node);

                if (!loop)
                {
                    graphView.tempConn.wire.inputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - menuBar.offsetHeight);
                }

                graphView.overInput = !loop ? this : null;
                this.node.inputs.forEach(i => i.updateControl());
            }
            else
                graphView.overInput = this;
        });


        this.hitbox.addEventListener('pointerleave', e => 
        {
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overInput = null;

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.output)
            graphView.tempConn.wire.inputPos = point_NaN;
    }



    updateControl()
    {
        const tc = graphView.tempConn;

        const mouseOver =
               this.mouseOver
            && !(   tc
                 && tc.input)
            && !(   tc
                 && tc.output
                 && (  !this.types.includes(tc.output.type)
                     || tc.output.node.isOrFollows(this.node)));

        const color =
            isDarkMode()
            ? this.colorDark
            : this.colorLight;
                     
        const colorStyle = 
            settings.showWires
            ? rgba2style(rgb_a(
                color,
                mouseOver 
                ? Math.min(color[3] * this.overFactor, 1) 
                : color[3]))
            : 'transparent';


        const isConnected =
               this.connected
            ||     tc
               && (   tc.input == this
                   ||    graphView.overInput == this
                      && !tc.input)
               && !(    tc.output
                    && !this.types.includes(tc.output.type));

        this.control.style.transform = 
              'translateX(' + (isConnected ? -1 : 0) + 'px)'
            + 'translateY(-50%)';
        
        this.control.style.width         = (isConnected ? 8 : 6) + 'px';
        this.control.style.height        = (isConnected ? 8 : 6) + 'px';
        this.control.style.borderRadius  = (isConnected ? 4 : 4) + 'px';
        this.control.style.marginBottom  = (isConnected ? 4 : 6) + 'px';
        this.control.style.boxShadow     = '0 0 0 1px ' + colorStyle;
        this.control.style.pointerEvents = settings.showWires ? 'auto' : 'none';

        this.hitbox.style.left   = isConnected ? -2 : -3;
        this.hitbox.style.top    = isConnected ? -2 : -3;

        this.wireBall.style.left = '1px';
        this.wireBall.style.top  = 'calc(50% - 3px)';

        this.wireBall.style.backgroundColor = 
            this.connected
            ? (   graphView.savedConn
               && graphView.savedConn.input == this
               && graphView.overInput != this
               ? 'transparent'
               : rgba2style(toRgba(this.connectedOutput.wireColor)))
            : (   tc
               && tc.output
               && this.types.includes(tc.output.type)
               && graphView.overInput == this
               ? rgba2style(toRgba(tc.output.wireColor))
               : (   tc
                  && tc.input
                  && tc.input == this)
                  ? (graphView.overOutput
                     ? rgba2style(toRgba(graphView.overOutput.wireColor))
                     : (graphView.headerOutput
                        ? rgba2style(toRgba(graphView.headerOutput.wireColor))
                        : rgba2style(toRgba(tc.input.wireColor))))
                  : colorStyle);

        this.wireBall.style.zIndex = MAX_INT32;


        show(this.wireBall, isConnected); 
    }
}


class Output
{
    _type;     
    get type() { return this._type; }

    _node  = null;  get node () { return this._node;  }
    _param = null;  get param() { return this._param; }
    
    
    get index() { return this.node.outputs.indexOf(this); }


    colorLight;
    colorDark;

    wireColor;

    control;
    hitbox;
    wireBall;
    
    
    connectedInputs = [];
    
    mouseOver  = false;
    connecting = false;

    overFactor = 1.7;
    
    
    genRequest = null; // function pointer, must be implemented
    cache      = [];


    _data;

    get data() 
    {
        if (this.param) this.param.setOutputData();
        //if (this.node ) this.node.update();

        return this._data;
    }
    
    set data(value)
    {
        this._data = value;
    }



    get connected() { return this.connectedInputs.length > 0; }



    constructor(type, genRequest)
    {
        this._type           = type;
        this.genRequest      = genRequest;

        this.control         = createDiv('output');
        this.hitbox          = createDiv('outputHitbox');
        this.wireBall        = createDiv('outputBall');
        
        this.control.output  = this;
        
        
        this.control.appendChild(this.hitbox);
        this.control.appendChild(this.wireBall);

        this.colorLight      = [0, 0, 0, 1];
        this.colorDark       = [1, 1, 1, 1];

        this.wireColor       = rgbFromType(this.type, true);
        
        this.updateControl();

        
        //this.hitbox.addEventListener('pointerdown', e => e.preventDefault());


        this.hitbox.addEventListener('pointerenter', e => 
        { 
            if (graphView.headerOutput)
            {
                graphView.headerOutput.updateControl();
                graphView.headerOutput = null;
            }


            this.mouseOver = true;
            this.updateControl();


            if (   graphView.tempConn
                && graphView.tempConn.input
                && graphView.tempConn.input.types.includes(this.type))
            {
                const rect = boundingRect(this.control);
                const loop = this.node.isOrFollows(graphView.tempConn.input.node);

                if (!loop)
                {
                    graphView.tempConn.wire.outputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - menuBar.offsetHeight);
                }

                graphView.overOutput = !loop ? this : null;
                this.node.outputs.forEach(o => o.updateControl());
            }
            else
                graphView.overOutput = this; 
        });



        this.hitbox.addEventListener('pointerleave', e => 
        { 
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overOutput = null; 

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.input)
            graphView.tempConn.wire.outputPos = point_NaN;
    }



    updateControl()
    {
        const mouseOver =
               this.mouseOver
            && !(   graphView.tempConn
                 && graphView.tempConn.output)
            && !(   graphView.tempConn
                 && graphView.tempConn.input
                 && (  !graphView.tempConn.input.types.includes(this.type)
                     || this.node.isOrFollows(graphView.tempConn.input.node)));


        const color = 
            isDarkMode()
            ? this.colorDark
            : this.colorLight;

        const colorStyle = 
            settings.showWires
            ? rgba2style(rgb_a(
                color, 
                mouseOver 
                ? Math.min(color[3] * this.overFactor, 1) 
                : color[3]))
            : 'transparent';

        this.control.style.pointerEvents   = settings.showWires ? 'auto' : 'none';
        this.control.style.backgroundColor = colorStyle;

        this.control.style.boxShadow = 
               this.connectedInputs.length > 0
            ||    graphView.tempConn
               && (   graphView.tempConn.output == this
                   || graphView.overOutput == this)
            ? '0 0 0 1px ' + colorStyle
            : 'none';

        this.wireBall.style.backgroundColor = rgba2style(toRgba(this.wireColor));

        this.wireBall.style.zIndex = MAX_INT32;


        const isConnected =
               this.connectedInputs.length > 0
            ||     graphView.tempConn
               && (   graphView.tempConn.output == this
                   ||     graphView.overOutput == this
                      && !graphView.tempConn.output)
               && !(    graphView.tempConn.input
                    && !graphView.tempConn.input.types.includes(this.type));

        show(this.wireBall, isConnected);
    }
}


class Connection
{
    output;
    input;

    wire;


    constructor(output, input)
    {
        this.output = output;
        this.input  = input;


        this.wire                            = createSvg('svg');
        this.wire.connection                 = this;
        this.wire.style.position             = 'absolute';
        this.wire.style.left                 = 0;
        this.wire.style.top                  = 0;
        this.wire.style.overflow             = 'hidden';
  
        this.wire.outputPos                  = point_NaN;
        this.wire. inputPos                  = point_NaN;
  
        this.wire.xp1                        = createSvg('path');
        this.wire.xp1.style.position         = 'absolute';
        this.wire.xp1.style.fill             = 'none';

        this.wire.xp2                        = createSvg('path');
        this.wire.xp2.style.position         = 'absolute';
        this.wire.xp2.style.fill             = 'none';

        this.wire.curve                      = createSvg('path');
        this.wire.curve.style.position       = 'absolute';
        this.wire.curve.style.fill           = 'none';

        this.wire.outBall                    = createSvg('circle');
        this.wire.outBall.style.position     = 'absolute';

        this.wire.inBall                     = createSvg('circle');
        this.wire.inBall.style.position      = 'absolute';


        this.wire.appendChild(this.wire.xp1);
        this.wire.appendChild(this.wire.xp2);
        this.wire.appendChild(this.wire.curve);
        this.wire.appendChild(this.wire.outBall);
        this.wire.appendChild(this.wire.inBall);

        

        this.wire.update = (x1, y1, x2, y2) =>
        {
            const cw = graphView.clientWidth;
            const ch = graphView.clientHeight;
        
            
            this.wire.updateCurve  (x1, y1, x2, y2);
            this.wire.updateOutBall(x1, y1        );
            this.wire.updateInBall (        x2, y2);

            this.wire.updateStyle(this.wire.getColor());

            this.wire.setAttribute('width',  cw);
            this.wire.setAttribute('height', ch);
            this.wire.setAttribute('stroke-width', graphView.zoom);
        };



        this.wire.updateCurve = (x1, y1, x2, y2) =>
        {
            if (!pointIsNaN(this.wire.outputPos))
            {
                x1 = this.wire.outputPos.x;
                y1 = this.wire.outputPos.y;
            }

            if (!pointIsNaN(this.wire.inputPos))
            {
                x2 = this.wire.inputPos.x;
                y2 = this.wire.inputPos.y;
            }

            
            const _x0 = x1;
            const _y0 = y1;

            const _x3 = x2;
            const _y3 = y2;


            const tx  = 600 * graphView.zoom;
            const ty  = 300 * graphView.zoom;
            const ecc = 100 * graphView.zoom;

            const yf  = (0.3 + Math.min(Math.abs(y2 - y1) / ty, 0.8));

            const df  = Math.pow((1 - Math.min(Math.abs(_x3 - _x0) / tx, 0.65)), 0.5)
                      * yf;

            const dx = 
                  (_x3 - _x0) * df 
                * (_x3 < _x0 ? -1 : 1);


            let _x1 = Math.max(_x0 + ecc * Math.pow(0.1 + yf*0.9, 1.5), _x0 + dx);
            let _y1 = _y0;

            let _x2 = Math.min(_x3 - ecc * Math.pow(0.1 + yf*0.9, 1.5), _x3 - dx);
            let _y2 = _y3;


            if (   graphView.tempConn == this
                && graphView.tempConn.output == graphView.overOutput)
            {
                _x1 += (_x0 - _x1) * 5/8;
                _y1 += (_y0 - _y1) * 5/8;
            }

            if (   graphView.tempConn == this
                && graphView.tempConn.input == graphView.overInput)
            {
                _x2 += (_x3 - _x2) * 5/8;
                _y2 += (_y3 - _y2) * 5/8;
            }

            
            const points =
                   'M ' + _x0 + ',' + _y0
                + ' C ' + _x1 + ',' + _y1
                + ' '   + _x2 + ',' + _y2
                + ' '   + _x3 + ',' + _y3;

            this.wire.xp1  .setAttribute('d', points);
            this.wire.xp2  .setAttribute('d', points);
            this.wire.curve.setAttribute('d', points);
     };



        this.wire.getColor = () =>
        {
            if (this.output)
                return this.output.wireColor;

            else if (this.input)
            {
                if (   graphView.overOutput
                    && this.input.types.includes(graphView.overOutput.type)) 
                    return graphView.overOutput.wireColor;
                else
                    return this.input.wireColor;
            }
                
            else 
                return [255, 0, 255];
        };



        this.wire.updateOutBall = (x, y) =>
        {
            this.wire.outBall.setAttribute('cx', x);
            this.wire.outBall.setAttribute('cy', y);
        };



        this.wire.updateInBall = (x, y) =>
        {
            this.wire.inBall.setAttribute('cx', x);
            this.wire.inBall.setAttribute('cy', y);
        };



        this.wire.updateStyle = (color) =>
        {
            const l = rgb2hclokl(color)[2];
            
            const bright       = Math.min(Math.max(0, (l-0.6) / 0.4), 1);
            const innerOpacity = Math.round(bright * 44 * Math.min(graphView.zoom, 1)).toString(16).padStart(2, '0');
            const outerOpacity = Math.round(bright * 60).toString(16).padStart(2, '0');

            this.wire.curve.style.filter = 
                !isDark(color)
                ?   'drop-shadow(0px 0px 1px #000000' + innerOpacity + ') '
                  + 'drop-shadow(0px 0px 6px #000000' + outerOpacity + ')'
                : 'none';

             
            let showCurve = true;

            if (   this.output && this.output.wireColor[3] < 1
                || this. input && this. input.wireColor[3] < 1)
            {
                showCurve = 
                       this.output && this.output.wireColor[3] > 0
                    || this. input && this. input.wireColor[3] > 0;

                this.wire.xp1.style.display          = 'inline';
                this.wire.xp1.style.stroke           = rgba2style(rgb_a(isDarkMode() ? [0.067, 0.067, 0.067] : [0.784, 0.784, 0.784], 1 - color[3]));
                this.wire.xp1.style.strokeDasharray  = 9 * graphView.zoom;

                this.wire.xp2.style.display          = 'inline';
                this.wire.xp2.style.stroke           = rgba2style(rgb_a(isDarkMode() ? [0.302, 0.302, 0.302] : [1, 1, 1], 1 - color[3]));//isDarkMode() ? '#4d4d4d' : '#fff';
                this.wire.xp2.style.strokeDasharray  = 9 * graphView.zoom;
                this.wire.xp2.style.strokeDashoffset = 9 * graphView.zoom;
            }
            else
            {
                this.wire.xp1.style.display = 'none';
                this.wire.xp2.style.display = 'none';
            }


            this.wire.  curve.style.stroke     = rgba2style(color);
            this.wire. inBall.style.fill       = rgba2style(color);
            this.wire.outBall.style.fill       = rgba2style(color);

            this.wire.xp1  .style.strokeWeight =
            this.wire.xp2  .style.strokeWeight =
            this.wire.curve.style.strokeWeight = (1.2 + 0.3 * bright * (1 + 1/(graphView.zoom/4))) * graphView.zoom;

            this.wire. inBall.style.r          = 3 * graphView.zoom;
            this.wire.outBall.style.r          = 3 * graphView.zoom;

            this.wire.style.zIndex             = 0;


            const isSolo = 
                   graphView._soloNode
                && (   this. input.node == graphView._soloNode
                    || this.output.node == graphView._soloNode);
            
            const showWire = 
                   settings.showWires 
                || isSolo;

            const isReordering =   
                   isNaN(newReorderIndex)
                || isNaN(oldReorderIndex);


            show(this.wire,         showWire && (this != graphView.savedConn || isReordering));
            show(this.wire.curve,   showWire && showCurve && (this != graphView.savedConn || isReordering));
            show(this.wire.xp1,     showWire && (this != graphView.savedConn || isReordering));
            show(this.wire.xp2,     showWire && (this != graphView.savedConn || isReordering));
            show(this.wire.outBall, showWire && (!graphView.tempConn || graphView.tempConn.output));
            show(this.wire. inBall, showWire && (!graphView.tempConn || graphView.tempConn. input));
        };
    }



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;
        
        let json = 
              pos + '{'
            +       NL + pos + tab + '"outputNodeId": "' + this.output.node.id + '"'
            + ',' + NL + pos + tab + '"outputId": "' + (this.output.param ? this.output.param.id : this.output.index) + '"'
            + (this.output.param ? ',' + NL + pos + tab + '"outputParam": "' + this.output.param.name + '"' : '')
            + ',' + NL + pos + tab + '"inputNodeId": "' + this.input.node.id + '"'
            + ',' + NL + pos + tab + '"inputId": "' + (this.input.param ? this.input.param.id : this.input.index) + '"'
            + (this.input.param ? ',' + NL + pos + tab  + '"inputParam": "' + this.input.param.name + '"' : '')
            +       NL + pos + '}';

        return json;
    }



    static parseJson(_conn)
    {
        const outputNode  = nodeFromId(_conn.outputNodeId);
        const outputId    = _conn.outputId;
        //const outputIndex = parseInt(_conn.outputIndex);

        const inputNode   = nodeFromId(_conn.inputNodeId);
        const inputId     = _conn.inputId;
        //const inputIndex  = parseInt(_conn.inputIndex);


        // log('---------------------------------------');

        // log('outputNode',                outputNode);
        // log('outputIndex',               outputIndex);
        // log('outputNode.outputs.length', outputNode.outputs.length);
        
        // log('inputNode',               inputNode);
        // log('inputIndex',              inputIndex);
        // log('inputNode.inputs.length', inputNode.inputs.length);



        if (   !outputNode 
            ||    isDigit(outputId[0])
               && parseInt(outputId) >= outputNode.outputs.filter(o => !o.param).length
            ||   !isDigit(outputId[0])
               && !outputNode.params.find(p => p.id == outputId && p.output)
            || !inputNode  
            ||    isDigit(inputId[0])
               && parseInt(inputId) >= inputNode.inputs.filter(i => !i.param).length
            ||   !isDigit(inputId[0])
               && !inputNode.params.find(p => p.id == inputId && p.input))
        {
            uiError(
                  'cannot connect ' 
                + _conn.outputNodeId + '.' + outputId 
                + ' to ' 
                + _conn.inputNodeId  + '.' + inputId);

            return null;
        }
        else
        {
            return uiVariableConnect(
                outputNode, 
                isDigit(outputId[0]) 
                ? parseInt(outputId) 
                : outputNode.params.find(p => p.id == outputId).output.index,
                inputNode, 
                isDigit(inputId[0])
                ? parseInt(inputId)
                : inputNode.params.find(p => p.id == inputId).input.index);
        }
    }
}



function getConnectionForArrayWithIds(conn)
{
    return {
        outputNodeId: conn.output.node.id,
        outputIndex:  conn.output.index,
        inputNodeId:  conn.input .node.id,
        inputIndex:   conn.input .index };
}



function getConnectionForArrayWithNames(conn)
{
    return {
        outputNodeName: conn.output.node.id,
        outputIndex:    conn.output.index,
        inputNodeName:  conn.input .node.id,
        inputIndex:     conn.input .index };
}


/*
    Operators don't have data types, those are inferred from the outputs.

    Outputs and have a toString() method, which creates a string that
    is added to the complete recursive generation request. 
    
    The generator then does the calculation and sends back two kinds of messages:
    node value updates and Figma page updates.

    Value updates can trigger a visual node update. The update info is passed
    in the update message.


    Output.genRequest()
    Parameter.genRequest()
*/



const connectionSize = 9;
const connectionGap  = 2;



class Operator
{
    graph = null;
    
    
    #type; // used in the code, not for generation
    get type() { return this.#type; }
    
    defShortName;
    

    id;

    _name;
    get name()     { return this._name; }
    set name(name) { this.setName(name); }


    inputs        = [];
    outputs       = [];

    params        = [];
    hiddenParams  = [];

    
    variableInputs       = false;

    alwaysLoadParams     = false;

    scrollName           = true;


    defaultWidth;
    labelOffsetFactor;


    _creatingButton  = null; // this is used to place the node under its creating button

    
    requestCache = []; // for nodes without an output


    // node UI

    div;
    inner;
    header;
    
    labelWrapper;
    label;
    textbox;
    inputControls;
    outputControls;

    paramBack;
    hiddenParamBack;

    //separator;
    //showAllParams = true;
    

    valid = false;



    _selected;
    get selected() { return this._selected; }
    set selected(sel) 
    {
        if (this._selected)
            removeFromArray(graphView.selectedNodes, this);

        this.setSelected(sel);     

        if (this._selected)
            graphView.selectedNodes.push(this);
    }        



    _active = false;
    get active() { return this._active; }
       
    
    get headerConnected()
    {
        const inputs = this.inputs.filter(i => 
              !i.param 
            && i.connected);
            
        return inputs.length > 0;
    }



    constructor(type, shortName, defWidth = 100)
    {
        this.#type             = type;
        this.id                = shortName;
        
        this.defShortName      = shortName;
        this.defaultWidth      = defWidth;
        this.labelOffsetFactor = 0;
        
        this.valid             = false;

        createOperatorNode(this);

        this.setName(shortName);
    }    



    addInput(input)
    {
        input._node = this;
        this.inputs.push(input);
        this.inputControls.appendChild(input.control);
    }



    getAutoInput(outType)
    {
        const inputs = this.inputs.filter(i => i.types.includes(outType));

        
        if (graphView.overInput)
            return graphView.overInput;

        if (   graphView.savedConn
            && graphView.savedConn.input
            && graphView.savedConn.input.node == this)
            return graphView.savedConn.input;
        
        else if (!graphView.tempConn.output.node.isOrFollows(this))
        {
            if (this.variableInputs)
                return lastOf(inputs);

            else
            {
                for (const input of inputs)
                {
                    if (!input.connected)
                        return input;
                }

                // at this point no empty inputs were found, so connect to the first one
                return inputs[0];
            }
        }

        return null;
    }



    addOutput(output)
    {
        output._node = this;
        this.outputs.push(output);
        this.outputControls.appendChild(output.control);
    }



    getAutoOutput(inputTypes)
    {
        const outputs = this.outputs.filter(o => inputTypes.includes(o.type));

        return     outputs.length == 1
               && !this.isOrFollows(graphView.tempConn.input.node)
               ? outputs[0]
               : null;
    }



    // initContentInput(input, firstParam = 0, condition = null)
    // {
    //     input.addEventListener('connect', () =>
    //     {
    //         if (    condition
    //             && !condition())
    //             return;

    //         for (let i = firstParam; i < this.params.length; i++)
    //             this.params[i].enableControlText(false);
    //     });
    

    //     input.addEventListener('disconnect', () =>
    //     {
    //         for (let i = firstParam; i < this.params.length; i++)
    //         {
    //             if (    this.params[i].input
    //                 && !this.params[i].input.connected) 
    //                 this.params[i].enableControlText(true);
    //         }

    //         this.updateNode();
    //     });
    // }



    addBaseParams()
    {

    }



    addParam(param)
    {
        this.params.push(param);
        
        param._node = this;

        if (param.input)
        {
            param.input._node = this;
            this.inputs.push(param.input);
        }

        if (param.output)
        {
            param.output._node = this;
            this.outputs.push(param.output);
        }

        this.inner.appendChild(param.div);
    }
 
    

    updateParamDisplay() // must be called at the end of each final Op constructor
    {
        for (const param of this.params)
            param.div.style.display = param.show() ? 'inline-block' : 'none';
    }



    setSelected(sel)
    {
        this._selected = sel;

        this.div.style.boxShadow = 
            this._selected
            ? '0 0 0 2px var(--figma-color-bg-brand)'
            : 'none';
    }
    


    makeActive()
    {
        //console.log(this.id + '.makeActive()');
        
        this._active = true;

        if (    graphView
            &&  graphView.activeNodes
            && !graphView.activeNodes.includes(this))
            graphView.activeNodes.push(this);
    }



    makePassive()
    {
        if (!this._active) 
            return;
            
        if (graphView.activeNodes.includes(this))
            removeFromArray(graphView.activeNodes, this);

        this._active = false;
    }



    setName(newName)
    {
        this._name = newName;
        // this.label.innerHTML = this._name;
        // //this.label.innerHTML = this.id;
        
        return true;
    }



    // isBefore(node)
    // {
    //     if (!this.outputs.find(o => o.connected))
    //         return false;

    //     for (const input of output.connectedInputs)
    //     {
    //         if (input.node == node)        return true;
    //         if (input.node.isBefore(node)) return true;
    //     }

    //     return false;
    // }



    follows(node) 
    { 
        return this.isOrFollows(node, true); 
    }



    isOrFollows(node, ignoreIs = false)
    {
        if (    this == node
            && !ignoreIs)
            return true;
            
        for (const input of this.inputs)
        {
            if (   input.connected
                && input.connectedOutput.node.isOrFollows(node))
                return true;
        }

        return false;
    }



    paramIsConsideredDefault(param) // this has to be an op virtual method, not a param method
    {
        return param.isDefault()
            && (   !param.input 
                || !param.input.connected);
    }



    reset() // for the entire generation run
    {
        for (const input of this.inputs)
        {
            input.currentSeed = input.initialSeed;
            
            if (input.connected)
                input.connectedOutput.node.reset();
        }
    }



    invalidate()
    {
        //if (!this.valid) // stops a node with inputs from same output 
        //    return;      // from being invalidated more than once
    
        //console.log(this.id + '.Operator.invalidate()');

        this.valid        = false;
        this.requestCache = [];

        for (const output of this.outputs)
        {
            output.cache = [];
            
            for (const input of output.connectedInputs)
                input.node.invalidate();
        }
    }



    toString() 
    { 
        // create the generator string here

        return '';
    }



    genRequest(gen)
    {
        // this function exists because a node without outputs
        // should still be able to generate a request
        
        return [];
    }



    genRequestStart(gen)
    {
        const request = [
            this.type, 
            this.id];

        const ignore = gen.passedNodes.includes(this);

    
        if (!ignore)
        {
            const nextActive   = getActiveNodeRightInTreeFromNode(this);
            const beforeActive = nextActive && nextActive.follows(this);

            const options =
                  ((this.active  ? 1 : 0) << 0)
                | ((beforeActive ? 1 : 0) << 1);

            request.push(options);
        }


        return [request, ignore];
    }



    updateNode() 
    {
        //console.log(this.id + '.Operator.updateNode()');

        this.      paramBack.style.backgroundColor = isDarkMode() ? '#363636' : 'white';
        this.hiddenParamBack.style.backgroundColor = isDarkMode() ? '#363636' : 'white';

        this.updateBorder();
        this.updateHeader();
        this.updateParams();

        graphView.updateNodeTransform(this);
    }



    updateBorder()
    {
        // this.inner.style.boxShadow = 
        //       '0 0 0 1px ' 
        //     + (this.div.over ? 'var(--figma-color-bg-brand)' : '#0001');
    }



    updateHeader()
    {
        //console.log(this.id + '.Operator.updateHeader()');
        
        const height = this.updateHeaderInputsAndOutputs();

        this.header.style.height = height;
        this.updateParamBack(height);

        this.updateHeaderLabel();
    }



    updateParamBack(headerHeight)
    {
        this.      paramBack.style.height =
        this.hiddenParamBack.style.height = this.inner.offsetHeight - headerHeight;

        this.      paramBack.style.top    =
        this.hiddenParamBack.style.top    = headerHeight;
    }



    updateHeaderLabel()
    {
        this.label.innerHTML = 
            settings.showNodeId 
            ? this.id 
            : this.name;
        
        this.label.style.left       = '50%';
        this.label.style.top        = '50%';

        updateHeaderLabelOffset(this);


        const colors                = Operator.prototype.getHeaderColors.call(this);

        this.label.style.color      = rgba2style(colors.text);
        this.label.style.fontWeight = this.active ? 'bold' : 'normal';
    }



    updateHeaderInputsAndOutputs()
    {
        // console.log('this.inputs',  this.inputs);
        // console.log('this.outputs', this.outputs);

        const inputs          = this.inputs .filter(i => !i.param);
        const connectedInputs = this.inputs .filter(i => !i.param && i.connected);
        const outputs         = this.outputs.filter(o => !o.param);

        const padding         = this.header.connectionPadding;
            
        const [ inputY,          inputHeight] = getHeaderConnY(inputs,          padding, 5);
        const [       , connectedInputHeight] = getHeaderConnY(connectedInputs, padding, 5);
        const [outputY,         outputHeight] = getHeaderConnY(outputs,         padding, 2);

             if (connectedInputHeight > outputHeight) for (let i = 0; i < outputs.length; i++) outputY[i] += (connectedInputHeight - outputHeight)/2;
        else if (        outputHeight > inputHeight ) for (let i = 0; i < inputs .length; i++)  inputY[i] += (outputHeight - inputHeight )/2;


        for (let i = 0; i < inputs.length; i++) 
        {
            inputs[i].control.style.top = inputY[i];
            inputs[i].updateControl();
        }

        for (let i = 0; i < outputs.length; i++) 
        {
            outputs[i].control.style.top = outputY[i];
            outputs[i].updateControl();
        }


        return Math.max(inputHeight, outputHeight) 
             + this.header.connectionPadding * 2;
    }



    updateValues(updateParamId, paramIds, values) // virtual
    {
        //logFunction('Operator.updateValues()');

        for (let i = 0, paramIndex; i < paramIds.length; i++)
        {
            if (    paramIds[i] != updateParamId
                && (paramIndex = this.params.findIndex(p => p.id == paramIds[i])) > -1)
                this.params[paramIndex].setValue(values[i], false, true, false);
        }
    }



    getHeaderColors()
    {
        const rgbaBack  = rgb_a(rgbFromType(this.type, this.active), 0.95);
        const rgbaText  = isDark(rgbaBack) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 
        const colInput  = rgb_a(rgbaText, 0.35);
        const colOutput = rgb_a(rgbaText, 0.35);
        const colWire   = rgbFromType(this.type, true);

        return {
            back:   rgbaBack, 
            text:   rgbaText,
            input:  colInput,
            output: colOutput,
            wire:   colWire };
    }



    setParamOutputData()
    {
        for (const param of this.params)
            param.setOutputData();
    }



    updateParams()
    {
        this.params.forEach(p => p.updateControls());
    }



    updateConnectedInputValueText() {}



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;
        

        let json = 
              pos + '{\n'
            + this.toJsonBase(nTab);

        if (this.params.filter(p => !this.paramIsConsideredDefault(p)).length > 0)
            json += this.paramsToJson(nTab);

        json += '\n' + pos + '}';


        return json;
    }



    toJsonBase(nTab)
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        let json =
              pos + tab + '"type": "' + this.type                      + '",\n'
            + pos + tab + '"id": "'   + this.id                        + '",\n'
            + pos + tab + '"name": "' + this.name.replace('"', '\\\"') + '",\n'
            + pos + tab + '"x": "'    + this.div.style.left            + '",\n'
            + pos + tab + '"y": "'    + this.div.style.top             + '",\n'
            + pos + tab + '"z": "'    + this.graph.nodes.indexOf(this) + '"';

        if (this.active)
            json += ',\n' + pos + tab + '"active": "' + this.active + '"';

        return json;
    }



    paramsToJson(nTab = 0)
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
            
        let first = true;
        for (const param of this.params)
        {
            if (!param.isDefault())
            {
                if (!first) json += ',\n'; first = false;
                json += pos + tab + tab + param.toJson(nTab);
            }
        }

        if (!first)
            json += '\n';

        json += pos + tab + ']';

        return json;
    }



    loadParams(_node, canLoadParam = index => true)
    {
        if (!_node.params)
            return;


        for (const _param of _node.params)
        {
            const index = this.params.findIndex(p => p.id == _param[0]);

            if (   index >= 0
                && canLoadParam(index)) 
                this.params[index].loadParam(_param[1]);
        }
    }
}



function getHeaderConnY(conns, padding, offset)
{
    const y      = [];
    let   height = 0;
    
    for (let i = 0; i < conns.length; i++)
    {
        if (i > 0) height += connectionGap;
        y.push(offset + padding + height);
        height += connectionSize;
    }

    return [y, height];
}



function pushUpdate(nodes)
{
    pushUpdateFromParam(nodes, null);
}



function pushUpdateFromParam(nodes, param)
{
    //console.log('pushUpdateFromParam('+param+')', nodes);

    
    const set =
          ((settings.enableLxxColorSpaces ? 1 : 0) << 0)
        | ((settings.logRequests          ? 1 : 0) << 1);


    const request = [set.toString()];


    if (param) request.push(param.node.id, param.id);
    else       request.push(NULL, NULL);


    const gen = createGenObject(param ? param.node : null);

        
    nodes.forEach(n => n.invalidate());

        
    const terminals = [];
    
    nodes.forEach(n => pushUnique(
        terminals, 
        getTerminalsAfterNode(n)));


    for (const node of terminals)
    {
        if (!gen.passedNodes.includes(node))
        {
            request.push(...getNodeRequest(node, gen));
            pushUnique(gen.passedNodes, node);
        }
    }


    for (const node of gen.paramNodes)
    {
        if (   !terminals.includes(node)
            && !gen.passedNodes.includes(node))
            request.push(...getNodeRequest(node, gen));
    }


    if (settings.logRawRequests)
        console.log(
            '%c%s%s', 
            'background: #60aa60; color: #cfd', 
            'raw request = ', 
            request.toString());


    uiQueueMessageToGenerator({
        cmd:     'genRequest',
        request:  request
    });
}



function pushInputOrParam(input, gen)
{
    if (    input.connectedOutput.param
        &&  gen.markParams
        &&  lastOf(gen.scope).nodeId != input.connectedOutput.node.id
        && !input.connectedOutput.node.valid)
    {
        pushUnique(gen.paramNodes, input.connectedOutput.node);

        return[ PARAM,
                input.connectedOutput.type,
                input.connectedOutput.node.id,
                input.connectedOutput.param.id ];
    }
    else
        return input.connectedOutput.genRequest(gen);
}



function getNodeRequest(node, gen)
{
    const request = [];


    if (node.outputs.filter(o => !o.param).length > 0)
    {
        node.outputs
            .filter(o => !o.param)
            .forEach(o =>
            {
                const _r = o.genRequest(gen);
                const  r = [..._r];
                request.push(...r);
            });
    }
    else
        request.push(...node.genRequest(gen));


    return request;
}



function createGenObject(paramNode)
{
    return {
        scope:       paramNode ? [{nodeId: paramNode.id, paramId: NULL}] : [], // [{nodeId, paramId}]
        passedNodes: [],
        paramNodes:  [],
        markParams:  true
    };    
}



function areConnected(node1, node2)
{
    return node1.isOrFollows(node2)
        || node2.isOrFollows(node1);
}


class OperatorBase
extends Operator
{
    updateHeader()
    {
        //console.log(this.id + '.OperatorBase.updateHeader()');

        super.updateHeader();

        
        const colors = this.getHeaderColors();


        this.header.style.backgroundColor = rgba2style(colors.back);
        this.label .style.color           = rgba2style(colors.text);


        for (const input of this.inputs.filter(i => !i.param))
        {
            input.colorLight = 
            input.colorDark  = colors.input;
        }

        
        for (const output of this.outputs.filter(o => !o.param)) 
        {
            output.colorLight =
            output.colorDark  = colors.output;

            output.wireColor  = colors.wire;
        }
    }
}


var  newReorderIndex = Number.NaN;
var prevReorderIndex = Number.NaN;
var  oldReorderIndex = Number.NaN;



function createOperatorNode(node)
{
    node.div                    = createDiv('node');
    node.div.node               = node;
       
    node.div.style.width        = node.defaultWidth + 'px';
           
    node.div.selectedSet        = false;
    node.div.over               = false;
    node.div.dragging           = false;
    node.div.shiftOnPointerDown = false;
    node.div.moved              = false;
       

    node.inner = createDiv('nodeInner');
    node.div.appendChild(node.inner);


    node.div.addEventListener('pointerenter', e =>
    {
        node.div.over      = true;
        graphView.overNode = node;
        
        if (    e.altKey
            && !getCtrlKey(e)
            && !e.shiftKey
            &&  graphView._soloNode != node) 
            graphView.soloNode(node);
        
        node.updateNode();
    });

    
    node.div.addEventListener('pointerleave', e =>
    {
        node.div.over      = false;
        graphView.overNode = null;
        
        if (   (  !e.altKey
                || getCtrlKey(e)
                || e.shiftKey)
            && graphView._soloNode == node)
            graphView.unsoloNode();

        node.updateNode();
    });

    
    node.paramBack = createDiv('nodeParamBack');
    //node.inner.appendChild(node.paramBack);
    
    
    //node.separator = createDiv('paramSeparator');
    //node.inner.appendChild(node.separator);
    
    // node.separator.addEventListener('click', () =>
    // {
    //     if (node.showAllParams)
    //     {
    //         node.showAllParams = !node.showAllParams;
    //         // TODO: save nodecd  here?
    //     }
    // });



    node.hiddenParamBack = createDiv('nodeHiddenParamBack');
    //node.inner.appendChild(node.hiddenParamBack);
    

    // node.div.addEventListener('pointermove', e =>
    // {
    //     const rect = boundingRect(node.div);
    
    //     let y = 
    //         + (e.clientY - rect.y) / graphView.zoom 
    //         - node.header.offsetHeight;

    //     const paramHeight = 20;

    //     y = Math.floor(y / paramHeight) * paramHeight;

    //     log(y);
        
    //     node.dragParam.style.top = node.header.offsetHeight + y + paramHeight/2 - 5.5;
    // });


    createNodeHeader(node);
}     



function createNodeHeader(node)
{
    node.header = createDiv('nodeHeader');
    
    node.header.connectionPadding = 8;
    node.header.ignoreDoubleClick = false; // used by child objects that need to be double clicked


    createNodeLabel(node);

    
    node. inputControls = createDiv('inputControls');
    node.outputControls = createDiv('outputControls');

    node.header.appendChild(node. inputControls);
    node.header.appendChild(node.outputControls);

    node.inner.appendChild(node.header);



    node.header.addEventListener('pointerdown', e =>
    {
        e.preventDefault();


        if (graphView.spaceDown)    
            return;


        graphView.lastSelectedNodes = [...graphView.selectedNodes];
        
        graphView.putNodeOnTop(node);


        for (const param of node.params)
        {
            if (param.textboxHasFocus())
                param.control.textbox.finish(true);
        }


        if (e.button == 0)
            hideAllMenus();


        if (    e.button == 0
            && !graphView.overOutput
            && !graphView.overInput)
        {
            e.stopPropagation();

            node.div.selectedSet = false;
            node.div.moved       = false;

            node.div.shiftOnPointerDown = 
                    e.shiftKey
                && !getCtrlKey(e)
                && !e.altKey;


            if (   getCtrlKey(e)
                && e.shiftKey
                && e.altKey)
            {
                graphView.selectedNodes = getAllNodesFromNode(node);
                console.log('graphView.selectedNodes = ', graphView.selectedNodes);
            }
            else if (e.shiftKey
                  && e.altKey)
            {
                if (isMac) graphView.selectedNodes = getNodesBeforeNode(node);
                else       graphView.selectedNodes = getNodesAcrossNode(node);
            }
            else if (getCtrlKey(e)
                  && e.shiftKey)
            {
                if (isMac) graphView.selectedNodes = getNodesAcrossNode(node);
                else       graphView.selectedNodes = getNodesBeforeNode(node);
            }
            else if (getCtrlKey(e)
                  && e.altKey)
                graphView.selectedNodes = getNodesAfterNode(node);

            else if (!node.selected)
            {
                if (e.shiftKey) node     .selected      = true;
                else            graphView.selectedNodes = [node];

                node.selectedSet = true;
            }

            
            node.div.sx = e.clientX;
            node.div.sy = e.clientY;


            for (const n of graphView.selectedNodes)
            {
                n.div.slx = n.div.offsetLeft;
                n.div.sly = n.div.offsetTop;
            }


            node.div.dragging = true;
            node.header.setPointerCapture(e.pointerId);
        }


        updateGraphNodes();
    });



    node.header.addEventListener('pointermove', e =>
    {
        //console.log(node.id + '.header.pointermove');

        const toTheRightOfInputs = e.clientX - boundingRect(node.header).x > 12 * graphView.zoom;

        const  tempConn = graphView. tempConn;
        const savedConn = graphView.savedConn;


        if (node.div.dragging)
        {
            const x       = graphView.clientLeft;
            const w       = graphView.clientWidth;
            const h       = graphView.clientHeight;
            const bounds  = graphView.getAllNodeBounds();
            const yOffset = menuBar.offsetHeight;
        
            setNodePositions(
                graphView.selectedNodes,
                (e.clientX - node.div.sx) / graphView.zoom,

                (e.clientY - node.div.sy) / graphView.zoom);
            
            node.div.moved = true;

            graphView.updateScroll(x, w, h, bounds, yOffset);
        }
        else if (   tempConn
                 && toTheRightOfInputs)
        {
            if (    tempConn.output
                && !tempConn.output.node.isOrFollows(node))
            {
                if (   node.variableInputs
                    && savedConn)
                {
                    const rect    = boundingRect(node.div);
                    const padding = node.header.connectionPadding;

                    const index = Math.min(Math.round(
                          ((e.clientY - rect.y) / graphView.zoom - padding - (connectionSize + connectionGap)/2) 
                        / (connectionSize + connectionGap)),
                        node.inputs.length-2);
                    
                    if (index != prevReorderIndex)
                    {
                        newReorderIndex = index;

                        moveInArray(
                            node.inputs, 
                            node.inputs.indexOf(savedConn.input),
                            newReorderIndex);

                        node.updateNode();
                         
                        prevReorderIndex = newReorderIndex;
                    }

                    graphView.overInput   = savedConn.input;
                    graphView.headerInput = savedConn.input;

                    graphView.overInput.updateControl();

                    
                    const inputRect = boundingRect(savedConn.input.control);

                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - menuBar.offsetHeight);
                }
                else
                {
                    const input = node.getAutoInput(tempConn.output.type);

                    if ( !input)
                        // ||    input.connected
                        //    && input.connectedOutput.node == tempConn.output.node) 
                        return;

                    graphView.overInput   = input;
                    graphView.headerInput = input;
                        
                    input.mouseOver = true;
                    input.updateControl();


                    const inputRect = boundingRect(input.control);

                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - menuBar.offsetHeight);
                }
            }
            else if (tempConn.input
                  && !node.isOrFollows(tempConn.input.node))
            {
                const output = node.getAutoOutput(tempConn.input.types);
                if (!output) return;

                graphView.overOutput   = output;
                graphView.headerOutput = output;
                    
                output.mouseOver = true;
                output.updateControl();


                const rect = boundingRect(output.control);

                tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - menuBar.offsetHeight);


                tempConn.input.updateControl();
            }
        }
    });



    node.header.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && node.div.dragging)
        {
            if (node.div.moved)
            {
                actionManager.do(new SelectMoveNodesAction(
                    graphView.lastSelectedNodes.map(n => n.id), 
                    graphView.selectedNodes.map(n => n.id), 
                    point(node.div.slx,        node.div.sly      ),
                    point(node.div.offsetLeft, node.div.offsetTop),
                    node.div.shiftOnPointerDown ));
            }
            else if (graphView.selectedNodes.length > 0) //(!node.selected)
            {
                actionManager.do(new SelectNodesAction(
                    graphView.selectedNodes    .map(n => n.id), 
                    graphView.lastSelectedNodes.map(n => n.id)));
            }


            node.div.dragging = false;
            node.header.releasePointerCapture(e.pointerId);
        }
        else if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(node)
                &&  graphView.overInput)
            {
                graphView          .endConnection(e.pointerId);
                graphView.overInput.endConnection();
            }
            else if ( graphView.tempConn.input
                  && !node.isOrFollows(graphView.tempConn.input.node)
                  &&  graphView.overOutput)
            {
                graphView           .endConnection(e.pointerId);
                graphView.overOutput.endConnection();
            }
        }


        node.div.shiftOnPointerDown = false;
    });
    
    

    node.header.addEventListener('pointerleave', e => 
    { 
        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != node)
            {
                const input = graphView.headerInput;
                
                graphView.overInput   = null;
                graphView.headerInput = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != node)
            {
                const output = graphView.headerOutput;
                
                graphView.overOutput   = null;
                graphView.headerOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }

        //updateHeaderLabelOffset(node, 0.5);
    });



    node.header.addEventListener('dblclick', e =>
    {
        e.preventDefault();

        
        var bounds = boundingRect(node.label);

        if (   e.clientX >= bounds.left && e.clientX < bounds.right
            && e.clientY >= bounds.top  && e.clientY < bounds.bottom)
            node.showLabelTextbox();
        else if (!node.header.ignoreDoubleClick)
            actionManager.do(new MakeActiveNodeAction(node.id));


        node.header.ignoreDoubleClick = false;
    });
}



function setNodePositions(nodes, dx, dy, updateTransform = true)
{
    //console.log('setNodePositions()');

    for (const node of nodes)
    {
        node.div.style.left = node.div.slx + dx;
        node.div.style.top  = node.div.sly + dy;
    }

    if (updateTransform)
        graphView.updateNodeTransforms(nodes);
}



function setNodePosition(node, x, y, updateTransform = true)
{
    //console.log('setNodePosition()');

    node.div.style.left = x;
    node.div.style.top  = y;

    if (updateTransform)
        graphView.updateNodeTransform(node);
}


function createNodeLabel(node)
{
    node.labelWrapper = createDiv('nodeLabelWrapper');

    node.label        = createDiv('nodeLabel');
    node.label.node   = node;
    
    node.labelWrapper.appendChild(node.label);
    node.header.appendChild(node.labelWrapper);


    node.labelWrapper.addEventListener('pointerdown', e =>
    {
        e.preventDefault();
    });

    
    node.labelWrapper.addEventListener('pointermove', e =>
    {
        if (!node.scrollName)
            return;

        const wrect      = boundingRect(node.labelWrapper);
        const margin     = 14;
        const viewMargin = margin * graphView.zoom;
        
        const x          = e.clientX - wrect.x;

             if (x <  viewMargin)               updateHeaderLabelOffset(node, 0);
        else if (x >= wrect.width - viewMargin) updateHeaderLabelOffset(node, 1);
        else if (x >= viewMargin
              && x <  wrect.width - viewMargin) updateHeaderLabelOffset(node, (x - viewMargin) / (wrect.width - viewMargin*2));
        else                                    updateHeaderLabelOffset(node);
    });


    initLabelTextbox(node);
}



function updateHeaderLabelOffset(node, f = node.labelOffsetFactor)
{
    //console.log('updateHeaderLabelOffset('+f+')');

    node.labelOffsetFactor = Math.min(Math.max(0, f), 1);

    const margin     = 15;
    const viewMargin = margin * graphView.zoom;

    const wrect      = boundingRect(node.labelWrapper);
    const rect       = boundingRect(node.label);

    const rw         = wrect.width - viewMargin*2;
    const sf         = rw / nozero(rect.width);
    const df         = viewMargin / rect.width / 2;
        
    const s1         = node.labelOffsetFactor * (rect.width - rw) / rect.width;
    const s0         = s1 - df;
    const s2         = s1 + sf;
    const s3         = s2 + df;


    if (rect.width > rw)
    {
        node.label.style.left = margin - node.labelOffsetFactor * (rect.width - rw - 1) / graphView.zoom;
        node.label.style.transform = 'translateY(calc(-50% - 0.5px))';
    }
    else
    {
        node.label.style.left = '50%';
        node.label.style.transform = 
              'translateX(-50%) '
            + 'translateY(calc(-50% - 0.5px))';
    }


    const color = 
        node.label.style.color.trim() != ''
        ? node.label.style.color
        : 'black';

    node.label.style.background = 
          'linear-gradient(90deg, '
        + '#0000 ' + (s0 * 100) + '%, '
        + color + ' ' + (s1 * 100) + '%, '
        + color + ' ' + (s2 * 100) + '%, '
        + '#0000 ' + (s3 * 100) + '%)';

    node.label.style.WebkitBackgroundClip = 'text';
    node.label.style.WebkitTextFillColor  = 'transparent';
}


function initLabelTextbox(node)
{
    node.textbox = createTextbox('nodeLabelTextbox');

    node.textbox.spellcheck     = false;
    node.textbox.keyboardFinish = false;
    


    node.textbox.addEventListener('keydown', function(e)
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
        {
            node.textbox.keyboardFinish = true;
            node.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            node.textbox.keyboardFinish = true;
            node.textbox.finish(false);
        }

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            var tabs  = document.querySelectorAll('.node, .figmaSelect, .menuSelect #hexValue, button');
            var index = node.tabIndex;

            for (var i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'node')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else if (e.key == 'Alt')
            e.preventDefault();
    });


    
    // node.textbox.addEventListener('input', function()
    // {
    //     node.setValue(parseFloat(node.textbox.value));
    // });



    node.textbox.addEventListener('pointerdown', e => e.stopPropagation());
    node.textbox.addEventListener('pointermove', e => node.textbox.style.cursor = 'default');



    node.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        var val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(node.min, val), node.max);

        node.textbox.value = isNaN(val) ? '' : val;
    });

    
    
    node.textbox.addEventListener('focus', () => node.textbox.keyboardFinish = false);

    
    
    node.textbox.addEventListener('focusout', function()
    {
        if (    node.textbox.value != ''
            && !node.textbox.keyboardFinish)
            node.textbox.finish(true);

        node.label.style.display = 'block';

        node.header.removeChild(node.textbox);
        node.clicked = false;
    });
    


    node.textbox.finish = function(success)
    {
        const enteredValue = node.textbox.value;
        const   savedValue = node.textbox.savedValue;

        if (success) 
        {
            if (   enteredValue != ''
                && enteredValue != savedValue)
            {
                const newName = node.textbox.value;
                setTimeout(() => node.setName(newName));
                actionManager.do(new RenameNodeAction(node.id, newName));
            }
        }
        else
            node.textbox.value = node.textbox.savedValue;


        node.textbox.dispatchEvent(new CustomEvent('finishedit', { 'detail': {
            'success':  success,
            'value':    enteredValue,
            'oldValue': savedValue }}));
    

        node.textbox.blur();
        
        node.label.style.display = 'block';

        setTimeout(() => 
        {
            node.updateHeaderLabel();
            
            if (node.inFocus)
                node.focus();
        });
    };    
 
    
    
    node.showLabelTextbox = function()
    {
        node.inFocus = 
                hasFocus(node)
            && !node.clicked;
    
        node.textbox.style.width           = node.header.offsetWidth  - 2;
        node.textbox.style.height          = node.header.offsetHeight - 4;
        node.textbox.style.position        = 'absolute';
        node.textbox.style.left            = '50%';
        node.textbox.style.top             = '50%';
        node.textbox.style.transform       = 'translateX(-50%) translateY(-50%)';
        node.textbox.style.textAlign       = 'center';
        //node.textbox.style.boxShadow       = '0 0 0 1px #a0a inset';

        node.textbox.style.backgroundColor = node.header.style.backgroundColor;
        node.textbox.style.color           = node.label.style.color;

        node.textbox.value                 = node.name;
        node.textbox.savedValue            = node.textbox.value;
        
        node.header.appendChild(node.textbox);

        node.label.style.display           = 'none';
        
        node.updateNode();
        
        node.textbox.focus();
        node.textbox.select();
    }
}


class   OpComment
extends OperatorBase
{
    constructor()
    {
        super(COMMENT, 'comment', 0);


        //this.div.style.pointerEvents = 'auto';

        this.scrollName = false;


        this.textbox.addEventListener('input', e =>
        {
            this.updateNode();
            graphView.updateNodeTransform(this);
        });


        this.textbox.addEventListener('change', e =>
        {
            if (this.textbox.value.trim() == '')
                actionManager.do(new DeleteNodesAction([this.id]), true);
        });
    }



    setSelected(sel)
    {
        this._selected = sel;
        this.div.style.boxShadow = 'none';
    }



    updateNode()
    {
        super.updateNode();


        this.inner.style.boxShadow = 'none';


        const cnv = this.canvas || (this.canvas = document.createElement("canvas"));
        const ctx = cnv.getContext("2d");
        
        ctx.font = '11px Inter';
        
        const mes = ctx.measureText(
            hasFocus(this.textbox) 
            ? this.textbox.value 
            : this.name);

        this.div    .style.width   =
        this.textbox.style.width   = Math.max(1, mes.width) + 'px';

        this.textbox.style.height  = this.div.offsetHeight;
        this.textbox.style.padding = '0';
        this.textbox.style.margin  = '2px 0 0 0';

        this.textbox.style.boxShadow = 'none';
    }



    updateHeader()
    {
        this.header.style.overflow   = 'visible';
        this.header.style.background = 'transparent';
       
        this.updateHeaderLabel();
    }



    updateHeaderLabel()
    {
        this.label.innerHTML = this.name;


        if (this.selected)
        {
            this.label.style.color        = rgb2style_a(hex2rgb(colFigmaBlue), 0.7);
            this.label.style.textShadow   = '0 0 0 ' + colFigmaBlue;

            this.textbox.style.color      = rgb2style_a(hex2rgb(colFigmaBlue), 0.7);
            this.textbox.style.textShadow = '0 0 0 ' + colFigmaBlue;
        }
        else
        {
            this.label.style.color        = '#666';
            this.label.style.textShadow   = 'none';

            this.textbox.style.color      = '#666';
            this.textbox.style.textShadow = 'none';
        }
    

        this.label.style.background           = 'transparent';
        this.label.style.textAlign            = 'left';

        this.label.style.left                 = '0';
        this.label.style.top                  = '0';

        this.label.style.transform            = 'none';

        this.label.style.WebkitBackgroundClip = 'inherit';
        this.label.style.WebkitTextFillColor  = 'inherit';
    }
}


class   OpNumber
extends OperatorBase
{
    paramValue;



    constructor()
    {
        super(NUMBER, 'num', 70);

        this.addInput (new Input ([NUMBER], this.input_getValuesForUndo));
        this.addOutput(new Output(NUMBER, this.output_genRequest));

        this.addParam(this.paramValue = new NumberParam('value', '', false, false, false));
        
        this.alwaysLoadParams = true;
    }



    input_getValuesForUndo()
    {
        return [[
            this.node.paramValue.id, 
            this.node.paramValue.value]];
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });
        
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        if (input.connected) request.push(...pushInputOrParam(input, gen));
        else                 request.push(...this.node.paramValue.genRequest(gen));


            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        const index = paramIds.indexOf('value');
 
        if (index > -1) 
            this.outputs[0].cache = [NUMBER_VALUE, values[index].toString()];
    }



    // updateNode()
    // {
    //     this.paramValue.control.readOnly = this.inputs[0].connected;
    //     enableElementText(this.paramValue.control, !this.inputs[0].connected);

    //     super.updateNode();
    // }



    paramIsConsideredDefault(param)
    {
        return param.isDefault()
            && !this.inputs[0].connected;
    }
}


class   OpLimits
extends OperatorBase
{
    paramValue;

    paramMin;
    paramMax;



    constructor()
    {
        super(NUMBER_LIMITS, 'lim', 70);

        this.addInput (new Input ([NUMBER]));
        this.addOutput(new Output(NUMBER, this.output_genRequest));


        this.addParam(this.paramValue = new NumberParam('value', '', false, false, false));
        //this.paramValue.enableControlText(false);
       
        this.addParam(this.paramMin = new NumberParam('min', 'min', true, true, true, 0));
        this.addParam(this.paramMax = new NumberParam('max', 'max', true, true, true));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramMin.genRequest(gen));
        request.push(...this.node.paramMax.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        this.paramMax.control.setMin(values[paramIds.indexOf('min')].value, false);
        this.paramMin.control.setMax(values[paramIds.indexOf('max')].value, false);
    }
}


class   OpArithmetic
extends OperatorBase
{
    paramValue;

    _symbol;
    _showOnlySymbol;


    constructor(type, shortName, symbol)
    {
        super(type, shortName, 50);

        this.variableInputs  = true;
        this.alwaysLoadParams = true;

        this._showOnlySymbol  = true;


        this.addNewInput();
        this.addOutput(new Output(NUMBER, this.output_genRequest));
        

        this.addParam(this.paramValue = new NumberParam('value', '', false, false, false));
        //this.paramValue.enableControlText(false);


        this._symbol           = createDiv('arithmeticSymbol');
        this._symbol.innerHTML = symbol;
        this._symbol.clicked0  = false;
        
        this._symbol.addEventListener('pointerenter', () => this._symbol.style.opacity = this._showOnlySymbol ? 1 : 0.65);
        this._symbol.addEventListener('pointerleave', () => this._symbol.style.opacity = 1);

        this._symbol.addEventListener('pointerdown', e => 
        { 
            if (e.button == 0)
            {
                if (this._symbol.clicked0) // finish double click on small symbol
                {
                    this._symbol.clicked0      = false;
                    this._symbol.style.opacity = 1;

                    actionManager.do(new ToggleArithmeticSymbolAction(this.id, true));

                    this.header.ignoreDoubleClick = true;
                }
                else if (!this._showOnlySymbol) // start double cick on small symbol
                {
                    this._symbol.clicked0 = true;
                    setTimeout(() => this._symbol.clicked0 = false, 250); // seems like a good default guess
                }
            }
        });

        this.header.appendChild(this._symbol);

        
        this.textbox.addEventListener('finishedit', e => 
        {
            if (this._showOnlySymbol)
                actionManager.do(new ToggleArithmeticSymbolAction(this.id, false), e.detail.value != e.detail.oldValue);
        });
    }
    
    
    
    addNewInput()
    {
        const input = new Input([NUMBER]);
        input.isNew = true;

        input.addEventListener('connect',    () => { OpArithmetic_onConnectInput(this); input.isNew = false; });
        input.addEventListener('disconnect', () => OpArithmetic_onDisconnectInput(this, input));

        this.addInput(input);

        return input;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            

        const connectedInputs = this.node.inputs.filter(i => i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        if (paramIds.includes('value'))
            this.outputs[0].cache = [NUMBER_VALUE, values[0].toString()];
    }



    updateHeader()
    {
        super.updateHeader();


        const colBack = rgbFromType(this.type, this.active);
        const colText = isDark(colBack) ? [1, 1, 1] : [0, 0, 0];

        this._symbol.style.fontSize   = this._showOnlySymbol ? 17 : 12;
        this._symbol.style.fontWeight = this.active ? 'bold' : 'normal';
        this._symbol.style.color      = rgb2style(colText);
        this._symbol.style.left       = 'calc(50% + 1px)';
        

        const padding         = this.header.connectionPadding;
        const connectedInputs = this.inputs .filter(i => !i.param && i.connected);


        if (connectedInputs.length == 0)
        {
            if (this._showOnlySymbol)
            {
                this._symbol.style.top = 2;
            }
            else
            {
                this._symbol.style.top = -1;
                this.label  .style.top = 'calc(50% + 4px)';
            }
        }
        else
        {
            const [connectedInputY, connectedInputHeight] = getHeaderConnY(connectedInputs, padding, 5);

            if (this._showOnlySymbol)
            {
                this._symbol.style.top = connectedInputY[0]/2 + connectedInputHeight/2 - 9;
            }
            else
            {
                this._symbol.style.top = connectedInputY[0]/2 + connectedInputHeight/2 - 6;
                this.label  .style.top = 'calc(50% + 5px)';
            }
        }
        

        this.label.style.visibility = this._showOnlySymbol ? 'hidden'  : 'visible';
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"onlySymbol": "' + boolString(this._showOnlySymbol) + '"';
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }



    loadParams(_node)
    {
        if (_node.showOnlySymbol)
            this._showOnlySymbol = isTrue(_node.showOnlySymbol);

        //super.loadParams(_node);
    }
}



function OpArithmetic_onConnectInput(node)
{
    node.addNewInput();
    //node.updateNode();
}



function OpArithmetic_onDisconnectInput(node, input)
{
    removeFromArray(node.inputs, input);
    node.inputControls.removeChild(input.control);
    //node.updateNode();
}


class   OpAdd
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_ADD, 'add', '+');
    }
}


class   OpSubtract
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_SUBTRACT, 'sub', '');
    }
}


class   OpMultiply
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_MULTIPLY, 'mul', '');
    }
}


class   OpDivide
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_DIVIDE, 'div', '');
    }
}


class   OpModulo
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_MODULO, 'mod', '%');
    }
    
    
    
    updateNode()
    {
        super.updateNode();

        // this._symbol.innerHTML =
        //     this._showOnlySymbol
        //     ? '<span style="font-size: 14px;">x</span><span style="position: relative; left: -1px; top: -7px; font-size: 7px; font-weight: bold;">y</span>'
        //     : '<span style="position: relative; top: -1.5px; font-size: 8px;">x</span><span style="position: relative; left: -0.5px; top: -5.15px; font-size: 3.75px; font-weight: bold;">y</span>';

        this._symbol.style.fontSize   = this._showOnlySymbol ? 11 : 8;
        this._symbol.style.fontWeight = 'bold';
        this._symbol.style.left       = 'calc(50% + ' + (this._showOnlySymbol ? 1.5 : 1) + 'px)';
        this._symbol.style.top        = parseFloat(this._symbol.style.top) + (this._showOnlySymbol ? 4 : 4.5);
    }
}


class   OpExponent
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_EXPONENT, 'exp', 'x'); // placeholder symbol, actual symbol set in updateNode()
    }



    updateNode()
    {
        super.updateNode();

        this._symbol.innerHTML =
            this._showOnlySymbol
            ? '<span style="font-size: 14px;">x</span><span style="position: relative; left: -1px; top: -7px; font-size: 7px; font-weight: bold;">y</span>'
            : '<span style="position: relative; top: -2.5px; font-size: 9px;">x</span><span style="position: relative; left: -0.5px; top: -7.5px; font-size: 3.75px; font-weight: bold;">y</span>';

        this._symbol.style.left = 'calc(50% + ' + (this._showOnlySymbol ? 1.5 : 1) + 'px)';
        this._symbol.style.top  = parseFloat(this._symbol.style.top) + (this._showOnlySymbol ? 1.5 : 6);
    }
}


// const ops = [ // the order is important for logical keyboard value changes
//     [NUMBER_SUBTRACT, '-'],
//     [NUMBER_ADD,      '+'],
//     [NUMBER_DIVIDE,   ''],
//     [NUMBER_MULTIPLY, ''],
//     [NUMBER_MODULO,   '%'],
//     [NUMBER_EXPONENT, 'x'] ];



class   OpMath
extends OperatorBase
{
    paramOperation;
    paramValue;



    constructor(type, shortName)
    {
        super(type, shortName, 50);

        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output(NUMBER, this.output_genRequest));
        
        this.addParam(this.paramOperation = new SelectParam('op',    '', false, true, true, [OpColorSpaces.map(s => s[1])], 0));
        this.addParam(this.paramValue     = new NumberParam('value', '', false, false, false));

        //this.paramValue.enableControlText(false);


        this._symbol           = createDiv('arithmeticSymbol');
        this._symbol.innerHTML = symbol;
        this._symbol.clicked0  = false;
        
        this._symbol.addEventListener('pointerenter', () => this._symbol.style.opacity = this._showOnlySymbol ? 1 : 0.65);
        this._symbol.addEventListener('pointerleave', () => this._symbol.style.opacity = 1);

        this._symbol.addEventListener('pointerdown', e => 
        { 
            if (e.button == 0)
            {
                if (this._symbol.clicked0) // finish double click on small symbol
                {
                    this._symbol.clicked0      = false;
                    this._symbol.style.opacity = 1;

                    actionManager.do(new ToggleArithmeticSymbolAction(this.id, true));

                    this.header.ignoreDoubleClick = true;
                }
                else if (!this._showOnlySymbol) // start double cick on small symbol
                {
                    this._symbol.clicked0 = true;
                    setTimeout(() => this._symbol.clicked0 = false, 250); // seems like a good default guess
                }
            }
        });

        this.header.appendChild(this._symbol);

        
        this.textbox.addEventListener('finishedit', e => 
        {
            if (this._showOnlySymbol)
                actionManager.do(new ToggleArithmeticSymbolAction(this.id, false), e.detail.value != e.detail.oldValue);
        });
    }
    
    
    
    addNewInput()
    {
        const input = new Input([NUMBER]);
        input.isNew = true;

        input.addEventListener('connect',    () => { onConnectInput(this); input.isNew = false; });
        input.addEventListener('disconnect', () => onDisconnectInput(this, input));

        this.addInput(input);

        return input;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;

        const connectedInputs  = this.node.inputs.filter(i => i.connected);


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...input.connectedOutput.genRequest(gen)));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        if (paramIds.includes('value'))
            this.outputs[0].cache = [NUMBER_VALUE, values[0].toString()];
    }



    updateHeader()
    {
        super.updateHeader();


        const colBack = rgbFromType(this.type, this.active);
        const colText = isDark(colBack) ? [1, 1, 1] : [0, 0, 0];

        this._symbol.style.fontSize   = this._showOnlySymbol ? 17 : 12;
        this._symbol.style.fontWeight = this.active ? 'bold' : 'normal';
        this._symbol.style.color      = rgb2style(colText);
        this._symbol.style.left       = 'calc(50% + 1px)';
        

        const padding         = this.header.connectionPadding;
        const connectedInputs = this.inputs .filter(i => !i.param && i.connected);


        if (connectedInputs.length == 0)
        {
            if (this._showOnlySymbol)
            {
                this._symbol.style.top = 2;
            }
            else
            {
                this._symbol.style.top = -1;
                this.label  .style.top = 'calc(50% + 4px)';
            }
        }
        else
        {
            const [connectedInputY, connectedInputHeight] = getHeaderConnY(connectedInputs, padding, 5);

            if (this._showOnlySymbol)
            {
                this._symbol.style.top = connectedInputY[0]/2 + connectedInputHeight/2 - 9;
            }
            else
            {
                this._symbol.style.top = connectedInputY[0]/2 + connectedInputHeight/2 - 6;
                this.label  .style.top = 'calc(50% + 5px)';
            }
        }
        

        this.label.style.visibility = this._showOnlySymbol ? 'hidden' : 'visible';
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"onlySymbol": "' + boolString(this._showOnlySymbol) + '"';
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }



    loadParams(_node)
    {
        if (_node.showOnlySymbol)
            this._showOnlySymbol = isTrue(_node.showOnlySymbol);

        //super.loadParams(_node);
    }
}



function onConnectInput(node)
{
    node.addNewInput();
    //node.updateNode();
}



function onDisconnectInput(node, input)
{
    removeFromArray(node.inputs, input);
    node.inputControls.removeChild(input.control);
    //node.updateNode();
}


class   OpInterpolate
extends OperatorBase
{
    paramValue;
    paramAmount;



    constructor()
    {
        super(NUMBER_INTERPOLATE, 'inter', 70);

        this.addInput(new Input([NUMBER]));
        this.addInput(new Input([NUMBER]));

        this.addOutput(new Output(NUMBER, this.output_genRequest));

        this.addParam(this.paramValue  = new NumberParam('value', '', false, false, false, 0));
        this.addParam(this.paramAmount = new NumberParam('amount', '', true,  true,  true, 50, 0, 100, 0));

        //this.paramValue.enableControlText(false);
        
        this.paramAmount.control.min = Number.MIN_SAFE_INTEGER; // allow
        this.paramAmount.control.max = Number.MAX_SAFE_INTEGER; // extrapolation
        
        this.paramAmount.control.setSuffix('%', true);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramAmount.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        if (paramIds.includes('value'))
            this.outputs[0].cache = [NUMBER_VALUE, values[0].toString()];
    }
}


class OpColorBase
extends Operator
{
    _color = dataColor_NaN;

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;
    


    constructor(nodeType, shortType, type, defWidth = 80)
    {
        super(nodeType, shortType, type, defWidth);


        this._warningOverlay = createDiv('colorWarningOverlay');
        this._warningOverlay.style.zIndex = 1;
        this.inner.appendChild(this._warningOverlay);


        this.header.addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.header.addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });
    }



    updateValues(updateParamId, paramIds, values)
    {
        //logFunction('OpColorBase.updateValues()');

        super.updateValues(updateParamId, paramIds, values);
        
        this.updateHeader();
    }



    updateHeader()
    {
        //console.log(this.id + '.OpColorBase.updateHeader()');

        super.updateHeader();


        const colors = this.getHeaderColors();


        this.header.style.background = 
              rgbIsOk(colors.back)
            ? rgb2style(colors.back)
            : 'transparent';


        for (const input of this.inputs.filter(i => !i.param))
        {
            input.colorLight =
            input.colorDark  = colors.input;

            input.wireColor  = colors.wire;
        }


        for (const output of this.outputs.filter(o => !o.param))
        {
            output.colorLight = 
            output.colorDark  = colors.output;

            output.wireColor  = colors.wire;
        }


        this.updateWarningOverlay();
    }



    getHeaderColors(options = {})
    {
        const noColor = 
            isDarkMode()
            ? rgbNoColorDark
            : rgbNoColorLight;

        const rgbBack = 
            dataColorIsNaN(this._color)
            ? rgb_NaN
            : dataColor2rgb(this._color);
            
        const rgbText = getTextColorFromBackColor(rgbBack);

        const rgbaWire = 
            !rgbIsNaN(rgbBack)   
            ? rgbBack 
            : noColor;

        return {
            back:   rgb_a(rgbBack, 1  ), 
            text:   rgb_a(rgbText, 0.9),
            input:  rgb_a(rgbText, 0.2),
            output: rgb_a(rgbText, 0.2),
            wire:   rgbaWire };
    }



    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgb = dataColor2rgb(this._color);

        if (!rgbIsNaN(rgb))
        {
            if (  !rgbIsValid(rgb)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgb);

                this.updateWarningOverlayStyle(rgb);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgb);
            this.updateWarningOverlayStyle(rgb);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? this.header.offsetHeight
            : height;

        this._warningOverlay.style.background =
                rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : 'repeating-linear-gradient('
               + '-45deg, '
               + 'transparent 0 7px,'
               +  this.warningStyle + ' 7px 14px)';

        this._warningOverlay.style.display = 'block';
    }
}


class   OpColor
extends OpColorBase
{
    paramSpace;
    param1;
    param2;
    param3;
    paramColor;

    colorBack;


    //hexbox;

    
    prevSpace;
    prevSpaceConnections = [];


    _colorBeforeNaN = dataColor_NaN;



    constructor(options = {})
    {
        super(COLOR, 'color');


        const defColor = ['hex', 0.788, 0.788, 0.788];

        this._color = 
            !!options.random
            ? ['hex', Math.random(), Math.random(), Math.random()]
            : [...defColor];
        
        this.prevSpace =  'hex';


        this.colorBack = createDiv('colorBack');
        this.inner.appendChild(this.colorBack);


        this.addInput(new Input(COLOR_TYPES, this.input_getValuesForUndo));
        this.addOutput(new Output(COLOR, this.output_genRequest));

        
        this.addParam(this.paramSpace = new SelectParam('space', '', false, true,  true,  OpColorSpaces.map(s => s[1]), 0));
        this.addParam(this.param1     = new NumberParam('c1',    '', true,  true,  true,  Math.round(defColor[1] * rgbFactor[0])));
        this.addParam(this.param2     = new NumberParam('c2',    '', true,  true,  true,  Math.round(defColor[2] * rgbFactor[1])));
        this.addParam(this.param3     = new NumberParam('c3',    '', true,  true,  true,  Math.round(defColor[3] * rgbFactor[2])));
        this.addParam(this.paramColor = new ColorParam ('color', '', false, false, false, ColorValue.fromRgb(scaleRgb(dataColor2rgb(this._color)))));

        this.param1.setValue(new NumberValue(Math.round(this._color[1] * rgbFactor[0])), false, true, false);
        this.param2.setValue(new NumberValue(Math.round(this._color[2] * rgbFactor[1])), false, true, false);
        this.param3.setValue(new NumberValue(Math.round(this._color[3] * rgbFactor[2])), false, true, false);


        this.paramSpace.control.barTop = 0.8;

        this.paramSpace.control.wheelScale = 1;
        this.param1    .control.wheelScale = 1;
        this.param2    .control.wheelScale = 1;
        this.param3    .control.wheelScale = 1;


        this.paramSpace.control.addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.paramSpace.control.addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });


        // hex is default, remove default sliders
        this.inner.removeChild(this.param1.div);
        this.inner.removeChild(this.param2.div);
        this.inner.removeChild(this.param3.div);

        
        this.paramColor.control.showColor = false;

        this.paramColor.addEventListener('change', () => 
        {
            this._color = this.paramColor.value.toDataColor();

            this.param1.setValue(new NumberValue(this._color[1] * rgbFactor[0]), false, true, false);
            this.param2.setValue(new NumberValue(this._color[2] * rgbFactor[1]), false, true, false);
            this.param3.setValue(new NumberValue(this._color[3] * rgbFactor[2]), false, true, false);
        });
    }



    getDataColorFromParams()
    {
        const col = getNormalColor_(
            colorSpace(this.paramSpace.value),
            this.param1.value,
            this.param2.value,
            this.param3.value);
    
        return [
            colorSpace(this.paramSpace.value),
            col[0],
            col[1],
            col[2] ];
    }
    
    
    
    setColorParams(color, fireChangeEvent = false)
    {
        const col = getScaledDataColor(color);

        this.param1.setValue(new NumberValue(col[1]), fireChangeEvent);
        this.param2.setValue(new NumberValue(col[2]), fireChangeEvent);
        this.param3.setValue(new NumberValue(col[3]), fireChangeEvent);
    }



    isConnected()
    {
        return this.inputs[0].connected
            //   skipping [1]
            || this.inputs[2].connected
            || this.inputs[3].connected
            || this.inputs[4].connected;
    }



    input_getValuesForUndo()
    {
        return [ 
            [this.node.param1.id, 
             this.node.param1.value],

            [this.node.param2.id, 
             this.node.param2.value],

            [this.node.param3.id, 
             this.node.param3.value]];
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        const paramIds = [];


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));
            
            paramIds.push(this.node.paramSpace.id);

            for (const param of this.node.params.filter(p => p.id != this.node.paramSpace.id))
                if (   param.input 
                    && param.input.connected) 
                    paramIds.push(param.id);

            request.push(paramIds.join(','));
            
                                                  request.push(...this.node.paramSpace.genRequest(gen));
            if (this.node.param1.input.connected) request.push(...this.node.param1    .genRequest(gen));
            if (this.node.param2.input.connected) request.push(...this.node.param2    .genRequest(gen));
            if (this.node.param3.input.connected) request.push(...this.node.param3    .genRequest(gen));
        }
        else
        {
            if (this.node.paramSpace.value == 0) // hex
            {
                request.push(
                    ...this.node.paramSpace.genRequest(gen),
                    NUMBER_VALUE, numToString(colorSpaceIndex(this.node.prevSpace)),
                    NUMBER_VALUE, numToString(this.node._color[1] * rgbScale[0]),
                    NUMBER_VALUE, numToString(this.node._color[2] * rgbScale[1]),
                    NUMBER_VALUE, numToString(this.node._color[3] * rgbScale[2]));
            }
            else
            {
                request.push(
                    ...this.node.paramSpace.genRequest(gen),
                    NUMBER_VALUE, numToString(colorSpaceIndex(this.node.prevSpace)), 
                    ...this.node.param1.genRequest(gen),
                    ...this.node.param2.genRequest(gen),
                    ...this.node.param3.genRequest(gen));
            }
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        const space = values[paramIds.findIndex(id => id == 'space')];
        const c1    = values[paramIds.findIndex(id => id == 'c1'   )];
        const c2    = values[paramIds.findIndex(id => id == 'c2'   )];
        const c3    = values[paramIds.findIndex(id => id == 'c3'   )];


        this.paramSpace.setValue(space, false, true, false);
        switchToSpace(this, colorSpace(space.value));


        this.param1.setValue(c1, false, true, false);
        this.param2.setValue(c2, false, true, false);
        this.param3.setValue(c3, false, true, false);


        const valid =
               space.isValid()
            && c1   .isValid()
            && c2   .isValid()
            && c3   .isValid();

            
        if (!valid)
            this.paramColor.setValue(ColorValue.NaN, false, true, false);


        this._color = 
            valid
            ? makeDataColor(space, c1, c2, c3)
            : dataColor_NaN;


        this.prevSpace = colorSpace(space.value);


        super.updateValues(updateParamId, paramIds, values);
    }



    updateNode()
    {
        //console.log(this.id + '.OpColor.updateNode()');
        
        super.updateNode();


        if (!hasFocus(this.paramColor.control))
            this.paramColor.setValue(ColorValue.fromRgb(scaleRgb(dataColor2rgb(this._color))), false, true, false);// = 
        

        const colors = this.getHeaderColors();

        const colSpaceBar = 
                isDark(colors.back)
            && !rgbIsNaN(colors.back)
            ? [1, 1, 1, 0.12]
            : [0, 0, 0, 0.09]; 


        this.paramSpace.control.setMax(colorSpaceCount()-1);


        this.paramSpace.control. backStyleLight =
        this.paramSpace.control. backStyleDark  = 'transparent';

        this.paramSpace.control.valueStyleLight =
        this.paramSpace.control.valueStyleDark  = rgba2style(colSpaceBar);

        this.paramSpace.control. textStyleLight =
        this.paramSpace.control. textStyleDark  = rgba2style(colors.text);


        this.paramSpace.input .colorLight =
        this.paramSpace.input .colorDark  = colors.input;

        this.paramSpace.output.colorLight =
        this.paramSpace.output.colorDark  = colors.output;


        this.paramSpace.updateControls();
    }



    updateHeader()
    {
        //console.log(this.id + '.OpColor.updateHeader()');

        super.updateHeader();

        
        this.header.style.background = 'transparent';
    
        const colors = this.getHeaderColors();

        
        this.colorBack.style.background = 
            !rgbIsNaN(colors.back)
            ? rgb2style(colors.back)
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));

        this.label.style.color = rgb2style(colors.text);
        
        this.inputs[0] .colorLight =
        this.inputs[0] .colorDark  = colors.input;

        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = colors.output; 


        const colWarning = 
            isDark(colors.back)
            ? [1, 1, 1, 0.2 ]
            : [0, 0, 0, 0.12]; 

        this.warningStyle = 
            rgbIsValid(colors.back) 
            ? 'transparent' 
            : rgba2style(colWarning);


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colors.back, 45);
    }



    updateParams()
    {
        this.updateAllControlRanges();

        this.param1.updateControls();
        this.param2.updateControls();
        this.param3.updateControls();

        this.param1.enableControlText(!this.inputs[0].connected);
        this.param2.enableControlText(!this.inputs[0].connected);
        this.param3.enableControlText(!this.inputs[0].connected);

        enableElementText(this.paramColor.control, !this.isConnected());

        super.updateParams();
    }



    resetAllControlRanges()
    {
        resetControlRanges(this.param1.control);
        resetControlRanges(this.param2.control);
        resetControlRanges(this.param3.control);
    }



    getWarnLineStyle()
    {
        return isDarkMode()
            ? 'rgba(255, 96, 96, 0.5)'
            : 'rgba(255, 0, 0, 0.16)';
    }



    updateAllControlRanges()
    {
        const warnLineStyle = this.getWarnLineStyle();

        const space = this.paramSpace.value.value;

        if (    space == 1
            && !dataColorIsNaN  (this._color)
            && !dataColorIsValid(this._color)) // RGB warning ranges
        {
            const rangesR = [];
            if (this._color[1] < 0) rangesR.push(new NumberControlRange(0, Math.min(-this._color[1], 1), warnLineStyle, 0.8));
            if (this._color[1] > 1) rangesR.push(new NumberControlRange(2-Math.min(this._color[1], 2), 1, warnLineStyle, 0.8));
            this.param1.control.ranges = rangesR;

            const rangesG = [];
            if (this._color[2] < 0) rangesG.push(new NumberControlRange(0, Math.min(-this._color[2], 1), warnLineStyle, 0.8));
            if (this._color[2] > 1) rangesG.push(new NumberControlRange(2-Math.min(this._color[2], 2), 1, warnLineStyle, 0.8));
            this.param2.control.ranges = rangesG;
            
            const rangesB = [];
            if (this._color[3] < 0) rangesB.push(new NumberControlRange(0, Math.min(-this._color[3], 1), warnLineStyle, 0.8));
            if (this._color[3] > 1) rangesB.push(new NumberControlRange(2-Math.min(this._color[3], 2), 1, warnLineStyle, 0.8));
            this.param3.control.ranges = rangesB;
        }
        else if ((   space == 2  // HSV
                  || space == 3) // HSL
              && !dataColorIsNaN  (this._color)
              && !dataColorIsValid(this._color))
        {
            const rangesS = [];
            if (this._color[2] < 0) rangesS.push(new NumberControlRange(0, Math.min(-this._color[2], 1), warnLineStyle, 0.8));
            if (this._color[2] > 1) rangesS.push(new NumberControlRange(2-Math.min(this._color[2], 2), 1, warnLineStyle, 0.8));
            this.param2.control.ranges = rangesS;
            
            const rangesVL = [];
            if (this._color[3] < 0) rangesVL.push(new NumberControlRange(0, Math.min(-this._color[3], 1), warnLineStyle, 0.8));
            if (this._color[3] > 1) rangesVL.push(new NumberControlRange(2-Math.min(this._color[3], 2), 1, warnLineStyle, 0.8));
            this.param3.control.ranges = rangesVL;
        }
        else if ( space > 3 // HCL
              && !dataColorIsNaN(this._color))
        {
            this.updateControlRanges(this.param1.control, f =>
                dataColor2rgb([
                    this._color[0],
                    (this.param1.control.displayMin + f * (this.param1.control.displayMax - this.param1.control.displayMin)) / getColorSpaceFactor(this._color[0])[0],
                    this._color[2],
                    this._color[3]]));

            this.updateControlRanges(this.param2.control, f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    (this.param2.control.displayMin + f * (this.param2.control.displayMax - this.param2.control.displayMin)) / getColorSpaceFactor(this._color[0])[1],
                    this._color[3]]));

            this.updateControlRanges(this.param3.control, f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    this._color[2],
                    (this.param3.control.displayMin + f * (this.param3.control.displayMax - this.param3.control.displayMin)) / getColorSpaceFactor(this._color[0])[2]]));
        }
        else // no warning ranges
        {
            this.resetAllControlRanges();
        }
    }



    updateControlRanges(control, getRgb)
    {
        const warnLineStyle = this.getWarnLineStyle();


        const ranges    = [];
 
        
        const precision = 0.01;
        let   open      = false;

        for (let f = 0; f <= 1; f += precision)
        {
            const rgb = getRgb(f);

            if (!open && !rgbIsValid(rgb))
            {
                ranges.push(new NumberControlRange(f, f, warnLineStyle, 0.8));
                open = true;
            }
            else if (open && rgbIsValid(rgb)) 
            {
                ranges[ranges.length-1].end = f;
                open = false;
            }
        }

        
        if (open)
            lastOf(ranges).end = 1;
        else if (!open
              && ranges.length == 0)
            resetControlRanges(control);


        control.ranges = ranges;
    }



    paramIsConsideredDefault(param)
    {
        return super.paramIsConsideredDefault(param)
            && !this.inputs[0].connected
            && (  !this.paramSpace.input.connected
                || this.paramSpace.value == 0);
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        let json = super.toJsonBase(nTab);

        json += ',\n' + pos + tab + '"prevSpace": "' + this.prevSpace + '"';

        if (!dataColorIsNaN(this._colorBeforeNaN))
            json += ',\n' + pos + tab + '"colorBeforeNaN":\n' + dataColorToJson(this._colorBeforeNaN, 4);

        return json;
    }



    paramsToJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;


        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
        

        let first = true;
        for (let i = 0; i < this.params.length-1; i++) // -1 is for paramColor
        {
            const param = this.params[i];

            if (!this.paramIsConsideredDefault(param))
            {
                if (!first) json += ',\n'; first = false;

                json += 
                      pos + tab + tab 
                    + param.toJson(nTab, i > 0 ? 'c' + i : '');
            }
        }


        if (!first)
            json += '\n';

        json += pos + tab + ']';


        return json;
    }



    loadParams(_node)
    {
        if (_node.colorBeforeNaN)
            this._colorBeforeNaN = _node.colorBeforeNaN;

        this.prevSpace = _node.prevSpace;


        super.loadParams(_node);


        const space  = colorSpace(Math.max(1, this.paramSpace.value.value));
        const factor = colorFactor(space);

        this._color = [
            space,
            this.param1.value.value / factor[0],
            this.param2.value.value / factor[1],
            this.param3.value.value / factor[2]];
    }
}


const OpColorSpaces = 
[
    ['hex',    'Hex'   ],
    ['rgb',    'RGB'   ], 
    ['hsv',    'HSV'   ], 
    ['hsl',    'HSL'   ], 
    ['hclokl', 'HCL/ok'],
    ['hcllab', 'HCL/ab'],
    ['hclluv', 'HCL/uv'],
    ['oklab',  'okLab' ],
    ['lab',    'Lab'   ],
    ['luv',    'Luv'   ]
];



function colorSpace     (index) { return OpColorSpaces[index][0]; }
function colorSpaceIndex(space) { return OpColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.enableLxxColorSpaces 
           ? OpColorSpaces.length
           : OpColorSpaces.length - 3; 
}



const rgbFactor   = [255, 255, 255];
const hs_Factor   = [360, 100, 100];
const hclFactor   = [360, 100, 100];
const oppFactor   = [100, 100, 100];


const rgbScale    = [255, 255, 255];

const hs_Scale    = [360, 100, 100];

const hcloklScale = [360,  51, 100];
const hcllabScale = [360, 400, 100];
const hclluvScale = [360, 330, 100];

const oklabScale  = [100,  30,  30];
const labScale    = [100, 100, 100];
const luvScale    = [100, 150, 150];



function colorFactor(space)
{
    switch (space)
    {
        case 'hex':    return rgbFactor;   
        case 'rgb':    return rgbFactor;

        case 'hsv':    return hs_Factor;   
        case 'hsl':    return hs_Factor;

        case 'hclokl': return hclFactor;
        case 'hcllab': return hclFactor;
        case 'hclluv': return hclFactor;

        case 'oklab':  return oppFactor; 
        case 'lab':    return oppFactor;   
        case 'luv':    return oppFactor;   
        
        default:       console.assert(false, 'invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    scale = rgbScale;    break;
        case 'rgb':    scale = rgbScale;    break;

        case 'hsv':    scale = hs_Scale;    break;
        case 'hsl':    scale = hs_Scale;    break;

        case 'hclokl': scale = hcloklScale; break;
        case 'hcllab': scale = hcllabScale; break;
        case 'hclluv': scale = hclluvScale; break;

        case 'oklab':  scale = oklabScale;  break;
        case 'lab':    scale = labScale;    break;
        case 'luv':    scale = luvScale;    break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function scaleRgb(rgb)
{
    return scaleColor(rgb, 'rgb');
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':    switchToHex   (node); break;
        case 'rgb':    switchToRgb   (node); break;

        case 'hsv':    switchToHsv   (node); break;
        case 'hsl':    switchToHsl   (node); break;

        case 'hclokl': switchToHclOkl(node); break;
        case 'hcllab': switchToHclLab(node); break;
        case 'hclluv': switchToHclLuv(node); break;

        case 'oklab':  switchToOklab (node); break;
        case 'lab':    switchToLab   (node); break;
        case 'luv':    switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex   (node) { switchToTextbox       (node);           }
function switchToRgb   (node) { switchToRgbControls   (node);           }

function switchToHsv   (node) { switchToHs_Controls   (node, 'V');      }
function switchToHsl   (node) { switchToHs_Controls   (node, 'L');      }

function switchToHclOkl(node) { switchToHclOklControls(node);           }
function switchToHclLab(node) { switchToHclLabControls(node);           }
function switchToHclLuv(node) { switchToHclLuvControls(node);           }

function switchToOklab (node) { switchToOklabControls (node, 'a', 'b'); }
function switchToLab   (node) { switchToLabControls   (node, 'a', 'b'); }
function switchToLuv   (node) { switchToLuvControls   (node, 'u', 'v'); }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.control.min = 
    node.param2.control.min = 
    node.param3.control.min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.control.max = 
    node.param2.control.max = 
    node.param3.control.max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param2.control.min = 
    node.param3.control.min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.control.max = 
    node.param3.control.max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hcloklScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hcllabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hclluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.control.showHex = show;
    node.param2.control.showHex = show;
    node.param3.control.showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.control.wrapValue = c1wrap;
    node.param1.control.setSuffix(c1suffix, c1suffix != '');

    node.param1.control.setMin(c1min, false); 
    node.param2.control.setMin(c2min, false);
    node.param3.control.setMin(c3min, false);
    
    node.param1.control.setMax(c1max, false); 
    node.param2.control.setMax(c2max, false); 
    node.param3.control.setMax(c3max, false); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();
}



function switchToTextbox(node)
{
    if (!node.inner.contains(node.paramColor.div))
    {
        removeOpColorParamWires(node);

        node.inner.removeChild(node.param1.div);
        node.inner.removeChild(node.param2.div);
        node.inner.removeChild(node.param3.div);
        
        node.inner.appendChild(node.paramColor.div);
    }
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    if (node.inner.contains(node.paramColor.div))
    {
        node.inner.removeChild(node.paramColor.div);

        node.inner.appendChild(node.param1.div);
        node.inner.appendChild(node.param2.div);
        node.inner.appendChild(node.param3.div);

        node.updateNode();
    }
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':    return getNormalValueHs_ (value, chan);

        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':    return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':    return getNormalColorHs_(c1, c2, c3);

        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':    return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':    return getScaledDataColorRgb(          color[1], color[2], color[3]);

        case 'hsv':    return getScaledDataColorHs_('hsv',    color[1], color[2], color[3]);
        case 'hsl':    return getScaledDataColorHs_('hsl',    color[1], color[2], color[3]);

        case 'hclokl': return getScaledDataColorHcl('hclokl', color[1], color[2], color[3]);
        case 'hcllab': return getScaledDataColorHcl('hcllab', color[1], color[2], color[3]);
        case 'hclluv': return getScaledDataColorHcl('hclluv', color[1], color[2], color[3]);

        case 'oklab':  return getScaledDataColorOpp('oklab',  color[1], color[2], color[3]);
        case 'lab':    return getScaledDataColorOpp('lab',    color[1], color[2], color[3]);
        case 'luv':    return getScaledDataColorOpp('luv',    color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function getColorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return rgbFactor;

        case 'hsv':   
        case 'hsl':    return hs_Factor;

        case 'hclokl': 
        case 'hcllab': 
        case 'hclluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':    return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':    return rgbScale;

        case 'hsv':   
        case 'hsl':    return hs_Scale;

        case 'hclokl': return hcloklScale;
        case 'hcllab': return hcllabScale;
        case 'hclluv': return hclluvScale;

        case 'oklab':  return oklabScale;
        case 'lab':    return labScale;
        case 'luv':    return luvScale;
    }    
}


// function initHexbox(node)
// {
//     node.hexbox = createDiv();//createTextbox('hexbox');
    
//     node.hexbox.node = node;
//     //node.hexbox.editing = false;
    
//     // node.hexbox.addEventListener('pointerdown', onHexboxPointerDown);
//     // node.hexbox.addEventListener('pointerup',   onHexboxPointerUp);
//     // node.hexbox.addEventListener('focus',       onHexboxFocus);
//     // node.hexbox.addEventListener('focusout',    onHexboxFocusOut);
//     // node.hexbox.addEventListener('input',       onHexboxInput);
//     // node.hexbox.addEventListener('keydown',     onHexboxKeyDown);
// }



// function onHexboxPointerDown(e)
// {
//     //const hexbox = e.target;

//     if (e.button > 0)
//         e.preventDefault();

//     e.stopPropagation();
// }



// function onHexboxPointerUp(e)
// {
//     const hexbox = e.target;

//     if (    e.button == 0
//         && !hexbox.editing)
//     {
//         e.preventDefault();

//         hexbox.savedValue = hexbox.value;

//         hexbox.focus();
//         hexbox.select();
//         hexbox.editing = true;
//     }
// }



// function onHexboxFocus(e)
// {
//     const hexbox = e.target;
//     hexbox.style.cursor = 'default';

//     if (hexbox.value == DISPLAY_INVALID)
//         hexbox.value = INVALID;
// }



// function onHexboxFocusOut(e)
// {
//     const hexbox = e.target;
//     hexboxFinish(hexbox.node, true);
//     hexbox.style.cursor = 'default';
// }



// function onHexboxInput(e)
// {
//     const hexbox = e.target;
    
//     let val = hexbox.value;

//     if (val.trim() == '')
//         return;

//          if (   val.length > 7 
//              && val[0] == '#') hexbox.value = val.trim().slice(0, 7);
//     else if (val.length > 6)   hexbox.value = val.trim().slice(0, 6);
// }



// function onHexboxKeyDown(e)
// {
//     e.stopPropagation();

    
//     const hexbox = e.target;

//     if (   e.code == 'KeyC'
//         && getCtrlKey(e))
//     {
//         e.preventDefault();
//         document.execCommand('copy');
//     }

//     else if (   e.code == 'KeyV'
//         && getCtrlKey(e)
//         && !hexbox.node.isConnected())
//     {
//         // do nothing and let the OS do its thing
//     }

//     else if ((   e.code == 'Enter'
//               || e.code == 'NumpadEnter')
//            && !hexbox.node.isConnected())
//         hexboxFinish(hexbox.node, true);

//     else if (e.code == 'Escape')
//         hexboxFinish(hexbox.node, false);

//     else if (   e.key.length == 1
//              && !isDigit(e.key)
//              && !isHexDigit(e.key)
//          ||     hexbox.node.isConnected()
//             && !isArrowKey(e.code)
//          ||    e.key != 'ArrowLeft'
//             && e.key != 'ArrowRight'
//             && e.key != 'Delete'
//             && e.key != 'Backspace'
//             && hexbox.value.length >= 6
//             && hexbox.selectionStart == hexbox.selectionEnd)
//         e.preventDefault();
// }



// function hexboxFinish(node, success)
// {
//     if (node.hexbox.value.trim() == '')
//         node.hexbox.value = node.hexbox.savedValue;

        
//     const rgb = hex2rgb(node.hexbox.value);
    
//     if (success) 
//     {
//         setDataColorToCurrentSpace(node, rgb2dataColor(rgb));
//         pushUpdate([node.hexbox.node]);
//     }

    
//     node.hexbox.selectionEnd = node.hexbox.selectionStart;
//     node.hexbox.editing = false;
//     node.hexbox.blur();
// };


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':    return            col;

        case 'hsv':    return hsv2rgb   (col);
        case 'hsl':    return hsl2rgb   (col);

        case 'hclokl': return hclokl2rgb(col);
        case 'hcllab': return hcllab2rgb(col);
        case 'hclluv': return hclluv2rgb(col);

        case 'oklab':  return oklab2rgb (col);
        case 'lab':    return lab2rgb   (col);
        case 'luv':    return luv2rgb   (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':    return convert2rgb   (color);

        case 'hsv':    return convert2hsv   (color);
        case 'hsl':    return convert2hsl   (color);

        case 'hclokl': return convert2hclokl(color);
        case 'hcllab': return convert2hcllab(color);
        case 'hclluv': return convert2hclluv(color);

        case 'oklab':  return convert2oklab (color);
        case 'lab':    return convert2lab   (color);
        case 'luv':    return convert2luv   (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    rgb =            col;  break;

        case 'hsv':    rgb = hsv2rgb   (col); break;
        case 'hsl':    rgb = hsl2rgb   (col); break;

        case 'hclokl': rgb = hclokl2rgb(col); break;
        case 'hcllab': rgb = hcllab2rgb(col); break;
        case 'hclluv': rgb = hclluv2rgb(col); break;

        case 'oklab':  rgb = oklab2rgb (col); break;
        case 'lab':    rgb = lab2rgb   (col); break;
        case 'luv':    rgb = luv2rgb   (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hsv = rgb2hsv(           col ); break;

        case 'hsv':    hsv =                    col;   break;
        case 'hsl':    hsv = rgb2hsv(hsl2rgb   (col)); break;

        case 'hclokl': hsv = rgb2hsv(hclokl2rgb(col)); break;
        case 'hcllab': hsv = rgb2hsv(hcllab2rgb(col)); break;
        case 'hclluv': hsv = rgb2hsv(hclluv2rgb(col)); break;

        case 'oklab':  hsv = rgb2hsv(oklab2rgb (col)); break;
        case 'lab':    hsv = rgb2hsv(lab2rgb   (col)); break;
        case 'luv':    hsv = rgb2hsv(luv2rgb   (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hsl = rgb2hsl(           col ); break;

        case 'hsv':    hsl = rgb2hsl(hsv2rgb   (col)); break;
        case 'hsl':    hsl =                    col;   break;

        case 'hclokl': hsl = rgb2hsl(hclokl2rgb(col)); break;
        case 'hcllab': hsl = rgb2hsl(hcllab2rgb(col)); break;
        case 'hclluv': hsl = rgb2hsl(hclluv2rgb(col)); break;

        case 'oklab':  hsl = rgb2hsl(oklab2rgb (col)); break;
        case 'lab':    hsl = rgb2hsl(lab2rgb   (col)); break;
        case 'luv':    hsl = rgb2hsl(luv2rgb   (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function convert2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    lab = rgb2oklab(           col ); break;

        case 'hsv':    lab = rgb2oklab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2oklab(hsl2rgb   (col)); break;

        case 'hclokl': lab = rgb2oklab(hclokl2rgb(col)); break;
        case 'hcllab': lab = rgb2oklab(hcllab2rgb(col)); break;
        case 'hclluv': lab = rgb2oklab(hclluv2rgb(col)); break;

        case 'oklab':  lab =                      col;   break;
        case 'lab':    lab = rgb2oklab(lab2rgb   (col)); break;
        case 'luv':    lab = rgb2oklab(luv2rgb   (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    lab = rgb2lab(           col ); break;

        case 'hsv':    lab = rgb2lab(hsv2rgb   (col)); break;
        case 'hsl':    lab = rgb2lab(hsl2rgb   (col)); break;

        case 'hclokl': lab = rgb2lab(hclokl2rgb(col)); break;
        case 'hcllab': lab =         hcllab2lab(col);  break;
        case 'hclluv': lab = rgb2lab(hclluv2rgb(col)); break;

        case 'oklab':  lab = rgb2lab(oklab2rgb (col)); break;
        case 'lab':    lab =                    col;   break;
        case 'luv':    lab = rgb2lab(luv2rgb   (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    luv = rgb2luv(           col ); break;

        case 'hsv':    luv = rgb2luv(hsv2rgb   (col)); break;
        case 'hsl':    luv = rgb2luv(hsl2rgb   (col)); break;

        case 'hclokl': luv = rgb2luv(hclokl2rgb(col)); break;
        case 'hcllab': luv = rgb2luv(hcllab2rgb(col)); break;
        case 'hclluv': luv =         hclluv2luv(col);  break;

        case 'oklab':  luv = rgb2luv(oklab2rgb (col)); break;
        case 'lab':    luv = rgb2luv(lab2rgb   (col)); break;
        case 'luv':    luv =                    col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclokl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hcl = rgb2hclokl(           col);  break;

        case 'hsv':    hcl = rgb2hclokl(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclokl(hsl2rgb   (col)); break;

        case 'hclokl': hcl =                       col;   break;
        case 'hcllab': hcl = rgb2hclokl(hcllab2rgb(col)); break;
        case 'hclluv': hcl = rgb2hclokl(hclluv2rgb(col)); break;

        case 'oklab':  hcl = rgb2hclokl(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclokl(lab2rgb   (col)); break;
        case 'luv':    hcl = rgb2hclokl(luv2rgb   (col)); break;
    }

    return [
       'hclokl',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcllab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hcl = rgb2hcllab(           col) ; break;
        
        case 'hsv':    hcl = rgb2hcllab(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hcllab(hsl2rgb   (col)); break;
        
        case 'hclokl': hcl = rgb2hcllab(hclokl2rgb(col)); break;
        case 'hcllab': hcl =                       col;   break;
        case 'hclluv': hcl = rgb2hcllab(hclluv2rgb(col)); break;
        
        case 'oklab':  hcl = rgb2hcllab(oklab2rgb (col)); break;
        case 'lab':    hcl = lab2hcllab(           col ); break;
        case 'luv':    hcl = rgb2hcllab(luv2rgb   (col)); break;
    }

    return [
       'hcllab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':    hcl = rgb2hclluv(           col ); break;

        case 'hsv':    hcl = rgb2hclluv(hsv2rgb   (col)); break;
        case 'hsl':    hcl = rgb2hclluv(hsl2rgb   (col)); break;

        case 'hcllab': hcl = rgb2hclluv(hcllab2rgb(col)); break;
        case 'hclluv': hcl =                       col;   break;
        case 'hclokl': hcl = rgb2hclluv(hclokl2rgb(col)); break;

        case 'oklab':  hcl = rgb2hclluv(oklab2rgb (col)); break;
        case 'lab':    hcl = rgb2hclluv(lab2rgb   (col)); break;
        case 'luv':    hcl = luv2hclluv(           col ); break;
    }

    return [
       'hclluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


function validateColor(color, order, margin1, margin2, margin3)
{
    let i1, i2, i3;
    
         if (order == 0) { i1 = 0; i2 = 1; i3 = 2; } // HCL
    else if (order == 1) { i1 = 1; i2 = 0; i3 = 2; } // CHL
    else if (order == 2) { i1 = 1; i2 = 2; i3 = 0; } // CLH
    else if (order == 3) { i1 = 0; i2 = 2; i3 = 1; } // HLC
    else if (order == 4) { i1 = 2; i2 = 0; i3 = 1; } // LHC
    else if (order == 5) { i1 = 2; i2 = 1; i3 = 0; } // LCH
 
                                  color = validateChannel(color, i1, margin1);
    if (!dataColorIsValid(color)) color = validateChannel(color, i2, margin2);
    if (!dataColorIsValid(color)) color = validateChannel(color, i3, margin3);

    return color;
}



function validateChannel(color, iChan, margin)
{
    const factor = getColorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsValid(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorValid(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorValid( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsValid(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorValid(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsValid(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorValid(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorValid(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsValid(color);
}



function getValidateMax(order)
{
    switch (order)
    {
        case 0: return [180, 100, 100]; // HCL
        case 1: return [100, 180, 100]; // CHL
        case 2: return [100, 100, 180]; // CLH
        case 3: return [180, 100, 100]; // HLC
        case 4: return [100, 180, 100]; // LHC
        case 5: return [100, 100, 180]; // LCH
    }

    // should never get here
    return [0, 0, 0];
}



function genFindCorrection(nodeId, 
                           inputColor, 
                           param1,  param2,  param3, 
                           locked1, locked2, locked3)
{
    const refOklab = dataColor2array(convert2oklab(inputColor));

    let
  [ closestOklab,
    closestOrder,
    closest1,
    closest2,
    closest3 ] = findCorrection(
                     nodeId, 
                     inputColor, 
                     refOklab, 
                     param1,  param2,  param3, 
                     locked1, locked2, locked3); 

//   [ closestOrder,
//     closest1, closest2, closest3,
//     locked1,  locked2,  locked3 ] = reorderCorrection(
//                                         closestOrder,
//                                         closest1, closest2, closest3,
//                                         locked1,  locked2,  locked3);

    genQueueMessageToUI(
    {
        cmd:         'uiEndFindCorrection',
        nodeId:       nodeId,
        success:      closestOklab != null,
        closestOrder: closestOrder,
        closest1:     closest1,
        closest2:     closest2,
        closest3:     closest3
    });
}



function findCorrection(nodeId, 
                        color, 
                        refOklab, 
                        param1,  param2,  param3, 
                        locked1, locked2, locked3) 
{
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);


    let d = 1;

    while (d > 1/1024)
    {
        let _closestColor = [...closestColor];


        for (let order = 0; order < 6; order++)
        {
            closestColor = [..._closestColor];

            const [max1, max2, max3] = getValidateMax(order);

            let start1 = lerp(0, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(0, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(0, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = param1; start1 = closest1; end1 = start1+Eps; }
            if (locked2) { closest2 = param2; start2 = closest2; end2 = start2+Eps; }
            if (locked3) { closest3 = param3; start3 = closest3; end3 = start3+Eps; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = findCorrectionInOrder(
                nodeId,
                refOklab,
                order, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }

        
        d /= 2;
    }


    // reduce closest to necessary minimums

    const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

    let c1 = closest1;
    let c2 = closest2;
    let c3 = closest3;

    // console.log('closest1', closest1);
    // console.log('closest2', closest2);
    // console.log('closest3', closest3);
    // console.log('');

    while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
    while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
    while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

    closest1 = Math.max(0, c1);
    closest2 = Math.max(0, c2);
    closest3 = Math.max(0, c3);

    // console.log('closest1', closest1);
    // console.log('closest2', closest2);
    // console.log('closest3', closest3);
    // console.log('');

    
    return [
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



function findCorrectionInOrder(nodeId,
                               refOklab,
                               order, 
                               locked1,  locked2,  locked3,
                               closest1, closest2, closest3,
                               start1,   start2,   start3, 
                               end1,     end2,     end3,
                               closestColor,
                               closestOklab,
                               closestOrder,
                               progress,
                               total)
{
    const color = [...closestColor];

    // console.log('order', order);
    // console.log('-------------------')

    // console.log('locked1',  locked1);
    // console.log('start1',   start1);
    // console.log('end1',     end1);
    
    // console.log('locked2',  locked2);
    // console.log('start2',   start2);
    // console.log('end2',     end2);
    
    // console.log('locked3',  locked3);
    // console.log('start3',   start3);
    // console.log('end3',     end3);

    // console.log('-------------------')
    // console.log('')

    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsValid(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    closestOrder = order;
                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;

                    console.log('order', order);
                    console.log('closest1', closest1);
                    console.log('closest2', closest2);
                    console.log('closest3', closest3);
                    console.log('');
                }

                progress++;
            }
        }

        genQueueMessageToUI(
        {
            cmd:     'uiUpdateFindCorrection',
            nodeId:   nodeId,
            progress: progress / total
        });
    }


    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = validateColor(color, order, m1, m2, m3);
    const _oklab = dataColor2array(convert2oklab(_color));
    const _rgb   = oklab2rgb(_oklab);

    return [_color, _oklab, _rgb];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Eps
        && c2.closest <  Eps
        && c3.closest >= Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Eps
          && c2.closest <  Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Eps)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



var validateIsFinding = false;



class OpColorValidate_Correction
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    //locked;

    constructor(name, max, value = 0)//, locked = false)
    {
        this.name   = name;
        this.max    = max;
        this.value  = value;
        //this.locked = locked;
    }
}



class   OpColorValidate
extends OpColorBase
{
    order;

    margin1;
    margin2;
    margin3;


    // findBar;
    // findProgress;


    corrections = [];



    constructor()
    {
        super(COLOR_VALIDATE, 'validate', 80);


        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output(COLOR, this.output_genRequest));


        this.alwaysLoadParams = true;


        this.addParam(this.order = new SelectParam('order', '', false, true, true, [
            'H,&thinsp;C,&thinsp;L', 
            'C,&thinsp;H,&thinsp;L', 
            'C,&thinsp;L,&thinsp;H', 
            'H,&thinsp;L,&thinsp;C', 
            'L,&thinsp;H,&thinsp;C', 
            'L,&thinsp;C,&thinsp;H' 
        ], 2));

        this.order.addEventListener('change', () => this.updateCorrections());


        this.addParam(this.margin1 = new NumberParam('margin1', '', true, true, true, 0));
        this.addParam(this.margin2 = new NumberParam('margin2', '', true, true, true, 0));
        this.addParam(this.margin3 = new NumberParam('margin3', '', true, true, true, 0));


        this.margin1.addEventListener('change', () => 
        {
            const [i1,,] = getCorrectionOrder(this.order.value);
            this.corrections[i1].value = this.margin1.value;
            uiSaveNodes([this.id]);
        });


        this.margin2.addEventListener('change', () => 
        {
            const [, i2,] = getCorrectionOrder(this.order.value);
            this.corrections[i2].value = this.margin2.value;
            uiSaveNodes([this.id]);
        });

        
        this.margin3.addEventListener('change', () => 
        {
            const [,, i3] = getCorrectionOrder(this.order.value);
            this.corrections[i3].value = this.margin3.value;
            uiSaveNodes([this.id]);
        });


        this.initCorrections();
        this.updateCorrections();


        this.header.connectionPadding = 18;


        // this.header.addEventListener('pointerup', e => 
        // { 
        //     if (   e.button == 0
        //         && !validateIsFinding
        //         && this.inputs[0].connected) 
        //     { 
        //         this.findBar     .style.display = 'block';
        //         this.findProgress.style.width   = 0;
                
        //         validateIsFinding = true;

        //         // uiQueueMessageToGenerator(
        //         // {
        //         //     cmd:       'genFindCorrection',
        //         //     nodeId:     this.id,
        //         //     inputColor: this.inputs[0].data.color,
        //         //     param1:     this.margin1.value,
        //         //     param2:     this.margin2.value,
        //         //     param3:     this.margin3.value,
        //         //     locked1:    this.margin1.locked,
        //         //     locked2:    this.margin2.locked,
        //         //     locked3:    this.margin3.locked
        //         // });
        //     }
        // });


        //this.createProgressBar();
    }



    // createProgressBar()
    // {
    //     this.findBar      = createDiv('findBar');
    //     this.findProgress = createDiv('findProgress');

    //     this.findBar.appendChild(this.findProgress);
    //     this.header .appendChild(this.findBar);
    // }



    initCorrections()
    {
        this.corrections = [
            new OpColorValidate_Correction('H', 180),
            new OpColorValidate_Correction('C', 100),
            new OpColorValidate_Correction('L', 100) ];
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.order  .genRequest(gen));

        request.push(...this.node.margin1.genRequest(gen));
        request.push(...this.node.margin2.genRequest(gen));
        request.push(...this.node.margin3.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;

        this.updateCorrections();

        super.updateValues(updateParamId, paramIds, values);
    }



    updateCorrections()
    {
        const [i1, i2, i3] = getCorrectionOrder(this.order.value);

        this.updateMargin(this.margin1, this.corrections[i1]);
        this.updateMargin(this.margin2, this.corrections[i2]);
        this.updateMargin(this.margin3, this.corrections[i3]);
    }



    updateMargin(margin, correction)
    {
        margin.setName(correction.name, false);
        margin.control.name = addValidateSymbol(correction.name);

        margin.control.setMin(0,              false);
        margin.control.setMax(correction.max, false);

        //margin.locked = correction.locked;
        //margin.updateLock();
console.log('correction.value =', correction.value);
        // if (!margin.locked)
        // {
            //margin.control.setDecimals(Math.min(decCount(numToString(correction.value, -1))));
            //margin.setValue(correction.value, true, true, false);
        //}
    }



    // updateHeaderLabel()
    // {
    //     this.label.style.top = '40%';

    //     // const colors    = this.getHeaderColors();
    //     // const findStyle = rgb2style_a(colors.text, 0.35);

    //     // this.findBar     .style.outline    = '1px solid ' + findStyle;
    //     // this.findProgress.style.background = findStyle;


    //     super.updateHeaderLabel();
    // }



    // canShowColor()
    // {
    //     return this.inputs[0].connected;
    // }



    isConnected()
    {
        return this.inputs[0].connected;
    }



    // toJsonBase(nTab = 0) 
    // {
    //     let   pos = ' '.repeat(nTab);
    //     const tab = TAB;

    //     const [i1, i2, i3] = getCorrectionOrder(this.order.value);

    //     return super.toJsonBase(nTab)
    //         + ',\n' + pos + tab + '"locked1": "' + boolString(this.corrections[i1].locked) + '"'
    //         + ',\n' + pos + tab + '"locked2": "' + boolString(this.corrections[i2].locked) + '"'
    //         + ',\n' + pos + tab + '"locked3": "' + boolString(this.corrections[i3].locked) + '"';
    // }



    // loadParams(_node)
    // {
    //     super.loadParams(_node);

    //     const [i1, i2, i3] = getCorrectionOrder(this.order.value);

    //     if (_node.locked1) this.corrections[i1].locked = isTrue(_node.locked1);
    //     if (_node.locked2) this.corrections[i2].locked = isTrue(_node.locked2);
    //     if (_node.locked3) this.corrections[i3].locked = isTrue(_node.locked3);

    //     this.updateCorrections();

    //     super.loadParams(_node); // must be done again after the locks have been set
    // }
}



function uiUpdateFindCorrectionProgress(nodeId, progress)
{
    const node = nodeFromId(nodeId);

    node.findProgress.style.width = (progress * 100) + '%';
}



function uiEndFindCorrection(nodeId, success, closestOrder, closest1, closest2, closest3)
{
    const node = nodeFromId(nodeId);

    if (success)
    {
        node.order.setValue(closestOrder, true, true, false);

        const [i1, i2, i3] = getCorrectionOrder(closestOrder);

        node.corrections[i1].value = closest1;
        node.corrections[i2].value = closest2;
        node.corrections[i3].value = closest3;

        node.updateCorrections();
    }

    validateIsFinding = false;

    node.findBar.style.display = 'none';

    pushUpdate([node]);

    uiSaveNodes([nodeId]);
}



function getCorrectionOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }
}



function addValidateSymbol(name)
{
    return /*'<span class="asterisk">&thinsp;</span>' + */name;
}


class   OpColorContrast
extends OpColorBase
{
    paramStandard;
    paramValue;

    labelColor = [0, 0, 0];


    constructor()
    {
        super(COLOR_CONTRAST, 'contrast', 80);


        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));


        this.addParam(this.paramValue    = new NumberParam('value',    '', false, false, true, 0, 0));
        this.addParam(this.paramStandard = new SelectParam('standard', '', false, true,  true, ['WCAG 2', 'WCAG 3'], 1));
      

        //this.paramValue.enableControlText(false);


        createTooltip(ttWcag2);
        createTooltip(ttWcag3);

        createTooltipSrc(
            this.paramValue.control, 
            () => this.paramStandard.value == 1 ? ttWcag3 : ttWcag2);


        this.header.connectionPadding = 12.5;
    }



    getShowTooltip()
    {
        return this.paramStandard.value == 1
               ? ttWcag3
               : ttWcag2;
    }



    genRequest(gen)
    {
        // 'this' is the node

        if (!isEmpty(this.requestCache))
            return this.requestCache;


        gen.scope.push({
            nodeId:  this.id, 
            paramId: '' });



        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.inputs[0];
        const input1 = this.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, 0, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, 1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.paramStandard.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        console.assert(
            paramIds.length == values.length,
            'paramIds.length must equal values.length');

        const colText = values[paramIds.findIndex(id => id == 'text')];
        const colBack = values[paramIds.findIndex(id => id == 'back')];

        console.assert(colText.type == COLOR_VALUE, 'colText.type = ' + colText.type);
        console.assert(colBack.type == COLOR_VALUE, 'colBack.type = ' + colBack.type);

        this.labelColor = 
            colText.isValid()
            ? colText.toRgb()
            : [0, 0, 0];

        this._color = colBack.toDataColor();


        super.updateValues(updateParamId, paramIds, values);


        const value = this.paramValue.value;


        if (this.paramStandard.value == 0)
        {
            let rating = getContrastRating2(value);

            if (rating != '')
                rating = '&nbsp;&nbsp;' + rating;

            this.paramValue.control.min        = 
            this.paramValue.control.displayMin = 0;

            this.paramValue.control.max        = 
            this.paramValue.control.displayMax = 21;

            this.paramValue.control.setDecimals(2);
            this.paramValue.control.setSuffix(rating);
        }
        else
        {
            this.paramValue.control.min        = 
            this.paramValue.control.displayMin = 0;

            this.paramValue.control.max        = 
            this.paramValue.control.displayMax = 105;

            this.paramValue.control.setDecimals(1);
            this.paramValue.control.setSuffix('<span style="font-size: 5; position: relative; top: -7px; left: 2px;">L</span><span style="font-size: 3; font-weight: bold; position: relative; top: -9px; left: 2px;">c</span>');

            this.paramValue.control.setValue(Math.abs(value), false, false);
        }


        if (   this.inputs[0].connected
            && this.inputs[1].connected)
        {
            const rgb0 = colText.toRgb();
            const rgb1 = colBack.toRgb();

            if (  !rgbIsOk(rgb0)
                && rgbIsOk(rgb1))
            {
                this.warningStyle     = rgb2style_a(invalid2validRgb(rgb0), 0.3);
                this.forceShowWarning = true;
            }
            else if ( rgbIsOk(rgb0)
                  && !rgbIsOk(rgb1))
            {
                this.warningStyle     = getDefaultWarningStyle(rgb1);
                this.forceShowWarning = true;
            }
            else
                this.forceShowWarning = false;
        }
        else
        {
            this.forceShowWarning = false;
        }
    }



    updateNode()
    {
        this.setRanges();
        
        super.updateNode();
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();

        let textStyle;

          if (   this.inputs[0].connected 
              && this.inputs[1].connected) this.label.style.color = rgb2style(this.labelColor);
        else if (this.inputs[1].connected) this.label.style.color = rgba2style(colors.text);
        else                               this.label.style.color = 'black';
    }



    setRanges()
    {
        if (isDarkMode())
        {
            if (this.paramStandard.value == 0)
                this.paramValue.control.ranges = [
                    new NumberControlRange(0  /21,  3  /21, 'rgba(255, 112,  0, 0.2 )', 0.8),
                    new NumberControlRange(3  /21,  4.5/21, 'rgba(255, 255,  0, 0.27)', 0.8),
                    new NumberControlRange(4.5/21,  7  /21, 'rgba(64,  220, 64, 0.27)', 0.8),
                    new NumberControlRange(7  /21, 21  /21, 'transparent') ];

            else
                this.paramValue.control.ranges = [
                    new NumberControlRange( 0/105,  15/105, 'rgba(255,  64,  96, 0.2)', 0.8),
                    new NumberControlRange(15/105,  30/105, 'rgba(255, 128,  24, 0.2)', 0.8),
                    new NumberControlRange(30/105,  45/105, 'rgba(255, 185,   0, 0.2)', 0.8),
                    new NumberControlRange(45/105,  60/105, 'rgba(255, 255,   0, 0.2)', 0.8),
                    new NumberControlRange(60/105,  75/105, 'rgba( 64, 255,  64, 0.2)', 0.8),
                    new NumberControlRange(75/105,  90/105, 'rgba(110, 128, 255, 0.4)', 0.8),
                    new NumberControlRange(90/105, 105/105, 'transparent') ];
        }
        else
        {
            if (this.paramStandard.value == 0)
                this.paramValue.control.ranges = [
                    new NumberControlRange(0  /21,  3  /21, 'rgba(255, 112,  0, 0.2 )', 0.8),
                    new NumberControlRange(3  /21,  4.5/21, 'rgba(255, 255,  0, 0.27)', 0.8),
                    new NumberControlRange(4.5/21,  7  /21, 'rgba(64,  220, 64, 0.27)', 0.8),
                    new NumberControlRange(7  /21, 21  /21, 'transparent') ];

            else
                this.paramValue.control.ranges = [
                    new NumberControlRange( 0/105,  15/105, 'rgba(255,   0,  64, 0.2 )', 0.8),
                    new NumberControlRange(15/105,  30/105, 'rgba(255, 112,   0, 0.2 )', 0.8),
                    new NumberControlRange(30/105,  45/105, 'rgba(255, 185,   0, 0.2 )', 0.8),
                    new NumberControlRange(45/105,  60/105, 'rgba(255, 255,   0, 0.2 )', 0.8),
                    new NumberControlRange(60/105,  75/105, 'rgba(64,  255,  64, 0.2 )', 0.8),
                    new NumberControlRange(75/105,  90/105, 'rgba(0,     0, 255, 0.07)', 0.8),
                    new NumberControlRange(90/105, 105/105, 'transparent') ];
        }

        this.paramValue.control.update();
    }
}


class   OpColorInterpolate
extends OpColorBase
{
    paramSpace;
    paramAmount;
    paramGamma;



    constructor()
    {
        super(COLOR_INTERPOLATE, 'inter', 80);

        
        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));

        this.addOutput(new Output(COLOR, this.output_genRequest));


        this.addParam(this.paramSpace  = new SelectParam('space',  '',  false, true, true, OpColorSpaces.map(s => s[1]), 1));
        this.addParam(this.paramAmount = new NumberParam('amount', '',  true,  true, true, 50, 0,  100, 0));
        this.addParam(this.paramGamma  = new NumberParam('gamma',  '', true,  true, true, 1,  0.01, 4, 2));
      
        
        this.paramSpace.control.setMin(1);

        
        this.paramAmount.control.min = Number.MIN_SAFE_INTEGER; // allow
        this.paramAmount.control.max = Number.MAX_SAFE_INTEGER; // extrapolation

        this.paramAmount.control.setSuffix('%', true);
        

        this.header.connectionPadding = 12.5;

        
        //this._color = dataColor_NaN;

        
        // this.inputs[0].addEventListener('connect', () => 
        // {
        //     if (   !this.inputs[1].connected
        //         && !graphView.loadingNodes) 
        //         this.paramSpace.setValue(
        //             colorSpaceIndex(this.inputs[0].data.color[0]),
        //             true, true, false);
        // });


        // this.inputs[1].addEventListener('connect', () => 
        // {
        //     if (   !this.inputs[0].connected
        //         && !graphView.loadingNodes) 
        //         this.paramSpace.setValue(
        //             colorSpaceIndex(this.inputs[1].data.color[0]),
        //             true, true, false);
        // });


        this.paramSpace.control.addEventListener('change', () => hideTooltip(ttInterpolationSpace));


        createTooltip(ttInterpolationSpace);
        createTooltipSrc(this.paramSpace.control, () => ttInterpolationSpace);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramSpace .genRequest(gen));
        request.push(...this.node.paramAmount.genRequest(gen));
        request.push(...this.node.paramGamma .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;

        super.updateValues(updateParamId, paramIds, values);


        showOpColorInterpolateGammaControl(this, this.paramSpace.value == 1);    
    }
}



function removeOpColorInterpolateParamWires(node)
{
    if (node.paramGamma.input.connected)
        uiDisconnect(node.paramGamma.input);

    for (const input of node.paramGamma.output.connectedInputs)
        uiDisconnect(input);
}



function showOpColorInterpolateGammaControl(node, show)
{
    if (    show
        && !node.inner.contains(node.paramGamma.div))
        node.inner.appendChild(node.paramGamma.div);

    else if (!show
           && node.inner.contains(node.paramGamma.div))
        node.inner.removeChild(node.paramGamma.div);
}



class   OpColorBlind
extends OpColorBase
{
    paramL;
    paramM;
    paramS;



    constructor()
    {
        super(COLORBLIND, 'colorblind', 80);


        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output(COLOR, this.output_genRequest));


        this.addParam(this.paramL = new NumberParam('l', 'L', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.paramM = new NumberParam('m', 'M', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.paramS = new NumberParam('s', 'S', false, true, true, 2, 0, 2, 0, 0.02));

        this.paramL.addEventListener('change', () => this.paramL.control.dragScale = decCount(numToString(this.paramL.value, this.paramL.control.displayDec)) == 0 ? 0.02 : 0.05);
        this.paramM.addEventListener('change', () => this.paramM.control.dragScale = decCount(numToString(this.paramM.value, this.paramM.control.displayDec)) == 0 ? 0.02 : 0.05);
        this.paramS.addEventListener('change', () => this.paramS.control.dragScale = decCount(numToString(this.paramS.value, this.paramS.control.displayDec)) == 0 ? 0.02 : 0.05);


        this.header.connectionPadding = 18;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramL.genRequest(gen));
        request.push(...this.node.paramM.genRequest(gen));
        request.push(...this.node.paramS.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;


        super.updateValues(updateParamId, paramIds, values);


        this.updateParamText(this.paramL, 'L');
        this.updateParamText(this.paramM, 'M');
        this.updateParamText(this.paramS, 'S');
    }



    updateParamText(param, cone)
    {
        const v = Math.round(param.value);

             if (v == 2) param.control.valueText = cone;
        else if (v == 1) param.control.valueText = cone + ' weak';
        else             param.control.valueText = cone + ' blind';
    }
}


class OpFill
extends OpColorBase
{
    paramColor;
    paramOpacity;

    checkers;
    colorBack;



    get inputIsShape() 
    {
        return this.inputs[0].connected
            && SHAPE_TYPES.includes(this.inputs[0].connectedOutput.type);
    }
    
    
    
    constructor()
    {
        super(FILL, 'solid');


        this.colorBack = createDiv('colorBack');
        this.checkers  = createDiv('nodeHeaderCheckers');

        //this.inner.appendChild(this.colorBack);
        this.inner.insertBefore(this.checkers, this.header);


        this.addInput (new Input([FILL, FILL_VALUE, ...SHAPE_TYPES], this.input_getValuesForUndo));
        this.addOutput(new Output(FILL, this.output_genRequest));


        this.inputs[0].addEventListener('connect',    () =>   this.outputs[0]._type = this.inputs[0].connectedOutput.type);
        this.inputs[0].addEventListener('disconnect', () => { this.outputs[0]._type = FILL; uiDeleteObjects([this.id]); });


        this.addParam(this.paramColor   = new ColorParam ('color',   '',        false, true, true, ColorValue.fromRgb(rgbDefaultFill)));
        this.addParam(this.paramOpacity = new NumberParam('opacity', 'opacity', true,  true, true, 100, 0, 100));

        this.paramOpacity.control.suffix = '%';
    }
    
    
    
    input_getValuesForUndo()
    {
        return [ 
            [this.node.paramColor  .id, 
             this.node.paramColor  .value],

            [this.node.paramOpacity.id, 
             this.node.paramOpacity.value] ];
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const paramIds = [];


        const input = this.node.inputs[0];

        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));

            for (const param of this.node.params)
                if (      param.input 
                       && param.input.connected
                       && param.show()
                    || SHAPE_TYPES.includes(input.connectedOutput.type)) 
                    paramIds.push(param.id);
        }
        else
        {
            for (const param of this.node.params)
                if (param.show())
                    paramIds.push(param.id);
        }

        
        request.push(paramIds.length);

        for (const paramId of paramIds)
            request.push(paramId, ...this.node.params.find(p => p.id == paramId).genRequest(gen));            


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        const color   = values[paramIds.findIndex(id => id == 'color'  )];
        const opacity = values[paramIds.findIndex(id => id == 'opacity')];


        this.paramColor  .setValue(color,   false, true, false);
        this.paramOpacity.setValue(opacity, false, true, false);


        this._color = 
            color.isValid()
            ? color.toDataColor()
            : dataColor_NaN;


        super.updateValues(updateParamId, paramIds, values);
    }



    updateColorControl()
    {
        if (this.paramOpacity.value.isValid())
            this.paramColor.checkers.style.opacity = 
                this.inputIsShape 
                ? (100 - this.paramOpacity.value.toNumber()) + '%'
                : 0;


        const colors = this.getHeaderColors({color: true});

        colors.text   = getTextColorFromBackColor(colors.back, this.inputIsShape ? colors.back[3] : 1);
        colors.input  = rgb_a(colors.text, 0.2);
        colors.output = rgb_a(colors.text, 0.2);


        this.paramColor.control. backStyleLight = 
        this.paramColor.control. backStyleDark  = 
        this.paramColor.control.valueStyleLight = 
        this.paramColor.control.valueStyleDark  = rgba2style(rgb_a(colors.back, 1));

        this.paramColor.control.textStyleLight  = 
        this.paramColor.control.textStyleDark   = rgba2style(colors.text);

        this.paramColor. input.colorLight       =
        this.paramColor. input.colorDark        = colors.input;
        
        this.paramColor.output.colorLight       =
        this.paramColor.output.colorDark        = colors.output;
        
        this.paramColor. input.wireColor        = rgb_a(colors.wire, 1);
        this.paramColor.output.wireColor        = rgb_a(colors.wire, 1);
    }



    updateNode()
    {
        this.updateColorControl();

        super.updateNode();
    }



    updateHeader()
    {
        //console.log(this.id + '.OpFill.updateHeader()');
        
        Operator.prototype.updateHeader.call(this);


        const colors =
              this.inputIsShape
            ? OperatorBase.prototype.getHeaderColors.call(this)
            : this.getHeaderColors();


        this.header.style.background = 
            !rgbIsNaN(colors.back)
            ? rgba2style(colors.back) 
            : 'transparent';

        this.colorBack.style.background = 
            !rgbIsNaN(colors.back)
            ? rgb2style(colors.back)
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));


        this.checkers.style.height = this.header.offsetHeight;

        this.checkers.style.background =
            isDarkMode()
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = isDarkMode() ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '26px 26px';
        this.checkers.style.backgroundPosition = '0 0, 13px 13px';
                        

        this.inputs[0] .colorLight = 
        this.inputs[0] .colorDark  = colors.input;
        this.inputs[0] .wireColor  = colors.wire;

        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = colors.output;
        this.outputs[0].wireColor  = colors.wire;


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colors.back, this.inputIsShape ? -1 : 45);
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        

        const colors                = this.getHeaderColors();

        this.label.style.color      = rgba2style(colors.text);
        this.label.style.fontWeight = this.active ? 'bold' : 'normal';
    }



    getHeaderColors(options = {})
    {
        if (    this.inputIsShape
            && !options.color)
            return Operator.prototype.getHeaderColors.call(this);

            
        const colors  = super.getHeaderColors();

        colors.back   = rgb_a(colors.back, this.paramOpacity.value.value/100);
        colors.text   = getTextColorFromBackColor(colors.back, colors.back[3]);
        colors.input  = rgb_a(colors.text, 0.2);
        colors.output = rgb_a(colors.text, 0.2);
        colors.wire   = colors.back;
        
        return colors;
    }



    updateParams()
    {
        const enable = 
               !this.inputs[0].connected
            ||  SHAPE_TYPES.includes(this.inputs[0].connectedOutput.type);

        this.paramColor  .enableControlText(enable);
        this.paramOpacity.enableControlText(enable);

        super.updateParams();
    }
}


class OpStroke
extends OpColorBase
{
    paramFill;
    paramWeight;
    paramFit;
    paramJoin;
    paramMiter;

    checkers;
    colorBack;


    constructor()
    {
        super(STROKE, 'stroke');


        this.colorBack = createDiv('colorBack');
        this.inner.appendChild(this.colorBack);

        this.addInput (new Input(STROKE_TYPES, this.input_getValuesForUndo));
        this.addOutput(new Output(STROKE, this.output_genRequest));

        // this.initContentInput(this.inputs[0]);


        this.addParam(this.paramFill   = new FillParam  ('fill',   'fill',   false, true, true, FillValue.create(0, 0, 0, 100)));
        this.addParam(this.paramWeight = new NumberParam('weight', 'weight', true,  true, true, 1, 0));
        this.addParam(this.paramFit    = new SelectParam('fit',    'fit',    true,  true, true, ['inside', 'edge', 'outside'], 0));
        this.addParam(this.paramJoin   = new SelectParam('join',   'join',   true,  true, true, ['miter', 'bevel', 'round'], 0));
        this.addParam(this.paramMiter  = new NumberParam('miter',  'miter',  true,  true, true, 28.96, 0, 180, 2));

        this.paramMiter.control.setSuffix('', true);
        this.paramMiter.show = () => this.paramJoin.value == 0;


        this.checkers = createDiv('nodeHeaderCheckers');
        this.inner.insertBefore(this.checkers, this.header);
    }
    
    
    
    input_getValuesForUndo()
    {
        return [ 
            [this.node.paramFill  .id, 
             this.node.paramFill  .value],

            [this.node.paramWeight.id, 
             this.node.paramWeight.value],

            [this.node.paramFit   .id, 
             this.node.paramFit   .value],

            [this.node.paramJoin  .id, 
             this.node.paramJoin  .value],

            [this.node.paramMiter .id, 
             this.node.paramMiter .value]];
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        const paramIds = [];

        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected) 
                    paramIds.push(param.id);

            request.push(paramIds.join(','));

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected) 
                    request.push(...param.genRequest(gen))
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen))
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        const fill   = values[paramIds.findIndex(id => id == 'fill'  )];
        const weight = values[paramIds.findIndex(id => id == 'weight')];
        const fit    = values[paramIds.findIndex(id => id == 'fit'   )];
        const join   = values[paramIds.findIndex(id => id == 'join'  )];
        const miter  = values[paramIds.findIndex(id => id == 'miter' )];


        this.paramFill  .setValue(fill,   false, true, false);
        this.paramWeight.setValue(weight, false, true, false);
        this.paramFit   .setValue(fit,    false, true, false);
        this.paramJoin  .setValue(join,   false, true, false);
        this.paramMiter .setValue(miter,  false, true, false);

        
        this._color = 
            fill.isValid()
            ? fill.color.toDataColor()
            : dataColor_NaN;


        super.updateValues(updateParamId, paramIds, values);
    }



    updateHeader()
    {
        //console.log(this.id + '.OpStroke.updateHeader()');


        const colors = this.getHeaderColors();

        this.colorBack.style.background = 
            rgbIsOk(colors.back)
            ? rgb2style(colors.back)
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));

              
        this.checkers.style.height = this.header.offsetHeight;

        this.checkers.style.background =
            isDarkMode()
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = isDarkMode() ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '26px 26px';
        this.checkers.style.backgroundPosition = '0 0, 13px 13px';
                        

        this.header.style.background = 
            !rgbIsNaN(colors.back)
            ? rgba2style(colors.back) 
            : 'transparent';


        const noColor = 
            isDarkMode()
            ? rgbNoColorDark
            : rgbNoColorLight;

        this.inputs[0] .wireColor  = !rgbIsNaN(colors.back) ? colors.back : noColor;
        this.inputs[0] .colorLight = 
        this.inputs[0] .colorDark  = rgb_a(colors.input, 0.2);

        this.outputs[0].wireColor  = !rgbIsNaN(colors.back) ? colors.back : noColor;
        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = rgb_a(colors.output, 0.2);


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colors.back);//, 45);


        Operator.prototype.updateHeader.call(this);
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors();
 
        colors.back = rgb_a(colors.back, this.paramFill.value.opacity.value/100);
        colors.text = getTextColorFromBackColor(colors.back, this.paramFill.value.opacity.value/100);

        return colors;
    }
}


class   OpColorStop
extends OpColorBase
{
    paramFill;
    paramPosition;

    
    constructor()
    {
        super(COLOR_STOP, 'stop');


        this.addInput(new Input([COLOR_STOP, COLOR_STOP_VALUE]));
        this.addOutput(new Output(COLOR_STOP, this.output_genRequest));

        this.addParam(this.paramFill     = new FillParam ('fill',     '',         false, true, true));
        this.addParam(this.paramPosition = new NumberParam('position', 'position', true,  true, true, 100, 0, 100));

        //this.paramFill.setValue([FillValue.default], false, true, false);
        
        this.paramPosition.control.suffix = '%';
    }
    
    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramFill    .genRequest(gen));
        request.push(...this.node.paramPosition.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        const stop = values[paramIds.findIndex(id => id == 'value')];

        
        if (stop.isValid())
        {
            this.paramFill    .setValue([stop.fill],   false, true, false);
            this.paramPosition.setValue(stop.position, false, true, false);

            // this._color = stop.color.toDataColor();
        }
        else
        {
            this.paramFill    .setValue([FillValue.NaN], false, true, false);
            this.paramPosition.setValue( NumberValue   .NaN,  false, true, false);
            
            this._color = dataColor_NaN;
        }


        super.updateValues(updateParamId, paramIds, values);
    }
}


class   OpGradient
extends OperatorBase
{
    paramType;

    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;


    constructor()
    {
        super(GRADIENT, 'grad', 90);

        this.variableInputs = true;


        this.addNewInput();
        this.addOutput(new Output(GRADIENT, this.output_genRequest));
        

        this.addParam(this.paramType   = new SelectParam('type', '', false, true, true, ['linear', 'radial', 'angular', 'diamond'], 0));

        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true, 0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true, 0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 1));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 1));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true, 0));
    }
    
    
    
    addNewInput()
    {
        const input = new Input([COLOR_TYPES]);
        input.isNew = true;

        input.addEventListener('connect',    () => { OpGradient_onConnectInput(this); input.isNew = false; });
        input.addEventListener('disconnect', () => OpGradient_onDisconnectInput(this, input));

        this.addInput(input);

        return input;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            
aram``
        const connectedInputs = this.node.inputs.filter(i => i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));

            
        request.push(
            ...this.node.paramX     .genRequest(gen),
            ...this.node.paramY     .genRequest(gen),
            ...this.node.paramWidth .genRequest(gen),
            ...this.node.paramHeight.genRequest(gen),
            ...this.node.paramAngle .genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        if (paramIds.includes('value'))
            this.outputs[0].cache = [NUMBER_VALUE, values[0].toString()];
    }
}



function OpGradient_onConnectInput(node)
{
    node.addNewInput();
    //node.updateNode();
}



function OpGradient_onDisconnectInput(node, input)
{
    removeFromArray(node.inputs, input);
    node.inputControls.removeChild(input.control);
    //node.updateNode();
}


class   OpShapeBase
extends OperatorBase
{
    // paramFill;
    // paramStroke;


    // btnProportional;

    // refWidth  = Number.NaN;
    // refHeight = Number.NaN;


    
    constructor(type, shortName, defWidth = 80)
    {
        super(type, shortName, defWidth);
    }



    // addBaseParams()
    // {
    //     this.addParam(this.paramFill   = new FillParam  ('fill',   'fill',   false, true, true, FillValue.default));
    //     this.addParam(this.paramStroke = new StrokeParam('stroke', 'stroke',        true, true, StrokeValue.NaN));

    //     this.paramStroke.input.addEventListener('disconnect', () => { this.paramStroke.setValue(StrokeValue.NaN, false, true, false); });
    // } 



    // getBaseValuesForUndo()
    // {
    //     return [ 
    //         [this.paramFill  .id, 
    //          this.paramFill  .value],

    //         [this.paramStroke.id, 
    //          this.paramStroke.value]];
    // }



    // updateBaseValues(updateParamId, paramIds, values)
    // {
    //     const fill   = values[paramIds.findIndex(id => id == 'fill'  )];
    //     const stroke = values[paramIds.findIndex(id => id == 'stroke')];

    //     setParamValue(this.paramFill,   fill,   updateParamId);
    //     setParamValue(this.paramStroke, stroke, updateParamId);

    //     this.updateParamDisplay();
    // }
}


class   OpRectangle
extends OperatorBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;
    paramRound;


    
    constructor()
    {
        super(RECTANGLE, 'rect', 100);


        this.addInput (new Input([RECTANGLE, RECTANGLE_VALUE], this.input_getValuesForUndo));
        this.addOutput(new Output(RECTANGLE, this.output_genRequest));

        // this.initContentInput(this.inputs[0]);


        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        this.addParam(this.paramRound  = new NumberParam('round',  'round',  true, true, true,   0,    0));


        this.paramWidth .addEventListener('change', () => this.updateRound());
        this.paramHeight.addEventListener('change', () => this.updateRound());

        this.paramAngle.control.setSuffix('', true);
        this.paramAngle.control.wrapValue   = true;
        this.paramAngle.control.dragReverse = true;
    }
    
    
    
    input_getValuesForUndo()
    {
        return [ 
            [this.node.paramX     .id, 
             this.node.paramX     .value],

            [this.node.paramY     .id, 
             this.node.paramY     .value],

            [this.node.paramWidth .id, 
             this.node.paramWidth .value],

            [this.node.paramHeight.id, 
             this.node.paramHeight.value],

            [this.node.paramAngle .id, 
             this.node.paramAngle .value],

            [this.node.paramRound .id, 
             this.node.paramRound .value] ];
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

                
        const paramIds = [];
        

        const input = this.node.inputs[0];
        
        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected
                    && param.show())
                    paramIds.push(param.id);
        }
        else
        {
            for (const param of this.node.params)
                if (param.show())
                    paramIds.push(param.id);
        }


        request.push(paramIds.length);

        for (const paramId of paramIds)
            request.push(paramId, ...this.node.params.find(p => p.id == paramId).genRequest(gen));            


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateRound()
    {
        const min = Math.min(this.paramWidth.value.value, this.paramHeight.value.value);

        this.paramRound.control.displayMin = 0;
        this.paramRound.control.displayMax = min/2;

        this.paramRound.control.update();
    }
}


class   OpLine
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramAngle;


    
    constructor()
    {
        super(LINE, 'line', 90);

        this.addInput (new Input ([LINE, LINE_VALUE]));
        this.addOutput(new Output(LINE, this.output_genRequest));

        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        

        this.paramAngle.control.setSuffix('', true);
        this.paramAngle.control.wrapValue   = true;
        this.paramAngle.control.dragReverse = true;


        // this.inputs[0].addEventListener('connect', () =>
        // {
        //     for (const param of this.params)
        //         param.enableControlText(false);
        // });


        // this.inputs[0].addEventListener('disconnect', () =>
        // {
        //     for (const param of this.params)
        //         if (!param.input.connected) 
        //             param.enableControlText(true);
        // });
    }
    
    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        const paramIds = [];


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            for (const param of this.node.params)
                if (param.input && param.input.connected) 
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            if (this.node.paramX     .input.connected) request.push(...this.node.paramX     .genRequest(gen));
            if (this.node.paramY     .input.connected) request.push(...this.node.paramY     .genRequest(gen));
            if (this.node.paramWidth .input.connected) request.push(...this.node.paramWidth .genRequest(gen));
            if (this.node.paramAngle .input.connected) request.push(...this.node.paramAngle .genRequest(gen));
        }
        else
        {
            request.push(
                ...this.node.paramX     .genRequest(gen),
                ...this.node.paramY     .genRequest(gen),
                ...this.node.paramWidth .genRequest(gen),
                ...this.node.paramAngle .genRequest(gen));
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpEllipse
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;

    //showAllParams = true;


    
    constructor()
    {
        super(ELLIPSE, 'elps', 90);

        this.addInput (new Input ([ELLIPSE, ELLIPSE_VALUE]));
        this.addOutput(new Output(ELLIPSE, this.output_genRequest));

        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        

        this.paramAngle.control.setSuffix('', true);
        this.paramAngle.control.wrapValue   = true;
        this.paramAngle.control.dragReverse = true;

        
        this.btnProportional = createToggleButton(12, 12);
        this.inner.appendChild(this.btnProportional);


        // this.inputs[0].addEventListener('connect', () =>
        // {
        //     for (const param of this.params)
        //         param.enableControlText(false);
        // });


        // this.inputs[0].addEventListener('disconnect', () =>
        // {
        //     for (const param of this.params)
        //         if (!param.input.connected) 
        //             param.enableControlText(true);
        // });


        this.btnProportional.addEventListener('click', () =>
        {
            if (this.btnProportional.enabled)
            {
                this.refWidth  = this.paramWidth .value.value;
                this.refHeight = this.paramHeight.value.value;
            }
        });


        this.paramWidth.addEventListener('change', () =>
        {
            if (this.btnProportional.enabled)
                this.paramHeight.setValue(this.paramWidth.value.value * this.refHeight / this.refWidth, false, true, false);
        });


        this.paramHeight.addEventListener('change', () =>
        {
            if (this.btnProportional.enabled)
                this.paramWidth.setValue(this.paramHeight.value.value * this.refWidth / this.refHeight, false, true, false);
        });
    }
    
    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        const paramIds = [];


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            for (const param of this.node.params)
                if (param.input && param.input.connected) 
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            if (this.node.paramX     .input.connected) request.push(...this.node.paramX     .genRequest(gen));
            if (this.node.paramY     .input.connected) request.push(...this.node.paramY     .genRequest(gen));
            if (this.node.paramWidth .input.connected) request.push(...this.node.paramWidth .genRequest(gen));
            if (this.node.paramHeight.input.connected) request.push(...this.node.paramHeight.genRequest(gen));
            if (this.node.paramAngle .input.connected) request.push(...this.node.paramAngle .genRequest(gen));
        }
        else
        {
            request.push(
                ...this.node.paramX     .genRequest(gen),
                ...this.node.paramY     .genRequest(gen),
                ...this.node.paramWidth .genRequest(gen),
                ...this.node.paramHeight.genRequest(gen),
                ...this.node.paramAngle .genRequest(gen));
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateNode()
    {
        this.btnProportional.style.left = 45;
        this.btnProportional.style.top  = 79;

        super.updateNode();
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        let json = 
                 super.toJsonBase(nTab)
               //+ ',\n' + pos + tab + '"showAllParams": "' + boolString(this.showAllParams) + '"'
               + ',\n' + pos + tab + '"proportional": "'  + boolString(this.btnProportional.enabled) + '"';

        if (this.btnProportional.enabled)
        {
            json +=
                  ',\n' + pos + tab + '"refWidth": "'  + this.refWidth  + '"'
                + ',\n' + pos + tab + '"refHeight": "' + this.refHeight + '"';
        }

        return json;
    }



    loadParams(_node)
    {
        super.loadParams(_node);

        // if (_node.proportional)
        // {
            //this.showAllParams = isTrue(_node.proportional);
            
            this.btnProportional.enabled = isTrue(_node.proportional);
            this.btnProportional.updateBackground(false);

            if (this.btnProportional.enabled)
            {
                this.refWidth  = parseFloat(_node.refWidth);
                this.refHeight = parseFloat(_node.refHeight);
            }
        //}
    }
}


class   OpPolygon
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;
    paramRound;
    paramCorners;


    
    constructor()
    {
        super(POLYGON, 'poly', 90);

        this.addInput (new Input ([POLYGON, POLYGON_VALUE]));
        this.addOutput(new Output(POLYGON, this.output_genRequest));

        this.addParam(this.paramX       = new NumberParam('x',       'x',       true, true, true,   0));
        this.addParam(this.paramY       = new NumberParam('y',       'y',       true, true, true,   0));
        this.addParam(this.paramWidth   = new NumberParam('width',   'width',   true, true, true, 100,    0.01));
        this.addParam(this.paramHeight  = new NumberParam('height',  'height',  true, true, true, 100,    0.01));
        this.addParam(this.paramAngle   = new NumberParam('angle',   'angle',   true, true, true,   0, -180,   180));
        this.addParam(this.paramRound   = new NumberParam('round',   'round',   true, true, true,   0,    0));
        this.addParam(this.paramCorners = new NumberParam('corners', 'corners', true, true, true,   3,    3));
        

        this.paramAngle.control.setSuffix('', true);
        this.paramAngle.control.wrapValue   = true;
        this.paramAngle.control.dragReverse = true;

        
        this.btnProportional = createToggleButton(12, 12);
        this.inner.appendChild(this.btnProportional);


        // this.inputs[0].addEventListener('connect', () =>
        // {
        //     for (const param of this.params)
        //         param.enableControlText(false);
        // });


        // this.inputs[0].addEventListener('disconnect', () =>
        // {
        //     for (const param of this.params)
        //         if (!param.input.connected) 
        //             param.enableControlText(true);
        // });


        this.btnProportional.addEventListener('click', () =>
        {
            if (this.btnProportional.enabled)
            {
                this.refWidth  = this.paramWidth .value.value;
                this.refHeight = this.paramHeight.value.value;
            }
        });


        this.paramWidth.addEventListener('change', () =>
        {
            if (this.btnProportional.enabled)
                this.paramHeight.setValue(this.paramWidth.value.value * this.refHeight / this.refWidth, false, true, false);
        });


        this.paramHeight.addEventListener('change', () =>
        {
            if (this.btnProportional.enabled)
                this.paramWidth.setValue(this.paramHeight.value.value * this.refWidth / this.refHeight, false, true, false);
        });
    }
    
    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        const paramIds = [];


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            for (const param of this.node.params)
                if (param.input && param.input.connected) 
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            if (this.node.paramX      .input.connected) request.push(...this.node.paramX      .genRequest(gen));
            if (this.node.paramY      .input.connected) request.push(...this.node.paramY      .genRequest(gen));
            if (this.node.paramWidth  .input.connected) request.push(...this.node.paramWidth  .genRequest(gen));
            if (this.node.paramHeight .input.connected) request.push(...this.node.paramHeight .genRequest(gen));
            if (this.node.paramAngle  .input.connected) request.push(...this.node.paramAngle  .genRequest(gen));
            if (this.node.paramRound  .input.connected) request.push(...this.node.paramRound  .genRequest(gen));
            if (this.node.paramCorners.input.connected) request.push(...this.node.paramCorners.genRequest(gen));
        }
        else
        {
            request.push(
                ...this.node.paramX      .genRequest(gen),
                ...this.node.paramY      .genRequest(gen),
                ...this.node.paramWidth  .genRequest(gen),
                ...this.node.paramHeight .genRequest(gen),
                ...this.node.paramAngle  .genRequest(gen),
                ...this.node.paramRound  .genRequest(gen),
                ...this.node.paramCorners.genRequest(gen));
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateNode()
    {
        this.btnProportional.style.left = 45;
        this.btnProportional.style.top  = 79;

        super.updateNode();
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        if (   paramIds.includes('width')
            || paramIds.includes('height'))
            this.updateRound();
    }



    updateRound()
    {
        const control = this.paramRound.control;
        const min     = Math.min(this.paramWidth.value, this.paramHeight.value);

        control.setMin(0);
        control.setMax(min/2);

        this.paramRound.control.update();
    }

    

    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        let json = 
               super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"proportional": "' + boolString(this.btnProportional.enabled) + '"';

        if (this.btnProportional.enabled)
        {
            json +=
                  ',\n' + pos + tab + '"refWidth": "'  + this.refWidth  + '"'
                + ',\n' + pos + tab + '"refHeight": "' + this.refHeight + '"';
        }

        return json;
    }



    loadParams(_node)
    {
        super.loadParams(_node);

        // if (_node.proportional)
        // {
            this.btnProportional.enabled = isTrue(_node.proportional);
            this.btnProportional.updateBackground(false);

            if (this.btnProportional.enabled)
            {
                this.refWidth  = parseFloat(_node.refWidth);
                this.refHeight = parseFloat(_node.refHeight);
            }
        //}
    }
}


class   OpStar
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;
    paramRound;
    paramPoints;
    paramConvex;


    
    constructor()
    {
        super(STAR, 'star', 90);

        this.addInput (new Input ([STAR, STAR_VALUE]));
        this.addOutput(new Output(STAR, this.output_genRequest));

        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        this.addParam(this.paramRound  = new NumberParam('round',  'round',  true, true, true,   0,    0));
        this.addParam(this.paramPoints = new NumberParam('points', 'points', true, true, true,   5,    3));
        this.addParam(this.paramConvex = new NumberParam('convex', 'convex', true, true, true,   38.2, 0, 100));
        

        this.paramAngle.control.setSuffix('', true);
        this.paramAngle.control.wrapValue   = true;
        this.paramAngle.control.dragReverse = true;

        this.paramConvex.control.setSuffix('%', true);
        

        this.btnProportional = createToggleButton(12, 12);
        this.inner.appendChild(this.btnProportional);


        // this.inputs[0].addEventListener('connect', () =>
        // {
        //     for (const param of this.params)
        //         param.enableControlText(false);
        // });


        // this.inputs[0].addEventListener('disconnect', () =>
        // {
        //     for (const param of this.params)
        //         if (!param.input.connected) 
        //             param.enableControlText(true);
        // });


        this.btnProportional.addEventListener('click', () =>
        {
            if (this.btnProportional.enabled)
            {
                this.refWidth  = this.paramWidth .value.value;
                this.refHeight = this.paramHeight.value.value;
            }
        });


        this.paramWidth.addEventListener('change', () =>
        {
            if (this.btnProportional.enabled)
                this.paramHeight.setValue(this.paramWidth.value.value * this.refHeight / this.refWidth, false, true, false);
        });


        this.paramHeight.addEventListener('change', () =>
        {
            if (this.btnProportional.enabled)
                this.paramWidth.setValue(this.paramHeight.value.value * this.refWidth / this.refHeight, false, true, false);
        });
    }
    
    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        if (!isEmpty(this.cache))
            return this.cache;


        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: '' });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        const paramIds = [];


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            for (const param of this.node.params)
                if (param.input && param.input.connected) 
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            if (this.node.paramX     .input.connected) request.push(...this.node.paramX     .genRequest(gen));
            if (this.node.paramY     .input.connected) request.push(...this.node.paramY     .genRequest(gen));
            if (this.node.paramWidth .input.connected) request.push(...this.node.paramWidth .genRequest(gen));
            if (this.node.paramHeight.input.connected) request.push(...this.node.paramHeight.genRequest(gen));
            if (this.node.paramAngle .input.connected) request.push(...this.node.paramAngle .genRequest(gen));
            if (this.node.paramRound .input.connected) request.push(...this.node.paramRound .genRequest(gen));
            if (this.node.paramPoints.input.connected) request.push(...this.node.paramPoints.genRequest(gen));
            if (this.node.paramConvex.input.connected) request.push(...this.node.paramConvex.genRequest(gen));
        }
        else
        {
            request.push(
                ...this.node.paramX     .genRequest(gen),
                ...this.node.paramY     .genRequest(gen),
                ...this.node.paramWidth .genRequest(gen),
                ...this.node.paramHeight.genRequest(gen),
                ...this.node.paramAngle .genRequest(gen),
                ...this.node.paramRound .genRequest(gen),
                ...this.node.paramPoints.genRequest(gen),
                ...this.node.paramConvex.genRequest(gen));
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateNode()
    {
        this.btnProportional.style.left = 45;
        this.btnProportional.style.top  = 79;

        super.updateNode();
    }



    updateValues(updateParamId, paramIds, values)
    {
        super.updateValues(updateParamId, paramIds, values);

        if (   paramIds.includes('width')
            || paramIds.includes('height'))
            this.updateRound();
    }



    updateRound()
    {
        const control = this.paramRound.control;
        const min     = Math.min(this.paramWidth.value, this.paramHeight.value);

        control.setMin(0);
        control.setMax(min/2);

        this.paramRound.control.update();
    }

    

    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = TAB;

        let json = 
               super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"proportional": "' + boolString(this.btnProportional.enabled) + '"';

        if (this.btnProportional.enabled)
        {
            json +=
                  ',\n' + pos + tab + '"refWidth": "'  + this.refWidth  + '"'
                + ',\n' + pos + tab + '"refHeight": "' + this.refHeight + '"';
        }

        return json;
    }



    loadParams(_node)
    {
        super.loadParams(_node);

        // if (_node.proportional)
        // {
            this.btnProportional.enabled = isTrue(_node.proportional);
            this.btnProportional.updateBackground(false);

            if (this.btnProportional.enabled)
            {
                this.refWidth  = parseFloat(_node.refWidth);
                this.refHeight = parseFloat(_node.refHeight);
            }
        //}
    }
}


// class   OpColorStroke
// extends OpShapeBase
// {
//     paramColor;
//     paramOpacity;

//     paramStrokeWeight;
//     paramStrokeFit;
//     paramStrokeJoin;
//     paramStrokeMiter;

    
//     constructor()
//     {
//         super(COLOR_STROKE, 'stroke', 90);


//         this.addInput(new Input(SHAPE_TYPES));
//         this.addOutput(new Output(COLOR_STROKE, this.output_genRequest));

//         this.addParam(this.paramColor        = new ColorParam ('color',        '',        false, true, true));
//         this.addParam(this.paramOpacity      = new NumberParam('opacity',      'opacity', true,  true, true, 100, 0, 100));

//         this.addParam(this.paramStrokeWeight = new NumberParam('strokeWeight', 'weight', true,  true, true, 1, 0));
//         this.addParam(this.paramStrokeFit    = new SelectParam('strokeFit',    'fit',    true,  true, true, ['inside', 'center', 'outside'], 0));
//         this.addParam(this.paramStrokeJoin   = new SelectParam('strokeJoin',   'join',   true,  true, true, ['miter', 'bevel', 'round'], 0));
//         this.addParam(this.paramStrokeMiter  = new NumberParam('strokeMiter',  'miter',  false, true, true, 28.96, 0, 180, 2));

//         this.paramColor.setValue(ColorValue.create(1, 0, 0, 0), false, true, false);
        
//         this.paramOpacity    .control.setSuffix('%', true);
//         this.paramStrokeMiter.control.setSuffix('', true);
//     }
    
    
    
//     output_genRequest(gen)
//     {
//         // 'this' is the output

//         if (!isEmpty(this.cache))
//             return this.cache;


//         gen.scope.push({
//             nodeId:  this.node.id, 
//             paramId: '' });

//         const [request, ignore] = this.node.genRequestStart(gen);
//         if (ignore) return request;

        
//         const input = this.node.inputs[0];

//         if (input.connected)
//             request.push(...pushInputOrParam(input, gen));

//         request.push(...this.node.paramColor       .genRequest(gen));
//         request.push(...this.node.paramOpacity     .genRequest(gen));
//         request.push(...this.node.paramStrokeWeight.genRequest(gen));
//         request.push(...this.node.paramStrokeFit   .genRequest(gen));
//         request.push(...this.node.paramStrokeJoin  .genRequest(gen));
//         request.push(...this.node.paramStrokeMiter .genRequest(gen));


//         gen.scope.pop();
//         pushUnique(gen.passedNodes, this.node);

//         return request;
//     }
// }


class Action
{
    manager;
 
    id;
    name;
  
    prevAction; // these are used to link actions into sequences
    nextAction; 
  
    data;
  
    onBefore;
    onAfter;

    onBeforeUndo;
    onAfterUndo;

    
    _linkWithNext = false;


    constructor(name)
    {
        this.name = name;

        console.assert(
               this.name != undefined
            && this.name != null
            && this.name != '',
            'cannot create user action');
    }



    do() {}



    redo()
    {
        this.do();
    }



    undo() {}
};



function linkActions(prevAction, nextAction)
{
    prevAction.nextAction = nextAction;
    nextAction.prevAction = prevAction;
}


class ActionManager
{
    actions      = [];
    redoActions  = [];
    
    nextActionId = 0;
   
    
    
    do(action, linkWithPrevious = false, linkWithNext = false)
    {
        // this is a fresh new action so any 
        // old redo queue is no longer relevant
        this.redoActions = [];

        this.actions.push(action);

        action.id            = this.nextActionId++;
        action.manager       = this;
        action._linkWithNext = linkWithNext;

        if (this.actions.length > 1)
        {
            const before = beforeLastOf(this.actions);
            const last   = lastOf      (this.actions);

            if (   linkWithPrevious
                || before._linkWithNext)
            {
                linkActions(before, last);
                before._linkWithNext = false;
            }
        }


        if (settings.logActions)
        {
            console.log(
                "%cDO %s", 
                'background: #e8ffe8; \
                 color:      #282;', 
                action.name);
        }
        
        action.do(); 
    }



    undo()
    {
        if (this.actions.length == 0)
            return;

        for (;;)
        {
            let last = removeLast(this.actions);
            this.redoActions.push(last);


            if (settings.logActions)
            {
                console.log(
                    "%cUNDO %s", 
                    'background: #fff4e8; \
                     color:      #c64;', 
                    last.name);
            }

            last.undo(); 


            if (   this.actions.length == 0
                || last.prevAction != lastOf(this.actions))
                break;
        }
    }



    redo()
    {
        if (this.redoActions.length == 0)
            return;
    
        for (;;)
        {
            let last = removeLast(this.redoActions);
            this.actions.push(last);


            if (settings.logActions)
            {
                console.log(
                    "%cREDO %s", 
                    'background: #ffd; \
                     color:      #b80;', 
                    last.name);
            }

            last.redo(); 
        

            if (   this.redoActions.length == 0
                || last.nextAction != lastOf(this.redoActions))
                break;
        }
    }
}



const actionManager = new ActionManager();


class ConnectAction
extends Action
{
    outputNodeId;
    outputIndex;
    get outputNode() { return nodeFromId(this.outputNodeId); }
    get output()     { return this.outputNode.outputs[this.outputIndex]; }
    
    oldOutputNodeId = '';
    oldOutputIndex;
    get oldOutputNode() { return nodeFromId(this.oldOutputNodeId); }
    
    inputNodeId;
    inputIndex;
    get inputNode() { return nodeFromId(this.inputNodeId); }
    get input()     { return this.inputNode.inputs[this.inputIndex]; }
    
    oldOutputActiveNodeId;      // the active node in the output node's tree
    oldInputActiveNodeIds = []; // the active nodes in the input node's tree
    
    newActiveNodeIds = [];

    oldinputValues   = []; // in index,value pairs, to be restored on undo



    constructor(output, input)
    {
        const oldOutIndex = 
            input.connected 
            ? input.connectedOutput.index
            : -1; 

        super('CONNECT ' 
            + output.node.id + ' ' + output.index
            + '  '
            + input.node.id + ' ' + input.index);


        this.outputNodeId    = output.node.id;
        this.outputIndex     = output.index;
   
        this.oldOutputNodeId = input.connected ? input.connectedOutput.node.id : '';
        this.oldOutputIndex  = oldOutIndex;
   
        this.inputNodeId     = input.node.id;
        this.inputIndex      = input.index;
    }


    
    do()
    {
        this.oldInputValues = 
            this.input.getValuesForUndo
            ? this.input.getValuesForUndo()
            : [];


        this.oldOutputActiveNodeId = idFromNode(getActiveNodeInTreeFromNodeId(this.outputNodeId));
        this.oldInputActiveNodeIds = getActiveNodesRightInTreeFromNodeId(this.inputNodeId).map(n => n.id);


        uiConnect(
            this.outputNode.outputs[this.outputIndex], 
            this.inputNode. inputs [this. inputIndex],
            this.inputIndex);


        this.newActiveNodeIds = [];

        const updateNodes = [this.inputNode];

        
        if (    this.oldOutputNode
            && !getActiveNodeInTreeFromNode(this.oldOutputNode))
        {
            uiMakeNodeActive(this.oldOutputNode);
            this.newActiveNodeIds.push(this.oldOutputNodeId);
        }


        const oldOutputActiveNode = nodeFromId(this.oldOutputActiveNodeId);
        if (oldOutputActiveNode) pushUnique(updateNodes, oldOutputActiveNode);


        const oldInputActiveNodeIds = [...this.oldInputActiveNodeIds];
        oldInputActiveNodeIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldInputActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));


        updateNodes.forEach(n => n.updateNode());
    }



    undo()
    {
        uiDisconnect(this.inputNode.inputs[this.inputIndex]);


        if (this.oldOutputNodeId != '')
        {
            uiVariableConnect(
                this.oldOutputNode, 
                this.oldOutputIndex, 
                this.inputNode, 
                this.inputIndex);
        }


        // restore old values
        for (const param of this.oldInputValues)
        {
            this.inputNode.params[this.inputNode.params.findIndex(p => p.id == param[0])]
                .setValue(param[1], true, true, false);
        }


        const updateNodes = [];

        for (const id of this.newActiveNodeIds)
        {
            const node = nodeFromId(id);
            uiMakeNodePassive(node);
        }

        for (const id of this.oldInputActiveNodeIds)
        {
            const node = nodeFromId(id);
            uiMakeNodeActive(node);
        }

        if (!this.oldInputActiveNodeIds.includes(this.oldOutputActiveNodeId))
        {
            const node = nodeFromId(this.oldOutputActiveNodeId);
            uiMakeNodeActive(node);
        }


        this.inputNode.updateNode();
 

        // cleanup
        this.oldOutputActiveNodeId = [];
        this.oldInputActiveNodeIds = [];
   }
}


class CreateNodeAction
extends Action
{
    nodeType;
    createdNodeId;

    options = {};

    prevSelectedIds = []; // currently selected nodes that are deselected as a result of creation

    creatingButton;
    


    constructor(nodeType, creatingButton, options = {})
    {
        super('CREATE \'' + nodeType + '\'');
        
        this.nodeType       = nodeType;
        this.creatingButton = creatingButton;

        this.options        = options;
    }



    do()
    {
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);

        const node = uiCreateNode(
            this.nodeType, 
            this.creatingButton, 
            -1, 
            true, 
            this.options);

        this.createdNodeId = node.id;

        graphView.updateNodeTransform(node);
        setTimeout(() => graphView.updateScrollWithBounds());
        
        uiMakeNodeActive(node);
    }



    undo()
    {
        uiDeleteNodes([this.createdNodeId]);

        graphView.selectByIds(this.prevSelectedIds);
    }



    redo()
    {
        const node = uiCreateNode(
            this.nodeType, 
            this.creatingButton, 
            this.createdNodeId, 
            true, 
            this.options);

        graphView.updateNodeTransform(node);
        setTimeout(() => graphView.updateScrollWithBounds());

        uiMakeNodeActive(node);
    }
}


class DeleteNodesAction
extends Action
{
    nodeIds          = [];
    prevSelectedIds  = [];
    
    nodes            = [];
    nodePos          = [];

    oldConnections   = []; // [{outputNodeId, outputIndex, inputNodeId, inputIndex}]

    newActiveNodeIds = [];
    oldActiveNodeIds = [];



    constructor(nodeIds)
    {
        super('DELETE ' + nodeIds.length + ' ' + countToString(nodeIds, 'node'));

        this.nodeIds         = [...nodeIds]; // clone the array
        this.nodes           = nodeIds.map(id => nodeFromId(id));
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);
    }



    addConnection(conn)
    {
        if (!this.oldConnections.find(c => 
                   c.outputNodeId == conn.output.node.id
                && c.outputIndex  == conn.output.index
                && c. inputNodeId == conn. input.node.id
                && c. inputIndex  == conn. input.index))
            this.oldConnections.push(getConnectionForArrayWithIds(conn));
    }



    do()
    {
        this.newActiveNodeIds = [];
        this.oldActiveNodeIds = [];

        for (const nodeId of this.nodeIds)
            pushUnique(this.oldActiveNodeIds, getActiveNodesInTreeFromNodeId(nodeId).map(n => n.id));
        

        for (const nodeId of this.nodeIds)
        {
            const node = nodeFromId(nodeId);

            this.nodePos.push(point(
                node.div.offsetLeft, 
                node.div.offsetTop));

            for (const input of node.inputs.filter(i => i.connected))
                this.addConnection(input.connection);

            for (const output of node.outputs)
                for (const input of output.connectedInputs)
                    this.addConnection(input.connection);
        }


        const updateNodes = [];


        for (const nodeId of this.nodeIds)
        {
            const node = nodeFromId(nodeId);


            const nodeInputs = [...node.inputs.filter(i => i.connected)];

            for (let i = nodeInputs.length-1; i >= 0; i--)
                updateNodes.push(...this.disconnect(nodeInputs[i], this.nodeIds));

                
            for (const output of node.outputs)
            {
                const connectedInputs = [...output.connectedInputs];
                removeFromArrayWhere(connectedInputs, i => i.node == node);

                // connected inputs need to be sorted by input index
                connectedInputs.sort((i1, i2) => 
                {
                    const node1 = i1.node;
                    const node2 = i2.node;
                        
                    const index1 = node1.inputs.indexOf(i1);
                    const index2 = node2.inputs.indexOf(i2);
                    
                    if (node1.id != node2.id) return node1.id - node2.id;
                    if (index1   != index2)   return index1   - index2;
                    return 0;
                });
 

                for (const input of connectedInputs)
                    updateNodes.push(...this.disconnect(input, this.nodeIds));
            }
        }

        
        uiDeleteNodes(this.nodeIds);

        uiSaveNodes(this.newActiveNodeIds);
       
        pushUpdate(updateNodes.filter(n => graph.nodes.includes(n)));
    }



    undo()
    {
        this.restoreNodes();
        this.restoreConns();

        this.nodePos     = [];
        this.oldConnections = [];

        graphView.selectByIds(this.prevSelectedIds);

        for (const id of this.newActiveNodeIds)
            uiMakeNodePassive(nodeFromId(id));
        

        let oldActiveNodeIds = [...this.oldActiveNodeIds];
        oldActiveNodeIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

        
        for (const id of oldActiveNodeIds)
            uiMakeNodesActive(oldActiveNodeIds.map(id => nodeFromId(id)));
    

        uiSaveNodes([
            ...this.newActiveNodeIds,
            ...this.oldActiveNodeIds]);
    }



    restoreNodes()
    {
        //console.log('this.nodes', this.nodes);

        graph.addNodes(this.nodes);
        graphView.selected = this.nodes;
        graphView.putNodeOnTop(lastOf(this.nodes));
    
        for (let i = 0; i < this.nodes.length; i++)
        {
            setNodePosition(
                this.nodes[i], 
                this.nodePos[i].x, 
                this.nodePos[i].y);
        }

        for (let i = 0; i < this.nodes.length; i++)
            this.nodes[i].id = this.nodeIds[i];
    }



    restoreConns()
    {
        const connections    = this.oldConnections.filter(c => !nodeFromId(c.inputNodeId).variableInputs);
        const varConnections = this.oldConnections.filter(c =>  nodeFromId(c.inputNodeId).variableInputs);
        
        varConnections.sort((c1, c2) =>
        {
            if (c1.inputNodeId != c2.inputNodeId) return c1.inputNodeId - c2.inputNodeId;
            if (c1.inputIndex  != c2.inputIndex ) return c1.inputIndex  - c2.inputIndex;
            return 0;
        });
        
        this.connect(connections);
        this.connect(varConnections);
    }



    connect(connections)
    {
        for (const conn of connections)
        {
            const outputNode = nodeFromId(conn.outputNodeId);
            const  inputNode = nodeFromId(conn. inputNodeId);

            uiVariableConnect(outputNode, conn.outputIndex, inputNode, conn.inputIndex);
        }
    }



    disconnect(input, ignoreNodeIds = [])
    {
        //console.log('disconnect');

        const output      = input.connectedOutput;
        const updateNodes = [input.node];        


        uiDisconnect(input);


        const activeLeft     = getActiveNodeLeftInTreeFromNode(output.node);
        const activeLeftOnly = getActiveNodeLeftOnlyInTreeFromNode(output.node);
        const activeRight    = getActiveNodeRightInTreeFromNode(input.node);


        if (  !activeLeftOnly
            && activeLeft != activeRight)
        {
            if (!ignoreNodeIds.includes(output.node.id))
            {
                uiMakeNodeActive(output.node);
                pushUnique(this.newActiveNodeIds, output.node.id);
            }

            updateNodes.push(output.node);
        }


        if (   !activeRight
            && !ignoreNodeIds.includes(input.node.id))
        {
            uiMakeNodeActive(input.node);
            pushUnique(this.newActiveNodeIds, input.node.id);
        }
        

        return updateNodes;
    }
}


class DisconnectAction
extends Action
{
    outputNodeId;
    outputIndex;
    get outputNode() { return nodeFromId(this.outputNodeId); }

    inputNodeId;
    inputIndex;
    get inputNode() { return nodeFromId(this.inputNodeId); }

    oldActiveNodeIds = [];
    newActiveNodeIds = [];



    constructor(output, input)
    {
        super('DISCONNECT ' 
            + output.node.id + ' ' + output.index
            + '  '
            + input.node.id + ' ' + input.index);


        this.outputNodeId = output.node.id;
        this.outputIndex  = output.index;

        this.inputNodeId  = input.node.id;
        this.inputIndex   = input.index;
    }



    do()
    {
        this.oldActiveNodeIds = [...getActiveNodesInTreeFromNodeId(this.inputNodeId).map(n => n.id)];


        uiDisconnect(this.inputNode.inputs[this.inputIndex]);
        this.inputNode.invalidate();
        

        if (!getActiveNodeInTreeFromNode(this.inputNode))
        {
            uiMakeNodeActive(this.inputNode);
            this.newActiveNodeIds.push(this.inputNodeId);
        }


        if (   !getActiveNodeLeftOnlyInTreeFromNode(this.outputNode)
            && !getActiveNodeRightInTreeFromNode(this.outputNode))
        {
            uiMakeNodeActive(this.outputNode);
            this.newActiveNodeIds.push(this.outputNodeId);
        }


        this.outputNode.updateNode();
        this.inputNode .updateNode();


        pushUpdate([this.inputNode]);
    }
    
    
    
    undo()
    {
        uiVariableConnect(
            this.outputNode, this.outputIndex, 
            this. inputNode, this. inputIndex);

        for (const id of this.newActiveNodeIds)
            uiMakeNodePassive(nodeFromId(id));


        let oldActiveNodeIds = [...this.oldActiveNodeIds];
        this.oldActiveNodeIds = [];
        

        oldActiveNodeIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));


        this.inputNode.updateNode();
    }
    
    
    
    redo()
    {
        uiDisconnect(this.inputNode.inputs[this.inputIndex]);
        

        if (!getActiveNodeInTreeFromNode(this.inputNode))
            uiMakeNodeActive(this.inputNode);

        if (   !getActiveNodeLeftOnlyInTreeFromNode(this.outputNode)
            && !getActiveNodeRightInTreeFromNode(this.outputNode))
            uiMakeNodeActive(this.outputNode);


        this.outputNode.updateNode();
        this.inputNode .updateNode();


        pushUpdate([this.inputNode]);
    }
}


class DuplicateNodesAction
extends Action
{
    copiedJson;
    pastedNodeIds = [];


    constructor(copiedJson)
    {
        const data = JSON.parse(copiedJson);

        super('DUPLICATE ' + data.nodes.length + ' ' + countToString(data.nodes, 'node'));

        this.copiedJson = copiedJson;
    }



    do()
    {
        this.pastedNodeIds = uiPasteNodes(this.copiedJson).map(n => n.id);

        uiSaveNodes(nodes.map(n => n.id));
    }



    undo()
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        pasteOffset[0] -= pasteOffsetDelta[0];
        pasteOffset[1] -= pasteOffsetDelta[1];

        uiRemoveSavedNodesAndConns(this.pastedNodeIds);
    }
}


class FindValidColorAction
extends Action
{
    // nodeId;

    // oldValue1;
    // oldValue1;
    // oldValue1;
    
    // newValue;



    // constructor(param, value)
    // {
    //     super('FIND VALID ' + param.node.id + '.' + param.id + ' = ' + value);

    //     this.nodeId  = param.node.id;
    //     this.paramId = param.id;

    //     this.newValue = value;
    // }



    // do()
    // {
    //     this.oldValue = this.param.oldValue;
    //     pushUpdate([this.param.node]);

    //     uiSaveNodes([this.nodeId]);
    // }



    // undo()
    // {
    //     this.param.setValue(this.oldValue, false, true);
    //     pushUpdate([this.param.node]);

    //     uiSaveNodes([this.nodeId]);
    // }



    // redo()
    // {
    //     this.param.setValue(this.newValue);
    //     pushUpdate([this.param.node]);

    //     uiSaveNodes([this.nodeId]);
    // }
}


class MakeActiveNodeAction
extends Action
{
    activeId;

    oldActiveNodeIds = [];



    constructor(activeId)
    {
        super('MAKE ACTIVE ' + activeId);

        this.activeId = activeId;
    }



    do()
    {
        this.oldActiveNodeIds = [...getActiveNodesInTreeFromNodeId(this.activeId).map(n => n.id)]; 

        uiMakeNodeActive(nodeFromId(this.activeId));

        uiSaveNodes(filterUnique([this.activeId, ...this.oldActiveNodeIds]));
    }



    undo()
    {
        if (!this.oldActiveNodeIds.includes(this.activeId));
            uiMakeNodePassive(nodeFromId(this.activeId));

        for (const id of this.oldActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));

        uiSaveNodes(filterUnique([this.activeId, ...this.oldActiveNodeIds]));
    }
}


class PasteNodesAction
extends Action
{
    copiedNodesJson;

    pasteOutsideConnections;

    pastedNodeIds = [];
    pastedNodePos = [];

    prevSelectedNodeIds = [];

    oldActiveNodeIds = [];



    constructor(copiedNodesJson, pasteOutsideConnections)
    {
        const data = JSON.parse(copiedNodesJson);

        super('PASTE ' + data.nodes.length + ' ' + countToString(data.nodes, 'node'));

        this.copiedNodesJson         = copiedNodesJson;
        this.pasteOutsideConnections = pasteOutsideConnections;
    }



    do()
    {
        this.prevSelectedNodeIds = graphView.selectedNodes.map(n => n.id);


        this.oldActiveNodeIds = [];

        for (const nodeId of this.prevSelectedNodeIds)
            pushUnique(this.oldActiveNodeIds, getActiveNodesInTreeFromNodeId(nodeId).map(n => n.id));


        const nodes = uiPasteNodes(this.copiedNodesJson, this.pasteOutsideConnections);

        this.pastedNodeIds = nodes.map(n => n.id);
        this.pastedNodePos = nodes.map(n => { return point(n.div.offsetLeft, n.div.offsetTop); });


        updateTerminalsAfterNodes(nodes);
        
        graphView.updateNodeTransforms(nodes);
        graphView.updateScrollWithBounds();

        uiSaveNodes(nodes.map(n => n.id));
    }



    undo()
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        pasteOffset[0] -= pasteOffsetDelta[0];
        pasteOffset[1] -= pasteOffsetDelta[1];

        graphView.selectedNodes = graph.nodes.filter(n => this.prevSelectedNodeIds.includes(n.id));


        let oldActiveNodeIds = [...this.oldActiveNodeIds];
        //console.log('oldActiveNodeIds', oldActiveNodeIds);
        oldActiveNodeIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));
    }



    redo()
    {
        const nodes = uiPasteNodes(this.copiedNodesJson, this.pasteOutsideConnections);
        
        this.pastedNodeIds = nodes.map(n => n.id);

        for (let i = 0; i < nodes.length; i++)
        {
            setNodePosition(
                nodes[i], 
                this.pastedNodePos[i].x,
                this.pastedNodePos[i].y);
        }

        updateTerminalsAfterNodes(nodes);
        graphView.updateNodeTransforms(nodes);

        uiSaveNodes(nodes.map(n => n.id));
    }
}


class ReconnectAction
extends Action
{
    outputNodeId;
    outputIndex;
    get outputNode() { return nodeFromId(this.outputNodeId); }

    oldOutputNodeId = '';
    oldOutputIndex;
    get oldOutputNode() { return nodeFromId(this.oldOutputNodeId); }

    inputNodeId;
    inputIndex;
    get inputNode() { return nodeFromId(this.inputNodeId); }

    oldInputNodeId = '';
    oldInputIndex;
    get oldInputNode() { return nodeFromId(this.oldInputNodeId); }
    
    oldOutputActiveNodeId;      // the active node in the output node's tree
    oldInputActiveNodeIds = []; // the active nodes in the input node's tree

    newActiveNodeIds = [];



    constructor(output, oldInput, input)
    {
        const oldOutIndex = 
            input.connected 
            ? input.connectedOutput.index
            : -1; 


        super(
             'RECONNECT '
            + output.node.id + ' ' + output.index
            + ' ( '
            + oldInput.node.id + ' ' + oldInput.index
            + ')  '
            + input.node.id + ' ' + input.index);


        this.outputNodeId          = output.node.id;
        this.outputIndex           = output.index;
               
        this.oldOutputNodeId       = input.connected ? input.connectedOutput.node.id : '';
        this.oldOutputIndex        = oldOutIndex;
       
        this.oldInputNodeId        = oldInput.node.id;
        this.oldInputIndex         = oldInput.index;
       
        this.inputNodeId           = input.node.id;
        this.inputIndex            = input.index;

        this.oldOutputActiveNodeId = getActiveNodeInTreeFromNodeId(this.outputNodeId).id;
        this.oldInputActiveNodeIds = [...getActiveNodesInTreeFromNodeId(this.inputNodeId).map(n => n.id)];
    }



    do()
    {
        uiDisconnect(this.oldInputNode.inputs[this.oldInputIndex]);
        

        uiConnect(
            this.outputNode.outputs[this.outputIndex], 
            this. inputNode. inputs[this. inputIndex],
            this.inputIndex);
            

        this.newActiveNodeIds = [];

        if (!getActiveNodeInTreeFromNode(this.oldOutputNode))
        {
            uiMakeNodeActive(this.oldOutputNode);
            this.newActiveNodeIds.push(this.oldOutputNodeId);

            pushUpdate([this.oldOutputNode]);
        }


        let oldInputActiveNodeIds = [...this.oldInputActiveNodeIds];
        oldInputActiveNodeIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldInputActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));
    }



    undo()
    {
        uiDisconnect(this.inputNode.inputs[this.inputIndex]);

            
        uiVariableConnect(
            this.outputNode, 
            this.outputIndex, 
            this.oldInputNode, 
            this.oldInputIndex);

        uiSaveNodes([this.oldInputNodeId]);
    

        if (this.oldOutputNodeId != '')
        {
            uiVariableConnect(
                this.oldOutputNode, 
                this.oldOutputIndex, 
                this.inputNode, 
                this.inputIndex);

            pushUpdate([this.inputNode]);
        }


        for (const id of this.newActiveNodeIds)
            uiMakeNodePassive(nodeFromId(id));

        for (const id of this.oldInputActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));

        if (!this.oldInputActiveNodeIds.includes(this.oldOutputActiveNodeId))
            uiMakeNodeActive(nodeFromId(this.oldOutputActiveNodeId));
    }
}


class RenameNodeAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    oldName;
    newName;



    constructor(nodeId, newName)
    {
        super('RENAME ' + nodeId + ' to \'' + newName + '\'');

        this.nodeId  = nodeId;
        this.newName = newName;
    }



    do()
    {
        this.oldName = this.node.name;
        this.node.setName(this.newName);

        uiSaveNodes([this.nodeId]);
    }



    undo()
    {
        this.node.setName(this.oldName);
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    redo()
    {
        this.node.setName(this.newName);
        this.node.updateNode();
        
        uiSaveNodes([this.nodeId]);
    }
}


class ReorderInputAction
extends Action
{
    nodeId;

    oldIndex;
    newIndex;
 


    constructor(nodeId, oldIndex, newIndex)
    {
        super(
              'REORDER ' + nodeFromId(nodeId).id 
            + ' ' + oldIndex
            + ' to ' + newIndex);

        this.nodeId   = nodeId;
        this.oldIndex = oldIndex;
        this.newIndex = newIndex;
    }



    do()
    {
        // .. already done

        pushUpdate([nodeFromId(this.nodeId)]);

        uiSaveNodes([this.nodeId]);


        uiRemoveSavedConnectionsToNodeId(this.nodeId);


        const node = nodeFromId(this.nodeId);

        for (const input of node.inputs.filter(i => i.connected))
        {
            const output = input.connectedOutput;

            uiSaveConnection(
                output.node.id, output.index,
                 input.node.id,  input.index,
                input.connection.toJson());
        }
    }



    undo()
    {
        const node = nodeFromId(this.nodeId);

        moveInArray(
            node.inputs,
            this.newIndex,
            this.oldIndex);
            
        pushUpdate([node]);

        uiSaveNodes([this.nodeId]);
    }



    redo()
    {
        const node = nodeFromId(this.nodeId);

        moveInArray(
            node.inputs,
            this.oldIndex,
            this.newIndex);

        uiSaveNodes([this.nodeId]);

        pushUpdate([node]);
    }
}


class SelectMoveNodesAction
extends Action
{
    newSelectedIds  = [];
    prevSelectedIds = [];

    shiftPressed;

    fromPos;
    toPos;

    from;
    to;



    constructor(prevSelectedIds, newSelectedIds, fromPos, toPos, shiftPressed)
    {
        super(
            'SELECT MOVE ' + newSelectedIds.length 
          + ' ' + countToString(newSelectedIds, 'node'));


        this.prevSelectedIds = [...prevSelectedIds];
        this.newSelectedIds  = [...newSelectedIds];
          
        this.shiftPressed    = shiftPressed;

        this.fromPos         = fromPos;
        this.toPos           = toPos;


        
        const dx = this.toPos.x - this.fromPos.x;
        const dy = this.toPos.y - this.fromPos.y;


        this.from = []; // these hold tuples
        this.to   = []; // [id, pos]

        for (const id of this.getMovedIds())
        {
            const node = nodeFromId(id);

            this.from.push([id, point(node.div.slx,      node.div.sly     )]);
            this.to  .push([id, point(node.div.slx + dx, node.div.sly + dy)]);
        }
    }



    getMovedIds()
    {
        const movedIds = [];

        if (this.shiftPressed)
            movedIds.push(...this.prevSelectedIds);
        
        movedIds.push(...this.newSelectedIds);

        return movedIds;
    }


    
    do()
    {
        const movedIds   = this.getMovedIds();
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (var i = 0; i < movedNodes.length; i++)
        {
            const p = this.to.find(t => t[0] == movedNodes[i].id)[1];
            setNodePosition(movedNodes[i].div.node, p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateNode();//Border();

        uiSaveNodes(movedIds);
    }



    undo()
    {
        const movedIds   = this.getMovedIds();
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (var i = 0; i < movedNodes.length; i++)
        {
            const p = this.from.find(t => t[0] == movedNodes[i].id)[1];
            setNodePosition(movedNodes[i].div.node, p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateNode();
            
        graphView.selectByIds(this.prevSelectedIds);

        uiSaveNodes(movedIds);
    }



    redo()
    {
        this.do();

        graphView.selectByIds(this.getMovedIds());
    }
}


class SelectNodesAction
extends Action
{
    selectedIds     = [];
    prevSelectedIds = [];



    constructor(selectedIds, prevSelectedIds)
    {
        super(
              'SELECT ' + selectedIds.length 
            + ' ' + countToString(selectedIds, 'node'));

        this.selectedIds     = [...selectedIds];
        this.prevSelectedIds = [...prevSelectedIds];
    }



    do()
    {
        // this happens in the UI
    }



    undo()
    {
        graphView.selectByIds(this.prevSelectedIds);
    }



    redo()
    {
        graphView.selectByIds(this.selectedIds);
    }
}


class SetParamValueAction
extends Action
{
    nodeId;
    paramId;

    get param() 
    { 
        return nodeFromId(this.nodeId).params
               .find(p => p.id == this.paramId); 
    } 


    oldValue; // decimal
    newValue; // decimal



    constructor(param, value)
    {
        super('SET VALUE ' + param.node.id + '.' + param.id + ' = ' + value.toDisplayString());

        this.nodeId   = param.node.id;
        this.paramId  = param.id;

        this.newValue = value;
    }



    do()
    {
        this.oldValue = this.param.oldValue;
        pushUpdateFromParam([this.param.node], this.param);

        //uiSaveNodes([this.nodeId]);
    }



    undo()
    {
        this.param.setValue(this.oldValue, false, true);
        pushUpdateFromParam([this.param.node], this.param);

        //uiSaveNodes([this.nodeId]);
    }



    redo()
    {
        this.param.setValue(this.newValue);
        pushUpdateFromParam([this.param.node], this.param);

        //uiSaveNodes([this.nodeId]);
    }
}


class ToggleArithmeticSymbolAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    showOnlySymbol;



    constructor(nodeId, showOnlySymbol)
    {
        super('TOGGLE MATH SYMBOL ' + boolString(showOnlySymbol));

        this.nodeId         = nodeId;
        this.showOnlySymbol = showOnlySymbol;
    }



    do()
    {
        this.node._showOnlySymbol = this.showOnlySymbol;
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    undo()
    {
        this.node._showOnlySymbol = !this.showOnlySymbol;
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }    
}


const colFigmaBlue         = '#0c8ce9';


const rgbObjectLight       = hex2rgb('#bee0ff');
const rgbActiveObjectLight = hex2rgb('#18a0fb');

const rgbObjectDark        = hex2rgb('#3c5c82');
const rgbActiveObjectDark  = hex2rgb('#18a0fb');


const rgbNumberLight       = hex2rgb('#ddd');
const rgbActiveNumberLight = hex2rgb('#787878');

const rgbNumberDark        = hex2rgb('#505050');
const rgbActiveNumberDark  = hex2rgb('#888');


const rgbColor             = hex2rgb('#ddd');   
const rgbActiveColor       = hex2rgb('#787878');


const rgbNoColorLight      = [0.95, 0.95, 0.95];
const rgbNoColorDark       = [0.3, 0.3, 0.3];

const rgbaNoColorTextLight  = [0, 0, 0, 0.6];
const rgbaNoColorTextDark   = [1, 1, 1, 0.4];


const rgbDefaultFill        = [0xD9, 0xD9, 0xD9];
var rgbDocumentBody;



function initModeColors()
{
    rgbDocumentBody = computedStyle2rgba(document.body, 'background-color');
}


const panCursor = 
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3Ln'
    + 'czLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzJweCIgaGVpZ2h0PSIzMnB4Ij48aW1hZ2UgeGxpbms6aHJlZj0i'
    + 'ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWE'
    + 'hlQUFBSHFrbEVRVlI0WHUyYWY4aVY1Um5IUDlhbXpjM0tkRERkSDJ2WitpUEQvdEJTSEtLQ1EyVmJaTWdnbDAx'
    + 'TENUUmJ0Q1hLSFA1Z1N1UWZNZGtmZ3lrMkZLTWtjU0wrV0RKbExOU2xwaWtSaEdRU1VTMU4zV2JiYW5OOG50M1'
    + 'h1N3ZIOXpYUE9jOXp3dDczZ3B2M25QT2U4enpQOWIyLzE4Lzc2a1UzbDE3ZFhIOTZBT2hoUURkSG9NY0V1amtC'
    + 'ZXB4Z2p3bTAwUVFFTzFiYzlnSVFxNDJQOHY5YnRZTUIzdU9xdEs0R0JnRTNBdThBYndML1R1cy9nS3V0VWpjQV'
    + 'hsK2x2d0I4RVZnRXpNODBmQkZZRFR3UGZGd0NvaTNNcUJzQWxWZnhQc0R2Z0xFcVAyVElFSTRmUDU3djlGVGdq'
    + 'OEJOd0YrQk54SWJaRWV0ektnRGdMQnphYS95MXdEZkIzNnJ4cHMyYldMS2xDbWNPSEdDdVhQbnNtM2JOai9lQl'
    + 'h3TnVDMmhjaEJZRE93QlBrcnNxTVU4cWdTZ2JPdlMzcDN2Qzh3R2ZqNXk1RWoyN2R2WHNmT3JWNjltOW16LzFh'
    + 'VThEdndhK0ZkZElGUUZRRGc1ZDF6RjF3SERnZXVBVjREWGdBZVhMRm5DNHNWdTdQOWt6NTQ5akI4L3ZuanQ1K1'
    + 'BHamFOZnYzNXMzYm9Wdnd1OEM0d0FQZ0QrbVh5RXZxRXlxUUtBY0hTOTA0NmY3dXJwTGdYQXNXUEhHRHAwYU1k'
    + 'UGUvWHFlTFFKd0NIZ2ZES0hTazJoQ2dEQzBYMEplQWFZcUJaYnRteGgrUERoTEZpd2dIWHJKQVRGcm5iRmdBc1'
    + 'hQcm14TWtPR0FQY0RMd0IvU3l3d1dsVEdnbFlCOFBkU1h1Vy9BdndaK1BxcVZhdVlOMjlleDI0T0dEQ0EwNmRQ'
    + 'Tnd2QVE4bEpHaDFrZ2Y1QUZnaEN5MnhvRlFCdFgrcC9PZGw3RWR2S3U3bDA2ZEpDK1NZWjhDandUV0JrOGlWUE'
    + 'F5K1Y4b2FtR1ZFRkFJYTVmc0FOd0tzMUFOQ1pTM2tTK0VVV0hjd1htcEpXQWREK3BmKzF3SURrOGF0bUFLTkhq'
    + 'MmI1OHVYSXBPUVhWRlpmc3pmNUJYT0ZwbGpRS2dCaC80YTdnY0RMVlROZzJMQmhIRGx5cEdOM1I0MGF4Zjc5Kz'
    + 'MwdkEzNlovRUtFeUlaWlVBVUFKam9CZ09HcVN3WVlBVko4dnlnUDZDb0s3TjY5dThnUFFzS2ZKRDh3SmFYT0g2'
    + 'WVErWmtDOEZYQUZMWmRBSGl2SHdCbmdMOG5mOUN3R1ZURmdPdVRDYlFUQU0zdFhzREV5eHpoSDgzNGdTc1pnTV'
    + 'BBRHhNQTV4SUFEZWNGVnpJQWVzYjdnRk9BQU9nSGFnY2dBSXUvRmorR3dYQ0NCenJ6QVRvK25WZkZUckN0QU9T'
    + 'bGJsUis2aHIxZmlSQ3BzS2RPa0hqOTlpeFl5K0tBZ0tqNk8xektWZUpuVVFCQVpoZVlrRERDZEhsbUVBb2JNen'
    + 'ZiMDBEV0tHNTY2YSttNjE5QUIzaG56b0RvT0hZZElrZlpHR3dMUUJFc2VOT1c2ditDcml6aytjek0xbWJtaGNY'
    + 'TWVCS0JzQlUxMkpITy84TmNJL0tyRnk1a2hFalJuRDQ4T0hDcnMrZDB3Y1ZEUXM3UUxVQ0VQNEVxSjBCN3I3S1'
    + 'creVlkeityY3VYR3hjR0RCMW0wYUJFN2R1em8yT2h5VmxjbEE5b0pnTHZ2amxycVBnQThZVXBhZGxhaDNMSmx5'
    + 'enFhSFo4WEFLTFEwY1BQQVg1V0xrektPN3RyMXk3bXo1L1BvVU5GU1ZDTHRKTUJPajRMSFV2ZE85TGhSY0dBdk'
    + 'RncGEzbisvSG42OXZWbjljaG5CWUNsN25KZ3NtcHQzNzZkU1pNbTFhUGhwMXkxblFEa0ptQ3o0MmJnS2VBYlB1'
    + 'UEdqUnVaT3RVRG5mWktPd0hJbmFCSmp1V3VKemNMMCtFbWE5ZXVaY2FNR1cxRm9BUkExQUkyVEswRktzMEVEWU'
    + '9SNjBlcWE5L3ZGdUNud0xmVXZOd0JyaHVOVWlhWUYwT1d3NVVDb0M2UkNJVXpOQlYyYVFZL0FXNzFTeXRXckdE'
    + 'aFFvbFJ2OHlhTllzMWE5WjRvejhBUDY2N0dveFVPRnJmTWtGekVBUVBNMlhDN1Q2TkFBaEUzYUx6M2JsenA3ZD'
    + 'VEbGlXQUFnVHFLVWN0aGpTSVFxQ1RBZ1FCRUxuS0FpR3llSXdSSk9vVXdZT0hNaXBVN1lBaXFKTUVPd0lDWUFt'
    + 'VUFzQTNxd3pFS3dHZ3cyUEFhUDlvazVSNTFpSDdOMjd0MmlSSi9rZThIbzZPQlVBYTVGYWU0S0NFSkhCNGtnbU'
    + 'NJTG1JQkNQeEFDRTRkRXdXYlZNbno2ZDlldlhlMW1yVCszL0wxbFRWQUFhbHN2cEIrUVhEUkRDSER3UHpFRXda'
    + 'YlpYd01TSkV6OVJJRFg4WktVZmJONjh1UmlzU0xJQStEM3dQbkEyaFVBUFJ4cVdSZ0h3QnJsakRDYVlMa2VFZU'
    + 'JENHJsLzBkUGpBZ2FKTDFwS2NPWE9HL3YyOWZDRk9rM2dvOGw2cEk5eHdDQXhsbW5tNHZGR2lZd3dtaEUvNEVY'
    + 'QjNGVXpJaHlpQXQ0RlppZnA2UW5lLzZUT0JWZ0NJMytZTmt6SUltc0xEZm5ITW1ERkZtSnc4dVNnbExrdk9uaj'
    + 'NMaGcwYm1ETkhxeXJFM244a1BpcnYxRWljQnpnejBKUTBZd0w1amZMcGtKZ1IwQnhrZ2tzUXpKWDlqSmt6WnpK'
    + 'dDJqUW1UQ2pjUktkeTlPalJRbkhYeVpNbjR6c2VoeitSS0cvWVUvbUkvZHArdytFdkx0d3FBRGtUSW0yV0NTcX'
    + 'NjM1E1K25ZWDhKMjRhZS9ldlJrOGVEQ0RCZzJpVDUraWk0WjI3dVNZZnpQeGplMWlSMHg4cmVMU1BzNEJtajRV'
    + 'clJLQU1naTIwT3dpR1NZRndpVW8xZzdmVGtOUGd6K0ZyOGRTejg4dTgxdHB0MVhjSmUxalVxVGxjWmtxR0pDRE'
    + 'dWT2hnaEFtb2ZJdVFmRXp0OXoza1QrWVpTcFdjOUpiKzViV1puWXFxcE9UN2k1Zit6M0haR0tJc2luYnI1b0Ir'
    + 'Zlh5ckZHRlhVYUtlQzBBNWhHQzVYSVRZaXhXcGR4VkZSUUFsUlVFbDYvOVRIQXFVVDZvMnhLQ1hmdzRRTkF2cU'
    + 'd5TTBJWHlmcTd5Zmk5WUdDT3hBcUNTZ3FDTng0cGhTWlZ2T09YdFNza3FUYUI4ajRnUStiQjBERTNudXgvUEVG'
    + 'TmZ3WUlBd3IvNUlIVmx5dGZKZ0J5TU9GcUxORHAvci9JNUFEa0lNaUlmbHE1VThicDh3S1hNS1pUTi8rYWJFQW'
    + '9HQ0orTGNmazYvRXVsMTZ6VEIxVDZvSFZkckFlQXVwQzlVcTdiN1Jud1g2cWNXVzY0MVZ5REFBQUFBRWxGVGtT'
    + 'dVFtQ0MiIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIvPjwvc3ZnPg==) 15 15, auto';


const zoomInCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kKSI+PHBhdGgg'
    + 'ZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC41IDhDMTQuNSAxMS4wMzggMT'
    + 'IuMDM4IDEzLjUgOSAxMy41QzUuOTYyIDEzLjUgMy41IDExLjAzOCAzLjUgOEMzLjUgNC45NjIgNS45NjIgMi41'
    + 'IDkgMi41QzEyLjAzOCAyLjUgMTQuNSA0Ljk2MiAxNC41IDhaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGZpbGwtcn'
    + 'VsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAzOCAx'
    + 'My41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5IDIuNU'
    + 'MxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPjxwYXRoIGZpbGwtcnVsZT0i'
    + 'ZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNTg1NyAxOC4wMDAyTDE4Ljk5OTcgMTYuNTg2Mk'
    + 'wxMy41NTA3IDExLjEzNzJMMTIuMTM2NyAxMi41NTEyTDE3LjU4NTcgMTguMDAwMloiIGZpbGw9ImJsYWNrIi8+'
    + 'PC9nPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0gxMFY1SD'
    + 'hWN0g2VjguOThIOFYxMUgxMFY4Ljk4SDEyVjdaIiBmaWxsPSJibGFjayIvPjxkZWZzPjxmaWx0ZXIgaWQ9ImZp'
    + 'bHRlcjBfZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIxLjk5OTciIGhlaWdodD0iMjIuMDAwMiIgZmlsdGVyVW5pdH'
    + 'M9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPjxmZUZsb29kIGZs'
    + 'b29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQ29sb3JNYXRyaXggaW49Il'
    + 'NvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMTI3IDAiLz48ZmVPZmZzZXQgZHk9IjEiLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLj'
    + 'UiLz48ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMCAwIDAgMC4zNSAwIi8+PGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZU'
    + 'ZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3ciLz48ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3Vy'
    + 'Y2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvdyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjwvZG'
    + 'Vmcz48L3N2Zz4=) 8 8, auto';


const zoomOutCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZCkiPgo8cGF0'
    + 'aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjUgOEMxNC41IDExLjAzOC'
    + 'AxMi4wMzggMTMuNSA5IDEzLjVDNS45NjIgMTMuNSAzLjUgMTEuMDM4IDMuNSA4QzMuNSA0Ljk2MiA1Ljk2MiAy'
    + 'LjUgOSAyLjVDMTIuMDM4IDIuNSAxNC41IDQuOTYyIDE0LjUgOFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGZpbG'
    + 'wtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAz'
    + 'OCAxMy41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5ID'
    + 'IuNUMxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1'
    + 'bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3LjU4NTcgMTguMDAwMkwxOC45OTk3IDE2Lj'
    + 'U4NjJMMTMuNTUwNyAxMS4xMzcyTDEyLjEzNjcgMTIuNTUxMkwxNy41ODU3IDE4LjAwMDJaIiBmaWxsPSJibGFj'
    + 'ayIvPgo8L2c+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0'
    + 'g2VjguOThIMTJWN1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2QiIHg9IjAi'
    + 'IHk9IjAiIHdpZHRoPSIyMS45OTk3IiBoZWlnaHQ9IjIyLjAwMDIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPbl'
    + 'VzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0i'
    + 'MCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIi'
    + 'B0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAi'
    + 'Lz4KPGZlT2Zmc2V0IGR5PSIxIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIvPgo8ZmVDb2'
    + 'xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAw'
    + 'IDAgMC4zNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3'
    + 'VsdD0iZWZmZWN0MV9kcm9wU2hhZG93Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBo'
    + 'aWMiIGluMj0iZWZmZWN0MV9kcm9wU2hhZG93IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cj'
    + 'wvc3ZnPgo=) 8 8, auto';


document.addEventListener('pointerdown', function(e)
{
    if (   e.button == 0)
    {
        if (   document.canResizeX
            || document.canResizeY)
        {
            document.startRect = new Rect(
                e.clientX,
                e.clientY,
                window.innerWidth,
                window.innerHeight);

            document.body.setPointerCapture(e.pointerId);

            document.resizingX = document.canResizeX;
            document.resizingY = document.canResizeY;
        }


        hideAllMenus();
    }
});



document.addEventListener('pointermove', function(e)
{
    if (   document.resizingX
        && document.resizingY)
    {
        uiResizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (document.resizingX)
    {
        uiResizeWindow(
            document.startRect.w + e.clientX - document.startRect.x,
            window.innerHeight);
    }
    else if (document.resizingY)
    {
        uiResizeWindow(
            window.innerWidth,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (!graphView.selecting)
        checkResize(e.clientX, e.clientY);
});



document.addEventListener('pointerup', function(e)
{
     if (   document.resizingX
         || document.resizingY)
    {
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }

    document.resizingX = false;
    document.resizingY = false;

    scrollbarX.moving  = false;
    scrollbarY.moving  = false;
});


var uiFigMessages = []; // messages from UI to Figma
var genMessages = []; // messages from UI to Generator

var genMessagePosted = false;


//uiClearAllLocalData();

//uiClearLocalData('windowWidth');
//uiClearLocalData('windowHeight');
//uiClearLocalData('productKey');

//uiRemoveConnsToNodes(['num10']);
//uiRemoveSavedNodesAndConns(['color']);
//uiRemoveAllSavedNodesAndConns();

uiLogAllSavedNodesAndConns();



var currentUser = '';



const graph = new Graph();

const generator = new Worker(
    window.URL.createObjectURL(
        new Blob([generatorScript.textContent])));
        

var panMode             = false;        

var     copiedNodesJson = '';
var duplicatedNodesJson = '';

var pasteOffset         = [ 0,   0];
var pasteOffsetDelta    = [40, 100];



clearConsole();
initColor();

uiQueueMessageToFigma({cmd: 'figStartGenerator'});



function uiEndStartGenerator(msg)
{
    initModeColors();
    initMenuBar();


    currentUser = msg.currentUser;
    productKey  = msg.productKey;


    uiGetLocalData('graphView');


    uiGetLocalData('enableLxxColorSpaces');

    uiGetLocalData('showNodeId'          );
    uiGetLocalData('showWires'           );

    uiGetLocalData('logMessages'         );
    uiGetLocalData('logActions'          );

    uiGetLocalData('logLoading'          );
    uiGetLocalData('logRequests'         );
    uiGetLocalData('logValueUpdates'     );
    uiGetLocalData('logObjectUpdates'    );

    uiGetLocalData('logRawLoading'       );
    uiGetLocalData('logRawSaving'        );
    uiGetLocalData('logRawRequests'      );
    uiGetLocalData('logRawValues'        );


    uiQueueMessageToFigma({cmd: 'figLoadNodesAndConns'});


    window.focus();
}


document.addEventListener('keydown', e =>
{
    let setLastKeyDown = true;


    // copy
    if (   e.code == 'KeyC'
        && getCtrlKey(e))
    {
        pasteOffset     = [0, 0];
        copiedNodesJson = uiCopyNodes(graphView.selectedNodes.map(n => n.id));
    }

    // paste
    else if (e.code == 'KeyV'
          && getCtrlKey(e))
    {
        if (copiedNodesJson.trim() != '')
            actionManager.do(new PasteNodesAction(copiedNodesJson, e.shiftKey));
    }

    // duplicate
    else if (e.code == 'KeyD'
          && getCtrlKey(e))
    {
        if (graphView.selectedNodes.length > 0)
        {
            pasteOffset = [0, 0];
            actionManager.do(new PasteNodesAction(uiCopyNodes(graphView.selectedNodes.map(n => n.id)), e.shiftKey));
        }

        return false;
    }

    // select all
    else if (e.code == 'KeyA'
          && getCtrlKey(e))
    {
        graphView.selectedNodes = graph.nodes;
        
        actionManager.do(new SelectNodesAction(
            graphView.selectedNodes    .map(n => n.id), 
            graphView.lastSelectedNodes.map(n => n.id)));
    }

    // undo/redo
    else if (e.code == 'KeyZ'
          && getCtrlKey(e))
    {
        if (e.shiftKey) actionManager.redo();
        else            actionManager.undo();

        setLastKeyDown = false;
    }

    // delete / backspace
    else if (   e.key == 'Delete'
             || e.key == 'Backspace')
    {
        const nodeIds = graphView.selectedNodes.map(n => n.id);

        if (nodeIds.length > 0)
        {
            actionManager.do(new DeleteNodesAction(nodeIds));
            graphView._selected = [];
        }
    }

    // escape
    else if (e.key == 'Escape')
    {
        if (graphView.tempConn)
        {
            if (graphView.savedConn)
            {
                const savedConn = graphView.savedConn;

                setTimeout(() => 
                {
                    updateWire(savedConn.wire);
                    savedConn.input.updateControl();
                });
            }

            graphView.cancelConnection(graphView.connPointerId);
        }
    }

    //
    else if (e.code == 'Minus'
          || e.code == 'NumpadSubtract')
    {
        graphView.zoom /= Math.pow(2, 1/2);
    }

    else if (e.code == 'Equal'
          || e.code == 'NumpadAdd')
    {
        graphView.zoom *= Math.pow(2, 1/2);
    }

    else if ((   e.code == 'Digit0'
              || e.code == 'Numpad0')
          && getCtrlKey(e))
    {
        graphView.zoom = 1;
        uiNotify('Zoom to 100%');
    }

    else if (e.code == 'Space'
         && !getCtrlKey(e))
    {
        if (   !graphView.selecting
            && !graphView.spaceDown)
        {
            graphView.spaceDown = true;
            setCursor(panCursor);
        }
    }

    else if (e.key == 'Shift')
    {
        if (graphView._soloNode)
            graphView.unsoloNode();
    }

    else if (e.key == 'Control')
    {
        if (graphView._soloNode)
            graphView.unsoloNode();

        if (graphView.spaceDown)
        {
            graphView.zoomSelecting = true;

            if (e.altKey) setCursor(zoomOutCursor);
            else          setCursor(zoomInCursor);
        }
    }

    else if (    e.key == 'Alt'
             && !e.shiftKey
             && !getCtrlKey(e))
    {
        if (   graphView.spaceDown
            && getCtrlKey(e))
            setCursor(zoomOutCursor);
        else if (graphView.overNode)
            graphView.soloNode(graphView.overNode);
    }

    else if (e.code == 'Tab')
        e.preventDefault();
});



document.addEventListener('keyup', e =>
{
    if (e.code == 'Space')
    {
        if (graphView.spaceDown)
        {
            graphView.spaceDown     = false;
            graphView.zoomSelecting = false;
            setAutoCursor();
        }
    }

    else if (e.key == 'Alt')
    {
        if (graphView.spaceDown)
        {
            if (getCtrlKey(e)) 
                setCursor(zoomInCursor);
            else
            {
                setCursor(panCursor);
                graphView.zoomSelecting = false;
            }
        }
        else if (graphView._soloNode)
            graphView.unsoloNode();
    }

    else if (e.key == 'Control'
          && graphView.spaceDown)
    {
        graphView.zoomSelecting = false;
        setCursor(panCursor);
    }
},false);


var uiFigMessagePosted = false;



// --> from Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = e =>
{
    let msg = JSON.parse(e.data.pluginMessage);


    if (settings.logMessages)
    {
        let _msg = msg.cmd;

        if (msg.cmd == 'uiEndFigMessage')
            _msg += ': ' + msg.msgCmd;

            console.log('%cFIG '+_msg+' -- UI', 'background: #08f; color: white;');
    }


    switch (msg.cmd)
    {
        case 'uiEndFigMessage':      uiEndFigMessage     (msg.msgCmd);                                   break;
        
        
        case 'uiEndStartGenerator':  uiEndStartGenerator (msg);                                          break;
        
        case 'uiLoadNodesAndConns':  uiLoadNodesAndConns (msg.nodesJson, msg.connsJson, msg.activeJson); break;
        
        case 'uiGetLocalDataReturn': uiGetLocalDataReturn(msg);                                          break;
        case 'uiGetPageDataReturn':  uiGetPageDataReturn (msg);                                          break;
        
        
        case 'uiEndResizeWindow':    uiEndResizeWindow   ();                                             break;
    }
}    

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

function uiPostMessageToFigma(msg)
{
    uiFigMessagePosted = true;
    parent.postMessage({pluginMessage: JSON.stringify(msg)}, '*');

    if (settings.logMessages)
        console.log('%c%s FIG -- UI '+msg.cmd, 'background: #bef; color: black;', '\n            ');
}



function uiQueueMessageToFigma(msg)
{
    uiFigMessages.push(msg);
    uiPostNextMessageToFigma();
}



function uiPostNextMessageToFigma()
{
    if (    uiFigMessages.length > 0
        && !uiFigMessagePosted)
    {
        let msg = uiFigMessages.shift();

        if (msg.cmd == 'figResizeWindow')
        {
            // move along the queue since only the last message is important
            while (uiFigMessages.length > 0
                && uiFigMessages[0].cmd == msg.cmd)
                msg = uiFigMessages.shift();
        }

        uiPostMessageToFigma(msg);    
    }
}



function uiEndFigMessage(msgCmd)
{
    uiFigMessagePosted = false;

    if (msgCmd == 'figUpdate')
        uiPostMessageToGenerator({
            cmd:   'genEndFigMessage',
            msgCmd: msgCmd});

    uiPostNextMessageToFigma();
}

///////////////////////////////////////////////////////////////////////////////////////////////////



//                                                                               from Generator <--
///////////////////////////////////////////////////////////////////////////////////////////////////

generator.onmessage = function(e)
{
    const msg = JSON.parse(e.data);

    if (settings.logMessages)
    {
        let _msg = msg.cmd;

        if (msg.cmd == 'uiEndGenMessage')
            _msg += ': ' + msg.msgCmd;

        console.log('%c%sUI -- GEN '+_msg, 'background: #ca0; color: white;', '\n                        ');
    }

    switch (msg.cmd)
    {
        case 'uiEndGenMessage':          uiEndGenMessage();                                                                                                   break;
        case 'uiUpdateValuesAndObjects': uiUpdateValuesAndObjects      (msg.updateNodeId, msg.updateParamId, msg.values, msg.objects); break;
        case 'uiUpdateFindCorrection':   uiUpdateFindCorrectionProgress(msg.nodeId, msg.progress);                                                            break;
        case 'uiEndFindCorrection':      uiEndFindCorrection           (msg.nodeId, msg.success, msg.closestOrder, msg.closest1, msg.closest2, msg.closest3); break;
    }
};



function uiEndGenMessage()
{
    genMessagePosted = false;
    
    if (genMessages.length > 0)
        uiPostNextMessageToGenerator();
}

///////////////////////////////////////////////////////////////////////////////////////////////////



//                                                                                 to Generator -->
///////////////////////////////////////////////////////////////////////////////////////////////////

function uiQueueMessageToGenerator(msg)
{
    genMessages.push(msg);
    uiPostNextMessageToGenerator();
}



function uiPostNextMessageToGenerator()
{
    if (    genMessages.length > 0
        && !genMessagePosted)
    {
        //console.log('message');
        let msg = genMessages.shift();

        if (msg.cmd == 'genRequest')
        {
            // move along the queue since only the last message is important
            while (genMessages.length > 0
                && genMessages[0].cmd        == msg.cmd
                && genMessages[0].request[0] == msg.request[0]
                && genMessages[0].request[1] == msg.request[1])
            {
                //console.log('skipping');
                msg = genMessages.shift();//deepCopy(genMessages.shift());
            }
        }

        uiPostMessageToGenerator(msg);
        genMessagePosted = true;
    }
}



function uiPostMessageToGenerator(msg)
{
    generator.postMessage(JSON.stringify(msg));

    if (settings.logMessages)
        console.log('%c%s UI '+msg.cmd+' -- GEN', 'background: #ffb; color: black;', '\n            ');
}

///////////////////////////////////////////////////////////////////////////////////////////////////


function setCursor(cursor, asyncForce = true)
{
    document.body.style.cursor = cursor;
    if (asyncForce) setTimeout(null, 0);
}



function setAutoCursor()
{
    if (graphView.zoomSelecting)
        setCursor(zoomInCursor);
    else if (graphView.spaceDown
          || graphView.panning
          || panMode)
        setCursor(panCursor);
    else
        setCursor('default'); // 'auto');
};





function      uiGetLocalData(key)        { uiQueueMessageToFigma({ cmd:      'figGetLocalData', key: key               }); }
function      uiSetLocalData(key, value) { uiQueueMessageToFigma({ cmd:      'figSetLocalData', key: key, value: value }); }
function    uiClearLocalData(key)        { uiQueueMessageToFigma({ cmd:      'figSetLocalData', key: key, value: ''    }); }
function uiClearAllLocalData(key)        { uiQueueMessageToFigma({ cmd: 'figClearAllLocalData', key: key, value: ''    }); }

function       uiGetPageData(key)        { uiQueueMessageToFigma({ cmd:       'figGetPageData', key: key               }); } 
function       uiSetPageData(key, value) { uiQueueMessageToFigma({ cmd:       'figSetPageData', key: key, value: value }); }
function     uiClearPageData(key)        { uiQueueMessageToFigma({ cmd:       'figSetPageData', key: key, value: ''    }); }



// function saveToLocalFile(filename, str) 
// {
//     const link = document.createElement('a');
//     link.style.display = 'none';
    
//     link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(str));
//     link.setAttribute('download', filename);
    
//     document.body.appendChild(link);
//     link.click();
//     document.body.removeChild(link);
// }



///////////////////////////////////////////////////////////////////////////////////////////////////
   


function uiGetLocalDataReturn(msg)
{
    switch (msg.key)
    {
        case 'graphView':        
            uiLoadGraphView(msg.value); 
            graphView.updatePanAndZoom();
            break;

        case 'enableLxxColorSpaces':       

        case 'showNodeId':       
        case 'showWires':        

        case 'logMessages':      
        case 'logActions':       

        case 'logLoading':       
        case 'logRequests':      
        case 'logValueUpdates':  
        case 'logObjectUpdates': 

        case 'logRawLoading':    
        case 'logRawSaving':     
        case 'logRawRequests':   
        case 'logRawValues':     
            updateSettingAndMenu(
                msg.key, 
                msg.value, 
                msg.value 
                    ? parseBool(msg.value) 
                    : false,
                false); 

            break;
    }
}


function uiGetPageDataReturn(msg)
{
    // switch (msg.key)
    // {
    //     case '':
    //         break;
    // }
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function uiLoadGraphView(json)
{
    graphView.loadingNodes   = true;
    graphView.canUpdateNodes = false;
   

    let pan  = point(0, 0);
    let zoom = 1;

    
    if (json)
    {
        const data = JSON.parse(json);

        pan = point( 
            parseFloat(data.panx), 
            parseFloat(data.pany));

        if (isNaN(pan.x)) pan.x = 0;
        if (isNaN(pan.y)) pan.y = 0;

        
        zoom = parseFloat(data.zoom);
        if (isNaN(zoom)) zoom  = 1;
    }


    graphView._zoom     = zoom;
    graphView._pan      = pan;
}



function uiLoadNodesAndConns(nodesJson, connsJson, activeJson)
{
    if (settings.logRawLoading)
        console.log(
            '%cnodes json = %s', 
            'background: #fed',
            nodesJson
                .replaceAll('\\n', '\n')
                .replaceAll('\\"', '\"'));

        
    graph.clear();

    const _nodes = JSON.parse(nodesJson).map(n => JSON.parse(n));
    const conns = JSON.parse(connsJson).map(c => JSON.parse(c));

    _nodes.sort((a, b) => a.z - b.z);

    loadNodesAndConnsAsync(_nodes, conns, setLoadingProgress);
}



function setLoadingProgress(progress)
{
    loadingProgress.style.width = (progress * 100) + '%';
}



function loadNodesAndConnsAsync(_nodes, _conns, setProgress)
{
    loadingProgress.style.width   = 0;
    loadingOverlay .style.display = 'block';


    let promise = Promise.resolve([]);


    const chunkSize = 10; // nodes
    for (let i = 0; i < _nodes.length; i += chunkSize)
    {
        promise = promise.then(nodes => 
        {
            const res = resolveNodes(
                _nodes, 
                i, 
                Math.min(i + chunkSize, _nodes.length), // exclusive
                nodes);

            setProgress(i / (_nodes.length + (_conns ? _conns.length : 0)));
            return res;
        });
    }


    promise.then(nodes => 
    {
        graph.addNodes(nodes, false, false);
        loadConnectionsAsync(_nodes, _conns, nodes, setProgress);    
    });
}



function loadConnectionsAsync(_nodes, _conns, loadedNodes, setProgress)
{
    let promise = Promise.resolve([]);
    

    if (_conns)
    {
        // variable inputs connections must be sorted by input index
        // as well as connection position left to right

        _conns.sort((c1, c2) => 
        {
            if (c1.inputNodeId != c2.inputNodeId ) return c1.inputNodeId < c2.inputNodeId ? -1 : 1;
            if (c1.inputIdd    != c2.inputId     ) return c1.inputId - c2.inputId;
            
            if (c1.inputNodeId == c2.outputNodeId) return -1;
            if (c2.inputNodeId == c1.outputNodeId) return  1;

            return 0;
        });


        const chunkSize = 10; // connections
        for (let i = 0; i < _conns.length; i += chunkSize)
        {
            promise = promise.then(() => 
            {
                const res = resolveConnections(
                    _nodes,
                    _conns, 
                    i, 
                    Math.min(i + chunkSize, _conns.length)); // exclusive

                setProgress((_nodes.length + i) / nozero(_nodes.length + _conns.length * 19/20)); // the proportion is arbitrary
                return res;
            });
        }
    }


    promise.then(() => 
    {
        finishLoading();
        finishLoadingNodes(_nodes, loadedNodes);
    });
}



function finishLoading()
{
    loadingOverlay.style.display = 'none';
    
    graphView.loadingNodes   = false;
    graphView.canUpdateNodes = true;
    
    //updateToggleShowWiresButton();
    graphView.updateShowWires(false);
}



function finishLoadingNodes(_nodes, loadedNodes, duplicates = false)
{
    _nodes
        .filter(_n => _n.active)
        .map(_n => nodeFromId(duplicates ? _n.newId : _n.id))
        .forEach(n => n.makeActive());

    // validateActiveNodesInTrees(loadedNodes);

    loadedNodes.forEach(n => n.updateNode());
    graphView.updateNodeTransforms(loadedNodes);

    updateTerminalsAfterNodes(loadedNodes);
}



function resolveNodes(_nodes, first, last, nodes)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
                nodes.push(loadNode(_nodes[i]));

            resolve(nodes);
        }));
}



function resolveConnections(nodes, _connections, first, last)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
            {
                const _conn = _connections[i];

                const outputNode = nodes.find(n => (n.newId ? n.newId : n.id) == _conn.outputNodeId);
                const  inputNode = nodes.find(n => (n.newId ? n.newId : n.id) == _conn. inputNodeId);

                if (!outputNode)
                { 
                    uiError('node \'' + _conn.outputNodeId + '\' not found'); 
                    uiRemoveConnsToNodes([_conn.outputNodeId]); 
                    continue; 
                }

                if (!inputNode) 
                { 
                    uiError('node \'' + _conn. inputNodeId + '\' not found'); 
                    uiRemoveConnsToNodes([_conn. inputNodeId]); 
                    continue; 
                }

                Connection.parseJson(_conn);
            }

            resolve();
        }));
}



function loadNodes(data)
{
    const nodes = [];
    
    for (let i = 0; i < data.nodes.length; i++)
        nodes.push(loadNode(data.nodes[i]));

    return nodes;
}



function loadNode(_node)
{
    const node = createNode(_node.type);

    node.id   = _node.id;
    node.name = _node.name;

    if (  _node.params
        || node.alwaysLoadParams)
        node.loadParams(_node);

    node.updateNode();
    
    updateHeaderLabelOffset(node, 0.5);

    setNodePosition(
        node, 
        parseFloat(_node.x), 
        parseFloat(_node.y),
        false);

    return node;
}



function loadConnections(data, loadOutsideConnections, setProgress = null)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];
        
        if (      data.nodes.find(n => (n.newId ? n.newId : n.id) == _conn.outputNodeId)
               && data.nodes.find(n => (n.newId ? n.newId : n.id) == _conn. inputNodeId)
            || loadOutsideConnections)
            Connection.parseJson(_conn);

        if (setProgress)
            setProgress(((data.nodes.length + i) / (data.nodes.length + data.connections.length)));
    }
}



function uiSaveGraphView()
{
    uiSetLocalData('graphView', graphView.toJson());
}



function dataColorToJson(color, nTab)
{
    let   pos = ' '.repeat(nTab);
    const tab = TAB;

    let json =
          pos + tab + '[\n'
        + pos + tab + tab + '"'+color[0] +'",\n'
        + pos + tab + tab +     color[1] + ',\n'
        + pos + tab + tab +     color[2] + ',\n'
        + pos + tab + tab +     color[3] + '\n'
        + pos + tab + ']';

    return json;
}


var tooltipTimer, 
    tooltipInTimer,
    tooltipOutTimer, 
    tooltipLeaveTimer;

var currentTooltipSource = null;
var currentTooltip       = null;

    

function createTooltipSrc(source, ref, getTooltip, bottomArrow = false)
{
    source.addEventListener('pointerenter', () =>
    {
        clearTimeout(tooltipInTimer);
        clearTimeout(tooltipLeaveTimer);
    
        if (!tooltipTimer)
        {
            tooltipTimer = setTimeout(() =>
            {
                showTooltip(ref, getTooltip(), bottomArrow);

                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }, 
            currentTooltip ? 0 : 1000);
        }
    });
      
    
    source.addEventListener('pointerleave', () =>
    {
        clearTimeout(tooltipTimer);
        currentTooltipSource = null;

        tooltipOutTimer = setTimeout(() => 
        {
            hideTooltip(getTooltip());
        }, 
        400);
    });
}



function createTooltip(tooltip)
{
    tooltip.addEventListener('pointerenter', () =>
    {
        clearTimeout(tooltipOutTimer);
        tooltipOutTimer = null;
    });
    
    
    tooltip.addEventListener('pointerleave', () =>
    {
        hideTooltip(tooltip);
    });


    hideTooltip(tooltip);
}



function showTooltip(source, tooltip, bottomArrow)
{
    if (currentMenus.length > 0)
        return;

    if (currentTooltip)
        hideTooltip(currentTooltip);


    tooltip     .style.display = 'block';
    tooltip     .style.opacity = '100%';

    tooltipArrow.style.display = 'block';
    tooltipArrow.style.opacity = '100%';

    let srcRect = source.getBoundingClientRect();

    srcRect.y -= 5;


    const margin = 10;
 
    tooltip.style.left = Math.min(Math.max(
        margin, 
        srcRect.x + srcRect.width/2 - tooltip.offsetWidth/2), 
        graphView.offsetWidth - tooltip.offsetWidth - margin);

    tooltipArrow.style.left = srcRect.x + srcRect.width/2;// - tooltipArrow.offsetWidth/2;

    
    if (bottomArrow)
    {
        const ttRect = tooltip.getBoundingClientRect();

        tooltip.style.top = srcRect.y - tooltipArrow.offsetHeight - ttRect.height;

        tooltipArrow.style.borderColor = '#040404 transparent transparent transparent';
        tooltipArrow.style.top         = srcRect.y - tooltipArrow.offsetHeight;
    }
    else
    {
        tooltip.style.top = srcRect.y + srcRect.height + tooltipArrow.offsetHeight;

        const ttRect = tooltip.getBoundingClientRect();

        tooltipArrow.style.borderColor = 'transparent transparent #040404 transparent';
        tooltipArrow.style.top         = ttRect.y - tooltipArrow.offsetHeight;
    }


    currentTooltip = tooltip;
}



function hideTooltip(tooltip)
{
    tooltip     .style.display = 'none';
    tooltip     .style.opacity = '0%';

    tooltipArrow.style.display = 'none';
    tooltipArrow.style.opacity = '0%';

    clearTimeout(tooltipTimer);
    clearTimeout(tooltipOutTimer);

    tooltipTimer   = null;
    currentTooltip = null;
}


createTooltip(ttCreateNumber);           createTooltipSrc(btnCreateNumber,           () => ttCreateNumber);
createTooltip(ttCreateLimits);           createTooltipSrc(btnCreateLimits,           () => ttCreateLimits);
createTooltip(ttCreateAdd);              createTooltipSrc(btnCreateAdd,              () => ttCreateAdd);
createTooltip(ttCreateSubtract);         createTooltipSrc(btnCreateSubtract,         () => ttCreateSubtract);
createTooltip(ttCreateMultiply);         createTooltipSrc(btnCreateMultiply,         () => ttCreateMultiply);
createTooltip(ttCreateDivide);           createTooltipSrc(btnCreateDivide,           () => ttCreateDivide);
createTooltip(ttCreateModulo);           createTooltipSrc(btnCreateModulo,           () => ttCreateModulo);
createTooltip(ttCreateExponent);         createTooltipSrc(btnCreateExponent,         () => ttCreateExponent);
createTooltip(ttCreateInterpolate);      createTooltipSrc(btnCreateInterpolate,      () => ttCreateInterpolate);

createTooltip(ttCreateColor);            createTooltipSrc(btnCreateColor,            () => ttCreateColor);
createTooltip(ttCreateColorInterpolate); createTooltipSrc(btnCreateColorInterpolate, () => ttCreateColorInterpolate);
createTooltip(ttCreateValidateColor);    createTooltipSrc(btnCreateValidateColor,    () => ttCreateValidateColor);
createTooltip(ttCreateColorContrast);    createTooltipSrc(btnCreateColorContrast,    () => ttCreateColorContrast);
createTooltip(ttCreateColorblind);       createTooltipSrc(btnCreateColorblind,       () => ttCreateColorblind);

// createTooltip(ttToggleWires);            createTooltipSrc(btnToggleWires,            () => ttToggleWires);


// menuSelect.addEventListener('change', async function(e) 
// {
//     switch (e.detail.selectedValue)
//     {
//         case 'saveLocal':  saveToLocalFile('graph.json'); break;
//         case 'loadLocal':  loadFromLocalFile();           break;
//         case 'duplicate':  console.log(graph.toJson());     break;
//         case 'productKey': showProductKeyDialog();        break;
//     }
// });



productKeyClose.addEventListener('click', e =>
{
    hideProductKeyDialog();
});



// btnToggleWires.addEventListener('pointerenter', () => { btnToggleWires.mouseOver = true;  updateToggleShowWiresButton(); });
// btnToggleWires.addEventListener('pointerleave', () => { btnToggleWires.mouseOver = false; updateToggleShowWiresButton(); });


/*
    At least one node in a tree must be active. It doesn't have to be a terminal,
    but there can be no other active nodes downstream.

    In diamonds exactly one node can be active.



    

       

    

            



    Connecting


          
                  
        [_______]

    

                   
        [_______]
                    

                 

                   
        [_______]
                   

    

        [_______]
                   
         

                 

        [_______]
                   
        [_______]

    

        
                   [_______]
         

                 

        
                   [_______]
        [_______]

    

                    
        [_______]               
                   

                         

                   [_______]
        [_______]             
                   

    

                   [_______]
        [_______]             
                    

                         

                   [_______]
        [_______]             
                   [_______]

    

                   
        [_______]             [_______]
                    

                         

                   
        [_______]             [_______]
                   [_______]

    



    Activating
    

        [______]
                  
        [_______]

    

        [______]
                  
        [_______]

    

                   [______]
        
                   [_______]
                 
                   
        [_______]
                   [_______]

    

                   
        [_______]
                   [______]
                 
                   
        [_______]
                   

    

                   
        [______]
                   
                 
                   [_______]
        
                   [_______]

    

                   [______]
                     [_______]
                   [_______]

                         

                   
        [_______]             [_______]
                   [_______]

    

                   
        [_______]             [_______]
                   [______]

                         

                   [_______]
        [_______]             [_______]
                   

    

                   [_______]
        [_______]             [______]
                   

                         

                   [_______]
        [_______]             
                   [_______]

    



    Disconnecting
    

        [_______]
                  
             

    

        [_______]
                  
             

    

        [_______][_______]
                         
        [_______]     

    

                   
        [_______]
                   
                 
                   
        [_______]
                      

    

                   [_______]
        
                   [_______]
                 
                   [_______]
        
                      

    

        [_______]
                   
        [_______]

                 

        [_______]
                   
        

    

        
                   [_______]
        [_______]

                 

        
                   [_______]
        

    

        [_______]
                   [_______]
        

                 

        [_______]
                   
        

    



    Deleting
    

                          
        [_______]
                        
        

    
            
        [______]
                
                      

    

            
        [_______]
                
                      

    

                          
        [______]
                        
        

    

                          
        [_______][_______]
                         
                          


    

        [_______]      
                   
        [_______]      

                 

        

        

    

                 [_______]
        
                 [_______]

                  

                      

                      

    

                   [_______]      
        [_______]             
                   [_______]      

                          

                   
        [_______]
                   

    
                          
                   
        [_______]           [_______]
                   [_______]

                         

        [_______]             
                   [_______]

    
                          
                   
        [_______]           [_______]
                   [_______]
                   
                   

                          

        [_______]             
                   [_______]
                   
                   

    

                 [_______]
                     [_______]
                 [_______]
                   
                   [_______]

                          

                      
                                 [_______]
                      [_______]

                      

    
*/



function uiCreateNode(nodeType, creatingButton, createdId = -1, updateUi = true, options = {})
{
    let node = createNode(nodeType, creatingButton, createdId, options);


    graph.addNode(node);
    
    uiSaveNodes([node.id]);


    // if (graphView.selectedNodes.length > 0)
    // {
    //     const selNode = graph.nodes.find(n => n.selected);
    //     const inputs  = node.inputs.filter(i => i.types.includes(selNode.type));

    //     if (   !!selNode
    //         && selNode.output
    //         && inputs.length > 0)
    //         uiConnect(selNode.output, inputs[0]);
    // }


    if (updateUi)
    {
        graphView.lastSelectedNodes = graphView.selectedNodes;
        graphView.selectedNodes     = [node];

        node.updateNode();

        //pushUpdate([node]);

        //graphView.putNodeOnTop(node);
        //graphView.updateNodeTransform(node);

        //updateGraphNodes();
    }


    return node;
}



function uiDeleteNodes(nodeIds)//, actionId)
{
    nodeIds.forEach(id => nodeFromId(id).makePassive());

    graph.deleteNodes(nodeIds);

    uiRemoveSavedNodesAndConns(nodeIds);
    uiDeleteObjects(nodeIds);
}



// function uiUndeleteNodes(nodes, nodePos, actionId)
// {
//     graph.addNodes(nodes);


//     graphView.selectedNodes = nodes;

//     graphView.putNodeOnTop(lastOf(nodes));

//     for (let i = 0; i < nodes.length; i++)
//     {
//         setNodePosition(
//             nodes[i],
//             nodePos[i].x,
//             nodePos[i].y);
//     }


//     // uiQueueMessageToGenerator({
//     //     cmd:       'genUndeleteNodes',
//     //     uiActionId: actionId
//     // });
// }



function uiDeleteObjects(nodeIds)
{
    uiQueueMessageToFigma({
        cmd:    'figDeleteObjects',
        nodeIds: nodeIds
    });
}



function uiSetNodeId(nodeId, newId)
{
    const node = nodeFromId(nodeId);

    node.id = newId;
}



function uiVariableConnect(outputNode, outputIndex, inputNode, inputIndex)
{
    //console.log('uiVariableConnect()');

    if (inputNode.variableInputs)
    {
        const input = lastOf(inputNode.inputs);

        const conn = uiConnect(
            outputNode.outputs[outputIndex],
            input,
            inputIndex);

        uiUpdateSavedConnectionsToNodeId(inputNode.id);

        return conn;
    }
    else
    {
        return uiConnect(
            outputNode.outputs[outputIndex],
             inputNode. inputs[ inputIndex]);
    }
}



function uiConnect(output, input, inputIndex = -1)
{
    const conn = graph.connect(output, input, inputIndex);

    uiSaveConnection(
        output.node.id,
        output.index,
        input.node.id,
        input.index,
        conn.toJson());

    return conn;
}



function uiDisconnect(input)
{
    //console.log('uiDisconnect()');
    
    const node = input.node;

    uiRemoveSavedConnection(
        input.connectedOutput.node.id,
        input.connectedOutput.index,
        input.node.id,
        input.index);

    graph.disconnect(input);

    node.updateNode();

    if (node.variableInputs)
        uiUpdateSavedConnectionsToNodeId(node.id);
}



function uiUpdateSavedConnectionsToNodeId(nodeId)
{
    const node = nodeFromId(nodeId);


    uiRemoveSavedConnectionsToNodeId(node.id);

    for (const _input of node.inputs.filter(i => i.connected))
    {
        uiSaveConnection(
            _input.connectedOutput.node.id,
            _input.connectedOutput.index,
            node.id,
            _input.index,
            _input.connection.toJson());
    }
}



function uiMakeNodeActive(node)
{
    uiMakeNodeLeftPassive (node);
    uiMakeNodeRightPassive(node);

    node.makeActive();
    node.updateNode();

    pushUpdate([node]);
}



function uiMakeNodesActive(nodes)
{
    for (const node of nodes)
    {
        uiMakeNodePassive(node);
        uiMakeNodeLeftPassive (node);
        uiMakeNodeRightPassive(node);
    }

    for (const node of nodes)
    {
        node._active = true;

        if (!graphView.activeNodes.includes(node))
            graphView.activeNodes.push(node);

        // uiQueueMessageToFigma({
        //     cmd:   'figSaveActiveNode',
        //     nodeId: node.id
        // });

        // if (node.type == 'object')
        //     uiGenerateObjects([node.id]);

        node.updateNode();
    }

    pushUpdate(nodes);
}



function uiMakeNodePassive(node)
{
    if (!node.active) return;

    node.makePassive();
    node.updateNode();

    uiDeleteObjects([node.id]);
}



function uiMakeNodeLeftPassive(node, fromNode = null)
{
    //console.log('uiMakeNodeLeftPassive() node =', node);
    for (const input of node.inputs.filter(i => !i.param))
    {
        if (    input.connected
            && !input.connectedOutput.param
            && (  !fromNode
                || input.connectedOutput.node != fromNode))
        {
            uiMakeNodePassive(input.connectedOutput.node);
            uiMakeNodeLeftPassive(input.connectedOutput.node, node);
        }
    }
}



function uiMakeNodeRightPassive(node, fromNode = null)
{
    for (const output of node.outputs.filter(o => !o.param))
    {
        for (const connInput of output.connectedInputs.filter(i => !i.param))
        {
            uiMakeNodePassive(connInput.node);
            uiMakeNodeRightPassive(connInput.node, node);
        }
    }

    uiMakeNodeLeftPassive(node, fromNode);//
    // for (const input of node.inputs.filter(i => !i.param))
    // {
    //     if (   input.connected
    //         && input.connectedOutput.node != fromNode)
    //     {
    //         uiMakeNodePassive(input.connectedOutput.node);
    //         uiMakeNodeLeftPassive(input.connectedOutput.node, node);
    //     }
    // }
}



function uiShowParamValue(nodeId, paramName, value)
{
    const node = nodeFromId(nodeId);

    if (!!node) // this is for deleted nodes which still exist
    {           // in genGraph but no longer in graph
        const param = node.params.find(p => p.name == paramName);
        param.control.setValue(value, false);
    }
}



function uiCopyNodes(nodeIds)
{
    const nodes      = graph.nodes.filter(n => nodeIds.includes(n.id));
    const copiedJson = nodesToJson(nodes, true, false);

    //console.log(copiedJson);

    return copiedJson;
}



function uiPasteNodes(nodesJson, pasteOutsideConnections)
{
    //console.log(nodesJson);

    graphView.loadingNodes = true;


    pasteOffset[0] += pasteOffsetDelta[0];
    pasteOffset[1] += pasteOffsetDelta[1];


    const data = JSON.parse(nodesJson);


    // offset new nodes (must be done before loading)
    for (let i = 0; i < data.nodes.length; i++)
    {
        data.nodes[i].x = parseFloat(data.nodes[i].x) + pasteOffset[0] / graphView.zoom;
        data.nodes[i].y = parseFloat(data.nodes[i].y) + pasteOffset[1] / graphView.zoom;
    }


    const nodes = loadNodes(data);

    // get the new names of the nodes after they've been added
    for (let i = 0; i < nodes.length; i++)
    {
        graph.addNode(nodes[i], false);
        data.nodes[i].newId = nodes[i].id;
    }

    if (data.connections)
    {
        correctNodeNamesInConnections(data);
        loadConnections(data, pasteOutsideConnections);
    }

    graphView.selectedNodes = nodes;


    // if there are no active nodes, activate terminals
    if (!nodes.find(n => n.active))
    {
        const terminals = [];

        for (const node of nodes)
            pushUnique(terminals, getTerminalsAfterNode(node));

        terminals.forEach(n => n.makeActive());
    }


    graphView.loadingNodes = false;
    finishLoadingNodes(data.nodes, nodes, true);


    return nodes;
}



function correctNodeNamesInConnections(data)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];

        let outputNodeIndex = data.nodes.findIndex(n => n.id == _conn.outputNodeId);
        if (outputNodeIndex > -1) data.connections[i].outputNodeId = data.nodes[outputNodeIndex].newId;

        const inputNodeIndex = data.nodes.findIndex(n => n.id == _conn.inputNodeId);

        data.connections[i].inputNodeId = data.nodes[inputNodeIndex].newId;
    }

    for (let i = 0; i < data.nodes.length; i++)
    {
        const _node = data.nodes[i];

        if (_node.newId && _node.newId != _node.id)
            _node.id = _node.newId;
    }
}



function updateGraphNodes()
{
    //console.log('updateGraphNodes()');

    for (const node of graphView.selectedNodes)      node.updateNode();
    for (const node of graphView._prevSelectedNodes) node.updateNode();
    for (const node of graphView.lastSelectedNodes)  node.updateNode();
}



function uiUpdateNodes(nodeIds)
{
    if (graph.mutex)
    {
        for (const nodeId of nodeIds)
            graph.deferNodeIds.push(nodeId);

        return;
    }

    graph.mutex = true;
}



function uiUpdateGraph()
{
    graph.mutex = false;


    if (graph.deferNodeIds.length > 0)
    {
        let deferNodes = filterUnique(graph.deferNodeIds);

        graph.deferNodeIds = [];

        uiUpdateNodes(deferNodes);
    }
}



function uiUpdateValuesAndObjects(updateNodeId, updateParamId, values, objects)
{
    if (settings.logRawValues)  
        console.log('raw values = ', values);

    if (settings.logValueUpdates)  
        logValueUpdates(updateNodeId, updateParamId, values);


    const nodes = [];

    let i = 0;
    while (i < values.length)
    {
        const nodeId = values[i++];
        const count  = values[i++];

        const node   = nodeFromId(nodeId);


        if (!node) // was deleted
        {
            i += count*2;
            continue;
        }


        pushUnique(nodes, node);


        if (count > 0)
        {
            const _ids    = [];
            const _values = [];

            for (let j = 0; j < count; j++)
            {
                const id   = values[i++];
                const type = values[i++];

                _ids.push(id);

                let value;

                switch (type)
                {
                    case NUMBER_VALUE:     value = parseNumberValue   (values[i++])[0]; break;
                    case COLOR_VALUE:      value = parseColorValue    (values[i++])[0]; break;
                    case FILL_VALUE:       value = parseFillValue     (values[i++])[0]; break;
                    case STROKE_VALUE:     value = parseStrokeValue   (values[i++])[0]; break;
                    case COLOR_STOP_VALUE: value = parseColorStopValue(values[i++])[0]; break;
                    case RECTANGLE_VALUE:  value = parseRectangleValue(values[i++])[0]; break;
                    case LINE_VALUE:       value = parseLineValue     (values[i++])[0]; break;
                    case ELLIPSE_VALUE:    value = parseEllipseValue  (values[i++])[0]; break;
                    case POLYGON_VALUE:    value = parsePolygonValue  (values[i++])[0]; break;
                    case STAR_VALUE:       value = parseStarValue     (values[i++])[0]; break;
                    
                    // case FILL:             console.log('values[i] =', values[i]);
                    //                        value = new FillValue(
                    //                            parseColorValue (values[i++])[0],
                    //                            parseNumberValue(values[i++])[0]);
                    //                        break;

                    default:               console.assert(false, 'unknown type \'' + type + '\'');
                }

                if (value.nodeId)
                    value.nodeId = nodeId; 
    
                _values.push(value);
            }

            node.updateValues(
                updateNodeId == nodeId ? updateParamId : '',
                _ids,
                _values);


            node.valid = true;
            node.updateNode();
        }
    }



    const nodeJson = [];

    nodes.forEach(n => nodeJson.push(n.toJson()));


    if (   settings.logRawSaving
        && updateNodeId  != NULL
        && updateParamId != NULL)
        logSaveNodes(nodeJson.join('\n'));

    if (settings.logObjectUpdates)
        logObjectUpdates([...objects]);


    uiPostMessageToFigma({
        cmd:          'figUpdate',
        updateNodeId:  updateNodeId,
        updateParamId: updateParamId,
        nodeIds:       nodes.map(n => n.id),
        nodeJson:      nodeJson,
        objects:       [...objects]
    });
        

    graphView.update(nodes);
}



function uiSaveNodes(nodeIds)
{
    const nodeJson = [];

    for (const id of nodeIds)
        nodeJson.push(nodeFromId(id).toJson());

    if (settings.logRawSaving)
        logSaveNodes(nodeJson.join('\n'));

    if (nodeJson.length > 0)
        uiQueueMessageToFigma({
            cmd:     'figSaveNodes',
            nodeIds:  nodeIds,
            nodeJson: nodeJson
    });
}



function uiSaveConnection(outputNodeId, outputIndex, inputNodeId, inputIndex, connJson)
{
    if (settings.logRawSaving)
        console.log('%cSAVING CONNECTION\n' + connJson, 'background: #ddeeff');

    uiQueueMessageToFigma({
        cmd: 'figSaveConnection',
        name: outputNodeId  + ' '
            + outputIndex + ' '
            + inputNodeId   + ' '
            + inputIndex,
        json: connJson
    });
}



function uiRemoveSavedConnection(outputNodeId, outputIndex, inputNodeId, inputIndex)
{
    if (settings.logRawSaving)
        console.log('%cREMOVING SAVED CONNECTION', 'background: #ddeeff');

    uiQueueMessageToFigma({
        cmd: 'figRemoveSavedConnection',
        name: outputNodeId + ' '
            + outputIndex  + ' '
            + inputNodeId  + ' '
            + inputIndex
    });
}



function uiRemoveSavedConnectionsToNodeId(nodeId)
{
    uiQueueMessageToFigma({
        cmd:   'figRemoveSavedConnectionsToNode',
        nodeId: nodeId
    });
}



function uiRemoveSavedNodesAndConns(nodeIds)
{
    uiQueueMessageToFigma({
        cmd:    'figRemoveSavedNodesAndConns',
        nodeIds: nodeIds
    });
}



function uiRemoveConnsToNodes(nodeIds)
{
    uiQueueMessageToFigma({
        cmd: 'figRemoveConnsToNodes',
        nodeIds: nodeIds
    });
}



function uiRemoveAllSavedNodesAndConns()
{
    uiQueueMessageToFigma({
        cmd: 'figRemoveAllSavedNodesAndConns'
    });
}



function uiLogAllSavedNodesAndConns()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedNodesAndConns',
        settings: settings
    });
}



function uiLogAllSavedNodes()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedNodes',
        settings: settings
    });
}



function uiLogAllSavedConns()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedConns',
        settings: settings
    });
}


// function checkAddMenuItemProductKey(menuSelectItems)
// {
//     if (!validateProductKey(currentUser.id, productKey))
//         menuSelectItems.push({value: 'productKey', text: 'Enter product key'});
// }



// function removeMenuItemProductKey()
// {
//     let index = menuSelect.items.findIndex(item => item.value == 'productKey');
//     removeAt(menuSelect.items, index);
//     menuSelect.updateItems();
// }



function uiError(text, delay = 6000)
{
    uiNotify(text, GEN_LOGO + 'Error: ', delay, true);
}



function uiNotify(text, prefix = GEN_LOGO + '', delay = 4000, error = false)
{
    uiQueueMessageToFigma({ 
        cmd:   'figNotify',
        text:   text,
        prefix: prefix,
        delay:  delay,
        error:  error
    });        
}


document.canResizeX = false;
document.canResizeY = false;
   
document.resizingX  = false;
document.resizingY  = false;

document.startRect  = new Rect();



window.addEventListener('keydown',       e => e.preventDefault());

window.addEventListener('gesturestart',  e => e.preventDefault());
window.addEventListener('gesturechange', e => e.preventDefault());
window.addEventListener('gestureend',    e => e.preventDefault());



function checkResize(x, y)
{
    const resizeEdgeWidth = 8;

    document.canResizeX = document.body.clientWidth  - x <= resizeEdgeWidth;
    document.canResizeY = document.body.clientHeight - y <= resizeEdgeWidth;

         if (document.canResizeX
          && document.canResizeY) setCursor('nwse-resize', false); 
    else if (document.canResizeX) setCursor('ew-resize',   false);   
    else if (document.canResizeY) setCursor('ns-resize',   false);   
    else                          setAutoCursor();
}



function uiResizeWindow(width, height)
{
    uiQueueMessageToFigma({ 
        cmd:   'figResizeWindow', 
        width:  Math.max(500, width),
        height: height
    });
}



function uiEndResizeWindow()
{
    graphView.updatePanAndZoom();

    // btnZoom.style.top  = 0;
    // btnZoom.style.left = window.innerWidth - btnZoom.offsetWidth;

    // btnToggleWires.style.top  = 0;
    // btnToggleWires.style.left = btnZoom.offsetLeft - btnToggleWires.offsetWidth;
}



function isDarkMode()
{
    const style = window.getComputedStyle(document.body);
    return isDark(style2rgba(style.backgroundColor));
}



// create an observer for when the UI theme changes

function onClassChange(element, callback) 
{
    const observer = new MutationObserver((mutations) => 
    {
        mutations.forEach((mutation) => 
        {
            if (   mutation.type          == 'attributes' 
                && mutation.attributeName == 'class') 
                callback(mutation.target);
        });
    });

    observer.observe(element, { attributes: true });

    return observer.disconnect;
}



onClassChange(document.childNodes[0], () =>
{ 
    initModeColors();
    graph.nodes.forEach(n => n.updateNode());
});


const licenseKeys     = createCryptoKeys();
const licenseHashSize = 4;



function createProductKey(name)
{
    var hash = hashLicenseName(name, licenseHashSize);
    var enc  = sign(hash, licenseKeys.private);
    var key  = arrayToBase32(enc);

    return key;
}



function validateProductKey(name, key, rec = false)
{
    // TODO: check from today until 1 year from now (max license length)
    // 1/day, so 365 max, add end day to name
    // check today against last launch date (in private data) to prevent clock tampering

    var arr  = base32toArray(key.toUpperCase());
    var dec  = verify(arr, licenseKeys.public).subarray(licenseHashSize);
    var trim = dec.subarray(dec.length - licenseHashSize);
    var hash = hashLicenseName(name, licenseHashSize);
    
    var valid = arraysEqual(trim, hash);

    if (valid && !rec)
    {
        var lowerKey  = key;

        var lastChar  = lowerKey[lowerKey.length-1];
        var lastIndex = base32chars.indexOf(lastChar);

        if (lastIndex > 0)
        {
            lowerKey = replaceInStringAt(lowerKey, lowerKey.length-1, base32chars[lastIndex-1]);

            if (validateProductKey(name, lowerKey, true))
                return false; // at this scale of product key the last bit needs to be guarded against
        }
    }

    return valid;
}



function hashLicenseName(name, nBytes)
{
    // XOR wrap name around a given number of bytes

    var bytes = stringToArray(name);

    if (bytes.length > nBytes)
    {
        var pos    = nBytes;
        var length = bytes.length - nBytes;
        
        while (length > 0)
        {
            for (var i = 0; i < nBytes; i++)
                bytes[i] ^= bytes[pos+i];
            
            pos    += nBytes;
            length -= nBytes;
        }
    }
    

    return newSizeArrayFrom(bytes, nBytes);
}


var productKey = '';



function showProductKeyDialog()
{
    productKeyBack  .style.display = 'block';
    productKeyDialog.style.display = 'block';

    productKeyUserInfo.innerHTML = '<span style="user-select: none; color: #aaa;">User ID: </span>' + currentUser.id;

    setDefaultProductKeyInput();
    productKeyInputBack.innerHTML = ''.repeat(13);
    productKeyInput.value = '';
    
    //menuSelect.setSelectedIndex(0);
    
    window.setTimeout(() => document.getElementById('productKeyInput').focus(), 0);
}



function hideProductKeyDialog()
{
    productKeyBack  .style.display = 'none';
    productKeyDialog.style.display = 'none';
}



productKeyBack.addEventListener('pointerdown', () =>
{
    hideProductKeyDialog();
});



productKeyInput.addEventListener('input', () =>
{
    let val = productKeyInput.value;
    
    val = val.toUpperCase();
    val = val.replace(/[^12345679ABCDEFGHJKLMNPQRSTUVWXYZ]/g, '');
    val = val.substring(0, Math.min(val.length, 13));
    
    productKeyInput.value = val;

    productKeyInputBack.innerHTML = 
          '&nbsp;'.repeat(val.length)
        + ''.repeat(13 - val.length);

    
    if (val.length == 13)
    {
        if (validateProductKey(currentUser.id, val))
        {
            productKey = val;        
            uiSetLocalData('productKey', productKey);
            
            productKeyInput.blur();
            setGoodProductKeyInput();
            
            window.setTimeout(() => 
            {
                hideProductKeyDialog();
                //updateMenuSelectItems();

                uiNotify(' Thank you for subscribing to Generator! ', '', 6000);    
            }, 
            1200);
        }
        else
            setBadProductKeyInput();
    }
    else
        setDefaultProductKeyInput();
});



function setBadProductKeyInput()
{
    productKeyInput.style.outline   = '2px dashed #e00';        
    productKeyInput.style.boxShadow = 'none';
}



function setGoodProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px #0b0';
}



function setDefaultProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
    productKeyInput.style.boxShadow = '0 0 0 2px var(--figma-color-bg-brand)'; 
}




////////////////////////////////////////////////////

</script>
