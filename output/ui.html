<!-- <link rel="preconnect" href="https://rsms.me/">
<link rel="stylesheet" href="https://rsms.me/inter/inter.css"> -->

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

<link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<style>


:root
{
    /* --colFigmaBlue: #0c8ce9; */
}


:root 
{
    --data-mode-node:        #fed;
    --data-mode-node-active: #fdb;

    --data-mode-conn:        #cfc;
    --data-mode-conn-active: #aea;
}


#dataModeView
{
    position:   absolute;
    left:       0;
    top:        0;
    width:      100%;
    height:     100%;
    display:    none;
    background: var(--figma-color-bg);
    z-index:    4;
}



#dataModeTitleBar
{
    padding: 13px 12px 14px 17px;
}


#dataModeContent
{
    overflow-y: scroll;
    height:     calc(100% - 43px);
}


#dataModeContent::-webkit-scrollbar
{
    background: transparent;
    width:      6px;
}


#dataModeContent::-webkit-scrollbar-track
{
    margin: 6px 6px 6px 0;
}


#dataModeContent::-webkit-scrollbar-thumb
{
    border-radius: 4px;
}


.figma-dark #dataModeContent::-webkit-scrollbar-thumb
{ 
    background:    #fff4;
    /* background-color: #0006;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}

.figma-light #dataModeContent::-webkit-scrollbar-thumb
{ 
    background-color: #0004;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}    


.dataModeRowWrapper
{
    padding:         13px 12px 20px 13px;
    border-bottom:   1px solid var(--figma-color-bg-tertiary);
}


.dataModeRowTitle
{
    font-family:    Inter;
    font-size:      11px;
    color:          var(--figma-color-text);
    font-weight:    600;
    margin:         4px 0 15px 4px;
}


.dataModePage
{
    font-family:    Inter;
    font-size:      11px;
    text-align:     center;
    display:        inline-block;
    min-width:      50px;
    background:     var(--data-mode-node); 
    border-radius:  3px;
    margin:         2px 0px 0px 3px;
    padding:        4px 4px;
    box-shadow:     0 0 0 1px #dac inset;
    white-space:    pre;
    vertical-align: top;
}


.dataModeNode
{
    font-family:    Inter;
    font-size:      11px;
    text-align:     center;
    display:        inline-block;
    min-width:      50px;
    background:     var(--data-mode-node); 
    border-radius:  3px;
    margin:         2px 0px 0px 3px;
    padding:        4px 4px;
    box-shadow:     0 0 0 1px #dca inset;
    white-space:    pre;
    vertical-align: top;
}


.dataModeConn
{
    font-family:    Inter;
    font-size:      11px;
    text-align:     center;
    display:        inline-block;
    min-width:      70px;
    background:     var(--data-mode-conn); 
    border-radius:  3px;
    margin:         2px 0px 0px 3px;
    padding:        4px 0px;
    box-shadow:     0 0 0 1px #ad8 inset;
    white-space:    pre;
    vertical-align: top;
}


.pageDataHeader
{
    border-bottom: 1px solid #b8a; 
    padding:       0px 11px 4px 9px;
}


.pageDataBody
{
    padding:       4px 11px 0px 0px;
}


.nodeDataHeader
{
    border-bottom: 1px solid #ba8; 
    padding:       0px 11px 4px 9px;
}


.nodeDataBody
{
    padding:       4px 11px 0px 0px;
}


.connDataHeader
{
    border-bottom: 1px solid #8b6; 
    padding:       0px 11px 4px 9px;
}


.connDataBody
{
    padding:       4px 11px 0px 0px;
}


.dataUndefined
{
    background: red;
    color:      white;
    padding:    0 3px;
}


.dialogButtonClose
{
    width:      32px;
    height:     32px;
    position:   absolute;
    left:       calc(100% - 36px);
    top:        4px;
}


.dialogButtonClose:active
{
    box-shadow: none;
}


#productKeyBack
{
    display:          none;

    z-index:          1;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;

    background-color: #0005
}


#productKeyDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    top:           50%;
    left:          50%;
    transform:     translateX(-50%)
                   translateY(-50%);

    width:         250px;
    height:        250px;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;

    overflow:      hidden;
}


.figma-light #productKeyDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #productKeyDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#productKeyTitle
{
    height:         40px;
    border-bottom:  1px solid rgb(0, 0, 0, 0.15);
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
}


#productKeyTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);

    pointer-events: none;
    user-select:    none;
}


#productKeyUserName
{
    font-size:      11px;
    font-weight:    bold;

    margin-top:     16px;
    margin-bottom:  3px;

    padding-bottom: 5px;

    position:       absolute;
    left:           50%;
    top:            70px;
    transform:      translateX(-50%);
    border-bottom:  1px solid var(--figma-color-bg-disabled);
    width:          240;

    overflow:       hidden;

    user-select:    text;

    /* box-shadow:  0 0 0 1px red inset; */
}


#productKeyUserId
{
    font-size:      11px;
    text-align:     center;

    margin-top:     0px;
    margin-bottom:  12px;

    position:       absolute;
    
    left:           50%;
    transform:      translateX(-50%);

    top:            70px;

    width:          180px;

    user-select:    text;

    overflow:       visible;

    /* box-shadow:  0 0 0 1px green inset; */
}


#productKeyTextBack
{
    display:        none;
    
    position:       absolute;
    left:           50%;
    top:            113px;
    width:          138px;
    height:         25px;

    transform:      translateX(-50%);

    z-index:        0;

    pointer-events: none;

    border-bottom:  1px solid var(--figma-color-bg-tertiary);

    /* box-shadow:  0 0 0 1px red inset; */
}



#productKeyInputBack
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    color:          var(--figma-color-bg-disabled);
    letter-spacing: 1px;
    
    width:          10em;
    padding-left:   3px;
    padding-top:    -2px;
    padding-bottom:  2px;

    position:       absolute;
    left:           calc(calc(50% - 4.5em) + 1px);
    top:            115px;

    z-index:        1;

    pointer-events: none;

    /* box-shadow:  0 0 0 1px red inset; */
}



#productKeyInput
{
    font-family:   'Roboto Mono';
    font-size:      16px;
    letter-spacing:  1px;
     
    width:          calc(10em + 2px);
    height:         24px;
    padding-left:   13px;
    padding-top:    -2px;
    padding-bottom:  2px;

    margin-bottom:  -3px;

    background:     transparent;

    position:       absolute;
    left:           calc(50%);
    top:            114px;

    transform:      translateX(-50%);
}


#licenseWatermark
{
    position:         absolute;
    left:             50%;
    top:              58px;
    transform:        translateX(-50%);
    width:            200px;
    height:           58px;
    overflow:         hidden;
    pointer-events:   none;
    z-index:          100;
}


#licenseInfo
{
    font-family:   'Inter';
    font-size:      11px;
    font-weight:    300;

    width:          max-content;
    height:         24px;
    padding-top:    4px;
    padding-bottom: 0;

    margin-bottom:  -3px;

    background:     transparent;

    position:       absolute;
    left:           calc(50%);
    transform:      translateX(-50%);
    top:            86px;


    pointer-events: none;

    text-align:     center;

    /* box-shadow:     0 0 0 1px red inset; */
}


#productKeyInput:disabled
{
    color: var(--figma-color-bg-disabled);
}


#validateProductKeyButton
{
    width:          138px;

    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);

    top:            147px;
}



#subscribeWebsite
{
    font-size:      11px;
    text-align:     center;

    margin-top:     16px;
    margin-bottom:   8px;

    position:       absolute;
    left:           50%;
    top:            200px;
    transform:      translateX(-50%);

    color:          var(--figma-color-bg-disabled);
}


#deleteConnectionsDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    width:         400px;
    height:        92px;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border-radius: 4px;
}


.figma-light #deleteConnectionsDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #deleteConnectionsDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#deleteConnectionsTitle
{
    height:         40px;
    font-weight:    900;
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
}


#deleteConnectionsTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);
}


#deleteConnectionsLabel
{
    font-size:      11px;

    margin-top:     16px;
    margin-bottom:  12px;

    position:       relative;
    left:           17px;

    user-select:    text;
}


#deleteConnectionsInputBack
{
    font-size:       11px;
    color:           var(--figma-color-bg-disabled);
      
    width:           266px;
    height:          20px;
 
    padding-top:     6px;
    padding-bottom: -6px;

    margin-top:      12px;
    margin-bottom:  -3px;

    position:        absolute;
    left:            18px;
}


#deleteConnectionsInput
{
    background:     transparent;
    font-size:      11px;
      
    width:          278px;
    height:         26px;
 
    padding-left:   6px;
    padding-right:  6px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-top:     12px;
    margin-bottom: -3px;

    position:       absolute;
    left:           12px;
}


#deleteConnectionsButton
{
    width:          60px;

    position:       absolute;
    right:          12px;
    transform:      translateY(-2px);

    margin-top:     12px;
}


#minZoomDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    width:         200px;
    height:        92px;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border-radius: 4px;
}


.figma-light #minZoomDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #minZoomDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#minZoomTitle
{
    height:         40px;
    font-weight:    900;
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
}


#minZoomTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);
}


#minZoomInput
{
    background:     transparent;
    font-size:      11px;
      
    width:          176px;
    height:         26px;
 
    padding-left:   6px;
    padding-right:  6px;
    padding-top:   -2px;
    padding-bottom: 2px;

    margin-top:     12px;
    margin-bottom: -3px;

    position:       absolute;
    left:           12px;
}


#whatsNewBack
{
    display:          none;

    z-index:          1;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    pointer-events:   all;

    background-color: #0005;
}



#whatsNewDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    top:           58px;
    left:          calc(50%);
    transform:     translateX(-50%);
    width:         600px;
    height:        calc(100% - 80px);

    overflow:      hidden;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;
}


#whatsNewDialogContainer
{
    height:   calc(100% - 42px);
    overflow: hidden;
    padding:  0;
    z-index:  1;
    /* box-shadow: 0 0 0 1px red inset; */
}


#whatsNewDialogContent
{
    font-size:      12px;
    margin:         0;
    padding:        1px 0 5px 0;
    position:       absolute;
    pointer-events: all;
    user-select:    text;
    /* box-shadow:  0 0 0 1px blue inset; */
}


.figma-light #whatsNewDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #whatsNewDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#whatsNewWatermark
{
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-41%)
                    translateY(-34%);
    font-size:      800px;
    font-weight:    600;
    white-space:    nowrap;
    color:          var(--figma-color-bg-secondary);
    z-index:        -1;
    user-select:    none;
    pointer-events: none;
}



#whatsNewTitle
{
    position:       relative;
    height:         40px;
    border-bottom:  1px solid rgb(0, 0, 0, 0.15);
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
    background:     var(--figma-color-bg);
    z-index:        10;
}


#whatsNewTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);

    pointer-events: none;
    user-select:    none;
}


#whatsNewBody
{
    margin:  0 30px 0 30px;
}



#chkHideWhatsNew
{
    display:  inline-block;
}



#whatsNewScrollbarY
{
    width:   6px;
    z-index: 1;
    margin:  6px 0 18px 0;
    display: none;
}



#aboutBack
{
    display:          none;

    z-index:          1;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    pointer-events:   all;

    background-color: #0005;
}



#aboutDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       2;
    position:      absolute;
    top:           50%;
    left:          50%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         270px;
    height:        160px;

    overflow:      hidden;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;
}


#aboutDialogContainer
{
    height:   calc(100% - 22px);
    overflow: hidden;
    padding:  0;
    z-index:  1;
    /* box-shadow: 0 0 0 1px red inset; */
}


#aboutDialogContent
{
    font-size: 12px;
    margin:    0;
    padding:   1px 0 5px 0;
    position:  absolute;
    pointer-events: all;
    user-select: text;
    /* box-shadow: 0 0 0 1px blue inset; */
}


.figma-light #aboutDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #aboutDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#aboutTitle
{
    position:       relative;
    height:         40px;
    border-bottom:  1px solid rgb(0, 0, 0, 0.15);
    border-top:     1px solid var(--figma-color-bg-tertiary);
    border-bottom:  1px solid var(--figma-color-bg-tertiary);
    background:     var(--figma-color-bg);
    z-index:        10;
}


#aboutTitleText
{
    position:       absolute;
    left:           16px;
    top:            12px;
    
    font-style:     normal;
    font-weight:    600;
    font-size:      11px;
    line-height:    16px;
    
    display:        flex;
    align-items:    center;
    letter-spacing: 0.005em;
    
    color:          var(--figma-color-text);

    pointer-events: none;
    user-select:    none;
}


#aboutDialogBody
{
    padding-left: 30px;
    width:        250px;
    /* box-shadow:   0 0 0 1px inset yellow; */
}


#chkAboutHideWhatsNew
{
    display:  inline-block;
}


#aboutBrainshiftLogo
{
    position:  absolute;
    left:      97px;
    top:       82px;
}


#aboutGeneratorLogo
{
    position: absolute;
    left:     33px;
    top:      22px;
}


#aboutLine
{
    position: absolute;
    left:     18px;
    top:      132px;
}


#aboutVersion
{
    font-weight: 300;
    font-size:   11px;
    display:     inline;
    position:    absolute;
    left:        100px;
    top:         18px;
}


#aboutCopyright
{
    font-weight: 300;
    font-size:   11px;
    display:     inline-block;
    width:       max-content;
    position:    absolute;
    left:        99px;
    top:         37px;
}


#crashBack
{
    display:          none;

    z-index:          10;
    
    position:         fixed;
    left:             0;
    top:              0;
    width:            100%;
    height:           100%;
    overflow:         auto;
    pointer-events:   all;

    background-color: #0005;
}



#crashDialog
{
    display:       none;

    font-family:   Inter;

    z-index:       20;
    position:      absolute;
    top:           50%;
    left:          50%;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         440px;
    height:        300px;

    overflow:      hidden;
    
    color:         var(--figma-color-text);
    background:    var(--figma-color-bg);
    
    border:        0.5px solid rgba(0, 0, 0, 0.2);

    border-radius: 4px;

    /* -webkit-font-smoothing: subpixel-antialiased;
    -moz-osx-font-smoothing: auto; */
}


#crashDialogContainer
{
    height:   calc(100% - 42px);
    overflow: hidden;
    padding:  0;
    z-index:  1;
    /* box-shadow: 0 0 0 1px red inset; */
}


#crashDialogContent
{
    font-size:      12px;
    margin:         0;
    padding:        1px 0 5px 0;
    position:       absolute;
    pointer-events: all;
    user-select:    text;
    width:          100%;
    /* box-shadow:     0 0 0 1px blue inset; */
}


.figma-light #crashDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark #crashDialog
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


#crashTitle
{
    font-size:     14px;
    font-weight:   500;
    margin-top:    20px;
    margin-bottom: 27px;
}


#crashDetails
{
    /* font-weight: bold; */
    height:        165px;
    margin-bottom: 30px;
    position:      relative;
    left:          1px;
    overflow-y:    scroll;
    /* box-shadow:    0 0 0 1px red inset; */
}


#crashDetails::-webkit-scrollbar
{
    background: transparent;
    width:      6px;
}


#crashDetails::-webkit-scrollbar-track
{
    margin: 6px 6px 6px 0;
}


#crashDetails::-webkit-scrollbar-thumb
{
    border-radius: 4px;
}


.figma-dark #crashDetails::-webkit-scrollbar-thumb
{ 
    background:    #fff4;
    /* background-color: #0006;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}


.figma-light #crashDetails::-webkit-scrollbar-thumb
{ 
    background-color: #0004;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}    


#crashDialogBody
{
    margin: 0 25px 0 25px;
}


#btnCrashRestart
{
    position: absolute;
    right:    24px;
    bottom:   21px;
}


#debugInfo
{
    color:            var(--figma-color-text);
    position:         absolute;
    left:             0;
    top:              40px;
    width:            100%; 
    height:           calc(100% - 40px);
    z-index:          100000;
    /* background-color: blue; */
    pointer-events:   none;
}


#loadingOverlay
{
    position: absolute;
    left:     0;
    top:      0;
    width:    100%;
    height:   100%;
    display:  block;
    z-index:  10;
}


.figma-light #loadingOverlay { background: #f0f0f0; } /* my tuning of bg-tertiary */
.figma-dark  #loadingOverlay { background: #1e1e1e; }


#loadingGraphic
{
    display:     none;
    font-family: Inter;
    font-size:   26;
    font-weight: 800;
    color:       var(--figma-color-text);/*#333;*/
    position:    absolute;
    left:        50%;
    top:         50%;
    width:       184px;
    height:       64px;
    transform:   translateX(-50%)
                 translateY(-50%);
    /* box-shadow:  0 0 0 1px red inset; */
}


.figma-light #loadingGraphic { font-weight: 800; }
.figma-dark  #loadingGraphic { font-weight: 600; }


#loadingG 
{
    position:  absolute;
    left:      50%;
    top:       40%;
    transform: translateX(-50%)
               translateY(-50%);
}

#loadingEmpty, #loadingFull
{
    position:  absolute;
    left:      calc(50% - 4px);
    top:       calc(40% - 4px);
}

#loadingG     > path { fill: var(--figma-color-text);            }

#loadingEmpty        { animation: emptyOrbit 5s linear infinite; }
#loadingEmpty > path { fill:var(--figma-color-text);             }

#loadingFull         { animation: fullOrbit 5s linear infinite;  }
#loadingFull  > path { fill: var(--figma-color-text);            }


@keyframes emptyOrbit
{
      0%   { transform: rotate(   0deg) translate(-20px) scale(100%);  opacity: 100%; }
     10%   { transform: rotate(-170deg) translate(-20px) scale(100%);  opacity: 100%; }
     11.3% { transform: rotate(-180deg) translate(-20px) scale(130%);  opacity: 100%; }
     15.3% { transform: rotate(-180deg) translate(-20px) scale(130%);  opacity: 100%; }
     20%   { transform: rotate(-180deg) translate(-20px) scale( 50%);  opacity:   0%; }
     23.4% { transform: rotate(-360deg) translate(-20px) scale(150%);  opacity:   0%; }
     26.7% { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     50%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     62%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     63.3% { transform: rotate(-360deg) translate(-20px) scale(130%);  opacity: 100%; }
     65.3% { transform: rotate(-360deg) translate(-20px) scale(130%);  opacity: 100%; }
     68%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     73.3% { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
     80%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
    100%   { transform: rotate(-360deg) translate(-20px) scale(100%);  opacity: 100%; }
}


@keyframes fullOrbit
{
      0%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     12%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     12.7% { transform: rotate(   0deg) translate(20px) scale( 75%);  opacity: 100%; }
     13.3% { transform: rotate(   0deg) translate(20px) scale( 75%);  opacity: 100%; }
     22%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     23.4% { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     30%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     50%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
     62%   { transform: rotate(-170deg) translate(20px) scale(100%);  opacity: 100%; }
     63.3% { transform: rotate(-180deg) translate(20px) scale( 50%);  opacity: 100%; }
     65.3% { transform: rotate(-180deg) translate(20px) scale( 50%);  opacity: 100%; }
     68%   { transform: rotate(-180deg) translate(20px) scale(  0%);  opacity:   0%; }
     73.4% { transform: rotate(   0deg) translate(20px) scale( 80%);  opacity:   0%; }
     76.7% { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
    100%   { transform: rotate(   0deg) translate(20px) scale(100%);  opacity: 100%; }
}


#loadingBar
{
    position:      absolute;
    left:          50%;
    bottom:          0;
    transform:     translateX(-50%)
                   translateY(-50%);
    width:         180px;
    height:        5px;
    border-radius: 2.5px;
    overflow:      hidden;
    /* box-shadow:    0 0 0 1px yellow inset; */
}


.figma-light #loadingBar { background: white; }
.figma-dark  #loadingBar { background: var(--figma-color-bg-tertiary); }


#loadingProgress
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         0;
    height:        5px;
    background:    var(--figma-color-text);
}


#btnLoadingRestart
{
    position:      absolute;
    left:          50%;
    top:           calc(75%);
    transform:     translateX(-50%)
                   translateY(-50%);
}


.btnRestart
{
    position:      static;
    font-family:   Inter;
    font-weight:   500;
    font-size:     11px;
    color:         var(--figma-color-text);
    padding:       10px 13px 10px 13px;
    border-radius: 6px;
    box-shadow:    0 0 0 1px inset var(--figma-color-text);
    width:         fit-content;
    /* display:       none; */
}


.btnRestart:active
{
    box-shadow:    0 0 0 2px inset var(--figma-color-bg-brand);
    background:    var(--figma-color-bg-pressed);
}


input[type=text]
{
    font-size:     11;
    font-family:   Inter;
    padding-top:   1px; 
    height:        20px;
    line-height:   14px;
    border:        none;
    border-radius: 0.5px;
    cursor:        default;
}


input[type=text]:focus
{
    box-shadow: 0 0 0 1px var(--activeObjectColor) inset;
    outline:    none;
}


input[type=text]::selection
{
    background-color: var(--figma-color-bg-brand);
    color:            white;
}


@import url('https://rsms.me/inter/inter.css');
html { font-family: 'Inter', sans-serif; }

@supports (font-variation-settings: normal) 
{
  html { font-family: 'Inter var', sans-serif; } 
}


body
{
    margin:                0;
    user-select:           none;
    font-family:           Inter;

    -webkit-touch-callout: none; 
      -webkit-user-select: none; 
       -khtml-user-select: none; 
         -moz-user-select: none; 
          -ms-user-select: none; 
              user-select: none; 

    overflow:              hidden;
}


/* body:active
{
    box-shadow: 0 0 0 1px red inset;
} */


.figma-light body { background: #f4f4f4; }
.figma-dark  body { background: #252524; }


div
{
    margin:  0;
    padding: 0;
}



#keyboardPanel
{
    display:       none;
    background:    #1E1E1E;
    width:         calc(100% - 2px);
    height:        240px;
    position:      absolute;
    bottom:        0;
    border-top:    1px solid #ffffff25;
    border-bottom: 1px solid #ffffff0d;
    border-left:   1px solid #ffffff08;
    border-right:  1px solid #ffffff08;
    z-index:       100;
}


#keyboardPanelTabsHolder
{
    height:        36px;
    overflow:      hidden;
    position:      relative;
    /* box-shadow:    0 0 0 1px inset red; */
    z-index:       1;
}


#keyboardPanelTabs
{
    display:    flex;
    width:      fit-content;
    height:     36px;
    position:   absolute;
    left:       50%;
    transform:  translateX(-50%);
    /* box-shadow: 0 0 0 1px inset blue;    */
}


#keyboardPanelTab
{
    background:    #1E1E1E;
    color:         #b6b6b6;
    font-size:     12px;
    font-weight:   500;
    display:       inline;
    padding-left:  16px;
    padding-right: 16px;
    padding-top:   10px;
    margin:        0;
    height:        26px;
    /* box-shadow:    0 0 0 1px inset green;    */
}


#keyboardPanelTab:hover
{
    color:         #f6f6f6;
}


#keyboardPanelClose
{
    position:            absolute;
    top:                 0;
    right:               0;
    width:               35px;
    height:              35px;
    background:          url('data:image/svg+xml;utf8,<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><path id="keyboardCloseX" fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="%23777"/></svg>');
    background-position: 50% calc(50% - 1px);
    background-repeat:   no-repeat;
}


#keyboardPanelClose:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg"><path id="keyboardCloseX" fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="%23f6f6f6"/></svg>');
    background-position: 50% calc(50% - 1px);
    background-repeat:   no-repeat;
}


#keyboardPanelContent
{
    position:   absolute;
    top:        35px;
    background: #1E1E1E;
    border-top: 1px solid #ffffff1b;   
    width:      100%;
    height:     206px;
    /* box-shadow: 0 0 0 1px inset orange; */
    z-index:    0;
}


.keyboardPage
{
    display:        flex;
    position:       absolute;
    left:           50%;
    top:            0;
    transform:      translateX(-50%);
    padding-top:    6px;
    width:          max-content;
    height:         calc(100% - 7px);
    /* box-shadow:     0 0 0 1px inset red; */
}


.keyboardGroup
{
    display:        inline-block;
    width:          300px;
    height:         auto;
    vertical-align: top;
    /* box-shadow:     0 0 0 1px inset yellow; */
}


.nextGroup
{
    margin-left: 46px;
}


.keyboardLabel
{
    display:     inline-block;
    font-size:   12px;
    font-weight: 600;
    color:       #757575;
    width:       300px;
    height:      26px;
    padding-top: 11px;
    /* box-shadow:  0 0 0 1px inset green; */
}


.keyboardInfo
{
    display:     inline-block;
    font-size:   12px;
    color:       #b6b6b6;
    font-weight: 500;
    width:       300px;
    height:      26px;
    padding-top: 11px;
    /* box-shadow:  0 0 0 1px inset green; */
}


.keyboardShortcut
{
    display:    inline-block;
    position:   relative;
    width:      300px;
    height:     37px;
    /* box-shadow: 0 0 0 1px inset green; */
}


.shortcutAction
{
    position:    absolute;
    left:        0;
    top:         50%;
    transform:   translateY(calc(-50% - 1px));
    display:     inline-block;
    font-size:   12px;
    font-weight: 500;
    color:       #bcbcbc;
    width:       fit-content;
    /* box-shadow:  0 0 0 1px inset blue; */
}


.shortcutKeys
{
    position:    absolute;
    right:       0;
    top:         50%;
    transform:   translateY(-50%);
    display:     flex;
    width:       fit-content;
    white-space: nowrap;
    /* box-shadow:  0 0 0 1px inset magenta; */
}


.shortcutKey
{
    font-family:             Inter;
    display:                 inline-block;
    font-size:               11px;
    color:                   #bcbcbc;
    margin-left:             3px;
    margin-right:            0px;
    padding-left:            5px;
    padding-right:           5px;
    padding-top:             5px;
    width:                   max(20px, fit-content);
    height:                  19px;
    border-radius:           2px;
    box-shadow:              0 0 0 1px inset #bcbcbc;
    font-variant-alternates: stylistic(), styleset();
    font-feature-settings:   'salt' on, 'ss02' on;
}


.shortcutChar
{
    padding-left:  9px;
    padding-right: 9px;
}

.shortcutCharWide
{
    padding-left:  5px;
    padding-right: 5px;
}

.shortcutCharNarrow
{
    padding-left:  9px;
    padding-right: 9px;
}



#pagesBar
{
    display:          flex;
    flex-wrap:        nowrap;
    flex-grow:        1 1;
    width:            100%;
    height:           36px;
    background-color: #1e1e1e;
    padding:          0;
    cursor:           default;
    position:         relative;
    z-index:          0;
    white-space:      nowrap;
    /* box-shadow:       0 0 0 1px red inset; */
}


.page
{
    /* flex:          0 1 auto; */
    flex-shrink:   1;
    font-family:   Inter;
    font-size:     11px;
    display:       inline-block;
    /* width:         auto; */
    /* min-width:     100px; */
    max-width:     272px;
    height:        calc(100% - 11px);
    outline:       1px solid var(--figma-color-bg-tertiary);
    padding-top:   11px;
    padding-right: 10px
}


.pageIcon
{
    display:      inline-block;
    width:        14px;
    height:       14px;
    margin-left:  13px;
    /* box-shadow:   0 0 0 1px red inset; */
}


.pageName
{
    display:     inline-block;
    flex-shrink: 1;
    /* height:  fit-content; */
    /* box-shadow: 0 0 0 1px orange inset; */
    margin-left: 9px;
    position:    relative;
    top:        -3px;
}


.pageClose
{
    display:     inline-block;
    position:    relative;
    top:         -2px;
    width:       8px;
    height:      8px;
    /* box-shadow:  0 0 0 1px green inset; */
    margin-top:  2px;
    margin-left: 13px;
}


#btnAddPage
{
    /* flex-shrink: 0 0 34px; */
    display:       inline-block;
    position:      relative;
    left:          1px;
    top:           -2px;
    outline:       none;
    /* width:         34px; */
    height:        calc(100% - 13px);
    padding-top:   13px;
    padding-left:  11px;
    padding-right: 12px;
    /* box-shadow:    0 0 0 1px orange inset; */
}


.tooltipPre /* to avoid FOUC (flash of unstyled content) */
{
    font-family: Inter;
    font-size:   12px;
}


.tooltip
{
    display:          none;
    font-family:      Inter;
    font-size:        11px;
    opacity:          0;
    width:            auto;
    height:           15px;
    background-color: #1e1e1e;
    color:            #eee;
    border-radius:    2px;
    padding:          5px 10px 5px 10px;
    position:         absolute;
    z-index:          10000;
    bottom:           125%;
    left:             13px;
    top:              44px;
}


.tooltip p
{
    margin: 0;
}


.figma-light .tooltip
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.15),
                      0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark .tooltip
{
    box-shadow:       0px 2px  7px rgba(0, 0, 0, 0.35),
                      0px 5px 22px rgba(0, 0, 0, 0.35),
                      0 0px 2px 0px #fff1 inset,
                      0 0.5px 1px 0px #fff2 inset;
}


#tooltipArrow
{
    content:        '';
    position:       absolute;
    margin-left:   -7px;
    border-width:   7px;
    border-style:   solid;
    border-color:   transparent transparent #1e1e1e transparent;
    display:        none;
    opacity:        0%;
    z-index:        20000;
    pointer-events: none;
}


.tooltipBottom
{
    display:    block;
    width:      100%;
    height:     25px;    
    position:   absolute;
    left:       0;
    bottom:     0;
    box-shadow: 0 1px 0 0px inset #ffffff1b;
}


.ignoreButton
{
    border-left: 1px solid #ffffff1b;
    position:    absolute;
    right:       0px;
    text-align:  center;
    width:       74px;
    height:      20px;
    padding-top: 6px;
}


.ignoreButton:hover
{
    background: #ffffff1b;
}


#ttColorblind
{
    width:        208px; 
    height:       322px;
    padding-left: 20px;
}


#ttMinValueZoom
{
    width: max(188px, auto);
}


#ttInterpolationSpace
{
    width:  193px;
    height: 228px;
}    


#ttWcag2
{
    width:  240px;
    height: 140px;
}    

.wcag2description
{
    text-align:       left;
    position:         absolute;
    top:              56px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag2value
{
    position:  absolute;
    top:       102px;
    transform: translateX(-50%);
}


#wcag2info
{
    position:  absolute;
    left:      50%;
    top:       120px;
    transform: translateX(-50%);
}


#wcag2info a
{
    color: #6eb8e9
}


#ttWcag3
{
    width:  240px;
    height: 130px;
}


.wcag3description
{
    text-align:       left;
    position:         absolute;
    top:              46px;
    transform:        rotateZ(-45deg);
    transform-origin: bottom left;
}


.wcag3value
{
    position:  absolute;
    top:       90px;
    transform: translateX(-50%);
}


#wcag3info
{
    position:  absolute;
    left:      50%;
    top:       100px;
    transform: translateX(-50%);
}


#wcag3info a
{
    color: #6eb8e9
}


#ttText
{
    padding:     0;
    height:      fit-content;
    /* box-shadow: 0 0 0 1px orange inset; */
}


#ttTextString
{
    display:     inline-block;
    padding:     10px;
    width:       auto;
    height:      auto;
    max-width:   400px;
    white-space: pre-wrap;
    /* box-shadow: 0 0 0 1px red inset; */
}


#tooltipTextBottom
{
    position: static;
}


#selectBox
{
    outline:          1pt solid var(--figma-color-bg-brand);
    background-color: #18A0FB20;
    pointer-events:   none;
    margin:           0;
    padding:          0;
    position:         absolute;
    visibility:       hidden;
}


#scrollbarX
{
    height: 6px;
}


#scrollbarY
{
    width: 6px;
}


.scrollbar
{
    border-radius:    4px;
    position:         absolute;
    display:          none;
}


.figma-light .scrollbar 
{ 
    background-color: #0004;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}


.figma-dark .scrollbar 
{ 
    background-color: #0006;
    box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25); 
}


.dialogScrollbar
{
    border-radius:    4px;
    position:         absolute;
    display:          none;
}


.figma-light .dialogScrollbar 
{ 
    background-color: var(--figma-color-text-tertiary);
    /* box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}

.figma-dark .dialogScrollbar 
{ 
    background-color: var(--figma-color-text-tertiary);
    /* box-shadow:       0 0 0 1px rgba(255, 255, 255, 0.25);  */
}


input[type=text]
{
    color:      var(--figma-color-text);
    background: var(--figma-color-bg);
}


input[type=text]:hover
{
    box-shadow: 0 0 0 1px var(--figma-color-bg-tertiary);
}


input[type=text]:focus
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
    outline:    none;
}


input[type=text]::selection
{
    color:            var(--figma-color-bg-inverse);
    background-color: var(--figma-color-border-brand);
}


a
{
    color: var(--figma-color-text-brand);
}


:root
{
    --operatorSymbolSize: 26;
    --colorBackSize:      45px;
}


#_graphView
{
    display:    block;
    overflow:   hidden;
    height:     calc(100% - 40px);
    position:   relative;
    z-index:    2;
    box-shadow: 0 1px 0 0 inset #383838;
    /* box-shadow: 0 0 0 1px red inset; */
}


.wireContainer
{
    position:       absolute;
    width:          100%;
    height:         calc(100% - 1px);
    z-index:        1;
    pointer-events: none;
    overflow:       hidden;
}


.menuButton
{
    display:       inline-block;
    font-family:   Inter;
    font-size:     11px;
    width:         50px;
    height:        40px;
    background:    #2c2c2c;
    border-radius: 0;
    min-width:     0;
    min-height:    0;
    border:        none;
    position:      relative;
    padding:       0;
    color:         #fff;
    overflow:      hidden;
    cursor:        default;
    /* box-shadow:    0 0 0 1px red inset; */
}


.menuButton:hover
{
    /* background: black; */
    color:      white;
}


.menuButtonIcon
{
    display:             inline-block;
    width:               30px;
    height:              40px;
    /* box-shadow: 0 0 0 1px yellow inset; */
}


.menuButtonArrow
{
    display:             inline-block;
    width:               20px;
    height:              40px;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="5" viewBox="0 0 8 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.507593 1.22627L1.2469 0.498783L4.01388 3.22151L6.78084 0.498783L7.52015 1.22627L4.01388 4.67648L0.507593 1.22627Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    transition:          0.25s;
    /* box-shadow: 0 0 0 1px magenta inset; */
}


.menu
{
    display:          none;
    position:         absolute;
    width:            auto;
    height:           auto;
    padding:          8px 0 8px 0;
    border-radius:    2px;
    font-family:      Inter;
    font-size:        11px;
    overflow:         hidden;
    overflow-y:       hidden;
    color:            #eee;
    background-color: #1e1e1e;
    z-index:          10000;
}


.menu::-webkit-scrollbar
{
    background: transparent;
    width:      6px;
}


.menu::-webkit-scrollbar-track
{
    margin: 4px 4px 4px 0;
}


.menu::-webkit-scrollbar-thumb
{
    background:    #fff4;
    border-radius: 3px;
}


.menuItems
{
    display:          inline-block;
    height:           fit-content;
    /* box-shadow:       0 0 0 1px red inset; */
}


.figma-light .menu
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.15),
                0px 5px 17px rgba(0, 0, 0, 0.15);
}


.figma-dark .menu
{
    box-shadow: 0px 2px  7px rgba(0, 0, 0, 0.45),
                0px 5px 25px rgba(0, 0, 0, 0.45),
                0 0px 2px 0px #fff3 inset;
}


.menuArrow
{
    content:      '';
    position:     absolute;
    margin-left:  -7px;
    border-width: 7px;
    border-style: solid;
    border-color: transparent transparent #1e1e1e transparent;
    display:      none;
    opacity:      0%;
    box-shadow:   0 0px 2px 0px #fff3 inset;
    z-index:      20000;
}


.menuItem
{
    display:     inline-block;
    width:       100%;
    height:      auto;
    font-family: Inter;
    font-size:   12px;
    /* box-shadow:  0 0 0 1px red inset; */
}


.menuItemHighlight
{
    display:  block;
    position: absolute;
    /* width:    100%; */
    height:   25px;
}


.menuItemCheck
{
    display:             inline-block;
    width:               32px;
    height:              22px;
    background:          url('data:image/svg+xml;utf8,<svg width="9" height="9" viewBox="0 -2 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.31749 2.4477L3.42546 4.55569L7.64142 0.339716L8.9589 1.65721L3.42546 7.19067L0 3.76519L1.31749 2.4477Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    visibility:          hidden;
    /* box-shadow:          0 0 0 1px blue inset; */
}



.menuItemIcon
{
    display:             inline-block;
    width:               32px;
    height:              22px;
    /* box-shadow:          0 0 0 1px orange inset; */
    transform:           translateY(1px);
}


.menuItemName
{
    display:     inline-block;
    position:    relative;
    font-weight: 500;
    top:        -5px;
    filter:      grayscale(); /* disables cleartype to match Figma */
    /* box-shadow: 0 0 0 1px yellow inset; */
}


.menuItemExpand
{
    display:             inline-block;
    width:               48px;
    height:              22px;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="9" viewBox="0 -1 6 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 4L0 0V8L6 4Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    visibility:          hidden;
    position:            absolute;
    right:               0;
    /* box-shadow:          0 0 0 1px green inset; */
}


.menuItemShortcut
{
    display:                 inline-block;
    position:                absolute;
    right:                   16px;
    transform:               translateY(5px);
    font-variant-alternates: stylistic(), styleset();
    font-feature-settings:   'salt' on, 'ss02' on;
    filter:                  grayscale(); /* disables cleartype to match Figma */
    /* box-shadow: 0 0 0 1px green inset; */
}


.disambiguate
{
    font-variant-alternates: stylistic(), styleset();
    font-feature-settings:   'salt' on, 'ss02' on;
}


.menuSeparator
{
    display:    inline-block;
    width:      100%;
    height:     1px;
    background: #383838;
    margin:     8px 0 8px 0;
}


#menuBar
{
    display:          flex;
    height:           40px;
    background-color: #2c2c2c;
    /* border-bottom:    1px solid var(--figma-color-bg-tertiary); */
    padding:          0;
    cursor:           default;
    position:         relative;
    z-index:          4;
    /* vertical-align:   middle; */
}



#pageName
{
    font-family:  Inter;
    font-size:    14px;
    color:        #fff;
    padding-top:  11px;
    margin-left:  auto;
    position:     relative;
    left:        -26px;
    /* margin-right: auto; */
    white-space:  nowrap;
    /* box-shadow:   0 0 0 1px yellow inset; */
}


#btnZoom
{
    position:      absolute;
    padding-left:  15px;
    padding-right: 45px;
}


#btnToggleWires
{
    position:            absolute;
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="%23d5d5d5" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="%23d5d5d5"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnToggleWires:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.65006 17.8918C15.4645 18.1216 13.0131 12.9935 10.1855 10.4007C7.35798 7.80786 4.94977 2.68156 17.7642 2.91138" stroke="white" stroke-width="1"/><circle cx="2.65005" cy="17.8918" r="2" transform="rotate(2.45954 2.65005 17.8918)" fill="white"/><circle cx="17.7642" cy="2.91141" r="2" transform="rotate(-177.54 17.7642 2.91141)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}



#btnCreateInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="23" height="5" viewBox="0 0 23 5" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.08447 0.0411377H9.96753V1.95288H18.5752C18.8079 1.10352 19.5852 0.479248 20.5085 0.479248C21.6155 0.479248 22.5129 1.37671 22.5129 2.48364C22.5129 3.5907 21.6155 4.48816 20.5085 4.48816C19.563 4.48816 18.7705 3.83362 18.5593 2.95288H9.96753V4.98364H8.08447V2.95288H4.51294C4.32324 3.85986 3.51904 4.54102 2.55566 4.54102C1.45117 4.54102 0.555908 3.64563 0.555908 2.54114C0.555908 1.43677 1.45117 0.541382 2.55566 0.541382C3.45532 0.541382 4.21631 1.13562 4.46753 1.95288H8.08447V0.0411377Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorInterpolate
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="%23d5d5d5"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.3"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="%23d5d5d5"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorInterpolate:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="19" viewBox="0 0 21 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="2.56288" cy="8.48389" r="1.99853" fill="white"/><circle cx="18.464" cy="8.48389" r="1.99853" fill="white"/><path d="M18.464 8.47584C18.464 7.43175 18.2584 6.39789 17.8588 5.43329C17.4593 4.46868 16.8736 3.59221 16.1354 2.85393C15.3971 2.11565 14.5206 1.53002 13.556 1.13047C12.5914 0.730912 11.5575 0.525265 10.5135 0.525265C9.46937 0.525265 8.43551 0.730912 7.4709 1.13047C6.50629 1.53002 5.62983 2.11566 4.89155 2.85393C4.15327 3.59221 3.56764 4.46868 3.16808 5.43329C2.76853 6.39789 2.56288 7.43175 2.56288 8.47584" stroke="white" stroke-opacity="0.5"/><path d="M18.464 8.47584C18.464 9.51992 18.2584 10.5538 17.8588 11.5184C17.4593 12.483 16.8736 13.3595 16.1354 14.0977C15.3971 14.836 14.5206 15.4217 13.556 15.8212C12.5914 16.2208 11.5575 16.4264 10.5135 16.4264C9.46937 16.4264 8.43551 16.2208 7.4709 15.8212C6.50629 15.4217 5.62983 14.836 4.89155 14.0977C4.15327 13.3595 3.56764 12.483 3.16808 11.5184C2.76853 10.5538 2.56288 9.51992 2.56288 8.47584" stroke="white"/><rect x="7.07658" y="12.8511" width="1.88119" height="4.9512" transform="rotate(26.6869 7.07658 12.8511)" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateCorrectColor
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="%23d5d5d5"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateCorrectColor:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="17" height="16" viewBox="0 -1 17 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.179 3.06615L6.68506 9.56013L2.88329 5.75836L4.0255 4.61615L6.68506 7.27571L12.0369 1.92393L13.179 3.06615Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6.06159 1.13348C7.25451 1.03474 8.44629 1.33665 9.44831 1.99145L10.0355 1.09298C8.8335 0.307551 7.40396 -0.054602 5.97305 0.0638407C4.54213 0.182283 3.19159 0.774556 2.13516 1.74692C1.07873 2.71929 0.376759 4.0162 0.140351 5.43241C-0.0960669 6.84862 0.146575 8.30322 0.829881 9.56601C1.51319 10.8288 2.59812 11.8277 3.91297 12.4044C5.22782 12.9812 6.69749 13.1031 8.08937 12.7507C9.03602 12.5109 9.90991 12.0611 10.6496 11.4415L15.2558 15.9919L16.01 15.2284L11.4122 10.6861C11.4756 10.6118 11.5375 10.536 11.5977 10.4586C12.4797 9.32556 12.9585 7.93076 12.9585 6.49496H11.8852C11.8852 7.69195 11.486 8.85476 10.7507 9.79935C10.0155 10.744 8.98629 11.4164 7.82592 11.7102C6.66554 12.0039 5.44031 11.9024 4.34415 11.4216C3.24799 10.9407 2.3435 10.108 1.77385 9.05523C1.20419 8.00247 1.0019 6.7898 1.19899 5.60913C1.39609 4.42848 1.98131 3.34726 2.86203 2.53663C3.74275 1.72599 4.86867 1.23223 6.06159 1.13348Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorContrast
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="%23d5d5d5" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="%23d5d5d5"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorContrast:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="21" height="21" viewBox="-2 -2 27 27" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="11.1368" cy="11.4506" r="10.327" stroke="white" stroke-width="1.5"/><path d="M11.1368 22.5276C8.19902 22.5276 5.38153 21.3606 3.30419 19.2832C1.22684 17.2059 0.0597991 14.3884 0.0597992 11.4506C0.0597993 8.51278 1.22684 5.6953 3.30419 3.61795C5.38153 1.54061 8.19902 0.373565 11.1368 0.373565L11.1368 11.4506L11.1368 22.5276Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateColorBlind
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_603_2)"><path d="M9.33666 18.2036C14.1602 18.2036 18.0705 14.2933 18.0705 9.46972C18.0705 4.64614 14.1602 0.735851 9.33666 0.735851C4.51308 0.735851 0.60279 4.64614 0.60279 9.46972C0.60279 14.2933 4.51308 18.2036 9.33666 18.2036Z" stroke="black" stroke-width="0.919355" stroke-dasharray="1.84 1.84"/><path d="M9.33666 14.1487C11.9208 14.1487 14.0156 12.0538 14.0156 9.46972C14.0156 6.88562 11.9208 4.79079 9.33666 4.79079C6.75256 4.79079 4.65773 6.88562 4.65773 9.46972C4.65773 12.0538 6.75256 14.1487 9.33666 14.1487Z" stroke="black" stroke-width="0.919355"/><path d="M9.33666 10.5448C9.93043 10.5448 10.4118 10.0635 10.4118 9.46972C10.4118 8.87595 9.93043 8.39461 9.33666 8.39461C8.74289 8.39461 8.26155 8.87595 8.26155 9.46972C8.26155 10.0635 8.74289 10.5448 9.33666 10.5448Z" fill="black"/></g><defs><clipPath id="clip0_603_2"><rect width="19" height="19" fill="white"/></clipPath></defs></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateColorBlind:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="19" height="19" viewBox="0 0 31 31" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="15.2335" cy="15.4506" r="14.25" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="7.63405" stroke="white" stroke-width="1.5"/><circle cx="15.2335" cy="15.4506" r="1.75413" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#btnCreateComment
{
    padding-left:        3px;
    padding-right:       30px;
    background:          url('data:image/svg+xml;utf8,<svg width="18" height="16" viewBox="0 0 18 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5266L3.6897 11.0341C3.24801 10.1174 3 9.08908 3 8C3 4.13401 6.13401 1 10 1C13.866 1 17 4.13401 17 8C17 11.866 13.866 15 10 15C8.89526 15 7.85296 14.7448 6.92628 14.2911L6.65842 14.1599L6.36249 14.1969L1.94388 14.7492L3.64047 11.9923L3.92701 11.5266ZM0.671856 14.9082L0 16L1.27203 15.841L6.48652 15.1892C7.5471 15.7085 8.73951 16 10 16C14.4183 16 18 12.4183 18 8C18 3.58172 14.4183 0 10 0C5.58172 0 2 3.58172 2 8C2 9.24258 2.28329 10.419 2.78881 11.4682L0.671856 14.9082Z" fill="white" fill-opacity="1"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


#btnCreateComment:hover
{
    background:          url('data:image/svg+xml;utf8,<svg width="18" height="16" viewBox="0 0 18 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5266L3.6897 11.0341C3.24801 10.1174 3 9.08908 3 8C3 4.13401 6.13401 1 10 1C13.866 1 17 4.13401 17 8C17 11.866 13.866 15 10 15C8.89526 15 7.85296 14.7448 6.92628 14.2911L6.65842 14.1599L6.36249 14.1969L1.94388 14.7492L3.64047 11.9923L3.92701 11.5266ZM0.671856 14.9082L0 16L1.27203 15.841L6.48652 15.1892C7.5471 15.7085 8.73951 16 10 16C14.4183 16 18 12.4183 18 8C18 3.58172 14.4183 0 10 0C5.58172 0 2 3.58172 2 8C2 9.24258 2.28329 10.419 2.78881 11.4682L0.671856 14.9082Z" fill="white" fill-opacity="1"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    background-color:    black;
}


#zoomIconOverlay
{
    display:             block;
    position:            absolute;
    height:              20;
}


#groupName
{
    box-shadow: 0 0 0 1px red inset;
}


.figma-light .toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="black"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="black"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.figma-light .toggleButton:hover
{
    box-shadow: 0 0 0 1px #e6e6e6
}


.figma-light .toggleButton:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
}


.figma-dark .toggleButton
{
    position:            absolute;
    left:                16;
    transform:           translateX(-50%);
    width:               12;
    height:              12;
    background:          url('data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="white"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="white"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
    color:               #ddd;
    /* box-shadow:          0 0 0 1px red inset; */
    border-radius:       0.5px;
}


.figma-dark .toggleButton:hover
{
    box-shadow: 0 0 0 1px #777;
}


.figma-dark .toggleButton:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand);
}


.numberControl
{
    padding:          0;
    width:            74px;
    height:           20px;
    overflow:         hidden;
    background-color: var(--figma-color-bg);
    text-align:       center;
    touch-action:     none;
}    


.numberControlBar
{
    position:       absolute;
    pointer-events: none;
}


.numberControlText
{
    font-family:          Inter;
    font-size:            11px;
    font-variant-numeric: tabular-nums;
    letter-spacing:       -0.35px;
    pointer-events:       none;
    position:             absolute;
    left:                 50%;
    top:                  50%;
    transform:            translateX(-50%)
                          translateY(-50%);
    white-space:          nowrap;
    /* box-shadow:           0 0 0 1px inset yellow; */
}


.numberControlText .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
    /* box-shadow:           0 0 0 1px inset orange; */
}


.numberControlTextbox
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    /* width:                100%; */
    white-space:          nowrap;
    background-color:     transparent;
    z-index:              10;
    border-radius:        0.5px;
}


.textControlTextarea:focus
{
    outline: 2px solid var(--figma-color-bg-brand);
}


.numberControlExt
{
    display:             block;
    position:            absolute;
    top:                 50%;
    transform:           translateY(-50%);
    width:               1px;
    height:              10px;
    /* box-shadow:          0 0 0 1px red inset; */
    z-index:             1200;
}

.numberControlExtLeft  { left:  0px; }
.numberControlExtRight { right: 0px; }


/* .figma-light .numberControlExt
{
    background:          url('data:image/svg+xml;utf8,<svg width="1" height="15" viewBox="0 0 1 15" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="12" width="1" height="3" fill="#000"/><rect y="6" width="1" height="3" fill="#000"/><rect width="1" height="3" fill="#000"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}

.figma-dark .numberControlExt
{
    background:          url('data:image/svg+xml;utf8,');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
} */


.numberControlFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px var(--activeObjectColor) inset;
    visibility:     hidden;
    opacity:        0;
    z-index:        1100;
}


.numberControlRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}


.textControl
{
    padding:       0;
    /* width:      74px; */
    /* height:     20px; */
    overflow:      visible;
    text-align:    center;
    touch-action:  none;
    /* box-shadow:    0 0 0 1px orange inset; */
}    


.figma-dark .textControl
{
    background-color: rgba(56, 56, 56, 0.95);
}


.figma-light .textControl
{
    background-color: rgba(255, 255, 255, 0.95);
}


.textControlTextarea
{
    color:                var(--figma-color-text);

    font-family:          Inter;
    font-size:            11;
    position:             absolute;
    left:                 0px;
    top:                  0px;
    /* left:                 50%; */
    /* transform:            translateX(-50%); */
    width:                100%;
    background-color:     transparent;
    z-index:              5000;

    border:               none;
    overflow:             auto;
    outline:              none;

    -webkit-box-shadow:   none;
    -moz-box-shadow:      none;
    box-shadow:           none;

    resize:               none;
    cursor:               default;

    padding-top:          0.4em;
    padding-left:         0.4em;
    padding-right:        0.4em;

    border-radius:        0.5px;
    
    /* box-shadow:           0 0 0 1px inset red; */
}


.textControlTextarea:focus
{
    outline: 2px solid var(--figma-color-bg-brand);
}


.textControlTextarea:focus::placeholder 
{
    color: transparent;
}


.textControlTextarea::-webkit-scrollbar
{
    background:   transparent;
    width:        6px;
    /* box-shadow:   0 0 0 1px red inset; */
}


.textControlTextarea::-webkit-scrollbar-track
{
    border: 4px solid transparent;
    margin: 2px 0px 2px 0;
}


.textControlTextarea::-webkit-scrollbar-thumb
{
    background:     #fff4;
    border:         4px solid transparent;
    border-radius:  3px;
    cursor:         default;
    pointer-events: none;
}



.colorControl
{
    padding:          0;
    width:            74px;
    height:           26px;
    overflow:         hidden;
    /* background-color: var(--figma-color-bg); */
    text-align:       center;
    touch-action:     none;
}    


.figma-light .colorControlName
{
    color: #0006;
}


.figma-dark .colorControlName
{
    color: #fff6;
}


.colorControlBar
{
    position:       absolute;
    pointer-events: none;
}


.colorControlText
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    pointer-events:       none;
    letter-spacing:       -0.35px;
    text-align:           center;
    position:             relative;
    left:                 50%;
    transform:            translateX(-50%);
    top:                  4px;
    white-space:          nowrap;
    /* box-shadow:           0 0 0 1px inset yellow; */
}


.colorControlText .hash
{
    font-size: 6;
    position:  relative;
    top:      -2px;
}


.colorControlTextbox
{
    font-family:          Inter;
    font-size:            11;
    font-variant-numeric: tabular-nums;
    position:             absolute;
    left:                 50%;
    transform:            translateX(-50%);
    /* width:                100%; */
    white-space:          nowrap;
    letter-spacing:       -0.35px;
    border-radius:        0.5px;
    z-index:              10;
}


.colorControlTextbox:focus
{
    outline: 2px solid var(--figma-color-bg-brand);
}


.colorControlFocus
{
    position:       absolute;
    pointer-events: none;
    box-shadow:     0 0 0 1px var(--figma-color-bg-brand) inset;
    visibility:     hidden;
    opacity:        0;
}


.colorControlRange
{
    display:        block;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
}




.menuSelect
{
    font-family:         Inter;
    font-size:           14;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         1;
    margin-right:        6;
    margin-top:          0;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
    color:               white;
}


.menuSelect:hover
{
    /* box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1); */
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) calc(50% + 3px);
    background-repeat:   no-repeat;
    padding-right:       30;
    transition:          all 0.2s ease;
}


.menuSelect:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="white" /> </svg>');
    background-position: calc(100% - 14px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.menuSelectText
{
    font-family:    Inter;
    font-size:      11;
    pointer-events: none;
    position:       relative;
    top:            3px;
}


.menuSelectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px  7px rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2 );
    /* overflow:      hidden; */
}


.menuSelectMenu::after 
{
    content:       '';
    position:      absolute;
    top:           -10px;
    left:          65px;
    border-width:  5px;
    border-style:  solid;
    border-color:  transparent transparent #222 transparent;
}




.select
{
    font-family:         Inter;
    font-size:           11;
    vertical-align:      middle;
    padding-left:        6;
    padding-right:       30;
    padding-top:         2;
    margin-right:        6;
    margin-top:          1;
    height:              24px;
    line-height:         22px;
    border:              none;
    border-radius:       0.5px;
    overflow:            hidden;
    -webkit-appearance:  none;
    appearance:          none;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.4"/> </svg>');
    background-position: calc(100% - 17px) 50%;
    background-repeat:   no-repeat;
    display:             inline-block;
}


.select:hover
{
    box-shadow:          0 0 0 1px rgba(0, 0, 0, 0.1);
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 7px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
}


.select:focus
{
    padding-left:        6;
    background:          url('data:image/svg+xml;utf8,<svg width="8" height="8" viewBox="0 0 8 8" fill="none" xmlns="http://www.w3.org/2000/svg"> <path fill-rule="evenodd" clip-rule="evenodd" d="M3.64648 6.35359L0.646484 3.35359L1.35359 2.64648L4.00004 5.29293L6.64648 2.64648L7.35359 3.35359L4.35359 6.35359L4.00004 6.70714L3.64648 6.35359Z" fill="black" fill-opacity="0.8"/> </svg>');
    background-position: calc(100% - 6px) 50%;
    background-repeat:   no-repeat;
    padding-right:       30;
    box-shadow:          0 0 0 2px var(--activeObjectColor);
    outline:             none;
}


.selectMenu
{
    position:      absolute;
    width:         auto;
    height:        auto;
    color:         white;
    background:    #222;
    font-family:   Inter;
    font-size:     13;
    text-align:    center;
    outline:       0.5px solid rgba(0, 0, 0, 0.1);
    border-radius: 2px;
    box-shadow:    0px 2px 7px  rgba(0, 0, 0, 0.15),
                   0px 5px 17px rgba(0, 0, 0, 0.2);
    overflow:      hidden;
}


.button
{
    color:          var(--figma-color-text);
    background:     var(--figma-color-bg);

    font-size:      11px;
    text-align:     center;

    padding:        8px 14px;

    border-radius:  6px;
    box-shadow:     0 0 0 1px var(--figma-color-text) inset;
}


.button:active
{
    box-shadow: 0 0 0 2px var(--figma-color-bg-brand) inset;
}


.panelButton
{
    font-family:   Inter;
    font-size:     11px;
    width:         30;
    height:        30;
    background:    white;
    min-width:     0;
    min-height:    0;
    border:        none;
    border-radius: 2px;
    position:      relative;
    padding:       0;
    background:    var(--figma-color-bg);
}


.panelButton:hover
{
    background: var(--figma-color-bg-hover);
}


.panelButton:active
{
    box-shadow: 0 0 0 2px var(--activeObjectColor) inset;
    outline:    none;
}


.checkbox
{
    font-family: Inter;
    font-size:   11px;
    display:     inline-block;
    width:       auto;
    height:      24px;
}


.checkboxCheck
{
    display:       inline-block;
    width:         12px;
    height:        12px;
    border-radius: 2px;
    transform:     translateY(2px);
}


.checkboxText
{
    color:       var(--figma-color-text);
    display:     inline;
    width:       auto;
    height:      auto;
    margin-left: 10px;
}


.inputControls
{
    width:          12px;
    height:         auto;
    float:          left;
    margin-right:   auto;
    padding-top:    13px;
    /* box-shadow:     0 0 0 1px red inset; */
    pointer-events: none;
}


.input
{
    /* display:        inline; */
    width:          6px;
    height:         6px;
    background:     transparent;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    left:           3px;
    pointer-events: none;
    box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12);
    z-index:        10;
    transition:     opacity 0.2s linear 0s;
}


.inputBall
{
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    top:            50%;
    left:           50%;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.inputHitbox
{
    position:       relative;
    left:          -3px;
    top:           -3px;
    width:          12px;
    height:         12px;
    pointer-events: auto;
}


:root 
{
    --sizeBorderWidth: 4px;
    --defHeaderHeight: 25px;
    /* --cornerBack:      #0f08;
    --edgeBack:        #08f8; */
    --cornerBack:      none;
    --edgeBack:        none;
}


.node
{
    display:       none;
    position:      absolute;
    height:        auto;
    border-radius: 4px 4px 0 0;
    padding:       0;
    overflow:      visible;
 /* box-shadow:    0 0 0 1px yellow inset; */
}


.nodeInner
{
    display:       block;
    position:      relative;
    width:         100%;
    height:        auto;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    padding:       0;
    box-shadow:    0 0 0 1px var(--figma-color-bg-tertiary);
    overflow:      visible;
    /* box-shadow:    0 0 0 1px orange inset; */
}    


.nodeHeader
{
    background:   'magenta';
    display:       flex;
    width:         100%;
    position:      relative;
    border-radius: 4px 4px 0 0;
    z-index:       1;
 /* overflow:      visible; */
 /* box-shadow:    0 0 0 1px red inset; */
}


.nodeHeaderCheckersHolder
{
    display:       inline-block;
    width:         100%;
    height: 100%;
    position:      absolute;
    left:          0;
    top:           0; 
    z-index:       1;
    overflow:      hidden;
    border-radius: 4px 4px 0 0;
    pointer-events: none;
    /* box-shadow:    0 0 0 1px red inset; */
}


.nodeHeaderCheckers
{
    display:       inline-block;
    width:         100%;
    height: 100%;
    position:      absolute;
    left:          0;
    top:           0; 
    border-radius: 4px 4px 0 0;
    pointer-events: none;
    /* box-shadow:    0 0 0 1px blue inset; */
}


.nodeParamBack
{
    display:        flex;
    flex-direction: column;
    position:       relative;
    z-index:        2000;
    /* box-shadow:  0 0 0 1px green inset; */
}


.nodeHiddenParamBack
{
    display:     block;
    position:    absolute;
    width:       100%;
    background:  #fffe;
    z-index:    -1;
 /* box-shadow:  0 0 0 1px green inset; */
}


/* .paramSeparator
{
    display:    inline-block;
    width:      100%;
    height:     10;
    background: #fffe;
 /* box-shadow: 0 0 0 1px green inset;
} */


.nodeLabelWrapper
{
    position:   absolute;
    width:      100%;
    height:     100%;   
    overflow:   hidden;
 /* box-shadow: 0 0 0 1px blue inset; */
}


.nodeLabel
{
    padding:        0;
    margin:         0;
    display:        block;
    width:          auto;
    height:         auto;
    position:       absolute;
    pointer-events: none;
    z-index:        1000;
    white-space:    nowrap;
    font-weight:    600;
 /* box-shadow:     0 0 0 1px magenta inset; */
}


.nodeLabelText
{
    font-family:    Inter;
    font-size:      11px;
    padding:        0;
    margin:         0;
    display:        inline;
    width:          auto;
    height:         15px;
    text-align:     center;
    white-space:    nowrap;
    vertical-align: top;
    left:           50%;
    text-rendering: geometricPrecision;
 /* box-shadow:     0 0 0 1px orange inset; */
}


.nodeLabelTextbox
{
    font-family: Inter;
    font-size:   11;
 /* box-shadow:  0 0 0 1px #a0a inset; */
    overflow:    visible;
}


.nodeLabelTextbox::selection
{
    background-color: white;
}


.subscribeCover
{
    background: transparent;
    position:   absolute;
    left:       0;
    width:      100%;
    z-index:    100000;
    display:    none;
}



.subscribeLabel
{
    font-family:    Inter;
    font-size:      16px;
    font-weight:    700;
    color:          #e88b;
    position:       absolute;
    left:           50%;
    top:            50%;
    pointer-events: none;
    z-index:        100000;
    transform:      translateX(-50%)
                    translateY(-50%)
                    rotate(-45deg);
    display:        none;
}


.operatorSymbol
{
    font-family:    Inter;
    font-size:      20px;
    width:          auto;
    height:         auto;
    position:       absolute;
    left:           50%;
    transform:      translateX(-50%);
 /* box-shadow:     0 0 0 1px red inset; */
}


.colorWarningOverlay
{
    width:            100%;
    z-index:          10;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.colorValueWarningOverlay
{
    width:            100%;
    z-index:          50;
    position:         absolute;
    top:              0;
    height:           var(--colorBackSize);
    pointer-events:   none;
}


.colorBack
{
    width:            100%;
    /* height:           var(--colorBackSize); */
    z-index:          0;
    position:         absolute;
    top:              0;
    pointer-events:   none;
    border-radius:    4px 4px 0 0;
}


.txtOrder
{
    text-align:  center;
    width:       100%;
    background:  transparent;
    cursor:      default;
}


.txtOrder:hover
{
    box-shadow: 0  1px 0 0 rgba(0, 0, 0, 0.1) inset,
                0 -1px 0 0 rgba(0, 0, 0, 0.1) inset;
}


.findCorrectColorion
{
    display:             block;
    width:               10px;
    height:              10px;
    position:            absolute;
    left:                50%;
    top:                 50%;
    transform:           translateX(-50%)
                         translateY(-50%);
 /* box-shadow:          0 0 0 1 red inset; */
    background:          url('data:image/svg+xml;utf8,<svg width="10" height="10" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.10345 5.05172C8.10345 7.01329 6.51329 8.60345 4.55172 8.60345C2.59016 8.60345 1 7.01329 1 5.05172C1 3.09016 2.59016 1.5 4.55172 1.5C6.51329 1.5 8.10345 3.09016 8.10345 5.05172ZM7.39723 8.60458C6.61787 9.22958 5.62846 9.60345 4.55172 9.60345C2.03788 9.60345 0 7.56557 0 5.05172C0 2.53788 2.03788 0.5 4.55172 0.5C7.06557 0.5 9.10345 2.53788 9.10345 5.05172C9.10345 6.12858 8.72949 7.1181 8.10436 7.8975L11.3535 11.1467L10.6464 11.8538L7.39723 8.60458Z" fill="black" fill-opacity="0.8"/></svg>');
    background-position: 50% 50%;
    background-repeat:   no-repeat;
}


.progressWrapper
{
    position:      absolute;
    left:          0;
    top:           0;
    width:         100%;
    height:        6px;   
    background:    transparent;
 /* border-radius: 2.5px; */
    border-radius: 4px 4px 0 0;
    overflow:      hidden;
    display:       none;
}


.progressBar
{
    position:   absolute;
    left:       0;
    top:        0;
    width:      0;
    height:     5px;   
    background: var(--figma-color-bg-brand);
}


.asterisk
{
    font-size: 8px;
    position:  relative;
    top:       -2px;
}


.btnAnimatePlay
{
    width:          15px;
    height:         15px;
    margin-right:   6px;
    pointer-events: all;
}


.styleCircleWrapper
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    border-radius:   8px;
    margin-right:    7px;
    position:       relative;
    top:           -1px;
    pointer-events: all;
    overflow:       hidden;
}


.styleCircleBack
{
    width:          16px;
    height:         16px;
    pointer-events: none;
    position:       absolute;
    left:           0;
    top:            0;
}


.styleCircleCheckers
{
    width:          16px;
    height:         8px;
    pointer-events: none;
    position:       absolute;
    left:           0;
    top:            0;
    transform:      rotate(45deg);
    transform-origin: 50% 100%;
}


.styleCircle
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    position:       absolute;
    left:           0;
    top:            0;
}


.styleLink
{
    width:          16px;
    height:         16px;
    pointer-events: none;
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-50%)
                    translateY(-50%);
}    


.headerCircleWrapper
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    /* border-radius:   8px; */
    margin-right:    3px;
    position:       relative;
    top:           -1px;
    pointer-events: all;
    overflow:       hidden;
}


.headerCircleBack
{
    width:          16px;
    height:         16px;
    pointer-events: none;
    position:       absolute;
    left:           0;
    top:            0;
}


.headerCircle
{
    display:        inline-block;
    width:          16px;
    height:         16px;
    position:       absolute;
    left:           0;
    top:            0;
}


.headerIcon
{
    width:          14px;
    height:         14px;
    pointer-events: none;
    position:       absolute;
    left:           50%;
    top:            50%;
    transform:      translateX(-50%)
                    translateY(-50%);
}    


.reorderArrows
{
    width:    5px;
    height:   8px;
    position: absolute;
    left:     0;
    top:      0;
}


.colorblindSymbol
{
    position:  absolute;
    width:     26px;
    height:    26px;
    left:      50%;
    top:       33%;
    transform: translateX(-50%)
               translateY(-50%);
}


.colorblindRing
{
    position:  absolute;
    left:      50%;
    top:       50%;
    transform: translateX(-50%)
               translateY(-50%);
}


.sizerBox
{
    position:       absolute;
    left:           0;
    top:            0;
    width:          100%;
    height:         100%;    
    box-shadow:     0 0 0 1px red inset;
    z-index:        10000;
    pointer-events: none;
}


.sizerEdge
{
    position:   absolute;
    background: var(--edgeBack);
    z-index:    10000;
}


.sizerH
{
    top:    var(--defHeaderHeight);
    /* top:    var(--sizeBorderWidth); */
    /* height: calc(100% - calc(2 * var(--sizeBorderWidth))); */
    width:  var(--sizeBorderWidth);
    height: calc(100% - calc(25px + var(--sizeBorderWidth)));
    cursor: ew-resize;
}


.sizerL { left:  0; }
.sizerR { right: 0; }


.sizerV
{
    left:   var(--sizeBorderWidth);
    width:  calc(100% - calc(2 * var(--sizeBorderWidth)));
    height: var(--sizeBorderWidth);
    cursor: ns-resize;
}


.sizerT { top:    0; }
.sizerB { bottom: 0; }


.sizerCorner
{
    position:   absolute;
    width:      var(--sizeBorderWidth);
    height:     var(--sizeBorderWidth);
    background: var(--cornerBack);
    z-index:    10000;
}


.sizerTL
{
    left:   0;
    top:    0;
    cursor: nwse-resize;
}


.sizerTR
{
    right:  0;
    top:    0;
    cursor: nesw-resize;
}


.sizerBL
{
    left:   0;
    bottom: 0;
    cursor: nesw-resize;
}


.sizerBR
{
    right:  0;
    bottom: 0;
    cursor: nwse-resize;
}



.outputControls
{
    width:          12px;
    /* height:         auto; */
    float:          right;
    margin-left:    auto;
    padding-top:    10px;
    /* box-shadow:     0 0 0 1px green inset; */
    pointer-events: none;
}


.output
{
    /* display:        inline; */
    width:          6px;
    height:         6px;
    border-radius:  3px;
    margin:         0;
    position:       absolute;
    right:          3px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
    z-index:        10;
    transition:     opacity 0.2s linear 0s;
}


.outputBall
{
    width:          6px;
    height:         6px;
    border-radius:  6px;
    margin:         0;
    position:       relative;
    top:            -12px;
    pointer-events: none;
    /* box-shadow:     0 0 0 1px rgba(0, 0, 0, 0.12); */
}


.outputHitbox
{
    position: relative;
    left:    -3px;
    top:     -3px;
    width:    12px;
    height:   12px;
    pointer-events: auto;
}


</style>


<div id='menuBar'>
    <div id='pageName'>Page name</div>
</div>
<div id='pagesBar'>
    <div id='btnAddPage' class='page'>
        <svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path id='btnAddPlus' fill-rule="evenodd" clip-rule="evenodd" d="M6 0.5H4V4L0.5 4V6H4V9.5H6V6H9.5V4L6 4V0.5Z" fill="white"/>
        </svg>
    </div>
</div>


<div id='_graphView'></div>

<div id='selectBox'></div>


<div id='loadingOverlay'>
    <div id='loadingGraphic'>
        <svg id="loadingEmpty" width="8"  height="8"  viewBox="0 0 8 8"   fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4 7C5.65685 7 7 5.65685 7 4C7 2.34315 5.65685 1 4 1C2.34315 1 1 2.34315 1 4C1 5.65685 2.34315 7 4 7ZM8 4C8 6.20914 6.20914 8 4 8C1.79086 8 0 6.20914 0 4C0 1.79086 1.79086 0 4 0C6.20914 0 8 1.79086 8 4Z" fill="white"/></svg>
        <svg id="loadingG"     width="21" height="24" viewBox="0 0 21 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.4398 7.77947C16.2474 7.1635 15.9819 6.61217 15.6432 6.12548C15.3123 5.63118 14.912 5.20913 14.4426 4.85932C13.9808 4.50951 13.4497 4.24715 12.8494 4.07224C12.249 3.88973 11.5948 3.79848 10.8868 3.79848C9.61682 3.79848 8.48543 4.11407 7.49258 4.74525C6.49973 5.37643 5.71853 6.30418 5.14898 7.52852C4.58714 8.74525 4.30621 10.2281 4.30621 11.9772C4.30621 13.7414 4.58714 15.2357 5.14898 16.4601C5.71083 17.6844 6.49203 18.616 7.49258 19.2548C8.49313 19.8859 9.65531 20.2015 10.9791 20.2015C12.1798 20.2015 13.2188 19.9734 14.0962 19.5171C14.9813 19.0608 15.6625 18.4144 16.1396 17.5779C16.6168 16.7338 16.8554 15.7452 16.8554 14.6122L17.8252 14.7605H11.4063V11.4525H21V14.2586C21 16.2586 20.569 17.9886 19.707 19.4487C18.845 20.9087 17.6597 22.0342 16.1512 22.8251C14.6427 23.6084 12.9109 24 10.956 24C8.7779 24 6.86531 23.5171 5.21825 22.5513C3.57889 21.5779 2.29742 20.1977 1.37383 18.4106C0.457944 16.616 0 14.4867 0 12.0228C0 10.1369 0.269379 8.45247 0.808136 6.96958C1.35459 5.48669 2.11655 4.22814 3.09401 3.19392C4.07147 2.15209 5.21825 1.36122 6.53436 0.821293C7.85047 0.273764 9.28202 0 10.829 0C12.1374 0 13.3573 0.190114 14.4887 0.570342C15.6201 0.942966 16.6245 1.47529 17.5019 2.1673C18.387 2.85932 19.1143 3.68061 19.6839 4.63118C20.2534 5.58175 20.6267 6.63118 20.8037 7.77947H16.4398Z" fill="white"/></svg>
        <svg id="loadingFull"  width="8"  height="8"  viewBox="0 0 8 8"   fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 4C8 6.20914 6.20914 8 4 8C1.79086 8 0 6.20914 0 4C0 1.79086 1.79086 0 4 0C6.20914 0 8 1.79086 8 4Z" fill="white"/></svg>

        <div id='loadingBar'>
            <div id='loadingProgress'></div>
        </div>
    </div>
    <div class='btnRestart' id='btnLoadingRestart'>Restart in debug mode</div>
</div>


<div id='dataModeView'>

    <div class='dataModeRowWrapper' id='dataModeTitleBar'>
        <div class='btnRestart' id='btnDataModeRestart'>Restart in normal mode</div>
    </div>

    <div id='dataModeContent'>
        
        <div class='dataModeRowWrapper' id='dataModePagesWrapper'>
            <div id='dataModePagesTitle' class='dataModeRowTitle'>Pages</div>
            <div id='dataModePages'></div>
        </div>
        
        <div class='dataModeRowWrapper' id='dataModeNodesWrapper'>
            <div id='dataModeNodesTitle' class='dataModeRowTitle'>Nodes</div>
            <div id='dataModeNodes'></div>
        </div>
        
        <div class='dataModeRowWrapper' id='dataModeConnsWrapper'>
            <div id='dataModeConnsTitle' class='dataModeRowTitle'>Connections</div>
            <div id='dataModeConns'></div>
        </div>

    </div>        
</div>


<div id='debugInfo'></div>


<div id='productKeyBack'></div>

<div id='productKeyDialog'>

    <div id='productKeyTitle'>
        <div id='productKeyTitleText'>Subscription</div>
        <div class='panelButton dialogButtonClose' id='productKeyClose' onclick='hideAllMenus(); productKeyClose.blur(); hideProductKeyDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='productKeyBody'>
        <!-- <div id='productKeyUserName'></div> -->
        <div id='productKeyUserId' ondblclick='copyUserId()'></div>
        <div id='productKeyTextBack'></div>
        <div id='productKeyInputBack'></div>
        <input type='text' spellcheck='false' id='productKeyInput' />
        <div id='licenseWatermark'>
            <svg width="274" height="50" viewBox="0 0 274 50" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path id="licenseWatermarkPath" fill-rule="evenodd" clip-rule="evenodd" d="M18 0V0.00025571H18.4314V3.98255C18.9313 2.94209 19.6356 2.21476 20.5444 1.69453C22.2208 0.717641 24.3493 0.000246173 27.3998 0.000246173C30.3989 0.000246173 32.2677 0.873789 33.6026 2.17033V2.03249e-06H34H35.034H35.3974V3.32489C35.8745 2.28445 36.5902 1.4702 37.5445 0.88213C38.476 0.294047 39.5666 2.03249e-06 40.8163 2.03249e-06C41.8841 2.03249e-06 42.8498 0.214882 43.7132 0.644635C44.5766 1.07439 45.2727 1.73517 45.7378 2.44547C46.2029 3.15578 46.4577 4.16297 46.4546 5.06373C46.4515 5.9645 46.3361 7.01287 45.7223 7.93912C45.1084 8.86537 44.2012 9.78183 42.3374 10.4498C40.4736 11.1177 37.7945 11.1709 35.4314 10.3438V11.0117C35.4314 12.3084 35.7495 13.0325 36.3857 13.779C37.7253 15.3507 39.8684 15.7828 42.2395 15.7828C44.6106 15.7828 47.3548 15.0874 49.1712 13.2361C50.1028 12.2635 50.5686 11.0273 50.5686 9.42134L50.5686 0H52V0.00025571H52.4314V3.98255C52.9313 2.94209 53.6356 2.21476 54.5444 1.69453C56.2208 0.717641 58.3493 0.000246173 61.3998 0.000246173C64.3989 0.000246173 66.2677 0.873789 67.6026 2.17033V2.03249e-06H68H69.034H69.3974V3.32489C69.8745 2.28445 70.5902 1.4702 71.5445 0.88213C72.476 0.294047 73.5666 2.03249e-06 74.8163 2.03249e-06C75.8841 2.03249e-06 76.8498 0.214882 77.7132 0.644635C78.5766 1.07439 79.2727 1.73517 79.7378 2.44547C80.2029 3.15578 80.4577 4.16297 80.4546 5.06373C80.4515 5.9645 80.3361 7.01287 79.7223 7.93912C79.1084 8.86537 78.2012 9.78183 76.3374 10.4498C74.4736 11.1177 71.7945 11.1709 69.4314 10.3438V11.0117C69.4314 12.3084 69.7495 13.0325 70.3857 13.779C71.7253 15.3507 73.8684 15.7828 76.2395 15.7828C78.6106 15.7828 81.3548 15.0874 83.1712 13.2361C84.1028 12.2635 84.5686 11.0273 84.5686 9.42134V0H86V0.00025571H86.4314V3.98255C86.9313 2.94209 87.6356 2.21476 88.5444 1.69453C90.2208 0.717641 92.3493 0.000246173 95.3998 0.000246173C98.3989 0.000246173 100.268 0.873789 101.603 2.17033V2.03249e-06H102H103.034H103.397V3.32489C103.874 2.28445 104.59 1.4702 105.544 0.88213C106.476 0.294047 107.567 2.03249e-06 108.816 2.03249e-06C109.884 2.03249e-06 110.85 0.214882 111.713 0.644635C112.577 1.07439 113.273 1.73517 113.738 2.44547C114.203 3.15578 114.458 4.16297 114.455 5.06373C114.451 5.9645 114.336 7.01287 113.722 7.93912C113.108 8.86537 112.201 9.78183 110.337 10.4498C108.474 11.1177 105.794 11.1709 103.431 10.3438V11.0117C103.431 12.3084 103.75 13.0325 104.386 13.779C105.725 15.3507 107.868 15.7828 110.24 15.7828C112.611 15.7828 115.355 15.0874 117.171 13.2361C118.103 12.2635 118.569 11.0273 118.569 9.42134V0H120V0.00025571H120.431V3.98255C120.931 2.94209 121.636 2.21476 122.544 1.69453C124.221 0.717641 126.349 0.000246173 129.4 0.000246173C132.399 0.000246173 134.268 0.873789 135.603 2.17033V2.03249e-06H136H137.034H137.397V3.32489C137.874 2.28445 138.59 1.4702 139.544 0.88213C140.476 0.294047 141.567 2.03249e-06 142.816 2.03249e-06C143.884 2.03249e-06 144.85 0.214882 145.713 0.644635C146.577 1.07439 147.273 1.73517 147.738 2.44547C148.203 3.15578 148.458 4.16297 148.455 5.06373C148.451 5.9645 148.336 7.01287 147.722 7.93912C147.108 8.86537 146.201 9.78183 144.337 10.4498C142.474 11.1177 139.794 11.1709 137.431 10.3438V11.0117C137.431 12.3084 137.75 13.0325 138.386 13.779C139.725 15.3507 141.868 15.7828 144.24 15.7828C146.611 15.7828 149.355 15.0874 151.171 13.2361C152.103 12.2635 152.569 11.0273 152.569 9.42134V0H154V0.00025571H154.431V3.98255C154.931 2.94209 155.636 2.21476 156.544 1.69453C158.221 0.717641 160.349 0.000246173 163.4 0.000246173C166.399 0.000246173 168.268 0.873789 169.603 2.17033V2.03249e-06H170H171.034H171.397V3.32489C171.874 2.28445 172.59 1.4702 173.544 0.88213C174.476 0.294047 175.567 2.03249e-06 176.816 2.03249e-06C177.884 2.03249e-06 178.85 0.214882 179.713 0.644635C180.577 1.07439 181.273 1.73517 181.738 2.44547C182.203 3.15578 182.458 4.16297 182.455 5.06373C182.451 5.9645 182.336 7.01287 181.722 7.93912C181.108 8.86537 180.201 9.78183 178.337 10.4498C176.474 11.1177 173.794 11.1709 171.431 10.3438V11.0117C171.431 12.3084 171.75 13.0325 172.386 13.779C173.725 15.3507 175.868 15.7828 178.24 15.7828C180.611 15.7828 183.355 15.0874 185.171 13.2361C186.103 12.2635 186.569 11.0273 186.569 9.42134V0H188V0.00025571H188.431V3.98255C188.931 2.94209 189.636 2.21476 190.544 1.69453C192.221 0.717641 194.349 0.000246173 197.4 0.000246173C200.399 0.000246173 202.268 0.873789 203.603 2.17033V2.03249e-06H204H205.034H205.397V3.32489C205.874 2.28445 206.59 1.4702 207.544 0.88213C208.476 0.294047 209.567 2.03249e-06 210.816 2.03249e-06C211.884 2.03249e-06 212.85 0.214882 213.713 0.644635C214.577 1.07439 215.273 1.73517 215.738 2.44547C216.203 3.15578 216.458 4.16297 216.455 5.06373C216.451 5.9645 216.336 7.01287 215.722 7.93912C215.108 8.86537 214.201 9.78183 212.337 10.4498C210.474 11.1177 207.794 11.1709 205.431 10.3438V11.0117C205.431 12.3084 205.75 13.0325 206.386 13.779C207.725 15.3507 209.868 15.7828 212.24 15.7828C214.611 15.7828 217.355 15.0874 219.171 13.2361C220.103 12.2635 220.569 11.0273 220.569 9.42134V0H222V0.00025571H222.431V3.98255C222.931 2.94209 223.636 2.21476 224.544 1.69453C226.221 0.717641 228.349 0.000246173 231.4 0.000246173C234.399 0.000246173 236.268 0.873789 237.603 2.17033V2.03249e-06H238H239.034H239.397V3.32489C239.874 2.28445 240.59 1.4702 241.544 0.88213C242.476 0.294047 243.567 2.03249e-06 244.816 2.03249e-06C245.884 2.03249e-06 246.85 0.214882 247.713 0.644635C248.577 1.07439 249.273 1.73517 249.738 2.44547C250.203 3.15578 250.458 4.16297 250.455 5.06373C250.451 5.9645 250.336 7.01287 249.722 7.93912C249.108 8.86537 248.201 9.78183 246.337 10.4498C244.474 11.1177 241.794 11.1709 239.431 10.3438V11.0117C239.431 12.3084 239.75 13.0325 240.386 13.779C241.725 15.3507 243.868 15.7828 246.24 15.7828C248.611 15.7828 251.355 15.0874 253.171 13.2361C254.103 12.2635 254.569 11.0273 254.569 9.42134V0H256V0.00025571H256.431V3.98255C256.931 2.94209 257.636 2.21476 258.544 1.69453C260.221 0.717641 262.349 0.000246173 265.4 0.000246173C268.399 0.000246173 270.268 0.873789 271.603 2.17033V2.03249e-06H273.034V6.70541L273.034 6.73069V16.7288L273.034 39.7054L273.034 39.7307V49.7288L273.034 50H271.637V46.6754C271.16 47.7158 270.444 48.53 269.49 49.1181C268.558 49.7062 267.467 50.0002 266.218 50.0002C265.15 50.0002 264.184 49.7854 263.321 49.3556C262.457 48.9259 261.761 48.2651 261.296 47.5548C260.831 46.8445 260.576 45.8373 260.579 44.9365C260.583 44.0357 260.698 42.9874 261.312 42.0611C261.926 41.1349 262.833 40.2184 264.697 39.5505C266.56 38.8825 269.24 38.8294 271.603 39.6565V38.9885C271.603 37.6919 271.285 36.9677 270.648 36.2213C269.309 34.6495 267.166 34.2174 264.795 34.2174C262.423 34.2174 259.679 34.9128 257.863 36.7641C256.931 37.7367 256.465 38.973 256.465 40.5789L256.431 50.0002H255V50H254.603V46.0177C254.103 47.0581 253.398 47.7855 252.49 48.3057C250.813 49.2826 248.685 50 245.634 50C242.635 50 240.766 49.1264 239.431 47.8299V50H239.034H238H237.637V46.6754C237.16 47.7158 236.444 48.53 235.49 49.1181C234.558 49.7062 233.467 50.0002 232.218 50.0002C231.15 50.0002 230.184 49.7854 229.321 49.3556C228.457 48.9259 227.761 48.2651 227.296 47.5548C226.831 46.8445 226.576 45.8373 226.579 44.9365C226.583 44.0357 226.698 42.9874 227.312 42.0611C227.926 41.1349 228.833 40.2184 230.697 39.5505C232.56 38.8825 235.24 38.8294 237.603 39.6565V38.9885C237.603 37.6919 237.285 36.9677 236.648 36.2213C235.309 34.6495 233.166 34.2174 230.795 34.2174C228.423 34.2174 225.679 34.9128 223.863 36.7641C222.931 37.7367 222.465 38.973 222.465 40.5789L222.431 50.0002H221V50H220.603V46.0177C220.103 47.0581 219.398 47.7855 218.49 48.3057C216.813 49.2826 214.685 50 211.634 50C208.635 50 206.766 49.1264 205.431 47.8299V50H205.034H204H203.637V46.6754C203.16 47.7158 202.444 48.53 201.49 49.1181C200.558 49.7062 199.467 50.0002 198.218 50.0002C197.15 50.0002 196.184 49.7854 195.321 49.3556C194.457 48.9259 193.761 48.2651 193.296 47.5548C192.831 46.8445 192.576 45.8373 192.579 44.9365C192.583 44.0357 192.698 42.9874 193.312 42.0611C193.926 41.1349 194.833 40.2184 196.697 39.5505C198.56 38.8825 201.24 38.8294 203.603 39.6565V38.9885C203.603 37.6919 203.285 36.9677 202.648 36.2213C201.309 34.6495 199.166 34.2174 196.795 34.2174C194.423 34.2174 191.679 34.9128 189.863 36.7641C188.931 37.7367 188.465 38.973 188.465 40.5789L188.431 50.0002H187V50H186.603V46.0177C186.103 47.0581 185.398 47.7855 184.49 48.3057C182.813 49.2826 180.685 50 177.634 50C174.635 50 172.766 49.1264 171.431 47.8299V50H171.034H170H169.637V46.6754C169.16 47.7158 168.444 48.53 167.49 49.1181C166.558 49.7062 165.467 50.0002 164.218 50.0002C163.15 50.0002 162.184 49.7854 161.321 49.3556C160.457 48.9259 159.761 48.2651 159.296 47.5548C158.831 46.8445 158.576 45.8373 158.579 44.9365C158.583 44.0357 158.698 42.9874 159.312 42.0611C159.926 41.1349 160.833 40.2184 162.697 39.5505C164.56 38.8825 167.24 38.8294 169.603 39.6565V38.9885C169.603 37.6919 169.285 36.9677 168.648 36.2213C167.309 34.6495 165.166 34.2174 162.795 34.2174C160.423 34.2174 157.679 34.9128 155.863 36.7641C154.931 37.7367 154.465 38.973 154.465 40.5789L154.431 50.0002H153V50H152.603V46.0177C152.103 47.0581 151.398 47.7855 150.49 48.3057C148.813 49.2826 146.685 50 143.634 50C140.635 50 138.766 49.1264 137.431 47.8299V50H137.034H136H135.637V46.6754C135.16 47.7158 134.444 48.53 133.49 49.1181C132.558 49.7062 131.467 50.0002 130.218 50.0002C129.15 50.0002 128.184 49.7854 127.321 49.3556C126.457 48.9259 125.761 48.2651 125.296 47.5548C124.831 46.8445 124.576 45.8373 124.579 44.9365C124.583 44.0357 124.698 42.9874 125.312 42.0611C125.926 41.1349 126.833 40.2184 128.697 39.5505C130.56 38.8825 133.24 38.8294 135.603 39.6565V38.9885C135.603 37.6919 135.285 36.9677 134.648 36.2213C133.309 34.6495 131.166 34.2174 128.795 34.2174C126.423 34.2174 123.679 34.9128 121.863 36.7641C120.931 37.7367 120.465 38.973 120.465 40.5789L120.431 50.0002H119V50H118.603V46.0177C118.103 47.0581 117.398 47.7855 116.49 48.3057C114.813 49.2826 112.685 50 109.634 50C106.635 50 104.766 49.1264 103.431 47.8299L103.431 50H103.034H102H101.637V46.6754C101.16 47.7158 100.444 48.53 99.4896 49.1181C98.558 49.7062 97.4674 50.0002 96.2178 50.0002C95.1499 50.0002 94.1843 49.7854 93.3209 49.3556C92.4575 48.9259 91.7614 48.2651 91.2963 47.5548C90.8312 46.8445 90.5763 45.8373 90.5795 44.9365C90.5826 44.0357 90.6979 42.9874 91.3118 42.0611C91.9256 41.1349 92.8328 40.2184 94.6967 39.5505C96.5605 38.8825 99.2396 38.8294 101.603 39.6565V38.9885C101.603 37.6919 101.285 36.9677 100.648 36.2213C99.3087 34.6495 97.1656 34.2174 94.7945 34.2174C92.4234 34.2174 89.6793 34.9128 87.8628 36.7641C86.9313 37.7367 86.4655 38.973 86.4655 40.5789L86.4314 50.0002H85V50H84.6027V46.0177C84.1028 47.0581 83.3984 47.7855 82.4896 48.3057C80.8132 49.2826 78.6847 50 75.6342 50C72.6351 50 70.7664 49.1264 69.4314 47.8299L69.4314 50H69.034H68H67.6367V46.6754C67.1596 47.7158 66.4439 48.53 65.4896 49.1181C64.558 49.7062 63.4674 50.0002 62.2178 50.0002C61.1499 50.0002 60.1843 49.7854 59.3209 49.3556C58.4575 48.9259 57.7614 48.2651 57.2963 47.5548C56.8312 46.8445 56.5763 45.8373 56.5795 44.9365C56.5826 44.0357 56.6979 42.9874 57.3118 42.0611C57.9256 41.1349 58.8328 40.2184 60.6967 39.5505C62.5605 38.8825 65.2396 38.8294 67.6026 39.6565V38.9885C67.6026 37.6919 67.2846 36.9677 66.6484 36.2213C65.3087 34.6495 63.1656 34.2174 60.7945 34.2174C58.4234 34.2174 55.6793 34.9128 53.8628 36.7641C52.9313 37.7367 52.4655 38.973 52.4655 40.5789L52.4314 50.0002H51V50H50.6027V46.0177C50.1028 47.0581 49.3984 47.7855 48.4896 48.3057C46.8132 49.2826 44.6847 50 41.6342 50C38.6351 50 36.7664 49.1264 35.4314 47.8299V50H35.034H34H33.6367V46.6754C33.1596 47.7158 32.4439 48.53 31.4896 49.1181C30.558 49.7062 29.4674 50.0002 28.2178 50.0002C27.1499 50.0002 26.1843 49.7854 25.3209 49.3556C24.4575 48.9259 23.7614 48.2651 23.2963 47.5548C22.8312 46.8445 22.5763 45.8373 22.5795 44.9365C22.5826 44.0357 22.6979 42.9874 23.3118 42.0611C23.9256 41.1349 24.8328 40.2184 26.6967 39.5505C28.5605 38.8825 31.2396 38.8294 33.6026 39.6565V38.9885C33.6026 37.6919 33.2845 36.9677 32.6484 36.2213C31.3087 34.6495 29.1656 34.2174 26.7945 34.2174C24.4234 34.2174 21.6793 34.9128 19.8628 36.7641C18.9313 37.7367 18.4655 38.973 18.4655 40.5789L18.4314 50.0002H17V50H16.6027V46.0177C16.1028 47.0581 15.3984 47.7855 14.4896 48.3057C12.8132 49.2826 10.6847 50 7.63421 50C4.63511 50 2.76638 49.1264 1.43142 47.8299L1.43141 50H0L3.09273e-06 43.2788L0 43.2695V33.2714L1.58907e-05 10.2906L0 10.2695V2.03249e-06H1.39734H1.39736L1.39736 3.32489C1.8745 2.28445 2.5902 1.4702 3.54446 0.88213C4.47601 0.294047 5.56661 2.03249e-06 6.81626 2.03249e-06C7.88414 2.03249e-06 8.84978 0.214882 9.71317 0.644635C10.5766 1.07439 11.2727 1.73517 11.7378 2.44547C12.2029 3.15578 12.4577 4.16297 12.4546 5.06373C12.4515 5.9645 12.3361 7.01287 11.7223 7.93912C11.1084 8.86537 10.2012 9.78183 8.3374 10.4498C6.47358 11.1177 3.79448 11.1709 1.43142 10.3438L1.43142 11.0117C1.43142 12.3084 1.74951 13.0325 2.38569 13.779C3.72535 15.3507 5.86841 15.7828 8.23951 15.7828C10.6106 15.7828 13.3548 15.0874 15.1712 13.2361C16.1028 12.2635 16.5686 11.0273 16.5686 9.42134L16.5686 0H18ZM14.4896 15.3057C15.378 14.7972 16.071 14.0908 16.5686 13.0875V19.1701C15.2336 17.8735 13.3649 17 10.3658 17C7.3153 17 5.1868 17.7174 3.5104 18.6943C2.60156 19.2145 1.89722 19.9418 1.39736 20.9823V14.7966C2.73457 16.1115 4.60952 17 7.63421 17C10.6847 17 12.8132 16.2826 14.4896 15.3057ZM3.98752 2.03567C4.76003 1.53807 5.66886 1.28926 6.71402 1.28926C8.00911 1.28926 9.08875 1.58369 9.93374 2.33796C10.7787 3.09222 11.0466 4.00773 11.0466 5.09342C11.0466 5.97554 10.8464 6.66179 10.3309 7.44717C9.81542 8.23254 8.96151 8.85094 7.45128 9.33017C5.94106 9.8094 3.48534 9.89497 1.43142 9.08843L1.43142 7.8331C1.43142 6.72479 1.65863 4.9874 2.11304 4.10527C2.56746 3.24577 3.19229 2.5559 3.98752 2.03567ZM4.92928 5.3413C4.92928 4.60936 5.52532 4.016 6.26058 4.016C6.99584 4.016 7.59188 4.60936 7.59188 5.3413C7.59188 6.07325 6.99583 6.66661 6.26058 6.66661C5.52532 6.66661 4.92928 6.07325 4.92928 5.3413ZM1.43142 40.8235L1.43142 40.8331L1.43142 42.0884C3.48534 42.895 5.94106 42.8094 7.45128 42.3302C8.96151 41.8509 9.81542 41.2325 10.3309 40.4472C10.8464 39.6618 11.0466 38.9755 11.0466 38.0934C11.0466 37.0077 10.7787 36.0922 9.93374 35.338C9.08875 34.5837 8.00911 34.2893 6.71402 34.2893C5.66886 34.2893 4.76003 34.5381 3.98752 35.0357C3.19229 35.5559 2.56746 36.2458 2.11304 37.1053C1.65994 37.9848 1.43273 39.7148 1.43142 40.8235ZM1.43142 43.3438L1.43142 44.0117L1.43142 44.0188C1.43257 45.311 1.75066 46.0339 2.38569 46.7789C3.72535 48.3507 5.86841 48.7828 8.23951 48.7828C10.6106 48.7828 13.3548 48.0874 15.1712 46.2361C16.1028 45.2635 16.5686 44.0273 16.5686 42.4213V30.6751C16.0914 31.7155 15.4098 32.5298 14.4556 33.1179C13.524 33.7059 12.4334 34 11.1838 34C10.8548 34 10.5356 33.9796 10.2261 33.9388C10.8542 34.3494 11.3688 34.8819 11.7378 35.4455C12.2029 36.1558 12.4577 37.163 12.4546 38.0637C12.4515 38.9645 12.3361 40.0129 11.7223 40.9391C11.1084 41.8654 10.2012 42.7818 8.3374 43.4498C6.47358 44.1177 3.79448 44.1708 1.43142 43.3438ZM7.77389 33.0612C7.46438 33.0204 7.14517 33 6.81626 33C5.56661 33 4.47601 33.294 3.54446 33.8821C2.61265 34.4564 1.9083 35.2463 1.43143 36.2518L1.43144 24.5787C1.43144 22.9727 1.89722 21.7365 2.82877 20.7639C4.64523 18.9126 7.3894 18.2172 9.7605 18.2172C12.1316 18.2172 14.2747 18.6493 15.6143 20.221C16.2476 20.964 16.5657 21.685 16.5686 22.9705V23.6562C14.2055 22.8291 11.5264 22.8823 9.66261 23.5502C7.79879 24.2182 6.89159 25.1346 6.27774 26.0609C5.66388 26.9871 5.54855 28.0355 5.54542 28.9363C5.5423 29.837 5.7971 30.8442 6.26221 31.5545C6.63126 32.1181 7.14578 32.6506 7.77389 33.0612ZM16.5686 24.9116C14.5147 24.105 12.0589 24.1906 10.5487 24.6698C9.0385 25.1491 8.1846 25.7675 7.66912 26.5528C7.15364 27.3382 6.95341 28.0245 6.95341 28.9066C6.95341 29.9923 7.22129 30.9078 8.06628 31.662C8.91127 32.4163 9.9909 32.7107 11.286 32.7107C12.3312 32.7107 13.24 32.4619 14.0125 31.9643C14.8077 31.4441 15.4325 30.7542 15.887 29.8947C16.3389 29.0174 16.5661 27.2941 16.5686 26.1851V24.9116ZM18.4314 36.9825V31.7966C19.4013 32.7503 20.6541 33.4797 22.4233 33.8084C21.7328 34.0621 21.1127 34.3634 20.5444 34.6945C19.6356 35.2148 18.9313 35.9421 18.4314 36.9825ZM33.6367 35.2036C32.6668 34.25 31.414 33.5206 29.6448 33.1918C30.3353 32.9381 30.9554 32.6368 31.5237 32.3057C32.4325 31.7855 33.1368 31.0581 33.6367 30.0177V35.2036ZM20.5785 17.8821C19.6242 18.4702 18.9085 19.2845 18.4314 20.3249V17.0002V17L18.4655 7.57889C18.4655 5.97297 18.9313 4.73673 19.8628 3.76413C21.6793 1.91279 24.4234 1.21742 26.7945 1.21742C29.1656 1.21742 31.3087 1.64951 32.6484 3.22129C33.2817 3.96437 33.5998 4.68541 33.6026 5.97118L33.6026 6.65648C31.2396 5.82939 28.5605 5.88249 26.6967 6.55045C24.8328 7.2184 23.9256 8.13487 23.3118 9.06112C22.6979 9.98737 22.5826 11.0357 22.5795 11.9365C22.5763 12.8373 22.8312 13.8445 23.2963 14.5548C23.7614 15.2651 24.4575 15.9259 25.3209 16.3556C26.1843 16.7854 27.1499 17.0002 28.2178 17.0002C29.4674 17.0002 30.558 16.7062 31.4896 16.1181C32.4214 15.5439 33.1257 14.754 33.6026 13.7484V26.4213C33.6026 28.0273 33.1368 29.2635 32.2053 30.2361C30.3888 32.0874 27.6447 32.7828 25.2736 32.7828C22.9025 32.7828 20.7594 32.3507 19.4197 30.7789C18.7836 30.0325 18.4655 29.3084 18.4655 28.0117V27.3438C20.8285 28.1708 23.5076 28.1177 25.3714 27.4498C27.2353 26.7818 28.1425 25.8654 28.7563 24.9391C29.3702 24.0129 29.4855 22.9645 29.4886 22.0637C29.4918 21.163 29.237 20.1558 28.7719 19.4455C28.3067 18.7352 27.6106 18.0744 26.7472 17.6446C25.8838 17.2149 24.9182 17 23.8503 17C22.6007 17 21.5101 17.294 20.5785 17.8821ZM27.5828 7.67007C29.093 7.19084 31.5487 7.10527 33.6026 7.91181L33.6026 9.18475C33.6002 10.2938 33.373 12.0175 32.921 12.895C32.4666 13.7545 31.8418 14.4443 31.0465 14.9646C30.274 15.4622 29.3652 15.711 28.32 15.711C27.025 15.711 25.9453 15.4165 25.1003 14.6623C24.2553 13.908 23.9875 12.9925 23.9875 11.9068C23.9875 11.0247 24.1877 10.3384 24.7032 9.55307C25.2186 8.7677 26.0725 8.1493 27.5828 7.67007ZM13.0707 28.6587C13.0707 29.3906 12.4747 29.984 11.7394 29.984C11.0042 29.984 10.4081 29.3906 10.4081 28.6587C10.4081 27.9267 11.0042 27.3334 11.7394 27.3334C12.4747 27.3334 13.0707 27.9267 13.0707 28.6587ZM31.0465 47.9646C30.274 48.4622 29.3652 48.711 28.32 48.711C27.025 48.711 25.9453 48.4165 25.1003 47.6623C24.2553 46.908 23.9875 45.9925 23.9875 44.9068C23.9875 44.0247 24.1877 43.3385 24.7032 42.5531C25.2186 41.7677 26.0725 41.1493 27.5828 40.6701C29.093 40.1908 31.5487 40.1053 33.6026 40.9118V42.1671C33.6026 43.2755 33.3754 45.0128 32.921 45.895C32.4666 46.7545 31.8418 47.4443 31.0465 47.9646ZM30.1048 44.6589C30.1048 45.3909 29.5087 45.9842 28.7735 45.9842C28.0382 45.9842 27.4422 45.3909 27.4422 44.6589C27.4422 43.927 28.0382 43.3336 28.7735 43.3336C29.5087 43.3336 30.1048 43.927 30.1048 44.6589ZM28.7735 12.9842C29.5087 12.9842 30.1048 12.3909 30.1048 11.6589C30.1048 10.927 29.5087 10.3336 28.7735 10.3336C28.0382 10.3336 27.4422 10.927 27.4422 11.6589C27.4422 12.3909 28.0382 12.9842 28.7735 12.9842ZM21.0216 19.0357C21.7941 18.5381 22.7029 18.2893 23.7481 18.2893C25.0432 18.2893 26.1228 18.5837 26.9678 19.338C27.8128 20.0922 28.0807 21.0077 28.0807 22.0934C28.0806 22.9755 27.8804 23.6618 27.3649 24.4472C26.8495 25.2325 25.9956 25.8509 24.4853 26.3302C22.9751 26.8094 20.5194 26.895 18.4655 26.0884V24.8331C18.4655 23.7248 18.6927 21.9874 19.1471 21.1053C19.6015 20.2458 20.2263 19.5559 21.0216 19.0357ZM21.9633 22.3413C21.9633 21.6094 22.5594 21.016 23.2946 21.016C24.0299 21.016 24.6259 21.6094 24.6259 22.3413C24.6259 23.0732 24.0299 23.6666 23.2946 23.6666C22.5594 23.6666 21.9633 23.0732 21.9633 22.3413ZM6.26058 37.016C5.52532 37.016 4.92928 37.6094 4.92928 38.3413C4.92928 39.0732 5.52532 39.6666 6.26058 39.6666C6.99583 39.6666 7.59188 39.0732 7.59188 38.3413C7.59188 37.6094 6.99584 37.016 6.26058 37.016ZM150.49 15.3057C151.378 14.7972 152.071 14.0908 152.569 13.0875V19.1701C151.234 17.8735 149.365 17 146.366 17C143.315 17 141.187 17.7174 139.51 18.6943C138.602 19.2145 137.897 19.9418 137.397 20.9823V14.7966C138.735 16.1115 140.61 17 143.634 17C146.685 17 148.813 16.2826 150.49 15.3057ZM139.988 2.03567C140.76 1.53807 141.669 1.28926 142.714 1.28926C144.009 1.28926 145.089 1.58369 145.934 2.33796C146.779 3.09222 147.047 4.00773 147.047 5.09342C147.047 5.97554 146.846 6.66179 146.331 7.44717C145.815 8.23254 144.962 8.85094 143.451 9.33017C141.941 9.8094 139.485 9.89497 137.431 9.08843V7.8331C137.431 6.72479 137.659 4.9874 138.113 4.10527C138.567 3.24577 139.192 2.5559 139.988 2.03567ZM140.929 5.3413C140.929 4.60936 141.525 4.016 142.261 4.016C142.996 4.016 143.592 4.60936 143.592 5.3413C143.592 6.07325 142.996 6.66661 142.261 6.66661C141.525 6.66661 140.929 6.07325 140.929 5.3413ZM137.431 40.8235L137.431 40.8331V42.0884C139.485 42.895 141.941 42.8094 143.451 42.3302C144.962 41.8509 145.815 41.2325 146.331 40.4472C146.846 39.6618 147.047 38.9755 147.047 38.0934C147.047 37.0077 146.779 36.0922 145.934 35.338C145.089 34.5837 144.009 34.2893 142.714 34.2893C141.669 34.2893 140.76 34.5381 139.988 35.0357C139.192 35.5559 138.567 36.2458 138.113 37.1053C137.66 37.9848 137.433 39.7148 137.431 40.8235ZM137.431 43.3438V44.0117L137.431 44.0188C137.433 45.311 137.751 46.0339 138.386 46.7789C139.725 48.3507 141.868 48.7828 144.24 48.7828C146.611 48.7828 149.355 48.0874 151.171 46.2361C152.103 45.2635 152.569 44.0273 152.569 42.4213V30.6751C152.091 31.7155 151.41 32.5298 150.456 33.1179C149.524 33.7059 148.433 34 147.184 34C146.855 34 146.536 33.9796 146.226 33.9388C146.854 34.3494 147.369 34.8819 147.738 35.4455C148.203 36.1558 148.458 37.163 148.455 38.0637C148.451 38.9645 148.336 40.0129 147.722 40.9391C147.108 41.8654 146.201 42.7818 144.337 43.4498C142.474 44.1177 139.794 44.1708 137.431 43.3438ZM143.774 33.0612C143.464 33.0204 143.145 33 142.816 33C141.567 33 140.476 33.294 139.544 33.8821C138.613 34.4564 137.908 35.2463 137.431 36.2518L137.431 24.5787C137.431 22.9727 137.897 21.7365 138.829 20.7639C140.645 18.9126 143.389 18.2172 145.76 18.2172C148.132 18.2172 150.275 18.6493 151.614 20.221C152.248 20.964 152.566 21.685 152.569 22.9705V23.6562C150.206 22.8291 147.526 22.8823 145.663 23.5502C143.799 24.2182 142.892 25.1346 142.278 26.0609C141.664 26.9871 141.549 28.0355 141.545 28.9363C141.542 29.837 141.797 30.8442 142.262 31.5545C142.631 32.1181 143.146 32.6506 143.774 33.0612ZM152.569 24.9116C150.515 24.105 148.059 24.1906 146.549 24.6698C145.038 25.1491 144.185 25.7675 143.669 26.5528C143.154 27.3382 142.953 28.0245 142.953 28.9066C142.953 29.9923 143.221 30.9078 144.066 31.662C144.911 32.4163 145.991 32.7107 147.286 32.7107C148.331 32.7107 149.24 32.4619 150.012 31.9643C150.808 31.4441 151.433 30.7542 151.887 29.8947C152.339 29.0174 152.566 27.2941 152.569 26.1851V24.9116ZM154.431 36.9825V31.7966C155.401 32.7503 156.654 33.4797 158.423 33.8084C157.733 34.0621 157.113 34.3634 156.544 34.6945C155.636 35.2148 154.931 35.9421 154.431 36.9825ZM169.637 35.2036C168.667 34.25 167.414 33.5206 165.645 33.1918C166.335 32.9381 166.955 32.6368 167.524 32.3057C168.432 31.7855 169.137 31.0581 169.637 30.0177V35.2036ZM156.579 17.8821C155.624 18.4702 154.909 19.2845 154.431 20.3249V17.0002V17L154.465 7.57889C154.465 5.97297 154.931 4.73673 155.863 3.76413C157.679 1.91279 160.423 1.21742 162.795 1.21742C165.166 1.21742 167.309 1.64951 168.648 3.22129C169.282 3.96437 169.6 4.68541 169.603 5.97118L169.603 6.65648C167.24 5.82939 164.56 5.88249 162.697 6.55045C160.833 7.2184 159.926 8.13487 159.312 9.06112C158.698 9.98737 158.583 11.0357 158.579 11.9365C158.576 12.8373 158.831 13.8445 159.296 14.5548C159.761 15.2651 160.457 15.9259 161.321 16.3556C162.184 16.7854 163.15 17.0002 164.218 17.0002C165.467 17.0002 166.558 16.7062 167.49 16.1181C168.421 15.5439 169.126 14.754 169.603 13.7484V26.4213C169.603 28.0273 169.137 29.2635 168.205 30.2361C166.389 32.0874 163.645 32.7828 161.274 32.7828C158.902 32.7828 156.759 32.3507 155.42 30.7789C154.784 30.0325 154.465 29.3084 154.465 28.0117V27.3438C156.829 28.1708 159.508 28.1177 161.371 27.4498C163.235 26.7818 164.142 25.8654 164.756 24.9391C165.37 24.0129 165.486 22.9645 165.489 22.0637C165.492 21.163 165.237 20.1558 164.772 19.4455C164.307 18.7352 163.611 18.0744 162.747 17.6446C161.884 17.2149 160.918 17 159.85 17C158.601 17 157.51 17.294 156.579 17.8821ZM163.583 7.67007C165.093 7.19084 167.549 7.10527 169.603 7.91181L169.603 9.18475C169.6 10.2938 169.373 12.0175 168.921 12.895C168.467 13.7545 167.842 14.4443 167.047 14.9646C166.274 15.4622 165.365 15.711 164.32 15.711C163.025 15.711 161.945 15.4165 161.1 14.6623C160.255 13.908 159.987 12.9925 159.987 11.9068C159.987 11.0247 160.188 10.3384 160.703 9.55307C161.219 8.7677 162.073 8.1493 163.583 7.67007ZM149.071 28.6587C149.071 29.3906 148.475 29.984 147.739 29.984C147.004 29.984 146.408 29.3906 146.408 28.6587C146.408 27.9267 147.004 27.3334 147.739 27.3334C148.475 27.3334 149.071 27.9267 149.071 28.6587ZM167.047 47.9646C166.274 48.4622 165.365 48.711 164.32 48.711C163.025 48.711 161.945 48.4165 161.1 47.6623C160.255 46.908 159.987 45.9925 159.987 44.9068C159.987 44.0247 160.188 43.3385 160.703 42.5531C161.219 41.7677 162.073 41.1493 163.583 40.6701C165.093 40.1908 167.549 40.1053 169.603 40.9118V42.1671C169.603 43.2755 169.375 45.0128 168.921 45.895C168.467 46.7545 167.842 47.4443 167.047 47.9646ZM166.105 44.6589C166.105 45.3909 165.509 45.9842 164.773 45.9842C164.038 45.9842 163.442 45.3909 163.442 44.6589C163.442 43.927 164.038 43.3336 164.773 43.3336C165.509 43.3336 166.105 43.927 166.105 44.6589ZM164.773 12.9842C165.509 12.9842 166.105 12.3909 166.105 11.6589C166.105 10.927 165.509 10.3336 164.773 10.3336C164.038 10.3336 163.442 10.927 163.442 11.6589C163.442 12.3909 164.038 12.9842 164.773 12.9842ZM157.022 19.0357C157.794 18.5381 158.703 18.2893 159.748 18.2893C161.043 18.2893 162.123 18.5837 162.968 19.338C163.813 20.0922 164.081 21.0077 164.081 22.0934C164.081 22.9755 163.88 23.6618 163.365 24.4472C162.849 25.2325 161.996 25.8509 160.485 26.3302C158.975 26.8094 156.519 26.895 154.465 26.0884V24.8331C154.465 23.7248 154.693 21.9874 155.147 21.1053C155.602 20.2458 156.226 19.5559 157.022 19.0357ZM157.963 22.3413C157.963 21.6094 158.559 21.016 159.295 21.016C160.03 21.016 160.626 21.6094 160.626 22.3413C160.626 23.0732 160.03 23.6666 159.295 23.6666C158.559 23.6666 157.963 23.0732 157.963 22.3413ZM142.261 37.016C141.525 37.016 140.929 37.6094 140.929 38.3413C140.929 39.0732 141.525 39.6666 142.261 39.6666C142.996 39.6666 143.592 39.0732 143.592 38.3413C143.592 37.6094 142.996 37.016 142.261 37.016ZM84.5686 13.0875C84.071 14.0908 83.378 14.7972 82.4896 15.3057C80.8132 16.2826 78.6847 17 75.6342 17C72.6095 17 70.7346 16.1115 69.3974 14.7966V20.9823C69.8972 19.9418 70.6016 19.2145 71.5104 18.6943C73.1868 17.7174 75.3153 17 78.3658 17C81.3649 17 83.2336 17.8735 84.5686 19.1701V13.0875ZM74.714 1.28926C73.6689 1.28926 72.76 1.53807 71.9875 2.03567C71.1923 2.5559 70.5675 3.24577 70.113 4.10527C69.6586 4.9874 69.4314 6.72479 69.4314 7.8331V9.08843C71.4853 9.89497 73.9411 9.8094 75.4513 9.33017C76.9615 8.85094 77.8154 8.23254 78.3309 7.44717C78.8464 6.66179 79.0466 5.97554 79.0466 5.09342C79.0466 4.00773 78.7787 3.09222 77.9337 2.33796C77.0887 1.58369 76.0091 1.28926 74.714 1.28926ZM74.2606 4.016C73.5253 4.016 72.9293 4.60936 72.9293 5.3413C72.9293 6.07325 73.5253 6.66661 74.2606 6.66661C74.9958 6.66661 75.5919 6.07325 75.5919 5.3413C75.5919 4.60936 74.9958 4.016 74.2606 4.016ZM69.4314 40.8331V40.8235C69.4327 39.7148 69.6599 37.9848 70.113 37.1053C70.5675 36.2458 71.1923 35.5559 71.9875 35.0357C72.76 34.5381 73.6689 34.2893 74.714 34.2893C76.0091 34.2893 77.0887 34.5837 77.9337 35.338C78.7787 36.0922 79.0466 37.0077 79.0466 38.0934C79.0466 38.9755 78.8464 39.6618 78.3309 40.4472C77.8154 41.2325 76.9615 41.8509 75.4513 42.3302C73.9411 42.8094 71.4853 42.895 69.4314 42.0884V40.8331ZM69.4314 44.0117V43.3438C71.7945 44.1708 74.4736 44.1177 76.3374 43.4498C78.2012 42.7818 79.1084 41.8654 79.7223 40.9391C80.3361 40.0129 80.4515 38.9645 80.4546 38.0637C80.4577 37.163 80.2029 36.1558 79.7378 35.4455C79.3688 34.8819 78.8542 34.3494 78.2261 33.9388C78.5356 33.9796 78.8548 34 79.1838 34C80.4334 34 81.524 33.7059 82.4556 33.1179C83.4098 32.5298 84.0914 31.7155 84.5686 30.6751V42.4213C84.5686 44.0273 84.1028 45.2635 83.1712 46.2361C81.3548 48.0874 78.6106 48.7828 76.2395 48.7828C73.8684 48.7828 71.7253 48.3507 70.3857 46.7789C69.7507 46.0339 69.4326 45.311 69.4314 44.0188V44.0117ZM74.8163 33C75.1452 33 75.4644 33.0204 75.7739 33.0612C75.1458 32.6506 74.6313 32.1181 74.2622 31.5545C73.7971 30.8442 73.5423 29.837 73.5454 28.9363C73.5485 28.0355 73.6639 26.9871 74.2777 26.0609C74.8916 25.1346 75.7988 24.2182 77.6626 23.5502C79.5264 22.8823 82.2055 22.8291 84.5686 23.6562V22.9705C84.5657 21.685 84.2476 20.964 83.6143 20.221C82.2747 18.6493 80.1316 18.2172 77.7605 18.2172C75.3894 18.2172 72.6452 18.9126 70.8288 20.7639C69.8972 21.7365 69.4314 22.9727 69.4314 24.5787L69.4314 36.2518C69.9083 35.2463 70.6126 34.4564 71.5445 33.8821C72.476 33.294 73.5666 33 74.8163 33ZM78.5487 24.6698C80.059 24.1906 82.5147 24.105 84.5686 24.9116V26.1851C84.5661 27.2941 84.3389 29.0174 83.887 29.8947C83.4325 30.7542 82.8077 31.4441 82.0125 31.9643C81.24 32.4619 80.3312 32.7107 79.286 32.7107C77.9909 32.7107 76.9113 32.4163 76.0663 31.662C75.2213 30.9078 74.9534 29.9923 74.9534 28.9066C74.9534 28.0245 75.1536 27.3382 75.6691 26.5528C76.1846 25.7675 77.0385 25.1491 78.5487 24.6698ZM86.4314 31.7966V36.9825C86.9313 35.9421 87.6356 35.2148 88.5444 34.6945C89.1127 34.3634 89.7328 34.0621 90.4233 33.8084C88.6541 33.4797 87.4013 32.7503 86.4314 31.7966ZM97.6449 33.1918C99.414 33.5206 100.667 34.25 101.637 35.2036V30.0177C101.137 31.0581 100.432 31.7855 99.5237 32.3057C98.9554 32.6368 98.3353 32.9381 97.6449 33.1918ZM86.4314 20.3249C86.9085 19.2845 87.6242 18.4702 88.5785 17.8821C89.5101 17.294 90.6007 17 91.8503 17C92.9182 17 93.8838 17.2149 94.7472 17.6446C95.6106 18.0744 96.3067 18.7352 96.7719 19.4455C97.237 20.1558 97.4918 21.163 97.4886 22.0637C97.4855 22.9645 97.3702 24.0129 96.7563 24.9391C96.1425 25.8654 95.2353 26.7818 93.3714 27.4498C91.5076 28.1177 88.8285 28.1708 86.4655 27.3438V28.0117C86.4655 29.3084 86.7836 30.0325 87.4197 30.7789C88.7594 32.3507 90.9025 32.7828 93.2736 32.7828C95.6447 32.7828 98.3888 32.0874 100.205 30.2361C101.137 29.2635 101.603 28.0273 101.603 26.4213V13.7484C101.126 14.754 100.421 15.5439 99.4896 16.1181C98.558 16.7062 97.4674 17.0002 96.2178 17.0002C95.1499 17.0002 94.1843 16.7854 93.3209 16.3556C92.4575 15.9259 91.7614 15.2651 91.2963 14.5548C90.8312 13.8445 90.5763 12.8373 90.5795 11.9365C90.5826 11.0357 90.6979 9.98737 91.3118 9.06112C91.9256 8.13487 92.8328 7.2184 94.6967 6.55045C96.5605 5.88249 99.2396 5.82939 101.603 6.65648L101.603 5.97118C101.6 4.68541 101.282 3.96437 100.648 3.22129C99.3087 1.64951 97.1656 1.21742 94.7945 1.21742C92.4234 1.21742 89.6793 1.91279 87.8628 3.76413C86.9313 4.73673 86.4655 5.97297 86.4655 7.57889L86.4314 17V17.0002V20.3249ZM101.603 7.91181C99.5487 7.10527 97.093 7.19084 95.5828 7.67007C94.0725 8.1493 93.2186 8.7677 92.7032 9.55307C92.1877 10.3384 91.9875 11.0247 91.9875 11.9068C91.9875 12.9925 92.2553 13.908 93.1003 14.6623C93.9453 15.4165 95.0249 15.711 96.32 15.711C97.3652 15.711 98.274 15.4622 99.0465 14.9646C99.8418 14.4443 100.467 13.7545 100.921 12.895C101.373 12.0175 101.6 10.2938 101.603 9.18475L101.603 7.91181ZM79.7394 29.984C80.4747 29.984 81.0707 29.3906 81.0707 28.6587C81.0707 27.9267 80.4747 27.3334 79.7394 27.3334C79.0042 27.3334 78.4081 27.9267 78.4081 28.6587C78.4081 29.3906 79.0042 29.984 79.7394 29.984ZM96.32 48.711C97.3652 48.711 98.274 48.4622 99.0465 47.9646C99.8418 47.4443 100.467 46.7545 100.921 45.895C101.375 45.0128 101.603 43.2755 101.603 42.1671V40.9118C99.5487 40.1053 97.093 40.1908 95.5828 40.6701C94.0725 41.1493 93.2186 41.7677 92.7032 42.5531C92.1877 43.3385 91.9875 44.0247 91.9875 44.9068C91.9875 45.9925 92.2553 46.908 93.1003 47.6623C93.9453 48.4165 95.0249 48.711 96.32 48.711ZM96.7735 45.9842C97.5087 45.9842 98.1048 45.3909 98.1048 44.6589C98.1048 43.927 97.5087 43.3336 96.7735 43.3336C96.0382 43.3336 95.4422 43.927 95.4422 44.6589C95.4422 45.3909 96.0382 45.9842 96.7735 45.9842ZM98.1048 11.6589C98.1048 12.3909 97.5087 12.9842 96.7735 12.9842C96.0382 12.9842 95.4422 12.3909 95.4422 11.6589C95.4422 10.927 96.0382 10.3336 96.7735 10.3336C97.5087 10.3336 98.1048 10.927 98.1048 11.6589ZM91.7481 18.2893C90.7029 18.2893 89.7941 18.5381 89.0216 19.0357C88.2263 19.5559 87.6015 20.2458 87.1471 21.1053C86.6927 21.9874 86.4655 23.7248 86.4655 24.8331V26.0884C88.5194 26.895 90.9751 26.8094 92.4853 26.3302C93.9956 25.8509 94.8495 25.2325 95.3649 24.4472C95.8804 23.6618 96.0807 22.9755 96.0807 22.0934C96.0807 21.0077 95.8128 20.0922 94.9678 19.338C94.1228 18.5837 93.0432 18.2893 91.7481 18.2893ZM91.2946 21.016C90.5594 21.016 89.9633 21.6094 89.9633 22.3413C89.9633 23.0732 90.5594 23.6666 91.2946 23.6666C92.0299 23.6666 92.6259 23.0732 92.6259 22.3413C92.6259 21.6094 92.0299 21.016 91.2946 21.016ZM72.9293 38.3413C72.9293 37.6094 73.5253 37.016 74.2606 37.016C74.9958 37.016 75.5919 37.6094 75.5919 38.3413C75.5919 39.0732 74.9958 39.6666 74.2606 39.6666C73.5253 39.6666 72.9293 39.0732 72.9293 38.3413ZM218.49 15.3057C219.378 14.7972 220.071 14.0908 220.569 13.0875V19.1701C219.234 17.8735 217.365 17 214.366 17C211.315 17 209.187 17.7174 207.51 18.6943C206.602 19.2145 205.897 19.9418 205.397 20.9823V14.7966C206.735 16.1115 208.61 17 211.634 17C214.685 17 216.813 16.2826 218.49 15.3057ZM207.988 2.03567C208.76 1.53807 209.669 1.28926 210.714 1.28926C212.009 1.28926 213.089 1.58369 213.934 2.33796C214.779 3.09222 215.047 4.00773 215.047 5.09342C215.047 5.97554 214.846 6.66179 214.331 7.44717C213.815 8.23254 212.962 8.85094 211.451 9.33017C209.941 9.8094 207.485 9.89497 205.431 9.08843V7.8331C205.431 6.72479 205.659 4.9874 206.113 4.10527C206.567 3.24577 207.192 2.5559 207.988 2.03567ZM208.929 5.3413C208.929 4.60936 209.525 4.016 210.261 4.016C210.996 4.016 211.592 4.60936 211.592 5.3413C211.592 6.07325 210.996 6.66661 210.261 6.66661C209.525 6.66661 208.929 6.07325 208.929 5.3413ZM205.431 40.8235L205.431 40.8331V42.0884C207.485 42.895 209.941 42.8094 211.451 42.3302C212.962 41.8509 213.815 41.2325 214.331 40.4472C214.846 39.6618 215.047 38.9755 215.047 38.0934C215.047 37.0077 214.779 36.0922 213.934 35.338C213.089 34.5837 212.009 34.2893 210.714 34.2893C209.669 34.2893 208.76 34.5381 207.988 35.0357C207.192 35.5559 206.567 36.2458 206.113 37.1053C205.66 37.9848 205.433 39.7148 205.431 40.8235ZM205.431 43.3438V44.0117L205.431 44.0188C205.433 45.311 205.751 46.0339 206.386 46.7789C207.725 48.3507 209.868 48.7828 212.24 48.7828C214.611 48.7828 217.355 48.0874 219.171 46.2361C220.103 45.2635 220.569 44.0273 220.569 42.4213V30.6751C220.091 31.7155 219.41 32.5298 218.456 33.1179C217.524 33.7059 216.433 34 215.184 34C214.855 34 214.536 33.9796 214.226 33.9388C214.854 34.3494 215.369 34.8819 215.738 35.4455C216.203 36.1558 216.458 37.163 216.455 38.0637C216.451 38.9645 216.336 40.0129 215.722 40.9391C215.108 41.8654 214.201 42.7818 212.337 43.4498C210.474 44.1177 207.794 44.1708 205.431 43.3438ZM211.774 33.0612C211.464 33.0204 211.145 33 210.816 33C209.567 33 208.476 33.294 207.544 33.8821C206.613 34.4564 205.908 35.2463 205.431 36.2518L205.431 24.5787C205.431 22.9727 205.897 21.7365 206.829 20.7639C208.645 18.9126 211.389 18.2172 213.76 18.2172C216.132 18.2172 218.275 18.6493 219.614 20.221C220.248 20.964 220.566 21.685 220.569 22.9705V23.6562C218.206 22.8291 215.526 22.8823 213.663 23.5502C211.799 24.2182 210.892 25.1346 210.278 26.0609C209.664 26.9871 209.549 28.0355 209.545 28.9363C209.542 29.837 209.797 30.8442 210.262 31.5545C210.631 32.1181 211.146 32.6506 211.774 33.0612ZM220.569 24.9116C218.515 24.105 216.059 24.1906 214.549 24.6698C213.038 25.1491 212.185 25.7675 211.669 26.5528C211.154 27.3382 210.953 28.0245 210.953 28.9066C210.953 29.9923 211.221 30.9078 212.066 31.662C212.911 32.4163 213.991 32.7107 215.286 32.7107C216.331 32.7107 217.24 32.4619 218.012 31.9643C218.808 31.4441 219.433 30.7542 219.887 29.8947C220.339 29.0174 220.566 27.2941 220.569 26.1851V24.9116ZM222.431 36.9825V31.7966C223.401 32.7503 224.654 33.4797 226.423 33.8084C225.733 34.0621 225.113 34.3634 224.544 34.6945C223.636 35.2148 222.931 35.9421 222.431 36.9825ZM237.637 35.2036C236.667 34.25 235.414 33.5206 233.645 33.1918C234.335 32.9381 234.955 32.6368 235.524 32.3057C236.432 31.7855 237.137 31.0581 237.637 30.0177V35.2036ZM224.579 17.8821C223.624 18.4702 222.909 19.2845 222.431 20.3249V17.0002V17L222.465 7.57889C222.465 5.97297 222.931 4.73673 223.863 3.76413C225.679 1.91279 228.423 1.21742 230.795 1.21742C233.166 1.21742 235.309 1.64951 236.648 3.22129C237.282 3.96437 237.6 4.68541 237.603 5.97118L237.603 6.65648C235.24 5.82939 232.56 5.88249 230.697 6.55045C228.833 7.2184 227.926 8.13487 227.312 9.06112C226.698 9.98737 226.583 11.0357 226.579 11.9365C226.576 12.8373 226.831 13.8445 227.296 14.5548C227.761 15.2651 228.457 15.9259 229.321 16.3556C230.184 16.7854 231.15 17.0002 232.218 17.0002C233.467 17.0002 234.558 16.7062 235.49 16.1181C236.421 15.5439 237.126 14.754 237.603 13.7484V26.4213C237.603 28.0273 237.137 29.2635 236.205 30.2361C234.389 32.0874 231.645 32.7828 229.274 32.7828C226.902 32.7828 224.759 32.3507 223.42 30.7789C222.784 30.0325 222.465 29.3084 222.465 28.0117V27.3438C224.829 28.1708 227.508 28.1177 229.371 27.4498C231.235 26.7818 232.142 25.8654 232.756 24.9391C233.37 24.0129 233.486 22.9645 233.489 22.0637C233.492 21.163 233.237 20.1558 232.772 19.4455C232.307 18.7352 231.611 18.0744 230.747 17.6446C229.884 17.2149 228.918 17 227.85 17C226.601 17 225.51 17.294 224.579 17.8821ZM231.583 7.67007C233.093 7.19084 235.549 7.10527 237.603 7.91181L237.603 9.18475C237.6 10.2938 237.373 12.0175 236.921 12.895C236.467 13.7545 235.842 14.4443 235.047 14.9646C234.274 15.4622 233.365 15.711 232.32 15.711C231.025 15.711 229.945 15.4165 229.1 14.6623C228.255 13.908 227.987 12.9925 227.987 11.9068C227.987 11.0247 228.188 10.3384 228.703 9.55307C229.219 8.7677 230.073 8.1493 231.583 7.67007ZM217.071 28.6587C217.071 29.3906 216.475 29.984 215.739 29.984C215.004 29.984 214.408 29.3906 214.408 28.6587C214.408 27.9267 215.004 27.3334 215.739 27.3334C216.475 27.3334 217.071 27.9267 217.071 28.6587ZM235.047 47.9646C234.274 48.4622 233.365 48.711 232.32 48.711C231.025 48.711 229.945 48.4165 229.1 47.6623C228.255 46.908 227.987 45.9925 227.987 44.9068C227.987 44.0247 228.188 43.3385 228.703 42.5531C229.219 41.7677 230.073 41.1493 231.583 40.6701C233.093 40.1908 235.549 40.1053 237.603 40.9118V42.1671C237.603 43.2755 237.375 45.0128 236.921 45.895C236.467 46.7545 235.842 47.4443 235.047 47.9646ZM234.105 44.6589C234.105 45.3909 233.509 45.9842 232.773 45.9842C232.038 45.9842 231.442 45.3909 231.442 44.6589C231.442 43.927 232.038 43.3336 232.773 43.3336C233.509 43.3336 234.105 43.927 234.105 44.6589ZM232.773 12.9842C233.509 12.9842 234.105 12.3909 234.105 11.6589C234.105 10.927 233.509 10.3336 232.773 10.3336C232.038 10.3336 231.442 10.927 231.442 11.6589C231.442 12.3909 232.038 12.9842 232.773 12.9842ZM225.022 19.0357C225.794 18.5381 226.703 18.2893 227.748 18.2893C229.043 18.2893 230.123 18.5837 230.968 19.338C231.813 20.0922 232.081 21.0077 232.081 22.0934C232.081 22.9755 231.88 23.6618 231.365 24.4472C230.849 25.2325 229.996 25.8509 228.485 26.3302C226.975 26.8094 224.519 26.895 222.465 26.0884V24.8331C222.465 23.7248 222.693 21.9874 223.147 21.1053C223.602 20.2458 224.226 19.5559 225.022 19.0357ZM225.963 22.3413C225.963 21.6094 226.559 21.016 227.295 21.016C228.03 21.016 228.626 21.6094 228.626 22.3413C228.626 23.0732 228.03 23.6666 227.295 23.6666C226.559 23.6666 225.963 23.0732 225.963 22.3413ZM210.261 37.016C209.525 37.016 208.929 37.6094 208.929 38.3413C208.929 39.0732 209.525 39.6666 210.261 39.6666C210.996 39.6666 211.592 39.0732 211.592 38.3413C211.592 37.6094 210.996 37.016 210.261 37.016ZM50.5686 13.0875C50.071 14.0908 49.378 14.7972 48.4896 15.3057C46.8132 16.2826 44.6847 17 41.6342 17C38.6095 17 36.7346 16.1115 35.3974 14.7966V20.9823C35.8972 19.9418 36.6016 19.2145 37.5104 18.6943C39.1868 17.7174 41.3153 17 44.3658 17C47.3649 17 49.2336 17.8735 50.5686 19.1701V13.0875ZM40.714 1.28926C39.6689 1.28926 38.76 1.53807 37.9875 2.03567C37.1923 2.5559 36.5675 3.24577 36.113 4.10527C35.6586 4.9874 35.4314 6.72479 35.4314 7.8331V9.08843C37.4853 9.89497 39.9411 9.8094 41.4513 9.33017C42.9615 8.85094 43.8154 8.23254 44.3309 7.44717C44.8464 6.66179 45.0466 5.97554 45.0466 5.09342C45.0466 4.00773 44.7787 3.09222 43.9337 2.33796C43.0887 1.58369 42.0091 1.28926 40.714 1.28926ZM40.2606 4.016C39.5253 4.016 38.9293 4.60936 38.9293 5.3413C38.9293 6.07325 39.5253 6.66661 40.2606 6.66661C40.9958 6.66661 41.5919 6.07325 41.5919 5.3413C41.5919 4.60936 40.9958 4.016 40.2606 4.016ZM35.4314 40.8331L35.4314 40.8235C35.4327 39.7148 35.6599 37.9848 36.113 37.1053C36.5675 36.2458 37.1923 35.5559 37.9875 35.0357C38.76 34.5381 39.6689 34.2893 40.714 34.2893C42.0091 34.2893 43.0887 34.5837 43.9337 35.338C44.7787 36.0922 45.0466 37.0077 45.0466 38.0934C45.0466 38.9755 44.8464 39.6618 44.3309 40.4472C43.8154 41.2325 42.9615 41.8509 41.4513 42.3302C39.9411 42.8094 37.4853 42.895 35.4314 42.0884V40.8331ZM35.4314 44.0117V43.3438C37.7945 44.1708 40.4736 44.1177 42.3374 43.4498C44.2012 42.7818 45.1084 41.8654 45.7223 40.9391C46.3361 40.0129 46.4515 38.9645 46.4546 38.0637C46.4577 37.163 46.2029 36.1558 45.7378 35.4455C45.3688 34.8819 44.8542 34.3494 44.2261 33.9388C44.5356 33.9796 44.8548 34 45.1838 34C46.4334 34 47.524 33.7059 48.4556 33.1179C49.4098 32.5298 50.0914 31.7155 50.5686 30.6751V42.4213C50.5686 44.0273 50.1028 45.2635 49.1712 46.2361C47.3548 48.0874 44.6106 48.7828 42.2395 48.7828C39.8684 48.7828 37.7253 48.3507 36.3857 46.7789C35.7507 46.0339 35.4326 45.311 35.4314 44.0188L35.4314 44.0117ZM40.8163 33C41.1452 33 41.4644 33.0204 41.7739 33.0612C41.1458 32.6506 40.6313 32.1181 40.2622 31.5545C39.7971 30.8442 39.5423 29.837 39.5454 28.9363C39.5485 28.0355 39.6639 26.9871 40.2777 26.0609C40.8916 25.1346 41.7988 24.2182 43.6626 23.5502C45.5264 22.8823 48.2055 22.8291 50.5686 23.6562V22.9705C50.5657 21.685 50.2476 20.964 49.6143 20.221C48.2747 18.6493 46.1316 18.2172 43.7605 18.2172C41.3894 18.2172 38.6452 18.9126 36.8288 20.7639C35.8972 21.7365 35.4314 22.9727 35.4314 24.5787L35.4314 36.2518C35.9083 35.2463 36.6126 34.4564 37.5445 33.8821C38.476 33.294 39.5666 33 40.8163 33ZM44.5487 24.6698C46.0589 24.1906 48.5147 24.105 50.5686 24.9116V26.1851C50.5661 27.2941 50.3389 29.0174 49.887 29.8947C49.4325 30.7542 48.8077 31.4441 48.0125 31.9643C47.24 32.4619 46.3312 32.7107 45.286 32.7107C43.9909 32.7107 42.9113 32.4163 42.0663 31.662C41.2213 30.9078 40.9534 29.9923 40.9534 28.9066C40.9534 28.0245 41.1536 27.3382 41.6691 26.5528C42.1846 25.7675 43.0385 25.1491 44.5487 24.6698ZM52.4314 31.7966V36.9825C52.9313 35.9421 53.6356 35.2148 54.5444 34.6945C55.1127 34.3634 55.7328 34.0621 56.4233 33.8084C54.6541 33.4797 53.4013 32.7503 52.4314 31.7966ZM63.6448 33.1918C65.414 33.5206 66.6668 34.25 67.6367 35.2036V30.0177C67.1368 31.0581 66.4325 31.7855 65.5237 32.3057C64.9554 32.6368 64.3353 32.9381 63.6448 33.1918ZM52.4314 20.3249C52.9085 19.2845 53.6242 18.4702 54.5785 17.8821C55.5101 17.294 56.6007 17 57.8503 17C58.9182 17 59.8838 17.2149 60.7472 17.6446C61.6106 18.0744 62.3067 18.7352 62.7719 19.4455C63.237 20.1558 63.4918 21.163 63.4886 22.0637C63.4855 22.9645 63.3702 24.0129 62.7563 24.9391C62.1425 25.8654 61.2353 26.7818 59.3714 27.4498C57.5076 28.1177 54.8285 28.1708 52.4655 27.3438V28.0117C52.4655 29.3084 52.7836 30.0325 53.4197 30.7789C54.7594 32.3507 56.9025 32.7828 59.2736 32.7828C61.6447 32.7828 64.3888 32.0874 66.2053 30.2361C67.1368 29.2635 67.6026 28.0273 67.6026 26.4213V13.7484C67.1257 14.754 66.4214 15.5439 65.4896 16.1181C64.558 16.7062 63.4674 17.0002 62.2178 17.0002C61.1499 17.0002 60.1843 16.7854 59.3209 16.3556C58.4575 15.9259 57.7614 15.2651 57.2963 14.5548C56.8312 13.8445 56.5763 12.8373 56.5795 11.9365C56.5826 11.0357 56.6979 9.98737 57.3118 9.06112C57.9256 8.13487 58.8328 7.2184 60.6967 6.55045C62.5605 5.88249 65.2396 5.82939 67.6026 6.65648L67.6026 5.97118C67.5998 4.68541 67.2817 3.96437 66.6484 3.22129C65.3087 1.64951 63.1656 1.21742 60.7945 1.21742C58.4234 1.21742 55.6793 1.91279 53.8628 3.76413C52.9313 4.73673 52.4655 5.97297 52.4655 7.57889L52.4314 17V17.0002V20.3249ZM67.6026 7.91181C65.5487 7.10527 63.093 7.19084 61.5828 7.67007C60.0725 8.1493 59.2186 8.7677 58.7032 9.55307C58.1877 10.3384 57.9875 11.0247 57.9875 11.9068C57.9875 12.9925 58.2553 13.908 59.1003 14.6623C59.9453 15.4165 61.025 15.711 62.32 15.711C63.3652 15.711 64.274 15.4622 65.0465 14.9646C65.8418 14.4443 66.4666 13.7545 66.921 12.895C67.373 12.0175 67.6002 10.2938 67.6026 9.18475L67.6026 7.91181ZM45.7394 29.984C46.4747 29.984 47.0707 29.3906 47.0707 28.6587C47.0707 27.9267 46.4747 27.3334 45.7394 27.3334C45.0042 27.3334 44.4081 27.9267 44.4081 28.6587C44.4081 29.3906 45.0042 29.984 45.7394 29.984ZM62.32 48.711C63.3652 48.711 64.274 48.4622 65.0465 47.9646C65.8418 47.4443 66.4666 46.7545 66.921 45.895C67.3754 45.0128 67.6026 43.2755 67.6026 42.1671V40.9118C65.5487 40.1053 63.093 40.1908 61.5828 40.6701C60.0725 41.1493 59.2186 41.7677 58.7032 42.5531C58.1877 43.3385 57.9875 44.0247 57.9875 44.9068C57.9875 45.9925 58.2553 46.908 59.1003 47.6623C59.9453 48.4165 61.025 48.711 62.32 48.711ZM62.7735 45.9842C63.5087 45.9842 64.1048 45.3909 64.1048 44.6589C64.1048 43.927 63.5087 43.3336 62.7735 43.3336C62.0382 43.3336 61.4422 43.927 61.4422 44.6589C61.4422 45.3909 62.0382 45.9842 62.7735 45.9842ZM64.1048 11.6589C64.1048 12.3909 63.5087 12.9842 62.7735 12.9842C62.0382 12.9842 61.4422 12.3909 61.4422 11.6589C61.4422 10.927 62.0382 10.3336 62.7735 10.3336C63.5087 10.3336 64.1048 10.927 64.1048 11.6589ZM57.7481 18.2893C56.7029 18.2893 55.7941 18.5381 55.0216 19.0357C54.2263 19.5559 53.6015 20.2458 53.1471 21.1053C52.6927 21.9874 52.4655 23.7248 52.4655 24.8331V26.0884C54.5194 26.895 56.9751 26.8094 58.4853 26.3302C59.9956 25.8509 60.8495 25.2325 61.3649 24.4472C61.8804 23.6618 62.0807 22.9755 62.0807 22.0934C62.0807 21.0077 61.8128 20.0922 60.9678 19.338C60.1228 18.5837 59.0432 18.2893 57.7481 18.2893ZM57.2946 21.016C56.5594 21.016 55.9633 21.6094 55.9633 22.3413C55.9633 23.0732 56.5594 23.6666 57.2946 23.6666C58.0299 23.6666 58.6259 23.0732 58.6259 22.3413C58.6259 21.6094 58.0299 21.016 57.2946 21.016ZM38.9293 38.3413C38.9293 37.6094 39.5253 37.016 40.2606 37.016C40.9958 37.016 41.5919 37.6094 41.5919 38.3413C41.5919 39.0732 40.9958 39.6666 40.2606 39.6666C39.5253 39.6666 38.9293 39.0732 38.9293 38.3413ZM184.49 15.3057C185.378 14.7972 186.071 14.0908 186.569 13.0875V19.1701C185.234 17.8735 183.365 17 180.366 17C177.315 17 175.187 17.7174 173.51 18.6943C172.602 19.2145 171.897 19.9418 171.397 20.9823V14.7966C172.735 16.1115 174.61 17 177.634 17C180.685 17 182.813 16.2826 184.49 15.3057ZM173.988 2.03567C174.76 1.53807 175.669 1.28926 176.714 1.28926C178.009 1.28926 179.089 1.58369 179.934 2.33796C180.779 3.09222 181.047 4.00773 181.047 5.09342C181.047 5.97554 180.846 6.66179 180.331 7.44717C179.815 8.23254 178.962 8.85094 177.451 9.33017C175.941 9.8094 173.485 9.89497 171.431 9.08843V7.8331C171.431 6.72479 171.659 4.9874 172.113 4.10527C172.567 3.24577 173.192 2.5559 173.988 2.03567ZM174.929 5.3413C174.929 4.60936 175.525 4.016 176.261 4.016C176.996 4.016 177.592 4.60936 177.592 5.3413C177.592 6.07325 176.996 6.66661 176.261 6.66661C175.525 6.66661 174.929 6.07325 174.929 5.3413ZM171.431 40.8235L171.431 40.8331V42.0884C173.485 42.895 175.941 42.8094 177.451 42.3302C178.962 41.8509 179.815 41.2325 180.331 40.4472C180.846 39.6618 181.047 38.9755 181.047 38.0934C181.047 37.0077 180.779 36.0922 179.934 35.338C179.089 34.5837 178.009 34.2893 176.714 34.2893C175.669 34.2893 174.76 34.5381 173.988 35.0357C173.192 35.5559 172.567 36.2458 172.113 37.1053C171.66 37.9848 171.433 39.7148 171.431 40.8235ZM171.431 43.3438V44.0117L171.431 44.0188C171.433 45.311 171.751 46.0339 172.386 46.7789C173.725 48.3507 175.868 48.7828 178.24 48.7828C180.611 48.7828 183.355 48.0874 185.171 46.2361C186.103 45.2635 186.569 44.0273 186.569 42.4213V30.6751C186.091 31.7155 185.41 32.5298 184.456 33.1179C183.524 33.7059 182.433 34 181.184 34C180.855 34 180.536 33.9796 180.226 33.9388C180.854 34.3494 181.369 34.8819 181.738 35.4455C182.203 36.1558 182.458 37.163 182.455 38.0637C182.451 38.9645 182.336 40.0129 181.722 40.9391C181.108 41.8654 180.201 42.7818 178.337 43.4498C176.474 44.1177 173.794 44.1708 171.431 43.3438ZM177.774 33.0612C177.464 33.0204 177.145 33 176.816 33C175.567 33 174.476 33.294 173.544 33.8821C172.613 34.4564 171.908 35.2463 171.431 36.2518L171.431 24.5787C171.431 22.9727 171.897 21.7365 172.829 20.7639C174.645 18.9126 177.389 18.2172 179.76 18.2172C182.132 18.2172 184.275 18.6493 185.614 20.221C186.248 20.964 186.566 21.685 186.569 22.9705V23.6562C184.206 22.8291 181.526 22.8823 179.663 23.5502C177.799 24.2182 176.892 25.1346 176.278 26.0609C175.664 26.9871 175.549 28.0355 175.545 28.9363C175.542 29.837 175.797 30.8442 176.262 31.5545C176.631 32.1181 177.146 32.6506 177.774 33.0612ZM186.569 24.9116C184.515 24.105 182.059 24.1906 180.549 24.6698C179.038 25.1491 178.185 25.7675 177.669 26.5528C177.154 27.3382 176.953 28.0245 176.953 28.9066C176.953 29.9923 177.221 30.9078 178.066 31.662C178.911 32.4163 179.991 32.7107 181.286 32.7107C182.331 32.7107 183.24 32.4619 184.012 31.9643C184.808 31.4441 185.433 30.7542 185.887 29.8947C186.339 29.0174 186.566 27.2941 186.569 26.1851V24.9116ZM188.431 36.9825V31.7966C189.401 32.7503 190.654 33.4797 192.423 33.8084C191.733 34.0621 191.113 34.3634 190.544 34.6945C189.636 35.2148 188.931 35.9421 188.431 36.9825ZM203.637 35.2036C202.667 34.25 201.414 33.5206 199.645 33.1918C200.335 32.9381 200.955 32.6368 201.524 32.3057C202.432 31.7855 203.137 31.0581 203.637 30.0177V35.2036ZM190.579 17.8821C189.624 18.4702 188.909 19.2845 188.431 20.3249V17.0002V17L188.465 7.57889C188.465 5.97297 188.931 4.73673 189.863 3.76413C191.679 1.91279 194.423 1.21742 196.795 1.21742C199.166 1.21742 201.309 1.64951 202.648 3.22129C203.282 3.96437 203.6 4.68541 203.603 5.97118L203.603 6.65648C201.24 5.82939 198.56 5.88249 196.697 6.55045C194.833 7.2184 193.926 8.13487 193.312 9.06112C192.698 9.98737 192.583 11.0357 192.579 11.9365C192.576 12.8373 192.831 13.8445 193.296 14.5548C193.761 15.2651 194.457 15.9259 195.321 16.3556C196.184 16.7854 197.15 17.0002 198.218 17.0002C199.467 17.0002 200.558 16.7062 201.49 16.1181C202.421 15.5439 203.126 14.754 203.603 13.7484V26.4213C203.603 28.0273 203.137 29.2635 202.205 30.2361C200.389 32.0874 197.645 32.7828 195.274 32.7828C192.902 32.7828 190.759 32.3507 189.42 30.7789C188.784 30.0325 188.465 29.3084 188.465 28.0117V27.3438C190.829 28.1708 193.508 28.1177 195.371 27.4498C197.235 26.7818 198.142 25.8654 198.756 24.9391C199.37 24.0129 199.486 22.9645 199.489 22.0637C199.492 21.163 199.237 20.1558 198.772 19.4455C198.307 18.7352 197.611 18.0744 196.747 17.6446C195.884 17.2149 194.918 17 193.85 17C192.601 17 191.51 17.294 190.579 17.8821ZM197.583 7.67007C199.093 7.19084 201.549 7.10527 203.603 7.91181L203.603 9.18475C203.6 10.2938 203.373 12.0175 202.921 12.895C202.467 13.7545 201.842 14.4443 201.047 14.9646C200.274 15.4622 199.365 15.711 198.32 15.711C197.025 15.711 195.945 15.4165 195.1 14.6623C194.255 13.908 193.987 12.9925 193.987 11.9068C193.987 11.0247 194.188 10.3384 194.703 9.55307C195.219 8.7677 196.073 8.1493 197.583 7.67007ZM183.071 28.6587C183.071 29.3906 182.475 29.984 181.739 29.984C181.004 29.984 180.408 29.3906 180.408 28.6587C180.408 27.9267 181.004 27.3334 181.739 27.3334C182.475 27.3334 183.071 27.9267 183.071 28.6587ZM201.047 47.9646C200.274 48.4622 199.365 48.711 198.32 48.711C197.025 48.711 195.945 48.4165 195.1 47.6623C194.255 46.908 193.987 45.9925 193.987 44.9068C193.987 44.0247 194.188 43.3385 194.703 42.5531C195.219 41.7677 196.073 41.1493 197.583 40.6701C199.093 40.1908 201.549 40.1053 203.603 40.9118V42.1671C203.603 43.2755 203.375 45.0128 202.921 45.895C202.467 46.7545 201.842 47.4443 201.047 47.9646ZM200.105 44.6589C200.105 45.3909 199.509 45.9842 198.773 45.9842C198.038 45.9842 197.442 45.3909 197.442 44.6589C197.442 43.927 198.038 43.3336 198.773 43.3336C199.509 43.3336 200.105 43.927 200.105 44.6589ZM198.773 12.9842C199.509 12.9842 200.105 12.3909 200.105 11.6589C200.105 10.927 199.509 10.3336 198.773 10.3336C198.038 10.3336 197.442 10.927 197.442 11.6589C197.442 12.3909 198.038 12.9842 198.773 12.9842ZM191.022 19.0357C191.794 18.5381 192.703 18.2893 193.748 18.2893C195.043 18.2893 196.123 18.5837 196.968 19.338C197.813 20.0922 198.081 21.0077 198.081 22.0934C198.081 22.9755 197.88 23.6618 197.365 24.4472C196.849 25.2325 195.996 25.8509 194.485 26.3302C192.975 26.8094 190.519 26.895 188.465 26.0884V24.8331C188.465 23.7248 188.693 21.9874 189.147 21.1053C189.602 20.2458 190.226 19.5559 191.022 19.0357ZM191.963 22.3413C191.963 21.6094 192.559 21.016 193.295 21.016C194.03 21.016 194.626 21.6094 194.626 22.3413C194.626 23.0732 194.03 23.6666 193.295 23.6666C192.559 23.6666 191.963 23.0732 191.963 22.3413ZM176.261 37.016C175.525 37.016 174.929 37.6094 174.929 38.3413C174.929 39.0732 175.525 39.6666 176.261 39.6666C176.996 39.6666 177.592 39.0732 177.592 38.3413C177.592 37.6094 176.996 37.016 176.261 37.016ZM118.569 13.0875C118.071 14.0908 117.378 14.7972 116.49 15.3057C114.813 16.2826 112.685 17 109.634 17C106.61 17 104.735 16.1115 103.397 14.7966V20.9823C103.897 19.9418 104.602 19.2145 105.51 18.6943C107.187 17.7174 109.315 17 112.366 17C115.365 17 117.234 17.8735 118.569 19.1701V13.0875ZM108.714 1.28926C107.669 1.28926 106.76 1.53807 105.988 2.03567C105.192 2.5559 104.567 3.24577 104.113 4.10527C103.659 4.9874 103.431 6.72479 103.431 7.8331V9.08843C105.485 9.89497 107.941 9.8094 109.451 9.33017C110.962 8.85094 111.815 8.23254 112.331 7.44717C112.846 6.66179 113.047 5.97554 113.047 5.09342C113.047 4.00773 112.779 3.09222 111.934 2.33796C111.089 1.58369 110.009 1.28926 108.714 1.28926ZM108.261 4.016C107.525 4.016 106.929 4.60936 106.929 5.3413C106.929 6.07325 107.525 6.66661 108.261 6.66661C108.996 6.66661 109.592 6.07325 109.592 5.3413C109.592 4.60936 108.996 4.016 108.261 4.016ZM103.431 40.8331V40.8235C103.433 39.7148 103.66 37.9848 104.113 37.1053C104.567 36.2458 105.192 35.5559 105.988 35.0357C106.76 34.5381 107.669 34.2893 108.714 34.2893C110.009 34.2893 111.089 34.5837 111.934 35.338C112.779 36.0922 113.047 37.0077 113.047 38.0934C113.047 38.9755 112.846 39.6618 112.331 40.4472C111.815 41.2325 110.962 41.8509 109.451 42.3302C107.941 42.8094 105.485 42.895 103.431 42.0884V40.8331ZM103.431 44.0117V43.3438C105.794 44.1708 108.474 44.1177 110.337 43.4498C112.201 42.7818 113.108 41.8654 113.722 40.9391C114.336 40.0129 114.451 38.9645 114.455 38.0637C114.458 37.163 114.203 36.1558 113.738 35.4455C113.369 34.8819 112.854 34.3494 112.226 33.9388C112.536 33.9796 112.855 34 113.184 34C114.433 34 115.524 33.7059 116.456 33.1179C117.41 32.5298 118.091 31.7155 118.569 30.6751V42.4213C118.569 44.0273 118.103 45.2635 117.171 46.2361C115.355 48.0874 112.611 48.7828 110.24 48.7828C107.868 48.7828 105.725 48.3507 104.386 46.7789C103.751 46.0339 103.433 45.311 103.431 44.0188V44.0117ZM108.816 33C109.145 33 109.464 33.0204 109.774 33.0612C109.146 32.6506 108.631 32.1181 108.262 31.5545C107.797 30.8442 107.542 29.837 107.545 28.9363C107.549 28.0355 107.664 26.9871 108.278 26.0609C108.892 25.1346 109.799 24.2182 111.663 23.5502C113.526 22.8823 116.206 22.8291 118.569 23.6562V22.9705C118.566 21.685 118.248 20.964 117.614 20.221C116.275 18.6493 114.132 18.2172 111.76 18.2172C109.389 18.2172 106.645 18.9126 104.829 20.7639C103.897 21.7365 103.431 22.9727 103.431 24.5787L103.431 36.2518C103.908 35.2463 104.613 34.4564 105.544 33.8821C106.476 33.294 107.567 33 108.816 33ZM112.549 24.6698C114.059 24.1906 116.515 24.105 118.569 24.9116V26.1851C118.566 27.2941 118.339 29.0174 117.887 29.8947C117.433 30.7542 116.808 31.4441 116.012 31.9643C115.24 32.4619 114.331 32.7107 113.286 32.7107C111.991 32.7107 110.911 32.4163 110.066 31.662C109.221 30.9078 108.953 29.9923 108.953 28.9066C108.953 28.0245 109.154 27.3382 109.669 26.5528C110.185 25.7675 111.038 25.1491 112.549 24.6698ZM120.431 31.7966V36.9825C120.931 35.9421 121.636 35.2148 122.544 34.6945C123.113 34.3634 123.733 34.0621 124.423 33.8084C122.654 33.4797 121.401 32.7503 120.431 31.7966ZM131.645 33.1918C133.414 33.5206 134.667 34.25 135.637 35.2036V30.0177C135.137 31.0581 134.432 31.7855 133.524 32.3057C132.955 32.6368 132.335 32.9381 131.645 33.1918ZM120.431 20.3249C120.909 19.2845 121.624 18.4702 122.579 17.8821C123.51 17.294 124.601 17 125.85 17C126.918 17 127.884 17.2149 128.747 17.6446C129.611 18.0744 130.307 18.7352 130.772 19.4455C131.237 20.1558 131.492 21.163 131.489 22.0637C131.486 22.9645 131.37 24.0129 130.756 24.9391C130.142 25.8654 129.235 26.7818 127.371 27.4498C125.508 28.1177 122.829 28.1708 120.465 27.3438V28.0117C120.465 29.3084 120.784 30.0325 121.42 30.7789C122.759 32.3507 124.902 32.7828 127.274 32.7828C129.645 32.7828 132.389 32.0874 134.205 30.2361C135.137 29.2635 135.603 28.0273 135.603 26.4213V13.7484C135.126 14.754 134.421 15.5439 133.49 16.1181C132.558 16.7062 131.467 17.0002 130.218 17.0002C129.15 17.0002 128.184 16.7854 127.321 16.3556C126.457 15.9259 125.761 15.2651 125.296 14.5548C124.831 13.8445 124.576 12.8373 124.579 11.9365C124.583 11.0357 124.698 9.98737 125.312 9.06112C125.926 8.13487 126.833 7.2184 128.697 6.55045C130.56 5.88249 133.24 5.82939 135.603 6.65648L135.603 5.97118C135.6 4.68541 135.282 3.96437 134.648 3.22129C133.309 1.64951 131.166 1.21742 128.795 1.21742C126.423 1.21742 123.679 1.91279 121.863 3.76413C120.931 4.73673 120.465 5.97297 120.465 7.57889L120.431 17V17.0002V20.3249ZM135.603 7.91181C133.549 7.10527 131.093 7.19084 129.583 7.67007C128.073 8.1493 127.219 8.7677 126.703 9.55307C126.188 10.3384 125.987 11.0247 125.987 11.9068C125.987 12.9925 126.255 13.908 127.1 14.6623C127.945 15.4165 129.025 15.711 130.32 15.711C131.365 15.711 132.274 15.4622 133.047 14.9646C133.842 14.4443 134.467 13.7545 134.921 12.895C135.373 12.0175 135.6 10.2938 135.603 9.18475L135.603 7.91181ZM113.739 29.984C114.475 29.984 115.071 29.3906 115.071 28.6587C115.071 27.9267 114.475 27.3334 113.739 27.3334C113.004 27.3334 112.408 27.9267 112.408 28.6587C112.408 29.3906 113.004 29.984 113.739 29.984ZM130.32 48.711C131.365 48.711 132.274 48.4622 133.047 47.9646C133.842 47.4443 134.467 46.7545 134.921 45.895C135.375 45.0128 135.603 43.2755 135.603 42.1671V40.9118C133.549 40.1053 131.093 40.1908 129.583 40.6701C128.073 41.1493 127.219 41.7677 126.703 42.5531C126.188 43.3385 125.987 44.0247 125.987 44.9068C125.987 45.9925 126.255 46.908 127.1 47.6623C127.945 48.4165 129.025 48.711 130.32 48.711ZM130.773 45.9842C131.509 45.9842 132.105 45.3909 132.105 44.6589C132.105 43.927 131.509 43.3336 130.773 43.3336C130.038 43.3336 129.442 43.927 129.442 44.6589C129.442 45.3909 130.038 45.9842 130.773 45.9842ZM132.105 11.6589C132.105 12.3909 131.509 12.9842 130.773 12.9842C130.038 12.9842 129.442 12.3909 129.442 11.6589C129.442 10.927 130.038 10.3336 130.773 10.3336C131.509 10.3336 132.105 10.927 132.105 11.6589ZM125.748 18.2893C124.703 18.2893 123.794 18.5381 123.022 19.0357C122.226 19.5559 121.602 20.2458 121.147 21.1053C120.693 21.9874 120.465 23.7248 120.465 24.8331V26.0884C122.519 26.895 124.975 26.8094 126.485 26.3302C127.996 25.8509 128.849 25.2325 129.365 24.4472C129.88 23.6618 130.081 22.9755 130.081 22.0934C130.081 21.0077 129.813 20.0922 128.968 19.338C128.123 18.5837 127.043 18.2893 125.748 18.2893ZM125.295 21.016C124.559 21.016 123.963 21.6094 123.963 22.3413C123.963 23.0732 124.559 23.6666 125.295 23.6666C126.03 23.6666 126.626 23.0732 126.626 22.3413C126.626 21.6094 126.03 21.016 125.295 21.016ZM106.929 38.3413C106.929 37.6094 107.525 37.016 108.261 37.016C108.996 37.016 109.592 37.6094 109.592 38.3413C109.592 39.0732 108.996 39.6666 108.261 39.6666C107.525 39.6666 106.929 39.0732 106.929 38.3413ZM252.49 15.3057C253.378 14.7972 254.071 14.0908 254.569 13.0875V19.1701C253.234 17.8735 251.365 17 248.366 17C245.315 17 243.187 17.7174 241.51 18.6943C240.602 19.2145 239.897 19.9418 239.397 20.9823V14.7966C240.735 16.1115 242.61 17 245.634 17C248.685 17 250.813 16.2826 252.49 15.3057ZM241.988 2.03567C242.76 1.53807 243.669 1.28926 244.714 1.28926C246.009 1.28926 247.089 1.58369 247.934 2.33796C248.779 3.09222 249.047 4.00773 249.047 5.09342C249.047 5.97554 248.846 6.66179 248.331 7.44717C247.815 8.23254 246.962 8.85094 245.451 9.33017C243.941 9.8094 241.485 9.89497 239.431 9.08843V7.8331C239.431 6.72479 239.659 4.9874 240.113 4.10527C240.567 3.24577 241.192 2.5559 241.988 2.03567ZM242.929 5.3413C242.929 4.60936 243.525 4.016 244.261 4.016C244.996 4.016 245.592 4.60936 245.592 5.3413C245.592 6.07325 244.996 6.66661 244.261 6.66661C243.525 6.66661 242.929 6.07325 242.929 5.3413ZM239.431 40.8235L239.431 40.8331V42.0884C241.485 42.895 243.941 42.8094 245.451 42.3302C246.962 41.8509 247.815 41.2325 248.331 40.4472C248.846 39.6618 249.047 38.9755 249.047 38.0934C249.047 37.0077 248.779 36.0922 247.934 35.338C247.089 34.5837 246.009 34.2893 244.714 34.2893C243.669 34.2893 242.76 34.5381 241.988 35.0357C241.192 35.5559 240.567 36.2458 240.113 37.1053C239.66 37.9848 239.433 39.7148 239.431 40.8235ZM239.431 43.3438V44.0117L239.431 44.0188C239.433 45.311 239.751 46.0339 240.386 46.7789C241.725 48.3507 243.868 48.7828 246.24 48.7828C248.611 48.7828 251.355 48.0874 253.171 46.2361C254.103 45.2635 254.569 44.0273 254.569 42.4213V30.6751C254.091 31.7155 253.41 32.5298 252.456 33.1179C251.524 33.7059 250.433 34 249.184 34C248.855 34 248.536 33.9796 248.226 33.9388C248.854 34.3494 249.369 34.8819 249.738 35.4455C250.203 36.1558 250.458 37.163 250.455 38.0637C250.451 38.9645 250.336 40.0129 249.722 40.9391C249.108 41.8654 248.201 42.7818 246.337 43.4498C244.474 44.1177 241.794 44.1708 239.431 43.3438ZM245.774 33.0612C245.464 33.0204 245.145 33 244.816 33C243.567 33 242.476 33.294 241.544 33.8821C240.613 34.4564 239.908 35.2463 239.431 36.2518L239.431 24.5787C239.431 22.9727 239.897 21.7365 240.829 20.7639C242.645 18.9126 245.389 18.2172 247.76 18.2172C250.132 18.2172 252.275 18.6493 253.614 20.221C254.248 20.964 254.566 21.685 254.569 22.9705V23.6562C252.206 22.8291 249.526 22.8823 247.663 23.5502C245.799 24.2182 244.892 25.1346 244.278 26.0609C243.664 26.9871 243.549 28.0355 243.545 28.9363C243.542 29.837 243.797 30.8442 244.262 31.5545C244.631 32.1181 245.146 32.6506 245.774 33.0612ZM254.569 24.9116C252.515 24.105 250.059 24.1906 248.549 24.6698C247.038 25.1491 246.185 25.7675 245.669 26.5528C245.154 27.3382 244.953 28.0245 244.953 28.9066C244.953 29.9923 245.221 30.9078 246.066 31.662C246.911 32.4163 247.991 32.7107 249.286 32.7107C250.331 32.7107 251.24 32.4619 252.012 31.9643C252.808 31.4441 253.433 30.7542 253.887 29.8947C254.339 29.0174 254.566 27.2941 254.569 26.1851V24.9116ZM256.431 36.9825V31.7966C257.401 32.7503 258.654 33.4797 260.423 33.8084C259.733 34.0621 259.113 34.3634 258.544 34.6945C257.636 35.2148 256.931 35.9421 256.431 36.9825ZM271.637 35.2036C270.667 34.25 269.414 33.5206 267.645 33.1918C268.335 32.9381 268.955 32.6368 269.524 32.3057C270.432 31.7855 271.137 31.0581 271.637 30.0177V35.2036ZM258.578 17.8821C257.624 18.4702 256.909 19.2845 256.431 20.3249V17.0002V17L256.465 7.57889C256.465 5.97297 256.931 4.73673 257.863 3.76413C259.679 1.91279 262.423 1.21742 264.795 1.21742C267.166 1.21742 269.309 1.64951 270.648 3.22129C271.282 3.96437 271.6 4.68541 271.603 5.97118V6.65648C269.24 5.82939 266.56 5.88249 264.697 6.55045C262.833 7.2184 261.926 8.13487 261.312 9.06112C260.698 9.98737 260.583 11.0357 260.579 11.9365C260.576 12.8373 260.831 13.8445 261.296 14.5548C261.761 15.2651 262.457 15.9259 263.321 16.3556C264.184 16.7854 265.15 17.0002 266.218 17.0002C267.467 17.0002 268.558 16.7062 269.49 16.1181C270.421 15.5439 271.126 14.754 271.603 13.7484V26.4213C271.603 28.0273 271.137 29.2635 270.205 30.2361C268.389 32.0874 265.645 32.7828 263.274 32.7828C260.902 32.7828 258.759 32.3507 257.42 30.7789C256.784 30.0325 256.465 29.3084 256.465 28.0117V27.3438C258.829 28.1708 261.508 28.1177 263.371 27.4498C265.235 26.7818 266.142 25.8654 266.756 24.9391C267.37 24.0129 267.486 22.9645 267.489 22.0637C267.492 21.163 267.237 20.1558 266.772 19.4455C266.307 18.7352 265.611 18.0744 264.747 17.6446C263.884 17.2149 262.918 17 261.85 17C260.601 17 259.51 17.294 258.578 17.8821ZM265.583 7.67007C267.093 7.19084 269.549 7.10527 271.603 7.91181V9.18475C271.6 10.2938 271.373 12.0175 270.921 12.895C270.467 13.7545 269.842 14.4443 269.047 14.9646C268.274 15.4622 267.365 15.711 266.32 15.711C265.025 15.711 263.945 15.4165 263.1 14.6623C262.255 13.908 261.987 12.9925 261.987 11.9068C261.987 11.0247 262.188 10.3384 262.703 9.55307C263.219 8.7677 264.073 8.1493 265.583 7.67007ZM251.071 28.6587C251.071 29.3906 250.475 29.984 249.739 29.984C249.004 29.984 248.408 29.3906 248.408 28.6587C248.408 27.9267 249.004 27.3334 249.739 27.3334C250.475 27.3334 251.071 27.9267 251.071 28.6587ZM269.047 47.9646C268.274 48.4622 267.365 48.711 266.32 48.711C265.025 48.711 263.945 48.4165 263.1 47.6623C262.255 46.908 261.987 45.9925 261.987 44.9068C261.987 44.0247 262.188 43.3385 262.703 42.5531C263.219 41.7677 264.073 41.1493 265.583 40.6701C267.093 40.1908 269.549 40.1053 271.603 40.9118V42.1671C271.603 43.2755 271.375 45.0128 270.921 45.895C270.467 46.7545 269.842 47.4443 269.047 47.9646ZM268.105 44.6589C268.105 45.3909 267.509 45.9842 266.773 45.9842C266.038 45.9842 265.442 45.3909 265.442 44.6589C265.442 43.927 266.038 43.3336 266.773 43.3336C267.509 43.3336 268.105 43.927 268.105 44.6589ZM266.773 12.9842C267.509 12.9842 268.105 12.3909 268.105 11.6589C268.105 10.927 267.509 10.3336 266.773 10.3336C266.038 10.3336 265.442 10.927 265.442 11.6589C265.442 12.3909 266.038 12.9842 266.773 12.9842ZM259.022 19.0357C259.794 18.5381 260.703 18.2893 261.748 18.2893C263.043 18.2893 264.123 18.5837 264.968 19.338C265.813 20.0922 266.081 21.0077 266.081 22.0934C266.081 22.9755 265.88 23.6618 265.365 24.4472C264.849 25.2325 263.996 25.8509 262.485 26.3302C260.975 26.8094 258.519 26.895 256.465 26.0884V24.8331C256.465 23.7248 256.693 21.9874 257.147 21.1053C257.602 20.2458 258.226 19.5559 259.022 19.0357ZM259.963 22.3413C259.963 21.6094 260.559 21.016 261.295 21.016C262.03 21.016 262.626 21.6094 262.626 22.3413C262.626 23.0732 262.03 23.6666 261.295 23.6666C260.559 23.6666 259.963 23.0732 259.963 22.3413ZM244.261 37.016C243.525 37.016 242.929 37.6094 242.929 38.3413C242.929 39.0732 243.525 39.6666 244.261 39.6666C244.996 39.6666 245.592 39.0732 245.592 38.3413C245.592 37.6094 244.996 37.016 244.261 37.016Z" fill="white"/>
            </svg>
               
        </div>
        <div id='licenseInfo'></div>
        <div class='button' id='validateProductKeyButton' onclick='onValidateClick(productKeyInput.value);'>Validate</div>
        <div id='subscribeWebsite'><!--<a href='http://www.bourt.com/generator/subscribe' target='_blank'>-->Buy subscription<!--</a>--></div>
    </div>

</div>



<div id='deleteConnectionsDialog'>

    <div id='deleteConnectionsTitle'>
        <div id='deleteConnectionsTitleText'>Delete connections to</div>
        <div class='panelButton dialogButtonClose' id='deleteConnectionsClose' onclick='deleteConnectionsClose.blur(); hideDeleteConnectionsDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='deleteConnectionsBody'>
        <div id='deleteConnectionsInputBack'></div>
        <input type='text' spellcheck='false' id='deleteConnectionsInput' />
        <div class='button' id='deleteConnectionsButton' onclick='deleteConnectionsToNodes(deleteConnectionsInput.value);'>Delete</div>
    </div>

</div>



<div id='minZoomDialog'>

    <div id='minZoomTitle'>
        <div id='minZoomTitleText'>Zoom level for values</div>
        <div class='panelButton dialogButtonClose' id='minZoomClose' onclick='hideAllMenus(); minZoomClose.blur(); hideMinZoomDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='minZoomBody'>
        <input type='text' spellcheck='false' id='minZoomInput' />
    </div>

</div>



<div id='aboutBack'></div>

<div id='aboutDialog'>
    
    <div id='aboutTitle'>
        <div id='aboutTitleText'>About</div>
        <div class='panelButton dialogButtonClose' id='aboutClose' onclick='aboutClose.blur(); hideAboutDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='aboutDialogContainer'>
        <div id='aboutDialogContent'>
            <div id='aboutDialogBody'>
                <div id='aboutBrainshiftLogo'>
                    <svg width="72" height="16" viewBox="0 0 72 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M25.9747 12.0013C25.412 12.0013 24.9232 11.8722 24.5081 11.6141C24.093 11.3465 23.784 10.9832 23.5811 10.5244L23.967 12.0013H23V2.01403H23.967V6.23724C24.1699 5.77841 24.093 5.49164 24.5081 5.23355C24.9232 4.9659 25.412 4.83208 25.9747 4.83208C26.8878 4.83208 27.6119 5.15708 28.1469 5.80709C28.6819 6.44754 28.9494 7.3174 28.9494 8.41668C28.9494 9.14316 28.8249 9.77882 28.5758 10.3237C28.336 10.859 27.9947 11.2748 27.552 11.5711C27.1092 11.8579 26.5835 12.0013 25.9747 12.0013ZM25.9747 11.141C26.7126 11.141 27.1277 11.0502 27.552 10.5244C27.9855 9.98912 28.0335 9.37257 28.0335 8.41668C28.0335 7.46078 27.9855 7.02556 27.552 6.49982C27.1277 5.96452 26.7954 5.80709 26.0575 5.80709C25.3289 5.80709 24.8182 5.96452 24.3846 6.49982C23.9511 7.02556 23.967 7.46078 23.967 8.41668C23.967 9.37257 23.9511 9.98912 24.3846 10.5244C24.8182 11.0502 25.246 11.141 25.9747 11.141Z" fill="white"/>
                        <path d="M38.9961 12.0013V5H39.9922V12.0013H38.9961Z" fill="white"/>
                        <path d="M50.6099 11.9985C50.1302 11.9985 49.6691 11.9221 49.2263 11.7691C48.7836 11.6066 48.4192 11.3772 48.1333 11.0809L48.41 10.5934C48.7421 10.8897 49.1282 11.0205 49.4909 11.0809C49.9119 11.151 50.1379 11.151 50.5345 11.151C51.1341 11.151 51.2449 11.0809 51.5606 10.9229C51.9495 10.7284 52.035 10.3693 52.035 9.95823C52.035 9.54719 51.8254 9.38563 51.6132 9.20401C51.4103 9.01283 51.1273 8.95914 50.6661 8.84444L49.6488 8.6515C49.0677 8.50811 48.6867 8.32312 48.41 8.0268C48.1425 7.73047 48 7.23433 48 6.76594C48 6.17329 48.2944 5.58487 48.7279 5.23119C49.1707 4.86795 50.0334 4.82934 50.7621 4.82934C51.2233 4.82934 51.6476 4.91059 52.035 5.07309C52.4316 5.23559 52.7498 5.465 52.9896 5.76133L52.651 6.37424C52.116 5.80071 51.5369 5.77567 50.7621 5.77567C50.1994 5.77567 49.7885 5.76133 49.4195 5.90472C49.0505 6.0481 48.9384 6.24011 48.9384 6.6607C48.9384 6.9857 48.9464 7.17911 49.1401 7.37984C49.3338 7.58058 49.7244 7.68689 50.1487 7.79203L51.3151 8.0268C51.9146 8.17974 52.4178 8.56723 52.7129 8.84444C53.0081 9.12165 53.1142 9.60881 53.1142 10.0772C53.1142 10.6603 52.8882 11.1287 52.4362 11.4824C51.9842 11.8265 51.3755 11.9985 50.6099 11.9985Z" fill="white"/>
                        <path d="M54.0027 12.0415V2.09424H55.007V6.20582C55.2283 5.74699 55.5466 5.40287 55.9616 5.17346C56.3767 4.94404 56.8425 4.82934 57.359 4.82934C59.1383 4.82934 60.0027 5.73969 60.0027 7.49854V11.9985H59.0027V7.4676C59.0027 6.73156 59.1446 6.71837 58.8587 6.37424C58.5727 6.03012 57.9955 5.77567 57.359 5.77567C56.6488 5.77567 56.0412 5.91542 55.6077 6.37424C55.1834 6.82351 55.007 7.13304 55.007 7.89775V12.0415H54.0027Z" fill="white"/>
                        <path d="M61.0046 11.9985V5H62.0046V11.9985H61.0046Z" fill="white"/>
                        <path d="M65.0046 11.9985V6H63.0046V5H65.0046V4.49955C65.0046 2.77894 65.9968 1.12295 67.6109 1.02736L68.9481 0.998535L69.0031 2.09424L67.4584 2.13741C66.7154 2.24618 66.0046 3.13262 66.0046 4.49955V5H67.862L67.9701 6H66.0046V11.9985H65.0046Z" fill="white"/>
                        <path d="M69.965 11.9985C69.264 11.9985 68.7383 11.793 68.3877 11.382C68.0372 10.9709 67.9701 10.3926 67.9701 9.64704V6L67.862 5H70.643V6H69.0031V9.51799C69.0031 10.1393 69.0358 10.4762 69.2756 10.8107C69.5154 11.1357 69.7141 11.1443 70.0237 11.1443C70.1897 11.1443 70.3512 11.132 70.4988 11.0938C70.6556 11.046 70.741 11.0309 70.8425 10.9927L71.0027 11.7548C70.9197 11.8121 70.7721 11.8647 70.56 11.9125C70.3478 11.9699 70.1495 11.9985 69.965 11.9985Z" fill="white"/>
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M30 12.0013V5.00128H31L31.0159 6.49982C31.2188 6.0601 31.5047 5.75272 31.8737 5.53287C32.5542 5.12002 33.4183 4.81684 34.6567 4.81684C35.8951 4.81684 36.6588 5.19878 37.2025 5.76228C37.5715 6.17332 38 6.75999 38 7.62986V12.0013H36.8981L37.1887 10.5961C36.995 11.0358 36.7044 11.3799 36.317 11.6285C35.9388 11.877 35.4961 12.0013 34.9888 12.0013C34.5553 12.0013 33.8185 12.0682 33.468 11.8866C33.1175 11.7049 32.6888 11.3015 32.5 11.0013C32.3112 10.7011 32.1719 10.2294 32.1731 9.84872C32.1744 9.46805 32.2508 8.89272 32.5 8.50128C32.7492 8.10983 33.6544 7.44465 34.411 7.16236C35.1676 6.88007 36.2155 7.28032 37.1748 7.62986V7.34757C37.0874 7.00635 37.0649 6.81526 36.8066 6.49982C36.2628 5.83556 35.3736 5.76228 34.411 5.76228C33.4484 5.76228 32.3177 6.06794 31.5803 6.85034C31.2021 7.26137 31.0297 7.341 31.0297 8.01968L31 12.0013H30ZM36 10.9222C35.6864 11.1325 35.4546 11.141 35.0303 11.141C34.5045 11.141 33.777 10.8533 33.562 10.6535C33.347 10.4537 33.2714 10.3076 33.2714 9.84872C33.2714 9.47593 33.3527 9.18591 33.562 8.854C33.7712 8.52209 34.1179 8.26074 34.731 8.05821C35.3441 7.85569 36.341 7.81952 37.1748 8.16038V8.6909C37.1748 9.15929 37.0826 9.68857 36.8981 10.0614C36.7136 10.4246 36.3228 10.7023 36 10.9222Z" fill="white"/>
                        <path d="M62.0855 3.49148C62.0855 3.80081 61.8435 4.05157 61.5451 4.05157C61.2466 4.05157 61.0046 3.80081 61.0046 3.49148C61.0046 3.18215 61.2466 2.93138 61.5451 2.93138C61.8435 2.93138 62.0855 3.18215 62.0855 3.49148Z" fill="white"/>
                        <path d="M40.0561 3.49931C40.0561 3.80864 39.8141 4.0594 39.5156 4.0594C39.2171 4.0594 38.9752 3.80864 38.9752 3.49931C38.9752 3.18997 39.2171 2.93921 39.5156 2.93921C39.8141 2.93921 40.0561 3.18997 40.0561 3.49931Z" fill="white"/>
                        <path d="M36 9.25528C36 9.70046 35.6518 10.0613 35.2222 10.0613C34.7926 10.0613 34.4444 9.70046 34.4444 9.25528C34.4444 8.8101 34.7926 8.44922 35.2222 8.44922C35.6518 8.44922 36 8.8101 36 9.25528Z" fill="white"/>
                        <path d="M41 12.0415V5H42.0043V6.20582C42.2256 5.74699 42.5439 5.40287 42.9589 5.17346C43.374 4.94404 43.8398 4.82934 44.3563 4.82934C46.1356 4.82934 47 5.73969 47 7.49854V11.9985H46V7.4676C46 6.73156 46.1419 6.71837 45.856 6.37424C45.57 6.03012 44.9928 5.77567 44.3563 5.77567C43.6461 5.77567 43.0385 5.91542 42.605 6.37424C42.1807 6.82351 42.0043 7.13304 42.0043 7.89775V12.0415H41Z" fill="white"/>
                        <path d="M8.01083 0H7.98917C3.57687 0 0 3.58174 0 8.00001C0 12.4183 3.57687 16 7.98917 16H8.01083C12.4231 16 16 12.4183 16 7.99999C16 3.58172 12.4231 0 8.01083 0Z" fill="#4278FF"/>
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M4.01672 11.9865V4.01343H4.96206V5.41195C5.11236 5.17815 5.16756 5.05205 5.5696 4.80807C6.31117 4.34989 7.25275 4.01343 8.60219 4.01343C9.95162 4.01343 10.7837 4.4373 11.3763 5.06267C11.7783 5.51881 11.9793 6.2047 11.9793 7.17004V11.9865H11.0574L11.3612 10.4271C11.1501 10.9151 10.8335 11.297 10.4114 11.5728C9.99926 11.8486 9.51682 11.9865 8.96402 11.9865C8.49163 11.9865 7.86564 11.908 7.48371 11.7065C7.10177 11.5049 6.70416 11.2231 6.49843 10.89C6.29267 10.5569 6.11294 10.0202 6.11433 9.59768C6.11571 9.17521 6.22688 8.58511 6.49843 8.15069C6.76998 7.71629 7.20304 7.22862 8.08489 7.03181C8.90938 6.71854 10.0121 6.74733 11.0574 7.13524V6.82197C11.0574 6.21384 11.0373 5.99582 10.7559 5.64574C10.1633 4.90857 9.35087 4.92766 8.30199 4.92766C7.25309 4.92766 6.11629 5.11146 5.31275 5.97974C4.90067 6.43588 4.96206 6.81468 4.96206 7.56786V11.9865H4.01672ZM10.0221 11.0318C9.68031 11.2652 9.29871 11.3818 8.83638 11.3818C8.46898 11.3818 7.95876 11.2438 7.58496 10.89C7.21117 10.5362 7.09265 10.1069 7.09265 9.59768C7.09265 9.18395 7.18124 8.8621 7.40927 8.49376C7.63729 8.12541 8.00139 7.97619 8.71948 7.8501C9.43756 7.724 10.2224 7.7332 11.0574 8.02952V8.61828C11.0574 9.13808 10.9569 9.6474 10.7559 10.0611C10.5549 10.4642 10.3738 10.7878 10.0221 11.0318Z" fill="white"/>
                        <path d="M10.1093 9.31756C10.1093 9.75136 9.77612 10.103 9.36512 10.103C8.95411 10.103 8.62091 9.75136 8.62091 9.31756C8.62091 8.88375 8.95411 8.5321 9.36512 8.5321C9.77612 8.5321 10.1093 8.88375 10.1093 9.31756Z" fill="white"/>
                        </svg>
                </div>

                <div id='aboutGeneratorLogo'>
                    <svg width="50" height="25" viewBox="0 0 50 25" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M31.7883 8.10361C31.5684 7.46198 31.265 6.88767 30.878 6.3807C30.4997 5.86581 30.0423 5.42617 29.5058 5.06179C28.978 4.6974 28.3711 4.42411 27.685 4.24192C26.9989 4.05181 26.2512 3.95675 25.442 3.95675C23.9907 3.95675 22.6976 4.28549 21.5629 4.94297C20.4283 5.60044 19.5355 6.56686 18.8846 7.8422C18.2424 9.10963 17.9214 10.6543 17.9214 12.4762C17.9214 14.314 18.2424 15.8706 18.8846 17.1459C19.5267 18.4213 20.4195 19.3916 21.5629 20.057C22.7064 20.7145 24.0346 21.0433 25.5476 21.0433C26.9197 21.0433 28.1072 20.8056 29.11 20.3303C30.1215 19.855 30.8999 19.1817 31.4453 18.3104C31.9907 17.4311 32.2633 16.4013 32.2633 15.221L33.3716 15.3755H26.0357V11.9297H37V14.8527C37 16.936 36.5074 18.7381 35.5223 20.259C34.5371 21.7799 33.1825 22.9523 31.4585 23.7761C29.7345 24.592 27.7554 25 25.5212 25C23.0319 25 20.8461 24.497 18.9637 23.491C17.0902 22.477 15.6256 21.0393 14.5701 19.1778C13.5234 17.3083 13 15.0903 13 12.5238C13 10.5593 13.3079 8.80466 13.9236 7.25998C14.5481 5.71531 15.4189 4.40431 16.536 3.327C17.6531 2.24176 18.9637 1.41793 20.4678 0.855513C21.972 0.285171 23.608 0 25.376 0C26.8714 0 28.2655 0.198035 29.5586 0.594106C30.8516 0.982256 31.9995 1.53676 33.0022 2.25761C34.0137 2.97845 34.845 3.83397 35.4959 4.82414C36.1468 5.81432 36.5734 6.90748 36.7757 8.10361H31.7883Z" fill="white"/>
                        <path d="M50 12.5C50 14.9853 47.9853 17 45.5 17C43.0147 17 41 14.9853 41 12.5C41 10.0147 43.0147 8 45.5 8C47.9853 8 50 10.0147 50 12.5Z" fill="white"/>
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M4.5 16C6.433 16 8 14.433 8 12.5C8 10.567 6.433 9 4.5 9C2.567 9 1 10.567 1 12.5C1 14.433 2.567 16 4.5 16ZM4.5 17C6.98528 17 9 14.9853 9 12.5C9 10.0147 6.98528 8 4.5 8C2.01472 8 0 10.0147 0 12.5C0 14.9853 2.01472 17 4.5 17Z" fill="white"/>
                        </svg>
                </div>

                <div id='aboutVersion'>version  _</div>

                <p id='aboutLine'><div id='aboutCopyright'> 2023&nbsp;&hairsp;Alex Bourt</div></p>
                
                <!-- <p><div id='chkAboutHideWhatsNew'></div></p> -->
            </div>
        </div>
    </div>

</div>



<div id='crashBack'></div>

<div id='crashDialog'>
    
    <div id='crashDialogContainer'>
        <div id='crashDialogContent'>
            <div id='crashDialogBody'>
                <p id='crashTitle'>Generator has experienced an error</p>
                <p id='crashDetails'></p>
            </div>
        </div>
        <div class='btnRestart' id='btnCrashRestart'>Restart in debug mode</div>
    </div>

</div>



<div id='whatsNewBack'></div>

<div id='whatsNewDialog'>
    
    <div id='whatsNewTitle'>
        <div id='whatsNewTitleText'>Version _</div>
        <div class='panelButton dialogButtonClose' id='whatsNewClose' onclick='hideAllMenus(); whatsNewClose.blur(); hideWhatsNewDialog();'>
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M16 15.293L20.6465 10.6465L21.3536 11.3536L16.7071 16.0001L21.3536 20.6465L20.6465 21.3536L16 16.7072L11.3536 21.3536L10.6465 20.6465L15.2929 16.0001L10.6465 11.3537L11.3536 10.6466L16 15.293Z" fill="var(--figma-color-text)" fill-opacity="0.8"/>
            </svg>
        </div>
    </div>
    
    <div id='whatsNewDialogContainer'>
        <div id='whatsNewDialogContent'>
            <div id='whatsNewWatermark'><span style="font-weight: 700; position: relative; top: 0.06em;">G</span></div>

            <div id='whatsNewBody'>
                <h1 style='margin-top: 20px;'>What's new in Generator</h1>

                <p>fixed wrong invalid colors assigned to styles</p>
                <p>fixed Mac shortcuts</p>
                <p>adjusting color controls with arrow keys now supports undo</p>
                <p>unsupported inputs/outputs are now hidden while connecting</p>
                <p>added a right-click copy menu to the crash dialog</p>
                <p>replaced restart checkboxes with buttons</p>
                <p>fixed many UI issues</p>
                
                <p><br/><br/><div id='chkHideWhatsNew'></div></p>
            </div>
        </div>
        <div class='dialogScrollbar' id='whatsNewScrollbarY'></div>
    </div>

</div>


<div id='keyboardPanel'>

    <div id='keyboardPanelTabsHolder'>
        <div id='keyboardPanelTabs'>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(0);">Menu</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(1);">Zoom</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(2);">Selection</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(3);">Nodes</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(4);">Connections</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(5);">Cursor</div>
            <div id='keyboardPanelTab' onclick="setCurrentKeyboardTab(6);">Edit</div>
        </div>
        <div id='keyboardPanelClose' onclick="hideKeyboardPanel();"></div>
    </div>
    
    <div id='keyboardPanelContent'>


        <div class='keyboardPage' id='keyboardPageMenu'>
            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Keep menu open</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey'>click</div></div></div></div>
                <div class='keyboardShortcut'></div>
                <div class='keyboardInfo'>Click a node menu to create a node under<br/>the menu button. Drag the menu to directly<br/>move the new node.</div>
            </div>
            <div class='keyboardGroup nextGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Create node</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Menu</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Insert node into branch</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey'>menu</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Connect node in new branch</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey newBranch1'>Ctrl</div><div class='shortcutKey newBranch2'>Alt</div><div class='shortcutKey'>menu</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Create random color</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Alt</div><div class='shortcutKey'>Color menu</div></div></div></div>
            </div>
        </div>


        <div class='keyboardPage' id='keyboardPageZoom'>

            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Pan</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Space</div><div class='shortcutKey'>drag</div></div></div></div>
                <div class='keyboardLabel'>While not using the hand tool...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey'>wheel</div></div></div></div>
                <div class='keyboardLabel'>While using the hand tool...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Wheel</div></div></div></div>
            </div>

            <div class='keyboardGroup nextGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom in</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>+</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom out</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'></div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to 100%</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>0</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to fit</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey shortcutCharNarrow'>1</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to selection</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey shortcutChar'>2</div></div></div></div>
            </div>

        </div>


        <div class='keyboardPage' id='keyboardPageSelection'>

            <!-- <div class='keyboardGroup'>
                <div class='keyboardLabel'>While selecting...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom to selection</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Zoom out from selection</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey'>Alt</div></div></div></div>
            </div> -->

            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select all</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>A</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select inverse</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>A</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select none</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Esc</div></div></div></div>
            </div>

            <div class='keyboardGroup nextGroup'>
                <!-- <div class='keyboardShortcut'><div class='shortcutAction'>Toggle selected</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Shift</div><div class='shortcutKey'>click</div></div></div></div> -->
                <div class='keyboardShortcut'><div class='shortcutAction'>Select tree left</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift treeLeftCtrl'>Shift</div><div class='shortcutKey'>click</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select tree right</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey treeRightCtrl1'>Alt</div><div class='shortcutKey treeRightCtrl2'>Shift</div><div class='shortcutKey'>click</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select tree across</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey treeAcross1'>Ctrl</div><div class='shortcutKey treeAcross2'>Alt</div><div class='shortcutKey'>click</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Select entire tree</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey'>Alt</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey'>click</div></div></div></div>
            </div>

        </div>


        <div class='keyboardPage' id='keyboardPageNodes'>
            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Enable/disable</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>E</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Show/hide operation results</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>R</div></div></div></div>
            </div>
        </div>
 

        <div class='keyboardPage' id='keyboardPageConnections'>
            <div class='keyboardGroup'>
                <div class='keyboardLabel'>While connecting from an output...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Copy input value back to output</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div></div></div></div>
            </div>
        </div>

        
        <div class='keyboardPage' id='keyboardPageCursor'>
            <div class='keyboardGroup'>
                <div class='keyboardLabel'>While adjusting (some) values...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Allow values outside the visible limits</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div></div></div></div>
            </div>
            <div class='keyboardGroup nextGroup'>
                <div class='keyboardLabel'>While hovering over a node...</div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Isolate the node and its connections</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Alt</div></div></div></div>
            </div>
        </div>

        
        <div class='keyboardPage' id='keyboardPageEdit'>
            <div class='keyboardGroup'>
                <div class='keyboardShortcut'><div class='shortcutAction'>Copy</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>C</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Cut</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>X</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Paste</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>V</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Paste with input connections</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>V</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Remove from branch</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutCharWide'></div></div></div></div>
            </div>
            <div class='keyboardGroup nextGroup'>
                <div id='shortcutCopyAsJavascript' class='keyboardShortcut'><div class='shortcutAction'>Copy as Javascript</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>C</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Duplicate</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey'>Ctrl</div><div class='shortcutKey shortcutChar'>D</div></div></div></div>
                <div class='keyboardShortcut'><div class='shortcutAction'>Duplicate with input connections</div><div class='shortcutKeys'><div class='shortcutKeys'><div class='shortcutKey ctrlShift'>Ctrl</div><div class='shortcutKey ctrlShift'>Shift</div><div class='shortcutKey shortcutChar'>D</div></div></div></div>
            </div>
        </div>
    
    
    </div>

</div>


<span id='tooltipArrow'></span>



<div id='ttColorblind' class='tooltip'>

    <div style='margin-top: 10px; margin-bottom: 10px;'>
        Three receptor types in our eyes see<br/>
        <i>three calibers of light</i>&ThinSpace;:<br/><br/>
        <p style='margin-top: 4px; margin-bottom: 20px;'><b>S</b>mall, <b>M</b>edium and <b>L</b>arge.</p>
    </div>

    <svg width="187" height="97" viewBox="0 0 187 97" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M64.3525 17.3547C63.1278 17.3547 62.0721 1.13879 60.8053 1.13879C59.5384 1.13879 58.4827 17.3547 57.258 17.3547" stroke="white"/>
        <path d="M84.3644 10.4618C83.8577 8.49826 82.9076 1.13879 82.0886 1.13879C80.8217 1.13879 79.766 17.3547 78.5414 17.3547" stroke="white"/>
        <path d="M78.5414 17.3547C77.3167 17.3547 76.261 1.13879 74.9942 1.13879C73.7273 1.13879 72.6716 17.3547 71.4469 17.3547" stroke="white"/>
        <path d="M71.4469 17.3547C70.2223 17.3547 69.1666 1.13879 67.8997 1.13879C66.6328 1.13879 65.5771 17.3547 64.3525 17.3547" stroke="white"/>
        <path d="M35.9747 17.3547C34.75 17.3547 33.6943 1.13879 32.4274 1.13879C31.1606 1.13879 30.1049 17.3547 28.8802 17.3547" stroke="white"/>
        <path d="M57.258 17.3547C56.0334 17.3547 54.9776 1.13879 53.7108 1.13879C52.4439 1.13879 51.3882 17.3547 50.1635 17.3547" stroke="white"/>
        <path d="M50.1636 17.3547C48.9389 17.3547 47.8832 1.13879 46.6163 1.13879C45.3495 1.13879 44.2938 17.3547 43.0691 17.3547" stroke="white"/>
        <path d="M43.0691 17.3547C41.8445 17.3547 40.7887 1.13879 39.5219 1.13879C38.255 1.13879 37.1993 17.3547 35.9746 17.3547" stroke="white"/>
        <path d="M7.59684 17.3547C6.3722 17.3547 5.31647 1.13879 4.04961 1.13879C2.78274 1.13879 1.72702 17.3547 0.50238 17.3547" stroke="white"/>
        <path d="M28.8802 17.3547C27.6556 17.3547 26.5998 1.13879 25.333 1.13879C24.0661 1.13879 23.0104 17.3547 21.7857 17.3547" stroke="white"/>
        <path d="M21.7857 17.3547C20.5611 17.3547 19.5054 1.13879 18.2385 1.13879C16.9716 1.13879 15.9159 17.3547 14.6913 17.3547" stroke="white"/>
        <path d="M14.6913 17.3547C13.4666 17.3547 12.4109 1.13879 11.144 1.13879C9.87716 1.13879 8.82144 17.3547 7.5968 17.3547" stroke="white"/>
        <path d="M26.1023 49.8573C21.6833 49.8573 17.8738 28.2361 13.3023 28.2361C8.73093 28.2361 4.92142 49.8573 0.50238 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M97.2868 40.4082C95.3801 36.1644 93.2103 28.2361 90.1022 28.2361C85.5307 28.2361 81.7212 49.8573 77.3022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M77.3021 49.8573C72.8831 49.8573 69.0736 28.2361 64.5022 28.2361C59.9308 28.2361 56.1212 49.8573 51.7022 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M51.7022 49.8573C47.2832 49.8573 43.4737 28.2361 38.9023 28.2361C34.3308 28.2361 30.5213 49.8573 26.1023 49.8573" stroke="white" stroke-width="1.5"/>
        <path d="M130.23 95.5318C119.033 95.5318 109.381 65.8027 97.7978 65.8027C86.215 65.8027 76.5627 95.5318 65.366 95.5318" stroke="white" stroke-width="2"/>
        <path d="M65.366 95.5318C54.1693 95.5318 44.517 65.8027 32.9342 65.8027C21.3514 65.8027 11.6991 95.5318 0.50238 95.5318" stroke="white" stroke-width="2"/>
        <path d="M133.608 95.8832C142.385 95.8832 149.5 88.7683 149.5 79.9916C149.5 71.2149 142.385 64.1 133.608 64.1C124.831 64.1 117.716 71.2149 117.716 79.9916C117.716 88.7683 124.831 95.8832 133.608 95.8832Z" stroke="white" stroke-width="1.5"/>
        <path d="M133.608 95.8832C142.385 95.8832 149.5 88.7683 149.5 79.9916C149.5 71.2149 142.385 64.1 133.608 64.1C124.831 64.1 117.716 71.2149 117.716 79.9916C117.716 88.7683 124.831 95.8832 133.608 95.8832Z" stroke="white" stroke-width="1.5"/>
        <path d="M133.608 95.8832C142.385 95.8832 149.5 88.7683 149.5 79.9916C149.5 71.2149 142.385 64.1 133.608 64.1C124.831 64.1 117.716 71.2149 117.716 79.9916C117.716 88.7683 124.831 95.8832 133.608 95.8832Z" stroke="white" stroke-width="1.5"/>
        <path d="M173 52C180.18 52 186 46.1797 186 39C186 31.8203 180.18 26 173 26C165.82 26 160 31.8203 160 39C160 46.1797 165.82 52 173 52Z" stroke="white" stroke-width="1.5"/>
        <path d="M105.364 46.8303C109.663 46.8303 113.148 43.3454 113.148 39.0467C113.148 34.7479 109.663 31.2631 105.364 31.2631C101.065 31.2631 97.5804 34.7479 97.5804 39.0467C97.5804 43.3454 101.065 46.8303 105.364 46.8303Z" stroke="white" stroke-width="1.5"/>
        <path d="M105.364 46.8303C109.663 46.8303 113.148 43.3454 113.148 39.0467C113.148 34.7479 109.663 31.2631 105.364 31.2631C101.065 31.2631 97.5804 34.7479 97.5804 39.0467C97.5804 43.3454 101.065 46.8303 105.364 46.8303Z" stroke="white" stroke-width="1.5"/>
        <path d="M105.364 46.8303C109.663 46.8303 113.148 43.3454 113.148 39.0467C113.148 34.7479 109.663 31.2631 105.364 31.2631C101.065 31.2631 97.5804 34.7479 97.5804 39.0467C97.5804 43.3454 101.065 46.8303 105.364 46.8303Z" stroke="white" stroke-width="1.5"/>
        <path d="M173 46C176.866 46 180 42.866 180 39C180 35.134 176.866 32 173 32C169.134 32 166 35.134 166 39C166 42.866 169.134 46 173 46Z" stroke="white" stroke-width="1.5"/>
        <path d="M86.3783 12.7566C87.6918 12.7566 88.7566 11.6918 88.7566 10.3783C88.7566 9.06481 87.6918 8 86.3783 8C85.0648 8 84 9.06481 84 10.3783C84 11.6918 85.0648 12.7566 86.3783 12.7566Z" fill="white"/>
        <path d="M173 41C174.105 41 175 40.1046 175 39C175 37.8954 174.105 37 173 37C171.895 37 171 37.8954 171 39C171 40.1046 171.895 41 173 41Z" fill="white"/>
    </svg>
                                                                                      
    <div style='margin-top: 20px; margin-bottom: -5px;'>
        If one or more are defective or absent,<br/>
        we call that <i>color blindness</i>.
    </div>
       
    <div style='margin-top: 16;'>
        Set the condition of each cone type<br/>
        to simulate types of color vision deficiency.
    </div>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorBlindness' onclick="updateSettingAndMenu('showTooltipColorBlindness', true, false); hideTooltip(ttColorblind);">Don't show</div></div>
</div>


<div id='ttToggleWires' class='tooltip'>Show&thinsp;/&thinsp;hide wires</div>


<div id='ttInterpolationSpace' class='tooltip'>

    <div style="margin-left: 7px;" id="ttInterpolationSpaces">
    </div>
    <div style="margin-left: 7px; margin-top: 7px;">
        Determines the interpolation path.
    </div>
    <div style="margin-left: 7px; margin-top: 7px;">
        In RGB and linear spaces<br/>it's a straight line,<br/><br/>
        in spaces with a Hue it's an arc around the center.
    </div>

    <div style="position: absolute; left:  44px; top: 126px;">Luv</div>
    <div style="position: absolute; left:  44px; top: 146px;">Lab</div>
    <div style="position: absolute; left:  42px; top: 176px;">RGB</div>

    <div style="position: absolute; left: 147px; top: 133px;">HSV</div>
    <div style="position: absolute; left: 147px; top: 153px;">HCL</div>

    <svg width="192" height="88" viewBox="0 0 192 88" fill="none" xmlns="http://www.w3.org/2000/svg" style="margin-top: 11px;">
        <circle cx="43.945" cy="43.6699" r="42.9129" transform="rotate(164.053 43.945 43.6699)" stroke="white"/>
        <circle cx="148.459" cy="43.6699" r="42.9129" transform="rotate(164.053 148.459 43.6699)" stroke="white"/>
        <path d="M177.161 53.8683C175.042 59.8328 171.117 64.9889 165.932 68.6199C160.747 72.2509 154.56 74.1764 148.23 74.1287C141.9 74.081 135.743 72.0626 130.613 68.3539C125.484 64.6453 121.637 59.4307 119.607 53.4349" stroke="white" stroke-width="0.8" stroke-dasharray="2 2"/>
        <circle cx="16.6584" cy="54.5167" r="2.79505" transform="rotate(164.053 16.1584 54.5167)" fill="white"/>
        <circle cx="71.0077" cy="54.5167" r="2.79505" transform="rotate(164.053 71.5077 54.4231)" fill="white"/>
        <circle cx="121.173" cy="54.5167" r="2.79505" transform="rotate(164.053 120.673 54.5167)" fill="white"/>
        <circle cx="175.522" cy="54.5167" r="2.79505" transform="rotate(164.053 176.022 54.4231)" fill="white"/>
        <line x1="72.3693" y1="54.0053" x2="15.8716" y2="54.0053" stroke="white" stroke-dasharray="2 2"/>
    </svg>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorInterpolationlindness' onclick="updateSettingAndMenu('showTooltipColorInterpolation', true, false); hideTooltip(ttInterpolationSpace);">Don't show</div></div>
</div>


<div id='ttMinValueZoom' class='tooltip'></div>


<!-- <div id='ttInterpolationGamma' class='tooltip'>
    <div style="text-align: center;">Gamma correction</div>              
    <div style="margin-top: 14px;">How linearly the lightness is interpolated.</div>
</div> -->


<div id='ttWcag2' class='tooltip'>

    <!-- <div style='text-align: center;'>Contrast ratio</div> -->
    
    <div class='wcag2description' style='left: 50px;'>min. normal  </div>
    <div class='wcag2description' style='left: 71px;'>min. reduced </div>
    <div class='wcag2description' style='left: 93px;'>min. assisted</div>
    <div class='wcag2description' style='left: 115px;'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vision</div>

    <svg width="221" height="21" viewBox="0 0 221 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 20px; top: 77px">
        <path d="M220.452 20.2466H70.0214V10.7924H220.452V20.2466Z" fill="white" fill-opacity="0.4"/>
        <path d="M30.0214 0V20.2466" stroke="white"/>
        <path d="M45.0214 0V20.2466" stroke="white"/>
        <path d="M70.0214 0V20.2466" stroke="white"/>
        <path d="M30.0214 10.7924H0.0213623V20.2465H30.0214V10.7924Z" fill="#FF3232" fill-opacity="0.5"/>
        <path d="M45.0214 10.7924H30.0214V20.2465H45.0214V10.7924Z" fill="#FFFF36" fill-opacity="0.55"/>
        <path d="M70.0214 10.7924H45.0214V20.2465H70.0214V10.7924Z" fill="#4FFE15" fill-opacity="0.5"/>
    </svg>
                
    <div class='wcag2value' style='left:  18px;'> 0  </div>
    <div class='wcag2value' style='left:  48px;'> 3  </div>
    <div class='wcag2value' style='left:  68px;'> 4.5</div>
    <div class='wcag2value' style='left:  90px;'> 7  </div>
    <div class='wcag2value' style='left: 239px;'>21  </div>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorContrast2' onclick="updateSettingAndMenu('showTooltipColorContrast', true, false); hideTooltip(ttWcag2);">Don't show</div></div>
    <!-- <div id='wcag2info'><a href='https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast7.html#visual-audio-contrast7-87-head' target='_blank'>More details</a></div> -->
</div>


<div id='ttWcag3' class='tooltip'>

    <!-- <div style='text-align: center;'>APCA visual contrast</div> -->
    
    <div class='wcag3description' style='left:  52px;'>discernible</div>
    <div class='wcag3description' style='left:  84px;'>minimum</div>
    <div class='wcag3description' style='left: 117px;'>large text</div>
    <div class='wcag3description' style='left: 148px;'>other text</div>
    <div class='wcag3description' style='left: 179px;'>body text</div>
    <div class='wcag3description' style='left: 211px;'>all text</div>

    <svg width="222" height="21" viewBox="0 0 222 21" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 19px; top: 65px">
        <rect x="0.854492" y="10.7924" width="31.5139" height="9.45416" fill="#FF0040" fill-opacity="0.5"/>
        <rect x="32.3684" y="10.7924" width="31.5139" height="9.45416" fill="#FF7048" fill-opacity="0.5"/>
        <rect x="63.8822" y="10.7924" width="31.5139" height="9.45416" fill="#FFB92F" fill-opacity="0.5"/>
        <rect x="95.3961" y="10.7924" width="31.5139" height="9.45416" fill="#FFFF36" fill-opacity="0.5"/>
        <rect x="126.91" y="10.7924" width="31.5139" height="9.45416" fill="#4FFE15" fill-opacity="0.5"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 158.424 20.2466)" fill="#7070FF" fill-opacity="0.7"/>
        <rect width="31.5139" height="9.45416" transform="matrix(1 0 0 -1 189.938 20.2466)" fill="white" fill-opacity="0.4"/>
        <line x1="32.8684" x2="32.8684" y2="20.2466" stroke="white"/>
        <line x1="64.3822" x2="64.3822" y2="20.2466" stroke="white"/>
        <line x1="95.8961" x2="95.8961" y2="20.2466" stroke="white"/>
        <line x1="127.41" x2="127.41" y2="20.2466" stroke="white"/>
        <line x1="158.924" x2="158.924" y2="20.2466" stroke="white"/>
        <line x1="190.438" x2="190.438" y2="20.2466" stroke="white"/>
    </svg>

    <div class='wcag3value' style='left:  20px;'>  0</div>
    <div class='wcag3value' style='left:  52px;'> 15</div>
    <div class='wcag3value' style='left:  84px;'> 30</div>
    <div class='wcag3value' style='left: 114px;'> 45</div>
    <div class='wcag3value' style='left: 147px;'> 60</div>
    <div class='wcag3value' style='left: 179px;'> 75</div>
    <div class='wcag3value' style='left: 210px;'> 90</div>
    <div class='wcag3value' style='left: 239px;'>105</div>

    <div class='tooltipBottom'><div class='ignoreButton' id='ignoreColorContrast3' onclick="updateSettingAndMenu('showTooltipColorContrast', true, false); hideTooltip(ttWcag3);">Don't show</div></div>
    <!-- <div id='wcag3info'><a href='https://www.myndex.com/APCA/#font-size-and-weight' target='_blank'>More details</a></div> -->
</div>



<div id='ttText' class='tooltip'>
    <div id='ttTextString'>This is a text string.</div>
    <!-- <div class='tooltipBottom' id='tooltipTextBottom'><div class='ignoreButton' id='ignoreText' onclick="updateSettingAndMenu('showTooltipLongText', true, false); hideTooltip(ttText);">Don't show</div></div> -->
</div>


<script id='generatorScript' type='javascript/worker'>
'use strict';




const generatorVersion = 132;


const MAX_INT32        = 2147483647;
  
const NULL             = '';
  
const HTAB             = '  '; // half-tab
const TAB              = '    ';
const NL               = '\n';
  
const GENERATOR_LOGO   = 'G';
const OBJECT_PREFIX    = 'G';
  
const nodeTag          = 'G_NODE';
const connTag          = 'G_CONN';
const pageTag          = 'G_PAGE';



function toInt(f) { return Math.floor(f) | 0; }



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >>  1;
    x |= x >>  2;
    x |= x >>  4;
    x |= x >>  8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function gcd(a, b)
{
    let temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function charCodeArrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function stringToCharCodeArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    const newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    const size = Math.min(srcSize, dstSize);

    for (let i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function arraysAreEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (let i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function arraysIntersect(array1, array2)
{
    return array1.findIndex(i => array2.includes(i)) > -1;
}



function  leftArrowChar(list) { return list ? '' : ''; }
function rightArrowChar(list) { return list ? '' : ''; }

function nodeNameForStorage(nodeId) { return nodeTag + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag + ' ' + name;   }
function pageNameForStorage(name)   { return pageTag + ' ' + name;   }



function parseBool(str) 
{ 
    return str.toLowerCase() == 'true'
        || str == '1';
}



function connToString(_conn, logSpace = false)
{
    return getConnectionString(
        _conn.outputNodeId,
        _conn.outputId,
        _conn.outputOrder,
        _conn.inputNodeId,
        _conn.inputId,
        _conn.list,
        logSpace);
}



function getConnectionKey(outputNodeId, outputId, outputOrder, inputNodeId, inputId)
{
    return connNameForStorage(
          outputNodeId + ' '
        + outputId     + ' '
        + outputOrder  + ' '
        + inputNodeId  + ' '
        + inputId);
}



function getStorageConnKey(conn)
{
    return getConnectionKey(
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId);
}



function getConnKey(conn)
{
    return getConnectionKey(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id);
}



function getConnString(conn, logSpace = false)
{
    return getConnectionString(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id,
        conn.list,
        logSpace);
}



function getConnectionString(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, logSpace = false)
{
    const  sp   = logSpace ? ' ' : ''; 
    const jsp   = logSpace ? ''  : ''; 

    const arrow = 
          sp 
        + subscriptNumber(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder) 
        + rightArrowChar(typeof list == 'string' ? parseBool(list) : list) 
        + sp;

    const join  = jsp + '.' + jsp;

    return '('
         + outputNodeId + join + outputId
         + arrow
         + inputNodeId  + join + inputId
         + ')';
}



function getPageKey(pageId)
{
    return pageNameForStorage(pageId);
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return '';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return ' ';
    }
}



function boolToString(bool)
{
    return bool ? 'true' : 'false';
}



function isValid(val)
{
    return val != undefined
        && val != null;
}



function isEmpty(array)
{
    return array.length == 0;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (isEmpty(array))
        return null;

    let last = array.at(-1);
    array.splice(array.length-1, 1)

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}



function removeFromArray(array, item)
{
    const index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeArrayFromArray(fromArray, array)
{
    for (const item of array)
    {
        const index = fromArray.indexOf(item);
        
        if (index > -1)
            fromArray.splice(index, 1);
    }
}



function removeFromArrayWhere(array, where)
{
    const index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function cleanStyleId(styleId)
{
    return styleId.split(',')[0] + ',';
}



function rgbFromType(type, active)
{
    return rgbFromTypeMode(type, active, darkMode);
}



function rgbFromTypeMode(type, active, mode)
{
    if (FLOW_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
        : (mode ? rgbFlowDark         : rgbFlowLight      );

    if (NUMBER_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveNumberDark : rgbActiveNumberLight)
        : (mode ? rgbNumberDark       : rgbNumberLight      );

    if (TEXT_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveTextDark   : rgbActiveTextLight)
        : (mode ? rgbTextDark         : rgbTextLight      );

    if (type == COLOR_STYLE)
        return active 
        ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
        : (mode ? rgbFlowDark         : rgbFlowLight      );

    if (SHAPE_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveShapeDark  : rgbActiveShapeLight)
        : (mode ? rgbShapeDark        : rgbShapeLight      );

    if (GROUP_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveGroupDark  : rgbActiveGroupLight)
        : (mode ? rgbGroupDark        : rgbGroupLight      );

        
    switch (type)
    {
        case COLOR_VALUE:           

        case COLOR:           
        case COLOR_INTERPOLATE:
        case CORRECT_COLOR:
        case COLOR_CONTRAST:
        case COLORBLIND:
        case COLOR_BLEND:
            return active 
                 ? rgbActiveColor  
                 : rgbColor;
    }

    return 'magenta';
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


const Epsilon = 0.0000001;



function nozero(x)
{
    return x != 0 ? x : Epsilon;
}



function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function isSimpleLatinLetter(c)
{
    return c >= 'a' && c <= 'z'
        || c >= 'A' && c <= 'Z';
}


function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     lst str = Number(num).toFixed(dec).toString();

//     let i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function getQueryVariable(strVar)
{
    const query = window.location.search.substring(1);
    const vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function equal(a, b, eps = Epsilon)
{
    return Math.abs(b - a) < eps;
}



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function ceilTo(x, dec)
{
    const div = Math.ceil(Math.pow(10, dec));
    return Math.ceil((x + Number.EPSILON) * div) / div;    
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function distance(p1, p2)
{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1v2 = v1v2sin "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 22 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    const m = [[0, 0, 0],
               [0, 0, 0],
               [0, 0, 0]];

    for (let i = 0; i < 3; i++)
    {
        for (let j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (let k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



// function ipow(n, e)
// {
//     let res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    let carry = 0n;
    
    // multiply individual digits of res[] by n
    for (let i = 0; i < resSize; i++) 
    {
        const prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    const num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    let d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (let i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    let val = 0;
    let mul = 1;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function lerp3(f0, f1, f2, f3, t)
{
    const c0  = lerp(f0, f1, t);
    const c1  = lerp(f1, f2, t);
    const c2  = lerp(f2, f3, t);

    const c01 = lerp(c0, c1, t);
    const c12 = lerp(c1, c2, t);

    return lerp(c01, c12, t);
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function unit(v)
{
    return v.X != 0 
        || v.Y != 0
        ? mulvs(v, 1 / lengthv(v))
        : point(0, 0);
}



function lerpv(p0, p1, t)
{
    return point(
        lerp(p0.x, p1.x, t),
        lerp(p0.y, p1.y, t));
}



function lerpv3(p0, p1, p2, p3, t)
{
    return point(
        lerp3(p0.x, p1.x, p2.x, p3.x, t),
        lerp3(p0.y, p1.y, p2.y, p3.y, t));
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        const r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        const r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    const t0 = 0;
    const t1 = 1;

    const dx = x2 - x1;
    const dy = y2 - y1;

    const cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    const cr = clipEdge( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    const ct = clipEdge(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    const cb = clipEdge( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    const v1 = subv(p2, p1);
    const v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    const t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    const t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    const d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    const xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectInside(rect1, rect2)
{
    return rect1.l >= rect2.l
        && rect1.r <= rect2.r
        && rect1.t >= rect2.t
        && rect1.b <= rect2.b; 
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


function bezierTangent(x0, y0, x1, y1, x2, y2, x3, y3, t)
{
    const p0 = point(x0, y0);
    const p1 = point(x1, y1);
    const p2 = point(x2, y2);
    const p3 = point(x3, y3);

    return unit(addv(addv(
        mulvs(subv(p1, p0), 3*sqr(1-t)),
        mulvs(subv(p2, p1), 6*(1-t)*t)),
        mulvs(subv(p3, p2), 3*sqr(t))));
}



function positionOnSegment(p0, p1, p2, p3, arcLen, error = 0.001)
{
    const hullLength = 
          distance(p0, p1) 
        + distance(p1, p2)
        + distance(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = arcLen / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(arcLen - length) > error
        && loopProtect-- > 0)
    {
        t += (arcLen - length) / hullLength;

        halves = splitSeg(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        console.log('endless loop in positionOnSegment()');


    return t;
}



function splitSeg(p0, p1, p2, p3, t)
{
    const c0   = lerpv(p0, p1, t);
    const c1   = lerpv(p1, p2, t);
    const c2   = lerpv(p2, p3, t);
                
    const c01  = lerpv(c0, c1, t);
    const c12  = lerpv(c1, c2, t);

    const c012 = lerpv(c01, c12, t);

    return [
        [p0, c0, c01, c012],
        [c012, c12, c2, p3] ];
}



// function splitSegments(_p0, _p1, _p2, _p3, ts)
// {
//     const segments = [];


//     let p0 = _p0, 
//         p1 = _p1,
//         p2 = _p2,
//         p3 = _p3;

//     for (let i = 0; i < ts.length; i++)
//     {
//         const parts = split(p0, p1, p2, p3, ts[i]);
//         const l     = parts[0];
//         const r     = parts[1];


//         segments.push(l);


//         if (i < ts.length-1)
//         {
//             p0 = r[0];
//             p1 = r[1];
//             p2 = r[2];
//             p3 = r[3];

//             for (let j = i+1; j < ts.length; j++)
//                 ts[j] = 1 - (1 - ts[j]) / (1 - ts[i]);
//         }
//         else segments.push(r);
//     }


//     return segments;
// }



function arcLength(p0, p1, p2, p3, error = 0.0000001)
{
    const arcLen = 
          distance(p0, p1)
        + distance(p1, p2)
        + distance(p2, p3);

    const chord = distance(p0, p3);

    if ((arcLen - chord) > error)
    {
        const halves = splitSeg(p0, p1, p2, p3, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength(l[0], l[1], l[2], l[3], error)
             + arcLength(r[0], r[1], r[2], r[3], error);
    }

    return arcLen;
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    const size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (let i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    let rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    let c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    let d = x - 1n;
    let s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (let i = 0; i < k; i++)    
    {
        const a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    let x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (let j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    let val = 0n;
    let mul = 1n;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    const gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    const gcd = bigGcdExtended(m % n, n);

    const x   = gcd[1];
    const y   = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l()            { return this.x;            }
    get c()            { return this.x + this.w/2; }
    get r()            { return this.x + this.w;   }
           
    get t()            { return this.y;            }
    get m()            { return this.y + this.h/2  }
    get b()            { return this.y + this.h;   }
          
    get tl()           { return point(this.l, this.t); }
    get tc()           { return point(this.c, this.t); }
    get tr()           { return point(this.r, this.t); }
    get ml()           { return point(this.l, this.m); }
    get mc()           { return point(this.c, this.m); }
    get cm()           { return point(this.c, this.m); }
    get mr()           { return point(this.r, this.m); }
    get bl()           { return point(this.l, this.b); }
    get bc()           { return point(this.c, this.b); }
    get br()           { return point(this.r, this.b); }
      
      
    get width()        { return this.w; }
    get height()       { return this.h; }
      
    get left()         { return this.l; }
    get center()       { return this.c; }
    get right()        { return this.r; }
          
    get top()          { return this.t; }
    get middle()       { return this.m; }
    get bottom()       { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;
    last;



    constructor(seed = 0, last = seed)//(seed = 0xb9ef7ca4, last = seed)
    { 
        this.seed = seed; 
        this.last = last;
    }



    copy()
    {
        return new Random(this.seed, this.last);
    }



    next()
    {
        this.last = this.seed;
        
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



var utilCanvas;
var utilContext;
    


function initUtilContext()
{
    utilCanvas  = document.createElement('canvas');
    utilContext = utilCanvas.getContext('2d');

    utilContext.willReadFrequently = true;
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function pluralString(count, pluralChar = 's')
{
    return count == 1 ? '' : pluralChar;
}



function countString(itemName, count)
{
    const lastChar   = itemName.at(-1);
    const pluralChar = lastChar == lastChar.toUpperCase() ? 'S' : 's';

    return itemName + pluralString(count, pluralChar);
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');
    const commaIndex = strValue.indexOf(',');

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    const svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    let str = '';

    for (let i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function printNum(num)
{
    return !isNaN(num) ? num : NAN_DISPLAY;
}



function parseNum(str)
{
    return str == NAN_DISPLAY
         ? Number.NaN 
         : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function osCtrl     (plus = true) { return isMac ? ('' + (plus ? '' : '')) : ('Ctrl'  + (plus ? '+' : '')); }
function osAlt      (plus = true) { return isMac ? ('' + (plus ? '' : '')) : ('Alt'   + (plus ? '+' : '')); }
function osShift    (plus = true) { return isMac ? ('' + (plus ? '' : '')) : ('Shift' + (plus ? '+' : '')); }
function osCtrlShift(plus = true) { return isMac ? osShift(plus) + osCtrl(plus) : osCtrl(plus) + osShift(plus); }



function getCreateNodeAction(type, creatingButton, options)
{
    let node = createNode(type);

    if (isEmpty(node.headerOutputs))
        options.autoConnect = true;

    node = null;


    return !!options.insert
        &&  !options.autoConnect
           ? new CreateInsertNodeAction(type, creatingButton, options)
           : new CreateNodeAction      (type, creatingButton, options, !!options.autoConnect);
}



function simpleIntHash(x)
{
    return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32);
}



function getNewNumberId(nodes, checkExists, curId, id = curId, join = '')
{
    if (!checkExists(id))//nodes.find(n => n.id == id))
        return id;
    

    let numLength = getNumLength(id);

    if (numLength > 0)
    {
        const len = id.length - numLength;
        let   num = parseInt(id.substring(len));

        let newId = '';
        while (newId == '' || checkExists(newId))//nodes.find(n => n.id == newId))
            newId = id.substring(0, len + join.length) + join + (++num);

        return newId;
    }

    else if (numLength == 0)
    {
        let num   = 2;
        let newId = id + join + num;

        while (checkExists(newId))//nodes.find(n => 
            //    n.id != curId 
            // && n.id == newId))
            newId = id + join + (++num);

        return newId;
    }

    else
        return id;
}



function getNumLength(name)
{
    let numLength = 0;

    for (let i = name.length - 1; i >= 0; i--)
    {
        if (isDigit(name[i])) numLength++;
        else break;
    }

    return numLength;
}



"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    const inLen  = base64.length;

    const outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    const bytes = new Uint8Array(outLen);

    for (let mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    let mod3   = 2, 
        base64 = "";

    const length = bytes.length;

    for (let i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    let   str    = "";

    const length = bytes.length;

    for (let i = 0; i < length; i++) 
    {
        const byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    let strLen = str.length, 
        arrLen = 0;


    // mapping

    for (let i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    const bytes = new Uint8Array(arrLen);


    // transcription

    for (let i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        const chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function appendDivTo(div, to)
{
    if (!to.contains(div))
        to.appendChild(div);
}



function removeDivFrom(div, from)
{
    if (from.contains(div))
        from.removeChild(div);
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function createTextarea(className = '')
{
    const textarea = document.createElement('textarea');

    if (className.trim() != '')
        textarea.className = className;
    
    textarea.spellcheck = false;
    
    return textarea;
}



function enableElementText(elem, enable)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 
    elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    const elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    const e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



function offsetRect(element)
{
    return new Rect(
        element.offsetLeft,
        element.offsetTop,
        element.offsetWidth,
        element.offsetHeight);
}



function clientRect(element)
{
    return new Rect(
        element.clientLeft,
        element.clientTop,
        element.clientWidth,
        element.clientHeight);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function selectElementText(elementId)
{
    if (document.selection) // IE
    {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(elementId));
        range.select();
    }
    else if (window.getSelection) 
    {
        var range = document.createRange();
        range.selectNode(document.getElementById(elementId));
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
}



function isTouchpad(e)
{
    return Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;
}



function showElement(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hideElement(element)              
{ 
    showElement(element, false); 
}



function isVisible(element)
{
    return element.offsetParent !== null;
}



function getSelectedText(element) // only allow input[type=text] & textarea
{ 
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        return element.value.substring(
            element.selectionStart,
            element.selectionEnd);
    }
}



function clearSelectedText(element)
{
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        const str = element.value;

        element.value = 
              str.slice(0, element.selectionStart) 
            + str.slice(element.selectionEnd)
    }
}



function scrollbarVisible(element) 
{
    return element.scrollHeight > element.clientHeight;
}



function clientPos(e)
{
    return point(e.clientX, e.clientY);
}



function elementHasSelectedText(div)
{
    const selection = window.getSelection();

    if (selection.rangeCount > 0) 
    {
        const range = selection.getRangeAt(0);
        
        if (   range.commonAncestorContainer === div
            || div.contains(range.commonAncestorContainer))
        {
            const selectedText = range.toString().trim();

            if (selectedText.length > 0)
                return true;
        }
    }

    return false; 
}



function selectDivText(div)
{
    var range = document.createRange();
    range.selectNode(div);

    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);    
}


const webColors = [
    {name: 'AliceBlue',            color: 'f0f8ff'},
    {name: 'AntiqueWhite',         color: 'faebd7'},
    {name: 'Aqua',                 color: '00ffff'},
    {name: 'Aquamarine',           color: '7fffd4'},
    {name: 'Azure',                color: 'f0ffff'},
    {name: 'Beige',                color: 'f5f5dc'},
    {name: 'Bisque',               color: 'ffe4c4'},
    {name: 'Black',                color: '000000'},
    {name: 'BlanchedAlmond',       color: 'ffebcd'},
    {name: 'Blue',                 color: '0000ff'},
    {name: 'BlueViolet',           color: '8a2be2'},
    {name: 'Brown',                color: 'a52a2a'},
    {name: 'BurlyWood',            color: 'deb887'},
    {name: 'CadetBlue',            color: '5f9ea0'},
    {name: 'Chartreuse',           color: '7fff00'},
    {name: 'Chocolate',            color: 'd2691e'},
    {name: 'Coral',                color: 'ff7f50'},
    {name: 'CornflowerBlue',       color: '6495ed'},
    {name: 'Cornsilk',             color: 'fff8dc'},
    {name: 'Crimson',              color: 'dc143c'},
    {name: 'Cyan',                 color: '00ffff'},
    {name: 'DarkBlue',             color: '00008b'},
    {name: 'DarkCyan',             color: '008b8b'},
    {name: 'DarkGoldenRod',        color: 'b8860b'},
    {name: 'DarkGray',             color: 'a9a9a9'},
    {name: 'DarkGrey',             color: 'a9a9a9'},
    {name: 'DarkGreen',            color: '006400'},
    {name: 'DarkKhaki',            color: 'bdb76b'},
    {name: 'DarkMagenta',          color: '8b008b'},
    {name: 'DarkOliveGreen',       color: '556b2f'},
    {name: 'DarkOrange',           color: 'ff8c00'},
    {name: 'DarkOrchid',           color: '9932cc'},
    {name: 'DarkRed',              color: '8b0000'},
    {name: 'DarkSalmon',           color: 'e9967a'},
    {name: 'DarkSeaGreen',         color: '8fbc8f'},
    {name: 'DarkSlateBlue',        color: '483d8b'},
    {name: 'DarkSlateGray',        color: '2f4f4f'},
    {name: 'DarkSlateGrey',        color: '2f4f4f'},
    {name: 'DarkTurquoise',        color: '00ced1'},
    {name: 'DarkViolet',           color: '9400d3'},
    {name: 'DeepPink',             color: 'ff1493'},
    {name: 'DeepSkyBlue',          color: '00bfff'},
    {name: 'DimGray',              color: '696969'},
    {name: 'DimGrey',              color: '696969'},
    {name: 'DodgerBlue',           color: '1e90ff'},
    {name: 'FireBrick',            color: 'b22222'},
    {name: 'FloralWhite',          color: 'fffaf0'},
    {name: 'ForestGreen',          color: '228b22'},
    {name: 'Fuchsia',              color: 'ff00ff'},
    {name: 'Gainsboro',            color: 'dcdcdc'},
    {name: 'GhostWhite',           color: 'f8f8ff'},
    {name: 'Gold',                 color: 'ffd700'},
    {name: 'GoldenRod',            color: 'daa520'},
    {name: 'Gray',                 color: '808080'},
    {name: 'Grey',                 color: '808080'},
    {name: 'Green',                color: '008000'},
    {name: 'GreenYellow',          color: 'adff2f'},
    {name: 'HoneyDew',             color: 'f0fff0'},
    {name: 'HotPink',              color: 'ff69b4'},
    {name: 'IndianRed',            color: 'cd5c5c'},
    {name: 'Indigo',               color: '4b0082'},
    {name: 'Ivory',                color: 'fffff0'},
    {name: 'Khaki',                color: 'f0e68c'},
    {name: 'Lavender',             color: 'e6e6fa'},
    {name: 'LavenderBlush',        color: 'fff0f5'},
    {name: 'LawnGreen',            color: '7cfc00'},
    {name: 'LemonChiffon',         color: 'fffacd'},
    {name: 'LightBlue',            color: 'add8e6'},
    {name: 'LightCoral',           color: 'f08080'},
    {name: 'LightCyan',            color: 'e0ffff'},
    {name: 'LightGoldenRodYellow', color: 'fafad2'},
    {name: 'LightGray',            color: 'd3d3d3'},
    {name: 'LightGrey',            color: 'd3d3d3'},
    {name: 'LightGreen',           color: '90ee90'},
    {name: 'LightPink',            color: 'ffb6c1'},
    {name: 'LightSalmon',          color: 'ffa07a'},
    {name: 'LightSeaGreen',        color: '20b2aa'},
    {name: 'LightSkyBlue',         color: '87cefa'},
    {name: 'LightSlateGray',       color: '778899'},
    {name: 'LightSlateGrey',       color: '778899'},
    {name: 'LightSteelBlue',       color: 'b0c4de'},
    {name: 'LightYellow',          color: 'ffffe0'},
    {name: 'Lime',                 color: '00ff00'},
    {name: 'LimeGreen',            color: '32cd32'},
    {name: 'Linen',                color: 'faf0e6'},
    {name: 'Magenta',              color: 'ff00ff'},
    {name: 'Maroon',               color: '800000'},
    {name: 'MediumAquaMarine',     color: '66cdaa'},
    {name: 'MediumBlue',           color: '0000cd'},
    {name: 'MediumOrchid',         color: 'ba55d3'},
    {name: 'MediumPurple',         color: '9370db'},
    {name: 'MediumSeaGreen',       color: '3cb371'},
    {name: 'MediumSlateBlue',      color: '7b68ee'},
    {name: 'MediumSpringGreen',    color: '00fa9a'},
    {name: 'MediumTurquoise',      color: '48d1cc'},
    {name: 'MediumVioletRed',      color: 'c71585'},
    {name: 'MidnightBlue',         color: '191970'},
    {name: 'MintCream',            color: 'f5fffa'},
    {name: 'MistyRose',            color: 'ffe4e1'},
    {name: 'Moccasin',             color: 'ffe4b5'},
    {name: 'NavajoWhite',          color: 'ffdead'},
    {name: 'Navy',                 color: '000080'},
    {name: 'OldLace',              color: 'fdf5e6'},
    {name: 'Olive',                color: '808000'},
    {name: 'OliveDrab',            color: '6b8e23'},
    {name: 'Orange',               color: 'ffa500'},
    {name: 'OrangeRed',            color: 'ff4500'},
    {name: 'Orchid',               color: 'da70d6'},
    {name: 'PaleGoldenRod',        color: 'eee8aa'},
    {name: 'PaleGreen',            color: '98fb98'},
    {name: 'PaleTurquoise',        color: 'afeeee'},
    {name: 'PaleVioletRed',        color: 'db7093'},
    {name: 'PapayaWhip',           color: 'ffefd5'},
    {name: 'PeachPuff',            color: 'ffdab9'},
    {name: 'Peru',                 color: 'cd853f'},
    {name: 'Pink',                 color: 'ffc0cb'},
    {name: 'Plum',                 color: 'dda0dd'},
    {name: 'PowderBlue',           color: 'b0e0e6'},
    {name: 'Purple',               color: '800080'},
    {name: 'RebeccaPurple',        color: '663399'},
    {name: 'Red',                  color: 'ff0000'},
    {name: 'RosyBrown',            color: 'bc8f8f'},
    {name: 'RoyalBlue',            color: '4169e1'},
    {name: 'SaddleBrown',          color: '8b4513'},
    {name: 'Salmon',               color: 'fa8072'},
    {name: 'SandyBrown',           color: 'f4a460'},
    {name: 'SeaGreen',             color: '2e8b57'},
    {name: 'SeaShell',             color: 'fff5ee'},
    {name: 'Sienna',               color: 'a0522d'},
    {name: 'Silver',               color: 'c0c0c0'},
    {name: 'SkyBlue',              color: '87ceeb'},
    {name: 'SlateBlue',            color: '6a5acd'},
    {name: 'SlateGray',            color: '708090'},
    {name: 'SlateGrey',            color: '708090'},
    {name: 'Snow',                 color: 'fffafa'},
    {name: 'SpringGreen',          color: '00ff7f'},
    {name: 'SteelBlue',            color: '4682b4'},
    {name: 'Tan',                  color: 'd2b48c'},
    {name: 'Teal',                 color: '008080'},
    {name: 'Thistle',              color: 'd8bfd8'},
    {name: 'Tomato',               color: 'ff6347'},
    {name: 'Turquoise',            color: '40e0d0'},
    {name: 'Violet',               color: 'ee82ee'},
    {name: 'Wheat',                color: 'f5deb3'},
    {name: 'White',                color: 'ffffff'},
    {name: 'WhiteSmoke',           color: 'f5f5f5'},
    {name: 'Yellow',               color: 'ffff00'},
    {name: 'YellowGreen',          color: '9acd32'}
];


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        const prevActive = document.activeElement;
        const textArea   = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



function readTextFromClipboard() 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.readText();

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('paste') ? res(textArea.value) : rej();
            textArea.remove();
        });
    }
}


function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isPageKey(key) { return isTagKey(key, pageTag); }
function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noPageTag(key) { return noTag(key, pageTag); }
function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


const NAN_CHAR            = '\uFFFD';
const NAN_DISPLAY         = '?';
    
const UNKNOWN_CHAR        = '?';
const UNKNOWN_DISPLAY     = UNKNOWN_CHAR;//'';
    

const  TRUE_DISPLAY_LIGHT = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const FALSE_DISPLAY_LIGHT = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    

const  TRUE_DISPLAY_DARK  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const FALSE_DISPLAY_DARK  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';

const  TRUE_DISPLAY_MENU  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_MENU  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';



function getTrueDisplay()
{
    return darkMode
         ? TRUE_DISPLAY_DARK
         : TRUE_DISPLAY_LIGHT;
}



function getFalseDisplay()
{
    return darkMode
         ? FALSE_DISPLAY_DARK
         : FALSE_DISPLAY_LIGHT;
}


function nodeIdArrayToString(nodeIds)
{
    let str = '';

    for (let i = 0; i < nodeIds.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodeIds[i];
    }

    return str;
}



function nodeArrayToString(nodes)
{
    let str = '';

    nodes.map(n => n ? n.id : 'undefined').join(', ');

    // for (let i = 0; i < nodes.length; i++)
    // {
    //     if (i > 0) str += ', ';
    //     str += nodes[i] ? nodes[i].id : 'undefined';
    // }

    return str;
}


const INTER_STEP   = 0,
      INTER_LINEAR = 1,
      INTER_COSINE = 2,
      INTER_CUBIC  = 3;



class NoiseSeed
{
    initial;
    current;

    

    constructor()
    {
        this.reset();
    }
    


    set(seed)
    {
        this.initial = seed;
        this.current = seed;
    }    
    


    rotate()
    {
        this.current = (this.current + 0x7ed55d16) + (this.current << 12);
        this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);
        this.current = (this.current + 0x165667b1) + (this.current <<  5);
        this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);
        this.current = (this.current + 0xfd7046c5) + (this.current <<  3);
        this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);
    }    
    


    next()
    {
        const seed = this.current;
        this.rotate();
        return seed;
    }



    reset()
    {
        this.current = this.initial;
    }
};



class Noise
{
	interpolation = INTER_CUBIC;
	clip = false;

	seed = new NoiseSeed();

	v0;
	v1;
	v2;
	v3;

	step = 0;


    constructor(seed = 0)
    {
        this.seed.set(seed);
        this.reset();
    }


    next(scale = 1)
    {
        //scale = Math.pow(Phi, scale) / Phi;
        scale = Math.max(1, scale);

        let next = this.v1;

        if (this.step >= 1)
        {
            // get the next random value
        
            this.seed.rotate();

            this.v0 = this.v1;
        //------------------------
            this.v1 = this.v2;
            this.v2 = this.v3;
        //------------------------
            this.v3 = normalizeSeed(this.seed.current);

            this.step -= 1;
        }

        // get the next 'noise' value

        switch (this.interpolation)
        {
            case INTER_STEP:
            {
                next = this.v1;
                break;
            }
            case INTER_LINEAR:
            {
                next = this.v1 + this.step * (this.v2 - this.v1);
                break;
            }
            case INTER_COSINE:
            {
                const ft = this.step * Math.PI;
                const f  = (1 - Math.cos(ft)) * 0.5;
                
                next = this.v1 + f * (this.v2 - this.v1);
                break;
            }
            case INTER_CUBIC:
            {
                const p = (this.v3 - this.v2) - (this.v0 - this.v1);
                const q = (this.v0 - this.v1) - p;
                const r =  this.v2 - this.v0;
                const s =  this.v1;

                const val = 
                      p * cube(this.step) 
                    + q * sqr(this.step) 
                    + r * this.step 
                    + s;

                next = this.clip 
                    ? Math.max(0, Math.min(val, 1)) 
                    : val;

                break;
            }
        }

        this.step += 1 / scale;

        return next;
    }

   
    reset()
    {
        this.seed.reset();

        this.v0 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v1 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v2 = normalizeSeed(this.seed.current); this.seed.rotate();
        this.v3 = normalizeSeed(this.seed.current); this.seed.rotate();

        this.step = 0;
    }
}


function normalizeSeed(x)
{
    return x / -0x7fffffff;
}


const LIST_VALUE              = 'LIST#';
const LIST                    = 'LIST';

const LIST_EXPAND             = 'LEXP';

const ITEMS                   = 'ITEMS';
const SELECT                  = 'SEL';
const LIST_COUNT              = 'COUNT';
const IF_ELSE                 = 'IF';
    
const START                   = 'START';
const REPEAT                  = 'REPT';
    
const CACHE                   = 'CACHE';
const COPY                    = 'COPY';


const ANY_TYPE                = 'ANY';


const LIST_TYPES =
[
    LIST_VALUE,
    LIST,
    LIST_EXPAND,
    ITEMS,
    LIST_COUNT,
    REPEAT
];


const FOREACH                 = 'FOR';


const FLOW_TYPES =
[
    ANY_TYPE,
    ...LIST_TYPES,
    ITEMS,
    SELECT,
    IF_ELSE,
    START,
    REPEAT,
    FOREACH,
    CACHE,
    COPY
];


const NUMBER_VALUE            = 'NUM#';  
const NUMBER                  = 'NUM';   
const NUMBER_SIGN             = 'NSIGN';   
const NUMBER_ABSOLUTE         = 'ABS';   
const NUMBER_ROUND            = 'ROUND';   
const NUMBER_LIMITS           = 'LIM';   
const NUMBER_SERIES           = 'SER';  
const NUMBER_RANDOM           = 'RAND';  
const NUMBER_INTERPOLATE      = 'LERP'; 
const NUMBER_TO_TEXT          = 'N2T';
const NUMBER_SOLVE            = 'SOLVE';
const NUMBER_ANIMATE          = 'ANIM';

const NUMBER_MATH             = 'MATH';  
const NUMBER_ADD              = 'ADD';   
const NUMBER_SUBTRACT         = 'SUB';   
const NUMBER_MULTIPLY         = 'MUL';   
const NUMBER_DIVIDE           = 'DIV';   
const NUMBER_MODULO           = 'MOD';   
const NUMBER_EXPONENT         = 'EXP';

const NUMBER_BOOLEAN          = 'BOOL';  
const NUMBER_NOT              = 'NOT';
const NUMBER_AND              = 'AND';
const NUMBER_OR               = 'OR';
const NUMBER_XOR              = 'XOR';

const NUMBER_CONDITION        = 'COND';
const NUMBER_EQUAL            = 'EQ';
const NUMBER_NOT_EQUAL        = 'NE';
const NUMBER_LESS             = 'LT';
const NUMBER_LESS_OR_EQUAL    = 'LE';
const NUMBER_GREATER          = 'GT';
const NUMBER_GREATER_OR_EQUAL = 'GE';


const MATH_TYPES =
[
    NUMBER_MATH,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT
];


const BOOLEAN_TYPES =
[
    NUMBER_BOOLEAN,
    NUMBER_NOT,
    NUMBER_AND,
    NUMBER_OR,
    NUMBER_XOR
];


const CONDITION_TYPES =
[
    NUMBER_CONDITION,
    NUMBER_EQUAL,
    NUMBER_NOT_EQUAL,
    NUMBER_LESS,
    NUMBER_LESS_OR_EQUAL,
    NUMBER_GREATER,
    NUMBER_GREATER_OR_EQUAL
];


const NUMBER_TYPES =
[
    NUMBER_VALUE,
    NUMBER,
    NUMBER_SIGN,
    NUMBER_ABSOLUTE,
    NUMBER_ROUND,
    NUMBER_LIMITS,
    NUMBER_SERIES,
    NUMBER_RANDOM,
    NUMBER_INTERPOLATE,
    NUMBER_TO_TEXT,
    NUMBER_SOLVE,
    NUMBER_ANIMATE,

    ...MATH_TYPES,
    ...BOOLEAN_TYPES,
    ...CONDITION_TYPES
];


const TEXT_VALUE     = 'TEXT#';  
const TEXT           = 'TEXT';   
const TEXT_SUBSTRING = 'TSUB'; 
const TEXT_REPLACE   = 'TREPL'; 
const TEXT_JOIN      = 'TJOIN';  
const TEXT_CHAR      = 'TCHAR';
const TEXT_CSV       = 'TCSV';
const TEXT_FETCH     = 'FETCH';


const TEXT_TYPES =
[
    TEXT_VALUE,
    TEXT,
    TEXT_SUBSTRING,
    TEXT_JOIN,
    TEXT_REPLACE,
    TEXT_CHAR,
    TEXT_CSV,
    TEXT_FETCH
];


const COLOR_VALUE       = 'COL#';  
const COLOR             = 'COL';   
const VALID_COLOR       = 'CVAL';  
const CORRECT_COLOR     = 'CCOR';  
const COLOR_CONTRAST    = 'CCNT';  
const COLORBLIND        = 'BLND';  
const COLOR_INTERPOLATE = 'CLERP'; 
const COLOR_BLEND       = 'CBLND';


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    CORRECT_COLOR,
    COLORBLIND,
    COLOR_INTERPOLATE,
    COLOR_BLEND
];


const FILL_VALUE       = 'FILL#';
const FILL             = 'FILL';
const FILL_TYPES       = [FILL_VALUE, FILL];

const STROKE_VALUE     = 'STRK#';
const STROKE           = 'STRK';
const STROKE_TYPES     = [STROKE_VALUE, STROKE];

const COLOR_STOP_VALUE = 'CSTOP#';
const COLOR_STOP       = 'CSTOP';

const GRADIENT_VALUE   = 'GRAD#';
const GRADIENT         = 'GRAD';
const GRADIENT_TYPES   = [GRADIENT_VALUE, GRADIENT];


const COLOR_STYLE      = 'CSTL';


const SHAPE_VALUE      = 'SHP#'; // abstract placeholder

const RECTANGLE_VALUE  = 'RECT#';
const RECTANGLE        = 'RECT'; 
const RECTANGLE_TYPES  = [RECTANGLE_VALUE, RECTANGLE];

const LINE_VALUE       = 'LINE#';
const LINE             = 'LINE'; 
const LINE_TYPES       = [LINE_VALUE, LINE];

const ELLIPSE_VALUE    = 'ELPS#';
const ELLIPSE          = 'ELPS'; 
const ELLIPSE_TYPES    = [ELLIPSE_VALUE, ELLIPSE];

const POLYGON_VALUE    = 'POLY#';
const POLYGON          = 'POLY'; 
const POLYGON_TYPES    = [POLYGON_VALUE, POLYGON];

const STAR_VALUE       = 'STAR#';
const STAR             = 'STAR'; 
const STAR_TYPES       = [STAR_VALUE, STAR];

const TEXTSHAPE_VALUE  = 'TXTS#';
const TEXTSHAPE        = 'TXTS'; 
const TEXTSHAPE_TYPES  = [TEXTSHAPE_VALUE, TEXTSHAPE];


const SHAPE_VALUES =
[
    SHAPE_VALUE,

    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE,
    TEXTSHAPE_VALUE
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    ...RECTANGLE_TYPES,
    ...LINE_TYPES,
    ...ELLIPSE_TYPES,
    ...POLYGON_TYPES,
    ...STAR_TYPES,
    ...TEXTSHAPE_TYPES
];


// const ALL_TYPES =
// [
//     ...FLOW_TYPES,
//     ...NUMBER_TYPES,
//     ...TEXT_TYPES,
//     ...COLOR_TYPES,
//     ...FILL_TYPES,
//     ...STROKE_TYPES,
//     ...GRADIENT_TYPES,
//     COLOR_STYLE,
//     ...SHAPE_TYPES
// ];


const GROUP_NODE    = 'GROUP';
const GROUP_PARAM   = 'GPARAM';


const GROUP_TYPES =
[
    GROUP_NODE,
    GROUP_PARAM
];


const COMMENT       = 'CMNT';


const ACTIVE        = 'ACT';
const BEFORE_ACTIVE = 'BEF';
const DISABLED      = 'DIS';
const NOCACHE       = 'NOC';
 
const PARAM         = 'PARAM'; // nodeId paramId
 

const LOG           = 'LOG';


const GRAPH         = 'GRAPH';


const MATH_OPS = 
[   // the order is important for logical keyboard value changes
    [NUMBER_SUBTRACT, '' ],
    [NUMBER_ADD,      '+' ],
    [NUMBER_MODULO,   '%' ],
    [NUMBER_DIVIDE,   '/' ], //'' ],
    [NUMBER_MULTIPLY, '' ],
    [NUMBER_EXPONENT, 'e<sup>x</sup>'] 
];



const BOOLEAN_NOT = 0;
const BOOLEAN_AND = 1;
const BOOLEAN_OR  = 2;
const BOOLEAN_XOR = 3;


const BOOLEAN_OPS = 
[   
    [BOOLEAN_NOT, 'not'],
    [BOOLEAN_XOR, 'xor'], 
    [BOOLEAN_OR,  'or' ],
    [BOOLEAN_AND, 'and']
];



const CONDITION_LESS             = 0;
const CONDITION_LESS_OR_EQUAL    = 1;
const CONDITION_NOT_EQUAL        = 2;
const CONDITION_EQUAL            = 3;
const CONDITION_GREATER_OR_EQUAL = 4;
const CONDITION_GREATER          = 5;


const CONDITION_OPS = 
[   
    [CONDITION_LESS,             '<'],
    [CONDITION_LESS_OR_EQUAL,    ''],
    [CONDITION_NOT_EQUAL,        ''],
    [CONDITION_EQUAL,            '='],
    [CONDITION_GREATER_OR_EQUAL, ''],
    [CONDITION_GREATER,          '>']
];



const EMPTY_ACTION               = 'EMPTY';
const CONNECT_ACTION             = 'CONNECT';
const CREATE_ACTION              = 'CREATE';
const CREATE_INSERT_ACTION       = 'CREATE_INSERT';
const DELETE_ACTION              = 'DELETE';
const DISCONNECT_ACTION          = 'DISCONNECT';
const LINK_STYLE_ACTION          = 'LINK_STYLE';
const MAKE_ACTIVE_ACTION         = 'MAKE_ACTIVE';
const PASTE_ACTION               = 'PASTE';
const RECONNECT_ACTION           = 'RECONNECT';
const REMOVE_ACTION              = 'REMOVE';
const RENAME_ACTION              = 'RENAME';
const REORDER_INPUTS_ACTION      = 'REORDER_INPUTS';
const REORDER_CONNECTIONS_ACTION = 'REORDER_CONNECTIONS';
const SELECT_ACTION              = 'SELECT';
const SELECT_MOVE_ACTION         = 'SELECT_MOVE';
const SET_PARAM_VALUE_ACTION     = 'SET_PARAM_VALUE';
const SET_PARAM_SETTING_ACTION   = 'SET_PARAM_SETTING';
const SET_NODE_RECT_ACTION       = 'SET_NODE_RECT';
const TOGGLE_DISABLE_ACTION      = 'TOGGLE_DISABLE';
const TOGGLE_SYMBOL_ACTION       = 'TOGGLE_SYMBOL';
const TOGGLE_PARAM_HEADER_ACTION = 'TOGGLE_PARAM_HEADER';
const SET_CURRENT_GRAPH_ACTION   = 'SET_CURRENT_GRAPH';



const BLEND_NORMAL      = 'BNORM';
const BLEND_DARKEN      = 'BDARK';
const BLEND_MULTIPLY    = 'BMULT';
const BLEND_COLOR_BURN  = 'BBURN';
const BLEND_LIGNTEN     = 'BLITE';
const BLEND_SCREEN      = 'BSCRN';
const BLEND_COLOR_DODGE = 'BDODG';
const BLEND_OVERLAY     = 'BOVER';
const BLEND_SOFT_LIGHT  = 'BSOFT';
const BLEND_HARD_LIGHT  = 'BHARD';
const BLEND_DIFFERENCE  = 'BDIFF';
const BLEND_EXCLUSION   = 'BEXCL';
const BLEND_HUE         = 'BHUE';
const BLEND_SATURATION  = 'BSAT';
const BLEND_COLOR       = 'BCOL';
const BLEND_LUMINOSITY  = 'BLUM';


const BlendModes =
[
    [BLEND_NORMAL,      'normal'     ],
    [BLEND_DARKEN,      'darken'     ],
    [BLEND_MULTIPLY,    'multiply'   ],
    [BLEND_COLOR_BURN,  'color burn' ],
    [BLEND_LIGNTEN,     'lighten'    ],
    [BLEND_SCREEN,      'screen'     ],
    [BLEND_COLOR_DODGE, 'color dodge'],
    [BLEND_OVERLAY,     'overlay'    ],
    [BLEND_SOFT_LIGHT,  'soft light' ],
    [BLEND_HARD_LIGHT,  'hard light' ],
    [BLEND_DIFFERENCE,  'difference' ],
    [BLEND_EXCLUSION,   'exclusion'  ],
    [BLEND_HUE,         'hue'        ],
    [BLEND_SATURATION,  'saturation' ],
    [BLEND_COLOR,       'color'      ],
    [BLEND_LUMINOSITY,  'luminosity' ]
];


class FigmaObject
{
    type;
    nodeId = '';


    constructor(type, nodeId)
    {
        this.type   = type;
        this.nodeId = nodeId;
    }



    copyBase(base)
    {
        this.fills            = clone(base.fills);
        this.stroks           = clone(base.strokes);
    
        this.strokeWeight     = base.strokeWeight;
        this.strokeFit        = base.strokeFit;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
    }
}


class FigmaShape
extends FigmaObject
{
    objectId = -1;

    fills    = [];
    strokes  = [];

    strokeWeight;
    strokeFit;
    strokeJoin;
    strokeMiterLimit;



    constructor(type, nodeId, objectId)
    {
        super(type, nodeId);

        this.objectId = objectId;
    }



    copyBase(base)
    {
        this.fills            = clone(base.fills);
        this.strokes          = clone(base.strokes);

        this.strokeWeight     = base.strokeWeight;
        this.strokeFit        = base.strokeFit;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
    }
}


class FigmaRectangle
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId, objectId, x, y, width, height, angle, round)
    {
        super(RECTANGLE, nodeId, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
    }



    copy()
    {
        const copy = new FigmaRectangle(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaLine
extends FigmaShape
{
    x;
    y;
    width;
    angle;



    constructor(nodeId, objectId, x, y, width, angle)
    {
        super(LINE, nodeId, objectId);
        
        this.x     = x;
        this.y     = y;
        this.width = width;
        this.angle = angle;
    }



    copy()
    {
        const copy = new FigmaLine(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.angle);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaEllipse
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;



    constructor(nodeId, objectId, x, y, width, height, angle)
    {
        super(ELLIPSE, nodeId, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new FigmaEllipse(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaPolygon
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(nodeId, objectId, x, y, width, height, angle, round, corners)
    {
        super(POLYGON, nodeId, objectId);
        
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new FigmaPolygon(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round,
            this.corners);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaStar
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(nodeId, objectId, x, y, width, height, angle, round, points, convex)
    {
        super(STAR, nodeId, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new FigmaStar(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round,
            this.points,
            this.convex);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaText
extends FigmaShape
{
    text;
    x;
    y;
    width;
    height;
    angle;
    font;
    style;
    size;
    alignH;
    alignV;
    lineHeight;
    letterSpacing;



    constructor(nodeId, objectId, text, x, y, width, height, angle, font, style, size, alignH, alignV, lineHeight, letterSpacing)
    {
        super(TEXTSHAPE, nodeId, objectId);
        
        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.angle         = angle;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignH        = alignH;
        this.alignV        = alignV;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;
    }



    copy()
    {
        const copy = new FigmaText(
            this.nodeId,
            this.objectId,
            this.text,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.font,
            this.style,
            this.size,
            this.alignH,
            this.alignV,
            this.lineHeight,
            this.letterSpacing);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaColorStyle
extends FigmaObject
{
    id;
    name;

    existing;



    constructor(nodeId, styleId, styleName)
    {
        super(COLOR_STYLE, nodeId);

        this.id   = styleId;
        this.name = styleName;
    }



    copy()
    {
        const copy = new FigmaColorStyle(this.nodeId, this.id, this.name);

        copy.copyBase(this);

        copy.existing = this.existing;

        return copy;
    }
}


class GNode
{
    type;

    options = {};
    data    = {}; // for type conversion info



    constructor(type, options) 
    {
        this.type    = type;
        this.options = options;
    }



    copy()
    {
        console.assert(false, 'abstract type GNode cannot be copied');
        return null;
    }



    copyBase(src)
    {
        this.options  = clone(src.options);
        this.data     = clone(src.data);
    }



    validate()
    {
        this.valid = true;
    }



    isValid() // is a valid value
    {
        return false;
    }



    toValue()
    {
        return null;
    }



    toString() 
    { 
        return this.type; 
    }
}



class GValue
extends GNode
{
    constructor(type, options) 
    {
        super(type, options);
    }



    copy()
    {
        console.assert(false, 'abstract class GValue cannot be copied');
        return null;
    }



    // eval()
    // {
    //     return this;
    // }



    toValue()
    {
        return this.copy();
    }



    toJson() 
    { 
        return this.toString(); 
    }



    toString() 
    { 
        return this.type; 
    }



    toJsCode(gen)
    {
        console.assert(false, 'invalid abstract method');
        return '';
    }



    getNaN()
    {
        console.assert(false, 'invalid abstract method');
        return null;
    }



    isCached()
    {
        return true;
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case    NUMBER_VALUE: return parseNumberValue   (value)[0].toDisplayString();
        case     COLOR_VALUE: return parseColorValue    (value)[0].toDisplayString();
        case      TEXT_VALUE: const val = parseTextValue(value)[0]; return val == '' ? '\'\'' : val.toDisplayString();
        case RECTANGLE_VALUE: return parseRectangleValue(value)[0].toDisplayString();
        case      LINE_VALUE: return parseLineValue     (value)[0].toDisplayString();
        case   ELLIPSE_VALUE: return parseEllipseValue  (value)[0].toDisplayString();
        case   POLYGON_VALUE: return parsePolygonValue  (value)[0].toDisplayString();
        case      STAR_VALUE: return parseStarValue     (value)[0].toDisplayString();
        case TEXTSHAPE_VALUE: return parseTextShapeValue(value)[0].toDisplayString();
        case      FILL_VALUE: return parseFillValue     (value)[0].toDisplayString();
        case    STROKE_VALUE: return parseStrokeValue   (value)[0].toDisplayString();
        case      LIST_VALUE: return parseListValue     (value)[0].toDisplayString();
    }


    console.assert(false, 'cannot display value of type \'' + type + '\'');
}



function nullFromType(type)
{
    switch (type)
    {
        case    NUMBER_VALUE: return NumberValue.NaN;
        case     COLOR_VALUE: return ColorValue.NaN;
        case      TEXT_VALUE: return new TextValue();
        case RECTANGLE_VALUE: return RectangleValue.NaN;
        case      LINE_VALUE: return      LineValue.NaN;
        case   ELLIPSE_VALUE: return   EllipseValue.NaN;
        case   POLYGON_VALUE: return   PolygonValue.NaN;
        case      STAR_VALUE: return      StarValue.NaN;
        case TEXTSHAPE_VALUE: return TextShapeValue.NaN;
        case      FILL_VALUE: return FillValue.NaN;
        case    STROKE_VALUE: return StrokeValue.NaN;
        case      LIST_VALUE: return ListValue.NaN;
    }

    console.assert(false, 'cannot determine null value from type \'' + type + '\'');
}


class GOperator
extends GNode
{
    nodeId;
    nodeName;

    valid; // has been evaluated
    topLevel;

    value;

   
    feedbackValue = null; // () => {}


    objects = []; // held by Operator because nodes like List and Repeat can also generate objects

    
    
    constructor(type, nodeId, options)
    {
        super(type, options);

        this.nodeId       = nodeId;
        this.nodeName     = options.nodeName;

        this.valid        = false;
        this.topLevel     = false;

        this.value        = null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId   = base.nodeId;
        this.nodeName = base.nodeName;

        this.valid    = base.valid;
        this.topLevel = base.topLevel;

        this.copyObjects(base.objects);
    }



    copyObjects(objects)
    {
        this.objects = objects.map(o => o.copy());
    }



    paramFromId(paramId)
    {
        return this[paramId];
    }



    isCached()
    {
        return this.options.cached
            && this.valid;
    }



    async eval(parse)
    {
        // calculate and add value update here

        return this;
    }



    async evalObjects(parse)
    {

    }


    
    toValue()
    {
        return null;
    }



    // isValid()
    // {
    //     return this.valid;
    // }



    invalidate()
    {
        this.valid = false;
    }
}


class GParam
extends GOperator
{
    paramId;
    
    node;
    param;
    


    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    copy()
    {
        const copy = new GParam(this.nodeId, this.paramId);

        copy.copyBase(this);

        copy.node = this.node;
    
        return copy;
    }



    async eval(parse)
    {
        this.node = parse.parsedNodes.find(v => v.nodeId == this.nodeId);
        console.assert(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');


        //this.param.feedbackValue = this.feedbackValue;

        this.node.feedbackValue = this.feedbackValue;
        await this.node.eval(parse);
        this.node.feedbackValue = null;

        this.param = this.node.paramFromId(this.paramId);


        if (isValid(this.param)) // could have been deleted from OpRepeat for example
        {
            // if (   this.feedbackValue)
            //     //&& this.param.type == NUMBER_VALUE)
            //     this.param = this.feedbackValue();

            const value = (await this.param.eval(parse)).toValue();

            //this.param.feedbackValue = null;
            return this.value = value;
        }
        else
        {
            //this.param.feedbackValue = null;
            return this.value = NullValue;
        }
    }


    
    isCached()
    {
        return super.isCached();
//            && this.node.isCached();
    }



    toValue()
    {
        return this.value;
    }



    invalidate()
    {
        super.invalidate();

        if (this.node)
            this.node.valid = false;
    }
}


class NumberValue
extends GValue
{
    value;
    decimals;



    constructor(val = Number.NaN, dec = 0)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
            console.assert(false, 'NumberValue(value) is ' + typeof val + ', must be a number');


        this.value    = val;
        this.decimals = dec;
    }



    static fromString(str)
    {
        return new NumberValue(
            parseFloat(str),
            decCount(str));
    }



    copy()
    {
        const copy = new NumberValue(
            this.value, 
            this.decimals);

        copy.copyBase(this);

        return copy;
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    toInteger()
    {
        return new NumberValue(Math.round(this.value));
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals); // only NumberValue can do this, other _Values have to list all members
    }



    toSimpleString()
    {
        return !isNaN(this.value)
              ? numToString(this.value, this.decimals)
              : NAN_DISPLAY; // only NumberValue can do this, other _Values have to list all members
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? subscriptNumber(this.decimals)
                : '');
    }



    toJsCode(gen)
    {
        return this.toSimpleString();
    }



    getNaN()
    {
        return NumberValue.NaN;
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



const NullValue = Object.freeze(NumberValue.NaN);



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
    {
        console.trace();
        console.assert(false, 'number value \'' + str + '\' missing \',\'');
    }

    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == NAN_DISPLAY
        ? NumberValue.NaN
        : NumberValue.fromString(str);

    return [num, 1];
}


class TextValue
extends GValue
{
    value;



    constructor(val = '')
    {
        super(TEXT_VALUE);

        if (typeof val !== 'string')
        {
            console.trace();
            console.assert(false, 'TextValue(value) is ' + typeof val + ', must be a string');
        }

        this.value = val;
    }



    copy()
    {
        const copy = new TextValue(this.value);

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.value == text.value;
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.value != NAN_CHAR;
    }



    toJson()
    {
        return toUtf8(this.value);
    }



    toString()
    {
        return this.value;
    }



    toSimpleString()
    {
        return this.value;
    }



    toDisplayString()
    {
        return '\'' 
             + this.value.replaceAll('\n', '')
             + '\'';
    }



    getNaN()
    {
        return new TextValue();//TextValue.NaN;
    }



    //static NaN = Object.freeze(new TextValue(NAN_CHAR));
}



function parseTextValue(str)
{
    const text = new TextValue(fromUtf8(str));

    return [text, 1];
}


class ColorValue
extends GValue
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        console.assert(typeof space == 'number', 'ColorValue.create() space must be a number');
        console.assert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        console.assert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        console.assert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    static fromDataColor(_color, spaceIndex = -1)
    {
        if (spaceIndex < 0)
            spaceIndex = colorSpaceIndex (_color[0]);

        const space  = colorSpace(spaceIndex);
        const factor = colorSpaceFactor(space);

        return ColorValue.create(
            spaceIndex,
            _color[1] * factor[0],
            _color[2] * factor[1],
            _color[3] * factor[2]);
    }



    copy()
    {
        const copy = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    async eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        const space = this.space.copy();

        space.value = Math.round(Math.min(Math.max(0, space.value), ColorSpaces.length-1));

        return makeDataColor(
            space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    toRgbString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    getNaN()
    {
        return ColorValue.NaN;
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart ];
}


class FillValue
extends GValue
{
    color;
    opacity;



    constructor(color   = ColorValue.NaN, 
                opacity = new NumberValue(100))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();

        this.valid   = true;
    }


    
    static create(r, g, b, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity));
    }



    static fromRgb(rgb, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity));
    }



    copy()
    {
        const copy = new FillValue(
            this.color  .copy(),
            this.opacity.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(fill)
    {
        return fill
            && this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity);
    }



    async eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    getNaN()
    {
        return FillValue.NaN;
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r = parseNumberValue(str[i]); i += r[1];
    const g = parseNumberValue(str[i]); i += g[1];
    const b = parseNumberValue(str[i]); i += b[1];
    const a = parseNumberValue(str[i]); i += a[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0]),
        i - iStart ];
}






// async function evalFillValue(fillValue, parse)
// {
//     await fillValue.eval(parse);

//          if ( FILL_TYPES.includes(fillValue.type)) return fill;
//     else if (COLOR_TYPES.includes(fillValue.type)) return new FillValue(fill, fillValue.data.opacity);

//     else console.assert(false, 'fill must have type');
// }


class StrokeValue
extends GValue
{
    fill;
    weight;
    fit;
    join;
    miter;



    constructor(fill   = FillValue.NaN, 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2))
    {
        if (fill.type != FILL_VALUE)
            console.assert(false, 'fill.type is ' + fill.type + ', must be FILL_VALUE');


        super(STROKE_VALUE);

        this.fill   = fill  .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();

        this.valid   = true;
    }


    
    // static create(r, g, b, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.create(1, r, g, b),
    //         new NumberValue(opacity));
    // }



    // static fromRgb(rgb, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.fromRgb(rgb),
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new StrokeValue(
            this.fill  .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fill  .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter );
    }



    async eval(parse)
    {
        return this;
    }



    // toFigma()
    // {
    //     let align, join;

        
    //     switch (this.fit.value)
    //     {
    //         case 0: align = 'INSIDE';  break;
    //         case 1: align = 'CENTER';  break;
    //         case 2: align = 'OUTSIDE'; break;
    //     }
        
    //     switch (this.join.value)
    //     {
    //         case 0: join = 'MITER'; break;
    //         case 1: join = 'BEVEL'; break;
    //         case 2: join = 'ROUND'; break;
    //     }

        
    //     return this.isValid()
    //         ? {
    //               strokes:          this.fill.toFigma(),
    //               strokeWeight:     this.weight.value,
    //               strokeAlign:      align,
    //               strokeJoin:       join,
    //               strokeMiterLimit: this.miter.value
    //           }
    //         : {
    //               strokes: []
    //           };
    // }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fill  .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString();
    }



    toDisplayString()
    {
        return      this.fill  .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString();
    }



    getNaN()
    {
        return StrokeValue.NaN;
    }



    static NaN = Object.freeze(new StrokeValue(
        FillValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(new StrokeValue(
        FillValue.create(0, 0, 0, 100),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96)));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill   = parseFillValue  (str, i); i += fill  [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];


    return [
        new StrokeValue(fill[0], weight[0], fit[0], join[0], miter[0]),
        i - iStart ];
}



// async function evalStrokeValue(value, parse)
// {
//     const stroke = (await value.eval(parse)).copy();

//          if (STROKE_TYPES.includes(stroke.type)) return stroke;
//     else if (  FILL_TYPES.includes(stroke.type)) return new StrokeValue(stroke, value.data.weight);
//     else if ( COLOR_TYPES.includes(stroke.type)) return new StrokeValue(new FillValue(stroke), value.data.weight);

//     else console.assert(false, 'stroke must have type');
// }


class ListValue
extends GValue
{
    items;



    constructor(items = [])
    {
        super(LIST_VALUE);

        if (items)
        {
            this.items = [];
            
            for (const item of items)
                this.items.push(item.copy());
        }
    }



    copy()
    {
        const copy = new ListValue(this.items);

        copy.copyBase(this);

        return copy;
    }



    equals(list)
    {
        if (!list)                                  return false;
        if (!(list instanceof ListValue))           return false;
        if (this.items.length != list.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(list.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.items
            && !this.items.find(i => !i.isValid());
    }



    toValue()
    {
        return this.copy();
    }



    toJson()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toJson();
        }


        return str;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    getNaN()
    {
        return ListValue.NaN;
    }



    static NaN = Object.freeze(new ListValue(null));
}



function parseListValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const list = new ListValue();
    

    const nInputs = parseInt(str[i++]);


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];
        
        switch (type)
        {
            case NUMBER_VALUE: { const num    = parseNumberValue(str[i]); i += num   [1]; list.items.push(num   [0]); break; }
            case TEXT_VALUE:   { const text   = parseTextValue  (str[i]); i += text  [1]; list.items.push(text  [0]); break; }
            case COLOR_VALUE:  { const col    = parseColorValue (str, i); i += col   [1]; list.items.push(col   [0]); break; }
            case FILL_VALUE:   { const fill   = parseFillValue  (str, i); i += fill  [1]; list.items.push(fill  [0]); break; }
            case STROKE_VALUE: { const stroke = parseStrokeValue(str, i); i += stroke[1]; list.items.push(stroke[0]); break; }
            case LIST_VALUE:   { const _list  = parseListValue  (str, i); i += _list [1]; list.items.push(_list [0]); break; }
        }
    }
 

    return [
        list, 
        i - iStart];
}


/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeValue
extends GValue
{
    nodeId;

    props;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 
    }



    copyBase(base)
    {
        this.nodeId = base.nodeId;

        this.props  = base.props.copy();
    }



    isValid()
    {
        return this.props.isValid();
    }



    // toString()
    // {
    //     return      this.fill  .toString()
    //         + ' ' + this.stroke.toString();
    // }



    // toDisplayString()
    // {
    //     return      this.fill  .toDisplayString()
    //         + ' ' + this.stroke.toDisplayString();
    // }
}



function parseShapeBaseValue(str, i, obj)
{
    const props = parseListValue(str, i); i += props[1];

    obj.props = props[0];

    return i;
}


class RectangleValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.angle .equals(rect.angle )
            && this.round .equals(rect.round );
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid()
            && super.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString();
    }



    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0],
        round [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends ShapeValue
{
    x;
    y;
    width;
    angle;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(LINE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new LineValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.width.copy(), 
            this.angle.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(line)
    {
        return line
            && this.x     .equals(line.x    )
            && this.y     .equals(line.y    )
            && this.width .equals(line.width)
            && this.angle .equals(line.angle);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.angle .isValid()
            && super.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.angle .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.angle .toDisplayString();
    }



    static NaN = new LineValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LineValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const width = parseNumberValue(str[i]); i += width[1];
    const angle = parseNumberValue(str[i]); i += angle[1];


    const line = new LineValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        width[0],
        angle[0]);


    i = parseShapeBaseValue(str, i, line);

    
    return [line, i - iStart];
}



class EllipseValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(ELLIPSE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new EllipseValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(ellipse)
    {
        return ellipse
            && this.x     .equals(ellipse.x     )
            && this.y     .equals(ellipse.y     )
            && this.width .equals(ellipse.width )
            && this.height.equals(ellipse.height)
            && this.angle .equals(ellipse.angle );
    }



    async eval(parse)
    {
        return this;
    }
    
    
    
    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && super.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString();
    }



    static NaN = new EllipseValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [EllipseValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];


    const ellipse = new EllipseValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0]);


    i = parseShapeBaseValue(str, i, ellipse);

    
    return [ellipse, i - iStart];
}



class PolygonValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(nodeId,
                x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                width   = new NumberValue(0), 
                height  = new NumberValue(0), 
                angle   = new NumberValue(0), 
                round   = new NumberValue(0), 
                corners = new NumberValue(0))
    {
        super(POLYGON_VALUE, nodeId);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new PolygonValue(
            this.nodeId,
            this.x      .copy(), 
            this.y      .copy(), 
            this.width  .copy(), 
            this.height .copy(), 
            this.angle  .copy(), 
            this.round  .copy(), 
            this.corners.copy());
    
        copy.copyBase(this);

        return copy;
    }



    equals(poly)
    {
        return poly
            && this.x      .equals(poly.x      )
            && this.y      .equals(poly.y      )
            && this.width  .equals(poly.width  )
            && this.height .equals(poly.height )
            && this.angle  .equals(poly.angle  )
            && this.round  .equals(poly.round  )
            && this.corners.equals(poly.corners);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x      .isValid()
            && this.y      .isValid()
            && this.width  .isValid()
            && this.height .isValid()
            && this.angle  .isValid()
            && this.round  .isValid()
            && this.corners.isValid()
            && super.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x      .toString()
            + ' ' + this.y      .toString()
            + ' ' + this.width  .toString()
            + ' ' + this.height .toString()
            + ' ' + this.angle  .toString()
            + ' ' + this.round  .toString()
            + ' ' + this.corners.toString();
    }



    toDisplayString()
    {
        return      this.x      .toDisplayString()
            + ' ' + this.y      .toDisplayString()
            + ' ' + this.width  .toDisplayString()
            + ' ' + this.height .toDisplayString()
            + ' ' + this.angle  .toDisplayString()
            + ' ' + this.round  .toDisplayString()
            + ' ' + this.corners.toDisplayString();
    }



    static NaN = new PolygonValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PolygonValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x       = parseNumberValue(str[i]); i += x      [1];
    const y       = parseNumberValue(str[i]); i += y      [1];
    const width   = parseNumberValue(str[i]); i += width  [1];
    const height  = parseNumberValue(str[i]); i += height [1];
    const angle   = parseNumberValue(str[i]); i += angle  [1];
    const round   = parseNumberValue(str[i]); i += round  [1];
    const corners = parseNumberValue(str[i]); i += corners[1];


    const poly = new PolygonValue(
        '', // set node ID elsewhere
        x      [0],
        y      [0],
        width  [0],
        height [0],
        angle  [0],
        round  [0],
        corners[0]);


    i = parseShapeBaseValue(str, i, poly);

    
    return [poly, i - iStart];
}



class StarValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0), 
                points = new NumberValue(0),
                convex = new NumberValue(0))
    {
        super(STAR_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new StarValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy(), 
            this.points.copy(),
            this.convex.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(star)
    {
        return star
            && this.x     .equals(star.x     )
            && this.y     .equals(star.y     )
            && this.width .equals(star.width )
            && this.height.equals(star.height)
            && this.angle .equals(star.angle )
            && this.round .equals(star.round )
            && this.points.equals(star.points)
            && this.convex.equals(star.convex);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid()
            && this.points.isValid()
            && this.convex.isValid()
            && super.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString()
            + ' ' + this.points.toString()
            + ' ' + this.convex.toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.points.toDisplayString()
            + ' ' + this.convex.toDisplayString();
    }



    static NaN = new StarValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StarValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const points = parseNumberValue(str[i]); i += points[1];
    const convex = parseNumberValue(str[i]); i += convex[1];


    const star = new StarValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0],
        round [0],
        points[0],
        convex[0]);


    i = parseShapeBaseValue(str, i, star);

    
    return [star, i - iStart];
}



class TextShapeValue
extends ShapeValue
{
    text;
    x;
    y;
    width;
    height;
    angle;
    font;
    style;
    size;
    alignH;
    alignV;
    lineHeight;
    letterSpacing;

    

    constructor(nodeId,
                text          = new TextValue(),
                x             = new NumberValue(0), 
                y             = new NumberValue(0), 
                width         = new NumberValue(0), 
                height        = new NumberValue(0), 
                angle         = new NumberValue(0),
                font          = new NumberValue(0),
                style         = new NumberValue(0),
                size          = new NumberValue(0),
                alignH        = new NumberValue(0),
                alignV        = new NumberValue(0),
                lineHeight    = new NumberValue(0),
                letterSpacing = new NumberValue(0))
    {
        super(TEXTSHAPE_VALUE, nodeId);

        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.angle         = angle;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignH        = alignH;
        this.alignV        = alignV;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.text         .copy(),
            this.x            .copy(), 
            this.y            .copy(), 
            this.width        .copy(), 
            this.height       .copy(), 
            this.angle        .copy(),
            this.font         .copy(),
            this.style        .copy(),
            this.size         .copy(),
            this.alignH       .copy(),
            this.alignV       .copy(),
            this.lineHeight   .copy(),
            this.letterSpacing.copy()); 

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.text         .equals(text.text         )
            && this.x            .equals(text.x            )
            && this.y            .equals(text.y            )
            && this.width        .equals(text.width        )
            && this.height       .equals(text.height       )
            && this.angle        .equals(text.angle        )
            && this.font         .equals(text.font         )
            && this.style        .equals(text.style        )
            && this.size         .equals(text.size         )
            && this.alignH       .equals(text.alignH       )
            && this.alignV       .equals(text.alignV       )
            && this.lineHeight   .equals(text.lineHeight   )
            && this.letterSpacing.equals(text.letterSpacing);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.angle        .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignH       .isValid()
            && this.alignV       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid()
            && super.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.text         .toString()
            + ' ' + this.x            .toString()
            + ' ' + this.y            .toString()
            + ' ' + this.width        .toString()
            + ' ' + this.height       .toString()
            + ' ' + this.angle        .toString()
            + ' ' + this.font         .toString()
            + ' ' + this.style        .toString()
            + ' ' + this.size         .toString()
            + ' ' + this.alignH       .toString()
            + ' ' + this.alignV       .toString()
            + ' ' + this.lineHeight   .toString()
            + ' ' + this.letterSpacing.toString();
    }



    toDisplayString()
    {
        return      this.text         .toDisplayString()
            + ' ' + this.x            .toDisplayString()
            + ' ' + this.y            .toDisplayString()
            + ' ' + this.width        .toDisplayString()
            + ' ' + this.height       .toDisplayString()
            + ' ' + this.angle        .toDisplayString()
            + ' ' + this.font         .toDisplayString()
            + ' ' + this.style        .toDisplayString()
            + ' ' + this.size         .toDisplayString()
            + ' ' + this.alignH       .toDisplayString()
            + ' ' + this.alignV       .toDisplayString()
            + ' ' + this.lineHeight   .toDisplayString()
            + ' ' + this.letterSpacing.toDisplayString();
    }



    static NaN = new TextShapeValue(
        '',
        TextValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTextShapeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TextShapeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const text          = parseTextValue  (str[i]); i += text         [1];
    const x             = parseNumberValue(str[i]); i += x            [1];
    const y             = parseNumberValue(str[i]); i += y            [1];
    const width         = parseNumberValue(str[i]); i += width        [1];
    const height        = parseNumberValue(str[i]); i += height       [1];
    const angle         = parseNumberValue(str[i]); i += angle        [1];
    const font          = parseNumberValue(str[i]); i += font         [1];
    const style         = parseNumberValue(str[i]); i += style        [1];
    const size          = parseNumberValue(str[i]); i += size         [1];
    const alignH        = parseNumberValue(str[i]); i += alignH       [1];
    const alignV        = parseNumberValue(str[i]); i += alignV       [1];
    const lineHeight    = parseNumberValue(str[i]); i += lineHeight   [1];
    const letterSpacing = parseNumberValue(str[i]); i += letterSpacing[1];


    const txts = new TextShapeValue(
        '', // set node ID elsewhere
        text         [0],
        x            [0],
        y            [0],
        width        [0],
        height       [0],
        angle        [0],
        font         [0],
        style        [0],
        size         [0],
        alignH       [0],
        alignV       [0],
        lineHeight   [0],
        letterSpacing[0]);


    i = parseShapeBaseValue(str, i, txts);

    
    return [txts, i - iStart];
}



class GList
extends GOperator
{
    inputs = [];

    value;



    constructor(nodeId, options)
    {
        super(LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GList(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());
        copy.value  = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        this.objects = [];


        for (let i = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);


            if (this.options.enabled)
            {
                for (let j = 0; j < this.inputs[i].objects.length; j++)
                {
                    const obj = this.inputs[i].objects[j].copy();

                    obj.nodeId   = this.nodeId;
                    obj.objectId = i;

                    this.objects.push(obj);
                }
            }


            const input = this.inputs[i].toValue();

            if (   input
                && this.options.enabled)            
            {
                if (input.type == LIST_VALUE)
                {
                    for (const item of input.items)
                        this.value.items.push(item);   
                }
                else
                    this.value.items.push(input);
            }
        }
    

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



class GExpandList
extends GOperator
{
    input = null;

    constructor(nodeId, options)
    {
        super(LIST_EXPAND, nodeId, options);
    }



    copy()
    {
        const copy = new GItems(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;



        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            this.value = new ListValue();

            for (const item of input.items)
            {
                this.value.items.push(item);   

                if (item.type == LIST_VALUE)
                {
                    for (const listItem of item.items)
                        this.value.items.push(listItem);
                }
            }
        }
        else
        {
            this.value = ListValue.NaN;
        }


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);



        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GItems
extends GOperator
{
    input = null;

    //item0
    //item1
    //item2
    //...



    constructor(nodeId, options)
    {
        super(ITEMS, nodeId, options);
    }



    copy()
    {
        const copy = new GItems(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (   key.length > 4
                && key.substring(0, 4) == 'item')
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            //if (!this.input.value)
                await this.input.eval(parse);

            this.value   = this.input.toValue();
            this.objects = clone(this.input.objects);
        }
        else
        {
            this.value   = ListValue.NaN;
            this.objects = [];
        }


        if (    this.value.isValid()
            && !isEmpty(this.value.items))
        {
            for (let i = 0; i < this.value.items.length; i++)
            {
                const item = this.value.items[i];

                Object.assign(this, {['item' + i]: item});
                genPushUpdateValue(parse, this.nodeId, 'item' + i, item);
            }
        }
        else
            genPushUpdateValue(parse, this.nodeId, '', NullValue);


        for (let j = 0; j < this.objects.length; j++)
            this.objects[j].nodeId = this.nodeId;


        this.validate();

        return this;
    }



    paramFromId(paramId)
    {
        if (   paramId.length > 4
            && paramId.substring(0, 4) == 'item'
            && strIsNum(paramId.substring(4)))
            return this[paramId];

        return null;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GSelect
extends GOperator
{
    input = null;
    
    index;



    constructor(nodeId, options)
    {
        super(SELECT, nodeId, options);
    }



    copy()
    {
        const copy = new GSelect(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.index) copy.index = this.index.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let index = (await this.index.eval(parse)).toValue();
        index = new NumberValue(Math.round(index.value));


        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            length = input.items.length;

            index.value = Math.min(index.value, input.items.length-1);

            this.value = input.items[index.value];
        }
        else
        {
            this.value = NullValue;
        }


        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);
        genPushUpdateValue(parse, this.nodeId, 'length', new NumberValue(length));
        genPushUpdateValue(parse, this.nodeId, 'index',  index);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GListCount
extends GOperator
{
    input = null;

    value = null;



    constructor(nodeId, options)
    {
        super(LIST_COUNT, nodeId, options);
    }



    copy()
    {
        const copy = new GListCount(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.count) copy.count = this.count.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            await this.input.eval(parse);
            this.value = new NumberValue(this.input.toValue().items.length);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    // toValue()
    // {
    //     return this.value.copy();
    // }
}


class GIfElse
extends GOperator
{
    input0 = null;
    input1 = null;

    condition;



    constructor(nodeId, options)
    {
        super(IF_ELSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GIfElse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input    ) copy.input     = this.input    .copy();
        if (this.condition) copy.condition = this.condition.copy();
        if (this.value    ) copy.value     = this.value    .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const cond = (await this.condition.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = (await this.input0.eval(parse)).toValue();
            const val1 = (await this.input1.eval(parse)).toValue();

            this.value = cond.value != 0 ? val0 : val1;
        }
        else if (this.input0)
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.value = 
                cond.value != 0
                ? input0
                : input0.getNaN()
        }
        else if (this.input1)
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = 
                cond.value == 0
                ? input1
                : input1.getNaN();
        }
        else                  
            this.value = NullValue;


        genPushUpdateValue(parse, this.nodeId, 'condition', cond);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GStart
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(START, nodeId, options);
    }


    
    copy()
    {
        const copy = new GStart(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.input)
        {
            this.input = (await this.input.eval(parse)).copy();
            this.value = this.input.toValue();
        }
        else
            this.value = null;

        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value ? this.value.copy() : null;
    }
}



class GRepeat
extends GOperator
{
    input = null;

    count;



    constructor(nodeId, options)
    {
        super(REPEAT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRepeat(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();

        copy.count = this.count.copy();
        copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        let count = (await this.count.eval(parse)).toValue();
        count = new NumberValue(Math.round(count.value));

       
        this.value = new ListValue();

        this.objects = [];


        if (this.input)
        {
            const nItems = 
                this.options.enabled 
                ? count.value 
                : 1;


            for (let i = 0; i < nItems; i++)
            {
                if (this.nodeId == 'graph/repeat2')                
                    console.log('this.input =', this.input);
    
                this.input.invalidate();
                await this.input.eval(parse);


                for (let j = 0; j < this.input.objects.length; j++)
                {
                    const obj = this.input.objects[j].copy();
    
                    obj.nodeId   = this.nodeId;
                    obj.objectId = i;
    
                    this.objects.push(obj);
                }
    

                const input = this.input.toValue();

                if (input)
                    this.value.items.push(input.copy());
            }
        }

        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'count', count);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



class GCache
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(CACHE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCache(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.valid)//isCached())
            return this;


        this.value = 
            this.input
            ? (await this.input.eval(parse)).toValue()
            : NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GCopy
extends GOperator
{
    input = null;

    copy;


    constructor(nodeId, options)
    {
        super(COPY, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCopy(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();
        if (this.copy)  copy.copy  = this.copy .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = this.input ? (await this.input.eval(parse)).toValue() : NullValue;
        this.copy  = this.value ? this.value.copy()                        : NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'copy',  this.copy);

        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GNumberType
extends GOperator
{
    value;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GNumber
extends GNumberType
{
    input = null;
    


    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.value = this.value;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = NumberValue.NaN;


        if (this.feedbackValue)
            this.value = this.feedbackValue();


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);    


        this.validate();

        return this;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    isCached()
    {
        return super.isCached()
            && (!this.input || this.input.isCached());
    }
}


class GSign
extends GNumberType
{
    input = null;



    constructor(nodeId, options)
    {
        super(NUMBER_SIGN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSign(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.sign(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GAbsolute
extends GNumberType
{
    input = null;



    constructor(nodeId, options)
    {
        super(NUMBER_ABSOLUTE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAbsolute(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.abs(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GRound
extends GNumberType
{
    input = null;

    type;
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_ROUND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.type     = this.type    .copy();
        copy.decimals = this.decimals.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const type = (await this.type    .eval(parse)).toValue();
        const dec  = (await this.decimals.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                switch (type.value)
                {
                    case 0: this.value.value = floorTo(this.value.value, dec.value); break;
                    case 1: this.value.value = roundTo(this.value.value, dec.value); break;
                    case 2: this.value.value =  ceilTo(this.value.value, dec.value); break;
                }

                this.value.decimals = dec.value;
            }
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'type',     type);
        genPushUpdateValue(parse, this.nodeId, 'decimals', dec );
        genPushUpdateValue(parse, this.nodeId, 'value',    this.value);


        this.validate();

        return this;
    }
}



class GLimits
extends GNumberType
{
    input = null;

    min;
    max;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.min = this.min.copy();
        copy.max = this.max.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const min = (await this.min.eval(parse)).toValue();
        const max = (await this.max.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            //console.log('this.value =', this.value);

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                this.value.value = Math.min(Math.max(
                    min.value,
                    this.value.value),
                    max.value);
            }
        }
        else
            this.value = NumberValue.NaN;


        if (this.feedbackValue)
            this.value = this.feedbackValue();


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'min',   min);
        genPushUpdateValue(parse, this.nodeId, 'max',   max);


        this.validate();

        return this;
    }



    isCached()
    {
        return super.isCached()
            && (!this.input || this.input.isCached())
            && (!this.min   || this.min  .isCached())
            && (!this.max   || this.max  .isCached());
    }
}



class GSeries
extends GNumberType
{
    start;
    step;

    current;



    constructor(nodeId, options)
    {
        super(NUMBER_SERIES, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSeries(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start  ) copy.start   = this.start  .copy();
        if (this.step   ) copy.step    = this.step   .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        //logString('GSeries.eval()');

        if (!this.valid)
        {
            await this.start.eval(parse);
            await this.step .eval(parse);
        }


        const start = this.start.toValue();
        const step  = this.step .toValue();
    

        if (!this.valid)
            this.current = start.copy();

        
        this.value = new NumberValue(
            this.current.value,
            Math.max(start.decimals, step.decimals));

        this.current.value += step.value;


        //if (!this.valid)
        //{
            //genPushUpdateValue(parse, this.nodeId, 'value', this.value);
            genPushUpdateValue(parse, this.nodeId, 'start', start);
            genPushUpdateValue(parse, this.nodeId, 'step',  step );
        //}
        

        this.validate();

        return this;
    }
}



class GRandom
extends GNumberType
{
    seed;
    min;
    max;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_RANDOM, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.min   ) copy.min    = this.min   .copy();
        if (this.max   ) copy.max    = this.max   .copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const seed = (await this.seed.eval(parse)).toValue();
        const min  = (await this.min .eval(parse)).toValue();
        const max  = (await this.max .eval(parse)).toValue();
    

        if (!this.valid)
            this.random = new Random(seed.value);

        
        this.value = new NumberValue(
            min.value + this.random.next() * (max.value - min.value),
            Math.max(min.decimals, max.decimals));


        if (!this.valid)
        {
            //genPushUpdateValue(parse, this.nodeId, 'value', this.value);
            genPushUpdateValue(parse, this.nodeId, 'seed',  seed);
            genPushUpdateValue(parse, this.nodeId, 'min',   min );
            genPushUpdateValue(parse, this.nodeId, 'max',   max );
        }
        

        this.validate();

        return this;
    }
}



class GInterpolate
extends GNumberType
{
    input0 = null;
    input1 = null;

    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount = (await this.amount.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = (await this.input0.eval(parse)).toValue();
            const val1 = (await this.input1.eval(parse)).toValue();

            const maxDec = Math.max(val0.decimals, val1.decimals);

            this.value = new NumberValue(
                floorTo(val0.value + amount.value * (val1.value - val0.value) / 100, maxDec),
                maxDec);
        }
        else if (this.input0)
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();

        else                  
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);


        this.validate();

        return this;
    }
}



class GNumberToText
extends GNumberType
{
    input = null;

    format;
    digits;


    
    constructor(nodeId, options)
    {
        super(NUMBER_TO_TEXT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNumberToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.format = this.format.copy();
        copy.digits = this.digits.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();
        const digits = (await this.digits.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            console.assert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');

                
            let str = NAN_CHAR;

            switch (format.value)
            {
                case 0: 
                    str = numToString(Math.round(input.value), digits.value, false);
                    break;

                case 1: // hex
                    str = numToString(Math.round(input.value), digits.value, true).toUpperCase();
                    break;

                case 2: // float
                    str = numToString(input.value, -digits.value);
                    break;
            }

            this.value = new TextValue(str);
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);
        genPushUpdateValue(parse, this.nodeId, 'format', format    );
        genPushUpdateValue(parse, this.nodeId, 'digits', digits    );


        this.validate();

        return this;
    }
}



class GSolve
extends GNumberType
{
    input = null;

    current;
    target;

    temp;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSolve(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.current = this.current.copy();
        copy.target  = this.target .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let   current = (await this.current.eval(parse)).toValue();
        const target  = (await this.target .eval(parse)).toValue();


        //console.log('this.input =', this.input);
        if (   this.input
            && current.isValid()
            && target .isValid())
        {
            let input = (await this.input.eval(parse)).toValue();

            console.assert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                const diffStart = target.value - current.value;
                let   diff      = diffStart;
                let   prevDiff  = diffStart;

                // console.log('diffStart =', diffStart);
                // console.log('diff =', diff);
                // console.log('prevDiff =', prevDiff);

                let   start     = input.copy();
                let   step      = Number.MAX_SAFE_INTEGER;


                const maxIter = 1000;
                let   iter    = 0;
                

                genInitNodeProgress(this.nodeId);


                this.temp = new NumberValue(Number.MIN_SAFE_INTEGER);


                while (iter++ < maxIter)
                {
                    this.temp.value += step;
                    // console.log('this.temp.value =', this.temp.value);
                    //console.log('diff =', step);
                    console.log('step =', step);

                    this.input.feedbackValue = this.getFeedbackValue;
                    this.input.valid = false;

                    // if (this.input.type == PARAM)
                    //     this.input.node.valid = false;
                        
                    current = (await this.current.eval(parse)).toValue();

                    this.input.feedbackValue = null;


                    diff = target.value - current.value;

                    if (   /*Math.abs(diff) < 0.0000001
                        && */Math.abs(step) < 0.0000001)
                        break;
                        

                    if (   Math.abs (diff) >  Math.abs (prevDiff)
                        || Math.sign(diff) != Math.sign(prevDiff))
                        step /= -2;

                    prevDiff = diff;


                    genUpdateNodeProgress(this.nodeId, iter / maxIter);
                }


                if (iter < maxIter)
                {
                    input = (await this.input.eval(parse)).toValue();
                    this.value = input;
                }
                else
                {
                    this.value = NumberValue.NaN;
                    genPushUpdateValue(parse, this.input.nodeId, 'value', start);
                    console.log('max solve iterations');
                }
            }
            else
                this.value = input;
        }
        else
        {
            if (this.input) 
                await this.input.eval(parse);

            this.value = NumberValue.NaN;
        }

        
        // TODO push good result value to input 

        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
        genPushUpdateValue(parse, this.nodeId, 'current', current   );
        genPushUpdateValue(parse, this.nodeId, 'target',  target    );


        this.validate();

        return this;
    }



    getFeedbackValue = () => this.temp.copy();



    isCached()
    {
        return super.isCached()
            && this.current.isCached()
            && this.target .isCached();
    }
}



class GAnimate
extends GNumberType
{
    from;
    to;
    curve;
    type;
    length;
    time;



    constructor(nodeId, options)
    {
        super(NUMBER_ANIMATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnimate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from  ) copy.from   = this.from  .copy();
        if (this.to    ) copy.to     = this.to    .copy();
        if (this.curve ) copy.curve  = this.curve .copy();
        if (this.type  ) copy.type   = this.type  .copy();
        if (this.length) copy.length = this.length.copy();
        if (this.time  ) copy.time   = this.time  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const from   = (await this.from  .eval(parse)).toValue();
        const to     = (await this.to    .eval(parse)).toValue();
        const curve  = (await this.curve .eval(parse)).toValue();
        const type   = (await this.type  .eval(parse)).toValue();
        const length = (await this.length.eval(parse)).toValue();
        const time   = (await this.time  .eval(parse)).toValue();
    

        const maxDec = Math.max(from.decimals, to.decimals);

        switch (curve.value)
        {
            case 0: 
            {
                this.value = new NumberValue(
                    time.value < length.value ? from.value : to.value, 
                    maxDec);
    
                break;
            }
            case 1: 
            {
                this.value = new NumberValue(
                    from.value + (to.value - from.value) * time.value / length.value,
                    maxDec);
    
                break;
            }
            case 2: 
            {
                let f = time.value / length.value;

                f = 1 - sqr(1 - f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 3: 
            {
                let f = time.value / length.value;

                f = sqr(f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 4: 
            {
                let f = time.value / length.value;

                f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
        }
        
        

        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);
        genPushUpdateValue(parse, this.nodeId, 'from',   from      );
        genPushUpdateValue(parse, this.nodeId, 'to',     to        );
        genPushUpdateValue(parse, this.nodeId, 'curve',  curve     );
        genPushUpdateValue(parse, this.nodeId, 'type',   type      );
        genPushUpdateValue(parse, this.nodeId, 'length', length    );
        genPushUpdateValue(parse, this.nodeId, 'time',   time      );
        

        this.validate();

        return this;
    }
}



class GArithmetic
extends GNumberType
{
    inputs = [];



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }
}



class GMath
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

        switch (op.value)
        {
            case 0: this.value = await evalSubtractInputs(this.inputs, parse); break;
            case 1: this.value = await evalAddInputs     (this.inputs, parse); break;
            case 2: this.value = await evalModuloInputs  (this.inputs, parse); break;
            case 3: this.value = await evalDivideInputs  (this.inputs, parse); break;
            case 4: this.value = await evalMultiplyInputs(this.inputs, parse); break;
            case 5: this.value = await evalExponentInputs(this.inputs, parse); break;
        }

        
        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);



        this.validate();

        return this;
    }
}



class GAdd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAdd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalAddInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalAddInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        console.assert(
            val.type == NUMBER_VALUE, 
            'val.type must be NUMBER_VALUE');

        value.value   += val.value;
        value.decimals = Math.max(value.decimals, val.decimals);
    }


    return value;
}


class GSubtract
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSubtract(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalSubtractInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalSubtractInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value   -= val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GMultiply
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GMultiply(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }

    

    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalMultiplyInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalMultiplyInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        value.value = 1;

        for (let i = 0; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            value.value   *= val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GDivide
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDivide(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalDivideInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalDivideInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.value == 0) 
            { 
                value.value    = Number.NaN; 
                value.decimals = 0;
                break; 
            }

            value.decimals = Math.max(value.decimals, val.decimals);
            value.value    = floorTo(value.value / val.value, value.decimals);
        }
    }


    return value;
}


class GModulo
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const copy = new GModulo(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalModuloInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalModuloInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.value == 0) 
            { 
                value.value    = Number.NaN; 
                value.decimals = 0;
                break; 
            }

            value.decimals = Math.max(value.decimals, val.decimals);
            value.value    = floorTo(value.value % val.value, value.decimals);
        }
    }


    return value;
}


class GExponent
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GExponent(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalExponentInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalExponentInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value    = Math.pow(value.value,    val.value);
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GBoolean
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_BOOLEAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), BOOLEAN_OPS.length-1);

        
        switch (op.value)
        {
            case BOOLEAN_NOT: this.value = await evalNandInputs(this.inputs, parse); break;
            case BOOLEAN_AND: this.value = await evalAndInputs (this.inputs, parse); break;
            case BOOLEAN_OR:  this.value = await evalOrInputs  (this.inputs, parse); break;
            case BOOLEAN_XOR: this.value = await evalXorInputs (this.inputs, parse); break;
        }

        
        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);


        this.validate();

        return this;
    }
}


class GNot
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNot(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalNandInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalNandInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber() != 0 ? 0 : 1;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.toNumber() == 0)
                value.value = 1;
        }
    }


    return value;
}



class GAnd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_AND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalAndInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalAndInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber();


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = Math.min(value.value, val.toNumber());
        }

        
        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GOr
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_OR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GOr(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalOrInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalOrInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber();


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = Math.max(value.value, val.toNumber());
        }


        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GXor
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_XOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GXor(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalXorInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalXorInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    let flipped;

    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        flipped = val0.toNumber() != 0;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            if (val.toNumber() != 0)
                flipped++;
        }


        value.value = flipped == 1 ? 1 : 0;
    }


    return value;
}


class GConditionBase
extends GNumberType
{
    input0 = null;
    input1 = null;
}



async function evalConditionInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : NumberValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : NumberValue.NaN;

    if (   val0.isValid() 
        && val1.isValid())
        return new NumberValue(op(val0.toNumber(), val1.toNumber()) ? 1 : 0);
    else                  
        return NumberValue.NaN;
}


class GCondition
extends GNumberType
{
    input0 = null;
    input1 = null;

    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_CONDITION, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondition(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        switch (op.value)
        {
            case CONDITION_LESS:              this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a >  b), parse);  break;
        }


        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);


        this.validate();

        return this;
    }
}


class GEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a == b, 
            parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GNotEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNotEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a != b, 
            parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GLess
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLess(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            this.value = await evalConditionInputs(
                this.input0, 
                this.input1, 
                (a, b) => a < b, 
                parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GLessOrEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLessOrEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            this.value = await evalConditionInputs(
                this.input0, 
                this.input1, 
                (a, b) => a <= b, 
                parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GGreater
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreater(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a > b, 
            parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GGreaterOrEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreaterOrEqual(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a >= b, 
            parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GTextType
extends GOperator
{
    value = null;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GText
extends GTextType
{
    input = null;
    


    constructor(nodeId, options)
    {
        super(TEXT, nodeId, options);
    }



    copy()
    {
        const copy = new GText(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.value = this.value;
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = new TextValue();//TextValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return this.value != NAN_CHAR;
    }
}


class GTextSubstring
extends GTextType
{
    input = null;

    start;
    end;


    
    constructor(nodeId, options)
    {
        super(TEXT_SUBSTRING, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextSubstring(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();

        let   length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            length = input.value.length;
            
            this.value = input.copy();
            
            console.assert(
                this.value.type == TEXT_VALUE, 
                'this.value.type must be TEXT_VALUE');
                
                
            if(start.value <= end.value)
            {
                if (this.options.enabled)
                    this.value.value = this.value.value.substring(start.value, end.value);
            }
            else
                this.value = new TextValue();//TextValue.NaN;
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'length', new NumberValue(length)); // used to set start and end maxima
        genPushUpdateValue(parse, this.nodeId, 'start',  start);
        genPushUpdateValue(parse, this.nodeId, 'end',    end);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GTextCharacter
extends GTextType
{
    input = null;

    code;


    
    constructor(nodeId, options)
    {
        super(TEXT_CHAR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCharacter(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.code = this.code.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const code = (await this.code.eval(parse)).toValue();


        this.value = new TextValue(String.fromCharCode(code.value));


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'code',  code);


        this.validate();

        return this;
    }
}



class GTextReplace
extends GTextType
{
    input = null;

    what;
    with;



    constructor(nodeId, options)
    {
        super(TEXT_REPLACE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextReplace(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.what  = this.what .copy();
        copy.with  = this.with .copy();

        copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _what = (await this.what.eval(parse)).toValue();
        const _with = (await this.with.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == TEXT_VALUE, 
                'this.value.type must be TEXT_VALUE');

            this.value.value = this.value.value.replaceAll(
                _what.value,
                _with.value);
        }
        else
            this.value = new TextValue();//TextValue.NaN;

            
        genPushUpdateValue(parse, this.nodeId, 'what',  _what);
        genPushUpdateValue(parse, this.nodeId, 'with',  _with);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        
        this.validate();

        return this;
    }
}



class GTextJoin
extends GTextType
{
    inputs = [];


    
    constructor(nodeId, options)
    {
        super(TEXT_JOIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextJoin(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalJoinInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



async function evalJoinInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return new TextValue();//TextValue.NaN;


    const value = new TextValue();


    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        console.assert(
            val.type == TEXT_VALUE, 
            'val.type must be TEXT_VALUE');

        value.value += val.value;
    }


    return value;
}


class GTextCSV
extends GOperator
{
    inputs = [];

    value;
    separator;



    constructor(nodeId, options)
    {
        super(TEXT_CSV, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCSV(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());

        copy.value     = this.value    .copy();
        copy.separator = this.separator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        // for (let i = 0; i < this.inputs.length; i++)
        // {
        //     const input = (await this.inputs[i].eval(parse)).toValue();

        //     if (input.type == LIST_VALUE)
        //     {
        //         for (const item of input.items)
        //             this.value.items.push(item);   
        //     }
        //     else
        //         this.value.items.push(input);
        // }
    

        genPushUpdateValue(parse, this.nodeId, 'value',     this.value    );
        genPushUpdateValue(parse, this.nodeId, 'separator', this.separator);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



//var fetchResolve = null;
//fetchResponse = null;



class GTextFetch
extends GTextType
{
    input = null;

    request;



    constructor(nodeId, options)
    {
        super(TEXT_FETCH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextFetch(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.request = this.request.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const request = (await this.request.eval(parse)).toValue();


        genInitNodeProgress(this.nodeId);


        try 
        {
            await fetch(request.value)
                .then(response => response.text())
                .then(text => this.value = new TextValue(text));
        }
        catch (e)
        {
            this.value = 
                request.value.trim() == NULL
                ? new TextValue() //TextValue.NaN
                : new TextValue(e.message);
        }


        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
        genPushUpdateValue(parse, this.nodeId, 'request', request   );

        
        this.validate();

        return this;
    }
}



// function genFetchResponse(result, response)
// {
//     console.assert(fetchResolve, 'fetchResolve cannot be null');
//     fetchResolve(response);
//     console.log('resolve');
// }


class ColorCorrection
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    
    constructor(name = '', max = 0, value = 0)//, locked = false)
    {
        this.name  = name;
        this.max   = max;
        this.value = value;
    }
}



function findCorrection(nodeId,
                        color,
                        order,       margin1, margin2, margin3,
                        lockedOrder, locked1, locked2, locked3) 
{
    const refOklab = dataColor2array(dataColor2oklab(color));

    
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = order ? order.value : -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);


    let d = 1;

    //dLoop:
    while (d > 1/1024)
    {
        //if (stopGenerate) break dLoop;

        let _closestColor = [...closestColor];


        for (let _order = 0; _order < 6; _order++)
        {
            //if (stopGenerate) break dLoop;

            closestColor = [..._closestColor];

            const [min1, min2, min3] = getMinCorrections(color[0], _order);
            const [max1, max2, max3] = getMaxCorrections(color[0], _order);

            let start1 = lerp(min1, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(min2, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(min3, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = margin1.toNumber(); start1 = closest1; end1 = closest1+Epsilon; }
            if (locked2) { closest2 = margin2.toNumber(); start2 = closest2; end2 = closest2+Epsilon; }
            if (locked3) { closest3 = margin3.toNumber(); start3 = closest3; end3 = closest3+Epsilon; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = findCorrectionInOrder(
                nodeId,
                refOklab,
                _order, 
                lockedOrder, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }

        
        d /= 2;
    }


    //if (!stopGenerate)
    //{
        // reduce closest to necessary minimums

        const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

        let c1 = closest1;
        let c2 = closest2;
        let c3 = closest3;

        while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
        while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
        while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

        closest1 = Math.max(0, c1);
        closest2 = Math.max(0, c2);
        closest3 = Math.max(0, c3);
    //}

    
    //stopGenerate = false;


    return [
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



function findCorrectionInOrder(nodeId,
                               refOklab,
                               order, 
                               lockedOrder, 
                               locked1,  locked2,  locked3,
                               closest1, closest2, closest3,
                               start1,   start2,   start3, 
                               end1,     end2,     end3,
                               closestColor,
                               closestOklab,
                               closestOrder,
                               progress,
                               total)
{
    const color = [...closestColor];
    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    cLoop:
    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
        //if (stopGenerate) break cLoop;

        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            //if (stopGenerate) break cLoop;

            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                //if (stopGenerate) break cLoop;

                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsOk(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    
                    if (!lockedOrder)
                        closestOrder = order;

                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;
                }

                progress++;
            }
        }

        
        //if (!stopGenerate)
            genUpdateNodeProgress(nodeId, progress / total);
    }

    
    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = correctColor(color, order, m1, m2, m3);
    const oklab  = dataColor2array(dataColor2oklab(_color));
    const rgb    = oklab2rgb(oklab);

    return [_color, oklab, rgb];
}



function correctColor(color, order, margin1, margin2, margin3)
{
    if (order < 0)
        return color;


    const [i1, i2, i3] = getCorrectionsInOrder(order);

                               color = correctChannel(color, i1, margin1);
    if (!dataColorIsOk(color)) color = correctChannel(color, i2, margin2);
    if (!dataColorIsOk(color)) color = correctChannel(color, i3, margin3);


    // clip colors that are reasonably valid but stick over the fence
    
    let rgb = dataColor2rgb(color);

    if (rgbIsOk(rgb))
        rgb = invalid2validRgb(rgb);
    
        
    color = convertDataColorToSpace(
        rgb2dataColor(rgb),
        color[0]);

        
    return color;
}



function correctChannel(color, iChan, margin)
{
    const factor = colorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsOk(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorOk(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorOk( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsOk(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorOk(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsOk(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorOk(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorOk(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsOk(color);
}



function getCorrectionsInOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }

    // should never get here
    console.assert(false, 'invalid correction order ' + order);
    return [0, 0, 0];
}



function getMinCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let min;

    switch (space)
    {
        case 'hex':
        case 'rgb':    min = [0, 0, 0]; break

        case 'hsv': 
        case 'hsl':    min = [0, 0, 0]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': min = [0, 0, 0]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    min = [0, -oppFactor[1]/2, -oppFactor[2]/2]; break;
        
        default:
            // should never get here
            console.assert(false, 'invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [min[c1], min[c2], min[c3]];
}



function getMaxCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let max;

    switch (space)
    {
        case 'hex':
        case 'rgb':    max = [...rgbFactor]; break;

        case 'hsv': 
        case 'hsl':    max = [hs_Factor[0]/2, hs_Factor[1], hs_Factor[2]]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': max = [hclFactor[0]/2, hclFactor[1], hclFactor[2]]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    max = [...oppFactor]; break;
        
        default:
            // should never get here
            console.assert(false, 'invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [max[c1], max[c2], max[c3]];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Epsilon
        && c2.closest <  Epsilon
        && c3.closest >= Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Epsilon
          && c2.closest <  Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getColorCorrections(colorSpace)
{
    switch (colorSpace)
    {
    case 'hex':
    case 'rgb':
        return [
            new ColorCorrection('R', rgbFactor[0]),
            new ColorCorrection('G', rgbFactor[1]),
            new ColorCorrection('B', rgbFactor[2]) ];

    case 'hsv':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('V', hs_Factor[2]) ];

    case 'hsl':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('L', hs_Factor[2]) ];

    case 'hclok':
    case 'hclab':
    case 'hcluv':
        return [
            new ColorCorrection('H', hclFactor[0]/2),
            new ColorCorrection('C', hclFactor[1]),
            new ColorCorrection('L', hclFactor[2]) ];

    case 'oklab': 
    case 'lab':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('a', oppFactor[1]),
            new ColorCorrection('b', oppFactor[2]) ];

    case 'luv':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('u', oppFactor[1]),
            new ColorCorrection('v', oppFactor[2]) ];
    }


    console.assert(false, 'invalid color space ' + colorSpace);
    return [
        new ColorCorrection(),
        new ColorCorrection(),
        new ColorCorrection() ];
}


class GColorType
extends GOperator
{
    value;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GColor
extends GColorType
{
    input   = null;

    space   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;

    hasInputs;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.space = this.space.copy();

        if (this.c1) copy.c1 = this.c1.copy();
        if (this.c2) copy.c2 = this.c2.copy();
        if (this.c3) copy.c3 = this.c3.copy();

        if (this.convert) 
            copy.convert = this.convert.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const space = this.space ? (await this.space.eval(parse)).toValue().toInteger() : null; 
        let   c1    = this.c1    ? (await this.c1   .eval(parse)).toValue()             : null;
        let   c2    = this.c2    ? (await this.c2   .eval(parse)).toValue()             : null;
        let   c3    = this.c3    ? (await this.c3   .eval(parse)).toValue()             : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (input.isValid())
            {
                if (this.options.enabled)
                {
                    this.value = new ColorValue(
                        input.space,
                        input.c1, 
                        input.c2, 
                        input.c3);

                    const fromSpaceIndex = input.space.value;

                    const toSpaceIndex = Math.min(Math.max(
                        0,
                        Math.round(space.value)), // round because a value can come in with decimals (TODO fix this)
                        colorSpaceCount(parse)-1);


                    this.convertColor(
                        this.value,
                        colorSpace(fromSpaceIndex), 
                        colorSpace(  toSpaceIndex));

                    this.value.space.value = toSpaceIndex;


                    if (!this.c1) { this.c1 = this.value.c1.copy(); c1 = this.c1.toValue(); }
                    if (!this.c2) { this.c2 = this.value.c2.copy(); c2 = this.c2.toValue(); }
                    if (!this.c3) { this.c3 = this.value.c3.copy(); c3 = this.c3.toValue(); }
                
                    if (c1) this.value.c1 = c1;
                    if (c2) this.value.c2 = c2;
                    if (c3) this.value.c3 = c3;
                }
                else
                    this.value = input;
            }
            else
                this.value = ColorValue.NaN;


            if (!this.convert)
                this.convert = NumberValue.NaN;
        }
        else
        {
            this.value = new ColorValue(space, c1, c2, c3);


            const toSpaceIndex = Math.min(Math.max(
                0,
                Math.round(this.value.space.value)), // round because a value can come in with decimals (TODO fix this)
                colorSpaceCount(parse)-1);

            this.value.space.value = toSpaceIndex;

            if (    this.convert
                &&  this.convert.isValid()
                &&  this.convert.value > -1
                &&  this.value.isValid()
                && !this.hasInputs)
            {
                await this.convert.eval(parse);

                this.convertColor(
                    this.value,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }


            if (!this.c1) this.c1 = this.value.c1.copy();
            if (!this.c2) this.c2 = this.value.c2.copy();
            if (!this.c3) this.c3 = this.value.c3.copy();
        }


        if (!this.value.space.isValid())
            this.value = new ColorValue(
                this.space.toValue(),
                NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN);


        // if (this.options.enabled)
        // {
            genPushUpdateValue(parse, this.nodeId, 'convert', this.convert    );
            genPushUpdateValue(parse, this.nodeId, 'space',   this.value.space);
            genPushUpdateValue(parse, this.nodeId, 'c1',      this.value.c1   );
            genPushUpdateValue(parse, this.nodeId, 'c2',      this.value.c2   );
            genPushUpdateValue(parse, this.nodeId, 'c3',      this.value.c3   );
        // }


        this.validate();

        return this;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2)];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    toValue()
    {
        return this.options.enabled
             ? this.value.copy()
             : ColorValue.NaN;
    }
}


class GValidColor
extends GColorType
{
    input        = null;
     
    quality      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(VALID_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GValidColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.quality) copy.quality = this.quality.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const quality = this.quality ? (await this.quality.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                if (   !isValid(this.value) 
                    || !this.value.isValid()) 
                {
                    let rgb = input.toRgb();

                    if (quality.value == 0) // clip sRGB
                    {
                        rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
                        rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
                        rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
                        
                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else if (quality.value == 1) // clip chroma
                    {
                        rgb = clipChroma(rgb);

                        rgb[0] = Math.round(rgb[0] * 0xff);   
                        rgb[1] = Math.round(rgb[1] * 0xff);   
                        rgb[2] = Math.round(rgb[2] * 0xff); 

                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else // find corrections
                    {
                        if (!rgbIsOk(rgb))
                            genInitNodeProgress(this.nodeId);
                        

                        const inputColor = input.toDataColor();


                        const
                      [ closestOrder,
                        closest1,
                        closest2,
                        closest3 ] = findCorrection(
                            this.nodeId,
                            inputColor, 
                            quality, null,  null,  null, 
                            false,   false, false, false); 

                            
                        //if (!stopGenerate)
                        //{
                            if (   closestOrder >= 0 
                                && closestOrder <  6)
                            {
                                this._color = correctColor(
                                    inputColor,
                                    closestOrder,
                                    closest1,
                                    closest2,
                                    closest3);

                                this.value = ColorValue.fromDataColor(this._color);
                            }
                            else
                            {
                                this.value = ColorValue.NaN;
                            }
                        //}
                    }
                }
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;

            
        genPushUpdateValue(parse, this.nodeId, 'quality', quality);
        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);


        this.validate();

        return this;
    }
}



class GCorrectColor
extends GColorType
{
    input        = null;
     
    order        = null;
    margin1      = null;
    margin2      = null;
    margin3      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(CORRECT_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCorrectColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.order  ) copy.order   = this.order  .copy();
        if (this.margin1) copy.margin1 = this.margin1.copy();
        if (this.margin2) copy.margin2 = this.margin2.copy();
        if (this.margin3) copy.margin3 = this.margin3.copy();
        if (this.value  ) copy.value   = this.value  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const order   = this.order   ? (await this.order  .eval(parse)).toValue().toInteger() : null;
        const margin1 = this.margin1 ? (await this.margin1.eval(parse)).toValue()             : null;
        const margin2 = this.margin2 ? (await this.margin2.eval(parse)).toValue()             : null;
        const margin3 = this.margin3 ? (await this.margin3.eval(parse)).toValue()             : null;

    
        if (order)
            order.value = Math.min(Math.max(0, order.value), 5);


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                if (   isValid(this.order  ) && this.order  .isValid()
                    && isValid(this.margin1) && this.margin1.isValid()
                    && isValid(this.margin2) && this.margin2.isValid()
                    && isValid(this.margin3) && this.margin3.isValid()
                    && isValid(this.value  ) && this.value  .isValid())
                {
                    genPushUpdateValue(parse, this.nodeId, 'order'  , this.order  );
                    genPushUpdateValue(parse, this.nodeId, 'margin1', this.margin1);
                    genPushUpdateValue(parse, this.nodeId, 'margin2', this.margin2);
                    genPushUpdateValue(parse, this.nodeId, 'margin3', this.margin3);
                    genPushUpdateValue(parse, this.nodeId, 'value'  , this.value  );
                }
                else
                {
                    const rgb = input.toRgb();
                    
                    if (!rgbIsOk(rgb))
                        genInitNodeProgress(this.nodeId);


                    const inputColor = input.toDataColor();


                    const
                  [ closestOrder,
                    closest1,
                    closest2,
                    closest3 ] = findCorrection(
                        this.nodeId,
                        inputColor, 
                        order, margin1, margin2, margin3, 
                        this.order   != null,
                        this.margin1 != null, 
                        this.margin2 != null, 
                        this.margin3 != null); 

                        
                    //if (!stopGenerate)
                    //{
                        if (   closestOrder >= 0 
                            && closestOrder <  6)
                        {
                            this._color = correctColor(
                                inputColor,
                                closestOrder,
                                closest1,
                                closest2,
                                closest3);

                                
                            this.order   = new NumberValue(closestOrder);
                            this.margin1 = new NumberValue(closest1);
                            this.margin2 = new NumberValue(closest2);
                            this.margin3 = new NumberValue(closest3);
                            this.value   = ColorValue.fromDataColor(this._color);

                            genPushUpdateValue(parse, this.nodeId, 'order',   new NumberValue(closestOrder));
                            genPushUpdateValue(parse, this.nodeId, 'margin1', new NumberValue(closest1    ));
                            genPushUpdateValue(parse, this.nodeId, 'margin2', new NumberValue(closest2    ));
                            genPushUpdateValue(parse, this.nodeId, 'margin3', new NumberValue(closest3    ));
                            genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
                        }
                        else
                        {
                            this.order   = NumberValue.NaN;
                            this.margin1 = NumberValue.NaN;
                            this.margin2 = NumberValue.NaN;
                            this.margin3 = NumberValue.NaN;
                            this.value   = ColorValue .NaN;

                            genPushUpdateValue(parse, this.nodeId, 'order',   NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'margin1', NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'margin2', NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'margin3', NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'value',   ColorValue .NaN);
                        }
                    //}
                }
            }
            else
            {
                this.order   = NumberValue.NaN;
                this.margin1 = NumberValue.NaN;
                this.margin2 = NumberValue.NaN;
                this.margin3 = NumberValue.NaN;
                this.value   = input;

                genPushUpdateValue(parse, this.nodeId, 'order'  , this.order  );
                genPushUpdateValue(parse, this.nodeId, 'margin1', this.margin1);
                genPushUpdateValue(parse, this.nodeId, 'margin2', this.margin2);
                genPushUpdateValue(parse, this.nodeId, 'margin3', this.margin3);
                genPushUpdateValue(parse, this.nodeId, 'value',   this.value  );
            }
        }
        else
        {
            this.order   = NumberValue.NaN;
            this.margin1 = NumberValue.NaN;
            this.margin2 = NumberValue.NaN;
            this.margin3 = NumberValue.NaN;
            this.value   = ColorValue .NaN;

            genPushUpdateValue(parse, this.nodeId, 'order',   NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin1', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin2', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin3', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'value',   ColorValue .NaN);
        }


        this.validate();

        return this;
    }
}



class GColorContrast
extends GColorType
{
    input0 = null;
    input1 = null;

    standard;
    contrast;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorContrast(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.standard = this.standard.copy();
        copy.contrast = this.contrast.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const standard = (await this.standard.eval(parse)).toValue().toInteger();

        
        if (standard.isValid())
            standard.value = Math.min(Math.max(0, standard.value), 1);


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();


            if (   input0.isValid()
                && input1.isValid())
            {
                this.value = input1;
                
                if (   dataColorIsValid(input0.toDataColor())
                    && dataColorIsValid(input1.toDataColor()))
                {
                    if (standard.value == 0)
                    {
                        const value = getContrastRatio2(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 2);
                    }
                    else
                    {
                        const value = getContrastRatio3(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 1);
                    }
                }
                else
                    this.contrast = NumberValue.NaN;
            }
            else
            {
                this.value    = ColorValue.NaN;
                this.contrast = NumberValue.NaN;
            }


            genPushUpdateValue(parse, this.nodeId, 'text', input0);
            genPushUpdateValue(parse, this.nodeId, 'back', input1);
        }

        else if (this.input0) 
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            genPushUpdateValue(parse, this.nodeId, 'text', input0.isValid() ? input0 : ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', ColorValue.NaN);

            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else if (this.input1) 
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', input1.isValid() ? input1 : ColorValue.NaN);

            this.value    = input1.isValid() ? input1 : ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else
        {
            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;

            genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', ColorValue.NaN);
        }
        


        genPushUpdateValue(parse, this.nodeId, 'standard', standard);
        genPushUpdateValue(parse, this.nodeId, 'contrast', this.contrast);


        this.validate();

        return this;
    }
}



class GColorBlind
extends GColorType
{
    input = null;

    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlind(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.l = this.l.copy();
        copy.m = this.m.copy();
        copy.s = this.s.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const l = (await this.l.eval(parse)).toValue();        
        const m = (await this.m.eval(parse)).toValue();
        const s = (await this.s.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            const rgb   = input.toRgb();

            if (this.options.enabled)
            {
                const rgbCb = rgb2colorblind(
                    rgb,
                    l.value / 2,
                    m.value / 2,
                    s.value / 2);

                if (   !rgbIsNaN(rgb)
                    && !rgbIsNaN(rgbCb))
                {
                    const validRgbCb = rgbCb;
                
                    const validCol = convertDataColorToSpace(
                        rgb2dataColor(validRgbCb), 
                        colorSpace(input.space.value));

                    this.value = ColorValue.fromDataColor(validCol);
                }
                else
                    this.value = ColorValue.NaN;
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'l',     l);
        genPushUpdateValue(parse, this.nodeId, 'm',     m);
        genPushUpdateValue(parse, this.nodeId, 's',     s);
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GColorInterpolate
extends GColorType
{
    input0 = null;
    input1 = null;

    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.space  = this.space .copy();
        copy.amount = this.amount.copy();
        copy.gamma  = this.gamma .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space  = (await this.space .eval(parse)).toValue().toInteger();
        const amount = (await this.amount.eval(parse)).toValue();
        const gamma  = (await this.gamma .eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            console.assert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const f = amount.value / 100;


            const spaceIndex = Math.min(Math.max(0, space.value), colorSpaceCount()-1);
            const gammaValue = Math.max(0.0001, gamma.value);

            const _space = colorSpace(spaceIndex);

            const _color = this.interpolate(
                spaceIndex,
                convertDataColorToSpace(input0.toDataColor(), _space),
                convertDataColorToSpace(input1.toDataColor(), _space),
                f,
                gammaValue);


            // allow interpolating invalid colors,
            // so no valid color check here

            this.value = ColorValue.fromDataColor(_color, spaceIndex);
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'space',  space );
        genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        genPushUpdateValue(parse, this.nodeId, 'gamma',  gamma );
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);


        this.validate();
        
        return this;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (   space <= 1
            || space >  6) // hex, rgb, okLab, lab, luv
        {
            const r0 = Math.pow(col0[1], gamma);  const r1 = Math.pow(col1[1], gamma);
            const g0 = Math.pow(col0[2], gamma);  const g1 = Math.pow(col1[2], gamma);
            const b0 = Math.pow(col0[3], gamma);  const b1 = Math.pow(col1[3], gamma);

            gamma = Math.max(0.01, gamma);

            return [
                colorSpace(space),
                Math.pow(lerp(r0, r1, f), 1/gamma),
                Math.pow(lerp(g0, g1, f), 1/gamma),
                Math.pow(lerp(b0, b1, f), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }
}



class GColorBlend
extends GColorType
{
    input0 = null;
    input1 = null;

    mode;
    opacity;
    

    constructor(nodeId, options)
    {
        super(COLOR_BLEND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlend(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.mode    = this.mode   .copy();
        copy.opacity = this.opacity.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const mode    = (await this.mode   .eval(parse)).toValue().toInteger();
        const opacity = (await this.opacity.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            console.assert(
                opacity.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const _opacity = opacity.value / 100;

            const modeIndex = Math.min(Math.max(0, mode.value), BlendModes.length-1);


            const col = this.blend(
                modeIndex,
                input0.toRgb(),
                input1.toRgb(),
                _opacity);

            this.value = ColorValue.fromRgb(scaleRgb(col));
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
        genPushUpdateValue(parse, this.nodeId, 'mode',    mode );
        genPushUpdateValue(parse, this.nodeId, 'opacity', opacity);


        this.validate();
        
        return this;
    }



    blend(mode, col0, col1, opacity)
    {
        switch (mode)
        {
            case  0: return blendNormal    (col0, col1, opacity);

            case  1: return blendDarken    (col0, col1, opacity);
            case  2: return blendMultiply  (col0, col1, opacity);
            case  3: return blendColorBurn (col0, col1, opacity);

            case  4: return blendLighten   (col0, col1, opacity);
            case  5: return blendScreen    (col0, col1, opacity);
            case  6: return blendColorDodge(col0, col1, opacity);

            case  7: return blendOverlay   (col0, col1, opacity);
            case  8: return blendSoftLight (col0, col1, opacity);
            case  9: return blendHardLight (col0, col1, opacity);

            case 10: return blendDifference(col0, col1, opacity);
            case 11: return blendExclusion (col0, col1, opacity);

            case 12: return blendHue       (col0, col1, opacity);
            case 13: return blendSaturation(col0, col1, opacity);
            case 14: return blendColor     (col0, col1, opacity);
            case 15: return blendLuminosity(col0, col1, opacity);
        }
    }
}



function blendNormal(col, back, opacity)
{
    return [ col[0] * opacity + back[0] * (1 - opacity),
             col[1] * opacity + back[1] * (1 - opacity),
             col[2] * opacity + back[2] * (1 - opacity) ];
}



function blendDarken(col, back, opacity)
{
    return blendNormal(
        [ Math.min(back[0], col[0]),
          Math.min(back[1], col[1]),
          Math.min(back[2], col[2]) ],
        back,
        opacity);
}



function chanMultiply(c, b)
{
    return c * b;
}



function blendMultiply(col, back, opacity)
{
    return blendNormal(
        [ chanMultiply(col[0], back[0]),
          chanMultiply(col[1], back[1]),
          chanMultiply(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorBurn(c, b)
{
         if (b == 1) return 1;
    else if (c == 0) return 0;
    else             return 1 - Math.min((1 - b) / c, 1);
}



function blendColorBurn(col, back, opacity)
{
    return blendNormal(
         [ chanColorBurn(col[0], back[0]),
           chanColorBurn(col[1], back[1]),
           chanColorBurn(col[2], back[2]) ],
        back,
        opacity);
}



function blendLighten(col, back, opacity)
{
    return blendNormal(
        [ Math.max(back[0], col[0]),
          Math.max(back[1], col[1]),
          Math.max(back[2], col[2]) ],
        back,
        opacity);
}



function chanScreen(c, b)
{
    return b + c - b*c;
}



function blendScreen(col, back, opacity)
{
    return blendNormal(
        [ chanScreen(col[0], back[0]),
          chanScreen(col[1], back[1]),
          chanScreen(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorDodge(c, b)
{
         if (b == 0) return 0;
    else if (c == 1) return 1;
    else             return Math.min(b / (1 - c), 1);
}



function blendColorDodge(col, back, opacity)
{
    return blendNormal(
        [ chanColorDodge(col[0], back[0]),
          chanColorDodge(col[1], back[1]),
          chanColorDodge(col[2], back[2]) ],
        back,
        opacity);
}



function blendOverlay(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(back[0], col[0]),
          chanHardLight(back[1], col[1]),
          chanHardLight(back[2], col[2]) ],
        back,
        opacity);
}



function bSL_D(b)
{
    return b <= 0.25
         ? ((16 * b - 12) * b + 4) * b
         : Math.sqrt(b);
}



function chanSoftLight(c, b)
{
    return c <= 0.5
         ? b - (1 - 2*c) * b * (1 - b)
         : b + (2*c - 1) * (bSL_D(b) - b);
}



function blendSoftLight(col, back, opacity)
{
    return blendNormal(
        [ chanSoftLight(col[0], back[0]),
          chanSoftLight(col[1], back[1]),
          chanSoftLight(col[2], back[2]) ],
        back,
        opacity);
}



function chanHardLight(c, b)
{
    if (c <= 0.5) return chanMultiply(b, 2 * c);
    else          return chanScreen(b, 2 * c - 1);
}



function blendHardLight(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(col[0], back[0]),
          chanHardLight(col[1], back[1]),
          chanHardLight(col[2], back[2]) ],
        back,
        opacity);
}



function blendDifference(col, back, opacity)
{
    return [ Math.abs(back[0] - col[0]),
             Math.abs(back[1] - col[1]),
             Math.abs(back[2] - col[2]) ];
}



function chanExclusion(c, b)
{
    return b + c - 2*b*c;
}



function blendExclusion(col, back, opacity)
{
    return blendNormal(
        [ chanExclusion(col[0], back[0]),
          chanExclusion(col[1], back[1]),
          chanExclusion(col[2], back[2]) ],
        back,
        opacity);
}



function bl_lum(col)
{
    return col[0] * 0.30
         + col[1] * 0.59
         + col[2] * 0.11;
}



function bl_setLum(_col, l)
{
    const col = [..._col];

    const d = l - bl_lum(col);

    col[0] += d;
    col[1] += d;
    col[2] += d;

    return bl_clamp(col);
}



function bl_sat(col)
{
    return Math.max(col[0], col[1], col[2]) 
         - Math.min(col[0], col[1], col[2]);
}



function bl_min(col)
{
         if (col[0] <= col[1] 
          && col[0] <= col[2]) return 0;
    else if (col[1] <= col[1] 
          && col[1] <= col[2]) return 1;
    else                       return 2;
}



function bl_mid(col)
{
         if (   col[0] >= col[1] 
             && col[0] <= col[2]
          ||    col[0] <= col[1] 
             && col[0] >= col[2]) return 0;
    else if (   col[1] >= col[0] 
             && col[1] <= col[2]
          ||    col[1] <= col[0] 
             && col[1] >= col[2]) return 1;
    else                          return 2;
}



function bl_max(col)
{
         if (col[0] >= col[1] 
          && col[0] >= col[2]) return 0;
    else if (col[1] >= col[1] 
          && col[1] >= col[2]) return 1;
    else                       return 2;
}



function bl_ndx(col) // get min/mid/max chan indices
{
    if (   col[0] == col[1] 
        && col[0] == col[2])
        return [0, 1, 2];

    else 
        return [
            bl_min(col), 
            bl_mid(col), 
            bl_max(col)];
}



function bl_setSat(_col, s)
{
    const col       = [..._col];
    const [n, d, x] = bl_ndx(col);

    if (col[x] > col[n])
    {
        col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));
        col[x] = s;
    }
    else
        col[d] = col[x] = 0;

    col[n] = 0;

    return col;
}



function bl_chanClamp(c, l, n, x)
{
         if (n < 0) return l + (((c - l) * l) / (l - n));
    else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));
    else            return c;
}



function bl_clamp(col)
{
    const l   = bl_lum(col);

    const n = Math.min(col[0], col[1], col[2]);
    const x = Math.max(col[0], col[1], col[2]);

    return [ bl_chanClamp(col[0], l, n, x),
             bl_chanClamp(col[1], l, n, x),
             bl_chanClamp(col[2], l, n, x) ];
}



function blendHue(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(col, bl_sat(back)), bl_lum(back)),
        back,
        opacity);
}



function blendSaturation(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(back, bl_sat(col)), bl_lum(back)),
        back,
        opacity);
}



function blendColor(col, back, opacity)
{
    return blendNormal(
        bl_setLum(col, bl_lum(back)),
        back,
        opacity);
}



function blendLuminosity(col, back, opacity)
{
    return blendNormal(
        bl_setLum(back, bl_lum(col)),
        back,
        opacity);
}


class GColorStop
extends GOperator
{
    input    = null;

    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorStop(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.fill    ) copy.fill     = this.fill    .copy();
        if (this.position) copy.position = this.position.copy();

        return copy;
    }



    async eval(parse)
    {
        if (!this.valid)
        {
            this.result = new ColorStopValue();


            if (this.input)
            {
                this.result = (await this.input.eval(parse)).copy();

                console.assert(
                    this.result.type == COLOR_STOP_VALUE, 
                    'this.result.type must be COLOR_STOP_VALUE');

                if (this.result.isValid())
                {
                    if (this.fill    ) this.result.fill     = (await this.fill    .eval(parse)).copy();
                    if (this.position) this.result.position = (await this.position.eval(parse)).copy();
                }
            }
            else
            {
                this.result.fill     = (await this.fill    .eval(parse)).copy();
                this.result.position = (await this.position.eval(parse)).copy();
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this;
    }
}


class GShape
extends GOperator
{
    props   = null;
   


    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        this.copyProperties(base.props);
    }



    copyProperties(props)
    {
        this.props = props.map(p => p.copy());
    }



    async evalBase(parse, input)
    {
        const props = this.props ? (await this.props.eval(parse)).toValue() : null;


        if (this.input)
            this.value.props = props ?? input.props;
        else
            this.value.props = props;


        genPushUpdateValue(parse, this.nodeId, 'props', this.value.props);
    }



    async evalObjects(parse)
    {
        for (const obj of this.objects)
        {
            for (let i = this.value.props.items.length-1; i >= 0; i--)
            {
                const prop = this.value.props.items[i];
                

                if (prop.type == COLOR_VALUE)
                {
                    if (!obj.fills) 
                        obj.fills = [];


                    const rgb = scaleRgb(prop.toRgb());

                    obj.fills.push([
                        'SOLID', 
                                rgb[0]
                        + ' ' + rgb[1]
                        + ' ' + rgb[2]
                        + ' ' + '255']);
                }

                else if (prop.type == FILL_VALUE)
                {
                    if (!obj.fills) 
                        obj.fills = [];


                    const rgb = scaleRgb(prop.color.toRgb());

                    obj.fills.push([
                        'SOLID', 
                                rgb[0]
                        + ' ' + rgb[1]
                        + ' ' + rgb[2]
                        + ' ' + prop.opacity.toValue().toNumber()]);
                }

                else if (prop.type == STROKE_VALUE)
                {
                    if (!obj.strokes)
                        obj.strokes = [];


                    const rgb = scaleRgb(prop.fill.color.toRgb());

                    obj.strokes.push([
                        'SOLID', 
                                rgb[0]
                        + ' ' + rgb[1]
                        + ' ' + rgb[2]
                        + ' ' + prop.fill.opacity.toValue().toNumber()]);


                    obj.strokeWeight = prop.weight.toValue().toNumber();

                    switch (prop.fit.toValue().value)
                    {
                        case 0: obj.strokeFit = 'INSIDE';  break;
                        case 1: obj.strokeFit = 'CENTER';  break;
                        case 2: obj.strokeFit = 'OUTSIDE'; break;
                    }

                    switch (prop.join.toValue().value)
                    {
                        case 0: obj.strokeJoin = 'MITER'; break;
                        case 1: obj.strokeJoin = 'BEVEL'; break;
                        case 2: obj.strokeJoin = 'ROUND'; break;
                    }

                    obj.strokeMiterLimit = prop.miter.toValue().value;
                }
            }
        }
    }


    
    evalStyle(options = {})
    {
        // for (const style of this.styles)
        //     style.nodeId = this.nodeId;
    }



    isValid()
    {
        return this.props.isValid()
            && super.isValid();
    }
}


class GRectangle
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    copy()
    {
        const copy = new GRectangle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();
        if (this.round ) copy.round  = this.round .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;
        const height = this.height ? (await this.height.eval(parse)).toValue() : null;
        const angle  = this.angle  ? (await this.angle .eval(parse)).toValue() : null;
        const round  = this.round  ? (await this.round .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new RectangleValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                angle  ?? input.angle,
                round  ?? input.round);
        }
        else
        {
            this.value = new RectangleValue(this.nodeId, x, y, width, height, angle, round);
        }

       
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value       );
        genPushUpdateValue(parse, this.nodeId, 'x',      this.value.x     );
        genPushUpdateValue(parse, this.nodeId, 'y',      this.value.y     );
        genPushUpdateValue(parse, this.nodeId, 'width',  this.value.width );
        genPushUpdateValue(parse, this.nodeId, 'height', this.value.height);
        genPushUpdateValue(parse, this.nodeId, 'angle',  this.value.angle );
        genPushUpdateValue(parse, this.nodeId, 'round',  this.value.round );


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.value.x 
            && this.value.y 
            && this.value.width 
            && this.value.height 
            && this.value.angle 
            && this.value.round)
        {
            this.objects = 
            [
                new FigmaRectangle(
                                this.nodeId,
                                0,
                                this.value.x     .value,
                                this.value.y     .value,
                                this.value.width .value,
                                this.value.height.value,
                                this.value.angle .value,
                    Math.max(0, this.value.round .value))
            ];
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid()
            && super.isValid();
    }



    toValue()
    {
        const rect = new RectangleValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.angle .toValue(),
            this.round .toValue());

        rect.props = this.props.toValue();

        return rect;
    }
}


class GLine
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const copy = new GLine(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.angle ) copy.angle  = this.angle .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const x     = this.x     ? (await this.x    .eval(parse)).toValue() : null;
        const y     = this.y     ? (await this.y    .eval(parse)).toValue() : null;
        const width = this.width ? (await this.width.eval(parse)).toValue() : null;
        const angle = this.angle ? (await this.angle.eval(parse)).toValue() : null;

        
        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new LineValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                width ?? input.width,
                angle ?? input.angle);
        }
        else
        {
            this.value = new LineValue(this.nodeId, x, y, width, angle);
        }


            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value      );
        genPushUpdateValue(parse, this.nodeId, 'x',     this.value.x    );
        genPushUpdateValue(parse, this.nodeId, 'y',     this.value.y    );
        genPushUpdateValue(parse, this.nodeId, 'width', this.value.width);
        genPushUpdateValue(parse, this.nodeId, 'angle', this.value.angle);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.x 
            && this.y 
            && this.width 
            && this.angle)
        {
            this.objects = 
            [
                new FigmaLine(
                    this.nodeId,
                    0,
                    this.value.x    .value,
                    this.value.y    .value,
                    this.value.width.value,
                    this.value.angle.value)
            ];
        }

        
        super.evalObjects(parse);
    }



    isValid()
    {
        return this.x    .isValid()
            && this.y    .isValid()
            && this.width.isValid()
            && this.angle.isValid()
            && super.isValid();
    }



    toValue()
    {
        const line = new LineValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.angle .toValue());

        line.props = this.props.toValue();

        return line;
    }
}


class GEllipse
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    copy()
    {
        const copy = new GEllipse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();

        return copy;
    }


    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;
        const height = this.height ? (await this.height.eval(parse)).toValue() : null;
        const angle  = this.angle  ? (await this.angle .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new EllipseValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                angle  ?? input.angle);
        }
        else
        {
            this.value = new EllipseValue(this.nodeId, x, y, width, height, angle);
        }


        genPushUpdateValue(parse, this.nodeId, 'value',  this.value       );
        genPushUpdateValue(parse, this.nodeId, 'x',      this.value.x     );
        genPushUpdateValue(parse, this.nodeId, 'y',      this.value.y     );
        genPushUpdateValue(parse, this.nodeId, 'width',  this.value.width );
        genPushUpdateValue(parse, this.nodeId, 'height', this.value.height);
        genPushUpdateValue(parse, this.nodeId, 'angle',  this.value.angle );


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
   }



   evalObjects(parse, options = {})
   {
       if (!this.options.enabled)
           return;
           
           
       if (   this.x 
           && this.y 
           && this.width 
           && this.height 
           && this.angle)
       {
           this.objects = 
           [
               new FigmaEllipse(
                    this.nodeId,
                    0,
                    this.x     .toValue().value,
                    this.y     .toValue().value,
                    this.width .toValue().value,
                    this.height.toValue().value,
                    this.angle .toValue().value)
           ];
       }

       
       super.evalObjects(parse);
   }



   isValid()
   {
       return this.x     .isValid()
           && this.y     .isValid()
           && this.width .isValid()
           && this.height.isValid()
           && this.angle .isValid()
           && super.isValid();
   }



   toValue()
   {
       const ellipse = new EllipseValue(
           this.nodeId,
           this.x     .toValue(),
           this.y     .toValue(),
           this.width .toValue(),
           this.height.toValue(),
           this.angle .toValue());

        ellipse.props = this.props.toValue();

        return ellipse;
   }
}


class GPolygon
extends GShape
{
    input   = null;

    x       = null;
    y       = null;
    width   = null;
    height  = null;
    angle   = null;
    round   = null;
    corners = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    copy()
    {
        const copy = new GPolygon(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x      ) copy.x       = this.x      .copy();
        if (this.y      ) copy.y       = this.y      .copy();
        if (this.width  ) copy.width   = this.width  .copy();
        if (this.height ) copy.height  = this.height .copy();
        if (this.angle  ) copy.angle   = this.angle  .copy();
        if (this.round  ) copy.round   = this.round  .copy();
        if (this.corners) copy.corners = this.corners.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x       = this.x       ? (await this.x      .eval(parse)).toValue() : null;
        const y       = this.y       ? (await this.y      .eval(parse)).toValue() : null;
        const width   = this.width   ? (await this.width  .eval(parse)).toValue() : null;
        const height  = this.height  ? (await this.height .eval(parse)).toValue() : null;
        const angle   = this.angle   ? (await this.angle  .eval(parse)).toValue() : null;
        const round   = this.round   ? (await this.round  .eval(parse)).toValue() : null;
        const corners = this.corners ? (await this.corners.eval(parse)).toValue() : null;


        let input = null;
             
        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new PolygonValue(
                this.nodeId,
                x       ?? input.x,
                y       ?? input.y,
                width   ?? input.width,
                height  ?? input.height,
                angle   ?? input.angle,
                round   ?? input.round,
                corners ?? input.corners);
        }
        else
        {
            this.value = new PolygonValue(this.nodeId, x, y, width, height, angle, round, corners);
        }

        
        genPushUpdateValue(parse, this.nodeId, 'value',   this.value        );
        genPushUpdateValue(parse, this.nodeId, 'x',       this.value.x      );
        genPushUpdateValue(parse, this.nodeId, 'y',       this.value.y      );
        genPushUpdateValue(parse, this.nodeId, 'width',   this.value.width  );
        genPushUpdateValue(parse, this.nodeId, 'height',  this.value.height );
        genPushUpdateValue(parse, this.nodeId, 'angle',   this.value.angle  );
        genPushUpdateValue(parse, this.nodeId, 'round',   this.value.round  );
        genPushUpdateValue(parse, this.nodeId, 'corners', this.value.corners);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.x 
            && this.y 
            && this.width 
            && this.height 
            && this.angle 
            && this.round
            && this.corners)
        {
            this.objects = 
            [
                new FigmaPolygon(
                                this.nodeId,
                                0,
                                this.x      .toValue().value,
                                this.y      .toValue().value,
                                this.width  .toValue().value,
                                this.height .toValue().value,
                                this.angle  .toValue().value,
                    Math.max(0, this.round  .toValue().value),
                                this.corners.toValue().value)
            ];
        }

        
        super.evalObjects(parse);
    }



    isValid()
    {
        return this.x      .isValid()
            && this.y      .isValid()
            && this.width  .isValid()
            && this.height .isValid()
            && this.angle  .isValid()
            && this.round  .isValid()
            && this.corners.isValid()
            && super.isValid();
    }



    toValue()
    {
        const poly = new PolygonValue(
            this.nodeId,
            this.x      .toValue(),
            this.y      .toValue(),
            this.width  .toValue(),
            this.height .toValue(),
            this.angle  .toValue(),
            this.round  .toValue(),
            this.corners.toValue());

        poly.props = this.props.toValue();

        return poly;
    }
}


class GStar
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;
    points = null;
    convex = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    copy()
    {
        const copy = new GStar(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();
        if (this.round ) copy.round  = this.round .copy();
        if (this.points) copy.points = this.points.copy();
        if (this.convex) copy.convex = this.convex.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;
        const height = this.height ? (await this.height.eval(parse)).toValue() : null;
        const angle  = this.angle  ? (await this.angle .eval(parse)).toValue() : null;
        const round  = this.round  ? (await this.round .eval(parse)).toValue() : null;
        const points = this.points ? (await this.points.eval(parse)).toValue() : null;
        const convex = this.convex ? (await this.convex.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new StarValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                angle  ?? input.angle,
                round  ?? input.round,
                points ?? input.points,
                convex ?? input.convex);
        }
        else
        {
            this.value = new StarValue(this.nodeId, x, y, width, height, angle, round, points, convex);
        }

             
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value       );
        genPushUpdateValue(parse, this.nodeId, 'x',      this.value.x     );
        genPushUpdateValue(parse, this.nodeId, 'y',      this.value.y     );
        genPushUpdateValue(parse, this.nodeId, 'width',  this.value.width );
        genPushUpdateValue(parse, this.nodeId, 'height', this.value.height);
        genPushUpdateValue(parse, this.nodeId, 'angle',  this.value.angle );
        genPushUpdateValue(parse, this.nodeId, 'round',  this.value.round );
        genPushUpdateValue(parse, this.nodeId, 'points', this.value.points);
        genPushUpdateValue(parse, this.nodeId, 'convex', this.value.convex);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
   }



   evalObjects(parse, options = {})
   {
       if (!this.options.enabled)
           return;
           
           
       if (   this.x 
           && this.y 
           && this.width 
           && this.height 
           && this.angle 
           && this.round
           && this.points
           && this.convex)
       {
           this.objects = 
           [
               new FigmaStar(
                               this.nodeId,
                               0,
                               this.x     .toValue().value,
                               this.y     .toValue().value,
                               this.width .toValue().value,
                               this.height.toValue().value,
                               this.angle .toValue().value,
                   Math.max(0, this.round .toValue().value),
                               this.points.toValue().value,
                               this.convex.toValue().value)
           ];
       }

       
       super.evalObjects(parse);
   }



   isValid()
   {
       return this.x     .isValid()
           && this.y     .isValid()
           && this.width .isValid()
           && this.height.isValid()
           && this.angle .isValid()
           && this.round .isValid()
           && this.points.isValid()
           && this.convex.isValid();
   }



   toValue()
   {
       const star = new StarValue(
           this.nodeId,
           this.x     .toValue(),
           this.y     .toValue(),
           this.width .toValue(),
           this.height.toValue(),
           this.angle .toValue(),
           this.round .toValue(),
           this.points.toValue(),
           this.convex.toValue());

        star.props = this.props.toValue();

        return star;
   }
}


class GTextShape
extends GShape
{
    input         = null;

    text          = null;
    x             = null;
    y             = null;
    width         = null;
    height        = null;
    angle         = null;
    font          = null;
    style         = null;
    size          = null;
    alignH        = null;
    alignV        = null;
    lineHeight    = null;
    letterSpacing = null;



    constructor(nodeId, options)
    {
        super(TEXTSHAPE, nodeId, options);
    }



    copy()
    {
        const copy = new GTextShape(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.text         ) copy.text          = this.text         .copy();
        if (this.x            ) copy.x             = this.x            .copy();
        if (this.y            ) copy.y             = this.y            .copy();
        if (this.width        ) copy.width         = this.width        .copy();
        if (this.height       ) copy.height        = this.height       .copy();
        if (this.angle        ) copy.angle         = this.angle        .copy();
        if (this.font         ) copy.font          = this.font         .copy();
        if (this.style        ) copy.style         = this.style        .copy();
        if (this.size         ) copy.size          = this.size         .copy();
        if (this.alignH       ) copy.alignH        = this.alignH       .copy();
        if (this.alignV       ) copy.alignV        = this.alignV       .copy();
        if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();
        if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const text          = this.text          ? (await this.text         .eval(parse)).toValue() : null;
        const x             = this.x             ? (await this.x            .eval(parse)).toValue() : null;
        const y             = this.y             ? (await this.y            .eval(parse)).toValue() : null;
        const width         = this.width         ? (await this.width        .eval(parse)).toValue() : null;
        const height        = this.height        ? (await this.height       .eval(parse)).toValue() : null;
        const angle         = this.angle         ? (await this.angle        .eval(parse)).toValue() : null;
        const font          = this.font          ? (await this.font         .eval(parse)).toValue() : null;
        const style         = this.style         ? (await this.style        .eval(parse)).toValue() : null;
        const size          = this.size          ? (await this.size         .eval(parse)).toValue() : null;
        const alignH        = this.alignH        ? (await this.alignH       .eval(parse)).toValue() : null;
        const alignV        = this.alignV        ? (await this.alignV       .eval(parse)).toValue() : null;
        const lineHeight    = this.lineHeight    ? (await this.lineHeight   .eval(parse)).toValue() : null;
        const letterSpacing = this.letterSpacing ? (await this.letterSpacing.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TextShapeValue(
                this.nodeId,
                text          ?? input.text,
                x             ?? input.x,
                y             ?? input.y,
                width         ?? input.width,
                height        ?? input.height,
                angle         ?? input.angle,
                font          ?? input.font,
                style         ?? input.style,
                size          ?? input.size,
                alignH        ?? input.size,
                alignV        ?? input.size,
                lineHeight    ?? input.size,
                letterSpacing ?? input.size);
        }
        else
        {
            this.value = new TextShapeValue(
                this.nodeId, 
                text, 
                x, 
                y, 
                width, 
                height, 
                angle, 
                font, 
                style,
                size,
                alignH,
                alignV,
                lineHeight,
                letterSpacing);
        }

       
        genPushUpdateValue(parse, this.nodeId, 'value',         this.value              );
        genPushUpdateValue(parse, this.nodeId, 'text',          this.value.text         );
        genPushUpdateValue(parse, this.nodeId, 'x',             this.value.x            );
        genPushUpdateValue(parse, this.nodeId, 'y',             this.value.y            );
        genPushUpdateValue(parse, this.nodeId, 'width',         this.value.width        );
        genPushUpdateValue(parse, this.nodeId, 'height',        this.value.height       );
        genPushUpdateValue(parse, this.nodeId, 'angle',         this.value.angle        );
        genPushUpdateValue(parse, this.nodeId, 'font',          this.value.font         );
        genPushUpdateValue(parse, this.nodeId, 'style',         this.value.style        );
        genPushUpdateValue(parse, this.nodeId, 'size',          this.value.size         );
        genPushUpdateValue(parse, this.nodeId, 'alignH',        this.value.alignH       );
        genPushUpdateValue(parse, this.nodeId, 'alignV',        this.value.alignV       );
        genPushUpdateValue(parse, this.nodeId, 'lineHeight',    this.value.lineHeight   );
        genPushUpdateValue(parse, this.nodeId, 'letterSpacing', this.value.letterSpacing);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;

            
        if (   this.value.text
            && this.value.x 
            && this.value.y 
            && this.value.width 
            && this.value.height 
            && this.value.angle
            && this.value.font
            && this.value.style
            && this.value.size
            && this.value.alignH
            && this.value.alignV
            && this.value.lineHeight
            && this.value.letterSpacing)
        {
            const font = figFonts[this.value.font.value];

            this.objects = 
            [
                new FigmaText(
                    this.nodeId,
                    0,
                    this.value.text         .value,
                    this.value.x            .value,
                    this.value.y            .value,
                    this.value.width        .value,
                    this.value.height       .value,
                    this.value.angle        .value,
                    font.fontName.family,
                    this.value.style        .value,
                    this.value.size         .value,
                    this.value.alignH       .value,
                    this.value.alignV       .value,
                    this.value.lineHeight   .value,
                    this.value.letterSpacing.value)
            ];
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.angle        .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignH       .isValid()
            && this.alignV       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid()
            && super.isValid();
    }



    toValue()
    {
        const rect = new TextShapeValue(
            this.nodeId,
            this.text         .toValue(),
            this.x            .toValue(),
            this.y            .toValue(),
            this.width        .toValue(),
            this.height       .toValue(),
            this.angle        .toValue(),
            this.font         .toValue(),
            this.style        .toValue(),
            this.size         .toValue(),
            this.alignH       .toValue(),
            this.alignV       .toValue(),
            this.lineHeight   .toValue(),
            this.letterSPacing.toValue());

        rect.props = this.props.toValue();

        return rect;
    }
}


class GColorStyle
extends GShape
{
    id;

    colorStyle;

    existing;
    linked;



    constructor(nodeId, options, styleId)
    {
        super(COLOR_STYLE, nodeId, options);

        this.id == styleId;
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        copy.id         = this.id;
        copy.colorStyle = this.colorStyle.copy();
        
        copy.existing   = this.existing;
        copy.linked     = this.linked;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        this.value = (await this.value.eval(parse)).toValue();


        if (   this.value.isValid()
            && (  !this.existing
                || this.linked))
        {
            if (this.value.type == COLOR_VALUE)
                this.value = FillValue.fromRgb(scaleRgb(this.value.toRgb()), 0xff);

            const rgba       = this.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            this.evalStyle({rgba: rgbaStripe});
        }
        else
            this.value = FillValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    evalStyle(options = {})
    {
        if (!this.options.enabled)
            return;

            
        const colorStyle = new FigmaColorStyle(this.nodeId, this.id, this.name);

        colorStyle.existing = this.existing;


        colorStyle.paints = 
        [
            [ 'SOLID', 
                      Math.round(options.rgba[0] * 0xff)
              + ' ' + Math.round(options.rgba[1] * 0xff)
              + ' ' + Math.round(options.rgba[2] * 0xff)
              + ' ' + Math.round(options.rgba[3] * 100 )]
        ];


        this.colorStyle = colorStyle;
    }
}


class GFill
extends GOperator
{
    input   = null;

    color   = null;
    opacity = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    copy()
    {
        const copy = new GFill(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.color  ) copy.color   = this.color  .copy();
        if (this.opacity) copy.opacity = this.opacity.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const color   = this.color   ? (await this.color  .eval(parse)).toValue() : null;
        const opacity = this.opacity ? (await this.opacity.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new FillValue(
                color   ?? input.color,
                opacity ?? input.opacity);
        }
        else
        {
            this.value = new FillValue(color, opacity);
        }


        genPushUpdateValue(parse, this.nodeId, 'color',   this.value.color  );
        genPushUpdateValue(parse, this.nodeId, 'opacity', this.value.opacity);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    toValue()
    {
        return this.options.enabled
             ? new FillValue(
                   this.color   ? this.color  .toValue() : this.input.color  .toValue(),
                   this.opacity ? this.opacity.toValue() : this.input.opacity.toValue())
             : FillValue.NaN;
    }
}


class GStroke
extends GShape
{
    input  = null;

    fill   = null;
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;



    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }



    copy()
    {
        const copy = new GStroke(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.weight) copy.weight = this.weight.copy();
        if (this.fit   ) copy.fit    = this.fit   .copy();
        if (this.join  ) copy.join   = this.join  .copy();
        if (this.miter ) copy.miter  = this.miter .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fill = this.fill ? (await this.fill.eval(parse)).toValue() : null;

        fill = this.validateFill(fill);


        const weight = this.weight ? (await this.weight.eval(parse)).toValue() : null;
        const fit    = this.fit    ? (await this.fit   .eval(parse)).toValue() : null;
        const join   = this.join   ? (await this.join  .eval(parse)).toValue() : null;
        const miter  = this.miter  ? (await this.miter .eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new StrokeValue(
                fill   ?? input.fill,
                weight ?? input.weight,
                fit    ?? input.fit,
                join   ?? input.join,
                miter  ?? input.miter);
        }
        else
        {
            this.value = new StrokeValue(fill, weight, fit, join, miter);
        }


        genPushUpdateValue(parse, this.nodeId, 'fill',   this.value.fill  );
        genPushUpdateValue(parse, this.nodeId, 'weight', this.value.weight);
        genPushUpdateValue(parse, this.nodeId, 'fit',    this.value.fit   );
        genPushUpdateValue(parse, this.nodeId, 'join',   this.value.join  );
        genPushUpdateValue(parse, this.nodeId, 'miter',  this.value.miter );


        this.validate();

        return this;
    }



    validateFill(fill)
    {
        if (!fill)
            return null;


        if (fill.type == COLOR_VALUE)
            return FillValue.fromRgb(scaleRgb(fill.toRgb()), 0xff);
        else
            return fill;
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    toValue()
    {
        return new StrokeValue(
            this.options.enabled
            ? this.validateFill(this.fill ? this.fill.toValue() : this.input.fill.toValue())
            : FillValue.NaN,
            this.weight ? this.weight.toValue() : this.input.weight.toValue(),
            this.fit    ? this.fit   .toValue() : this.input.fit   .toValue(),
            this.join   ? this.join  .toValue() : this.input.join  .toValue(),
            this.miter  ? this.miter .toValue() : this.input.miter .toValue());
    }                 
}


class GGroupNode
extends GOperator
{
    paramIds = [];
    params   = [];



    constructor(nodeId, options)
    {
        super(GROUP_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGroupNode(this.nodeId, this.options);

        copy.copyBase(this);

        copy.params = this.params.map(p => p.copy());

        return copy;
    }



    paramFromId(paramId)
    {
        return this.params[this.paramIds.findIndex(id => id == paramId)];
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (!isEmpty(this.params))
        {
            for (let i = 0; i < this.params.length; i++)
            {
                const param = await this.params[i].eval(parse);
                genPushUpdateValue(parse, this.nodeId, this.paramIds[i], param.toValue());
            }
        }
        else
            genPushUpdateValue(parse, this.nodeId, '', NullValue);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GGroupParam
extends GOperator
{
    input = null;
    
    dataType = NULL;



    constructor(nodeId, options)
    {
        super(GROUP_PARAM, nodeId, options);
    }



    copy()
    {
        const copy = new GGroupParam(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.dataType = this.dataType;
      
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            if (!this.input.value)
                await this.input.eval(parse);

            this.value = this.input.toValue();
        }

        else if (this.dataType != NULL)
            this.value = nullFromType(this.dataType);
        
        else
            this.value = NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GComment
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GComment(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



const settings =
{
    dataMode:                      false,
    debugMode:                     false,
        
    enableZoomedOutParams:         false,
    minZoomForParams:              0.35,
    showPages:                     false,
    showAllColorSpaces:            false,
    showBoolValues:                true,
    showOperationResults:          false,
    showClearUndoWarning:          true,
    showDebugMenu:                 false,
        
    showNodeId:                    false, // instead of name

    showTooltipLongText:           true,
    showTooltipColorInterpolation: true,
    showTooltipColorBlindness:     true,
    showTooltipColorContrast:      true,

    enableBetaFeatures:            false,
            
    logMessages:                   false,
    logActions:                    false, 
            
    logLoading:                    false, 
    logRequests:                   false, 
    logValueUpdates:               false, 
    logObjectUpdates:              false,
    logStyleUpdates:               false,
            
    logRawLoadPages:               false, 
    logRawLoadNodes:               false, 
    logRawLoadConnections:         false, 
        
    logRawSavePages:               false, 
    logRawSaveNodes:               false, 
    logRawSaveConnections:         false, 
        
    logRawRequests:                false, 
    logRawValues:                  false    
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'dataMode':                      settings.dataMode                      = value;  break;
        case 'debugMode':                     settings.debugMode                     = value;  break;
                
        case 'enableZoomedOutParams':         settings.enableZoomedOutParams         = value;  break;
        case 'minZoomForParams':              settings.minZoomForParams              = value;  break;
        case 'showPages':                     settings.showPages                     = value;  break;
        case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;
        case 'showBoolValues':                settings.showBoolValues                = value;  break;
        case 'showOperationResults':          settings.showOperationResults          = value;  break;
        case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;
        case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;
                        
        case 'showNodeId':                    settings.showNodeId                    = value;  break;

        case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;
        case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;
        case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;
        case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;

        case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;
                   
        case 'logMessages':                   settings.logMessages                   = value;  break;
        case 'logActions':                    settings.logActions                    = value;  break;
        case 'logLoading':                    settings.logLoading                    = value;  break;
        case 'logRequests':                   settings.logRequests                   = value;  break;
        case 'logValueUpdates':               settings.logValueUpdates               = value;  break;
        case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;
        case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;
                   
        case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;
        case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;
        case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;
                
        case 'logRawSavePages':               settings.logRawSavePages               = value;  break;
        case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;
        case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;
                
        case 'logRawRequests':                settings.logRawRequests                = value;  break;
        case 'logRawValues':                  settings.logRawValues                  = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'dataMode':                      updateSettingAndMenu_(valid, settingName, value, menuItemDataMode                     ); break;
        case 'debugMode':                     updateSettingAndMenu_(valid, settingName, value                                       ); break;
              
        case 'enableZoomedOutParams':         updateSettingAndMenu_(valid, settingName, value, menuItemEnableZoomedOutParams        ); break;
        case 'showPages':                     updateSettingAndMenu_(valid, settingName, value, menuItemShowPages                    ); break;
        case 'showAllColorSpaces':            updateSettingAndMenu_(valid, settingName, value, menuItemShowAllColorSpaces           ); break;
        case 'showBoolValues':                updateSettingAndMenu_(valid, settingName, value, menuItemShowBoolValues               ); break;
        case 'showOperationResults':          updateSettingAndMenu_(valid, settingName, value, menuItemShowOperationResults         ); break;
        case 'showClearUndoWarning':          updateSettingAndMenu_(valid, settingName, value, menuItemShowClearUndoWarning         ); break;
        case 'showDebugMenu':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowDebugMenu                ); break;
                      
        case 'showNodeId':                    updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId                   ); break;
        
        case 'showTooltipLongText':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipLongText          ); break;
        case 'showTooltipColorContrast':      updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorContrast     ); break;
        case 'showTooltipColorInterpolation': updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorInterpolation); break;
        case 'showTooltipColorBlindness':     updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorBlindness    ); break;

        case 'enableBetaFeatures':            updateSettingAndMenu_(valid, settingName, value, menuItemEnableBetaFeatures           ); break;
                      
        case 'logMessages':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages                  ); break;
        case 'logActions':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogActions                   ); break;
        case 'logLoading':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading                   ); break;
        case 'logRequests':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests                  ); break;
        case 'logValueUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates              ); break;
        case 'logObjectUpdates':              updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates             ); break;
        case 'logStyleUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogStyleUpdates              ); break;
                      
        case 'logRawLoadPages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadPages              ); break;
        case 'logRawLoadNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadNodes              ); break;
        case 'logRawLoadConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadConnections        ); break;
                      
        case 'logRawSavePages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSavePages              ); break;
        case 'logRawSaveNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveNodes              ); break;
        case 'logRawSaveConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveConnections        ); break;
                      
        case 'logRawRequests':                updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests               ); break;
        case 'logRawValues':                  updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues                 ); break;
    } 

    if (   save
        && settingName != 'showAllColorSpaces')
        uiSetLocalData(settingName, boolToString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  

    if (menu)
        menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemDataMode                     .setVisible(settings.dataMode                     );
    menuItemDebug                        .setVisible(settings.debugMode                    );
                
    menuItemEnableZoomedOutParams        .setChecked(settings.enableZoomedOutParams        );
    menuItemShowPages                    .setChecked(settings.showPages                    );
    menuItemShowAllColorSpaces           .setChecked(settings.showAllColorSpaces           );
    menuItemShowBoolValues               .setChecked(settings.showBoolValues               );
    menuItemShowOperationResults         .setChecked(settings.showOperationResults         );
    menuItemShowClearUndoWarning         .setChecked(settings.showClearUndoWarning         );
    menuItemShowDebugMenu                .setChecked(settings.showDebugMenu                );
                
    menuItemShowNodeId                   .setChecked(settings.showNodeId                   );

    menuItemShowTooltipLongText          .setChecked(settings.showTooltipLongText          );
    menuItemShowTooltipColorInterpolation.setChecked(settings.showTooltipColorInterpolation);
    menuItemShowTooltipColorBlindness    .setChecked(settings.showTooltipColorBlindness    );
    menuItemShowTooltipColorContrast     .setChecked(settings.showTooltipColorContrast     );

    menuItemEnableBetaFeatures           .setChecked(settings.enableBetaFeatures           );
                  
    menuItemLogMessages                  .setChecked(settings.logMessages                  );
    menuItemLogActions                   .setChecked(settings.logActions                   );
                  
    menuItemLogLoading                   .setChecked(settings.logLoading                   );
    menuItemLogRequests                  .setChecked(settings.logRequests                  );
    menuItemLogValueUpdates              .setChecked(settings.logValueUpdates              );
    menuItemLogObjectUpdates             .setChecked(settings.logObjectUpdates             );
    menuItemLogStyleUpdates              .setChecked(settings.logStyleUpdates              );
                  
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadPages              );
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadNodes              );
    menuItemLogRawLoadConnections        .setChecked(settings.logRawLoadConnections        );
                    
    menuItemLogRawSavePages              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveNodes              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveConnections        .setChecked(settings.logRawSaveConnections        );
                
    menuItemLogRawRequests               .setChecked(settings.logRawRequests               );
    menuItemLogRawValues                 .setChecked(settings.logRawValues                 );
}



function updateMenuItemShowPages()
{
    uiSetPageData('showPages', boolToString(settings.showPages));
    graph.updatePages();
    graphView.update();
}



function updateMenuItemShowAllColorSpaces()
{
    uiSetPageData('showAllColorSpaces', boolToString(settings.showAllColorSpaces));

    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowBoolValues()
{
    graph.nodes
        .filter(n => 
                 BOOLEAN_TYPES.includes(n.type)
            || CONDITION_TYPES.includes(n.type)
            || n.type == IF_ELSE)
        .forEach(n => n.updateNode());
}



function updateMenuItemShowOperationResults()
{
    const nodes = graph.nodes
        .filter(n => n.params.find(p => p.isResult));

    nodes.forEach(n => n.updateNode());
    graphView.updateNodeTransforms(nodes);
}



function enableFeatures(subscription, beta)
{
    updateElementDisplay(menuItemShowPages           .div, subscription);
    updateElementDisplay(menuPrefSep1                .div, subscription);
    updateElementDisplay(menuPrefSep2                .div, subscription);
    updateElementDisplay(menuItemEnableBetaFeatures  .div, subscription);

    updateElementDisplay(btnFlow                     .div, subscription);
    updateElementDisplay(btnText                     .div, subscription && beta);
    updateElementDisplay(btnShape                    .div, subscription && beta);
    updateElementDisplay(btnGroup                    .div, subscription && beta);

    updateElementDisplay(menuItemLogObjectUpdates    .div, subscription && beta);
    
    updateElementDisplay(menuItemList                .div, subscription && beta);
    updateElementDisplay(menuFlowSep1                .div, subscription && beta);
    //updateElementDisplay(menuItemExpandList          .div, subscription && beta);
    updateElementDisplay(menuItemItems               .div, subscription && beta);
    updateElementDisplay(menuFlowSep2                .div, subscription && beta);
    updateElementDisplay(menuItemSelect              .div, subscription && beta);
    updateElementDisplay(menuItemCount               .div, subscription && beta);
    updateElementDisplay(menuFlowSep3                .div, subscription && beta);
    updateElementDisplay(menuItemRepeat              .div, subscription && beta);
    // updateElementDisplay(menuItemCache               .div, subscription && beta);
    // updateElementDisplay(menuItemCopy                .div, subscription && beta);
    
    updateElementDisplay(menuItemSeries              .div, subscription && beta);    
    updateElementDisplay(menuItemSolve               .div, subscription && beta);    
    updateElementDisplay(menuItemNumberSep1          .div, subscription && beta);
    updateElementDisplay(menuItemAnimate             .div, subscription && beta);    
    updateElementDisplay(menuItemNumberSep2          .div, subscription && beta);
    updateElementDisplay(menuItemNumberConvertToText .div, subscription && beta);
    
    updateElementDisplay(menuItemCorrectColor        .div, subscription);
    updateElementDisplay(menuItemColorSep1           .div, subscription);
    updateElementDisplay(menuItemColorblind          .div, subscription);
    //updateMenuItemDisplay(menuItemColorBlend        .div, beta);

    //updateMenuItemDisplay(menuItemStyleFill         .div, subscription && beta);
    updateElementDisplay(menuItemStyleStroke         .div, subscription && beta);
    //updateMenuItemDisplay(menuItemStyleSep1         .div, subscription && beta);
    
    //updateMenuItemDisplay(menuItemNodeCopyAsJsCode    .div, subscription && beta);
    updateElementDisplay(menuItemNodeCopyAsJsFunction.div, subscription && beta);

    updateElementDisplay(shortcutCopyAsJavascript        , subscription && beta);


    graph.nodes.forEach(n => n.updateSubscribeStatus(subscription));
}



function updateMenuItemShowDebugMenu()
{
    updateElementDisplay(menuItemDebug.div, settings.showDebugMenu);
}

 

function updateElementDisplay(menuItem, enable)
{
    menuItem.style.display = enable ? 'block' : 'none';
}



function loadLocalSettings()
{
    uiGetLocalData('dataMode'                     );
    uiGetLocalData('debugMode'                    );
        
    uiGetLocalData('enableZoomedOutParams'        );
    uiGetLocalData('minZoomForParams'             );
    uiGetLocalData('showBoolValues'               );
    uiGetLocalData('showPages'                    );
    uiGetLocalData('showOperationResults'         );
    uiGetLocalData('showClearUndoWarning'         );
    uiGetLocalData('showDebugMenu'                );
        
    uiGetLocalData('showNodeId'                   );

    uiGetLocalData('showTooltipLongText'          );
    uiGetLocalData('showTooltipColorInterpolation');
    uiGetLocalData('showTooltipColorBlindness'    );
    uiGetLocalData('showTooltipColorContrast'     );

    uiGetLocalData('enableBetaFeatures'           );
            
    uiGetLocalData('logMessages'                  );
    uiGetLocalData('logActions'                   );
            
    uiGetLocalData('logLoading'                   );
    uiGetLocalData('logRequests'                  );
    uiGetLocalData('logValueUpdates'              );
    uiGetLocalData('logObjectUpdates'             );
    uiGetLocalData('logStyleUpdates'              );
            
    uiGetLocalData('logRawLoadPages'              );
    uiGetLocalData('logRawLoadNodes'              );
    uiGetLocalData('logRawLoadConnections'        );
        
    uiGetLocalData('logRawSavePages'              );
    uiGetLocalData('logRawSaveNodes'              );
    uiGetLocalData('logRawSaveConnections'        );
        
    uiGetLocalData('logRawRequests'               );
    uiGetLocalData('logRawValues'                 );
}


var genFigMessagePosted = false;

var uiMessages          = [];


var figFonts            = [];



// --> from UI
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = function(e)
{
    const msg = JSON.parse(e.data);


    // processMessage(msg).next();
    switch (msg.cmd)
    {
        case 'initFonts':        figFonts = msg.fonts;         break;
     
        case 'genRequest':       genRequest(msg.request);      break;

        //case 'genFetchResponse': genFetchResponse(msg.result, msg.response); break;

        //case 'genStopGenerate': genStopGenerate (msg); break;
        
        case 'genEndUiMessage':  genEndUiMessage (msg.msgCmd); break;
        case 'genEndFigMessage': genEndFigMessage();           break;
    }


    genPostMessageToUi({
        cmd:   'uiEndGenMessage',
        msgCmd: msg.cmd
    });
};

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to UI
///////////////////////////////////////////////////////////////////////////////////////////////////

function genPostMessageToUi(msg)
{
    if (msg == undefined)
        console.trace();

    postMessage(JSON.stringify(msg));
}



function genQueueMessageToUi(msg)
{
    uiMessages.push(msg);
    genPostNextMessageToUi();
}



function genPostNextMessageToUi(msg)
{
    if (!isEmpty(uiMessages))
    //    && !genFigMessagePosted)
    {
        //console.log('yes');
        let msg = uiMessages.shift();

        // while (   !isEmpty(uiMessages)
        //        &&  uiMessages[0].cmd     == 'uiUpdateValuesAndObjects'
        //        &&  uiMessages[0].chunkId == 0)
        // {
        //     const nextFirst = uiMessages.find(m => 
        //            m.cmd     == msg.cmd 
        //         && m.chunkId == 0);

        //     if (nextFirst)
        //     {
        //         while (!isEmpty(uiMessages)
        //             &&  uiMessages[0].cmd           == msg.cmd
        //             &&  uiMessages[0].updateNodeId  == msg.updateNodeId
        //             &&  uiMessages[0].updateParamId == msg.updateParamId
        //             &&  uiMessages[0].cmd.chunkId   >  0)
        //             msg = uiMessages.shift();

        //         msg = uiMessages.shift();
        //     }
        // }

        genPostMessageToUi(msg);
    }
}



function genEndUiMessage(msgCmd)
{
    //console.log('next UI message');
    genPostNextMessageToUi();
}



function genEndFigMessage()
{
    genFigMessagePosted = false;
    
    if (   !isEmpty(lastUpdateValues )
        || !isEmpty(lastUpdateObjects)
        || !isEmpty(lastUpdateStyles ))
        genUpdateValuesAndObjects(lastRequestId, -1, lastUpdateNodeId, lastUpdateParamId, [], [], []);

    genPostNextMessageToUi();
}

///////////////////////////////////////////////////////////////////////////////////////////////////


var lastRequestId      = -1;
var lastUpdateNodeId   =  NULL;
var lastUpdateParamId  =  NULL;
var lastUpdateValues   =  [];
var lastUpdateObjects  =  [];
var lastUpdateStyles   =  [];

//var stopGenerate       =  false;



function genRequest(request)
{
    const requestId             = parseInt(request[0]);
    const actionId              = parseInt(request[1]);
    const set                   = parseInt(request[2]);

    const showAllColorSpaces = (set >> 0) & 1 != 0;
    const logRequests           = (set >> 1) & 1 != 0;


    const updateNodeId          = request[3];
    const updateParamId         = request[4];


    const parse = new Parse(
        request, 
        5,
        updateNodeId, 
        updateParamId, 
        showAllColorSpaces,
        logRequests);


    const stackOverflowProtect = 100;

    while (   parse.pos < parse.request.length
           && parse.so  < stackOverflowProtect)
        genParse(parse);


    if (logRequests)
        logRequest(parse);


    const    paramNodes = parse.paramNodeIds.map(id => parse.parsedNodes.find(n => n.nodeId == id));
    const topLevelNodes = parse.parsedNodes.filter(n => n.topLevel);

    (async () =>
    {
        for (const node of    paramNodes) await node.eval(parse);
        for (const node of topLevelNodes) await node.eval(parse);


        for (const node of parse.parsedNodes)
        {
            node.objects.forEach(o => genPushUpdateObject(parse, o));

            if (   node instanceof GShape
                && node.options.active)
                if (!!node.colorStyle) genPushUpdateColorStyle(parse, node.colorStyle);
        }


        genUpdateValuesAndObjects(
            requestId,
            actionId,
            parse.updateNodeId,
            parse.updateParamId,
            parse.updateValues,
            parse.updateObjects,
            parse.updateStyles);
    })
    ();

    //stopGenerate = false;
}



// function genStopGenerate(msg)
// {
//     console.log('%cSTOP', 'color: white; background: #080;');
//     stopGenerate = true;
// }



function genPushUpdateValue(parse, nodeId, paramId, value)
{
    removeFromArrayWhere(parse.updateValues, v =>
           v.nodeId     == nodeId
        && v.paramId    == paramId
        && v.value.type == value.type);

    parse.updateValues.push(
    {
        nodeId:  nodeId,
        paramId: paramId,
        type:    value.type, // needed to correctly parse NAN_DISPLAY
        value:   value
    });
}



function genPushUpdateObject(parse, object)
{
    pushUniqueExcept(
        parse.updateObjects,
        object,
        o =>    o.nodeId   == object.nodeId
             && o.objectId == object.objectId);
}



function genPushUpdateColorStyle(parse, style)
{
    pushUniqueExcept(
        parse.updateStyles,
        style,
        o => o.nodeId == style.nodeId);
}



function clearLastUpdate()
{
    lastRequestId     = -1;
    lastUpdateNodeId  =  NULL;
    lastUpdateParamId =  NULL;

    lastUpdateValues  =  [];
    lastUpdateObjects =  [];
    lastUpdateStyles  =  [];
}



function genUpdateValuesAndObjects(requestId, actionId, updateNodeId, updateParamId, updateValues, updateObjects, updateStyles)
{
    if (   isEmpty(updateValues )
        && isEmpty(updateObjects)
        && isEmpty(updateStyles ))
    {
        requestId     = lastRequestId;
        updateNodeId  = lastUpdateNodeId;
        updateParamId = lastUpdateParamId;
        
        updateValues  = lastUpdateValues;
        updateObjects = lastUpdateObjects;
        updateStyles  = lastUpdateStyles;

        clearLastUpdate();
    }
    else if (genFigMessagePosted)
    {
        lastRequestId     = requestId;
        lastUpdateNodeId  = updateNodeId;
        lastUpdateParamId = updateParamId;

        lastUpdateValues  = updateValues;
        lastUpdateObjects = updateObjects;
        lastUpdateStyles  = updateStyles;

        return;
    }


    const nodeIds = filterUnique(updateValues.map(v => v.nodeId));
    const counts  = nodeIds.map(id => updateValues.filter(v => v.nodeId == id).length);


    // send updates in chunks

    const approxNodeChunkSize = 20;
    const objChunkSize        = 100;
    const styleChunkSize      = 20;

    
    let n  = 0; // node
    let o  = 0; // object
    let s  = 0; // style

    let nc = 0; // node cunk count
    let oc = 0; // object chunk count
    let sc = 0; // style chunk count


    let nodeValChunk   = [],
        objChunk       = [],
        styleChunk     = [];

    let nodeValChunkId = 0;
        

    while (   n < nodeIds      .length
           || o < updateObjects.length
           || s < updateStyles .length)
    {
        if (n < nodeIds.length)
        {
            nodeValChunk.push(nodeIds[n], counts[n]);

            const values = updateValues.filter(v => v.nodeId == nodeIds[n]);
            values.sort((a, b) => a.paramId - b.paramId);

            for (const v of values)
                nodeValChunk.push(v.paramId, v.type, v.value);

            n++, nc++;
        }


        if (o < updateObjects.length)
        {
            objChunk.push(updateObjects[o]);
            o++, oc++;
        }


        if (s < updateStyles.length)
        {
            styleChunk.push(updateStyles[s]);
            s++, sc++;
        }


        const chunkNotEmpty =
               nc >= approxNodeChunkSize
            || oc == objChunkSize
            || sc == styleChunkSize;


        if (chunkNotEmpty)
        {
            const isLastChunk =    
                   n >= nodeIds      .length
                && o >= updateObjects.length
                && s >= updateStyles .length
                && (   !isEmpty(nodeValChunk)
                    || !isEmpty(objChunk    )
                    || !isEmpty(styleChunk  ));

            genQueueChunk(
                requestId,
                actionId,
                updateNodeId,
                updateParamId,
                nodeValChunkId++,
                nodeValChunk,
                objChunk,
                styleChunk,
                n,
                nodeIds.length,
                isLastChunk);

            nodeValChunk = [];  nc = 0;
            objChunk     = [];  oc = 0;
            styleChunk   = [];  sc = 0;
        }
    }


    const lastChunkNotEmpty =
           !isEmpty(nodeValChunk)
        || !isEmpty(objChunk    )
        || !isEmpty(styleChunk  );


    if (lastChunkNotEmpty)
    {
        genQueueChunk(
            requestId,
            actionId,
            updateNodeId,
            updateParamId,
            nodeValChunkId++,
            nodeValChunk,
            objChunk,
            styleChunk,
            nodeIds.length,
            nodeIds.length,
            true);
    }


    genQueueMessageToUi({
        cmd: 'uiForwardToFigma',
        msg: {cmd: 'figCommitUndo'}
    })
}



function genQueueChunk(requestId, actionId, updateNodeId, updateParamId, nodeValChunkId, nodeValChunk, objChunk, styleChunk, updatedNodes, totalNodes, isLastChunk)
{
    genQueueMessageToUi({
        cmd:          'uiUpdateValuesAndObjects',
        requestId:     requestId,
        actionId:      actionId,
        updateNodeId:  updateNodeId,
        updateParamId: updateParamId,
        chunkId:       nodeValChunkId,
        values:        [...nodeValChunk].map(v => v ? v.toString() : NAN_DISPLAY),
        objects:       [...objChunk],
        styles:        [...styleChunk],
        updatedNodes:  updatedNodes,
        totalNodes:    totalNodes,
        isLastChunk:   isLastChunk
    });


    if (   !isEmpty(objChunk  )
        || !isEmpty(styleChunk))
        genFigMessagePosted = true;
}



function genInitNodeProgress(nodeId)
{
    genQueueMessageToUi(
    {
        cmd:   'uiInitNodeProgress',
        nodeId: nodeId
    });
}



function genUpdateNodeProgress(nodeId, progress)
{
    genQueueMessageToUi(
    {
        cmd:     'uiUpdateNodeProgress',
        nodeId:   nodeId,
        progress: progress
    });
}


function getObjectBounds(objects)
{
    let boundsL = Number.MAX_SAFE_INTEGER;
    let boundsT = Number.MAX_SAFE_INTEGER;
    let boundsR = Number.MIN_SAFE_INTEGER;
    let boundsB = Number.MIN_SAFE_INTEGER;
    
    for (const obj of objects)
    {
        switch (obj[0])
        {
            case RECTANGLE:
                boundsL = Math.min(boundsL, obj[3]);
                boundsT = Math.min(boundsT, obj[4]);
                boundsR = Math.max(boundsR, obj[3] + obj[5]);
                boundsB = Math.max(boundsB, obj[4] + obj[6]);
                break;
        }
    }

    return {
        x: boundsL, 
        y: boundsT,
        w: boundsR - boundsL,
        h: boundsB - boundsT };
}


function genParseColorValue(parse)
{
    parse.pos++; // COLOR_VALUE

    const col = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_VALUE, col, parse);

    return parseColorValue(col)[0];
}



function genParseColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const col = new GColor(nodeId, options);

    col.hasInputs = options.hasInputs;
    
  
    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(col, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, col);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    let paramIds;

    if (nInputs == 1)
    {
        col.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['space', 'convert', 'c1', 'c2', 'c3'];


    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'space':   col.space   = genParse(parse); break;
        case 'convert': col.convert = genParse(parse); break;
        case 'c1':      col.c1      = genParse(parse); break;
        case 'c2':      col.c2      = genParse(parse); break;
        case 'c3':      col.c3      = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, col);
    return col;
}



function genParseValidColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const valid = new GValidColor(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(valid, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, valid);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        valid.input = genParse(parse);


    valid.quality = genParse(parse);
    valid.value   = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, valid);
    return valid;
}



function genParseCorrectColor(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const corr = new GCorrectColor(nodeId, options);

    corr.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(corr, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, corr);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
        corr.input = genParse(parse);


    paramIds = parse.move().split(',');

    parse.inParam = false;
    
    for (const id of paramIds)
    {
        switch (id)
        {
        case 'order':    corr.order   = genParse(parse); break;
        case 'margin1':  corr.margin1 = genParse(parse); break;
        case 'margin2':  corr.margin2 = genParse(parse); break;
        case 'margin3':  corr.margin3 = genParse(parse); break;
        case 'value':    corr.value   = genParse(parse); break;
        }
    }
                

    parse.nTab--;


    genParseNodeEnd(parse, corr);
    return corr;
}



function genParseColorContrast(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cnt = new GColorContrast(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;

    
    if (parse.settings.logRequests) 
        logReqColorContrast(cnt, nInputs, valueIndex, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cnt.input0   = genParse(parse);
        cnt.input1   = genParse(parse);
        cnt.standard = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) cnt.input0 = genParse(parse); 
        else if (valueIndex == 1) cnt.input1 = genParse(parse); 

        cnt.standard = genParse(parse);
    }
    else if (nInputs == 0)
    {
        cnt.standard = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, cnt);
    return cnt;
}



function genParseColorBlind(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cb = new GColorBlind(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cb, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cb);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cb.input = genParse(parse);

    cb.l = genParse(parse);
    cb.m = genParse(parse);
    cb.s = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, cb);
    return cb;
}



function genParseColorInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GColorInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        console.assert(false, 'nInputs must be [0, 2]');


    lerp.space  = genParse(parse);
    lerp.amount = genParse(parse);
    lerp.gamma  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseColorBlend(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const blend = new GColorBlend(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(blend, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, blend);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 2)
    {
        blend.input0 = genParse(parse);
        blend.input1 = genParse(parse);
    }

    else if (nInputs == 1)
        blend.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same

    else if (nInputs != 0)
        console.assert(false, 'nInputs must be [0, 2]');


    blend.mode    = genParse(parse);
    blend.opacity = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, blend);
    return blend;
}


function genParseComment(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cmnt = new GComment(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(cmnt, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, cmnt);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    genParseNodeEnd(parse, cmnt);
    return cmnt;
}



function genParseListValue(parse)
{
    parse.pos++; // LIST_VALUE

    const list = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(LIST_VALUE, list, parse);

    return parseListValue(list)[0];
}



function genParseList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const list = new GList(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(list, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, list);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    
    for (let i = 0; i < nInputs; i++)
        list.inputs.push(genParse(parse));


    parse.nTab--;

        
    genParseNodeEnd(parse, list);
    return list;
}



function genParseExpandList(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const expand = new GExpandList(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(expand, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, expand);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        expand.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, expand);
    return expand;
}



function genParseItems(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const items = new GItems(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(items, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, items);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        items.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, items);
    return items;
}



function genParseSelect(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sel = new GSelect(nodeId, options);
    

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(sel, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sel);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sel.input = genParse(parse);

    sel.index = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sel);
    return sel;
}



function genParseListCount(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const count = new GListCount(nodeId, options);

    
    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(count, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, count);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        count.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, count);
    return count;
}



function genParseIfElse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ifElse = new GIfElse(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }


    const valueIndex = 
        nInputs == 1
        ? parseInt(parse.move())
        : -1;


    if (parse.settings.logRequests) 
        logReq(ifElse, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, ifElse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        ifElse.input0    = genParse(parse);
        ifElse.input1    = genParse(parse);
        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 1)
    {
             if (valueIndex == 0) ifElse.input0 = genParse(parse); 
        else if (valueIndex == 1) ifElse.input1 = genParse(parse); 

        ifElse.condition = genParse(parse);
    }
    else if (nInputs == 0)
    {
        ifElse.condition = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, ifElse);
    return ifElse;
}



function genParseStart(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const start = new GStart(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(start, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, start);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        start.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, start);
    return start;
}



function genParseRepeat(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rep = new GRepeat(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rep, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, rep);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rep.input = genParse(parse);

    rep.count = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, rep);
    return rep;
}



function genParseCache(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cache = new GCache(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(cache, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cache);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        cache.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, cache);
    return cache;
}



function genParseCopy(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const copy = new GCopy(nodeId, options);


    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(copy, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, copy);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        copy.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, copy);
    return copy;
}


function genParseGroupNode(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const group = new GGroupNode(nodeId, options);


    let nParams = -1;
    
    if (!ignore)
    {
        nParams = parseInt(parse.move());
        //console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(group, parse, ignore);//, nParams);


    if (ignore)
    {
        genParseNodeEnd(parse, group);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    //const nParams = parseInt(parse.move());

    for (let i = 0; i < nParams; i++)
    {
        group.paramIds.push(parse.move());
        group.params  .push(genParse(parse));
    }


    parse.nTab--;


    genParseNodeEnd(parse, group);
    return group;
}



function genParseGroupParam(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const param = new GGroupParam(nodeId, options);


    let nInputs  = -1;
    let nOutputs = -1;
    
    if (!ignore)
    {
        nInputs  = parseInt(parse.move());
        nOutputs = parseInt(parse.move());

        console.assert(nInputs  == 0 || nInputs  == 1,  'nInputs must be [0, 1]');
        console.assert(nOutputs == 0 || nOutputs == 1, 'nOutputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(param, parse, ignore);//, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, param);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
    {
        param.input    = genParse(parse);
        param.dataType = parse.move();
    }
    else if (nOutputs == 1)
        param.dataType = parse.move();


    parse.nTab--;


    genParseNodeEnd(parse, param);
    return param;
}



function genParseNumValue(parse)
{
    parse.pos++; // N

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(NUMBER_VALUE, val, parse);

    return val.indexOf(',') >= 0
         ? parseNumberValue      (val)[0]
         : parseSimpleNumberValue(val)[0];
}



function genParseNumber(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num = new GNumber(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(num, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, num);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == NUMBER_VALUE) num.value = genParse(parse);
    else                            num.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, num);
    return num;
}



function genParseSign(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sign = new GSign(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sign, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, sign);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sign.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sign);
    return sign;
}



function genParseAbsolute(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const abs = new GAbsolute(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(abs, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, abs);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        abs.input = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, abs);
    return abs;
}



function genParseRound(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const round = new GRound(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(round, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, round);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        round.input = genParse(parse);

    round.type     = genParse(parse);
    round.decimals = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, round);
    return round;
}



function genParseLimits(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const limits = new GLimits(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(limits, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, limits);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        limits.input = genParse(parse);

    limits.min = genParse(parse);
    limits.max = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, limits);
    return limits;
}



function genParseMath(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const math = newNode(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(math, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, math);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        math.inputs.push(genParse(parse));


    math.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, math);
    return math;
}



function genParseArithmetic(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const arith = newNode(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(arith, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, arith);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        arith.inputs.push(genParse(parse));

    parse.nTab--;

        
    genParseNodeEnd(parse, arith);
    return arith;
}



function genParseSeries(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const series = new GSeries(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(series, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, series);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    series.start = genParse(parse);
    series.step  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, series);
    return series;
}



function genParseRandom(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rnd = new GRandom(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(rnd, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, rnd);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    rnd.seed = genParse(parse);
    rnd.min  = genParse(parse);
    rnd.max  = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, rnd);
    return rnd;
}



function genParseInterpolate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const lerp = new GInterpolate(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(lerp, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, lerp);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        lerp.input0 = genParse(parse);
        lerp.input1 = genParse(parse);
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 1)
    {
        lerp.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        lerp.amount = genParse(parse);
    }
    else if (nInputs == 0)
    {
        lerp.amount = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, lerp);
    return lerp;
}



function genParseBoolean(parse)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const bool = new GBoolean(nodeId, options);

    
    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(bool, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, bool);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        bool.inputs.push(genParse(parse));


    bool.operation = genParse(parse);


    parse.nTab--;

        
    genParseNodeEnd(parse, bool);
    return bool;
}



function genParseCondition(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = new GCondition(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests) 
        logReq(cond, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cond.input0    = genParse(parse);
        cond.input1    = genParse(parse);
        cond.operation = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cond.input0    = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
        cond.operation = genParse(parse);
    }
    else if (nInputs == 0)
    {
        cond.operation = genParse(parse);
    }

    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseConditionBase(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const cond = newNode(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 2, 'nInputs must be [0, 2]');
    }

    
    if (parse.settings.logRequests)
        logReq(cond, parse, ignore, nInputs); 


    if (ignore) 
    {
        genParseNodeEnd(parse, cond);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    if (nInputs == 2)
    {
        cond.input0 = genParse(parse);
        cond.input1 = genParse(parse);
    }
    else if (nInputs == 1)
    {
        cond.input0 = genParse(parse); // doesn't matter if it's input0 or input1, the eval() result will be the same
    }

    parse.nTab--;


    genParseNodeEnd(parse, cond);
    return cond;
}



function genParseNumberToText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const num2text = new GNumberToText(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(num2text, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, num2text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        num2text.input = genParse(parse);

    num2text.format = genParse(parse);
    num2text.digits = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, num2text);
    return num2text;
}



function genParseSolve(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const solve = new GSolve(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(solve, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, solve);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        solve.input = genParse(parse);

    solve.current = genParse(parse);
    solve.target  = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, solve);
    return solve;
}



function genParseAnimate(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const anim = new GAnimate(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(anim, parse);


    if (ignore) 
    {
        genParseNodeEnd(parse, anim);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    anim.from     = genParse(parse);
    anim.to       = genParse(parse);
    anim.curve    = genParse(parse);
    anim.type     = genParse(parse);
    anim.length = genParse(parse);
    anim.time     = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, anim);
    return anim;
}



function genParseRectangle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const rect = new GRectangle(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(rect, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        rect.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      rect.x      = genParse(parse); break;
        case 'y':      rect.y      = genParse(parse); break;
        case 'width':  rect.width  = genParse(parse); break;
        case 'height': rect.height = genParse(parse); break;
        case 'angle':  rect.angle  = genParse(parse); break;
        case 'round':  rect.round  = genParse(parse); break;
        case 'props':  rect.props  = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, rect);
    return rect;
}



function genParseLine(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);

  
    const line = new GLine(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(line, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, rect);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        line.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':     line.x     = genParse(parse); break;
        case 'y':     line.y     = genParse(parse); break;
        case 'width': line.width = genParse(parse); break;
        case 'angle': line.angle = genParse(parse); break;
        case 'props': line.props = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, line);
    return line;
}



function genParseEllipse(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const ellipse = new GEllipse(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(ellipse, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, ellipse);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        ellipse.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      ellipse.x      = genParse(parse); break;
        case 'y':      ellipse.y      = genParse(parse); break;
        case 'width':  ellipse.width  = genParse(parse); break;
        case 'height': ellipse.height = genParse(parse); break;
        case 'angle':  ellipse.angle  = genParse(parse); break;
        case 'props':  ellipse.props  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, ellipse);
    return ellipse;
}



function genParsePolygon(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const poly = new GPolygon(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(poly, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, poly);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        poly.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':       poly.x       = genParse(parse); break;
        case 'y':       poly.y       = genParse(parse); break;
        case 'width':   poly.width   = genParse(parse); break;
        case 'height':  poly.height  = genParse(parse); break;
        case 'angle':   poly.angle   = genParse(parse); break;
        case 'round':   poly.round   = genParse(parse); break;
        case 'corners': poly.corners = genParse(parse); break;
        case 'props':   poly.props   = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, poly);
    return poly;
}



function genParseStar(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const star = new GStar(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(star, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, star);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        star.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {
        case 'x':      star.x      = genParse(parse); break;
        case 'y':      star.y      = genParse(parse); break;
        case 'width':  star.width  = genParse(parse); break;
        case 'height': star.height = genParse(parse); break;
        case 'angle':  star.angle  = genParse(parse); break;
        case 'round':  star.round  = genParse(parse); break;
        case 'points': star.points = genParse(parse); break;
        case 'convex': star.convex = genParse(parse); break;
        case 'props':  star.props  = genParse(parse); break;
        }
    }
    
    
    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, star);
    return star;
}



function genParseTextShape(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GTextShape(nodeId, options);


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        text.input = genParse(parse);


    const nParamIds = genParseParamCount(parse);

    for (let i = 0; i < nParamIds; i++)
    {
        const paramId = genParseParamId(parse);

        parse.inParam = true;

        switch (paramId)
        {       
        case 'text':          text.text          = genParse(parse); break;
        case 'x':             text.x             = genParse(parse); break;
        case 'y':             text.y             = genParse(parse); break;
        case 'width':         text.width         = genParse(parse); break;
        case 'height':        text.height        = genParse(parse); break;
        case 'angle':         text.angle         = genParse(parse); break;
        case 'font':          text.font          = genParse(parse); break;
        case 'style':         text.style         = genParse(parse); break;
        case 'size':          text.size          = genParse(parse); break;
        case 'props':         text.props         = genParse(parse); break;
        case 'alignH':        text.alignH        = genParse(parse); break;
        case 'alignV':        text.alignV        = genParse(parse); break;
        case 'lineHeight':    text.lineHeight    = genParse(parse); break;
        case 'letterSpacing': text.letterSpacing = genParse(parse); break;
        }
    }


    parse.inParam = false;
    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}


function genParseFillValue(parse)
{
    parse.pos++; // FILL_VALUE

    const fill = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(FILL_VALUE, fill, parse);

    return parseFillValue(fill)[0];
}



function genParseFill(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fill = new GFill(nodeId, options);

    fill.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(fill, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, fill);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        fill.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['color', 'opacity'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'color':   fill.color   = genParse(parse); break;
        case 'opacity': fill.opacity = genParse(parse); break;
        }
    }

    
    parse.nTab--;


    genParseNodeEnd(parse, fill);
    return fill;
}



function genParseFillParam(parse)
{
    const fill = genParse(parse); 

    if (COLOR_TYPES.includes(fill.type))
        fill.options.opacity = genParse(parse);

    return fill;
}



function genParseStrokeValue(parse)
{
    parse.pos++; // STROKE_VALUE

    const stroke = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(STROKE_VALUE, stroke, parse);

    return parseStrokeValue(stroke)[0];
}



function genParseStroke(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stroke = new GStroke(nodeId, options);

    stroke.hasInputs = options.hasInputs;


    let nInputs = -1;

    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs => 0 && nInputs <= 1, 'nInputs must be [0, 1]');
    }


    if (parse.settings.logRequests) 
        logReq(stroke, parse, ignore, nInputs);


    if (ignore)
    {
        genParseNodeEnd(parse, stroke);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    let paramIds;

    if (nInputs == 1)
    {
        stroke.input = genParse(parse);
        paramIds = parse.move().split(',');
    }
    else
        paramIds = ['fill', 'weight', 'fit', 'join', 'miter'];


    parse.inParam = false;

    for (const id of paramIds)
    {
        switch (id)
        {
        case 'fill':   stroke.fill   = genParse(parse); break;
        case 'weight': stroke.weight = genParse(parse); break;
        case 'fit':    stroke.fit    = genParse(parse); break;
        case 'join':   stroke.join   = genParse(parse); break;
        case 'miter':  stroke.miter  = genParse(parse); break;
        }
    }
    
    
    parse.nTab--;


    genParseNodeEnd(parse, stroke);
    return stroke;
}



function genParseStrokeParam(parse)
{
    const stroke = genParse(parse); 

    if (    FILL_TYPES.includes(stroke.type)
        || COLOR_TYPES.includes(stroke.type))
        stroke.data.weight = genParse(parse);

    return stroke;
}



function genParseColorStopValue(parse)
{
    parse.pos++; // COLOR_STOP_VALUE

    const stop = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(COLOR_STOP_VALUE, stop, parse);

    return parseColorStopValue(stop);
}



function genParseColorStop(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const stop = new GColorStop(nodeId, options);


    if (parse.settings.logRequests) 
        logReq(stop, parse, ignore);


    if (ignore)
    {
        genParseNodeEnd(parse, stop);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (   parse.next == COLOR_STOP
        || parse.next == COLOR_STOP_VALUE)
        stop.input = genParse(parse);


    stop.fill     = genParse(parse);
    stop.position = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, stop);
    return stop;
}



// function genParseColorStyleValue(parse)
// {
//     parse.pos++; // COLOR_STYLE_VALUE

//     const style = parse.move();

//     if (parse.settings.logRequests) 
//         logReqStyleValue(style, parse);

//     return parseColorStyleValue(style)[0];
// }



function genParseColorStyle(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const style = new GColorStyle(nodeId, options);

    style.existing = options.existing;


    if (parse.settings.logRequests) 
        logReq(style, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, style);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    style.id    = parse.move();
    style.name  = options.nodeName;
    
    style.value = genParse(parse);

    
    parse.nTab--;

    
    style.linked = style.id != NULL;


    genParseNodeEnd(parse, style);
    return style;
}



//function genParseStyleParam(parse)
//{
    // const style = genParse(parse); 

    // if (STYLE_TYPES.includes(style.type))
    //     style.options.opacity = genParse(parse);

    // return style;
//}



function genParseTextValue(parse)
{
    parse.pos++; // tag

    const val = parse.move();

    if (parse.settings.logRequests) 
        logReqValue(TEXT_VALUE, val, parse);

    return parseTextValue(decodeURIComponent(val))[0];
}



function genParseText(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const text = new GText(nodeId, options);

    
    if (parse.settings.logRequests) 
        logReq(text, parse, ignore);


    if (ignore) 
    {
        genParseNodeEnd(parse, text);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;
    parse.inParam = false;


    if (parse.next == TEXT_VALUE) text.value = genParse(parse);
    else                          text.input = genParse(parse);


    parse.nTab--;


    genParseNodeEnd(parse, text);
    return text;
}



function genParseTextSubstring(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const sub = new GTextSubstring(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(sub, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, sub);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        sub.input = genParse(parse);

    sub.start = genParse(parse);
    sub.end   = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, sub);
    return sub;
}



function genParseTextReplace(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const replace = new GTextReplace(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(replace, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, replace);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        replace.input = genParse(parse);

    replace.what = genParse(parse);
    replace.with = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, replace);
    return replace;
}




function genParseTextJoin(parse, newNode)
{
    const [type, nodeId, options, ignore] = genParseNodeStart(parse);


    const join = new GTextJoin(nodeId, options);


    let nInputs = 0;
    
    if (!ignore)
        nInputs = parseInt(parse.move());


    if (parse.settings.logRequests) 
        logReq(join, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, join);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;

    for (let i = 0; i < nInputs; i++)
        join.inputs.push(genParse(parse));

    parse.nTab--;

        
    genParseNodeEnd(parse, join);
    return join;
}



function genParseTextCharacter(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const char = new GTextCharacter(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(char, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, char);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        char.input = genParse(parse);

    char.code = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, char);
    return char;
}



function genParseTextCSV(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const csv = new GTextCSV(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(csv, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, csv);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        csv.input = genParse(parse);

    csv.separator = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, csv);
    return csv;
}



function genParseTextFetch(parse)
{
    const [, nodeId, options, ignore] = genParseNodeStart(parse);


    const fetch = new GTextFetch(nodeId, options);
   

    let nInputs = -1;
    
    if (!ignore)
    {
        nInputs = parseInt(parse.move());
        console.assert(nInputs == 0 || nInputs == 1, 'nInputs must be [0, 1]');
    }

    
    if (parse.settings.logRequests) 
        logReq(fetch, parse, ignore, nInputs);


    if (ignore) 
    {
        genParseNodeEnd(parse, fetch);
        return parse.parsedNodes.find(n => n.nodeId == nodeId);
    }


    parse.nTab++;


    if (nInputs == 1)
        fetch.input = genParse(parse);

    fetch.request = genParse(parse);

    
    parse.nTab--;


    genParseNodeEnd(parse, fetch);
    return fetch;
}


class Parse
{
    request;
    
    pos; 
    so;

    settings = {};


    log  = '';
    
    nTab = 0;

    get tab() { return this.inParam ? ' ' : (NL + HTAB.repeat(Math.max(0, this.nTab))); }

    
    inParam = false;

    
    updateNodeId;
    updateParamId;

    scope         = []; // current parse stack
    parsedNodes   = []; // must be evaluated to create the value updates

    paramNodeIds  = [];

    updateParams  = [];
    updateValues  = [];
    updateObjects = [];
    updateStyles  = [];

    
    get next() { return this.request[this.pos]; }

    get afterNext() 
    { 
        return this.pos+1 < this.request.length 
             ? this.request[this.pos+1]
             : null;
    }



    constructor(request, firstPos, updateNodeId, updateParamId, showAllColorSpaces, logRequests)
    {
        this.request       = request;
          
        this.pos           = firstPos; 
        this.so            = 0;
        
        this.updateNodeId  = updateNodeId; 
        this.updateParamId = updateParamId;
   
        
        this.settings.showAllColorSpaces = showAllColorSpaces;
        this.settings.logRequests           = logRequests;
    }



    move()
    {
        return this.request[this.pos++];
    }
}



function genParse(parse, inParam = true)
{
    //console.log('parse.next', parse.next);

    if (!inParam)
        parse.inParam = false;


    let result = null;


         if (parse.next == PARAM                  ) result = genParseParam           (parse);
        
    else if (parse.next == LIST_VALUE             ) result = genParseListValue       (parse);
    else if (parse.next == LIST                   ) result = genParseList            (parse);
    else if (parse.next == LIST_EXPAND            ) result = genParseExpandList      (parse);
    else if (parse.next == ITEMS                  ) result = genParseItems           (parse);
    else if (parse.next == SELECT                 ) result = genParseSelect          (parse);
    else if (parse.next == LIST_COUNT             ) result = genParseListCount       (parse);
    else if (parse.next == IF_ELSE                ) result = genParseIfElse          (parse);
    else if (parse.next == START                  ) result = genParseStart           (parse);
    else if (parse.next == REPEAT                 ) result = genParseRepeat          (parse);
    else if (parse.next == CACHE                  ) result = genParseCache           (parse);
    else if (parse.next == COPY                   ) result = genParseCopy            (parse);
    
    else if (parse.next == NUMBER_VALUE           ) result = genParseNumValue        (parse);
    else if (parse.next == NUMBER                 ) result = genParseNumber          (parse);
    
    else if (parse.next == NUMBER_SIGN            ) result = genParseSign            (parse);
    else if (parse.next == NUMBER_ABSOLUTE        ) result = genParseAbsolute        (parse);
    else if (parse.next == NUMBER_ROUND           ) result = genParseRound           (parse);
    else if (parse.next == NUMBER_LIMITS          ) result = genParseLimits          (parse);
    else if (parse.next == NUMBER_RANDOM          ) result = genParseRandom          (parse);
    else if (parse.next == NUMBER_SERIES          ) result = genParseSeries          (parse);
    else if (parse.next == NUMBER_INTERPOLATE     ) result = genParseInterpolate     (parse);
    else if (parse.next == NUMBER_TO_TEXT         ) result = genParseNumberToText    (parse);
    else if (parse.next == NUMBER_SOLVE           ) result = genParseSolve           (parse);
    else if (parse.next == NUMBER_ANIMATE         ) result = genParseAnimate         (parse);
    
    else if (parse.next == NUMBER_MATH            ) result = genParseMath            (parse, (nodeId, options) => new GMath          (nodeId, options));
    else if (parse.next == NUMBER_ADD             ) result = genParseArithmetic      (parse, (nodeId, options) => new GAdd           (nodeId, options));
    else if (parse.next == NUMBER_SUBTRACT        ) result = genParseArithmetic      (parse, (nodeId, options) => new GSubtract      (nodeId, options));
    else if (parse.next == NUMBER_MULTIPLY        ) result = genParseArithmetic      (parse, (nodeId, options) => new GMultiply      (nodeId, options));
    else if (parse.next == NUMBER_DIVIDE          ) result = genParseArithmetic      (parse, (nodeId, options) => new GDivide        (nodeId, options));
    else if (parse.next == NUMBER_MODULO          ) result = genParseArithmetic      (parse, (nodeId, options) => new GModulo        (nodeId, options));
    else if (parse.next == NUMBER_EXPONENT        ) result = genParseArithmetic      (parse, (nodeId, options) => new GExponent      (nodeId, options));
    
    else if (parse.next == NUMBER_BOOLEAN         ) result = genParseBoolean         (parse);
    else if (parse.next == NUMBER_NOT             ) result = genParseArithmetic      (parse, (nodeId, options) => new GNot           (nodeId, options));
    else if (parse.next == NUMBER_AND             ) result = genParseArithmetic      (parse, (nodeId, options) => new GAnd           (nodeId, options));
    else if (parse.next == NUMBER_OR              ) result = genParseArithmetic      (parse, (nodeId, options) => new GOr            (nodeId, options));
    else if (parse.next == NUMBER_XOR             ) result = genParseArithmetic      (parse, (nodeId, options) => new GXor           (nodeId, options));
    
    else if (parse.next == NUMBER_CONDITION       ) result = genParseCondition       (parse);
    else if (parse.next == NUMBER_EQUAL           ) result = genParseConditionBase   (parse, (nodeId, options) => new GEqual         (nodeId, options));
    else if (parse.next == NUMBER_NOT_EQUAL       ) result = genParseConditionBase   (parse, (nodeId, options) => new GNotEqual      (nodeId, options));
    else if (parse.next == NUMBER_LESS            ) result = genParseConditionBase   (parse, (nodeId, options) => new GLess          (nodeId, options));
    else if (parse.next == NUMBER_LESS_OR_EQUAL   ) result = genParseConditionBase   (parse, (nodeId, options) => new GLessOrEqual   (nodeId, options));
    else if (parse.next == NUMBER_GREATER         ) result = genParseConditionBase   (parse, (nodeId, options) => new GGreater       (nodeId, options));
    else if (parse.next == NUMBER_GREATER_OR_EQUAL) result = genParseConditionBase   (parse, (nodeId, options) => new GGreaterOrEqual(nodeId, options));

    else if (parse.next == TEXT_VALUE             ) result = genParseTextValue       (parse);
    else if (parse.next == TEXT                   ) result = genParseText            (parse);
    else if (parse.next == TEXT_SUBSTRING         ) result = genParseTextSubstring   (parse);
    else if (parse.next == TEXT_CHAR              ) result = genParseTextCharacter   (parse);
    else if (parse.next == TEXT_REPLACE           ) result = genParseTextReplace     (parse);
    else if (parse.next == TEXT_JOIN              ) result = genParseTextJoin        (parse);
    else if (parse.next == TEXT_CSV               ) result = genParseTextCSV         (parse);
    else if (parse.next == TEXT_FETCH             ) result = genParseTextFetch       (parse);

    else if (parse.next == COLOR_VALUE            ) result = genParseColorValue      (parse);
    else if (parse.next == COLOR                  ) result = genParseColor           (parse);
    else if (parse.next == VALID_COLOR            ) result = genParseValidColor      (parse);
    else if (parse.next == CORRECT_COLOR          ) result = genParseCorrectColor    (parse);
    else if (parse.next == COLOR_CONTRAST         ) result = genParseColorContrast   (parse);
    else if (parse.next == COLORBLIND             ) result = genParseColorBlind      (parse);
    else if (parse.next == COLOR_INTERPOLATE      ) result = genParseColorInterpolate(parse);
    else if (parse.next == COLOR_BLEND            ) result = genParseColorBlend      (parse);
     
    else if (parse.next == FILL_VALUE             ) result = genParseFillValue       (parse);
    else if (parse.next == FILL                   ) result = genParseFill            (parse);
     
    else if (parse.next == STROKE_VALUE           ) result = genParseStrokeValue     (parse);
    else if (parse.next == STROKE                 ) result = genParseStroke          (parse);
     
    else if (parse.next == COLOR_STOP_VALUE       ) result = genParseColorStopValue  (parse);
    else if (parse.next == COLOR_STOP             ) result = genParseColorStop       (parse);
     
    else if (parse.next == COLOR_STYLE            ) result = genParseColorStyle      (parse);
     
    else if (parse.next == RECTANGLE              ) result = genParseRectangle       (parse);
    else if (parse.next == LINE                   ) result = genParseLine            (parse);
    else if (parse.next == ELLIPSE                ) result = genParseEllipse         (parse);
    else if (parse.next == POLYGON                ) result = genParsePolygon         (parse);
    else if (parse.next == STAR                   ) result = genParseStar            (parse);
    else if (parse.next == TEXTSHAPE              ) result = genParseTextShape       (parse);

    else if (parse.next == GROUP_NODE             ) result = genParseGroupNode       (parse);
    else if (parse.next == GROUP_PARAM            ) result = genParseGroupParam      (parse);

    else if (parse.next == COMMENT                ) result = genParseComment         (parse);

    else console.assert(false, 'unknown parse token \'' + parse.next + '\' @ ' + parse.pos);


    parse.inParam = false;


    if (result)
        return result;
    else
    {
        parse.so++;
        return null;
    }
}



function genParseNodeStart(parse)
{
    const type     = parse.move();
    const nodeId   = parse.move();
    const nodeName = parse.move();

    
    parse.scope.push(nodeId);


    if (parse.parsedNodes.find(n => n.nodeId == nodeId))
        return [type, nodeId, {nodeName: nodeName}, true];


    const options = genParseNodeOptions(parse);

    options.nodeName = nodeName;


    return [type, nodeId, options, false];
}



function genParseNodeEnd(parse, node = null)
{
    parse.scope.pop();

    if (node)
    {
        if (isEmpty(parse.scope))
            node.topLevel = true;

        pushUnique(parse.parsedNodes, node);
    }
}



function genParseNodeOptions(parse)
{
    const opt = parseInt(parse.move());

    const options = 
    {
        active:       ((opt >>  0) & 1) != 0,
        beforeActive: ((opt >>  1) & 1) != 0,
        enabled:      ((opt >>  2) & 1) != 0,
        cached:       ((opt >>  3) & 1) != 0,
        hasInputs:    ((opt >> 20) & 1) != 0,
        existing:     ((opt >> 21) & 1) != 0
    };

    return options;
}



function genParseParamCount(parse)
{
    const nParamIds = parseInt(parse.move());

    if (parse.settings.logRequests) 
        parse.log += parse.tab + nParamIds;

    return nParamIds;
}



function genParseParam(parse)
{
    if (parse.next != PARAM) 
        return null;
        
    parse.move(); // PARAM
    const type = parse.move(); // type

    
    const nodeId  = parse.move();
    const paramId = parse.move();
    
    const param   = new GParam(nodeId, paramId);
 
    
    pushUnique(parse.paramNodeIds, nodeId);


    if (parse.settings.logRequests) 
        logReqParam(param, type, parse);


    return param;
}



function genParseParamId(parse)
{
    const paramId = parse.move();

    if (parse.settings.logRequests)
        parse.log += parse.tab + paramId;

    return paramId;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + HTAB.repeat(Math.max(0, this.nTab)); 
    }
}



function log(str)
{
    debugInfo.innerHTML = str;
}



function logFunction(funcName, obj = null)
{
    let str = funcName;

    if (obj)
        str = obj.id + '.' + str;

    console.log(
        '%c ' + str + ' ', 
        'background: #fc0; color: #632;');
}



function logString(str, color = 'white', background = 'red')
{
    console.log(
        '%c ' + str + ' ', 
        'background: ' + background + '; color: ' + color + ';');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = ' ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nInputs = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + HTAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nInputs;

        newLine = true;

        nTab++;

        for (let j = 0; j < nInputs; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + HTAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logStyleUpdates(styles)
{
    console.log(
        '%cstyles', 
        'background: #b4d; color: white;', 
        styles);
}



function logSavePages(pageJson)
{
    console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;');
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;');
}



function logSaveConnections(conns)
{
    let log = 'SAVING ' + conns.length + ' ' + countString('CONNECTION', conns.length);

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUpdateSavedConnections(conns)
{
    let log = 'UPDATING ' + conns.length + ' ' + countString('SAVED CONNECTION', conns.length);

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUndoStack()
{
    let log = 'UNDO STACK:\n';

    for (const act of actionManager.actions)
        log += act.name + '\n';

        console.log('%c%s', 'background: #ffd; color: #b80;', log);
    }



function logRedoStack()
{
    let log = 'REDO STACK:\n';

    for (const act of actionManager.redoActions)
        log += act.name + '\n';

    console.log('%c%s', 'background: #fff4e8; color: #c64;', log);
}


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = ' ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReq(node, parse, ignore, nInputs = -1)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node, ignore);

    if (    nInputs > -1
        && !ignore)
        parse.log += ' ' + nInputs;
}



function logReqNodeId(node, ignore = false)
{
    return ' ' 
         + logReqId(node.nodeId) 
         + ' ' + logReqId(node.nodeName)
         + (!ignore
            ? logReqOptions(node)
            : '');
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if ( node.options.active      ) log += ' ' + ACTIVE;
    if ( node.options.beforeActive) log += ' ' + BEFORE_ACTIVE;
    if (!node.options.enabled     ) log += ' ' + DISABLED;
    if (!node.options.cached      ) log += ' ' + NOCACHE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



function logReqColorContrast(lerp, nInputs, valueIndex, parse, ignore)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp, ignore);

    if (!ignore)
    {
        parse.log += ' ' + nInputs;

        if (nInputs == 1)
            parse.log += ' ' + valueIndex;
    }
}



function logReqValue(type, val, parse)
{
    parse.log += parse.tab + type + ' ' + displayValue(type, val);
}



// function logReqListValue(list, parse, ignore)
// {
//     parse.log += parse.tab + LIST_VALUE + ' ' + displayValue(LIST_VALUE, list);
// }



// function logReqColorValue(val, parse, ignore)
// {
//     parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
// }



// function logReqNumberValue(val, parse, ignore)
// {
//     parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
// }



// function logReqFillValue(fill, parse, ignore)
// {
//     parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
// }



// function logReqStrokeValue(stroke, parse, ignore)
// {
//     // parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
// }



// function logReqColorStopValue(stop, parse, ignore)
// {
//     // parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
// }



function logSavedNode(nodeKey, darkMode)
{
    const log  = formatSavedNodeJson(figGetPageData(nodeKey, false));

    if (darkMode)
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fa24; color: white;', 
            noNodeTag(nodeKey), 
            'background: #fa44; color: #edc;',
            log);
    }
    else
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fdb; color: black;', 
            noNodeTag(nodeKey), 
            'background: #fed; color: black;',
            log);
    }
}



function formatSavedNodeJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')

        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '')

        .split(HTAB + '"params":\n').join('') // have to do .split().join() because there's no .replace() in TS

        .split('": "').join(': ')
        .split('", "').join(': ')

        .split(HTAB + '"').join(HTAB)
        .split(HTAB + HTAB + '["').join(HTAB + HTAB)
        
        .split('",\n').join('\n')
        .split('"\n').join('\n')
        
        .split('"],\n').join('\n');


    if (formJson[formJson.length-1] == '"')
        formJson = formJson.substring(0, formJson.length - 1);

    if (formJson.substring(formJson.length-2) == '"]')    
        formJson = formJson.substring(0, formJson.length - 2);

    return formJson;
}



function formatSavedDataJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')
        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '');

    return formJson;
}



function logSavedConn(conn, darkMode)
{
    const strConn = connToString(conn, true);

    if (darkMode)
    {
        console.log(
            '%c%s', 
            'background: #4f44; color: #ded', 
            strConn); 
    }
    else
    {
        console.log(
            '%c%s', 
            'background: #cfc; color: black;', 
            strConn); 
    }
}


// Observer = 2

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgbSaturateHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[1] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsl(rgb, amount)
{
    const hsl = rgb2hsl(rgb);
    hsl[1] *= amount;
    return hsl2rgb(hsl);
}


function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    // h %= 1;

    // if (h < 0) h += 1;
    //while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = 0.008856; //cube(6/29);
    const k = 903.3;    //cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;
    yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;
    zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;


    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = 0.008856 / 100; //cube(6/29) / 100;
    const k = 903.3    / 100; //cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l, a, b) 
{
    return [
        l + 0.3963377774 * a + 0.2158037573 * b,
        l - 0.1055613458 * a - 0.0638541728 * b,
        l - 0.0894841775 * a - 1.2914855480 * b ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


const hclok_C_scale = 0.89;


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclok2rgb(hcl, cs = sRGB)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 

    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclok2rgb_(h, c, l, cs = sRGB)
{
    return hclok2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclok(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));

    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclok_(r, g, b, cs = sRGB)
{
    return rgb2hclok([r, g, b], cs);
}



function hclab2lab(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hclab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hclab2lab(hcl), cs);
}



function lab2hclab(lab)
{
    let hcl = opp2pol(lab);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclab(rgb, cs = sRGB)
{
    return lab2hclab(rgb2lab(rgb, cs));
}



function hcluv2luv(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hcluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hcluv2luv(hcl), cs);
}



function luv2hcluv(luv)
{
    let hcl = opp2pol(luv);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hcluv(rgb, cs = sRGB)
{
    return luv2hcluv(rgb2luv(rgb, cs));
}


const ColorSpaces = 
[
    ['hex',   'Hex'   ],
    ['rgb',   'RGB'   ], 
    ['hsv',   'HSV'   ], 
    ['hsl',   'HSL'   ], 
    ['hclok', 'HCL/ok'],
    ['hclab', 'HCL/ab'],
    ['hcluv', 'HCL/uv'],
    ['oklab', 'okLab' ],
    ['lab',   'Lab'   ],
    ['luv',   'Luv'   ]
];



class ColorSpace
{
    hex   = Object.freeze(0);
    rgb   = Object.freeze(1);
    hsv   = Object.freeze(2);
    hsl   = Object.freeze(3);
    hclok = Object.freeze(4);
    hclab = Object.freeze(5);
    hcluv = Object.freeze(6);
    oklab = Object.freeze(7);
    lab   = Object.freeze(8);
    luv   = Object.freeze(9);
}



class Color
extends Float32Array
{
    get r() { return this[0]; }
    get g() { return this[1]; }
    get b() { return this[2]; }
    get a() { return this[3]; }
    get s() { return this[4]; }

    set r(r) { this[0] = r; }
    set g(g) { this[1] = g; }
    set b(b) { this[2] = b; }
    set a(a) { this[3] = a; }
    set s(s) { this[4] = s; }



    constructor(c = null)
    {
        super(5); // c1, c2, c3, a, s (space)

        if (c)
        {
            this.r = c.r;
            this.g = c.g;
            this.b = c.b;
            this.a = c.a;
            this.s = c.s;
        }
        else
        {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.s = ColorSpace.rgb;
        }
    }
}


const ColorEpsilon = 0.001;



function rgb2dataColor(rgb)
{
    const _space = 'rgb';

    return [
        _space, 
        getNormalColorValue(rgb[0], _space, 0), 
        getNormalColorValue(rgb[1], _space, 1), 
        getNormalColorValue(rgb[2], _space, 2) ]; 
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = ColorEpsilon)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}



function dataColorIsOk(col, lim = ColorEpsilon)
{
    return rgbIsOk(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const rgba_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN,
    Number.NaN ];


const rgbInvalid  = [0xff, 0, 0xff];
const rgbaInvalid = [0xff, 0, 0xff, 0xff];


const dataColor_NaN = Object.freeze([
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ]);


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);


const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],
            [ 0.0329845436, 0.9293118715,  0.0361456387 ],
            [ 0.0482003018, 0.2643662691,  0.6338517070 ]];

const invM1 = inverse(M1);



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = ColorEpsilon)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbaIsValid(rgba, lim = ColorEpsilon)
{
    return rgba[0] > -lim && rgba[0] < 1 + lim 
        && rgba[1] > -lim && rgba[1] < 1 + lim 
        && rgba[2] > -lim && rgba[2] < 1 + lim
        && rgba[3] > -lim && rgba[3] < 1 + lim;
}



function rgbIsOk(rgb, lim = ColorEpsilon)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function rgbaIsOk(rgba, lim = ColorEpsilon)
{
    return !rgbaIsNaN  (rgba)
        &&  rgbaIsValid(rgba, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbaLerp(rgba1, rgba2, t)
{
    return [ lerp(rgba1[0], rgba2[0], t),
             lerp(rgba1[1], rgba2[1], t),
             lerp(rgba1[2], rgba2[2], t),
             lerp(rgba1[3], rgba2[3], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a = 1)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a = 1)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclok(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < ColorEpsilon
        && Math.abs(rgb1[1] - rgb2[1]) < ColorEpsilon
        && Math.abs(rgb1[2] - rgb2[2]) < ColorEpsilon;        
}



function style2rgba(style) // SLOW
{
    utilContext.fillStyle = style;
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) // SLOW
{
    utilContext.fillStyle = getStyleValue(obj, style);
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])
               : (darkMode ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))
           : (darkMode ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningRgba(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])  
         : (darkMode ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);  
}



function getWarningStyles(colBack)
{
    let warnStyle1, 
        warnStyle2;
    
        
    const colWarning = getDefaultWarningRgba(colBack);

     
    if (!rgbIsNaN(colBack))
    {
        const hclBack = rgb2hclok(colBack);

        const hclBack1 = [...hclBack];
        const hclBack2 = [...hclBack];

        hclBack1[0] += 1/12;  if (hclBack1[0] > 1) hclBack1[0] -= 1;
        hclBack2[0] -= 1/12;  if (hclBack2[0] < 0) hclBack2[0] += 1;


        const altBack1 = rgb_a(clampRgb(hclok2rgb(hclBack1)), 0.35);
        const altBack2 = rgb_a(clampRgb(hclok2rgb(hclBack2)), 0.35);

        const factor   = getWarningFactor(colBack);

        const colWarn1 = rgbaLerp(colWarning, altBack1, factor);
        const colWarn2 = rgbaLerp(colWarning, altBack2, factor);
        
        warnStyle1     = rgba2style(colWarn1);
        warnStyle2     = rgba2style(colWarn2);
    }
    else
    {
        warnStyle1 = rgba2style(colWarning);
        warnStyle2 = rgba2style(colWarning);
    }


    return [warnStyle1, 
            warnStyle2];
}



function getWarningGradient(i, style1, style2)
{
    return 'repeating-linear-gradient('
            + '-45deg, '
            + 'transparent 0 ' + i   + 'px,' 
            +  style1 + ' '    + i   + 'px ' + i*2 +'px,'
            + 'transparent '   + i*2 + 'px ' + i*3 +'px,'
            +  style2 + ' '    + i*3 + 'px ' + i*4 +'px)';
}



function getWarningFactor(colBack)
{
    let dr, dg, db;

    if (colBack[0] < 0) dr = -colBack[0]; else if (colBack[0] > 1) dr = colBack[0] - 1; else dr = 0;
    if (colBack[1] < 0) dg = -colBack[1]; else if (colBack[1] > 1) dg = colBack[1] - 1; else dg = 0;
    if (colBack[2] < 0) db = -colBack[2]; else if (colBack[2] > 1) db = colBack[2] - 1; else db = 0;
    
    const d   = [dr, dg, db].sort()[1];
    const avg = (dr + dg + db) / 3;

    const factor = Math.min((d + avg) / 2, 1);

    // if (this.id == 'color')
    // {
    //     console.log('colBack =', colBack);
    //     console.log('dr     =', dr);
    //     console.log('dg     =', dg);
    //     console.log('db     =', db);
    //     console.log('d      =', d);
    //     console.log('avg    =', avg);
    //     console.log('factor =', factor);
    //     console.log('');
    // }

    return factor;
}



function getStripeBackColor(rgbBack)
{
    let rgbStripeBack = [...rgbBack];
        
    const factor = getWarningFactor(rgbBack);

    if (factor > 0)
    {
        const hcl = rgb2hclok(clampRgb(rgbBack));
        hcl[1] /= 2;
        

        rgbStripeBack = rgbLerp(rgbBack, clipChroma(hclok2rgb(hcl)), factor);
    }

    return rgbStripeBack;
}



function getDefaultWarningStyle(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? '#ffffff29' : '#00000022')
         : (darkMode ? '#ffffff08' : '#00000006'); 
}



function clampRgb(_rgb)
{
    const rgb = [..._rgb];

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function clampChan(val)
{
    return Math.min(Math.max(0, val), 1);
}



function setChan(_col, chan, val)
{
    const col = [..._col];
    col[chan] = val;
    return col;
}



function clipChroma(rgb)
{
    let hcl = rgb2hclok(rgb);

    let loopProtect = 10000;

    while (!rgbIsValid(hclok2rgb(hcl))
         && hcl[1] > 0.001
         && loopProtect-- > 0)
        hcl[1] -= 0.001;

    rgb = hclok2rgb(hcl);

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function noColorStyle(rgba)
{
    if (!rgbaIsNaN(rgba))
        return 'transparent';
    else
    {
        return darkMode
            ? 'rgba(56, 56, 56, 0.95)'
            : 'rgba(255, 255, 255, 0.95)';
    }
}


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function rgba2hex(rgba)
{
    let hex =
          Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function validHex2rgba(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgba_NaN 
           : hex2rgba(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }


    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    
    return rgb;
}



function hex2rgba(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgba = [];

    if (hex.length >= 8)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = parseInt(hex.slice(6, 8), 16); 
    }
    else if (hex.length >= 6)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = 0xff; 
    }
    else if (hex.length >= 4)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = parseInt(hex[3], 16) * 0x11; 
    }
    else if (hex.length == 3)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v; 
        rgba[1] = v; 
        rgba[2] = v; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v * 0x11; 
        rgba[1] = v * 0x11; 
        rgba[2] = v * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 0)
    {
        rgba[0] = 0; 
        rgba[1] = 0; 
        rgba[2] = 0;         
        rgba[3] = 0; 
    }


    rgba[0] /= 0xff;
    rgba[1] /= 0xff;
    rgba[2] /= 0xff;
    rgba[3] /= 0xff;


    return rgba;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


function colorSpace     (index) { return ColorSpaces[index][0]; }
function colorSpaceIndex(space) { return ColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.showAllColorSpaces 
           ? ColorSpaces.length
        : ColorSpaces.length - 5; 
}



const rgbFactor  = [255, 255, 255];
const hs_Factor  = [360, 100, 100];
const hclFactor  = [360, 100, 100];
const oppFactor  = [100, 100, 100];
  
 
const rgbScale   = [255, 255, 255];
  
const hs_Scale   = [360, 100, 100];
 
const hclokScale = [360, 50,  100];
const hclabScale = [360, 400, 100];
const hcluvScale = [360, 330, 100];
 
 
const oklabScale = [100,  30,  30];
const labScale   = [100, 100, 100];
const luvScale   = [100, 150, 150];
 


function colorFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':
        case 'hsl':   return hs_Factor;

        case 'hclok':
        case 'hclab':
        case 'hcluv': return hclFactor;

        case 'oklab':  
        case 'lab':      
        case 'luv':   return oppFactor;   
        
        default:      console.assert(false, 'invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    
        case 'rgb':   scale = rgbScale;   break;

        case 'hsv':    
        case 'hsl':   scale = hs_Scale;   break;

        case 'hclok': scale = hclokScale; break;
        case 'hclab': scale = hclabScale; break;
        case 'hcluv': scale = hcluvScale; break;

        case 'oklab': scale = oklabScale; break;
        case 'lab':   scale = labScale;   break;
        case 'luv':   scale = luvScale;   break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function scaleRgb(rgb)
{
    return scaleColor(rgb, 'rgb');
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':   switchToHex   (node); break;
        case 'rgb':   switchToRgb   (node); break;

        case 'hsv':   switchToHsv   (node); break;
        case 'hsl':   switchToHsl   (node); break;

        case 'hclok': switchToHclok (node); break;
        case 'hclab': switchToHclab (node); break;
        case 'hcluv': switchToHcluv (node); break;

        case 'oklab': switchToOklab (node); break;
        case 'lab':   switchToLab   (node); break;
        case 'luv':   switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex  (node) { switchToRgbControls   (node); switchToTextbox(node); }
function switchToRgb  (node) { switchToRgbControls   (node);                        }

function switchToHsv  (node) { switchToHs_Controls   (node, 'V');                   }
function switchToHsl  (node) { switchToHs_Controls   (node, 'L');                   }
             
function switchToHclok(node) { switchToHclOklControls(node);                        }
function switchToHclab(node) { switchToHclLabControls(node);                        }
function switchToHcluv(node) { switchToHclLuvControls(node);                        }
             
function switchToOklab(node) { switchToOklabControls (node, 'a', 'b');              }
function switchToLab  (node) { switchToLabControls   (node, 'a', 'b');              }
function switchToLuv  (node) { switchToLuvControls   (node, 'u', 'v');              }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.controls[0].min = 
    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.controls[0].max = 
    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hclokScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hclabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hcluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.controls[0].showHex = show;
    node.param2.controls[0].showHex = show;
    node.param3.controls[0].showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.controls[0].wrapValue = c1wrap;
    node.param1.controls[0].setSuffix(c1suffix, c1suffix != '');

    node.param1.controls[0].setMin(c1min); 
    node.param2.controls[0].setMin(c2min);
    node.param3.controls[0].setMin(c3min);
    
    node.param1.controls[0].setMax(c1max); 
    node.param2.controls[0].setMax(c2max); 
    node.param3.controls[0].setMax(c3max); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();
}



function switchToTextbox(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div, node.paramHolder);
    removeDivFrom(node.param2.div, node.paramHolder);
    removeDivFrom(node.param3.div, node.paramHolder);
        
    appendDivTo(node.paramColor.div, node.paramHolder);
}



function removeParamDivs(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div,     node.paramHolder);
    removeDivFrom(node.param2.div,     node.paramHolder);
    removeDivFrom(node.param3.div,     node.paramHolder);
    
    removeDivFrom(node.paramColor.div, node.paramHolder);
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    removeDivFrom(node.paramColor.div, node.paramHolder);

    appendDivTo(node.param1.div, node.paramHolder);
    appendDivTo(node.param2.div, node.paramHolder);
    appendDivTo(node.param3.div, node.paramHolder);
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':   return getNormalValueHs_ (value, chan);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':   return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':   return getNormalColorHs_(c1, c2, c3);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':   return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return getScaledDataColorRgb(         color[1], color[2], color[3]);

        case 'hsv':   return getScaledDataColorHs_('hsv',   color[1], color[2], color[3]);
        case 'hsl':   return getScaledDataColorHs_('hsl',   color[1], color[2], color[3]);

        case 'hclok': return getScaledDataColorHcl('hclok', color[1], color[2], color[3]);
        case 'hclab': return getScaledDataColorHcl('hclab', color[1], color[2], color[3]);
        case 'hcluv': return getScaledDataColorHcl('hcluv', color[1], color[2], color[3]);

        case 'oklab': return getScaledDataColorOpp('oklab', color[1], color[2], color[3]);
        case 'lab':   return getScaledDataColorOpp('lab',   color[1], color[2], color[3]);
        case 'luv':   return getScaledDataColorOpp('luv',   color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function colorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':   
        case 'hsl':   return hs_Factor;

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':   return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbScale;

        case 'hsv':   
        case 'hsl':   return hs_Scale;

        case 'hclok': return hclokScale;
        case 'hclab': return hclabScale;
        case 'hcluv': return hcluvScale;

        case 'oklab': return oklabScale;
        case 'lab':   return labScale;
        case 'luv':   return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return           col;

        case 'hsv':   return hsv2rgb  (col);
        case 'hsl':   return hsl2rgb  (col);

        case 'hclok': return hclok2rgb(col);
        case 'hclab': return hclab2rgb(col);
        case 'hcluv': return hcluv2rgb(col);

        case 'oklab': return oklab2rgb(col);
        case 'lab':   return lab2rgb  (col);
        case 'luv':   return luv2rgb  (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':   return convert2rgb    (color);

        case 'hsv':   return convert2hsv    (color);
        case 'hsl':   return convert2hsl    (color);

        case 'hclok': return convert2hclok  (color);
        case 'hclab': return convert2hclab  (color);
        case 'hcluv': return convert2hcluv  (color);

        case 'oklab': return dataColor2oklab(color);
        case 'lab':   return convert2lab    (color);
        case 'luv':   return convert2luv    (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   rgb =           col;  break;

        case 'hsv':   rgb = hsv2rgb  (col); break;
        case 'hsl':   rgb = hsl2rgb  (col); break;

        case 'hclok': rgb = hclok2rgb(col); break;
        case 'hclab': rgb = hclab2rgb(col); break;
        case 'hcluv': rgb = hcluv2rgb(col); break;

        case 'oklab': rgb = oklab2rgb(col); break;
        case 'lab':   rgb = lab2rgb  (col); break;
        case 'luv':   rgb = luv2rgb  (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsv = rgb2hsv(          col ); break;

        case 'hsv':   hsv =                   col;   break;
        case 'hsl':   hsv = rgb2hsv(hsl2rgb  (col)); break;

        case 'hclok': hsv = rgb2hsv(hclok2rgb(col)); break;
        case 'hclab': hsv = rgb2hsv(hclab2rgb(col)); break;
        case 'hcluv': hsv = rgb2hsv(hcluv2rgb(col)); break;

        case 'oklab': hsv = rgb2hsv(oklab2rgb(col)); break;
        case 'lab':   hsv = rgb2hsv(lab2rgb  (col)); break;
        case 'luv':   hsv = rgb2hsv(luv2rgb  (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsl = rgb2hsl(          col ); break;

        case 'hsv':   hsl = rgb2hsl(hsv2rgb  (col)); break;
        case 'hsl':   hsl =                   col;   break;

        case 'hclok': hsl = rgb2hsl(hclok2rgb(col)); break;
        case 'hclab': hsl = rgb2hsl(hclab2rgb(col)); break;
        case 'hcluv': hsl = rgb2hsl(hcluv2rgb(col)); break;

        case 'oklab': hsl = rgb2hsl(oklab2rgb(col)); break;
        case 'lab':   hsl = rgb2hsl(lab2rgb  (col)); break;
        case 'luv':   hsl = rgb2hsl(luv2rgb  (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function dataColor2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2oklab(          col ); break;

        case 'hsv':   lab = rgb2oklab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2oklab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2oklab(hclok2rgb(col)); break;
        case 'hclab': lab = rgb2oklab(hclab2rgb(col)); break;
        case 'hcluv': lab = rgb2oklab(hcluv2rgb(col)); break;

        case 'oklab': lab =                     col;   break;
        case 'lab':   lab = rgb2oklab(lab2rgb  (col)); break;
        case 'luv':   lab = rgb2oklab(luv2rgb  (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2lab(          col ); break;

        case 'hsv':   lab = rgb2lab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2lab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2lab(hclok2rgb(col)); break;
        case 'hclab': lab =         hclab2lab(col);  break;
        case 'hcluv': lab = rgb2lab(hcluv2rgb(col)); break;

        case 'oklab': lab = rgb2lab(oklab2rgb(col)); break;
        case 'lab':   lab =                   col;   break;
        case 'luv':   lab = rgb2lab(luv2rgb  (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   luv = rgb2luv(          col ); break;

        case 'hsv':   luv = rgb2luv(hsv2rgb  (col)); break;
        case 'hsl':   luv = rgb2luv(hsl2rgb  (col)); break;

        case 'hclok': luv = rgb2luv(hclok2rgb(col)); break;
        case 'hclab': luv = rgb2luv(hclab2rgb(col)); break;
        case 'hcluv': luv =         hcluv2luv(col);  break;

        case 'oklab': luv = rgb2luv(oklab2rgb(col)); break;
        case 'lab':   luv = rgb2luv(lab2rgb  (col)); break;
        case 'luv':   luv =                   col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclok(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclok(          col);  break;

        case 'hsv':   hcl = rgb2hclok(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclok(hsl2rgb  (col)); break;

        case 'hclok': hcl =                     col;   break;
        case 'hclab': hcl = rgb2hclok(hclab2rgb(col)); break;
        case 'hcluv': hcl = rgb2hclok(hcluv2rgb(col)); break;

        case 'oklab': hcl = rgb2hclok(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hclok(lab2rgb  (col)); break;
        case 'luv':   hcl = rgb2hclok(luv2rgb  (col)); break;
    }

    return [
       'hclok',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclab(          col) ; break;
        
        case 'hsv':   hcl = rgb2hclab(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclab(hsl2rgb  (col)); break;
        
        case 'hclok': hcl = rgb2hclab(hclok2rgb(col)); break;
        case 'hclab': hcl =                     col;   break;
        case 'hcluv': hcl = rgb2hclab(hcluv2rgb(col)); break;
        
        case 'oklab': hcl = rgb2hclab(oklab2rgb(col)); break;
        case 'lab':   hcl = lab2hclab(          col ); break;
        case 'luv':   hcl = rgb2hclab(luv2rgb  (col)); break;
    }

    return [
       'hclab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hcluv(          col ); break;

        case 'hsv':   hcl = rgb2hcluv(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hcluv(hsl2rgb  (col)); break;

        case 'hclab': hcl = rgb2hcluv(hclab2rgb(col)); break;
        case 'hcluv': hcl =                     col;   break;
        case 'hclok': hcl = rgb2hcluv(hclok2rgb(col)); break;

        case 'oklab': hcl = rgb2hcluv(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hcluv(lab2rgb  (col)); break;
        case 'luv':   hcl = luv2hcluv(          col ); break;
    }

    return [
       'hcluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


</script>


<script>
'use strict';

////////////////////////////////////////////////////



onerror = (event, source, line, pos, error) =>
{
    initCrashDialog(event, error);
    showCrashDialog();
};


const generatorVersion = 132;


const MAX_INT32        = 2147483647;
  
const NULL             = '';
  
const HTAB             = '  '; // half-tab
const TAB              = '    ';
const NL               = '\n';
  
const GENERATOR_LOGO   = 'G';
const OBJECT_PREFIX    = 'G';
  
const nodeTag          = 'G_NODE';
const connTag          = 'G_CONN';
const pageTag          = 'G_PAGE';



function toInt(f) { return Math.floor(f) | 0; }



function nextPow2(x)
{
    x = toInt(x);

    x--;

    x |= x >>  1;
    x |= x >>  2;
    x |= x >>  4;
    x |= x >>  8;
    x |= x >> 16;
    x |= x >> 32;

    return ++x;
}



function gcd(a, b)
{
    let temp;
    while (1)
    {
        temp = a % b;

        if (temp == 0)
          return b;

        a = b;
        b = temp;
    }
}



function toUtf8(str) 
{
    return decodeURI(encodeURIComponent(str));
}



function fromUtf8(str) 
{
    return decodeURIComponent(encodeURI(str));
}



function charCodeArrayToString(bytes) 
{
    let str = '';

    for (let i = 0; i < bytes.length; i++)
        str += String.fromCharCode(bytes[i]);

    return str;
}



function stringToCharCodeArray(str)
{
    return Array.from(fromUtf8(str), c => c.charCodeAt(0));
}



function newSizeArrayFrom(array, size) // resizes an array and returns a new array
{
    const newArray = new Uint8Array(size);
    copyArray(array, newArray);
    return newArray;
}



function copyArray(src, dst)
{
    copyArrayAt(
        src, 0, src.length,
        dst, 0, dst.length);
}



function copyArrayAt(src, srcStart, srcSize, dst, dstStart, dstSize)
{
    const size = Math.min(srcSize, dstSize);

    for (let i = 0; i < size; i++)
        dst[dstStart + i] = src[srcStart + i];
}



function arraysAreEqual(arr1, arr2)
{
    if (arr1.length != arr2.length)
        return false;

    for (let i = 0; i < arr1.length; i++)
    {
        if (arr1[i] != arr2[i])
            return false;
    }

    return true;
}



function arraysIntersect(array1, array2)
{
    return array1.findIndex(i => array2.includes(i)) > -1;
}



function  leftArrowChar(list) { return list ? '' : ''; }
function rightArrowChar(list) { return list ? '' : ''; }

function nodeNameForStorage(nodeId) { return nodeTag + ' ' + nodeId; }
function connNameForStorage(name)   { return connTag + ' ' + name;   }
function pageNameForStorage(name)   { return pageTag + ' ' + name;   }



function parseBool(str) 
{ 
    return str.toLowerCase() == 'true'
        || str == '1';
}



function connToString(_conn, logSpace = false)
{
    return getConnectionString(
        _conn.outputNodeId,
        _conn.outputId,
        _conn.outputOrder,
        _conn.inputNodeId,
        _conn.inputId,
        _conn.list,
        logSpace);
}



function getConnectionKey(outputNodeId, outputId, outputOrder, inputNodeId, inputId)
{
    return connNameForStorage(
          outputNodeId + ' '
        + outputId     + ' '
        + outputOrder  + ' '
        + inputNodeId  + ' '
        + inputId);
}



function getStorageConnKey(conn)
{
    return getConnectionKey(
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId);
}



function getConnKey(conn)
{
    return getConnectionKey(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id);
}



function getConnString(conn, logSpace = false)
{
    return getConnectionString(
        conn.output.node.id,
        conn.output.id,
        conn.outputOrder,
        conn.input.node.id,
        conn.input.id,
        conn.list,
        logSpace);
}



function getConnectionString(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, logSpace = false)
{
    const  sp   = logSpace ? ' ' : ''; 
    const jsp   = logSpace ? ''  : ''; 

    const arrow = 
          sp 
        + subscriptNumber(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder) 
        + rightArrowChar(typeof list == 'string' ? parseBool(list) : list) 
        + sp;

    const join  = jsp + '.' + jsp;

    return '('
         + outputNodeId + join + outputId
         + arrow
         + inputNodeId  + join + inputId
         + ')';
}



function getPageKey(pageId)
{
    return pageNameForStorage(pageId);
}



function superscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += superscriptChar(c);

    return sup;
}



function superscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return '';
    }
}



function subscriptNumber(num)
{
    const str = num.toString();

    let sup = '';

    for (const c of str)
        sup += subscriptChar(c);

    return sup;
}



function subscriptChar(c)
{
    switch (c)
    {
        case '0': return '';
        case '1': return '';
        case '2': return '';
        case '3': return '';
        case '4': return '';
        case '5': return '';
        case '6': return '';
        case '7': return '';
        case '8': return '';
        case '9': return '';
        case '.': return ' ';
    }
}



function boolToString(bool)
{
    return bool ? 'true' : 'false';
}



function isValid(val)
{
    return val != undefined
        && val != null;
}



function isEmpty(array)
{
    return array.length == 0;
}



function removeFrom(array, item)
{
    removeAt(array, array.indexOf(item));
}



function removeAt(array, index)
{
    if (   index > -1 
        && index < array.length)
        array.splice(index, 1)
}



function removeLast(array)
{
    if (isEmpty(array))
        return null;

    let last = array.at(-1);
    array.splice(array.length-1, 1)

    return last;
}



function lastOf(array)
{
    return array[array.length-1];
}



function moveInArray(array, from, to) 
{
    const item = array[from];
    array.splice(from, 1);
    array.splice(to, 0, item);
}



function removeFromArray(array, item)
{
    const index = array.indexOf(item);
    
    if (index > -1)
        array.splice(index, 1);
}



function removeArrayFromArray(fromArray, array)
{
    for (const item of array)
    {
        const index = fromArray.indexOf(item);
        
        if (index > -1)
            fromArray.splice(index, 1);
    }
}



function removeFromArrayWhere(array, where)
{
    const index = array.findIndex(where);
    
    if (index > -1)
        array.splice(index, 1);
}



function cleanStyleId(styleId)
{
    return styleId.split(',')[0] + ',';
}



function rgbFromType(type, active)
{
    return rgbFromTypeMode(type, active, darkMode);
}



function rgbFromTypeMode(type, active, mode)
{
    if (FLOW_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
        : (mode ? rgbFlowDark         : rgbFlowLight      );

    if (NUMBER_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveNumberDark : rgbActiveNumberLight)
        : (mode ? rgbNumberDark       : rgbNumberLight      );

    if (TEXT_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveTextDark   : rgbActiveTextLight)
        : (mode ? rgbTextDark         : rgbTextLight      );

    if (type == COLOR_STYLE)
        return active 
        ? (mode ? rgbActiveFlowDark   : rgbActiveFlowLight)
        : (mode ? rgbFlowDark         : rgbFlowLight      );

    if (SHAPE_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveShapeDark  : rgbActiveShapeLight)
        : (mode ? rgbShapeDark        : rgbShapeLight      );

    if (GROUP_TYPES.includes(type))
        return active 
        ? (mode ? rgbActiveGroupDark  : rgbActiveGroupLight)
        : (mode ? rgbGroupDark        : rgbGroupLight      );

        
    switch (type)
    {
        case COLOR_VALUE:           

        case COLOR:           
        case COLOR_INTERPOLATE:
        case CORRECT_COLOR:
        case COLOR_CONTRAST:
        case COLORBLIND:
        case COLOR_BLEND:
            return active 
                 ? rgbActiveColor  
                 : rgbColor;
    }

    return 'magenta';
}



function isDataColorNaN(color)
{
    return isNaN(color[1])
        || isNaN(color[2])
        || isNaN(color[3]);
}


const Epsilon = 0.0000001;



function nozero(x)
{
    return x != 0 ? x : Epsilon;
}



function noNaN(x, replace)
{
    return !isNaN(x) ? x : replace;
}



function isSimpleLatinLetter(c)
{
    return c >= 'a' && c <= 'z'
        || c >= 'A' && c <= 'Z';
}


function getDigitCount(i)
{
    let l = Math.floor(Math.log10(Math.abs(i))); // the minus sign doesn't count as a digit;
    return l + 1;
}



function isDigit(c)
{
    return c >= '0' 
        && c <= '9';
}



function isHexDigit(c)
{
    return c.length == 1
        && (   c >= 'A' && c <= 'F'
            || c >= 'a' && c <= 'f');
}



function isArrowKey(code)
{
    return code == 'ArrowLeft'
        || code == 'ArrowRight'
        || code == 'ArrowUp'
        || code == 'ArrowDown';
}



function numToString(num, dec, showHex = false)
{
    if (showHex)
    {
        const _num = Number(num);
        let str = Math.round(Math.abs(_num)).toString(16);

        if (str.length % 2 > 0) str = '0' + str;
        if (_num < 0)           str = '-' + str;

        return str;
    }

    
    const _dec = Math.abs(dec);
    let    str = Number(num).toFixed(_dec).toString(showHex ? 16 : 10);
    

    let i = 0;

    // find decimal place

    while (i < str.length 
        && str[i] !== '.' 
        && str[i] !== ',')
        i++;

    if (i >= str.length) // if no decimal place
        return str;

        
    i = str.length-1;

    if (dec < 0)
    {
        while (i >= 0 && str[i] === '0')
            str = str.substring(0, i--);
        
         if (   str[i] === '.' 
             || str[i] === ',') // hack because JavaScript has shit support for locales
            str = str.substring(0, i--);
    }    

    return str;
}



// function numToString(num, dec)
// {
//     lst str = Number(num).toFixed(dec).toString();

//     let i = 0;

//     // find decimal place

//     while (   i < str.length 
//            && str[i] !== '.' 
//            && str[i] !== ',')
//         i++;

//     if (i >= str.length) // if no decimal place
//         return str;

//     i = str.length-1;

//     while (i >= 0 && str[i] === '0')
//         str = str.substring(0, i--);

//     if (str[i] === '.' || str[i] === ',') // hack because JavaScript has shit support for locales
//         str = str.substring(0, i--);

//     return str;
// }



function capitalize(str)
{
    let cap = "";

    if (str.length > 0)
        cap += str[0].toUpperCase();

    if (str.length > 1)
        cap += str.substring(1).toLowerCase();

    return cap;
}



function getQueryVariable(strVar)
{
    const query = window.location.search.substring(1);
    const vars  = query.split('&');

    for (let i = 0; i < vars.length; i++) 
    {
        let pair = vars[i].split('=');

        if (pair[0] == strVar)
            return pair[1];
    }

    return false;
}


const Tau = Math.PI * 2;
const phi = (Math.sqrt(5) - 1) / 2; // 0.618
const Phi = (Math.sqrt(5) + 1) / 2; // 1.618



function equal(a, b, eps = Epsilon)
{
    return Math.abs(b - a) < eps;
}



function floorTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.floor((x + Number.EPSILON) * div) / div;    
}



function roundTo(x, dec)
{
    const div = Math.round(Math.pow(10, dec));
    return Math.round((x + Number.EPSILON) * div) / div;    
}



function ceilTo(x, dec)
{
    const div = Math.ceil(Math.pow(10, dec));
    return Math.ceil((x + Number.EPSILON) * div) / div;    
}



function sqr (x) { return x*x;   };
function cube(x) { return x*x*x; };



function distance(p1, p2)
{
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;

    return Math.sqrt(dx*dx + dy*dy);
}



function distance_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    return Math.sqrt(dx*dx + dy*dy);
}



function vector(angle, dist)
{
    return point( 
        dist * Math.cos(angle), 
        dist * Math.sin(angle));
}



function equalv(v1, v2)
{
    return v1.x == v2.x
        && v1.y == v2.y;
}



function lengthv(v)
{
    return Math.sqrt(v.x*v.x + v.y*v.y);
}



function unitv(v)
{
    return point(
        v.x == 0 ? 0 : v.x / lengthv(v),
        v.y == 0 ? 0 : v.y / lengthv(v));
}



function addv(v1, v2)
{
    return point(
        v1.x + v2.x,
        v1.y + v2.y);
}	



function subv(v1, v2)
{
    return point(
        v1.x - v2.x,
        v1.y - v2.y);
}	



function mulv(v1, v2)
{
    return point(
        v1.x * v2.x,
        v1.y * v2.y);
}	



function mulvs(v, s)
{
    return point(
        v.x * s,
        v.y * s);
}	



function divvs(v, s)
{
    return point(
        v.x / s,
        v.y / s);
}	



function crossv(v)
{
    // returns a cross product of v and the unit vector pointing up the Z axis

    return point(v.y, -v.x);
}



function crossv2(v1, v2)
{
    // returns the magnitude of v1v2 = v1v2sin "perpendicular dot product",
    // equivalent to dot(v1, cross(v2)) (same as in 3D with a Z component of 0)
    // also the area of the parallelogram between the two vectors
    // also determinant of 22 matrix built from the two vectors
    // positive if turn from v1 to v2 is clockwise

    return (v1.x * v2.y 
          - v1.y * v2.x);
}	



function angle(v)
{
    let angle = Math.atan2(v.y, v.x);
    if (angle < 0) angle += Tau;

    return angle;
}



function anglev(v1, v2)
{
    return anglev_(v1.x, v1.y, v2.x, v2.y);
}



function anglev_(x1, y1, x2, y2)
{
    const dx = x2 - x1;
    const dy = y2 - y1;

    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += Tau;

    return angle;
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        let r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        let r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    let t0 = 0;
    let t1 = 1;

    let dx = x2 - x1;
    let dy = y2 - y1;

    let cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    let cr = clipEdge( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    let ct = clipEdge(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    let cb = clipEdge( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersect(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    let v1 = subv(p2, p1);
    let v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    let t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    let t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    let d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersect(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    let xform = mulm3m3(
        xmove(negv(p0)),
        xrotate(-anglev(p0, p1)));
        
    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.x - p0.x) / nozero(p1.x - p0.x);
}



function mulv3m3(v, m)
{
    let r = [0, 0, 0];

    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            r[i] += v[j] * m[i][j];

    return r;
}



function mulv2m3(v, m)
{
    let v3 = [v.x, v.y, 1];
    let r  = mulv3m3(v3, m);

    return point(r[0], r[1]);
}



function mulm3m3(m1, m2)
{
    const m = [[0, 0, 0],
               [0, 0, 0],
               [0, 0, 0]];

    for (let i = 0; i < 3; i++)
    {
        for (let j = 0; j < 3; j++)
        {
            /*	calculate the dot product of ith row 
                of this and jth column of m  */
            for (let k = 0; k < 3; k++)
                m[i][j] += m1[i][k] * m2[k][j];
        }
    }

    return m;
}



function divm3s(m, s)
{
    for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
            m[i][j] /= s;

    return m;
}



function cofactor(m)
{
    return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],
            [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],
            [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]]; 
}



function adjugate(m)
{
    return cofactor(transpose(m));
}



function determinant(m)
{
    return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
           - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])
           + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
}



function inverse(m)
{
    return divm3s(adjugate(m), determinant(m));
}



function transpose(m)
{
    return [[m[0][0], m[1][0], m[2][0]],
            [m[0][1], m[1][1], m[2][1]],
            [m[0][2], m[1][2], m[2][2]]];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



// function ipow(n, e)
// {
//     let res = 1;

//     for (;;)
//     {
//         if (e & 1 != 0)
//             res *= n;

//         e >>= 1;

//         if (e == 0)
//             break;

//         n *= n;
//     }

//     return res;
// }



const MaxDigits = 100000;
 
function multRes(x, res, resSize)
{
    let carry = 0n;
    
    // multiply individual digits of res[] by n
    for (let i = 0; i < resSize; i++) 
    {
        const prod = res[i] * x + carry;
    
        res[i] = prod % 10n; // store last digit of prod in res[]
        carry  = prod / 10n; // put rest in carry
    }
    
    // put carry in res and
    // increase result size
    while (carry)
    {
        res[resSize] = carry % 10n;
        carry        = carry / 10n;
        resSize++;
    }

    return resSize;
}



function randomPrime(max = Number.MAX_SAFE_INTEGER/2)
{
    const num = Math.floor(Math.random() * max);
    return nextPrime(num);
}



function nextPrime(x) 
{
    while (!isPrime(++x));
    return x;
}



function isPrime(n, k = millerRabinIterations) // Miller-Rabin
{
    if (n <= 1) return false; 
    if (n <= 3) return true; // prime
    
    if (n % 2 == 0) 
        return false; // composite
    
    
    let d = n - 1;     // find d      
    while (d % 2 == 0) // so that x = 2^d * r + 1 
        d /= 2;        // for r >= 1
    
    
    for (let i = 0; i < k; i++)    
        if (!millerTest(d, n))
            return false; // composite
    
    
    return true; // maybe prime        
}    



function millerTest(d, n)
{
    return bigMillerTest(
        BigInt(d),
        BigInt(n));
}        



function uintFromBuffer(buffer, size)
{
    return uintFromBufferAt(buffer, 0, size);
}



function uintFromBufferAt(buffer, start, size)
{
    let val = 0;
    let mul = 1;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * buffer[i];
        mul <<= 8;
    }

    return val;
}



function uintToBuffer(val, buffer, bufferSize)
{
    uintToBufferAt(val, buffer, 0, bufferSize);
}



function uintToBufferAt(val, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(val) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = val & 0xFF; 
        val >>= 8;
    }
}



function lerp(a, b, t)
{
    return a + (b - a) * t;
}



function lerp3(f0, f1, f2, f3, t)
{
    const c0  = lerp(f0, f1, t);
    const c1  = lerp(f1, f2, t);
    const c2  = lerp(f2, f3, t);

    const c01 = lerp(c0, c1, t);
    const c12 = lerp(c1, c2, t);

    return lerp(c01, c12, t);
}



function normalAngle(angle)
{
    while (angle <  0  ) angle += Tau;
    while (angle >= Tau) angle -= Tau;

    return angle; // [0, Tau|
}



function angleDiff(a1, a2)
{
    let diff = a2 - a1;

    while (diff <= -Tau/2) diff += Tau;
    while (diff >   Tau/2) diff -= Tau;

    return diff; // |-Tau/2, Tau/2]
}


const point_NaN = point(Number.NaN, Number.NaN);



function point(x, y) { return {x: x, y: y}; }

function pointIsNaN(p) { return isNaN(p.x) || isNaN(p.y); }



function unit(v)
{
    return v.X != 0 
        || v.Y != 0
        ? mulvs(v, 1 / lengthv(v))
        : point(0, 0);
}



function lerpv(p0, p1, t)
{
    return point(
        lerp(p0.x, p1.x, t),
        lerp(p0.y, p1.y, t));
}



function lerpv3(p0, p1, p2, p3, t)
{
    return point(
        lerp3(p0.x, p1.x, p2.x, p3.x, t),
        lerp3(p0.y, p1.y, p2.y, p3.y, t));
}



function clipEdge(p, q, t0, t1)
{
    if (p == 0 && q < 0)
    {
        return null;
    }
    else if (p < 0)
    {
        const r = q/p;

             if (r > t1) return null;
        else if (r > t0) t0 = r;
    }
    else if (p > 0)
    {
        const r = q/p;

             if (r < t0) return null;
        else if (r < t1) t1 = r;
    }

    return [t0, t1];
}



function clipLine(x1, y1, x2, y2, left, top, right, bottom)
{
    const t0 = 0;
    const t1 = 1;

    const dx = x2 - x1;
    const dy = y2 - y1;

    const cl = clipEdge(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;
    const cr = clipEdge( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;
    const ct = clipEdge(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;
    const cb = clipEdge( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;

    if (t1 < 1)
    {
        x2 = x1 + t1*dx;
        y2 = y1 + t1*dy;
    }

    if (t0 > 0)
    {
        x1 = x1 + t0*dx;
        y1 = y1 + t0*dy;
    }

    return [
        point(x1, y1), 
        point(x2, y2) ];
}



function intersectLines(p1, p2, q1, q2, segment)
{
    if (   equalv(p1, p2) 
        || equalv(q1, q2)) 
        return point_NaN; // undefined line

    const v1 = subv(p2, p1);
    const v2 = subv(q2, q1);

    if (crossv2(v1, v2) == 0) 
        return point_NaN; // parallel lines

    const t1 = crossv2(subv(q1, p1), v2) / crossv2(v1, v2);
    const t2 = crossv2(subv(q1, p1), v1) / crossv2(v1, v2);

    if ((  0 <= t1 && t1 <= 1
        && 0 <= t2 && t2 <= 1)
        || !segment)
        return addv(p1, mulvs(v1, t1));
        
    return point_NaN;
}



function closestPointOnLine(l0, l1, p, segment)
{
    if (equalv(p, l0))
        return l0;
        
    const d = mulvs(
        unitv(crossv(subv(l1, l0))), // perpendicular unit vector from p towards the line
        distance(p, l0));            // the distance to any of the two points guarantees intersection with the line

    return intersectLines(l0, l1, p, subv(p, d), segment);
}



function signedPosOnLine(p0, p1, p)
{
    let cp = closestPointOnLine(p0, p1, p, false);

    const xform = mulm3m3(
        xmove(-p0),
        xrotate(-anglev(p0, p1)));

    p0 = transform(p0, xform);
    p1 = transform(p1, xform);
    cp = transform(cp, xform);

    return (cp.X - p0.X) / nozero(p1.X - p0.X);
}



function rectInside(rect1, rect2)
{
    return rect1.l >= rect2.l
        && rect1.r <= rect2.r
        && rect1.t >= rect2.t
        && rect1.b <= rect2.b; 
}



function rectsIntersect(rect1, rect2)
{
    return !(
           rect1.l >= rect2.r
        || rect1.r <= rect2.l
        || rect1.t >= rect2.b
        || rect1.b <= rect2.t); 
}



function clipRect(rect, clip)
{
    if (!rectsIntersect(rect, clip))
        return Rect.NaN;

    return new AbsRect(
        Math.max(rect.l, clip.l),
        Math.max(rect.t, clip.t),
        Math.min(rect.r, clip.r),
        Math.min(rect.b, clip.b));
}



function validateRect(rect)
{
    return new Rect(
        rect.x + Math.min(rect.w, 0),
        rect.y + Math.min(rect.h, 0),
        Math.abs(rect.w),
        Math.abs(rect.h));
}



function validateRect_(x, y, w, h)
{
    return [
        x + Math.min(w, 0),
        y + Math.min(h, 0),
        Math.abs(w),
        Math.abs(h) ];
}



function transform(p, xform)
{
    return mulv2m3(p, xform);
}



function xmove(v)
{
    return [[1, 0, v.x],
            [0, 1, v.y],
            [0, 0, 1  ]];
}



function xrotate(angle)
{
    return [[Math.cos(angle), -Math.sin(angle), 0],
            [Math.sin(angle),  Math.cos(angle), 0],
            [0,                0,               1]];
}



function offsetRect(elem)
{
    return new Rect(
        elem.offsetLeft,
        elem.offsetTop,
        elem.offsetWidth,
        elem.offsetHeight);
}



function boundingRect(elem)
{
    const bounds = elem.getBoundingClientRect();

    return new Rect(
        bounds.x,
        bounds.y,
        bounds.width,
        bounds.height);
}


function bezierTangent(x0, y0, x1, y1, x2, y2, x3, y3, t)
{
    const p0 = point(x0, y0);
    const p1 = point(x1, y1);
    const p2 = point(x2, y2);
    const p3 = point(x3, y3);

    return unit(addv(addv(
        mulvs(subv(p1, p0), 3*sqr(1-t)),
        mulvs(subv(p2, p1), 6*(1-t)*t)),
        mulvs(subv(p3, p2), 3*sqr(t))));
}



function positionOnSegment(p0, p1, p2, p3, arcLen, error = 0.001)
{
    const hullLength = 
          distance(p0, p1) 
        + distance(p1, p2)
        + distance(p2, p3);

    if (hullLength == 0)
        return Number.NAN;


    let t = arcLen / hullLength;

    if (t < 0 || t > 1)
        return Number.NAN;

        
    let halves = splitSeg(p0, p1, p2, p3, t);
    let l      = halves[0];

    let length = arcLength(l[0], l[1], l[2], l[3], error);


    let loopProtect = 1000;

    while (Math.abs(arcLen - length) > error
        && loopProtect-- > 0)
    {
        t += (arcLen - length) / hullLength;

        halves = splitSeg(p0, p1, p2, p3, t);
        l      = halves[0];

        length = arcLength(l[0], l[1], l[2], l[3], error);
    }

    if (loopProtect == 0)
        console.log('endless loop in positionOnSegment()');


    return t;
}



function splitSeg(p0, p1, p2, p3, t)
{
    const c0   = lerpv(p0, p1, t);
    const c1   = lerpv(p1, p2, t);
    const c2   = lerpv(p2, p3, t);
                
    const c01  = lerpv(c0, c1, t);
    const c12  = lerpv(c1, c2, t);

    const c012 = lerpv(c01, c12, t);

    return [
        [p0, c0, c01, c012],
        [c012, c12, c2, p3] ];
}



// function splitSegments(_p0, _p1, _p2, _p3, ts)
// {
//     const segments = [];


//     let p0 = _p0, 
//         p1 = _p1,
//         p2 = _p2,
//         p3 = _p3;

//     for (let i = 0; i < ts.length; i++)
//     {
//         const parts = split(p0, p1, p2, p3, ts[i]);
//         const l     = parts[0];
//         const r     = parts[1];


//         segments.push(l);


//         if (i < ts.length-1)
//         {
//             p0 = r[0];
//             p1 = r[1];
//             p2 = r[2];
//             p3 = r[3];

//             for (let j = i+1; j < ts.length; j++)
//                 ts[j] = 1 - (1 - ts[j]) / (1 - ts[i]);
//         }
//         else segments.push(r);
//     }


//     return segments;
// }



function arcLength(p0, p1, p2, p3, error = 0.0000001)
{
    const arcLen = 
          distance(p0, p1)
        + distance(p1, p2)
        + distance(p2, p3);

    const chord = distance(p0, p3);

    if ((arcLen - chord) > error)
    {
        const halves = splitSeg(p0, p1, p2, p3, 0.5);
        const l      = halves[0];
        const r      = halves[1];
            
        return arcLength(l[0], l[1], l[2], l[3], error)
             + arcLength(r[0], r[1], r[2], r[3], error);
    }

    return arcLen;
}


var bigBuffer = new Uint8Array(2048);



function bigRandom(max = 0)
{
    const size = 
        max > 0
        ? Math.max(1, Math.floor(bigBitCount(max)/8))
        : bigBuffer.length;
    
    if (size > bigBuffer.length)
        bigBuffer = new Uint8Array(nextPow2(size));
        
    for (let i = 0; i < size; i++)
        bigBuffer[i] = toInt(Math.random() * 0x100);

    let rnd = bigFromBufferAt(bigBuffer, 0, size);

    if (max > 0)
        rnd = rnd % max;
        
    return rnd;
}



function bigPowMod(n, e, m) // n^e % mod
{
    let c = 1n;

    while (e > 0n)
    {
        if ((e & 1n) != 0n)
        {
            c *= n;
            c %= m;
        }

        e  >>= 1n;
        
        n *= n;
        n %= m;
    }
    
    return c;
}



function bigNextPrime(n) 
{
    while (!bigIsPrime(++n));
    return n;
}



function bigIsPrime(x, k = millerRabinIterations) // Miller-Rabin
{
    if (x <= 1n) return false; 
    if (x <= 3n) return true;
    
    if (x % 2n == 0n) 
        return false;
        
        
    let d = x - 1n;
    let s = 0n; 
                
    while (d % 2n == 0n) 
    {
        d /= 2n;         
        s++;
    }
        

    for (let i = 0; i < k; i++)    
    {
        const a = 2n + bigRandom(x - 1n);//bigMult(n - 3n, Math.random()); // -3 = -4 + 1 because random() doesn't include 1.0

        if (!bigIsWitness(a, s, d, x))
            return false;        
    }
        

    return true; 
}    

    

function bigIsWitness(a, s, d, n)
{
    let x = bigPowMod(a, d, n);
        
    if (x == 1n)
        return true;

    for (let j = 0n; j < s-1n; j++)
    {
        if (x == n-1n)
            return true;
        
        x = bigPowMod(x, 2n, n);
    }

    return x == n-1n;
}



function bigFromBuffer(buffer)
{
    return bigFromBufferAt(buffer, 0, buffer.length);
}



function bigFromBufferAt(buffer, start, size)
{
    size = Math.min(size, buffer.length - start);
    
    let val = 0n;
    let mul = 1n;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        val += mul * BigInt(buffer[i]);
        mul <<= 8n;
    }

    return val;
}



function bigToBuffer(n, buffer, bufferSize)
{
    bigToBufferAt(n, buffer, 0, bufferSize);
}



function bigToBufferAt(n, buffer, start, bufferSize)
{
    let size = Math.ceil(bigBitCount(n) / 8);
    
    size = Math.min(size, buffer.length - start);

    start += bufferSize - size;

    for (let i = start+size-1; i >= start; i--) // little-endian
    {
        buffer[i] = Number(n & 0xFFn); 
        n >>= 8n;
    }
}



function bigBitCount(n)
{
    return n.toString(2).length;
}



function bigModInvert(n, m)
{
    const gcd = bigGcdExtended(n, m);

    if (gcd[0] != 1n) return undefined; // inverse doesn't exist
    else              return (gcd[1] % m + m) % m;
}



function bigGcdExtended(n, m)
{
    if (n == 0n)
        return [m, 0n, 1n];

    const gcd = bigGcdExtended(m % n, n);

    const x   = gcd[1];
    const y   = gcd[2];

    return [
        gcd[0], 
        y - (m/n)*x,
        x ];
}


class Point
{
    x;
    y;

    constructor(x, y)
    {
        this.x = x;
        this.y = y;
    }
}


class Rect
{
    x;
    y;
    w;
    h;


    get l()            { return this.x;            }
    get c()            { return this.x + this.w/2; }
    get r()            { return this.x + this.w;   }
           
    get t()            { return this.y;            }
    get m()            { return this.y + this.h/2  }
    get b()            { return this.y + this.h;   }
          
    get tl()           { return point(this.l, this.t); }
    get tc()           { return point(this.c, this.t); }
    get tr()           { return point(this.r, this.t); }
    get ml()           { return point(this.l, this.m); }
    get mc()           { return point(this.c, this.m); }
    get cm()           { return point(this.c, this.m); }
    get mr()           { return point(this.r, this.m); }
    get bl()           { return point(this.l, this.b); }
    get bc()           { return point(this.c, this.b); }
    get br()           { return point(this.r, this.b); }
      
      
    get width()        { return this.w; }
    get height()       { return this.h; }
      
    get left()         { return this.l; }
    get center()       { return this.c; }
    get right()        { return this.r; }
          
    get top()          { return this.t; }
    get middle()       { return this.m; }
    get bottom()       { return this.b; }

    get topLeft()      { return this.tl; }
    get topCenter()    { return this.tc; }
    get topRight()     { return this.tr; }
    get middleLeft()   { return this.ml; }
    get middleCenter() { return this.mc; }
    get centerMiddle() { return this.cm; }
    get middleRight()  { return this.mr; }
    get bottomLeft()   { return this.bl; }
    get bottomCenter() { return this.bc; }
    get bottomRight()  { return this.br; }



    constructor(x, y, w, h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }



    static fromTypical(typ)
    {
        return new Rect(typ.x, typ.y, typ.width, typ.height); 
    }



    // w & h are kept 0 so that isEmpty() works logically on NaN rects
    static get NaN() { return new Rect(Number.NaN, Number.NaN, 0, 0) };
    static get Zero() { return new Rect(0, 0, 0, 0); }



    get isNaN()
    {
        return isNaN(this.x)
            || isNaN(this.y)
            || isNaN(this.w)
            || isNaN(this.h);
    }



	get isEmpty()
	{
		return (this.w == 0
			 || this.h == 0);
	}



    assign(rect)
    {
        this.x = rect.x;
        this.y = rect.y;
        this.w = rect.w;
        this.h = rect.h;
    }
}


class   AbsRect
extends Rect
{
    constructor(l, t, r, b)
    {
        super(l, t, r-l, b-t);
    }
}



function expandRect(rect1, rect2)
{
    if (rect1.isNaN  ) return rect2;
    if (rect1.isEmpty) return rect2;

    if (rect2.isNaN  ) return rect1;
    if (rect2.isEmpty) return rect1;
    
    return new AbsRect(
        Math.min(rect2.l, rect1.l),
        Math.min(rect2.t, rect1.t),
        Math.max(rect2.r, rect1.r),
        Math.max(rect2.b, rect1.b));
}



class Random
{
    seed;
    last;



    constructor(seed = 0, last = seed)//(seed = 0xb9ef7ca4, last = seed)
    { 
        this.seed = seed; 
        this.last = last;
    }



    copy()
    {
        return new Random(this.seed, this.last);
    }



    next()
    {
        this.last = this.seed;
        
        this.seed = (this.seed + 0x7ed55d16) + (this.seed << 12);
        this.seed = (this.seed ^ 0xc761c23c) ^ (this.seed >> 19);
        this.seed = (this.seed + 0x165667b1) + (this.seed <<  5);
        this.seed = (this.seed + 0xd3a2646c) ^ (this.seed <<  9);
        this.seed = (this.seed + 0xfd7046c5) + (this.seed <<  3);
        this.seed = (this.seed ^ 0xb55a4f09) ^ (this.seed >> 16);

        return this.seed / -0x7fffffff;
    }

}


const isMac = navigator.platform.toLowerCase().indexOf('mac') >= 0;



var utilCanvas;
var utilContext;
    


function initUtilContext()
{
    utilCanvas  = document.createElement('canvas');
    utilContext = utilCanvas.getContext('2d');

    utilContext.willReadFrequently = true;
}



function indexOfChild(parent, child)
{
    return Array.prototype.indexOf.call(parent.children, child);
}



function pluralString(count, pluralChar = 's')
{
    return count == 1 ? '' : pluralChar;
}



function countString(itemName, count)
{
    const lastChar   = itemName.at(-1);
    const pluralChar = lastChar == lastChar.toUpperCase() ? 'S' : 's';

    return itemName + pluralString(count, pluralChar);
}



function decCount(strValue)
{
    const dotIndex   = strValue.indexOf('.');
    const commaIndex = strValue.indexOf(',');

    return dotIndex >= 0
         ? strValue.length-1 - dotIndex
         : (commaIndex >= 0
            ? strValue.length-1 - commaIndex
            : 0);
}



function getUserDecimalSeparator()
{
    const num = 1.1;

    return num
        .toLocaleString(navigator.language)
        .substring(1, 2);
}



function isEmptyObject(obj)
{
    if (obj == null)
        return false;
        
    return (
           Object.keys(obj).length === 0 
        && obj.constructor === Object);
}



function shallowCopy(obj)
{
    return Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);
}



function deepCopy(obj)
{
    return JSON.parse(JSON.stringify(obj));
}



function clone(val) 
{
    const type = typeof val;
    
    if (val === null) 
      return null;

    else if (type === 'undefined' 
          || type === 'number' 
          || type === 'string' 
          || type === 'boolean') 
        return val;

    else if (type === 'object') 
    {
        if (val instanceof Array) 
            return val.map(x => clone(x));

        else if (val instanceof Uint8Array) 
            return new Uint8Array(val);

        else 
        {
            let obj = {};

            for (const key in val) 
                obj[key] = clone(val[key]);

            return obj;
        }
    }

    throw 'unknown';
}



function filterUnique(array)
{
    return array.filter((value, index) => 
        array.indexOf(value) === index);
}



function createSvg(element)
{
    const svg = document.createElementNS('http://www.w3.org/2000/svg', element);
    svg.style.pointerEvents = 'none';
    return svg;
}



function isVisible(element)
{ 
    return element.style.visibility == 'visible'; 
}



function isLastInArray(array, item)
{
    return array.indexOf(item) == array.length-1;
}



function pushUnique(array, item)
{
    if (Array.isArray(item))
        item.forEach(i => pushUnique(array, i));
    else if (!array.includes(item))
        array.push(item);
}



function pushUniqueExcept(array, item, except)
{
    if (Array.isArray(item))
        item.forEach(i => pushUniqueExcept(array, i, except));
    else if (!array.find(except))
        array.push(item);
}



function clearChildren(parent) 
{
    while (parent.firstChild)
        parent.removeChild(parent.firstChild);
}



function replaceInStringAt(str, index, replace)
{
    return str.substring(0, index) 
         + replace 
         + str.substring(index + replace.length);
}



function strFromData(data)
{
    let str = '';

    for (let i = 0; i < data.length; i++)
        str += String.fromCharCode(data[si]);

    return str;
}



function clearConsole()
{
    setTimeout(console.clear.bind(console));
}



function log(...params)
{
    setTimeout(console.log.bind(console, ...params)); // doesn't show log source, which makes logs cleaner
}



function logTrace()
{
    setTimeout(console.trace.bind(console));
}



function printNum(num)
{
    return !isNaN(num) ? num : NAN_DISPLAY;
}



function parseNum(str)
{
    return str == NAN_DISPLAY
         ? Number.NaN 
         : parseFloat(str);
}



function isTrue(strBool)
{
    return strBool == 'true';
}



function strIsNum(str) 
{
    if (typeof str != 'string') 
        return false; // only process strings

    if (str == 'NaN') // explicitly support NaN
        return true;

    return !isNaN(str) // use type coercion to parse the whole string
        && !isNaN(parseFloat(str)); // ensure strings of whitespace fail
}



function reflow(elem)
{
    void(elem.offsetHeight);
}


function readonly(target, name, descriptor)
{
    descriptor.writable = false;
    return descriptor;
}



function osCtrl     (plus = true) { return isMac ? ('' + (plus ? '' : '')) : ('Ctrl'  + (plus ? '+' : '')); }
function osAlt      (plus = true) { return isMac ? ('' + (plus ? '' : '')) : ('Alt'   + (plus ? '+' : '')); }
function osShift    (plus = true) { return isMac ? ('' + (plus ? '' : '')) : ('Shift' + (plus ? '+' : '')); }
function osCtrlShift(plus = true) { return isMac ? osShift(plus) + osCtrl(plus) : osCtrl(plus) + osShift(plus); }



function getCreateNodeAction(type, creatingButton, options)
{
    let node = createNode(type);

    if (isEmpty(node.headerOutputs))
        options.autoConnect = true;

    node = null;


    return !!options.insert
        &&  !options.autoConnect
           ? new CreateInsertNodeAction(type, creatingButton, options)
           : new CreateNodeAction      (type, creatingButton, options, !!options.autoConnect);
}



function simpleIntHash(x)
{
    return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32);
}



function getNewNumberId(nodes, checkExists, curId, id = curId, join = '')
{
    if (!checkExists(id))//nodes.find(n => n.id == id))
        return id;
    

    let numLength = getNumLength(id);

    if (numLength > 0)
    {
        const len = id.length - numLength;
        let   num = parseInt(id.substring(len));

        let newId = '';
        while (newId == '' || checkExists(newId))//nodes.find(n => n.id == newId))
            newId = id.substring(0, len + join.length) + join + (++num);

        return newId;
    }

    else if (numLength == 0)
    {
        let num   = 2;
        let newId = id + join + num;

        while (checkExists(newId))//nodes.find(n => 
            //    n.id != curId 
            // && n.id == newId))
            newId = id + join + (++num);

        return newId;
    }

    else
        return id;
}



function getNumLength(name)
{
    let numLength = 0;

    for (let i = name.length - 1; i >= 0; i--)
    {
        if (isDigit(name[i])) numLength++;
        else break;
    }

    return numLength;
}



"use strict";

// Base64 / binary data / UTF-8 strings utilities
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding


// byte array to Base64 string decoding

function base64toUint6(c) 
{
    return    c > 64 
           && c < 91 
           ? c - 65 
           :    c > 96 
             && c < 123 
             ? c - 71
             :    c > 47 
               && c < 58 
               ? c + 4
               : c === 43 
                 ? 62
                 : c === 47 ? 63 : 0;
}



function base64toArray(str, blocksSize) 
{
    const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");
    const inLen  = base64.length;

    const outLen = 
        blocksSize 
        ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize 
        : inLen * 3 + 1 >> 2;
        
    const bytes = new Uint8Array(outLen);

    for (let mod3, 
             mod4, 
             uint24 = 0, 
             out    = 0, 
        i = 0; 
        i < inLen; 
        i++) 
    {
        mod4 = i & 3;
        uint24 |= base64toUint6(base64.charCodeAt(i)) << 6 * (3 - mod4);

        if (   mod4 === 3 
            || inLen - i === 1) 
        {
            for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++) 
                bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;

            uint24 = 0;
        }
    }

    return bytes;
}



// Base64 string to array encoding

function uint6toBase64(i) 
{
    return i < 26 
           ? i + 65
           : i < 52 
             ? i + 71
             : i < 62 
               ? i - 4
               : i === 62 
                 ? 43
                 : i === 63 ? 47 : 65;
}



function arrayToBase64(bytes)
{
    let mod3   = 2, 
        base64 = "";

    const length = bytes.length;

    for (let i = 0, uint24 = 0; i < length; i++) 
    {
        mod3 = i % 3;

        if (i > 0 && (i * 4 / 3) % 76 === 0) 
            base64 += "\r\n";

        uint24 |= bytes[i] << (16 >>> mod3 & 24);

        if (   mod3 === 2 
            || bytes.length - i === 1) 
        {
            base64 += String.fromCharCode(
                uint6toBase64(uint24 >>> 18 & 0x3F), 
                uint6toBase64(uint24 >>> 12 & 0x3F), 
                uint6toBase64(uint24 >>>  6 & 0x3F), 
                uint6toBase64(uint24        & 0x3F));
                
            uint24 = 0;
        }
    }

    return base64.substr(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '==');
}



// UTF-8 array to DOMString and vice versa

function UTF8ArrToStr(bytes) 
{
    let   str    = "";

    const length = bytes.length;

    for (let i = 0; i < length; i++) 
    {
        const byte = bytes[i];

        str += String.fromCharCode(
               byte > 251 
            && byte < 254 
            && i + 5 < length // six bytes
            ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
            :    byte > 247 
              && byte < 252 
              && i + 4 < length // five bytes
              ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
              :    byte > 239 
                && byte < 248 
                && i + 3 < length // four bytes
                ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                :    byte > 223 
                  && byte < 240 
                  && i + 2 < length // three bytes
                  ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128
                  :    byte > 191 
                    && byte < 224 
                    && i + 1 < length // two bytes
                    ? (byte - 192 << 6) + bytes[++i] - 128 /* nPart < 127 ? */ // one byte
                    : byte);
    }

    return str;
}



function strToUTF8Arr(str) 
{
    let strLen = str.length, 
        arrLen = 0;


    // mapping

    for (let i = 0; i < strLen; i++) 
    {
        chr = str.charCodeAt(i);
        arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;
    }

    const bytes = new Uint8Array(arrLen);


    // transcription

    for (let i = 0, iChr = 0; i < arrLen; iChr++) 
    {
        const chr = str.charCodeAt(iChr);
     
        if (chr < 0x80) // one byte
        {
            bytes[i++] = chr;
        } 
        else if (chr < 0x800) // two bytes
        {
            bytes[i++] = 192 + (chr >>> 6);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x10000) // three bytes
        {
            bytes[i++] = 224 + (chr >>> 12);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
        else if (chr < 0x200000) // four bytes
        {
            bytes[i++] = 240 + (chr >>> 18);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else if (chr < 0x4000000) // five bytes
        {
            bytes[i++] = 248 + (chr >>> 24);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        } 
        else //if (nChr <= 0x7fffffff) // six bytes
        {
            bytes[i++] = 252 + (chr >>> 30);
            bytes[i++] = 128 + (chr >>> 24 & 0x3F);
            bytes[i++] = 128 + (chr >>> 18 & 0x3F);
            bytes[i++] = 128 + (chr >>> 12 & 0x3F);
            bytes[i++] = 128 + (chr >>>  6 & 0x3F);
            bytes[i++] = 128 + (chr        & 0x3F);
        }
    }


    return bytes;
}


function position(e)
{
    return point(e.clientX, e.clientY);
}



function getStyleValue(obj, style)
{
    return window.getComputedStyle(obj).getPropertyValue(style);
}



function getCtrlKey(e)
{
    return  isMac && e.metaKey
        || !isMac && e.ctrlKey;
}



function dispatchNewEvent(target, proto)
{
    target.dispatchEvent(new proto.constructor(proto.type, proto));
}



function createDiv(className = '', id = '')
{
    const div = document.createElement('div');
    
    if (className != '')
        div.className = className;
    
    if (id != '')
        div.id = id;

    return div;
}



function appendDivTo(div, to)
{
    if (!to.contains(div))
        to.appendChild(div);
}



function removeDivFrom(div, from)
{
    if (from.contains(div))
        from.removeChild(div);
}



function createTextbox(className = '')
{
    const textbox = document.createElement('INPUT');
    textbox.setAttribute('type', 'text'); 

    if (className.trim() != '')
        textbox.className = className;
    
    return textbox;
}



function createTextarea(className = '')
{
    const textarea = document.createElement('textarea');

    if (className.trim() != '')
        textarea.className = className;
    
    textarea.spellcheck = false;
    
    return textarea;
}



function enableElementText(elem, enable)
{
    elem.style.fontStyle  = enable ? 'normal' : 'italic'; 
    elem.style.fontWeight = enable ? 'normal' : 'bold';
}



function hasFocus(elem)
{
    return elem == document.activeElement;
}



function setStyle(id, properties)
{
    const elem = document.getElementById(id);

    for (const property of properties)
        elem.style[property] = properties[property];
}



function containsChild(parent, child)
{
    return child.parentNode == parent;
}



function forwardEvent(event, element)
{
    const e = new event.constructor(event.type, event);
    element.dispatchEvent(e);
}



function offsetRect(element)
{
    return new Rect(
        element.offsetLeft,
        element.offsetTop,
        element.offsetWidth,
        element.offsetHeight);
}



function clientRect(element)
{
    return new Rect(
        element.clientLeft,
        element.clientTop,
        element.clientWidth,
        element.clientHeight);
}



// function triggerMouseEvent(element, event, px, py, button = 0)
// {
//     const e = new MouseEvent(event, 
//     {
//         clientX: px,
//         clientY: py,
//         button:  button
//     });
//
//     element.dispatchEvent(e);
// }



function selectElementText(elementId)
{
    if (document.selection) // IE
    {
        var range = document.body.createTextRange();
        range.moveToElementText(document.getElementById(elementId));
        range.select();
    }
    else if (window.getSelection) 
    {
        var range = document.createRange();
        range.selectNode(document.getElementById(elementId));
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }
}



function isTouchpad(e)
{
    return Math.abs(e.deltaX) < 100
        && Math.abs(e.deltaY) < 100;
}



function showElement(element, show = true) 
{
    const showStyle = 'block';
    const hideStyle = 'none';

    if (  !show
        && element.style.display != hideStyle)
        element.oldDisplay = element.style.display;

    element.style.display = 
        show 
        ? (   element.style.oldDisplay 
           && element.style.oldDisplay != hideStyle
           ? element.style.oldDsplay
           : showStyle)
        : hideStyle; 
}


function hideElement(element)              
{ 
    showElement(element, false); 
}



function isVisible(element)
{
    return element.offsetParent !== null;
}



function getSelectedText(element) // only allow input[type=text] & textarea
{ 
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        return element.value.substring(
            element.selectionStart,
            element.selectionEnd);
    }
}



function clearSelectedText(element)
{
    if (   element.tagName === 'TEXTAREA' 
        || (   element.tagName === 'INPUT' 
            && element.type === 'text')) 
    {
        const str = element.value;

        element.value = 
              str.slice(0, element.selectionStart) 
            + str.slice(element.selectionEnd)
    }
}



function scrollbarVisible(element) 
{
    return element.scrollHeight > element.clientHeight;
}



function clientPos(e)
{
    return point(e.clientX, e.clientY);
}



function elementHasSelectedText(div)
{
    const selection = window.getSelection();

    if (selection.rangeCount > 0) 
    {
        const range = selection.getRangeAt(0);
        
        if (   range.commonAncestorContainer === div
            || div.contains(range.commonAncestorContainer))
        {
            const selectedText = range.toString().trim();

            if (selectedText.length > 0)
                return true;
        }
    }

    return false; 
}



function selectDivText(div)
{
    var range = document.createRange();
    range.selectNode(div);

    window.getSelection().removeAllRanges();
    window.getSelection().addRange(range);    
}


const webColors = [
    {name: 'AliceBlue',            color: 'f0f8ff'},
    {name: 'AntiqueWhite',         color: 'faebd7'},
    {name: 'Aqua',                 color: '00ffff'},
    {name: 'Aquamarine',           color: '7fffd4'},
    {name: 'Azure',                color: 'f0ffff'},
    {name: 'Beige',                color: 'f5f5dc'},
    {name: 'Bisque',               color: 'ffe4c4'},
    {name: 'Black',                color: '000000'},
    {name: 'BlanchedAlmond',       color: 'ffebcd'},
    {name: 'Blue',                 color: '0000ff'},
    {name: 'BlueViolet',           color: '8a2be2'},
    {name: 'Brown',                color: 'a52a2a'},
    {name: 'BurlyWood',            color: 'deb887'},
    {name: 'CadetBlue',            color: '5f9ea0'},
    {name: 'Chartreuse',           color: '7fff00'},
    {name: 'Chocolate',            color: 'd2691e'},
    {name: 'Coral',                color: 'ff7f50'},
    {name: 'CornflowerBlue',       color: '6495ed'},
    {name: 'Cornsilk',             color: 'fff8dc'},
    {name: 'Crimson',              color: 'dc143c'},
    {name: 'Cyan',                 color: '00ffff'},
    {name: 'DarkBlue',             color: '00008b'},
    {name: 'DarkCyan',             color: '008b8b'},
    {name: 'DarkGoldenRod',        color: 'b8860b'},
    {name: 'DarkGray',             color: 'a9a9a9'},
    {name: 'DarkGrey',             color: 'a9a9a9'},
    {name: 'DarkGreen',            color: '006400'},
    {name: 'DarkKhaki',            color: 'bdb76b'},
    {name: 'DarkMagenta',          color: '8b008b'},
    {name: 'DarkOliveGreen',       color: '556b2f'},
    {name: 'DarkOrange',           color: 'ff8c00'},
    {name: 'DarkOrchid',           color: '9932cc'},
    {name: 'DarkRed',              color: '8b0000'},
    {name: 'DarkSalmon',           color: 'e9967a'},
    {name: 'DarkSeaGreen',         color: '8fbc8f'},
    {name: 'DarkSlateBlue',        color: '483d8b'},
    {name: 'DarkSlateGray',        color: '2f4f4f'},
    {name: 'DarkSlateGrey',        color: '2f4f4f'},
    {name: 'DarkTurquoise',        color: '00ced1'},
    {name: 'DarkViolet',           color: '9400d3'},
    {name: 'DeepPink',             color: 'ff1493'},
    {name: 'DeepSkyBlue',          color: '00bfff'},
    {name: 'DimGray',              color: '696969'},
    {name: 'DimGrey',              color: '696969'},
    {name: 'DodgerBlue',           color: '1e90ff'},
    {name: 'FireBrick',            color: 'b22222'},
    {name: 'FloralWhite',          color: 'fffaf0'},
    {name: 'ForestGreen',          color: '228b22'},
    {name: 'Fuchsia',              color: 'ff00ff'},
    {name: 'Gainsboro',            color: 'dcdcdc'},
    {name: 'GhostWhite',           color: 'f8f8ff'},
    {name: 'Gold',                 color: 'ffd700'},
    {name: 'GoldenRod',            color: 'daa520'},
    {name: 'Gray',                 color: '808080'},
    {name: 'Grey',                 color: '808080'},
    {name: 'Green',                color: '008000'},
    {name: 'GreenYellow',          color: 'adff2f'},
    {name: 'HoneyDew',             color: 'f0fff0'},
    {name: 'HotPink',              color: 'ff69b4'},
    {name: 'IndianRed',            color: 'cd5c5c'},
    {name: 'Indigo',               color: '4b0082'},
    {name: 'Ivory',                color: 'fffff0'},
    {name: 'Khaki',                color: 'f0e68c'},
    {name: 'Lavender',             color: 'e6e6fa'},
    {name: 'LavenderBlush',        color: 'fff0f5'},
    {name: 'LawnGreen',            color: '7cfc00'},
    {name: 'LemonChiffon',         color: 'fffacd'},
    {name: 'LightBlue',            color: 'add8e6'},
    {name: 'LightCoral',           color: 'f08080'},
    {name: 'LightCyan',            color: 'e0ffff'},
    {name: 'LightGoldenRodYellow', color: 'fafad2'},
    {name: 'LightGray',            color: 'd3d3d3'},
    {name: 'LightGrey',            color: 'd3d3d3'},
    {name: 'LightGreen',           color: '90ee90'},
    {name: 'LightPink',            color: 'ffb6c1'},
    {name: 'LightSalmon',          color: 'ffa07a'},
    {name: 'LightSeaGreen',        color: '20b2aa'},
    {name: 'LightSkyBlue',         color: '87cefa'},
    {name: 'LightSlateGray',       color: '778899'},
    {name: 'LightSlateGrey',       color: '778899'},
    {name: 'LightSteelBlue',       color: 'b0c4de'},
    {name: 'LightYellow',          color: 'ffffe0'},
    {name: 'Lime',                 color: '00ff00'},
    {name: 'LimeGreen',            color: '32cd32'},
    {name: 'Linen',                color: 'faf0e6'},
    {name: 'Magenta',              color: 'ff00ff'},
    {name: 'Maroon',               color: '800000'},
    {name: 'MediumAquaMarine',     color: '66cdaa'},
    {name: 'MediumBlue',           color: '0000cd'},
    {name: 'MediumOrchid',         color: 'ba55d3'},
    {name: 'MediumPurple',         color: '9370db'},
    {name: 'MediumSeaGreen',       color: '3cb371'},
    {name: 'MediumSlateBlue',      color: '7b68ee'},
    {name: 'MediumSpringGreen',    color: '00fa9a'},
    {name: 'MediumTurquoise',      color: '48d1cc'},
    {name: 'MediumVioletRed',      color: 'c71585'},
    {name: 'MidnightBlue',         color: '191970'},
    {name: 'MintCream',            color: 'f5fffa'},
    {name: 'MistyRose',            color: 'ffe4e1'},
    {name: 'Moccasin',             color: 'ffe4b5'},
    {name: 'NavajoWhite',          color: 'ffdead'},
    {name: 'Navy',                 color: '000080'},
    {name: 'OldLace',              color: 'fdf5e6'},
    {name: 'Olive',                color: '808000'},
    {name: 'OliveDrab',            color: '6b8e23'},
    {name: 'Orange',               color: 'ffa500'},
    {name: 'OrangeRed',            color: 'ff4500'},
    {name: 'Orchid',               color: 'da70d6'},
    {name: 'PaleGoldenRod',        color: 'eee8aa'},
    {name: 'PaleGreen',            color: '98fb98'},
    {name: 'PaleTurquoise',        color: 'afeeee'},
    {name: 'PaleVioletRed',        color: 'db7093'},
    {name: 'PapayaWhip',           color: 'ffefd5'},
    {name: 'PeachPuff',            color: 'ffdab9'},
    {name: 'Peru',                 color: 'cd853f'},
    {name: 'Pink',                 color: 'ffc0cb'},
    {name: 'Plum',                 color: 'dda0dd'},
    {name: 'PowderBlue',           color: 'b0e0e6'},
    {name: 'Purple',               color: '800080'},
    {name: 'RebeccaPurple',        color: '663399'},
    {name: 'Red',                  color: 'ff0000'},
    {name: 'RosyBrown',            color: 'bc8f8f'},
    {name: 'RoyalBlue',            color: '4169e1'},
    {name: 'SaddleBrown',          color: '8b4513'},
    {name: 'Salmon',               color: 'fa8072'},
    {name: 'SandyBrown',           color: 'f4a460'},
    {name: 'SeaGreen',             color: '2e8b57'},
    {name: 'SeaShell',             color: 'fff5ee'},
    {name: 'Sienna',               color: 'a0522d'},
    {name: 'Silver',               color: 'c0c0c0'},
    {name: 'SkyBlue',              color: '87ceeb'},
    {name: 'SlateBlue',            color: '6a5acd'},
    {name: 'SlateGray',            color: '708090'},
    {name: 'SlateGrey',            color: '708090'},
    {name: 'Snow',                 color: 'fffafa'},
    {name: 'SpringGreen',          color: '00ff7f'},
    {name: 'SteelBlue',            color: '4682b4'},
    {name: 'Tan',                  color: 'd2b48c'},
    {name: 'Teal',                 color: '008080'},
    {name: 'Thistle',              color: 'd8bfd8'},
    {name: 'Tomato',               color: 'ff6347'},
    {name: 'Turquoise',            color: '40e0d0'},
    {name: 'Violet',               color: 'ee82ee'},
    {name: 'Wheat',                color: 'f5deb3'},
    {name: 'White',                color: 'ffffff'},
    {name: 'WhiteSmoke',           color: 'f5f5f5'},
    {name: 'Yellow',               color: 'ffff00'},
    {name: 'YellowGreen',          color: '9acd32'}
];


function writeTextToClipboard(str) 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.writeText(str);

    else 
    {
        const prevActive = document.activeElement;
        const textArea   = document.createElement('textarea');

        textArea.value = str;

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('copy') ? res() : rej();
            textArea.remove();
        });
    }
}



function readTextFromClipboard() 
{
    if (   navigator.clipboard 
        && window.isSecureContext) 
        return navigator.clipboard.readText();

    else 
    {
        let textArea = document.createElement('textarea');

        textArea.style.position = 'fixed';
        textArea.style.left     = '-999999px';
        textArea.style.top      = '-999999px';
        
        document.body.appendChild(textArea);
        
        textArea.focus();
        textArea.select();
        
        return new Promise((res, rej) => 
        {
            document.execCommand('paste') ? res(textArea.value) : rej();
            textArea.remove();
        });
    }
}


function isTagKey(key, tag) 
{
    return key.substring(0, tag.length+1) == tag + ' ';
}



function noTag(key, tag)
{
    return key.substring(tag.length+1);
}



function isPageKey(key) { return isTagKey(key, pageTag); }
function isNodeKey(key) { return isTagKey(key, nodeTag); }
function isConnKey(key) { return isTagKey(key, connTag); }



function noPageTag(key) { return noTag(key, pageTag); }
function noNodeTag(key) { return noTag(key, nodeTag); }
function noConnTag(key) { return noTag(key, connTag); }


const NAN_CHAR            = '\uFFFD';
const NAN_DISPLAY         = '?';
    
const UNKNOWN_CHAR        = '?';
const UNKNOWN_DISPLAY     = UNKNOWN_CHAR;//'';
    

const  TRUE_DISPLAY_LIGHT = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const FALSE_DISPLAY_LIGHT = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    

const  TRUE_DISPLAY_DARK  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const FALSE_DISPLAY_DARK  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';

const  TRUE_DISPLAY_MENU  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const FALSE_DISPLAY_MENU  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';



function getTrueDisplay()
{
    return darkMode
         ? TRUE_DISPLAY_DARK
         : TRUE_DISPLAY_LIGHT;
}



function getFalseDisplay()
{
    return darkMode
         ? FALSE_DISPLAY_DARK
         : FALSE_DISPLAY_LIGHT;
}


function nodeIdArrayToString(nodeIds)
{
    let str = '';

    for (let i = 0; i < nodeIds.length; i++)
    {
        if (i > 0) str += ', ';
        str += nodeIds[i];
    }

    return str;
}



function nodeArrayToString(nodes)
{
    let str = '';

    nodes.map(n => n ? n.id : 'undefined').join(', ');

    // for (let i = 0; i < nodes.length; i++)
    // {
    //     if (i > 0) str += ', ';
    //     str += nodes[i] ? nodes[i].id : 'undefined';
    // }

    return str;
}


class RequestSettings
{
    request;
    pos;

    so            = 0;
    nTab          = 0;
  
    skipNewLine   = false;

    loggedNodeIds = [];
    


    constructor(request, pos)
    {
        this.request = request;
        this.pos     = pos;
    }


    get tab() 
    { 
        if (this.skipNewLine)
        {
            this.skipNewLine = false;
            return '';
        }
        else 
            return NL + HTAB.repeat(Math.max(0, this.nTab)); 
    }
}



function log(str)
{
    debugInfo.innerHTML = str;
}



function logFunction(funcName, obj = null)
{
    let str = funcName;

    if (obj)
        str = obj.id + '.' + str;

    console.log(
        '%c ' + str + ' ', 
        'background: #fc0; color: #632;');
}



function logString(str, color = 'white', background = 'red')
{
    console.log(
        '%c ' + str + ' ', 
        'background: ' + background + '; color: ' + color + ';');
}



function logValueUpdates(updateNodeId, updateParamId, values)
{
    //console.log('values = ', values);

    let log     = '';
    let newLine = true;

    if (   updateNodeId  != '' 
        || updateParamId != '')
        log = ' ' + logReqId(updateNodeId) + '.' + logReqId(updateParamId);
    else
        newLine = false;

          
    let i    = 0;
    let nTab = 0;

    while (i < values.length)
    {
        const nodeId  = values[i++];
        const nInputs = parseInt(values[i++]);

        log += 
              (newLine ? NL : '') + HTAB.repeat(Math.max(0, nTab))
            + nodeId;// + ' ' + nInputs;

        newLine = true;

        nTab++;

        for (let j = 0; j < nInputs; j++)
        {
            const index = values[i++];
            const type  = values[i++];
            const value = values[i++];

            log += 
                  NL + HTAB.repeat(Math.max(0, nTab))
                + index + ' ' + displayValue(type, value);
        }

        nTab--;
    }


    console.log(
        '%c%s', 
        'background: #e70; color: white;', 
        log);
}



function logObjectUpdates(objects)
{
    console.log(
        '%cobjects', 
        'background: #07e; color: white;', 
        objects);
}



function logStyleUpdates(styles)
{
    console.log(
        '%cstyles', 
        'background: #b4d; color: white;', 
        styles);
}



function logSavePages(pageJson)
{
    console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;');
}



function logSaveNodes(nodeJson)
{
    console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;');
}



function logSaveConnections(conns)
{
    let log = 'SAVING ' + conns.length + ' ' + countString('CONNECTION', conns.length);

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUpdateSavedConnections(conns)
{
    let log = 'UPDATING ' + conns.length + ' ' + countString('SAVED CONNECTION', conns.length);

    for (const conn of conns)
        log += '\n' + conn.toJson();

    console.log(
        '%c' + log, 
        'color: black; background: #ddeeff;');
}



function logUndoStack()
{
    let log = 'UNDO STACK:\n';

    for (const act of actionManager.actions)
        log += act.name + '\n';

        console.log('%c%s', 'background: #ffd; color: #b80;', log);
    }



function logRedoStack()
{
    let log = 'REDO STACK:\n';

    for (const act of actionManager.redoActions)
        log += act.name + '\n';

    console.log('%c%s', 'background: #fff4e8; color: #c64;', log);
}


function logRequest(parse)
{
    let log = '';

    if (   parse.updateNodeId  != '' 
        || parse.updateParamId != '')
        log = ' ' + logReqId(parse.updateNodeId) + '.' + logReqId(parse.updateParamId);

    log += parse.log;

    console.log(
        '%c%s', 
        'background: #60aa60; color: #fff', 
         log);
}



function logReq(node, parse, ignore, nInputs = -1)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node, ignore);

    if (    nInputs > -1
        && !ignore)
        parse.log += ' ' + nInputs;
}



function logReqNodeId(node, ignore = false)
{
    return ' ' 
         + logReqId(node.nodeId) 
         + ' ' + logReqId(node.nodeName)
         + (!ignore
            ? logReqOptions(node)
            : '');
}



function logReqId(nodeId)
{
    return nodeId == '' ? '\'\'' : nodeId;
}



function logReqOptions(node)
{
    let log = '';

    if ( node.options.active      ) log += ' ' + ACTIVE;
    if ( node.options.beforeActive) log += ' ' + BEFORE_ACTIVE;
    if (!node.options.enabled     ) log += ' ' + DISABLED;
    if (!node.options.cached      ) log += ' ' + NOCACHE;

    return log;
}



function logReqParam(param, type, parse)
{
    parse.log += 
                parse.tab + PARAM
        + ' ' + type 
        + ' ' + logReqId(param.nodeId) 
        + '.' + logReqId(param.paramId);
}



function logReqNode(node, parse)
{
    parse.log += parse.tab + node.type;
    parse.log += logReqNodeId(node);
}



function logReqColorContrast(lerp, nInputs, valueIndex, parse, ignore)
{
    parse.log += parse.tab + COLOR_CONTRAST;
    parse.log += logReqNodeId(lerp, ignore);

    if (!ignore)
    {
        parse.log += ' ' + nInputs;

        if (nInputs == 1)
            parse.log += ' ' + valueIndex;
    }
}



function logReqValue(type, val, parse)
{
    parse.log += parse.tab + type + ' ' + displayValue(type, val);
}



// function logReqListValue(list, parse, ignore)
// {
//     parse.log += parse.tab + LIST_VALUE + ' ' + displayValue(LIST_VALUE, list);
// }



// function logReqColorValue(val, parse, ignore)
// {
//     parse.log += parse.tab + COLOR_VALUE + ' ' + displayValue(COLOR_VALUE, val);
// }



// function logReqNumberValue(val, parse, ignore)
// {
//     parse.log += parse.tab + NUMBER_VALUE + ' ' + displayValue(NUMBER_VALUE, val);
// }



// function logReqFillValue(fill, parse, ignore)
// {
//     parse.log += parse.tab + FILL_VALUE + ' ' + displayValue(FILL_VALUE, fill);
// }



// function logReqStrokeValue(stroke, parse, ignore)
// {
//     // parse.log += parse.tab + STROKE_VALUE + ' ' + displayValue(STROKE_VALUE, stroke);
// }



// function logReqColorStopValue(stop, parse, ignore)
// {
//     // parse.log += parse.tab + COLOR_STOP_VALUE + ' ' + displayValue(COLOR_STOP_VALUE, stop);
// }



function logSavedNode(nodeKey, darkMode)
{
    const log  = formatSavedNodeJson(figGetPageData(nodeKey, false));

    if (darkMode)
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fa24; color: white;', 
            noNodeTag(nodeKey), 
            'background: #fa44; color: #edc;',
            log);
    }
    else
    {
        console.log(
            '%c%s\n%c%s', 
            'background: #fdb; color: black;', 
            noNodeTag(nodeKey), 
            'background: #fed; color: black;',
            log);
    }
}



function formatSavedNodeJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')

        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '')

        .split(HTAB + '"params":\n').join('') // have to do .split().join() because there's no .replace() in TS

        .split('": "').join(': ')
        .split('", "').join(': ')

        .split(HTAB + '"').join(HTAB)
        .split(HTAB + HTAB + '["').join(HTAB + HTAB)
        
        .split('",\n').join('\n')
        .split('"\n').join('\n')
        
        .split('"],\n').join('\n');


    if (formJson[formJson.length-1] == '"')
        formJson = formJson.substring(0, formJson.length - 1);

    if (formJson.substring(formJson.length-2) == '"]')    
        formJson = formJson.substring(0, formJson.length - 2);

    return formJson;
}



function formatSavedDataJson(json)
{
    let formJson = json
        .replace('{\n', '')
        .replace('\n}', '')
        .replace('[\n' + HTAB, '')
        .replace('\n' + HTAB + ']', '');

    return formJson;
}



function logSavedConn(conn, darkMode)
{
    const strConn = connToString(conn, true);

    if (darkMode)
    {
        console.log(
            '%c%s', 
            'background: #4f44; color: #ded', 
            strConn); 
    }
    else
    {
        console.log(
            '%c%s', 
            'background: #cfc; color: black;', 
            strConn); 
    }
}


// Observer = 2

const D65 = [0.95047, 1, 1.08883]; 


function createColorSpace(R, G, B, Y, W, gamma, degamma, regamma, luminance)
{
    return {    
        R:         R,
        G:         G,
        B:         B,

        Y:         Y,

        W:         W,

        lin2xyz:   rgbMatrix(R, G, B, W),
        xyz2lin:   inverse(rgbMatrix(R, G, B, W)),

        gamma:     gamma,
        
        degamma:   degamma,
        regamma:   regamma,
        
        luminance: luminance
    };
}


function rgbMatrix(R, G, B, W)
{
    const C0 = colorVector(R);
    const C1 = colorVector(G);
    const C2 = colorVector(B);

    const M = [ [ C0[0], C1[0], C2[0] ], 
                [ C0[1], C1[1], C2[1] ], 
                [ C0[2], C1[2], C2[2] ] ];

    const S = mulv3m3(W, inverse(M));

    return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],
             [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],
             [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ];
}


function colorVector(c)
{
    const x = c[0],
          y = c[1];

    return [x/y, 1, (1-x-y)/y];
}



const sRGB = createColorSpace
(
    [0.64, 0.33], // R
    [0.3,  0.6 ], // G
    [0.15, 0.06], // B

    [0.212656,
     0.715158,
     0.072186], // Y

    D65,        // W

    2.4,        // gamma



    function(v) // degamma
    {
        return v >= 0.04045
               ? Math.pow((v + 0.055) / 1.055, this.gamma)
               : v / 12.92;
    },
    


    function(v) // regamma
    {
        return v > 0.0031308
               ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055
               : v * 12.92;
    },
    

    
    function(rgb) // luminance
    {
        return  this.Y[0] * this.degamma(rgb[0]) 
              + this.Y[1] * this.degamma(rgb[1]) 
              + this.Y[2] * this.degamma(rgb[2]);
    }
);



function rgbSaturateHsv(rgb, amount)
{
    const hsv = rgb2hsv(rgb);
    hsv[1] *= amount;
    return hsv2rgb(hsv);
}



function rgbSaturateHsl(rgb, amount)
{
    const hsl = rgb2hsl(rgb);
    hsl[1] *= amount;
    return hsl2rgb(hsl);
}


function rgb2hsv_(r, g, b)
{
    let h, s, v;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    v = max;
    s = max == 0 ? 0 : delta / max;
	
    if      (max == r) h = 1/6 * (g - b) / delta + 1;   // between yellow and magenta
    else if (max == g) h = 1/6 * (b - r) / delta + 1/3; // between cyan and yellow
    else if (max == b) h = 1/6 * (r - g) / delta + 2/3; // between between magenta and cyan

	if (h > 1) h -= 1;
	//if (h < 0) h += 1;

    return [h, s, v];
}



function rgb2hsv(rgb)
{
    return rgb2hsv_(rgb[0], rgb[1], rgb[2]);
}



function hsv2rgb_(h, s, v)
{
    // h %= 1;

    // if (h < 0) h += 1;
    //while (h > 1) h -= 1;

    if (s == 0)
        return [v, v, v]; // achromatic

    h *= 6 - 0.0000001;

    let i = Math.floor(h);
    let f = h - i;
	
    let p = v * (1 - s);
    let q = v * (1 - s * f);
    let t = v * (1 - s * (1 - f));

    switch (i)
    {
        case 0:  return [v, t, p];
        case 1:  return [q, v, p];
        case 2:  return [p, v, t];
        case 3:  return [p, q, v];
        case 4:  return [t, p, v];
        default: return [v, p, q];
    }
}



function hsv2rgb(hsv)
{
	return hsv2rgb_(hsv[0], hsv[1], hsv[2]);
}


function rgb2hsl_(r, g, b)
{
    let h, s, l;

    let min = Math.min(Math.min(r, g), b),
        max = Math.max(Math.max(r, g), b);

    let delta = max - min;

    l = (max + min) / 2;

         if (max == min) h = 0;
    else if (max == r  ) h = 1/6 * (g - b) / delta + 1;
    else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;
    else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;

         if (max == min) s = 0;
    else if (l <= 0.5)   s = delta / (2 * l);
    else if (l >  0.5)   s = delta / (2 - 2 * l);

    return [h, s, l];
}



function rgb2hsl(rgb)
{
    return rgb2hsl_(rgb[0], rgb[1], rgb[2]);
}



function hsl2rgb_(h, s, l)
{
    let q =
        l < 0.5
        ? l * (1 + s)
        : l + s - l * s;

    let p = 2 * l - q;

    let tr = h + 1/3;
    let tg = h;
    let tb = h - 1/3;

    if (tr < 0) tr += 1; if (tr > 1) tr -= 1;
    if (tg < 0) tg += 1; if (tg > 1) tg -= 1;
    if (tb < 0) tb += 1; if (tb > 1) tb -= 1;

    let r, g, b;

    let qp6 = (q - p) * 6; 

         if (tr <  1/6)				r = p + qp6 * tr;
    else if (tr >= 1/6 && tr < 0.5)	r = q;
    else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);
    else							r = p;
	
         if (tg <  1/6)				g = p + qp6 * tg;
    else if (tg >= 1/6 && tg < 0.5)	g = q;
    else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);
    else							g = p;

         if (tb <  1/6)				b = p + qp6 * tb;
    else if (tb >= 1/6 && tb < 0.5) b = q;
    else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);
    else							b = p;

    return [r, g, b];
}



function hsl2rgb(hsl)
{
    return hsl2rgb_(hsl[0], hsl[1], hsl[2]);
}


function xyz2lms(xyz)
{
    return mulv3m3(xyz, CAT);//HPE);
}



function lms2xyz(lms)
{
    return mulv3m3(lms, invCAT);//invHPE);
}



function rgb2xyz(rgb, cs = sRGB)
{ 
    return rgb2xyz_(rgb[0], rgb[1], rgb[2], cs);
}    



function rgb2xyz_(r, g, b, cs = sRGB)
{ 
    let rgb = [
        cs.degamma(r),
        cs.degamma(g),
        cs.degamma(b) ];

    return lrgb2xyz(rgb, cs);
}    



function lrgb2xyz(rgb, cs = sRGB)
{
    return mulv3m3(rgb, cs.lin2xyz);
}        



function xyz2rgb(xyz, cs = sRGB)
{
    let rgb = xyz2lrgb(xyz, cs);

    return [
        cs.regamma(rgb[0]),
        cs.regamma(rgb[1]),
        cs.regamma(rgb[2]) ];
}



function xyz2lrgb(xyz, cs = sRGB)
{
    return mulv3m3(xyz, cs.xyz2lin);
}






function rgb2luv(rgb, cs = sRGB)
{
    return xyz2luv(rgb2xyz(rgb, cs), cs.W);
}



function luv2rgb(luv, cs = sRGB)
{
    return xyz2rgb(luv2xyz(luv, cs.W), cs);
}



function xyz2luv(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = cube(6/29);
    const k = cube(29/3);

    const yw = y / W[1];

    let l = 
        yw > e
        ? 116 * Math.cbrt(yw) - 16
        : k * yw;

    const u_ = 4*x / (x + 15*y + 3*z);
    const v_ = 9*y / (x + 15*y + 3*z);
    
    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const u = 13*l * (u_ - uw);
    const v = 13*l * (v_ - vw);

    return [
        l / 100, 
        u / 100, 
        v / 100];
}



function luv2xyz(luv, W = sRGB.W)
{
    let l = luv[0] * 100, 
        u = luv[1] * 100, 
        v = luv[2] * 100;

    const e = cube(6/29);    
    const k = cube(29/3);

    const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);
    const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);
    
    const y = 
        l > e*k
        ? cube((l + 16) / 116)
        : l / k;
    
    const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;
    const b = -5 * y;
    const c = -1/3;
    const d =  y * (39*l / nozero(v + 13*l*vw) - 5);

    const x = (d - b) / nozero(a - c);

    const z = x*a + b;

    return [x, y, z];
}


function rgb2lab(rgb, cs = sRGB)
{
    return xyz2lab(rgb2xyz(rgb, cs), cs.W);
}



function lab2rgb(lab, cs = sRGB)
{
    return xyz2rgb(lab2xyz(lab, cs.W), cs);
}



function xyz2lab(xyz, W = sRGB.W)
{
    const x = xyz[0], 
          y = xyz[1], 
          z = xyz[2];

    const e = 0.008856; //cube(6/29);
    const k = 903.3;    //cube(29/3);

    let xw = x / W[0];
    let yw = y / W[1];
    let zw = z / W[2];

    xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;
    yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;
    zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;


    const l = (1.16 * yw) - 0.16;
    const a = 5 * (xw - yw);
    const b = 2 * (yw - zw);

    return [l, a, b];
}



function lab2xyz(lab, W = sRGB.W)
{
    const l = lab[0], 
          a = lab[1], 
          b = lab[2];

    const e = 0.008856 / 100; //cube(6/29) / 100;
    const k = 903.3    / 100; //cube(29/3) / 100;

    const yw = (l + 0.16)/1.16;
    const xw = a/5 + yw;
    const zw = yw - b/2;

    let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;
    let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;
    let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;

    x *= W[0];
    y *= W[1];
    z *= W[2];
 
    return [x, y, z];
}


function rgb2oklab(rgb, cs = sRGB)
{
    return rgb2oklab_(rgb[0], rgb[1], rgb[2], cs);
}



function rgb2oklab_(r, g, b, cs = sRGB) 
{
    return oklms2oklab(rgb2oklms_(r, g, b, cs));
}



function rgb2oklms_(r, g, b, cs = sRGB) 
{
    r = cs.degamma(r);
    g = cs.degamma(g);
    b = cs.degamma(b);

    return [
        0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b,
	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b,
	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ];
}        



function oklms2oklab(lms) 
{
    const l = Math.cbrt(lms[0]);
    const m = Math.cbrt(lms[1]);
    const s = Math.cbrt(lms[2]);

    const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;
    const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;
    const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;

    return [
        l_,
        a_, 
        b_ ];
}        



function oklab2rgb(lab, cs = sRGB)
{
    return oklms2rgb(oklab2oklms(lab), cs);
}



function oklab2rgb_(l, a, b, cs = sRGB) 
{
    return oklab2rgb([l, a, b], cs);
}



function oklab2oklms(lab)
{
    return oklab2oklms_(lab[0], lab[1], lab[2]);
}



function oklab2oklms_(l, a, b) 
{
    return [
        l + 0.3963377774 * a + 0.2158037573 * b,
        l - 0.1055613458 * a - 0.0638541728 * b,
        l - 0.0894841775 * a - 1.2914855480 * b ];
}



function oklms2rgb(lms, cs = sRGB) 
{
    const l = cube(lms[0]);
    const m = cube(lms[1]);
    const s = cube(lms[2]);

	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;
	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;
	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;

    return [
        cs.regamma(r),
        cs.regamma(g),
        cs.regamma(b) ];
}


const hclok_C_scale = 0.89;


function opp2pol(opp) // opponent to polar
{
    // either lab or luv, 
    // the polar transformation is the same

    const l = opp[0], 
          a = opp[1], 
          b = opp[2];

    const h = Math.atan2(b, a);
    const c = Math.sqrt(a*a + b*b);

    return [h, c, l];
}



function pol2opp(pol) // polar to opponent
{
    // either lab or luv, 
    // the polar transformation is the same

    const h = pol[0], 
          c = pol[1], 
          l = pol[2];

    const a = c * Math.cos(h);
    const b = c * Math.sin(h);

    return [l, a, b];
}


function hclok2rgb(hcl, cs = sRGB)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2]; 

    return oklab2rgb(pol2opp(hcl), cs);
}    



function hclok2rgb_(h, c, l, cs = sRGB)
{
    return hclok2rgb_([h, c, l], cs);
}    
    
    
    
function rgb2hclok(rgb, cs = sRGB)
{
    const hcl = opp2pol(rgb2oklab(rgb, cs));

    hcl[0] /= Tau;
    hcl[1] /= nozero(hcl[2]);

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclok_(r, g, b, cs = sRGB)
{
    return rgb2hclok([r, g, b], cs);
}



function hclab2lab(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hclab2rgb(hcl, cs = sRGB)
{
    return lab2rgb(hclab2lab(hcl), cs);
}



function lab2hclab(lab)
{
    let hcl = opp2pol(lab);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hclab(rgb, cs = sRGB)
{
    return lab2hclab(rgb2lab(rgb, cs));
}



function hcluv2luv(hcl)
{
    hcl = [...hcl];

    hcl[0] *= Tau;
    hcl[1] *= hcl[2];

    return pol2opp(hcl);
}



function hcluv2rgb(hcl, cs = sRGB)
{
    return luv2rgb(hcluv2luv(hcl), cs);
}



function luv2hcluv(luv)
{
    let hcl = opp2pol(luv);

    hcl[0] /= Tau;
    hcl[1] /= hcl[2];

    while (hcl[0] < 0) hcl[0] += 1;
    while (hcl[0] > 1) hcl[0] -= 1;

    return hcl;
}



function rgb2hcluv(rgb, cs = sRGB)
{
    return luv2hcluv(rgb2luv(rgb, cs));
}


const ColorSpaces = 
[
    ['hex',   'Hex'   ],
    ['rgb',   'RGB'   ], 
    ['hsv',   'HSV'   ], 
    ['hsl',   'HSL'   ], 
    ['hclok', 'HCL/ok'],
    ['hclab', 'HCL/ab'],
    ['hcluv', 'HCL/uv'],
    ['oklab', 'okLab' ],
    ['lab',   'Lab'   ],
    ['luv',   'Luv'   ]
];



class ColorSpace
{
    hex   = Object.freeze(0);
    rgb   = Object.freeze(1);
    hsv   = Object.freeze(2);
    hsl   = Object.freeze(3);
    hclok = Object.freeze(4);
    hclab = Object.freeze(5);
    hcluv = Object.freeze(6);
    oklab = Object.freeze(7);
    lab   = Object.freeze(8);
    luv   = Object.freeze(9);
}



class Color
extends Float32Array
{
    get r() { return this[0]; }
    get g() { return this[1]; }
    get b() { return this[2]; }
    get a() { return this[3]; }
    get s() { return this[4]; }

    set r(r) { this[0] = r; }
    set g(g) { this[1] = g; }
    set b(b) { this[2] = b; }
    set a(a) { this[3] = a; }
    set s(s) { this[4] = s; }



    constructor(c = null)
    {
        super(5); // c1, c2, c3, a, s (space)

        if (c)
        {
            this.r = c.r;
            this.g = c.g;
            this.b = c.b;
            this.a = c.a;
            this.s = c.s;
        }
        else
        {
            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 0;
            this.s = ColorSpace.rgb;
        }
    }
}


const ColorEpsilon = 0.001;



function rgb2dataColor(rgb)
{
    const _space = 'rgb';

    return [
        _space, 
        getNormalColorValue(rgb[0], _space, 0), 
        getNormalColorValue(rgb[1], _space, 1), 
        getNormalColorValue(rgb[2], _space, 2) ]; 
}



function makeDataColor(space, c1, c2, c3)
{
    const _space = colorSpace(space.value);

    return [
        _space, 
        getNormalColorValue(c1.value, _space, 0), 
        getNormalColorValue(c2.value, _space, 1), 
        getNormalColorValue(c3.value, _space, 2) ]; 
}



function dataColorIsNaN(c)
{
    return isNaN(c[1])
        || isNaN(c[2])
        || isNaN(c[3]);
}



function dataColorIsValid(col, lim = ColorEpsilon)
{
    return rgbIsValid(dataColor2rgb(col), lim);
}



function dataColorIsOk(col, lim = ColorEpsilon)
{
    return rgbIsOk(dataColor2rgb(col), lim);
}


const rgb_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN ];

const rgba_NaN = [
    Number.NaN,
    Number.NaN,
    Number.NaN,
    Number.NaN ];


const rgbInvalid  = [0xff, 0, 0xff];
const rgbaInvalid = [0xff, 0, 0xff, 0xff];


const dataColor_NaN = Object.freeze([
    'rgb',
    Number.NaN,
    Number.NaN,
    Number.NaN ]);


// Hunt-Pointer-Estevez
// const HPE = [[ 0.4002, 0.7076, -0.0808],
//              [-0.2263, 1.1653,  0.0457],
//              [ 0,      0,       0.9182]];

// const invHPE = inverse(HPE);


// CIECAM02
const CAT = [[ 0.7328, 0.4296, -0.1624],
             [-0.7036, 1.6975,  0.0061],
             [ 0.0030, 0.0136,  0.9834]];

const invCAT = inverse(CAT);


const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],
            [ 0.0329845436, 0.9293118715,  0.0361456387 ],
            [ 0.0482003018, 0.2643662691,  0.6338517070 ]];

const invM1 = inverse(M1);



function rgbIsNaN(rgb) 
{
    return isNaN(rgb[0])
        || isNaN(rgb[1])
        || isNaN(rgb[2]);
}



function rgbaIsNaN(rgba) 
{
    return isNaN(rgba[0])
        || isNaN(rgba[1])
        || isNaN(rgba[2])
        || isNaN(rgba[3]);
}



function rgbIsValid(rgb, lim = ColorEpsilon)
{
    return rgb[0] > -lim && rgb[0] < 1 + lim 
        && rgb[1] > -lim && rgb[1] < 1 + lim 
        && rgb[2] > -lim && rgb[2] < 1 + lim;
}



function rgbaIsValid(rgba, lim = ColorEpsilon)
{
    return rgba[0] > -lim && rgba[0] < 1 + lim 
        && rgba[1] > -lim && rgba[1] < 1 + lim 
        && rgba[2] > -lim && rgba[2] < 1 + lim
        && rgba[3] > -lim && rgba[3] < 1 + lim;
}



function rgbIsOk(rgb, lim = ColorEpsilon)
{
    return !rgbIsNaN  (rgb)
        &&  rgbIsValid(rgb, lim);
}



function rgbaIsOk(rgba, lim = ColorEpsilon)
{
    return !rgbaIsNaN  (rgba)
        &&  rgbaIsValid(rgba, lim);
}



function invalid2validRgb(rgb)
{
    return [
        Math.min(Math.max(0, rgb[0]), 1),
        Math.min(Math.max(0, rgb[1]), 1),
        Math.min(Math.max(0, rgb[2]), 1) ];
}



function rgbLerp(rgb1, rgb2, t)
{
    return [ lerp(rgb1[0], rgb2[0], t),
             lerp(rgb1[1], rgb2[1], t),
             lerp(rgb1[2], rgb2[2], t) ];
}



function rgbaLerp(rgba1, rgba2, t)
{
    return [ lerp(rgba1[0], rgba2[0], t),
             lerp(rgba1[1], rgba2[1], t),
             lerp(rgba1[2], rgba2[2], t),
             lerp(rgba1[3], rgba2[3], t) ];
}



function rgbAdd(rgb1, rgb2)
{
    return [ rgb1[0] + rgb2[0],
             rgb1[1] + rgb2[1],
             rgb1[2] + rgb2[2] ];
}



function rgbSub(rgb1, rgb2)
{
    return [ rgb1[0] - rgb2[0],
             rgb1[1] - rgb2[1],
             rgb1[2] - rgb2[2] ];
}



function rgbMuls(rgb, s)
{
    return [ rgb[0] * s,
             rgb[1] * s,
             rgb[2] * s ];
}



function rgbAvg(rgb1, rgb2)
{
    return [ (rgb1[0] + rgb2[0]) / 2,
             (rgb1[1] + rgb2[1]) / 2,
             (rgb1[2] + rgb2[2]) / 2 ];
}



function rgbMax(rgb1, rgb2)
{
    return [ Math.max(rgb1[0], rgb2[0]),
             Math.max(rgb1[1], rgb2[1]),
             Math.max(rgb1[2], rgb2[2]) ];
}



function rgbPow(col, p)
{
    return [
        Math.pow(col[0], p), 
        Math.pow(col[1], p), 
        Math.pow(col[2], p) ]
}



function allConesWork(cones)
{
    return cones.l == 1 
        && cones.m == 1 
        && cones.s == 1;
}



function rgbToString(rgb)
{
    return '{' + Math.round(rgb[0] * 255) + ', '
               + Math.round(rgb[1] * 255) + ', '
               + Math.round(rgb[2] * 255) + '}';
}



function colorStyle_(r, g, b, a)
{
    if (a != undefined)
    {
        return 'rgba('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ', '
            + a + ')';
    }
    else
    {
        return 'rgb('
            + Math.round(r * 0xff) + ', '
            + Math.round(g * 0xff) + ', '
            + Math.round(b * 0xff) + ')';
    }
}



function colorStyleRgb_(r, g, b)
{
    return colorStyle_(r, g, b, 1);
}



function rgb2style(rgb)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], 1);
}



function colorStyleRgba_(r, g, b, a)
{
    return colorStyle_(r, g, b, a);
}



function rgba2style(rgba)
{
    return colorStyle_(rgba[0], rgba[1], rgba[2], rgba[3]);
}



function rgb2style_a(rgb, a = 1)
{
    return colorStyle_(rgb[0], rgb[1], rgb[2], a);
}



function toRgba(rgb_)
{
    return rgb_.length == 3
         ? [...rgb_, 1]
         : rgb_;
}



function rgb_a(rgb, a = 1)
{
    return [rgb[0], rgb[1], rgb[2], a];
}



function isDark(rgb, threshold = 0.71)
{
    return rgb2hclok(rgb)[2] < threshold;
}



function rgbDistance(col1, col2)
{
    const d0 = col2[0] - col1[0];
    const d1 = col2[1] - col1[1];
    const d2 = col2[2] - col1[2];

    return Math.sqrt(d0*d0 + d1*d1 + d2*d2);
}



function rgbaMul(rgba, v)
{
    return [
        rgba[0] * v,
        rgba[1] * v,
        rgba[2] * v,
        rgba[3] * v ];
}



function rgbaDiv(rgba, v)
{
    return [
        rgba[0] / v,
        rgba[1] / v,
        rgba[2] / v,
        rgba[3] / v ];
}



function maxRgbDistance(col1, col2)
{
    return Math.max(Math.max(Math.max(
        Math.abs(col2[0] - col1[0]),
        Math.abs(col2[1] - col1[1])),
        Math.abs(col2[2] - col1[2])));
}



function rgbEqual(rgb1, rgb2)
{
    return Math.abs(rgb1[0] - rgb2[0]) < ColorEpsilon
        && Math.abs(rgb1[1] - rgb2[1]) < ColorEpsilon
        && Math.abs(rgb1[2] - rgb2[2]) < ColorEpsilon;        
}



function style2rgba(style) // SLOW
{
    utilContext.fillStyle = style;
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function computedStyle2rgba(obj, style) // SLOW
{
    utilContext.fillStyle = getStyleValue(obj, style);
    utilContext.fillRect(0, 0, 1, 1);

    return rgbaDiv(utilContext.getImageData(0, 0, 1, 1).data, 0xFF);
}



function getTextColorFromBackColor(rgb, opacity = 1)
{
    return !rgbIsNaN(rgb)
           ? (opacity >= 0.5
               ? (isDark(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])
               : (darkMode ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))
           : (darkMode ? rgbaNoColorTextDark : rgbaNoColorTextLight);
}



function getDefaultWarningRgba(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])  
         : (darkMode ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);  
}



function getWarningStyles(colBack)
{
    let warnStyle1, 
        warnStyle2;
    
        
    const colWarning = getDefaultWarningRgba(colBack);

     
    if (!rgbIsNaN(colBack))
    {
        const hclBack = rgb2hclok(colBack);

        const hclBack1 = [...hclBack];
        const hclBack2 = [...hclBack];

        hclBack1[0] += 1/12;  if (hclBack1[0] > 1) hclBack1[0] -= 1;
        hclBack2[0] -= 1/12;  if (hclBack2[0] < 0) hclBack2[0] += 1;


        const altBack1 = rgb_a(clampRgb(hclok2rgb(hclBack1)), 0.35);
        const altBack2 = rgb_a(clampRgb(hclok2rgb(hclBack2)), 0.35);

        const factor   = getWarningFactor(colBack);

        const colWarn1 = rgbaLerp(colWarning, altBack1, factor);
        const colWarn2 = rgbaLerp(colWarning, altBack2, factor);
        
        warnStyle1     = rgba2style(colWarn1);
        warnStyle2     = rgba2style(colWarn2);
    }
    else
    {
        warnStyle1 = rgba2style(colWarning);
        warnStyle2 = rgba2style(colWarning);
    }


    return [warnStyle1, 
            warnStyle2];
}



function getWarningGradient(i, style1, style2)
{
    return 'repeating-linear-gradient('
            + '-45deg, '
            + 'transparent 0 ' + i   + 'px,' 
            +  style1 + ' '    + i   + 'px ' + i*2 +'px,'
            + 'transparent '   + i*2 + 'px ' + i*3 +'px,'
            +  style2 + ' '    + i*3 + 'px ' + i*4 +'px)';
}



function getWarningFactor(colBack)
{
    let dr, dg, db;

    if (colBack[0] < 0) dr = -colBack[0]; else if (colBack[0] > 1) dr = colBack[0] - 1; else dr = 0;
    if (colBack[1] < 0) dg = -colBack[1]; else if (colBack[1] > 1) dg = colBack[1] - 1; else dg = 0;
    if (colBack[2] < 0) db = -colBack[2]; else if (colBack[2] > 1) db = colBack[2] - 1; else db = 0;
    
    const d   = [dr, dg, db].sort()[1];
    const avg = (dr + dg + db) / 3;

    const factor = Math.min((d + avg) / 2, 1);

    // if (this.id == 'color')
    // {
    //     console.log('colBack =', colBack);
    //     console.log('dr     =', dr);
    //     console.log('dg     =', dg);
    //     console.log('db     =', db);
    //     console.log('d      =', d);
    //     console.log('avg    =', avg);
    //     console.log('factor =', factor);
    //     console.log('');
    // }

    return factor;
}



function getStripeBackColor(rgbBack)
{
    let rgbStripeBack = [...rgbBack];
        
    const factor = getWarningFactor(rgbBack);

    if (factor > 0)
    {
        const hcl = rgb2hclok(clampRgb(rgbBack));
        hcl[1] /= 2;
        

        rgbStripeBack = rgbLerp(rgbBack, clipChroma(hclok2rgb(hcl)), factor);
    }

    return rgbStripeBack;
}



function getDefaultWarningStyle(rgb)
{
    return !rgbIsNaN(rgb)
         ? (isDark(rgb)  ? '#ffffff29' : '#00000022')
         : (darkMode ? '#ffffff08' : '#00000006'); 
}



function clampRgb(_rgb)
{
    const rgb = [..._rgb];

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function clampChan(val)
{
    return Math.min(Math.max(0, val), 1);
}



function setChan(_col, chan, val)
{
    const col = [..._col];
    col[chan] = val;
    return col;
}



function clipChroma(rgb)
{
    let hcl = rgb2hclok(rgb);

    let loopProtect = 10000;

    while (!rgbIsValid(hclok2rgb(hcl))
         && hcl[1] > 0.001
         && loopProtect-- > 0)
        hcl[1] -= 0.001;

    rgb = hclok2rgb(hcl);

    rgb[0] = Math.min(Math.max(0, rgb[0]), 1);   
    rgb[1] = Math.min(Math.max(0, rgb[1]), 1);   
    rgb[2] = Math.min(Math.max(0, rgb[2]), 1); 

    return rgb;
}



function noColorStyle(rgba)
{
    if (!rgbaIsNaN(rgba))
        return 'transparent';
    else
    {
        return darkMode
            ? 'rgba(56, 56, 56, 0.95)'
            : 'rgba(255, 255, 255, 0.95)';
    }
}


const lmsW = xyz2lms(lrgb2xyz([1, 1, 1]));
const lmsB = xyz2lms(lrgb2xyz([0, 0, 1]));
const lmsR = xyz2lms(lrgb2xyz([1, 0, 0]));

const lq1 = (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]) / (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]);
const lq2 = (lmsW[1]*lmsB[0] - lmsB[1]*lmsW[0]) / (lmsW[1]*lmsB[2] - lmsB[1]*lmsW[2]);

const mq1 = (lmsW[2]*lmsB[1] - lmsB[2]*lmsW[1]) / (lmsW[2]*lmsB[0] - lmsB[2]*lmsW[0]);
const mq2 = (lmsW[0]*lmsB[1] - lmsB[0]*lmsW[1]) / (lmsW[0]*lmsB[2] - lmsB[0]*lmsW[2]);

const sq1 = (lmsW[1]*lmsR[2] - lmsR[1]*lmsW[2]) / (lmsW[1]*lmsR[0] - lmsR[1]*lmsW[0]);
const sq2 = (lmsW[0]*lmsR[2] - lmsR[0]*lmsW[2]) / (lmsW[0]*lmsR[1] - lmsR[0]*lmsW[1]);

const bq1 = lmsW[0] / lmsW[2];
const bq2 = lmsW[1] / lmsW[2];


// this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
// the simulation itself gives grayscale
// on the site the simulation has color in it, so I decided to leave some color in as well,
// but the amount is completely arbitrary, I just felt that this particular value matches
// the description on that site without being unrealistically exaggerated
const blueMono = 0.88;


function rgb2colorblind(rgb, l, m, s, cs = sRGB)
{
    if (   l == 0
        && m == 0
        && s == 0)
    {
        // achromatopsia is simulated by taking only the luminance

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        rgb = [a, a, a];
    }
    else
    {
        const xyz = rgb2xyz(rgb, cs);
        const lms = xyz2lms(xyz);

        const a = 
              cs.Y[0] * rgb[0]
            + cs.Y[1] * rgb[1]
            + cs.Y[2] * rgb[2];

        const lm = Math.min(l + m, 1);


        const lms_ = [
            lms[0] + lerp(blueMono * (bq1*lms[2] - lms[0]), (1 - l) * ((lq1*lms[1] + lq2*lms[2]) - lms[0]), lm),
            lms[1] + lerp(blueMono * (bq2*lms[2] - lms[1]), (1 - m) * ((mq1*lms[0] + mq2*lms[2]) - lms[1]), lm),
            lms[2] + lerp(0,                     lerp(s, 1 - s, lm) * ((sq1*lms[0] + sq2*lms[1]) - lms[2]), lm) ];

        const xyz_ = lms2xyz(lms_);
              rgb  = xyz2rgb(xyz_, cs);


        let bm_ = rgb2lab(rgb, cs);
        bm_[0] = lerp(a, bm_[0], lm);
        rgb = lab2rgb(bm_, cs);

        
        rgb = rgbLerp(
            [a, a, a], 
            rgb, 
            Math.min(s + lm, 1));
    }
    

    return rgb;
}


function rgb2hex(rgb)
{
    let hex =
          Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function rgba2hex(rgba)
{
    let hex =
          Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()
        + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();

    return hex;
}



function validHex2rgb(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgb_NaN 
           : hex2rgb(hex);
}



function validHex2rgba(hex) // can process invalid '-'
{
    return hex.indexOf(NAN_DISPLAY) > -1 
           ? rgba_NaN 
           : hex2rgba(hex);
}



function hex2rgb(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgb = [];

    if (hex.length >= 6)
    {
        rgb[0] = parseInt(hex.slice(0, 2), 16); 
        rgb[1] = parseInt(hex.slice(2, 4), 16); 
        rgb[2] = parseInt(hex.slice(4, 6), 16); 
    }
    else if (hex.length >= 3)
    {
        rgb[0] = parseInt(hex[0], 16) * 0x11; 
        rgb[1] = parseInt(hex[1], 16) * 0x11; 
        rgb[2] = parseInt(hex[2], 16) * 0x11; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v; 
        rgb[1] = v; 
        rgb[2] = v; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgb[0] = v * 0x11; 
        rgb[1] = v * 0x11; 
        rgb[2] = v * 0x11; 
    }
    else if (hex.length == 0)
    {
        rgb[0] = 0; 
        rgb[1] = 0; 
        rgb[2] = 0;         
    }


    rgb[0] /= 0xff;
    rgb[1] /= 0xff;
    rgb[2] /= 0xff;

    
    return rgb;
}



function hex2rgba(hex)
{
    if (hex[0] == '#')
        hex = hex.substring(1);

        
    let rgba = [];

    if (hex.length >= 8)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = parseInt(hex.slice(6, 8), 16); 
    }
    else if (hex.length >= 6)
    {
        rgba[0] = parseInt(hex.slice(0, 2), 16); 
        rgba[1] = parseInt(hex.slice(2, 4), 16); 
        rgba[2] = parseInt(hex.slice(4, 6), 16); 
        rgba[3] = 0xff; 
    }
    else if (hex.length >= 4)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = parseInt(hex[3], 16) * 0x11; 
    }
    else if (hex.length == 3)
    {
        rgba[0] = parseInt(hex[0], 16) * 0x11; 
        rgba[1] = parseInt(hex[1], 16) * 0x11; 
        rgba[2] = parseInt(hex[2], 16) * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 2)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v; 
        rgba[1] = v; 
        rgba[2] = v; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 1)
    {
        let v = parseInt(hex, 16);
        
        rgba[0] = v * 0x11; 
        rgba[1] = v * 0x11; 
        rgba[2] = v * 0x11; 
        rgba[3] = 0xff; 
    }
    else if (hex.length == 0)
    {
        rgba[0] = 0; 
        rgba[1] = 0; 
        rgba[2] = 0;         
        rgba[3] = 0; 
    }


    rgba[0] /= 0xff;
    rgba[1] /= 0xff;
    rgba[2] /= 0xff;
    rgba[3] /= 0xff;


    return rgba;
}


function getContrastRatio2(textColor, backColor)
{
    if (    rgbIsNaN  (textColor)
        || !rgbIsValid(textColor))
        return Number.NaN;

    const txtY = sRGB.luminance(textColor);
    const  bgY = sRGB.luminance(backColor);

    return (
        bgY > txtY
        ? ( bgY + 0.05) / (txtY + 0.05)
        : (txtY + 0.05) / ( bgY + 0.05));
}



function getContrastRating2(ratio)
{
         if (ratio >= 7  ) return 'AAA';
    else if (ratio >= 4.5) return 'AA';
    else if (ratio >= 3  ) return 'AA<sub>L</sub>'
    else                   return '';
}



function getContrastRatio3(textColor, backColor)
{
    if (!rgbIsOk(textColor))
        return Number.NaN;

    return APCAcontrast(
        sRGBtoY(textColor),
        sRGBtoY(backColor));
}



// I copied the code below from https://github.com/Myndex/SAPC-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
// and refactored it to fit my code style.

const mainTRC     = 2.4; // 2.4 exponent emulates actual monitor perception
       
const sRco        = 0.2126729, 
      sGco        = 0.7151522, 
      sBco        = 0.0721750; // sRGB coefficients
   
const normBG      = 0.56, 
      normTXT     = 0.57,
      revTXT      = 0.62,
      revBG       = 0.65; // G-4g constants for use with 2.4 exponent
   
const blkThrs     = 0.022,
      blkClmp     = 1.414, 
      scaleBoW    = 1.14,
      scaleWoB    = 1.14,
      loBoWthresh = 0.035991,
      loWoBthresh = 0.035991,
      loBoWfactor = 27.7847239587675,
      loWoBfactor = 27.7847239587675,
      loBoWoffset = 0.027,
      loWoBoffset = 0.027,
      loClip      = 0.001,
      deltaYmin   = 0.0005;



function sRGBtoY(rgb) 
{
    // NOTE this is not the actual sRGB luminance as it
    // ignores the straight section. Using actual sRGB
    // luminance gives a slightly different contrast score.

    return sRco * Math.pow(rgb[0], mainTRC) 
         + sGco * Math.pow(rgb[1], mainTRC)
         + sBco * Math.pow(rgb[2], mainTRC);
}



function APCAcontrast(txtY, bgY)
{
    let SAPC           = 0; // For raw SAPC values
    let outputContrast = 0; // For weighted final values

    txtY = 
        txtY > blkThrs 
        ? txtY 
        : txtY + Math.pow(blkThrs - txtY, blkClmp);
        
    bgY = 
        bgY > blkThrs 
        ? bgY 
        : bgY + Math.pow(blkThrs - bgY, blkClmp);

    if (Math.abs(bgY - txtY) < deltaYmin)  
        return 0; 


    if (bgY > txtY) 
    {  
        SAPC = (Math.pow(bgY, normBG) - Math.pow(txtY, normTXT)) * scaleBoW;

        outputContrast = 
            SAPC < loClip 
            ? 0 
            : SAPC < loBoWthresh
              ? SAPC - SAPC * loBoWfactor * loBoWoffset 
              : SAPC - loBoWoffset;
    } 
    else 
    {  
        SAPC = (Math.pow(bgY, revBG) - Math.pow(txtY, revTXT)) * scaleWoB;

        outputContrast = 
            SAPC > -loClip 
            ? 0 
            : SAPC > -loWoBthresh 
              ? SAPC - SAPC * loWoBfactor * loWoBoffset 
              : SAPC + loWoBoffset;
    }


    return outputContrast * 100;
}


const base32chars = '12345679ABCDEFGHJKLMNPQRSTUVWXYZ';



function arrayToBase32(array, chars = base32chars)
{
    let base32 = '';

    
    let len = array.length;
    let i   = 0;

    while (len > 0)
    {
        if (len >= 5)
        {
            const a0 = array[i  ],
                  a1 = array[i+1],
                  a2 = array[i+2],
                  a3 = array[i+3],
                  a4 = array[i+4];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[ (a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) <<  3) | ((a4 & 0xE0) >>> 5)];
            base32 += chars[ (a4 & 0x1F)];
        }
        else if (len == 4)
        {
            const a0 = array[i  ],
                  a1 = array[i+1],
                  a2 = array[i+2],
                  a3 = array[i+3];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1) | ((a3 & 0x80) >>> 7)];
            base32 += chars[ (a3 & 0x7C) >>> 2];
            base32 += chars[((a3 & 0x03) <<  3)];
        }
        else if (len == 3)
        {
            const a0 = array[i  ],
                  a1 = array[i+1],
                  a2 = array[i+2];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4) | ((a2 & 0xF0) >>> 4)];
            base32 += chars[((a2 & 0x0F) <<  1)];
        }
        else if (len == 2)
        {
            const a0 = array[i  ],
                  a1 = array[i+1];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2) | ((a1 & 0xC0) >>> 6)];
            base32 += chars[ (a1 & 0x3E) >>> 1];
            base32 += chars[((a1 & 0x01) <<  4)];
        }
        else if (len == 1)
        {
            const a0 = array[i];
            
            base32 += chars[ (a0 & 0xF8) >>> 3];
            base32 += chars[((a0 & 0x07) <<  2)];
        }


        i   += 5;
        len -= 5;
    }


    return base32;
}



function base32toArray(base32, chars = base32chars)
{
    const array = [];


    let len = base32.length;
    let c   = 0;

    while (len > 0)
    {
        if (len >= 8)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]),
                  c4 = chars.indexOf(base32[c+4]),
                  c5 = chars.indexOf(base32[c+5]),
                  c6 = chars.indexOf(base32[c+6]),
                  c7 = chars.indexOf(base32[c+7]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
            array.push(((c6 & 0x07) << 5) | c7);
        }
        else if (len == 7)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]),
                  c4 = chars.indexOf(base32[c+4]),
                  c5 = chars.indexOf(base32[c+5]),
                  c6 = chars.indexOf(base32[c+6]);

            array.push(( c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
            array.push(((c4 & 0x01) << 7) | (c5 << 2) | ((c6 & 0x18) >>> 3));
        }
        else if (len == 5)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]),
                  c4 = chars.indexOf(base32[c+4]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
            array.push(((c3 & 0x0F) << 4) | ((c4 & 0x1E) >>> 1));
        }
        else if (len == 4)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]),
                  c2 = chars.indexOf(base32[c+2]),
                  c3 = chars.indexOf(base32[c+3]);

            array.push( (c0         << 3) | ((c1 & 0x1C) >>> 2));
            array.push(((c1 & 0x03) << 6) | (c2 << 1) | ((c3 & 0x10) >>> 4));
        }
        else if (len == 2)
        {
            const c0 = chars.indexOf(base32[c  ]),
                  c1 = chars.indexOf(base32[c+1]);

            array.push((c0 << 3) | ((c1 & 0x1C) >>> 2));
        }


        c   += 8;
        len -= 8;
    }


    return array;
}


const cryptoModulusSize     = 64; // to keep the keys short
const millerRabinIterations = 40;

const cryptoBufferSize      = cryptoModulusSize/8;
const cryptoPrimeBufferSize = cryptoBufferSize /2;
     
const cryptoBuffer          = new Uint8Array(cryptoPrimeBufferSize);


function bigCryptoRandom()
{
    for (let i = 0; i < cryptoPrimeBufferSize; i++)
        cryptoBuffer[i] = toInt(Math.random() * 0x100);

    cryptoBuffer[0]                       |= 0xC0; // set the top bit to ensure a relatively large number
    cryptoBuffer[cryptoPrimeBufferSize-1] |= 0x01; // set low bit to ensure the number is odd

    return bigFromBuffer(cryptoBuffer);
}



function bigNextCryptoPrime(n) 
{
    while (!bigIsPrime(n))
        n += 2n;
    
    return n;
}



function bigCryptoPrime(e)
{
    // set p so that gcd(e, p-1) = 1
    
    let p;

    do
    {
        const rnd = bigCryptoRandom();
        p         = bigNextCryptoPrime(rnd);
    }
    while (gcd(p-1n, e) != 1n); 
        
    return p;
}



function createCryptoPrimePair(e)
{
    let p = bigCryptoPrime(e);
    
    let q;
    do { q = bigCryptoPrime(e); } 
    while (q == p);

    if (p < q)
        [p,q] = [q,p];

    return [p, q];
}



function createCryptoKeys(e = 65537n) 
{
    const  p   = 4177474087n,
           q   = 3438374081n; // for a 64-bit modulus
    
    const  n   = p * q;
    const _phi = (p-1n) * (q-1n);

    const  d   = bigModInvert(e, _phi);

    return {
        public:  {n:n, e:e },
        private: {n:n, d:d, p:p, q:q} };
}                        



function encryptBlock(n, key, sign  ) { return bigPowMod(n, (sign   ? key.d : key.e), key.n); }        
function decryptBlock(n, key, verify) { return bigPowMod(n, (verify ? key.e : key.d), key.n); }        



function encrypt(data, key) { return encryptData(data, key, false); }
function decrypt(data, key) { return decryptData(data, key, false); }

function sign   (data, key) { return encryptData(data, key, true); } // yes I know real sign/verify uses a hash,
function verify (data, key) { return decryptData(data, key, true); } // but I prefer it this way for what I need



function encryptData(data, key, sign)
{
    // prep array should be a multiple of cryptoBufferSize
    const prep   = new Uint8Array(Math.ceil((data.length) / cryptoBufferSize) * cryptoBufferSize); 
    const cipher = new Uint8Array(prep.length);


    const start = prep.length - data.length;
    for (let i = 0; i < data.length; i++)
        prep[start+i] = data[i];


    let length = prep.length;
    let nBlock = 0;

    while (length > 0)
    {
        const blockStart = nBlock * cryptoBufferSize;
        const blockSize  = Math.min(length, cryptoBufferSize);
        
        const block = bigFromBufferAt(prep, blockStart, cryptoBufferSize);
        const enc   = encryptBlock(block, key, sign);
        
        bigToBufferAt(enc, cipher, blockStart, cryptoBufferSize);
        
        nBlock++;
        length -= blockSize;
    }
    
    
    return cipher;
}



function decryptData(cipher, key, verify)
{
    const data = new Uint8Array(cipher.length);
    
    
    let length = cipher.length;
    let nBlock = 0;
    
    while (length > 0)
    {
        var blockStart = nBlock * cryptoBufferSize;
        var blockSize  = Math.min(length, cryptoBufferSize);

        var block = bigFromBufferAt(cipher, blockStart, cryptoBufferSize);
        var dec   = decryptBlock(block, key, verify);
        bigToBufferAt(dec, data, blockStart, cryptoBufferSize); 

        nBlock++;
        length -= blockSize;
    }    


    return data;    
}


const licenseKeys     = createCryptoKeys();
const licenseHashSize = 4;



function createLicenseKey(license)
{
    const str  = createLicenseDataString(license);
    const hash = hashLicenseString(str, licenseHashSize);
    const enc  = sign(hash, licenseKeys.private);
    const key  = arrayToBase32(enc);

    return key;
}



function createLicenseFromDate(userId, strDate) // DDMMYYYY
{
    return createLicense(
        userId,
        parseInt(strDate.substring(0, 2)),
        parseInt(strDate.substring(2, 4)),
        parseInt(strDate.substring(4)));

}



function createLicense(userId, lastDay, lastMonth, lastYear, tier = 1)
{
    return {
        userId:    userId,
        tier:      tier, // 0 = free, 1+ = subscription
        lastDay:   lastDay,
        lastMonth: lastMonth,
        lastYear:  lastYear,
    };
}



function createLicenseString(license)
{
    return license.userId
         + createLicenseInfoString(license);
}



function createLicenseInfoString(license)
{
    return license.tier     .toString()
         + license.lastDay  .toString().padStart(2, '0') 
         + license.lastMonth.toString().padStart(2, '0')
         + license.lastYear .toString(); 
}



function createLicenseDataString(license)
{
    const str = createLicenseInfoString(license);

    let comp1 = str;
    let comp2 = '';
    let comp3 = '';
    
    for (let i = 0; i < comp1.length; i++)
    {
        const code2 = ((parseInt(comp1[i]) + i) % 10);

        comp2 += code2.toString();
        comp3 += ((parseInt(comp1[i]) ^ code2) % 10).toString()
    }


    const compData = (comp1 + comp2 + comp3).substring(0, license.userId.length)

    return compactLicenseDataString(license.userId, compData);
}



function getLicenseCompData(license)
{
    const str = createLicenseInfoString(license);

    let comp1 = str;
    let comp2 = '';
    let comp3 = '';
    
    for (let i = 0; i < comp1.length; i++)
    {
        const code2 = (parseInt(comp1[i]) + i) % 10;

        comp2 += code2.toString();
        comp3 += ((parseInt(comp1[i]) ^ code2) % 10).toString()
    }


    return (comp1 + comp2 + comp3).substring(0, license.userId.length)
}



function compactLicenseDataString(userId, str)
{
    let comp = new Uint8Array(userId.length);

    for (let i = 0; i < comp.length; i++)
        comp[i] = (userId.charCodeAt(i) ^ str.charCodeAt(i)) % 0x100;

    return arrayToBase32(comp);
}



function hashLicenseString(str, nBytes)
{
    // XOR wrap name around a given number of bytes

    const bytes = stringToCharCodeArray(str);


    if (bytes.length > nBytes)
    {
        let pos    = nBytes;
        let length = bytes.length - nBytes;
        
        while (length > 0)
        {
            for (let i = 0; i < nBytes; i++)
                bytes[i] ^= bytes[pos+i];
            
            pos    += nBytes;
            length -= nBytes;
        }
    }
    

    return newSizeArrayFrom(bytes, nBytes);
}



function validateLicense(userId, licenseKey)
{
    const now = new Date(Date.now());

    const license = createLicense(
        userId,
        now.getDate(),
        now.getMonth()+1, // months start at 0
        now.getFullYear());


    let   curCheck  = 0;
    const maxCheck  = 31 * 24;


    while (curCheck++ < maxCheck)
    {
        if (validateLicenseKey(license, licenseKey))
            return license;

        license.lastDay++; // err on the side of client, include current day if it's last

        if (license.lastDay   > 31) { license.lastMonth++; license.lastDay   = 1; }
        if (license.lastMonth > 12) { license.lastYear ++; license.lastMonth = 1; }
    }


    return null;
}



function validateLicenseKey(license, key, rec = false)
{
    const str   = createLicenseDataString(license);
    
    const hash  = hashLicenseString(str, licenseHashSize);
    
    const arr   = base32toArray(key.toUpperCase());
    const dec   = verify(arr, licenseKeys.public).subarray(licenseHashSize);
    const trim  = dec.subarray(dec.length - licenseHashSize);
   
    const valid = arraysAreEqual(hash, trim);


    if (valid && !rec)
    {
        let lowerKey = key;

        const lastChar  = lowerKey.at(-1);
        const lastIndex = base32chars.indexOf(lastChar);

        if (lastIndex > 0)
        {
            lowerKey = replaceInStringAt(lowerKey, lowerKey.length-1, base32chars[lastIndex-1]);

            if (validateLicenseKey(license, lowerKey, true))
                return false; // guard against the last bit
        }
    }


    return valid;
}


const LIST_VALUE              = 'LIST#';
const LIST                    = 'LIST';

const LIST_EXPAND             = 'LEXP';

const ITEMS                   = 'ITEMS';
const SELECT                  = 'SEL';
const LIST_COUNT              = 'COUNT';
const IF_ELSE                 = 'IF';
    
const START                   = 'START';
const REPEAT                  = 'REPT';
    
const CACHE                   = 'CACHE';
const COPY                    = 'COPY';


const ANY_TYPE                = 'ANY';


const LIST_TYPES =
[
    LIST_VALUE,
    LIST,
    LIST_EXPAND,
    ITEMS,
    LIST_COUNT,
    REPEAT
];


const FOREACH                 = 'FOR';


const FLOW_TYPES =
[
    ANY_TYPE,
    ...LIST_TYPES,
    ITEMS,
    SELECT,
    IF_ELSE,
    START,
    REPEAT,
    FOREACH,
    CACHE,
    COPY
];


const NUMBER_VALUE            = 'NUM#';  
const NUMBER                  = 'NUM';   
const NUMBER_SIGN             = 'NSIGN';   
const NUMBER_ABSOLUTE         = 'ABS';   
const NUMBER_ROUND            = 'ROUND';   
const NUMBER_LIMITS           = 'LIM';   
const NUMBER_SERIES           = 'SER';  
const NUMBER_RANDOM           = 'RAND';  
const NUMBER_INTERPOLATE      = 'LERP'; 
const NUMBER_TO_TEXT          = 'N2T';
const NUMBER_SOLVE            = 'SOLVE';
const NUMBER_ANIMATE          = 'ANIM';

const NUMBER_MATH             = 'MATH';  
const NUMBER_ADD              = 'ADD';   
const NUMBER_SUBTRACT         = 'SUB';   
const NUMBER_MULTIPLY         = 'MUL';   
const NUMBER_DIVIDE           = 'DIV';   
const NUMBER_MODULO           = 'MOD';   
const NUMBER_EXPONENT         = 'EXP';

const NUMBER_BOOLEAN          = 'BOOL';  
const NUMBER_NOT              = 'NOT';
const NUMBER_AND              = 'AND';
const NUMBER_OR               = 'OR';
const NUMBER_XOR              = 'XOR';

const NUMBER_CONDITION        = 'COND';
const NUMBER_EQUAL            = 'EQ';
const NUMBER_NOT_EQUAL        = 'NE';
const NUMBER_LESS             = 'LT';
const NUMBER_LESS_OR_EQUAL    = 'LE';
const NUMBER_GREATER          = 'GT';
const NUMBER_GREATER_OR_EQUAL = 'GE';


const MATH_TYPES =
[
    NUMBER_MATH,
    NUMBER_ADD,
    NUMBER_SUBTRACT,
    NUMBER_MULTIPLY,
    NUMBER_DIVIDE,
    NUMBER_MODULO,
    NUMBER_EXPONENT
];


const BOOLEAN_TYPES =
[
    NUMBER_BOOLEAN,
    NUMBER_NOT,
    NUMBER_AND,
    NUMBER_OR,
    NUMBER_XOR
];


const CONDITION_TYPES =
[
    NUMBER_CONDITION,
    NUMBER_EQUAL,
    NUMBER_NOT_EQUAL,
    NUMBER_LESS,
    NUMBER_LESS_OR_EQUAL,
    NUMBER_GREATER,
    NUMBER_GREATER_OR_EQUAL
];


const NUMBER_TYPES =
[
    NUMBER_VALUE,
    NUMBER,
    NUMBER_SIGN,
    NUMBER_ABSOLUTE,
    NUMBER_ROUND,
    NUMBER_LIMITS,
    NUMBER_SERIES,
    NUMBER_RANDOM,
    NUMBER_INTERPOLATE,
    NUMBER_TO_TEXT,
    NUMBER_SOLVE,
    NUMBER_ANIMATE,

    ...MATH_TYPES,
    ...BOOLEAN_TYPES,
    ...CONDITION_TYPES
];


const TEXT_VALUE     = 'TEXT#';  
const TEXT           = 'TEXT';   
const TEXT_SUBSTRING = 'TSUB'; 
const TEXT_REPLACE   = 'TREPL'; 
const TEXT_JOIN      = 'TJOIN';  
const TEXT_CHAR      = 'TCHAR';
const TEXT_CSV       = 'TCSV';
const TEXT_FETCH     = 'FETCH';


const TEXT_TYPES =
[
    TEXT_VALUE,
    TEXT,
    TEXT_SUBSTRING,
    TEXT_JOIN,
    TEXT_REPLACE,
    TEXT_CHAR,
    TEXT_CSV,
    TEXT_FETCH
];


const COLOR_VALUE       = 'COL#';  
const COLOR             = 'COL';   
const VALID_COLOR       = 'CVAL';  
const CORRECT_COLOR     = 'CCOR';  
const COLOR_CONTRAST    = 'CCNT';  
const COLORBLIND        = 'BLND';  
const COLOR_INTERPOLATE = 'CLERP'; 
const COLOR_BLEND       = 'CBLND';


const COLOR_TYPES =
[
    COLOR_VALUE,
    COLOR,
    CORRECT_COLOR,
    COLORBLIND,
    COLOR_INTERPOLATE,
    COLOR_BLEND
];


const FILL_VALUE       = 'FILL#';
const FILL             = 'FILL';
const FILL_TYPES       = [FILL_VALUE, FILL];

const STROKE_VALUE     = 'STRK#';
const STROKE           = 'STRK';
const STROKE_TYPES     = [STROKE_VALUE, STROKE];

const COLOR_STOP_VALUE = 'CSTOP#';
const COLOR_STOP       = 'CSTOP';

const GRADIENT_VALUE   = 'GRAD#';
const GRADIENT         = 'GRAD';
const GRADIENT_TYPES   = [GRADIENT_VALUE, GRADIENT];


const COLOR_STYLE      = 'CSTL';


const SHAPE_VALUE      = 'SHP#'; // abstract placeholder

const RECTANGLE_VALUE  = 'RECT#';
const RECTANGLE        = 'RECT'; 
const RECTANGLE_TYPES  = [RECTANGLE_VALUE, RECTANGLE];

const LINE_VALUE       = 'LINE#';
const LINE             = 'LINE'; 
const LINE_TYPES       = [LINE_VALUE, LINE];

const ELLIPSE_VALUE    = 'ELPS#';
const ELLIPSE          = 'ELPS'; 
const ELLIPSE_TYPES    = [ELLIPSE_VALUE, ELLIPSE];

const POLYGON_VALUE    = 'POLY#';
const POLYGON          = 'POLY'; 
const POLYGON_TYPES    = [POLYGON_VALUE, POLYGON];

const STAR_VALUE       = 'STAR#';
const STAR             = 'STAR'; 
const STAR_TYPES       = [STAR_VALUE, STAR];

const TEXTSHAPE_VALUE  = 'TXTS#';
const TEXTSHAPE        = 'TXTS'; 
const TEXTSHAPE_TYPES  = [TEXTSHAPE_VALUE, TEXTSHAPE];


const SHAPE_VALUES =
[
    SHAPE_VALUE,

    RECTANGLE_VALUE,
    LINE_VALUE,
    ELLIPSE_VALUE,
    POLYGON_VALUE,
    STAR_VALUE,
    TEXTSHAPE_VALUE
];


const SHAPE_TYPES =
[
    ...SHAPE_VALUES,

    ...RECTANGLE_TYPES,
    ...LINE_TYPES,
    ...ELLIPSE_TYPES,
    ...POLYGON_TYPES,
    ...STAR_TYPES,
    ...TEXTSHAPE_TYPES
];


// const ALL_TYPES =
// [
//     ...FLOW_TYPES,
//     ...NUMBER_TYPES,
//     ...TEXT_TYPES,
//     ...COLOR_TYPES,
//     ...FILL_TYPES,
//     ...STROKE_TYPES,
//     ...GRADIENT_TYPES,
//     COLOR_STYLE,
//     ...SHAPE_TYPES
// ];


const GROUP_NODE    = 'GROUP';
const GROUP_PARAM   = 'GPARAM';


const GROUP_TYPES =
[
    GROUP_NODE,
    GROUP_PARAM
];


const COMMENT       = 'CMNT';


const ACTIVE        = 'ACT';
const BEFORE_ACTIVE = 'BEF';
const DISABLED      = 'DIS';
const NOCACHE       = 'NOC';
 
const PARAM         = 'PARAM'; // nodeId paramId
 

const LOG           = 'LOG';


const GRAPH         = 'GRAPH';


const MATH_OPS = 
[   // the order is important for logical keyboard value changes
    [NUMBER_SUBTRACT, '' ],
    [NUMBER_ADD,      '+' ],
    [NUMBER_MODULO,   '%' ],
    [NUMBER_DIVIDE,   '/' ], //'' ],
    [NUMBER_MULTIPLY, '' ],
    [NUMBER_EXPONENT, 'e<sup>x</sup>'] 
];



const BOOLEAN_NOT = 0;
const BOOLEAN_AND = 1;
const BOOLEAN_OR  = 2;
const BOOLEAN_XOR = 3;


const BOOLEAN_OPS = 
[   
    [BOOLEAN_NOT, 'not'],
    [BOOLEAN_XOR, 'xor'], 
    [BOOLEAN_OR,  'or' ],
    [BOOLEAN_AND, 'and']
];



const CONDITION_LESS             = 0;
const CONDITION_LESS_OR_EQUAL    = 1;
const CONDITION_NOT_EQUAL        = 2;
const CONDITION_EQUAL            = 3;
const CONDITION_GREATER_OR_EQUAL = 4;
const CONDITION_GREATER          = 5;


const CONDITION_OPS = 
[   
    [CONDITION_LESS,             '<'],
    [CONDITION_LESS_OR_EQUAL,    ''],
    [CONDITION_NOT_EQUAL,        ''],
    [CONDITION_EQUAL,            '='],
    [CONDITION_GREATER_OR_EQUAL, ''],
    [CONDITION_GREATER,          '>']
];



const EMPTY_ACTION               = 'EMPTY';
const CONNECT_ACTION             = 'CONNECT';
const CREATE_ACTION              = 'CREATE';
const CREATE_INSERT_ACTION       = 'CREATE_INSERT';
const DELETE_ACTION              = 'DELETE';
const DISCONNECT_ACTION          = 'DISCONNECT';
const LINK_STYLE_ACTION          = 'LINK_STYLE';
const MAKE_ACTIVE_ACTION         = 'MAKE_ACTIVE';
const PASTE_ACTION               = 'PASTE';
const RECONNECT_ACTION           = 'RECONNECT';
const REMOVE_ACTION              = 'REMOVE';
const RENAME_ACTION              = 'RENAME';
const REORDER_INPUTS_ACTION      = 'REORDER_INPUTS';
const REORDER_CONNECTIONS_ACTION = 'REORDER_CONNECTIONS';
const SELECT_ACTION              = 'SELECT';
const SELECT_MOVE_ACTION         = 'SELECT_MOVE';
const SET_PARAM_VALUE_ACTION     = 'SET_PARAM_VALUE';
const SET_PARAM_SETTING_ACTION   = 'SET_PARAM_SETTING';
const SET_NODE_RECT_ACTION       = 'SET_NODE_RECT';
const TOGGLE_DISABLE_ACTION      = 'TOGGLE_DISABLE';
const TOGGLE_SYMBOL_ACTION       = 'TOGGLE_SYMBOL';
const TOGGLE_PARAM_HEADER_ACTION = 'TOGGLE_PARAM_HEADER';
const SET_CURRENT_GRAPH_ACTION   = 'SET_CURRENT_GRAPH';



const BLEND_NORMAL      = 'BNORM';
const BLEND_DARKEN      = 'BDARK';
const BLEND_MULTIPLY    = 'BMULT';
const BLEND_COLOR_BURN  = 'BBURN';
const BLEND_LIGNTEN     = 'BLITE';
const BLEND_SCREEN      = 'BSCRN';
const BLEND_COLOR_DODGE = 'BDODG';
const BLEND_OVERLAY     = 'BOVER';
const BLEND_SOFT_LIGHT  = 'BSOFT';
const BLEND_HARD_LIGHT  = 'BHARD';
const BLEND_DIFFERENCE  = 'BDIFF';
const BLEND_EXCLUSION   = 'BEXCL';
const BLEND_HUE         = 'BHUE';
const BLEND_SATURATION  = 'BSAT';
const BLEND_COLOR       = 'BCOL';
const BLEND_LUMINOSITY  = 'BLUM';


const BlendModes =
[
    [BLEND_NORMAL,      'normal'     ],
    [BLEND_DARKEN,      'darken'     ],
    [BLEND_MULTIPLY,    'multiply'   ],
    [BLEND_COLOR_BURN,  'color burn' ],
    [BLEND_LIGNTEN,     'lighten'    ],
    [BLEND_SCREEN,      'screen'     ],
    [BLEND_COLOR_DODGE, 'color dodge'],
    [BLEND_OVERLAY,     'overlay'    ],
    [BLEND_SOFT_LIGHT,  'soft light' ],
    [BLEND_HARD_LIGHT,  'hard light' ],
    [BLEND_DIFFERENCE,  'difference' ],
    [BLEND_EXCLUSION,   'exclusion'  ],
    [BLEND_HUE,         'hue'        ],
    [BLEND_SATURATION,  'saturation' ],
    [BLEND_COLOR,       'color'      ],
    [BLEND_LUMINOSITY,  'luminosity' ]
];


class FigmaObject
{
    type;
    nodeId = '';


    constructor(type, nodeId)
    {
        this.type   = type;
        this.nodeId = nodeId;
    }



    copyBase(base)
    {
        this.fills            = clone(base.fills);
        this.stroks           = clone(base.strokes);
    
        this.strokeWeight     = base.strokeWeight;
        this.strokeFit        = base.strokeFit;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
    }
}


class FigmaShape
extends FigmaObject
{
    objectId = -1;

    fills    = [];
    strokes  = [];

    strokeWeight;
    strokeFit;
    strokeJoin;
    strokeMiterLimit;



    constructor(type, nodeId, objectId)
    {
        super(type, nodeId);

        this.objectId = objectId;
    }



    copyBase(base)
    {
        this.fills            = clone(base.fills);
        this.strokes          = clone(base.strokes);

        this.strokeWeight     = base.strokeWeight;
        this.strokeFit        = base.strokeFit;
        this.strokeJoin       = base.strokeJoin;
        this.strokeMiterLimit = base.strokeMiterLimit;
    }
}


class FigmaRectangle
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId, objectId, x, y, width, height, angle, round)
    {
        super(RECTANGLE, nodeId, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
    }



    copy()
    {
        const copy = new FigmaRectangle(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaLine
extends FigmaShape
{
    x;
    y;
    width;
    angle;



    constructor(nodeId, objectId, x, y, width, angle)
    {
        super(LINE, nodeId, objectId);
        
        this.x     = x;
        this.y     = y;
        this.width = width;
        this.angle = angle;
    }



    copy()
    {
        const copy = new FigmaLine(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.angle);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaEllipse
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;



    constructor(nodeId, objectId, x, y, width, height, angle)
    {
        super(ELLIPSE, nodeId, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new FigmaEllipse(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaPolygon
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(nodeId, objectId, x, y, width, height, angle, round, corners)
    {
        super(POLYGON, nodeId, objectId);
        
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new FigmaPolygon(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round,
            this.corners);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaStar
extends FigmaShape
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(nodeId, objectId, x, y, width, height, angle, round, points, convex)
    {
        super(STAR, nodeId, objectId);
        
        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new FigmaStar(
            this.nodeId,
            this.objectId,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.round,
            this.points,
            this.convex);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaText
extends FigmaShape
{
    text;
    x;
    y;
    width;
    height;
    angle;
    font;
    style;
    size;
    alignH;
    alignV;
    lineHeight;
    letterSpacing;



    constructor(nodeId, objectId, text, x, y, width, height, angle, font, style, size, alignH, alignV, lineHeight, letterSpacing)
    {
        super(TEXTSHAPE, nodeId, objectId);
        
        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.angle         = angle;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignH        = alignH;
        this.alignV        = alignV;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;
    }



    copy()
    {
        const copy = new FigmaText(
            this.nodeId,
            this.objectId,
            this.text,
            this.x,
            this.y,
            this.width,
            this.height,
            this.angle,
            this.font,
            this.style,
            this.size,
            this.alignH,
            this.alignV,
            this.lineHeight,
            this.letterSpacing);

        copy.copyBase(this);

        return copy;
    }
}


class FigmaColorStyle
extends FigmaObject
{
    id;
    name;

    existing;



    constructor(nodeId, styleId, styleName)
    {
        super(COLOR_STYLE, nodeId);

        this.id   = styleId;
        this.name = styleName;
    }



    copy()
    {
        const copy = new FigmaColorStyle(this.nodeId, this.id, this.name);

        copy.copyBase(this);

        copy.existing = this.existing;

        return copy;
    }
}


class GNode
{
    type;

    options = {};
    data    = {}; // for type conversion info



    constructor(type, options) 
    {
        this.type    = type;
        this.options = options;
    }



    copy()
    {
        console.assert(false, 'abstract type GNode cannot be copied');
        return null;
    }



    copyBase(src)
    {
        this.options  = clone(src.options);
        this.data     = clone(src.data);
    }



    validate()
    {
        this.valid = true;
    }



    isValid() // is a valid value
    {
        return false;
    }



    toValue()
    {
        return null;
    }



    toString() 
    { 
        return this.type; 
    }
}



class GValue
extends GNode
{
    constructor(type, options) 
    {
        super(type, options);
    }



    copy()
    {
        console.assert(false, 'abstract class GValue cannot be copied');
        return null;
    }



    // eval()
    // {
    //     return this;
    // }



    toValue()
    {
        return this.copy();
    }



    toJson() 
    { 
        return this.toString(); 
    }



    toString() 
    { 
        return this.type; 
    }



    toJsCode(gen)
    {
        console.assert(false, 'invalid abstract method');
        return '';
    }



    getNaN()
    {
        console.assert(false, 'invalid abstract method');
        return null;
    }



    isCached()
    {
        return true;
    }
}



function displayValue(type, value)
{
    if (   type == NUMBER_VALUE
        && value.indexOf(',') < 0)
        return value;


    switch (type)
    {
        case    NUMBER_VALUE: return parseNumberValue   (value)[0].toDisplayString();
        case     COLOR_VALUE: return parseColorValue    (value)[0].toDisplayString();
        case      TEXT_VALUE: const val = parseTextValue(value)[0]; return val == '' ? '\'\'' : val.toDisplayString();
        case RECTANGLE_VALUE: return parseRectangleValue(value)[0].toDisplayString();
        case      LINE_VALUE: return parseLineValue     (value)[0].toDisplayString();
        case   ELLIPSE_VALUE: return parseEllipseValue  (value)[0].toDisplayString();
        case   POLYGON_VALUE: return parsePolygonValue  (value)[0].toDisplayString();
        case      STAR_VALUE: return parseStarValue     (value)[0].toDisplayString();
        case TEXTSHAPE_VALUE: return parseTextShapeValue(value)[0].toDisplayString();
        case      FILL_VALUE: return parseFillValue     (value)[0].toDisplayString();
        case    STROKE_VALUE: return parseStrokeValue   (value)[0].toDisplayString();
        case      LIST_VALUE: return parseListValue     (value)[0].toDisplayString();
    }


    console.assert(false, 'cannot display value of type \'' + type + '\'');
}



function nullFromType(type)
{
    switch (type)
    {
        case    NUMBER_VALUE: return NumberValue.NaN;
        case     COLOR_VALUE: return ColorValue.NaN;
        case      TEXT_VALUE: return new TextValue();
        case RECTANGLE_VALUE: return RectangleValue.NaN;
        case      LINE_VALUE: return      LineValue.NaN;
        case   ELLIPSE_VALUE: return   EllipseValue.NaN;
        case   POLYGON_VALUE: return   PolygonValue.NaN;
        case      STAR_VALUE: return      StarValue.NaN;
        case TEXTSHAPE_VALUE: return TextShapeValue.NaN;
        case      FILL_VALUE: return FillValue.NaN;
        case    STROKE_VALUE: return StrokeValue.NaN;
        case      LIST_VALUE: return ListValue.NaN;
    }

    console.assert(false, 'cannot determine null value from type \'' + type + '\'');
}


class GOperator
extends GNode
{
    nodeId;
    nodeName;

    valid; // has been evaluated
    topLevel;

    value;

   
    feedbackValue = null; // () => {}


    objects = []; // held by Operator because nodes like List and Repeat can also generate objects

    
    
    constructor(type, nodeId, options)
    {
        super(type, options);

        this.nodeId       = nodeId;
        this.nodeName     = options.nodeName;

        this.valid        = false;
        this.topLevel     = false;

        this.value        = null;
    }



    copyBase(base)
    {
        super.copyBase(base);
        
        this.nodeId   = base.nodeId;
        this.nodeName = base.nodeName;

        this.valid    = base.valid;
        this.topLevel = base.topLevel;

        this.copyObjects(base.objects);
    }



    copyObjects(objects)
    {
        this.objects = objects.map(o => o.copy());
    }



    paramFromId(paramId)
    {
        return this[paramId];
    }



    isCached()
    {
        return this.options.cached
            && this.valid;
    }



    async eval(parse)
    {
        // calculate and add value update here

        return this;
    }



    async evalObjects(parse)
    {

    }


    
    toValue()
    {
        return null;
    }



    // isValid()
    // {
    //     return this.valid;
    // }



    invalidate()
    {
        this.valid = false;
    }
}


class GParam
extends GOperator
{
    paramId;
    
    node;
    param;
    


    constructor(nodeId, paramId)
    {
        super(PARAM, nodeId, false);

        this.paramId = paramId;
    }



    copy()
    {
        const copy = new GParam(this.nodeId, this.paramId);

        copy.copyBase(this);

        copy.node = this.node;
    
        return copy;
    }



    async eval(parse)
    {
        this.node = parse.parsedNodes.find(v => v.nodeId == this.nodeId);
        console.assert(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');


        //this.param.feedbackValue = this.feedbackValue;

        this.node.feedbackValue = this.feedbackValue;
        await this.node.eval(parse);
        this.node.feedbackValue = null;

        this.param = this.node.paramFromId(this.paramId);


        if (isValid(this.param)) // could have been deleted from OpRepeat for example
        {
            // if (   this.feedbackValue)
            //     //&& this.param.type == NUMBER_VALUE)
            //     this.param = this.feedbackValue();

            const value = (await this.param.eval(parse)).toValue();

            //this.param.feedbackValue = null;
            return this.value = value;
        }
        else
        {
            //this.param.feedbackValue = null;
            return this.value = NullValue;
        }
    }


    
    isCached()
    {
        return super.isCached();
//            && this.node.isCached();
    }



    toValue()
    {
        return this.value;
    }



    invalidate()
    {
        super.invalidate();

        if (this.node)
            this.node.valid = false;
    }
}


class NumberValue
extends GValue
{
    value;
    decimals;



    constructor(val = Number.NaN, dec = 0)
    {
        super(NUMBER_VALUE);

        if (typeof val !== 'number')
            console.assert(false, 'NumberValue(value) is ' + typeof val + ', must be a number');


        this.value    = val;
        this.decimals = dec;
    }



    static fromString(str)
    {
        return new NumberValue(
            parseFloat(str),
            decCount(str));
    }



    copy()
    {
        const copy = new NumberValue(
            this.value, 
            this.decimals);

        copy.copyBase(this);

        return copy;
    }



    equals(num)
    {
        return num
            && this.value    == num.value
            && this.decimals == num.decimals;
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    toInteger()
    {
        return new NumberValue(Math.round(this.value));
    }



    toNumber()
    {
        return roundTo(this.value, this.decimals);
    }



    toString()
    {
        return printNum(this.value) + ',' + printNum(this.decimals); // only NumberValue can do this, other _Values have to list all members
    }



    toSimpleString()
    {
        return !isNaN(this.value)
              ? numToString(this.value, this.decimals)
              : NAN_DISPLAY; // only NumberValue can do this, other _Values have to list all members
    }



    toDisplayString()
    {
        return printNum(this.value) 
             + (!isNaN(this.decimals)
                ? subscriptNumber(this.decimals)
                : '');
    }



    toJsCode(gen)
    {
        return this.toSimpleString();
    }



    getNaN()
    {
        return NumberValue.NaN;
    }



    static NaN = Object.freeze(new NumberValue(
        Number.NaN, 
        Number.NaN));
}



const NullValue = Object.freeze(NumberValue.NaN);



function parseNumberValue(str)
{
    if (str.indexOf(',') < 0)
    {
        console.trace();
        console.assert(false, 'number value \'' + str + '\' missing \',\'');
    }

    
    const parts = str.split(',');

    const num = new NumberValue(
        parseNum(parts[0]),
        parseNum(parts[1]));

    return [num, 1];
}



function parseSimpleNumberValue(str)
{
    const num = 
        str == NAN_DISPLAY
        ? NumberValue.NaN
        : NumberValue.fromString(str);

    return [num, 1];
}


class TextValue
extends GValue
{
    value;



    constructor(val = '')
    {
        super(TEXT_VALUE);

        if (typeof val !== 'string')
        {
            console.trace();
            console.assert(false, 'TextValue(value) is ' + typeof val + ', must be a string');
        }

        this.value = val;
    }



    copy()
    {
        const copy = new TextValue(this.value);

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.value == text.value;
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.value != NAN_CHAR;
    }



    toJson()
    {
        return toUtf8(this.value);
    }



    toString()
    {
        return this.value;
    }



    toSimpleString()
    {
        return this.value;
    }



    toDisplayString()
    {
        return '\'' 
             + this.value.replaceAll('\n', '')
             + '\'';
    }



    getNaN()
    {
        return new TextValue();//TextValue.NaN;
    }



    //static NaN = Object.freeze(new TextValue(NAN_CHAR));
}



function parseTextValue(str)
{
    const text = new TextValue(fromUtf8(str));

    return [text, 1];
}


class ColorValue
extends GValue
{
    space;
    c1;
    c2;
    c3;



    constructor(space = NumberValue.NaN, 
                c1    = NumberValue.NaN, 
                c2    = NumberValue.NaN, 
                c3    = NumberValue.NaN)
    {
        super(COLOR_VALUE);

        this.space  = space.copy();
        this.c1     = c1   .copy();
        this.c2     = c2   .copy();
        this.c3     = c3   .copy();

        this.valid  = true;
    }



    static create(space, c1, c2, c3)
    {
        console.assert(typeof space == 'number', 'ColorValue.create() space must be a number');
        console.assert(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');
        console.assert(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');
        console.assert(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');

        return new ColorValue(
            new NumberValue(space),
            new NumberValue(c1   ),
            new NumberValue(c2   ),
            new NumberValue(c3   ));
    }



    static fromRgb(rgb)
    {
        return ColorValue.create(1, rgb[0], rgb[1], rgb[2]);
    }



    static fromDataColor(_color, spaceIndex = -1)
    {
        if (spaceIndex < 0)
            spaceIndex = colorSpaceIndex (_color[0]);

        const space  = colorSpace(spaceIndex);
        const factor = colorSpaceFactor(space);

        return ColorValue.create(
            spaceIndex,
            _color[1] * factor[0],
            _color[2] * factor[1],
            _color[3] * factor[2]);
    }



    copy()
    {
        const copy = new ColorValue(
            this.space.copy(), 
            this.c1   .copy(), 
            this.c2   .copy(), 
            this.c3   .copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    equals(col)
    {
        return col
            && this.space.equals(col.space)
            && this.c1   .equals(col.c1   )
            && this.c2   .equals(col.c2   )
            && this.c3   .equals(col.c3   );
    }



    async eval(parse)
    {
        return this;
    }



    toDataColor()
    {
        if (!this.isValid())
            return dataColor_NaN;

        const space = this.space.copy();

        space.value = Math.round(Math.min(Math.max(0, space.value), ColorSpaces.length-1));

        return makeDataColor(
            space,
            this.c1,
            this.c2,
            this.c3);
    }



    toRgb()
    {
        return dataColor2rgb(this.toDataColor());
    }



    toString()
    {
        return      this.space.toString()
            + ' ' + this.c1   .toString()
            + ' ' + this.c2   .toString()
            + ' ' + this.c3   .toString();
    }



    toDisplayString()
    {
        return      this.space.toDisplayString()
            + ' ' + this.c1   .toDisplayString()
            + ' ' + this.c2   .toDisplayString()
            + ' ' + this.c3   .toDisplayString();
    }



    toRgbString()
    {
        if (!this.isValid())
            return UNKNOWN_DISPLAY;

        const rgb = this.toRgb();

        return      rgb[0].toString()
            + ' ' + rgb[1].toString()
            + ' ' + rgb[2].toString();
    }



    getNaN()
    {
        return ColorValue.NaN;
    }



    static NaN = Object.freeze(new ColorValue(
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));
}



function parseColorValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const space = parseNumberValue(str[i]); i += space[1];
    const c1    = parseNumberValue(str[i]); i += c1   [1];
    const c2    = parseNumberValue(str[i]); i += c2   [1];
    const c3    = parseNumberValue(str[i]); i += c3   [1];


    return [
        new ColorValue(space[0], c1[0], c2[0], c3[0]), 
        i - iStart ];
}


class FillValue
extends GValue
{
    color;
    opacity;



    constructor(color   = ColorValue.NaN, 
                opacity = new NumberValue(100))
    {
        super(FILL_VALUE);

        this.color   = color  .copy();
        this.opacity = opacity.copy();

        this.valid   = true;
    }


    
    static create(r, g, b, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.create(1, r, g, b),
            new NumberValue(opacity));
    }



    static fromRgb(rgb, opacity)
    {
        console.assert(
            typeof opacity == 'number',
            'opacity must be a number');

        return new FillValue(
            ColorValue.fromRgb(rgb),
            new NumberValue(opacity));
    }



    copy()
    {
        const copy = new FillValue(
            this.color  .copy(),
            this.opacity.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(fill)
    {
        return fill
            && this.color  .equals(fill.color  )
            && this.opacity.equals(fill.opacity);
    }



    async eval(parse)
    {
        return this;
    }



    toRgba()
    {
        return [
            ...this.color.toRgb(),
            this.opacity.value / 100 ];
    }



    // toFigma()
    // {
    //     return [['SOLID', this.toString()]];
    // }



    toString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toString()
              + ' ' + new NumberValue(rgb[1]).toString()
              + ' ' + new NumberValue(rgb[2]).toString()
              + ' ' + this.opacity           .toString();
    }



    toDisplayString()
    {
        const rgb = scaleRgb(this.color.toRgb());

        return        new NumberValue(rgb[0]).toDisplayString()
              + ' ' + new NumberValue(rgb[1]).toDisplayString()
              + ' ' + new NumberValue(rgb[2]).toDisplayString()
              + ' ' + this.opacity           .toDisplayString();
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    getNaN()
    {
        return FillValue.NaN;
    }



    static NaN = Object.freeze(new FillValue(
        ColorValue .NaN,
        NumberValue.NaN));



    static default = Object.freeze(FillValue.create(217, 217, 217, 100));
}



function parseFillValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const r = parseNumberValue(str[i]); i += r[1];
    const g = parseNumberValue(str[i]); i += g[1];
    const b = parseNumberValue(str[i]); i += b[1];
    const a = parseNumberValue(str[i]); i += a[1];

    const color = new ColorValue(new NumberValue(1), r[0], g[0], b[0]);

    
    return [
        new FillValue(color, a[0]),
        i - iStart ];
}






// async function evalFillValue(fillValue, parse)
// {
//     await fillValue.eval(parse);

//          if ( FILL_TYPES.includes(fillValue.type)) return fill;
//     else if (COLOR_TYPES.includes(fillValue.type)) return new FillValue(fill, fillValue.data.opacity);

//     else console.assert(false, 'fill must have type');
// }


class StrokeValue
extends GValue
{
    fill;
    weight;
    fit;
    join;
    miter;



    constructor(fill   = FillValue.NaN, 
                weight = new NumberValue(1),
                fit    = new NumberValue(0),
                join   = new NumberValue(0),
                miter  = new NumberValue(28.96, 2))
    {
        if (fill.type != FILL_VALUE)
            console.assert(false, 'fill.type is ' + fill.type + ', must be FILL_VALUE');


        super(STROKE_VALUE);

        this.fill   = fill  .copy();
        this.weight = weight.copy();
        this.fit    = fit   .copy();
        this.join   = join  .copy();
        this.miter  = miter .copy();

        this.valid   = true;
    }


    
    // static create(r, g, b, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.create(1, r, g, b),
    //         new NumberValue(opacity));
    // }



    // static fromRgb(rgb, opacity)
    // {
    //     console.assert(
    //         typeof opacity == 'number',
    //         'opacity must be a number');

    //     return new FillValue(
    //         ColorValue.fromRgb(rgb),
    //         new NumberValue(opacity));
    // }



    copy()
    {
        const copy = new StrokeValue(
            this.fill  .copy(),
            this.weight.copy(),
            this.fit   .copy(),
            this.join  .copy(),
            this.miter .copy());

        copy.copyBase(this);

        return copy;
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    equals(stroke)
    {
        return stroke
            && this.fill  .equals(stroke.fill  )
            && this.weight.equals(stroke.weight)
            && this.fit   .equals(stroke.fit   )
            && this.join  .equals(stroke.join  )
            && this.miter .equals(stroke.miter );
    }



    async eval(parse)
    {
        return this;
    }



    // toFigma()
    // {
    //     let align, join;

        
    //     switch (this.fit.value)
    //     {
    //         case 0: align = 'INSIDE';  break;
    //         case 1: align = 'CENTER';  break;
    //         case 2: align = 'OUTSIDE'; break;
    //     }
        
    //     switch (this.join.value)
    //     {
    //         case 0: join = 'MITER'; break;
    //         case 1: join = 'BEVEL'; break;
    //         case 2: join = 'ROUND'; break;
    //     }

        
    //     return this.isValid()
    //         ? {
    //               strokes:          this.fill.toFigma(),
    //               strokeWeight:     this.weight.value,
    //               strokeAlign:      align,
    //               strokeJoin:       join,
    //               strokeMiterLimit: this.miter.value
    //           }
    //         : {
    //               strokes: []
    //           };
    // }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.fill  .toString()
            + ' ' + this.weight.toString()
            + ' ' + this.fit   .toString()
            + ' ' + this.join  .toString()
            + ' ' + this.miter .toString();
    }



    toDisplayString()
    {
        return      this.fill  .toDisplayString()
            + ' ' + this.weight.toDisplayString()
            + ' ' + this.fit   .toDisplayString()
            + ' ' + this.join  .toDisplayString()
            + ' ' + this.miter .toDisplayString();
    }



    getNaN()
    {
        return StrokeValue.NaN;
    }



    static NaN = Object.freeze(new StrokeValue(
        FillValue  .NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN));



    static default = Object.freeze(new StrokeValue(
        FillValue.create(0, 0, 0, 100),
        new NumberValue(1),
        new NumberValue(0),
        new NumberValue(0),
        new NumberValue(28.96)));
}



function parseStrokeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StrokeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const fill   = parseFillValue  (str, i); i += fill  [1];
    const weight = parseNumberValue(str[i]); i += weight[1];
    const fit    = parseNumberValue(str[i]); i += fit   [1];
    const join   = parseNumberValue(str[i]); i += join  [1];
    const miter  = parseNumberValue(str[i]); i += miter [1];


    return [
        new StrokeValue(fill[0], weight[0], fit[0], join[0], miter[0]),
        i - iStart ];
}



// async function evalStrokeValue(value, parse)
// {
//     const stroke = (await value.eval(parse)).copy();

//          if (STROKE_TYPES.includes(stroke.type)) return stroke;
//     else if (  FILL_TYPES.includes(stroke.type)) return new StrokeValue(stroke, value.data.weight);
//     else if ( COLOR_TYPES.includes(stroke.type)) return new StrokeValue(new FillValue(stroke), value.data.weight);

//     else console.assert(false, 'stroke must have type');
// }


class ListValue
extends GValue
{
    items;



    constructor(items = [])
    {
        super(LIST_VALUE);

        if (items)
        {
            this.items = [];
            
            for (const item of items)
                this.items.push(item.copy());
        }
    }



    copy()
    {
        const copy = new ListValue(this.items);

        copy.copyBase(this);

        return copy;
    }



    equals(list)
    {
        if (!list)                                  return false;
        if (!(list instanceof ListValue))           return false;
        if (this.items.length != list.items.length) return false;
            
        for (let i = 0; i < this.items.length; i++)
            if (!this.items[i].equals(list.items[i]))
                return false;

        return true;
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.items
            && !this.items.find(i => !i.isValid());
    }



    toValue()
    {
        return this.copy();
    }



    toJson()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toJson();
        }


        return str;
    }



    toString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toString();
        }


        return str;
    }



    toDisplayString()
    {
        if (!this.items)
            return '';


        let str = '';
        
        
        str += this.items.length;

        for (let i = 0; i < this.items.length; i++)
        {
            const item = this.items[i];

            str += ' ' + item.type + ' ';
            str += item.toDisplayString();
        }


        return str;
    }



    getNaN()
    {
        return ListValue.NaN;
    }



    static NaN = Object.freeze(new ListValue(null));
}



function parseListValue(str, i = -1)
{
    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }
        

    const iStart = i;

    const list = new ListValue();
    

    const nInputs = parseInt(str[i++]);


    for (let j = 0; j < nInputs; j++)
    {
        const type = str[i++];
        
        switch (type)
        {
            case NUMBER_VALUE: { const num    = parseNumberValue(str[i]); i += num   [1]; list.items.push(num   [0]); break; }
            case TEXT_VALUE:   { const text   = parseTextValue  (str[i]); i += text  [1]; list.items.push(text  [0]); break; }
            case COLOR_VALUE:  { const col    = parseColorValue (str, i); i += col   [1]; list.items.push(col   [0]); break; }
            case FILL_VALUE:   { const fill   = parseFillValue  (str, i); i += fill  [1]; list.items.push(fill  [0]); break; }
            case STROKE_VALUE: { const stroke = parseStrokeValue(str, i); i += stroke[1]; list.items.push(stroke[0]); break; }
            case LIST_VALUE:   { const _list  = parseListValue  (str, i); i += _list [1]; list.items.push(_list [0]); break; }
        }
    }
 

    return [
        list, 
        i - iStart];
}


/*
    This is getting closer to Figma now, so here the format changes,
    and objects hold stroke values directly, which incoming stroke values just set.
*/

class ShapeValue
extends GValue
{
    nodeId;

    props;



    constructor(type, nodeId)
    {
        super(type);

        this.nodeId = nodeId; 
    }



    copyBase(base)
    {
        this.nodeId = base.nodeId;

        this.props  = base.props.copy();
    }



    isValid()
    {
        return this.props.isValid();
    }



    // toString()
    // {
    //     return      this.fill  .toString()
    //         + ' ' + this.stroke.toString();
    // }



    // toDisplayString()
    // {
    //     return      this.fill  .toDisplayString()
    //         + ' ' + this.stroke.toDisplayString();
    // }
}



function parseShapeBaseValue(str, i, obj)
{
    const props = parseListValue(str, i); i += props[1];

    obj.props = props[0];

    return i;
}


class RectangleValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;
    round;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0))
    {
        super(RECTANGLE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(rect)
    {
        return rect
            && this.x     .equals(rect.x     )
            && this.y     .equals(rect.y     )
            && this.width .equals(rect.width )
            && this.height.equals(rect.height)
            && this.angle .equals(rect.angle )
            && this.round .equals(rect.round );
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid()
            && super.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString();
    }



    static NaN = new RectangleValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseRectangleValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [RectangleValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];
    const round  = parseNumberValue(str[i]); i += round [1];


    const rect = new RectangleValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0],
        round [0]);


    i = parseShapeBaseValue(str, i, rect);

    
    return [rect, i - iStart];
}



class LineValue
extends ShapeValue
{
    x;
    y;
    width;
    angle;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(LINE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new LineValue(
            this.nodeId,
            this.x    .copy(), 
            this.y    .copy(), 
            this.width.copy(), 
            this.angle.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(line)
    {
        return line
            && this.x     .equals(line.x    )
            && this.y     .equals(line.y    )
            && this.width .equals(line.width)
            && this.angle .equals(line.angle);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.angle .isValid()
            && super.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.angle .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.angle .toDisplayString();
    }



    static NaN = new LineValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseLineValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [LineValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x     = parseNumberValue(str[i]); i += x    [1];
    const y     = parseNumberValue(str[i]); i += y    [1];
    const width = parseNumberValue(str[i]); i += width[1];
    const angle = parseNumberValue(str[i]); i += angle[1];


    const line = new LineValue(
        '', // set node ID elsewhere
        x    [0],
        y    [0],
        width[0],
        angle[0]);


    i = parseShapeBaseValue(str, i, line);

    
    return [line, i - iStart];
}



class EllipseValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0))
    {
        super(ELLIPSE_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
    }



    copy()
    {
        const copy = new EllipseValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy());

        copy.copyBase(this);

        return copy;
    }



    equals(ellipse)
    {
        return ellipse
            && this.x     .equals(ellipse.x     )
            && this.y     .equals(ellipse.y     )
            && this.width .equals(ellipse.width )
            && this.height.equals(ellipse.height)
            && this.angle .equals(ellipse.angle );
    }



    async eval(parse)
    {
        return this;
    }
    
    
    
    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && super.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString();
    }



    static NaN = new EllipseValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseEllipseValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [EllipseValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];


    const ellipse = new EllipseValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0]);


    i = parseShapeBaseValue(str, i, ellipse);

    
    return [ellipse, i - iStart];
}



class PolygonValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;
    round;
    corners;



    constructor(nodeId,
                x       = new NumberValue(0), 
                y       = new NumberValue(0), 
                width   = new NumberValue(0), 
                height  = new NumberValue(0), 
                angle   = new NumberValue(0), 
                round   = new NumberValue(0), 
                corners = new NumberValue(0))
    {
        super(POLYGON_VALUE, nodeId);

        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.angle   = angle;
        this.round   = round;
        this.corners = corners;
    }



    copy()
    {
        const copy = new PolygonValue(
            this.nodeId,
            this.x      .copy(), 
            this.y      .copy(), 
            this.width  .copy(), 
            this.height .copy(), 
            this.angle  .copy(), 
            this.round  .copy(), 
            this.corners.copy());
    
        copy.copyBase(this);

        return copy;
    }



    equals(poly)
    {
        return poly
            && this.x      .equals(poly.x      )
            && this.y      .equals(poly.y      )
            && this.width  .equals(poly.width  )
            && this.height .equals(poly.height )
            && this.angle  .equals(poly.angle  )
            && this.round  .equals(poly.round  )
            && this.corners.equals(poly.corners);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x      .isValid()
            && this.y      .isValid()
            && this.width  .isValid()
            && this.height .isValid()
            && this.angle  .isValid()
            && this.round  .isValid()
            && this.corners.isValid()
            && super.isValid();
    }



    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x      .toString()
            + ' ' + this.y      .toString()
            + ' ' + this.width  .toString()
            + ' ' + this.height .toString()
            + ' ' + this.angle  .toString()
            + ' ' + this.round  .toString()
            + ' ' + this.corners.toString();
    }



    toDisplayString()
    {
        return      this.x      .toDisplayString()
            + ' ' + this.y      .toDisplayString()
            + ' ' + this.width  .toDisplayString()
            + ' ' + this.height .toDisplayString()
            + ' ' + this.angle  .toDisplayString()
            + ' ' + this.round  .toDisplayString()
            + ' ' + this.corners.toDisplayString();
    }



    static NaN = new PolygonValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parsePolygonValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [PolygonValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x       = parseNumberValue(str[i]); i += x      [1];
    const y       = parseNumberValue(str[i]); i += y      [1];
    const width   = parseNumberValue(str[i]); i += width  [1];
    const height  = parseNumberValue(str[i]); i += height [1];
    const angle   = parseNumberValue(str[i]); i += angle  [1];
    const round   = parseNumberValue(str[i]); i += round  [1];
    const corners = parseNumberValue(str[i]); i += corners[1];


    const poly = new PolygonValue(
        '', // set node ID elsewhere
        x      [0],
        y      [0],
        width  [0],
        height [0],
        angle  [0],
        round  [0],
        corners[0]);


    i = parseShapeBaseValue(str, i, poly);

    
    return [poly, i - iStart];
}



class StarValue
extends ShapeValue
{
    x;
    y;
    width;
    height;
    angle;
    round;
    points;
    convex;



    constructor(nodeId,
                x      = new NumberValue(0), 
                y      = new NumberValue(0), 
                width  = new NumberValue(0), 
                height = new NumberValue(0), 
                angle  = new NumberValue(0), 
                round  = new NumberValue(0), 
                points = new NumberValue(0),
                convex = new NumberValue(0))
    {
        super(STAR_VALUE, nodeId);

        this.x      = x;
        this.y      = y;
        this.width  = width;
        this.height = height;
        this.angle  = angle;
        this.round  = round;
        this.points = points;
        this.convex = convex;
    }



    copy()
    {
        const copy = new StarValue(
            this.nodeId,
            this.x     .copy(), 
            this.y     .copy(), 
            this.width .copy(), 
            this.height.copy(), 
            this.angle .copy(), 
            this.round .copy(), 
            this.points.copy(),
            this.convex.copy());

        copy.copyBase(this);

        return copy;
    }



    equals(star)
    {
        return star
            && this.x     .equals(star.x     )
            && this.y     .equals(star.y     )
            && this.width .equals(star.width )
            && this.height.equals(star.height)
            && this.angle .equals(star.angle )
            && this.round .equals(star.round )
            && this.points.equals(star.points)
            && this.convex.equals(star.convex);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid()
            && this.points.isValid()
            && this.convex.isValid()
            && super.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.x     .toString()
            + ' ' + this.y     .toString()
            + ' ' + this.width .toString()
            + ' ' + this.height.toString()
            + ' ' + this.angle .toString()
            + ' ' + this.round .toString()
            + ' ' + this.points.toString()
            + ' ' + this.convex.toString();
    }



    toDisplayString()
    {
        return      this.x     .toDisplayString()
            + ' ' + this.y     .toDisplayString()
            + ' ' + this.width .toDisplayString()
            + ' ' + this.height.toDisplayString()
            + ' ' + this.angle .toDisplayString()
            + ' ' + this.round .toDisplayString()
            + ' ' + this.points.toDisplayString()
            + ' ' + this.convex.toDisplayString();
    }



    static NaN = new StarValue(
        '',
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseStarValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [StarValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const x      = parseNumberValue(str[i]); i += x     [1];
    const y      = parseNumberValue(str[i]); i += y     [1];
    const width  = parseNumberValue(str[i]); i += width [1];
    const height = parseNumberValue(str[i]); i += height[1];
    const angle  = parseNumberValue(str[i]); i += angle [1];
    const round  = parseNumberValue(str[i]); i += round [1];
    const points = parseNumberValue(str[i]); i += points[1];
    const convex = parseNumberValue(str[i]); i += convex[1];


    const star = new StarValue(
        '', // set node ID elsewhere
        x     [0],
        y     [0],
        width [0],
        height[0],
        angle [0],
        round [0],
        points[0],
        convex[0]);


    i = parseShapeBaseValue(str, i, star);

    
    return [star, i - iStart];
}



class TextShapeValue
extends ShapeValue
{
    text;
    x;
    y;
    width;
    height;
    angle;
    font;
    style;
    size;
    alignH;
    alignV;
    lineHeight;
    letterSpacing;

    

    constructor(nodeId,
                text          = new TextValue(),
                x             = new NumberValue(0), 
                y             = new NumberValue(0), 
                width         = new NumberValue(0), 
                height        = new NumberValue(0), 
                angle         = new NumberValue(0),
                font          = new NumberValue(0),
                style         = new NumberValue(0),
                size          = new NumberValue(0),
                alignH        = new NumberValue(0),
                alignV        = new NumberValue(0),
                lineHeight    = new NumberValue(0),
                letterSpacing = new NumberValue(0))
    {
        super(TEXTSHAPE_VALUE, nodeId);

        this.text          = text;
        this.x             = x;
        this.y             = y;
        this.width         = width;
        this.height        = height;
        this.angle         = angle;
        this.font          = font;
        this.style         = style;
        this.size          = size;
        this.alignH        = alignH;
        this.alignV        = alignV;
        this.lineHeight    = lineHeight;
        this.letterSpacing = letterSpacing;
    }



    copy()
    {
        const copy = new RectangleValue(
            this.nodeId,
            this.text         .copy(),
            this.x            .copy(), 
            this.y            .copy(), 
            this.width        .copy(), 
            this.height       .copy(), 
            this.angle        .copy(),
            this.font         .copy(),
            this.style        .copy(),
            this.size         .copy(),
            this.alignH       .copy(),
            this.alignV       .copy(),
            this.lineHeight   .copy(),
            this.letterSpacing.copy()); 

        copy.copyBase(this);

        return copy;
    }



    equals(text)
    {
        return text
            && this.text         .equals(text.text         )
            && this.x            .equals(text.x            )
            && this.y            .equals(text.y            )
            && this.width        .equals(text.width        )
            && this.height       .equals(text.height       )
            && this.angle        .equals(text.angle        )
            && this.font         .equals(text.font         )
            && this.style        .equals(text.style        )
            && this.size         .equals(text.size         )
            && this.alignH       .equals(text.alignH       )
            && this.alignV       .equals(text.alignV       )
            && this.lineHeight   .equals(text.lineHeight   )
            && this.letterSpacing.equals(text.letterSpacing);
    }



    async eval(parse)
    {
        return this;
    }



    isValid()
    {
        return this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.angle        .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignH       .isValid()
            && this.alignV       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid()
            && super.isValid();
    }


    
    toValue()
    {
        return this.copy();
    }



    toString()
    {
        return      this.text         .toString()
            + ' ' + this.x            .toString()
            + ' ' + this.y            .toString()
            + ' ' + this.width        .toString()
            + ' ' + this.height       .toString()
            + ' ' + this.angle        .toString()
            + ' ' + this.font         .toString()
            + ' ' + this.style        .toString()
            + ' ' + this.size         .toString()
            + ' ' + this.alignH       .toString()
            + ' ' + this.alignV       .toString()
            + ' ' + this.lineHeight   .toString()
            + ' ' + this.letterSpacing.toString();
    }



    toDisplayString()
    {
        return      this.text         .toDisplayString()
            + ' ' + this.x            .toDisplayString()
            + ' ' + this.y            .toDisplayString()
            + ' ' + this.width        .toDisplayString()
            + ' ' + this.height       .toDisplayString()
            + ' ' + this.angle        .toDisplayString()
            + ' ' + this.font         .toDisplayString()
            + ' ' + this.style        .toDisplayString()
            + ' ' + this.size         .toDisplayString()
            + ' ' + this.alignH       .toDisplayString()
            + ' ' + this.alignV       .toDisplayString()
            + ' ' + this.lineHeight   .toDisplayString()
            + ' ' + this.letterSpacing.toDisplayString();
    }



    static NaN = new TextShapeValue(
        '',
        TextValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN,
        NumberValue.NaN);
}



function parseTextShapeValue(str, i = -1)
{
    if (   i <  0 && str    == NAN_DISPLAY
        || i >= 0 && str[i] == NAN_DISPLAY)
        return [TextShapeValue.NaN, 1];


    if (i < 0)
    {
        str = str.split(' ');
        i   = 0;
    }


    const iStart = i;

    const text          = parseTextValue  (str[i]); i += text         [1];
    const x             = parseNumberValue(str[i]); i += x            [1];
    const y             = parseNumberValue(str[i]); i += y            [1];
    const width         = parseNumberValue(str[i]); i += width        [1];
    const height        = parseNumberValue(str[i]); i += height       [1];
    const angle         = parseNumberValue(str[i]); i += angle        [1];
    const font          = parseNumberValue(str[i]); i += font         [1];
    const style         = parseNumberValue(str[i]); i += style        [1];
    const size          = parseNumberValue(str[i]); i += size         [1];
    const alignH        = parseNumberValue(str[i]); i += alignH       [1];
    const alignV        = parseNumberValue(str[i]); i += alignV       [1];
    const lineHeight    = parseNumberValue(str[i]); i += lineHeight   [1];
    const letterSpacing = parseNumberValue(str[i]); i += letterSpacing[1];


    const txts = new TextShapeValue(
        '', // set node ID elsewhere
        text         [0],
        x            [0],
        y            [0],
        width        [0],
        height       [0],
        angle        [0],
        font         [0],
        style        [0],
        size         [0],
        alignH       [0],
        alignV       [0],
        lineHeight   [0],
        letterSpacing[0]);


    i = parseShapeBaseValue(str, i, txts);

    
    return [txts, i - iStart];
}



class GList
extends GOperator
{
    inputs = [];

    value;



    constructor(nodeId, options)
    {
        super(LIST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GList(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());
        copy.value  = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        this.objects = [];


        for (let i = 0; i < this.inputs.length; i++)
        {
            await this.inputs[i].eval(parse);


            if (this.options.enabled)
            {
                for (let j = 0; j < this.inputs[i].objects.length; j++)
                {
                    const obj = this.inputs[i].objects[j].copy();

                    obj.nodeId   = this.nodeId;
                    obj.objectId = i;

                    this.objects.push(obj);
                }
            }


            const input = this.inputs[i].toValue();

            if (   input
                && this.options.enabled)            
            {
                if (input.type == LIST_VALUE)
                {
                    for (const item of input.items)
                        this.value.items.push(item);   
                }
                else
                    this.value.items.push(input);
            }
        }
    

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



class GExpandList
extends GOperator
{
    input = null;

    constructor(nodeId, options)
    {
        super(LIST_EXPAND, nodeId, options);
    }



    copy()
    {
        const copy = new GItems(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;



        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            this.value = new ListValue();

            for (const item of input.items)
            {
                this.value.items.push(item);   

                if (item.type == LIST_VALUE)
                {
                    for (const listItem of item.items)
                        this.value.items.push(listItem);
                }
            }
        }
        else
        {
            this.value = ListValue.NaN;
        }


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);



        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GItems
extends GOperator
{
    input = null;

    //item0
    //item1
    //item2
    //...



    constructor(nodeId, options)
    {
        super(ITEMS, nodeId, options);
    }



    copy()
    {
        const copy = new GItems(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        for (const key of this.keys())
        {
            if (   key.length > 4
                && key.substring(0, 4) == 'item')
                Object.assign(copy, {[key]: this[key]});
        }

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            //if (!this.input.value)
                await this.input.eval(parse);

            this.value   = this.input.toValue();
            this.objects = clone(this.input.objects);
        }
        else
        {
            this.value   = ListValue.NaN;
            this.objects = [];
        }


        if (    this.value.isValid()
            && !isEmpty(this.value.items))
        {
            for (let i = 0; i < this.value.items.length; i++)
            {
                const item = this.value.items[i];

                Object.assign(this, {['item' + i]: item});
                genPushUpdateValue(parse, this.nodeId, 'item' + i, item);
            }
        }
        else
            genPushUpdateValue(parse, this.nodeId, '', NullValue);


        for (let j = 0; j < this.objects.length; j++)
            this.objects[j].nodeId = this.nodeId;


        this.validate();

        return this;
    }



    paramFromId(paramId)
    {
        if (   paramId.length > 4
            && paramId.substring(0, 4) == 'item'
            && strIsNum(paramId.substring(4)))
            return this[paramId];

        return null;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GSelect
extends GOperator
{
    input = null;
    
    index;



    constructor(nodeId, options)
    {
        super(SELECT, nodeId, options);
    }



    copy()
    {
        const copy = new GSelect(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.index) copy.index = this.index.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let index = (await this.index.eval(parse)).toValue();
        index = new NumberValue(Math.round(index.value));


        let length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            length = input.items.length;

            index.value = Math.min(index.value, input.items.length-1);

            this.value = input.items[index.value];
        }
        else
        {
            this.value = NullValue;
        }


        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);
        genPushUpdateValue(parse, this.nodeId, 'length', new NumberValue(length));
        genPushUpdateValue(parse, this.nodeId, 'index',  index);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GListCount
extends GOperator
{
    input = null;

    value = null;



    constructor(nodeId, options)
    {
        super(LIST_COUNT, nodeId, options);
    }



    copy()
    {
        const copy = new GListCount(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.count) copy.count = this.count.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            await this.input.eval(parse);
            this.value = new NumberValue(this.input.toValue().items.length);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    // toValue()
    // {
    //     return this.value.copy();
    // }
}


class GIfElse
extends GOperator
{
    input0 = null;
    input1 = null;

    condition;



    constructor(nodeId, options)
    {
        super(IF_ELSE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GIfElse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input    ) copy.input     = this.input    .copy();
        if (this.condition) copy.condition = this.condition.copy();
        if (this.value    ) copy.value     = this.value    .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        const cond = (await this.condition.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = (await this.input0.eval(parse)).toValue();
            const val1 = (await this.input1.eval(parse)).toValue();

            this.value = cond.value != 0 ? val0 : val1;
        }
        else if (this.input0)
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            this.value = 
                cond.value != 0
                ? input0
                : input0.getNaN()
        }
        else if (this.input1)
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            this.value = 
                cond.value == 0
                ? input1
                : input1.getNaN();
        }
        else                  
            this.value = NullValue;


        genPushUpdateValue(parse, this.nodeId, 'condition', cond);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GStart
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(START, nodeId, options);
    }


    
    copy()
    {
        const copy = new GStart(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.input)
        {
            this.input = (await this.input.eval(parse)).copy();
            this.value = this.input.toValue();
        }
        else
            this.value = null;

        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value ? this.value.copy() : null;
    }
}



class GRepeat
extends GOperator
{
    input = null;

    count;



    constructor(nodeId, options)
    {
        super(REPEAT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRepeat(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();

        copy.count = this.count.copy();
        copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
            

        let count = (await this.count.eval(parse)).toValue();
        count = new NumberValue(Math.round(count.value));

       
        this.value = new ListValue();

        this.objects = [];


        if (this.input)
        {
            const nItems = 
                this.options.enabled 
                ? count.value 
                : 1;


            for (let i = 0; i < nItems; i++)
            {
                if (this.nodeId == 'graph/repeat2')                
                    console.log('this.input =', this.input);
    
                this.input.invalidate();
                await this.input.eval(parse);


                for (let j = 0; j < this.input.objects.length; j++)
                {
                    const obj = this.input.objects[j].copy();
    
                    obj.nodeId   = this.nodeId;
                    obj.objectId = i;
    
                    this.objects.push(obj);
                }
    

                const input = this.input.toValue();

                if (input)
                    this.value.items.push(input.copy());
            }
        }

        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'count', count);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



class GCache
extends GOperator
{
    input = null;



    constructor(nodeId, options)
    {
        super(CACHE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCache(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.valid)//isCached())
            return this;


        this.value = 
            this.input
            ? (await this.input.eval(parse)).toValue()
            : NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GCopy
extends GOperator
{
    input = null;

    copy;


    constructor(nodeId, options)
    {
        super(COPY, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCopy(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) copy.input = this.input.copy();
        if (this.value) copy.value = this.value.copy();
        if (this.copy)  copy.copy  = this.copy .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = this.input ? (await this.input.eval(parse)).toValue() : NullValue;
        this.copy  = this.value ? this.value.copy()                        : NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'copy',  this.copy);

        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GNumberType
extends GOperator
{
    value;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GNumber
extends GNumberType
{
    input = null;
    


    constructor(nodeId, options)
    {
        super(NUMBER, nodeId, options);
    }



    copy()
    {
        const copy = new GNumber(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.value = this.value;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        
        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = NumberValue.NaN;


        if (this.feedbackValue)
            this.value = this.feedbackValue();


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);    


        this.validate();

        return this;
    }



    isValid()
    {
        return !isNaN(this.value)
            && !isNaN(this.decimals);
    }



    isCached()
    {
        return super.isCached()
            && (!this.input || this.input.isCached());
    }
}


class GSign
extends GNumberType
{
    input = null;



    constructor(nodeId, options)
    {
        super(NUMBER_SIGN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSign(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.sign(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GAbsolute
extends GNumberType
{
    input = null;



    constructor(nodeId, options)
    {
        super(NUMBER_ABSOLUTE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAbsolute(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            if (this.options.enabled)
                this.value.value = Math.abs(this.value.value);
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GRound
extends GNumberType
{
    input = null;

    type;
    decimals;



    constructor(nodeId, options)
    {
        super(NUMBER_ROUND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRound(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.type     = this.type    .copy();
        copy.decimals = this.decimals.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new NumberValue(0);

        
        const type = (await this.type    .eval(parse)).toValue();
        const dec  = (await this.decimals.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');

            
            if (this.options.enabled)
            {
                switch (type.value)
                {
                    case 0: this.value.value = floorTo(this.value.value, dec.value); break;
                    case 1: this.value.value = roundTo(this.value.value, dec.value); break;
                    case 2: this.value.value =  ceilTo(this.value.value, dec.value); break;
                }

                this.value.decimals = dec.value;
            }
        }
        else
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'type',     type);
        genPushUpdateValue(parse, this.nodeId, 'decimals', dec );
        genPushUpdateValue(parse, this.nodeId, 'value',    this.value);


        this.validate();

        return this;
    }
}



class GLimits
extends GNumberType
{
    input = null;

    min;
    max;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLimits(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.min = this.min.copy();
        copy.max = this.max.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const min = (await this.min.eval(parse)).toValue();
        const max = (await this.max.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();
            //console.log('this.value =', this.value);

            console.assert(
                this.value.type == NUMBER_VALUE, 
                'this.value.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                this.value.value = Math.min(Math.max(
                    min.value,
                    this.value.value),
                    max.value);
            }
        }
        else
            this.value = NumberValue.NaN;


        if (this.feedbackValue)
            this.value = this.feedbackValue();


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'min',   min);
        genPushUpdateValue(parse, this.nodeId, 'max',   max);


        this.validate();

        return this;
    }



    isCached()
    {
        return super.isCached()
            && (!this.input || this.input.isCached())
            && (!this.min   || this.min  .isCached())
            && (!this.max   || this.max  .isCached());
    }
}



class GSeries
extends GNumberType
{
    start;
    step;

    current;



    constructor(nodeId, options)
    {
        super(NUMBER_SERIES, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSeries(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.start  ) copy.start   = this.start  .copy();
        if (this.step   ) copy.step    = this.step   .copy();

        if (this.current) copy.current = this.current.copy();

        return copy;
    }



    async eval(parse)
    {
        //logString('GSeries.eval()');

        if (!this.valid)
        {
            await this.start.eval(parse);
            await this.step .eval(parse);
        }


        const start = this.start.toValue();
        const step  = this.step .toValue();
    

        if (!this.valid)
            this.current = start.copy();

        
        this.value = new NumberValue(
            this.current.value,
            Math.max(start.decimals, step.decimals));

        this.current.value += step.value;


        //if (!this.valid)
        //{
            //genPushUpdateValue(parse, this.nodeId, 'value', this.value);
            genPushUpdateValue(parse, this.nodeId, 'start', start);
            genPushUpdateValue(parse, this.nodeId, 'step',  step );
        //}
        

        this.validate();

        return this;
    }
}



class GRandom
extends GNumberType
{
    seed;
    min;
    max;

    random = null;



    constructor(nodeId, options)
    {
        super(NUMBER_RANDOM, nodeId, options);
    }


    
    copy()
    {
        const copy = new GRandom(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.seed  ) copy.seed   = this.seed  .copy();
        if (this.min   ) copy.min    = this.min   .copy();
        if (this.max   ) copy.max    = this.max   .copy();

        if (this.random) copy.random = this.random.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const seed = (await this.seed.eval(parse)).toValue();
        const min  = (await this.min .eval(parse)).toValue();
        const max  = (await this.max .eval(parse)).toValue();
    

        if (!this.valid)
            this.random = new Random(seed.value);

        
        this.value = new NumberValue(
            min.value + this.random.next() * (max.value - min.value),
            Math.max(min.decimals, max.decimals));


        if (!this.valid)
        {
            //genPushUpdateValue(parse, this.nodeId, 'value', this.value);
            genPushUpdateValue(parse, this.nodeId, 'seed',  seed);
            genPushUpdateValue(parse, this.nodeId, 'min',   min );
            genPushUpdateValue(parse, this.nodeId, 'max',   max );
        }
        

        this.validate();

        return this;
    }
}



class GInterpolate
extends GNumberType
{
    input0 = null;
    input1 = null;

    amount;


    constructor(nodeId, options)
    {
        super(NUMBER_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.amount = this.amount.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const amount = (await this.amount.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const val0 = (await this.input0.eval(parse)).toValue();
            const val1 = (await this.input1.eval(parse)).toValue();

            const maxDec = Math.max(val0.decimals, val1.decimals);

            this.value = new NumberValue(
                floorTo(val0.value + amount.value * (val1.value - val0.value) / 100, maxDec),
                maxDec);
        }
        else if (this.input0)
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();

        else                  
            this.value = NumberValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);


        this.validate();

        return this;
    }
}



class GNumberToText
extends GNumberType
{
    input = null;

    format;
    digits;


    
    constructor(nodeId, options)
    {
        super(NUMBER_TO_TEXT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNumberToText(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.format = this.format.copy();
        copy.digits = this.digits.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const format = (await this.format.eval(parse)).toValue();
        const digits = (await this.digits.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            console.assert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');

                
            let str = NAN_CHAR;

            switch (format.value)
            {
                case 0: 
                    str = numToString(Math.round(input.value), digits.value, false);
                    break;

                case 1: // hex
                    str = numToString(Math.round(input.value), digits.value, true).toUpperCase();
                    break;

                case 2: // float
                    str = numToString(input.value, -digits.value);
                    break;
            }

            this.value = new TextValue(str);
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);
        genPushUpdateValue(parse, this.nodeId, 'format', format    );
        genPushUpdateValue(parse, this.nodeId, 'digits', digits    );


        this.validate();

        return this;
    }
}



class GSolve
extends GNumberType
{
    input = null;

    current;
    target;

    temp;


    
    constructor(nodeId, options)
    {
        super(NUMBER_LIMITS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSolve(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.current = this.current.copy();
        copy.target  = this.target .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        let   current = (await this.current.eval(parse)).toValue();
        const target  = (await this.target .eval(parse)).toValue();


        //console.log('this.input =', this.input);
        if (   this.input
            && current.isValid()
            && target .isValid())
        {
            let input = (await this.input.eval(parse)).toValue();

            console.assert(
                input.type == NUMBER_VALUE, 
                'input.type must be NUMBER_VALUE');


            if (this.options.enabled)
            {
                const diffStart = target.value - current.value;
                let   diff      = diffStart;
                let   prevDiff  = diffStart;

                // console.log('diffStart =', diffStart);
                // console.log('diff =', diff);
                // console.log('prevDiff =', prevDiff);

                let   start     = input.copy();
                let   step      = Number.MAX_SAFE_INTEGER;


                const maxIter = 1000;
                let   iter    = 0;
                

                genInitNodeProgress(this.nodeId);


                this.temp = new NumberValue(Number.MIN_SAFE_INTEGER);


                while (iter++ < maxIter)
                {
                    this.temp.value += step;
                    // console.log('this.temp.value =', this.temp.value);
                    //console.log('diff =', step);
                    console.log('step =', step);

                    this.input.feedbackValue = this.getFeedbackValue;
                    this.input.valid = false;

                    // if (this.input.type == PARAM)
                    //     this.input.node.valid = false;
                        
                    current = (await this.current.eval(parse)).toValue();

                    this.input.feedbackValue = null;


                    diff = target.value - current.value;

                    if (   /*Math.abs(diff) < 0.0000001
                        && */Math.abs(step) < 0.0000001)
                        break;
                        

                    if (   Math.abs (diff) >  Math.abs (prevDiff)
                        || Math.sign(diff) != Math.sign(prevDiff))
                        step /= -2;

                    prevDiff = diff;


                    genUpdateNodeProgress(this.nodeId, iter / maxIter);
                }


                if (iter < maxIter)
                {
                    input = (await this.input.eval(parse)).toValue();
                    this.value = input;
                }
                else
                {
                    this.value = NumberValue.NaN;
                    genPushUpdateValue(parse, this.input.nodeId, 'value', start);
                    console.log('max solve iterations');
                }
            }
            else
                this.value = input;
        }
        else
        {
            if (this.input) 
                await this.input.eval(parse);

            this.value = NumberValue.NaN;
        }

        
        // TODO push good result value to input 

        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
        genPushUpdateValue(parse, this.nodeId, 'current', current   );
        genPushUpdateValue(parse, this.nodeId, 'target',  target    );


        this.validate();

        return this;
    }



    getFeedbackValue = () => this.temp.copy();



    isCached()
    {
        return super.isCached()
            && this.current.isCached()
            && this.target .isCached();
    }
}



class GAnimate
extends GNumberType
{
    from;
    to;
    curve;
    type;
    length;
    time;



    constructor(nodeId, options)
    {
        super(NUMBER_ANIMATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnimate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.from  ) copy.from   = this.from  .copy();
        if (this.to    ) copy.to     = this.to    .copy();
        if (this.curve ) copy.curve  = this.curve .copy();
        if (this.type  ) copy.type   = this.type  .copy();
        if (this.length) copy.length = this.length.copy();
        if (this.time  ) copy.time   = this.time  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const from   = (await this.from  .eval(parse)).toValue();
        const to     = (await this.to    .eval(parse)).toValue();
        const curve  = (await this.curve .eval(parse)).toValue();
        const type   = (await this.type  .eval(parse)).toValue();
        const length = (await this.length.eval(parse)).toValue();
        const time   = (await this.time  .eval(parse)).toValue();
    

        const maxDec = Math.max(from.decimals, to.decimals);

        switch (curve.value)
        {
            case 0: 
            {
                this.value = new NumberValue(
                    time.value < length.value ? from.value : to.value, 
                    maxDec);
    
                break;
            }
            case 1: 
            {
                this.value = new NumberValue(
                    from.value + (to.value - from.value) * time.value / length.value,
                    maxDec);
    
                break;
            }
            case 2: 
            {
                let f = time.value / length.value;

                f = 1 - sqr(1 - f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 3: 
            {
                let f = time.value / length.value;

                f = sqr(f);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
            case 4: 
            {
                let f = time.value / length.value;

                f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);

                this.value = new NumberValue(
                    from.value + (to.value - from.value) * f,
                    maxDec);
    
                break;
            }
        }
        
        

        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);
        genPushUpdateValue(parse, this.nodeId, 'from',   from      );
        genPushUpdateValue(parse, this.nodeId, 'to',     to        );
        genPushUpdateValue(parse, this.nodeId, 'curve',  curve     );
        genPushUpdateValue(parse, this.nodeId, 'type',   type      );
        genPushUpdateValue(parse, this.nodeId, 'length', length    );
        genPushUpdateValue(parse, this.nodeId, 'time',   time      );
        

        this.validate();

        return this;
    }
}



class GArithmetic
extends GNumberType
{
    inputs = [];



    isCached()
    {
        for (const input of this.inputs)
            if (!input.isCached())
                return false;

        return super.isCached();
    }
}



class GMath
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_MATH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GMath(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), MATH_OPS.length-1);

        switch (op.value)
        {
            case 0: this.value = await evalSubtractInputs(this.inputs, parse); break;
            case 1: this.value = await evalAddInputs     (this.inputs, parse); break;
            case 2: this.value = await evalModuloInputs  (this.inputs, parse); break;
            case 3: this.value = await evalDivideInputs  (this.inputs, parse); break;
            case 4: this.value = await evalMultiplyInputs(this.inputs, parse); break;
            case 5: this.value = await evalExponentInputs(this.inputs, parse); break;
        }

        
        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);



        this.validate();

        return this;
    }
}



class GAdd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_ADD, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAdd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalAddInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalAddInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        console.assert(
            val.type == NUMBER_VALUE, 
            'val.type must be NUMBER_VALUE');

        value.value   += val.value;
        value.decimals = Math.max(value.decimals, val.decimals);
    }


    return value;
}


class GSubtract
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_SUBTRACT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GSubtract(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalSubtractInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalSubtractInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value   -= val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GMultiply
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MULTIPLY, nodeId, options);
    }



    copy()
    {
        const copy = new GMultiply(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }

    

    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalMultiplyInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalMultiplyInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        value.value = 1;

        for (let i = 0; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            value.value   *= val.value;
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GDivide
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_DIVIDE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GDivide(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalDivideInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalDivideInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.value == 0) 
            { 
                value.value    = Number.NaN; 
                value.decimals = 0;
                break; 
            }

            value.decimals = Math.max(value.decimals, val.decimals);
            value.value    = floorTo(value.value / val.value, value.decimals);
        }
    }


    return value;
}


class GModulo
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_MODULO, nodeId, options);
    }


    
    copy()
    {
        const copy = new GModulo(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalModuloInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalModuloInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;

        
    const value = new NumberValue(0);

        
    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.value == 0) 
            { 
                value.value    = Number.NaN; 
                value.decimals = 0;
                break; 
            }

            value.decimals = Math.max(value.decimals, val.decimals);
            value.value    = floorTo(value.value % val.value, value.decimals);
        }
    }


    return value;
}


class GExponent
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_EXPONENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GExponent(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalExponentInputs(this.inputs, parse);

        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalExponentInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue(0);


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();

        value.value    = val0.value;
        value.decimals = val0.decimals;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value    = Math.pow(value.value,    val.value);
            value.decimals = Math.max(value.decimals, val.decimals);
        }
    }


    return value;
}


class GBoolean
extends GArithmetic
{
    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_BOOLEAN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GBoolean(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());
        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), BOOLEAN_OPS.length-1);

        
        switch (op.value)
        {
            case BOOLEAN_NOT: this.value = await evalNandInputs(this.inputs, parse); break;
            case BOOLEAN_AND: this.value = await evalAndInputs (this.inputs, parse); break;
            case BOOLEAN_OR:  this.value = await evalOrInputs  (this.inputs, parse); break;
            case BOOLEAN_XOR: this.value = await evalXorInputs (this.inputs, parse); break;
        }

        
        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);


        this.validate();

        return this;
    }
}


class GNot
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNot(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalNandInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalNandInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber() != 0 ? 0 : 1;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');

            if (val.toNumber() == 0)
                value.value = 1;
        }
    }


    return value;
}



class GAnd
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_AND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GAnd(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalAndInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalAndInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber();


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = Math.min(value.value, val.toNumber());
        }

        
        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GOr
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_OR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GOr(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalOrInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalOrInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        value.value = val0.toNumber();


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            value.value = Math.max(value.value, val.toNumber());
        }


        if (value.value != 0)
            value.value = 1;
    }


    return value;
}


class GXor
extends GArithmetic
{
    constructor(nodeId, options)
    {
        super(NUMBER_XOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GXor(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalXorInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



async function evalXorInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return NumberValue.NaN;


    const value = new NumberValue();


    let flipped;

    if (!isEmpty(inputs))
    {
        const val0 = (await inputs[0].eval(parse)).toValue();
        if (!val0.isValid()) return NumberValue.NaN;

        flipped = val0.toNumber() != 0;


        for (let i = 1; i < inputs.length; i++)
        {
            const val = (await inputs[i].eval(parse)).toValue();
            if (!val.isValid()) return NumberValue.NaN;

            console.assert(
                val.type == NUMBER_VALUE, 
                'val.type must be NUMBER_VALUE');
                
            if (val.toNumber() != 0)
                flipped++;
        }


        value.value = flipped == 1 ? 1 : 0;
    }


    return value;
}


class GConditionBase
extends GNumberType
{
    input0 = null;
    input1 = null;
}



async function evalConditionInputs(input0, input1, op, parse) 
{
    const val0 = input0 ? (await input0.eval(parse)).toValue() : NumberValue.NaN;
    const val1 = input1 ? (await input1.eval(parse)).toValue() : NumberValue.NaN;

    if (   val0.isValid() 
        && val1.isValid())
        return new NumberValue(op(val0.toNumber(), val1.toNumber()) ? 1 : 0);
    else                  
        return NumberValue.NaN;
}


class GCondition
extends GNumberType
{
    input0 = null;
    input1 = null;

    operation;



    constructor(nodeId, options)
    {
        super(NUMBER_CONDITION, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCondition(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.operation = this.operation.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const op = (await this.operation.eval(parse)).toValue().toInteger();

        op.value = Math.min(Math.max(0, op.value), CONDITION_OPS.length-1);

        
        switch (op.value)
        {
            case CONDITION_LESS:              this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a <  b), parse);  break;
            case CONDITION_LESS_OR_EQUAL:     this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a <= b), parse);  break;
            case CONDITION_NOT_EQUAL:         this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a != b), parse);  break;
            case CONDITION_EQUAL:             this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a == b), parse);  break;
            case CONDITION_GREATER_OR_EQUAL:  this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a >= b), parse);  break;
            case CONDITION_GREATER:           this.value = await evalConditionInputs(this.input0, this.input1, ((a, b) => a >  b), parse);  break;
        }


        genPushUpdateValue(parse, this.nodeId, 'operation', op);
        genPushUpdateValue(parse, this.nodeId, 'value',     this.value);


        this.validate();

        return this;
    }
}


class GEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a == b, 
            parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GNotEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_NOT_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GNotEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a != b, 
            parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GLess
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLess(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            this.value = await evalConditionInputs(
                this.input0, 
                this.input1, 
                (a, b) => a < b, 
                parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GLessOrEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_LESS_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GLessOrEqual(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            this.value = await evalConditionInputs(
                this.input0, 
                this.input1, 
                (a, b) => a <= b, 
                parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GGreater
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreater(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a > b, 
            parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}


class GGreaterOrEqual
extends GConditionBase
{
    constructor(nodeId, options)
    {
        super(NUMBER_GREATER_OR_EQUAL, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGreaterOrEqual(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs = this.inputs.map(i => i.copy());

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        this.value = await evalConditionInputs(
            this.input0, 
            this.input1, 
            (a, b) => a >= b, 
            parse);
            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        this.validate();

        return this;
    }
}



class GTextType
extends GOperator
{
    value = null;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GText
extends GTextType
{
    input = null;
    


    constructor(nodeId, options)
    {
        super(TEXT, nodeId, options);
    }



    copy()
    {
        const copy = new GText(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.value = this.value;
        
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
            this.value = (await this.input.eval(parse)).toValue();
        else if (this.value)
            await this.value.eval(parse);
        else
            this.value = new TextValue();//TextValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        
        this.validate();

        return this;
    }



    isValid()
    {
        return this.value != NAN_CHAR;
    }
}


class GTextSubstring
extends GTextType
{
    input = null;

    start;
    end;


    
    constructor(nodeId, options)
    {
        super(TEXT_SUBSTRING, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextSubstring(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.start = this.start.copy();
        copy.end   = this.end  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const start = (await this.start.eval(parse)).toValue();
        const end   = (await this.end  .eval(parse)).toValue();

        let   length = 0;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            
            length = input.value.length;
            
            this.value = input.copy();
            
            console.assert(
                this.value.type == TEXT_VALUE, 
                'this.value.type must be TEXT_VALUE');
                
                
            if(start.value <= end.value)
            {
                if (this.options.enabled)
                    this.value.value = this.value.value.substring(start.value, end.value);
            }
            else
                this.value = new TextValue();//TextValue.NaN;
        }
        else
            this.value = new TextValue();//TextValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'length', new NumberValue(length)); // used to set start and end maxima
        genPushUpdateValue(parse, this.nodeId, 'start',  start);
        genPushUpdateValue(parse, this.nodeId, 'end',    end);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GTextCharacter
extends GTextType
{
    input = null;

    code;


    
    constructor(nodeId, options)
    {
        super(TEXT_CHAR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCharacter(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.code = this.code.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const code = (await this.code.eval(parse)).toValue();


        this.value = new TextValue(String.fromCharCode(code.value));


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        genPushUpdateValue(parse, this.nodeId, 'code',  code);


        this.validate();

        return this;
    }
}



class GTextReplace
extends GTextType
{
    input = null;

    what;
    with;



    constructor(nodeId, options)
    {
        super(TEXT_REPLACE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextReplace(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.what  = this.what .copy();
        copy.with  = this.with .copy();

        copy.value = this.value.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const _what = (await this.what.eval(parse)).toValue();
        const _with = (await this.with.eval(parse)).toValue();


        if (this.input)
        {
            this.value = (await this.input.eval(parse)).toValue();

            console.assert(
                this.value.type == TEXT_VALUE, 
                'this.value.type must be TEXT_VALUE');

            this.value.value = this.value.value.replaceAll(
                _what.value,
                _with.value);
        }
        else
            this.value = new TextValue();//TextValue.NaN;

            
        genPushUpdateValue(parse, this.nodeId, 'what',  _what);
        genPushUpdateValue(parse, this.nodeId, 'with',  _with);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);

        
        this.validate();

        return this;
    }
}



class GTextJoin
extends GTextType
{
    inputs = [];


    
    constructor(nodeId, options)
    {
        super(TEXT_JOIN, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextJoin(this.nodeId, this.options);
        copy.copyBase(this);
        copy.inputs = this.inputs.map(i => i.copy());
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = await evalJoinInputs(this.inputs, parse);
        
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



async function evalJoinInputs(inputs, parse)
{
    if (isEmpty(inputs))
        return new TextValue();//TextValue.NaN;


    const value = new TextValue();


    for (let i = 0; i < inputs.length; i++)
    {
        const val = (await inputs[i].eval(parse)).toValue();

        console.assert(
            val.type == TEXT_VALUE, 
            'val.type must be TEXT_VALUE');

        value.value += val.value;
    }


    return value;
}


class GTextCSV
extends GOperator
{
    inputs = [];

    value;
    separator;



    constructor(nodeId, options)
    {
        super(TEXT_CSV, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextCSV(this.nodeId, this.options);

        copy.copyBase(this);

        copy.inputs    = this.inputs.map(i => i.copy());

        copy.value     = this.value    .copy();
        copy.separator = this.separator.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = new ListValue();

        // for (let i = 0; i < this.inputs.length; i++)
        // {
        //     const input = (await this.inputs[i].eval(parse)).toValue();

        //     if (input.type == LIST_VALUE)
        //     {
        //         for (const item of input.items)
        //             this.value.items.push(item);   
        //     }
        //     else
        //         this.value.items.push(input);
        // }
    

        genPushUpdateValue(parse, this.nodeId, 'value',     this.value    );
        genPushUpdateValue(parse, this.nodeId, 'separator', this.separator);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}



//var fetchResolve = null;
//fetchResponse = null;



class GTextFetch
extends GTextType
{
    input = null;

    request;



    constructor(nodeId, options)
    {
        super(TEXT_FETCH, nodeId, options);
    }


    
    copy()
    {
        const copy = new GTextFetch(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.request = this.request.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const request = (await this.request.eval(parse)).toValue();


        genInitNodeProgress(this.nodeId);


        try 
        {
            await fetch(request.value)
                .then(response => response.text())
                .then(text => this.value = new TextValue(text));
        }
        catch (e)
        {
            this.value = 
                request.value.trim() == NULL
                ? new TextValue() //TextValue.NaN
                : new TextValue(e.message);
        }


        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
        genPushUpdateValue(parse, this.nodeId, 'request', request   );

        
        this.validate();

        return this;
    }
}



// function genFetchResponse(result, response)
// {
//     console.assert(fetchResolve, 'fetchResolve cannot be null');
//     fetchResolve(response);
//     console.log('resolve');
// }


class ColorCorrection
{
    name; // 'H', 'C', or 'L'
    max;
    value;
    
    constructor(name = '', max = 0, value = 0)//, locked = false)
    {
        this.name  = name;
        this.max   = max;
        this.value = value;
    }
}



function findCorrection(nodeId,
                        color,
                        order,       margin1, margin2, margin3,
                        lockedOrder, locked1, locked2, locked3) 
{
    const refOklab = dataColor2array(dataColor2oklab(color));

    
    let closestColor = [...color],
        closestOklab = null, 
        closestOrder = order ? order.value : -1,
        closest1     = -1,
        closest2     = -1,
        closest3     = -1;


    let progress = 0,
        total    = 6 * Math.pow(2, Tau);


    let d = 1;

    //dLoop:
    while (d > 1/1024)
    {
        //if (stopGenerate) break dLoop;

        let _closestColor = [...closestColor];


        for (let _order = 0; _order < 6; _order++)
        {
            //if (stopGenerate) break dLoop;

            closestColor = [..._closestColor];

            const [min1, min2, min3] = getMinCorrections(color[0], _order);
            const [max1, max2, max3] = getMaxCorrections(color[0], _order);

            let start1 = lerp(min1, closest1, 1-d),  end1 = lerp(max1, closest1, 1-d),
                start2 = lerp(min2, closest2, 1-d),  end2 = lerp(max2, closest2, 1-d),
                start3 = lerp(min3, closest3, 1-d),  end3 = lerp(max3, closest3, 1-d);
               
                
            if (locked1) { closest1 = margin1.toNumber(); start1 = closest1; end1 = closest1+Epsilon; }
            if (locked2) { closest2 = margin2.toNumber(); start2 = closest2; end2 = closest2+Epsilon; }
            if (locked3) { closest3 = margin3.toNumber(); start3 = closest3; end3 = closest3+Epsilon; }
            

          [ closestColor,
            closestOklab,
            closestOrder,
            closest1,
            closest2,
            closest3,
            progress ] = findCorrectionInOrder(
                nodeId,
                refOklab,
                _order, 
                lockedOrder, 
                locked1,  locked2,  locked3,
                closest1, closest2, closest3,
                start1,   start2,   start3, 
                end1,     end2,     end3,
                [...closestColor],
                closestOklab, 
                closestOrder,
                progress,
                total);
        }

        
        d /= 2;
    }


    //if (!stopGenerate)
    //{
        // reduce closest to necessary minimums

        const closestRgb = getCorrectedColor(color, closestOrder, closest1, closest2, closest3)[2];

        let c1 = closest1;
        let c2 = closest2;
        let c3 = closest3;

        while (c1 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, c1-1, closest2, closest3)[2], closestRgb)) c1--;
        while (c2 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, c2-1, closest3)[2], closestRgb)) c2--;
        while (c3 >= 0 && rgbEqual(getCorrectedColor(color, closestOrder, closest1, closest2, c3-1)[2], closestRgb)) c3--;

        closest1 = Math.max(0, c1);
        closest2 = Math.max(0, c2);
        closest3 = Math.max(0, c3);
    //}

    
    //stopGenerate = false;


    return [
        closestOrder,
        closest1,
        closest2,
        closest3 ];
}



function findCorrectionInOrder(nodeId,
                               refOklab,
                               order, 
                               lockedOrder, 
                               locked1,  locked2,  locked3,
                               closest1, closest2, closest3,
                               start1,   start2,   start3, 
                               end1,     end2,     end3,
                               closestColor,
                               closestOklab,
                               closestOrder,
                               progress,
                               total)
{
    const color = [...closestColor];
    
    let nSteps1 = locked1 ? 1 : 2;
    let nSteps2 = locked2 ? 1 : 2;
    let nSteps3 = locked3 ? 1 : 2;


    cLoop:
    for (let m1 = start1; m1 < end1; m1 += (end1-start1)/nSteps1)
    {
        //if (stopGenerate) break cLoop;

        for (let m2 = start2; m2 < end2; m2 += (end2-start2)/nSteps2)
        {
            //if (stopGenerate) break cLoop;

            for (let m3 = start3; m3 < end3; m3 += (end3-start3)/nSteps3)
            {
                //if (stopGenerate) break cLoop;

                const [_color, _oklab, _rgb] = getCorrectedColor(color, order, m1, m2, m3);

                if (   rgbIsOk(_rgb)
                    && (  !closestOklab
                        || rgbDistance(refOklab, _oklab) < rgbDistance(refOklab, closestOklab)))
                {
                    closestColor = _color;
                    closestOklab = _oklab;
                    
                    if (!lockedOrder)
                        closestOrder = order;

                    closest1     = m1;
                    closest2     = m2;
                    closest3     = m3;
                }

                progress++;
            }
        }

        
        //if (!stopGenerate)
            genUpdateNodeProgress(nodeId, progress / total);
    }

    
    return [
        closestColor,
        closestOklab,
        closestOrder,
        closest1,
        closest2,
        closest3,
        progress ];
}



function getCorrectedColor(color, order, m1, m2, m3)
{
    const _color = correctColor(color, order, m1, m2, m3);
    const oklab  = dataColor2array(dataColor2oklab(_color));
    const rgb    = oklab2rgb(oklab);

    return [_color, oklab, rgb];
}



function correctColor(color, order, margin1, margin2, margin3)
{
    if (order < 0)
        return color;


    const [i1, i2, i3] = getCorrectionsInOrder(order);

                               color = correctChannel(color, i1, margin1);
    if (!dataColorIsOk(color)) color = correctChannel(color, i2, margin2);
    if (!dataColorIsOk(color)) color = correctChannel(color, i3, margin3);


    // clip colors that are reasonably valid but stick over the fence
    
    let rgb = dataColor2rgb(color);

    if (rgbIsOk(rgb))
        rgb = invalid2validRgb(rgb);
    
        
    color = convertDataColorToSpace(
        rgb2dataColor(rgb),
        color[0]);

        
    return color;
}



function correctChannel(color, iChan, margin)
{
    const factor = colorSpaceFactor(color[0]);

    margin /= factor[iChan];


    const savedColor = [...color];
    const savedValue = color[iChan+1];

    const d = 0.001;


    let _c  = savedValue,
         c_ = savedValue;

    let _valid  = dataColorIsOk(color);
    let  valid_ = _valid;


    let stackOverflowProtect = 1/d;


    while (   !_valid
           && ! valid_
           && stackOverflowProtect-- > 0)
    {
        _c  -= d;  _valid  = isColorOk(_c , iChan, savedColor);
         c_ += d;   valid_ = isColorOk( c_, iChan, savedColor);
    }


    stackOverflowProtect = 1/d;
    color = [...savedColor];


    if (_valid) 
    { 
        _valid = dataColorIsOk(color);
        _c     = savedValue;

        while (   !_valid
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            _c -= d; 
            _valid = isColorOk(_c, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = _c;
    }
    else if (valid_)
    { 
        valid_ = dataColorIsOk(color);
        c_     = savedValue;

        while (   !valid_
               && margin > 0
               && stackOverflowProtect-- > 0)
        {
            c_ += d; 
            valid_ = isColorOk(c_, iChan, savedColor);
            margin -= d;
        }

        color[iChan+1] = c_;
    }


    return color;
}



function isColorOk(c, iChan, savedColor)
{
    let color = [...savedColor];
    color[iChan+1] = c; 
    return dataColorIsOk(color);
}



function getCorrectionsInOrder(order)
{
    switch (order)
    {
        case 0: return [0, 1, 2];
        case 1: return [1, 0, 2];
        case 2: return [1, 2, 0];
        case 3: return [0, 2, 1];
        case 4: return [2, 0, 1];
        case 5: return [2, 1, 0];
    }

    // should never get here
    console.assert(false, 'invalid correction order ' + order);
    return [0, 0, 0];
}



function getMinCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let min;

    switch (space)
    {
        case 'hex':
        case 'rgb':    min = [0, 0, 0]; break

        case 'hsv': 
        case 'hsl':    min = [0, 0, 0]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': min = [0, 0, 0]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    min = [0, -oppFactor[1]/2, -oppFactor[2]/2]; break;
        
        default:
            // should never get here
            console.assert(false, 'invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [min[c1], min[c2], min[c3]];
}



function getMaxCorrections(space, order)
{
    const [c1, c2, c3] = getCorrectionsInOrder(order);

    let max;

    switch (space)
    {
        case 'hex':
        case 'rgb':    max = [...rgbFactor]; break;

        case 'hsv': 
        case 'hsl':    max = [hs_Factor[0]/2, hs_Factor[1], hs_Factor[2]]; break;

        case 'hclok':
        case 'hclab':
        case 'hcluv': max = [hclFactor[0]/2, hclFactor[1], hclFactor[2]]; break;

        case 'oklab':
        case 'lab':
        case 'luv':    max = [...oppFactor]; break;
        
        default:
            // should never get here
            console.assert(false, 'invalid validation order ' + order);
            return [0, 0, 0];
    }

    return [max[c1], max[c2], max[c3]];
}



function reorderCorrection(closestOrder,
                           closest1, closest2, closest3,
                           locked1,  locked2,  locked3)
{
    let c1 = { closest: closest1, locked: locked1 };
    let c2 = { closest: closest2, locked: locked2 };
    let c3 = { closest: closest3, locked: locked3 };

    if (   c1.closest <  Epsilon
        && c2.closest <  Epsilon
        && c3.closest >= Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 4; break;
            case 1: closestOrder = 5; break;
            case 2: closestOrder = 0; break;
            case 3: closestOrder = 1; break;
            case 4: closestOrder = 2; break;
            case 5: closestOrder = 3; break;
        }

        const tmp = c2;
        c1 = c3;
        c2 = c1;
        c3 = tmp;
    }
    else if (c1.closest >= Epsilon
          && c2.closest <  Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 3; break;
            case 1: closestOrder = 2; break;
            case 2: closestOrder = 1; break;
            case 3: closestOrder = 0; break;
            case 4: closestOrder = 5; break;
            case 5: closestOrder = 4; break;
        }

        const tmp = c2;
        c2 = c3;
        c3 = tmp;
    }
    else if (c1.closest < Epsilon)
    {
        switch (closestOrder)
        {
            case 0: closestOrder = 2; break;
            case 1: closestOrder = 3; break;
            case 2: closestOrder = 4; break;
            case 3: closestOrder = 5; break;
            case 4: closestOrder = 0; break;
            case 5: closestOrder = 1; break;
        }

        const tmp = c1;
        c1 = c2;
        c2 = c3;
        c3 = tmp;
    }


    return [
        closestOrder,
        c1.closest, c2.closest, c3.closest,
        c1.locked,  c2.locked,  c3.locked ];
}



function getColorCorrections(colorSpace)
{
    switch (colorSpace)
    {
    case 'hex':
    case 'rgb':
        return [
            new ColorCorrection('R', rgbFactor[0]),
            new ColorCorrection('G', rgbFactor[1]),
            new ColorCorrection('B', rgbFactor[2]) ];

    case 'hsv':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('V', hs_Factor[2]) ];

    case 'hsl':
        return [
            new ColorCorrection('H', hs_Factor[0]/2),
            new ColorCorrection('S', hs_Factor[1]),
            new ColorCorrection('L', hs_Factor[2]) ];

    case 'hclok':
    case 'hclab':
    case 'hcluv':
        return [
            new ColorCorrection('H', hclFactor[0]/2),
            new ColorCorrection('C', hclFactor[1]),
            new ColorCorrection('L', hclFactor[2]) ];

    case 'oklab': 
    case 'lab':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('a', oppFactor[1]),
            new ColorCorrection('b', oppFactor[2]) ];

    case 'luv':
        return [
            new ColorCorrection('L', oppFactor[0]),
            new ColorCorrection('u', oppFactor[1]),
            new ColorCorrection('v', oppFactor[2]) ];
    }


    console.assert(false, 'invalid color space ' + colorSpace);
    return [
        new ColorCorrection(),
        new ColorCorrection(),
        new ColorCorrection() ];
}


class GColorType
extends GOperator
{
    value;
    


    copyBase(src)
    {
        super.copyBase(src);

        if (src.value) this.value = src.value.copy();
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GColor
extends GColorType
{
    input   = null;

    space   = null;
    c1      = null;
    c2      = null;
    c3      = null;

    convert = null;

    hasInputs;



    constructor(nodeId, options)
    {
        super(COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.space = this.space.copy();

        if (this.c1) copy.c1 = this.c1.copy();
        if (this.c2) copy.c2 = this.c2.copy();
        if (this.c3) copy.c3 = this.c3.copy();

        if (this.convert) 
            copy.convert = this.convert.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const space = this.space ? (await this.space.eval(parse)).toValue().toInteger() : null; 
        let   c1    = this.c1    ? (await this.c1   .eval(parse)).toValue()             : null;
        let   c2    = this.c2    ? (await this.c2   .eval(parse)).toValue()             : null;
        let   c3    = this.c3    ? (await this.c3   .eval(parse)).toValue()             : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            
            if (input.isValid())
            {
                if (this.options.enabled)
                {
                    this.value = new ColorValue(
                        input.space,
                        input.c1, 
                        input.c2, 
                        input.c3);

                    const fromSpaceIndex = input.space.value;

                    const toSpaceIndex = Math.min(Math.max(
                        0,
                        Math.round(space.value)), // round because a value can come in with decimals (TODO fix this)
                        colorSpaceCount(parse)-1);


                    this.convertColor(
                        this.value,
                        colorSpace(fromSpaceIndex), 
                        colorSpace(  toSpaceIndex));

                    this.value.space.value = toSpaceIndex;


                    if (!this.c1) { this.c1 = this.value.c1.copy(); c1 = this.c1.toValue(); }
                    if (!this.c2) { this.c2 = this.value.c2.copy(); c2 = this.c2.toValue(); }
                    if (!this.c3) { this.c3 = this.value.c3.copy(); c3 = this.c3.toValue(); }
                
                    if (c1) this.value.c1 = c1;
                    if (c2) this.value.c2 = c2;
                    if (c3) this.value.c3 = c3;
                }
                else
                    this.value = input;
            }
            else
                this.value = ColorValue.NaN;


            if (!this.convert)
                this.convert = NumberValue.NaN;
        }
        else
        {
            this.value = new ColorValue(space, c1, c2, c3);


            const toSpaceIndex = Math.min(Math.max(
                0,
                Math.round(this.value.space.value)), // round because a value can come in with decimals (TODO fix this)
                colorSpaceCount(parse)-1);

            this.value.space.value = toSpaceIndex;

            if (    this.convert
                &&  this.convert.isValid()
                &&  this.convert.value > -1
                &&  this.value.isValid()
                && !this.hasInputs)
            {
                await this.convert.eval(parse);

                this.convertColor(
                    this.value,
                    colorSpace(this.convert.value), 
                    colorSpace(toSpaceIndex));
            }


            if (!this.c1) this.c1 = this.value.c1.copy();
            if (!this.c2) this.c2 = this.value.c2.copy();
            if (!this.c3) this.c3 = this.value.c3.copy();
        }


        if (!this.value.space.isValid())
            this.value = new ColorValue(
                this.space.toValue(),
                NumberValue.NaN,
                NumberValue.NaN,
                NumberValue.NaN);


        // if (this.options.enabled)
        // {
            genPushUpdateValue(parse, this.nodeId, 'convert', this.convert    );
            genPushUpdateValue(parse, this.nodeId, 'space',   this.value.space);
            genPushUpdateValue(parse, this.nodeId, 'c1',      this.value.c1   );
            genPushUpdateValue(parse, this.nodeId, 'c2',      this.value.c2   );
            genPushUpdateValue(parse, this.nodeId, 'c3',      this.value.c3   );
        // }


        this.validate();

        return this;
    }



    convertColor(color, fromSpace, toSpace)
    {
        let col = [
            fromSpace, 
            getNormalColorValue(color.c1.value, fromSpace, 0),
            getNormalColorValue(color.c2.value, fromSpace, 1),
            getNormalColorValue(color.c3.value, fromSpace, 2)];

        col = getScaledDataColor(convertDataColorToSpace(col, toSpace));

        color.c1.value = col[1];
        color.c2.value = col[2];
        color.c3.value = col[3];
    }



    isValid()
    {
        return this.space.isValid()
            && this.c1   .isValid()
            && this.c2   .isValid()
            && this.c3   .isValid();
    }



    toValue()
    {
        return this.options.enabled
             ? this.value.copy()
             : ColorValue.NaN;
    }
}


class GValidColor
extends GColorType
{
    input        = null;
     
    quality      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(VALID_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GValidColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.quality) copy.quality = this.quality.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const quality = this.quality ? (await this.quality.eval(parse)).toValue().toInteger() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                if (   !isValid(this.value) 
                    || !this.value.isValid()) 
                {
                    let rgb = input.toRgb();

                    if (quality.value == 0) // clip sRGB
                    {
                        rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);   
                        rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);   
                        rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff); 
                        
                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else if (quality.value == 1) // clip chroma
                    {
                        rgb = clipChroma(rgb);

                        rgb[0] = Math.round(rgb[0] * 0xff);   
                        rgb[1] = Math.round(rgb[1] * 0xff);   
                        rgb[2] = Math.round(rgb[2] * 0xff); 

                        this.value = ColorValue.fromRgb(rgb);
                    }
                    else // find corrections
                    {
                        if (!rgbIsOk(rgb))
                            genInitNodeProgress(this.nodeId);
                        

                        const inputColor = input.toDataColor();


                        const
                      [ closestOrder,
                        closest1,
                        closest2,
                        closest3 ] = findCorrection(
                            this.nodeId,
                            inputColor, 
                            quality, null,  null,  null, 
                            false,   false, false, false); 

                            
                        //if (!stopGenerate)
                        //{
                            if (   closestOrder >= 0 
                                && closestOrder <  6)
                            {
                                this._color = correctColor(
                                    inputColor,
                                    closestOrder,
                                    closest1,
                                    closest2,
                                    closest3);

                                this.value = ColorValue.fromDataColor(this._color);
                            }
                            else
                            {
                                this.value = ColorValue.NaN;
                            }
                        //}
                    }
                }
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;

            
        genPushUpdateValue(parse, this.nodeId, 'quality', quality);
        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);


        this.validate();

        return this;
    }
}



class GCorrectColor
extends GColorType
{
    input        = null;
     
    order        = null;
    margin1      = null;
    margin2      = null;
    margin3      = null;

    corrections  = [];



    constructor(nodeId, options)
    {
        super(CORRECT_COLOR, nodeId, options);
    }


    
    copy()
    {
        const copy = new GCorrectColor(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.order  ) copy.order   = this.order  .copy();
        if (this.margin1) copy.margin1 = this.margin1.copy();
        if (this.margin2) copy.margin2 = this.margin2.copy();
        if (this.margin3) copy.margin3 = this.margin3.copy();
        if (this.value  ) copy.value   = this.value  .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const order   = this.order   ? (await this.order  .eval(parse)).toValue().toInteger() : null;
        const margin1 = this.margin1 ? (await this.margin1.eval(parse)).toValue()             : null;
        const margin2 = this.margin2 ? (await this.margin2.eval(parse)).toValue()             : null;
        const margin3 = this.margin3 ? (await this.margin3.eval(parse)).toValue()             : null;

    
        if (order)
            order.value = Math.min(Math.max(0, order.value), 5);


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();


            if (this.options.enabled)
            {
                if (   isValid(this.order  ) && this.order  .isValid()
                    && isValid(this.margin1) && this.margin1.isValid()
                    && isValid(this.margin2) && this.margin2.isValid()
                    && isValid(this.margin3) && this.margin3.isValid()
                    && isValid(this.value  ) && this.value  .isValid())
                {
                    genPushUpdateValue(parse, this.nodeId, 'order'  , this.order  );
                    genPushUpdateValue(parse, this.nodeId, 'margin1', this.margin1);
                    genPushUpdateValue(parse, this.nodeId, 'margin2', this.margin2);
                    genPushUpdateValue(parse, this.nodeId, 'margin3', this.margin3);
                    genPushUpdateValue(parse, this.nodeId, 'value'  , this.value  );
                }
                else
                {
                    const rgb = input.toRgb();
                    
                    if (!rgbIsOk(rgb))
                        genInitNodeProgress(this.nodeId);


                    const inputColor = input.toDataColor();


                    const
                  [ closestOrder,
                    closest1,
                    closest2,
                    closest3 ] = findCorrection(
                        this.nodeId,
                        inputColor, 
                        order, margin1, margin2, margin3, 
                        this.order   != null,
                        this.margin1 != null, 
                        this.margin2 != null, 
                        this.margin3 != null); 

                        
                    //if (!stopGenerate)
                    //{
                        if (   closestOrder >= 0 
                            && closestOrder <  6)
                        {
                            this._color = correctColor(
                                inputColor,
                                closestOrder,
                                closest1,
                                closest2,
                                closest3);

                                
                            this.order   = new NumberValue(closestOrder);
                            this.margin1 = new NumberValue(closest1);
                            this.margin2 = new NumberValue(closest2);
                            this.margin3 = new NumberValue(closest3);
                            this.value   = ColorValue.fromDataColor(this._color);

                            genPushUpdateValue(parse, this.nodeId, 'order',   new NumberValue(closestOrder));
                            genPushUpdateValue(parse, this.nodeId, 'margin1', new NumberValue(closest1    ));
                            genPushUpdateValue(parse, this.nodeId, 'margin2', new NumberValue(closest2    ));
                            genPushUpdateValue(parse, this.nodeId, 'margin3', new NumberValue(closest3    ));
                            genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
                        }
                        else
                        {
                            this.order   = NumberValue.NaN;
                            this.margin1 = NumberValue.NaN;
                            this.margin2 = NumberValue.NaN;
                            this.margin3 = NumberValue.NaN;
                            this.value   = ColorValue .NaN;

                            genPushUpdateValue(parse, this.nodeId, 'order',   NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'margin1', NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'margin2', NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'margin3', NumberValue.NaN);
                            genPushUpdateValue(parse, this.nodeId, 'value',   ColorValue .NaN);
                        }
                    //}
                }
            }
            else
            {
                this.order   = NumberValue.NaN;
                this.margin1 = NumberValue.NaN;
                this.margin2 = NumberValue.NaN;
                this.margin3 = NumberValue.NaN;
                this.value   = input;

                genPushUpdateValue(parse, this.nodeId, 'order'  , this.order  );
                genPushUpdateValue(parse, this.nodeId, 'margin1', this.margin1);
                genPushUpdateValue(parse, this.nodeId, 'margin2', this.margin2);
                genPushUpdateValue(parse, this.nodeId, 'margin3', this.margin3);
                genPushUpdateValue(parse, this.nodeId, 'value',   this.value  );
            }
        }
        else
        {
            this.order   = NumberValue.NaN;
            this.margin1 = NumberValue.NaN;
            this.margin2 = NumberValue.NaN;
            this.margin3 = NumberValue.NaN;
            this.value   = ColorValue .NaN;

            genPushUpdateValue(parse, this.nodeId, 'order',   NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin1', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin2', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'margin3', NumberValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'value',   ColorValue .NaN);
        }


        this.validate();

        return this;
    }
}



class GColorContrast
extends GColorType
{
    input0 = null;
    input1 = null;

    standard;
    contrast;


    constructor(nodeId, options)
    {
        super(COLOR_CONTRAST, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorContrast(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.standard = this.standard.copy();
        copy.contrast = this.contrast.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const standard = (await this.standard.eval(parse)).toValue().toInteger();

        
        if (standard.isValid())
            standard.value = Math.min(Math.max(0, standard.value), 1);


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();


            if (   input0.isValid()
                && input1.isValid())
            {
                this.value = input1;
                
                if (   dataColorIsValid(input0.toDataColor())
                    && dataColorIsValid(input1.toDataColor()))
                {
                    if (standard.value == 0)
                    {
                        const value = getContrastRatio2(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 2);
                    }
                    else
                    {
                        const value = getContrastRatio3(input0.toRgb(), input1.toRgb());
                        this.contrast = new NumberValue(value, 1);
                    }
                }
                else
                    this.contrast = NumberValue.NaN;
            }
            else
            {
                this.value    = ColorValue.NaN;
                this.contrast = NumberValue.NaN;
            }


            genPushUpdateValue(parse, this.nodeId, 'text', input0);
            genPushUpdateValue(parse, this.nodeId, 'back', input1);
        }

        else if (this.input0) 
        {
            const input0 = (await this.input0.eval(parse)).toValue();

            genPushUpdateValue(parse, this.nodeId, 'text', input0.isValid() ? input0 : ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', ColorValue.NaN);

            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else if (this.input1) 
        {
            const input1 = (await this.input1.eval(parse)).toValue();

            genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', input1.isValid() ? input1 : ColorValue.NaN);

            this.value    = input1.isValid() ? input1 : ColorValue.NaN;
            this.contrast = NumberValue.NaN;
        }

        else
        {
            this.value    = ColorValue.NaN;
            this.contrast = NumberValue.NaN;

            genPushUpdateValue(parse, this.nodeId, 'text', ColorValue.NaN);
            genPushUpdateValue(parse, this.nodeId, 'back', ColorValue.NaN);
        }
        


        genPushUpdateValue(parse, this.nodeId, 'standard', standard);
        genPushUpdateValue(parse, this.nodeId, 'contrast', this.contrast);


        this.validate();

        return this;
    }
}



class GColorBlind
extends GColorType
{
    input = null;

    l;
    m;
    s;


    constructor(nodeId, options)
    {
        super(COLORBLIND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlind(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        copy.l = this.l.copy();
        copy.m = this.m.copy();
        copy.s = this.s.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const l = (await this.l.eval(parse)).toValue();        
        const m = (await this.m.eval(parse)).toValue();
        const s = (await this.s.eval(parse)).toValue();


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();
            const rgb   = input.toRgb();

            if (this.options.enabled)
            {
                const rgbCb = rgb2colorblind(
                    rgb,
                    l.value / 2,
                    m.value / 2,
                    s.value / 2);

                if (   !rgbIsNaN(rgb)
                    && !rgbIsNaN(rgbCb))
                {
                    const validRgbCb = rgbCb;
                
                    const validCol = convertDataColorToSpace(
                        rgb2dataColor(validRgbCb), 
                        colorSpace(input.space.value));

                    this.value = ColorValue.fromDataColor(validCol);
                }
                else
                    this.value = ColorValue.NaN;
            }
            else
                this.value = input;
        }
        else
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'l',     l);
        genPushUpdateValue(parse, this.nodeId, 'm',     m);
        genPushUpdateValue(parse, this.nodeId, 's',     s);
        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }
}



class GColorInterpolate
extends GColorType
{
    input0 = null;
    input1 = null;

    space;
    amount;
    gamma;


    constructor(nodeId, options)
    {
        super(COLOR_INTERPOLATE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorInterpolate(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.space  = this.space .copy();
        copy.amount = this.amount.copy();
        copy.gamma  = this.gamma .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const space  = (await this.space .eval(parse)).toValue().toInteger();
        const amount = (await this.amount.eval(parse)).toValue();
        const gamma  = (await this.gamma .eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            console.assert(
                amount.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const f = amount.value / 100;


            const spaceIndex = Math.min(Math.max(0, space.value), colorSpaceCount()-1);
            const gammaValue = Math.max(0.0001, gamma.value);

            const _space = colorSpace(spaceIndex);

            const _color = this.interpolate(
                spaceIndex,
                convertDataColorToSpace(input0.toDataColor(), _space),
                convertDataColorToSpace(input1.toDataColor(), _space),
                f,
                gammaValue);


            // allow interpolating invalid colors,
            // so no valid color check here

            this.value = ColorValue.fromDataColor(_color, spaceIndex);
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'space',  space );
        genPushUpdateValue(parse, this.nodeId, 'amount', amount);
        genPushUpdateValue(parse, this.nodeId, 'gamma',  gamma );
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value);


        this.validate();
        
        return this;
    }



    interpolate(space, col0, col1, f, gamma)
    {
        if (   space <= 1
            || space >  6) // hex, rgb, okLab, lab, luv
        {
            const r0 = Math.pow(col0[1], gamma);  const r1 = Math.pow(col1[1], gamma);
            const g0 = Math.pow(col0[2], gamma);  const g1 = Math.pow(col1[2], gamma);
            const b0 = Math.pow(col0[3], gamma);  const b1 = Math.pow(col1[3], gamma);

            gamma = Math.max(0.01, gamma);

            return [
                colorSpace(space),
                Math.pow(lerp(r0, r1, f), 1/gamma),
                Math.pow(lerp(g0, g1, f), 1/gamma),
                Math.pow(lerp(b0, b1, f), 1/gamma) ];
        }
        else // hsv/hsl/hcl
        {
            const h0 = col0[1] * Tau;  const h1 = col1[1] * Tau;
            const c0 = col0[2];        const c1 = col1[2];
            const l0 = col0[3];        const l1 = col1[3];

            return [
                colorSpace(space),
                normalAngle(h0 + angleDiff(h0, h1) * f) / Tau,
                lerp(c0, c1, f),
                lerp(l0, l1, f) ];
        }
    }
}



class GColorBlend
extends GColorType
{
    input0 = null;
    input1 = null;

    mode;
    opacity;
    

    constructor(nodeId, options)
    {
        super(COLOR_BLEND, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorBlend(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input0) copy.input0 = this.input0.copy();
        if (this.input1) copy.input1 = this.input1.copy();

        copy.mode    = this.mode   .copy();
        copy.opacity = this.opacity.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const mode    = (await this.mode   .eval(parse)).toValue().toInteger();
        const opacity = (await this.opacity.eval(parse)).toValue();


        if (   this.input0 
            && this.input1)
        {
            const input0 = (await this.input0.eval(parse)).toValue();
            const input1 = (await this.input1.eval(parse)).toValue();

            console.assert(
                opacity.type == NUMBER_VALUE, 
                'this.result.type must be NUMBER_VALUE');

            const _opacity = opacity.value / 100;

            const modeIndex = Math.min(Math.max(0, mode.value), BlendModes.length-1);


            const col = this.blend(
                modeIndex,
                input0.toRgb(),
                input1.toRgb(),
                _opacity);

            this.value = ColorValue.fromRgb(scaleRgb(col));
        }

        else if (this.input0) 
            this.value = (await this.input0.eval(parse)).toValue();

        else if (this.input1) 
            this.value = (await this.input1.eval(parse)).toValue();
            
        else 
            this.value = ColorValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value',   this.value);
        genPushUpdateValue(parse, this.nodeId, 'mode',    mode );
        genPushUpdateValue(parse, this.nodeId, 'opacity', opacity);


        this.validate();
        
        return this;
    }



    blend(mode, col0, col1, opacity)
    {
        switch (mode)
        {
            case  0: return blendNormal    (col0, col1, opacity);

            case  1: return blendDarken    (col0, col1, opacity);
            case  2: return blendMultiply  (col0, col1, opacity);
            case  3: return blendColorBurn (col0, col1, opacity);

            case  4: return blendLighten   (col0, col1, opacity);
            case  5: return blendScreen    (col0, col1, opacity);
            case  6: return blendColorDodge(col0, col1, opacity);

            case  7: return blendOverlay   (col0, col1, opacity);
            case  8: return blendSoftLight (col0, col1, opacity);
            case  9: return blendHardLight (col0, col1, opacity);

            case 10: return blendDifference(col0, col1, opacity);
            case 11: return blendExclusion (col0, col1, opacity);

            case 12: return blendHue       (col0, col1, opacity);
            case 13: return blendSaturation(col0, col1, opacity);
            case 14: return blendColor     (col0, col1, opacity);
            case 15: return blendLuminosity(col0, col1, opacity);
        }
    }
}



function blendNormal(col, back, opacity)
{
    return [ col[0] * opacity + back[0] * (1 - opacity),
             col[1] * opacity + back[1] * (1 - opacity),
             col[2] * opacity + back[2] * (1 - opacity) ];
}



function blendDarken(col, back, opacity)
{
    return blendNormal(
        [ Math.min(back[0], col[0]),
          Math.min(back[1], col[1]),
          Math.min(back[2], col[2]) ],
        back,
        opacity);
}



function chanMultiply(c, b)
{
    return c * b;
}



function blendMultiply(col, back, opacity)
{
    return blendNormal(
        [ chanMultiply(col[0], back[0]),
          chanMultiply(col[1], back[1]),
          chanMultiply(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorBurn(c, b)
{
         if (b == 1) return 1;
    else if (c == 0) return 0;
    else             return 1 - Math.min((1 - b) / c, 1);
}



function blendColorBurn(col, back, opacity)
{
    return blendNormal(
         [ chanColorBurn(col[0], back[0]),
           chanColorBurn(col[1], back[1]),
           chanColorBurn(col[2], back[2]) ],
        back,
        opacity);
}



function blendLighten(col, back, opacity)
{
    return blendNormal(
        [ Math.max(back[0], col[0]),
          Math.max(back[1], col[1]),
          Math.max(back[2], col[2]) ],
        back,
        opacity);
}



function chanScreen(c, b)
{
    return b + c - b*c;
}



function blendScreen(col, back, opacity)
{
    return blendNormal(
        [ chanScreen(col[0], back[0]),
          chanScreen(col[1], back[1]),
          chanScreen(col[2], back[2]) ],
        back,
        opacity);
}



function chanColorDodge(c, b)
{
         if (b == 0) return 0;
    else if (c == 1) return 1;
    else             return Math.min(b / (1 - c), 1);
}



function blendColorDodge(col, back, opacity)
{
    return blendNormal(
        [ chanColorDodge(col[0], back[0]),
          chanColorDodge(col[1], back[1]),
          chanColorDodge(col[2], back[2]) ],
        back,
        opacity);
}



function blendOverlay(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(back[0], col[0]),
          chanHardLight(back[1], col[1]),
          chanHardLight(back[2], col[2]) ],
        back,
        opacity);
}



function bSL_D(b)
{
    return b <= 0.25
         ? ((16 * b - 12) * b + 4) * b
         : Math.sqrt(b);
}



function chanSoftLight(c, b)
{
    return c <= 0.5
         ? b - (1 - 2*c) * b * (1 - b)
         : b + (2*c - 1) * (bSL_D(b) - b);
}



function blendSoftLight(col, back, opacity)
{
    return blendNormal(
        [ chanSoftLight(col[0], back[0]),
          chanSoftLight(col[1], back[1]),
          chanSoftLight(col[2], back[2]) ],
        back,
        opacity);
}



function chanHardLight(c, b)
{
    if (c <= 0.5) return chanMultiply(b, 2 * c);
    else          return chanScreen(b, 2 * c - 1);
}



function blendHardLight(col, back, opacity)
{
    return blendNormal(
        [ chanHardLight(col[0], back[0]),
          chanHardLight(col[1], back[1]),
          chanHardLight(col[2], back[2]) ],
        back,
        opacity);
}



function blendDifference(col, back, opacity)
{
    return [ Math.abs(back[0] - col[0]),
             Math.abs(back[1] - col[1]),
             Math.abs(back[2] - col[2]) ];
}



function chanExclusion(c, b)
{
    return b + c - 2*b*c;
}



function blendExclusion(col, back, opacity)
{
    return blendNormal(
        [ chanExclusion(col[0], back[0]),
          chanExclusion(col[1], back[1]),
          chanExclusion(col[2], back[2]) ],
        back,
        opacity);
}



function bl_lum(col)
{
    return col[0] * 0.30
         + col[1] * 0.59
         + col[2] * 0.11;
}



function bl_setLum(_col, l)
{
    const col = [..._col];

    const d = l - bl_lum(col);

    col[0] += d;
    col[1] += d;
    col[2] += d;

    return bl_clamp(col);
}



function bl_sat(col)
{
    return Math.max(col[0], col[1], col[2]) 
         - Math.min(col[0], col[1], col[2]);
}



function bl_min(col)
{
         if (col[0] <= col[1] 
          && col[0] <= col[2]) return 0;
    else if (col[1] <= col[1] 
          && col[1] <= col[2]) return 1;
    else                       return 2;
}



function bl_mid(col)
{
         if (   col[0] >= col[1] 
             && col[0] <= col[2]
          ||    col[0] <= col[1] 
             && col[0] >= col[2]) return 0;
    else if (   col[1] >= col[0] 
             && col[1] <= col[2]
          ||    col[1] <= col[0] 
             && col[1] >= col[2]) return 1;
    else                          return 2;
}



function bl_max(col)
{
         if (col[0] >= col[1] 
          && col[0] >= col[2]) return 0;
    else if (col[1] >= col[1] 
          && col[1] >= col[2]) return 1;
    else                       return 2;
}



function bl_ndx(col) // get min/mid/max chan indices
{
    if (   col[0] == col[1] 
        && col[0] == col[2])
        return [0, 1, 2];

    else 
        return [
            bl_min(col), 
            bl_mid(col), 
            bl_max(col)];
}



function bl_setSat(_col, s)
{
    const col       = [..._col];
    const [n, d, x] = bl_ndx(col);

    if (col[x] > col[n])
    {
        col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));
        col[x] = s;
    }
    else
        col[d] = col[x] = 0;

    col[n] = 0;

    return col;
}



function bl_chanClamp(c, l, n, x)
{
         if (n < 0) return l + (((c - l) * l) / (l - n));
    else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));
    else            return c;
}



function bl_clamp(col)
{
    const l   = bl_lum(col);

    const n = Math.min(col[0], col[1], col[2]);
    const x = Math.max(col[0], col[1], col[2]);

    return [ bl_chanClamp(col[0], l, n, x),
             bl_chanClamp(col[1], l, n, x),
             bl_chanClamp(col[2], l, n, x) ];
}



function blendHue(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(col, bl_sat(back)), bl_lum(back)),
        back,
        opacity);
}



function blendSaturation(col, back, opacity)
{
    return blendNormal(
        bl_setLum(bl_setSat(back, bl_sat(col)), bl_lum(back)),
        back,
        opacity);
}



function blendColor(col, back, opacity)
{
    return blendNormal(
        bl_setLum(col, bl_lum(back)),
        back,
        opacity);
}



function blendLuminosity(col, back, opacity)
{
    return blendNormal(
        bl_setLum(back, bl_lum(col)),
        back,
        opacity);
}


class GColorStop
extends GOperator
{
    input    = null;

    fill     = null;
    position = null;



    constructor(nodeId, options)
    {
        super(COLOR_STOP, nodeId, options);
    }


    
    copy()
    {
        const copy = new GColorStop(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.fill    ) copy.fill     = this.fill    .copy();
        if (this.position) copy.position = this.position.copy();

        return copy;
    }



    async eval(parse)
    {
        if (!this.valid)
        {
            this.result = new ColorStopValue();


            if (this.input)
            {
                this.result = (await this.input.eval(parse)).copy();

                console.assert(
                    this.result.type == COLOR_STOP_VALUE, 
                    'this.result.type must be COLOR_STOP_VALUE');

                if (this.result.isValid())
                {
                    if (this.fill    ) this.result.fill     = (await this.fill    .eval(parse)).copy();
                    if (this.position) this.result.position = (await this.position.eval(parse)).copy();
                }
            }
            else
            {
                this.result.fill     = (await this.fill    .eval(parse)).copy();
                this.result.position = (await this.position.eval(parse)).copy();
            }


            this.result.valid = true;
            this.valid        = true;


            genPushUpdateValue(parse, this.nodeId, 'value', this.result);
        }


        return this;
    }
}


class GShape
extends GOperator
{
    props   = null;
   


    constructor(type, nodeId, options)
    {
        super(type, nodeId, options);
    }



    copyBase(base)
    {
        this.copyProperties(base.props);
    }



    copyProperties(props)
    {
        this.props = props.map(p => p.copy());
    }



    async evalBase(parse, input)
    {
        const props = this.props ? (await this.props.eval(parse)).toValue() : null;


        if (this.input)
            this.value.props = props ?? input.props;
        else
            this.value.props = props;


        genPushUpdateValue(parse, this.nodeId, 'props', this.value.props);
    }



    async evalObjects(parse)
    {
        for (const obj of this.objects)
        {
            for (let i = this.value.props.items.length-1; i >= 0; i--)
            {
                const prop = this.value.props.items[i];
                

                if (prop.type == COLOR_VALUE)
                {
                    if (!obj.fills) 
                        obj.fills = [];


                    const rgb = scaleRgb(prop.toRgb());

                    obj.fills.push([
                        'SOLID', 
                                rgb[0]
                        + ' ' + rgb[1]
                        + ' ' + rgb[2]
                        + ' ' + '255']);
                }

                else if (prop.type == FILL_VALUE)
                {
                    if (!obj.fills) 
                        obj.fills = [];


                    const rgb = scaleRgb(prop.color.toRgb());

                    obj.fills.push([
                        'SOLID', 
                                rgb[0]
                        + ' ' + rgb[1]
                        + ' ' + rgb[2]
                        + ' ' + prop.opacity.toValue().toNumber()]);
                }

                else if (prop.type == STROKE_VALUE)
                {
                    if (!obj.strokes)
                        obj.strokes = [];


                    const rgb = scaleRgb(prop.fill.color.toRgb());

                    obj.strokes.push([
                        'SOLID', 
                                rgb[0]
                        + ' ' + rgb[1]
                        + ' ' + rgb[2]
                        + ' ' + prop.fill.opacity.toValue().toNumber()]);


                    obj.strokeWeight = prop.weight.toValue().toNumber();

                    switch (prop.fit.toValue().value)
                    {
                        case 0: obj.strokeFit = 'INSIDE';  break;
                        case 1: obj.strokeFit = 'CENTER';  break;
                        case 2: obj.strokeFit = 'OUTSIDE'; break;
                    }

                    switch (prop.join.toValue().value)
                    {
                        case 0: obj.strokeJoin = 'MITER'; break;
                        case 1: obj.strokeJoin = 'BEVEL'; break;
                        case 2: obj.strokeJoin = 'ROUND'; break;
                    }

                    obj.strokeMiterLimit = prop.miter.toValue().value;
                }
            }
        }
    }


    
    evalStyle(options = {})
    {
        // for (const style of this.styles)
        //     style.nodeId = this.nodeId;
    }



    isValid()
    {
        return this.props.isValid()
            && super.isValid();
    }
}


class GRectangle
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;



    constructor(nodeId, options)
    {
        super(RECTANGLE, nodeId, options);
    }



    copy()
    {
        const copy = new GRectangle(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();
        if (this.round ) copy.round  = this.round .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;
        const height = this.height ? (await this.height.eval(parse)).toValue() : null;
        const angle  = this.angle  ? (await this.angle .eval(parse)).toValue() : null;
        const round  = this.round  ? (await this.round .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new RectangleValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                angle  ?? input.angle,
                round  ?? input.round);
        }
        else
        {
            this.value = new RectangleValue(this.nodeId, x, y, width, height, angle, round);
        }

       
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value       );
        genPushUpdateValue(parse, this.nodeId, 'x',      this.value.x     );
        genPushUpdateValue(parse, this.nodeId, 'y',      this.value.y     );
        genPushUpdateValue(parse, this.nodeId, 'width',  this.value.width );
        genPushUpdateValue(parse, this.nodeId, 'height', this.value.height);
        genPushUpdateValue(parse, this.nodeId, 'angle',  this.value.angle );
        genPushUpdateValue(parse, this.nodeId, 'round',  this.value.round );


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.value.x 
            && this.value.y 
            && this.value.width 
            && this.value.height 
            && this.value.angle 
            && this.value.round)
        {
            this.objects = 
            [
                new FigmaRectangle(
                                this.nodeId,
                                0,
                                this.value.x     .value,
                                this.value.y     .value,
                                this.value.width .value,
                                this.value.height.value,
                                this.value.angle .value,
                    Math.max(0, this.value.round .value))
            ];
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return this.x     .isValid()
            && this.y     .isValid()
            && this.width .isValid()
            && this.height.isValid()
            && this.angle .isValid()
            && this.round .isValid()
            && super.isValid();
    }



    toValue()
    {
        const rect = new RectangleValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.height.toValue(),
            this.angle .toValue(),
            this.round .toValue());

        rect.props = this.props.toValue();

        return rect;
    }
}


class GLine
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(LINE, nodeId, options);
    }



    copy()
    {
        const copy = new GLine(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.angle ) copy.angle  = this.angle .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        const x     = this.x     ? (await this.x    .eval(parse)).toValue() : null;
        const y     = this.y     ? (await this.y    .eval(parse)).toValue() : null;
        const width = this.width ? (await this.width.eval(parse)).toValue() : null;
        const angle = this.angle ? (await this.angle.eval(parse)).toValue() : null;

        
        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new LineValue(
                this.nodeId,
                x     ?? input.x,
                y     ?? input.y,
                width ?? input.width,
                angle ?? input.angle);
        }
        else
        {
            this.value = new LineValue(this.nodeId, x, y, width, angle);
        }


            
        genPushUpdateValue(parse, this.nodeId, 'value', this.value      );
        genPushUpdateValue(parse, this.nodeId, 'x',     this.value.x    );
        genPushUpdateValue(parse, this.nodeId, 'y',     this.value.y    );
        genPushUpdateValue(parse, this.nodeId, 'width', this.value.width);
        genPushUpdateValue(parse, this.nodeId, 'angle', this.value.angle);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.x 
            && this.y 
            && this.width 
            && this.angle)
        {
            this.objects = 
            [
                new FigmaLine(
                    this.nodeId,
                    0,
                    this.value.x    .value,
                    this.value.y    .value,
                    this.value.width.value,
                    this.value.angle.value)
            ];
        }

        
        super.evalObjects(parse);
    }



    isValid()
    {
        return this.x    .isValid()
            && this.y    .isValid()
            && this.width.isValid()
            && this.angle.isValid()
            && super.isValid();
    }



    toValue()
    {
        const line = new LineValue(
            this.nodeId,
            this.x     .toValue(),
            this.y     .toValue(),
            this.width .toValue(),
            this.angle .toValue());

        line.props = this.props.toValue();

        return line;
    }
}


class GEllipse
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;



    constructor(nodeId, options)
    {
        super(ELLIPSE, nodeId, options);
    }



    copy()
    {
        const copy = new GEllipse(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();

        return copy;
    }


    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;
        const height = this.height ? (await this.height.eval(parse)).toValue() : null;
        const angle  = this.angle  ? (await this.angle .eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new EllipseValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                angle  ?? input.angle);
        }
        else
        {
            this.value = new EllipseValue(this.nodeId, x, y, width, height, angle);
        }


        genPushUpdateValue(parse, this.nodeId, 'value',  this.value       );
        genPushUpdateValue(parse, this.nodeId, 'x',      this.value.x     );
        genPushUpdateValue(parse, this.nodeId, 'y',      this.value.y     );
        genPushUpdateValue(parse, this.nodeId, 'width',  this.value.width );
        genPushUpdateValue(parse, this.nodeId, 'height', this.value.height);
        genPushUpdateValue(parse, this.nodeId, 'angle',  this.value.angle );


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
   }



   evalObjects(parse, options = {})
   {
       if (!this.options.enabled)
           return;
           
           
       if (   this.x 
           && this.y 
           && this.width 
           && this.height 
           && this.angle)
       {
           this.objects = 
           [
               new FigmaEllipse(
                    this.nodeId,
                    0,
                    this.x     .toValue().value,
                    this.y     .toValue().value,
                    this.width .toValue().value,
                    this.height.toValue().value,
                    this.angle .toValue().value)
           ];
       }

       
       super.evalObjects(parse);
   }



   isValid()
   {
       return this.x     .isValid()
           && this.y     .isValid()
           && this.width .isValid()
           && this.height.isValid()
           && this.angle .isValid()
           && super.isValid();
   }



   toValue()
   {
       const ellipse = new EllipseValue(
           this.nodeId,
           this.x     .toValue(),
           this.y     .toValue(),
           this.width .toValue(),
           this.height.toValue(),
           this.angle .toValue());

        ellipse.props = this.props.toValue();

        return ellipse;
   }
}


class GPolygon
extends GShape
{
    input   = null;

    x       = null;
    y       = null;
    width   = null;
    height  = null;
    angle   = null;
    round   = null;
    corners = null;



    constructor(nodeId, options)
    {
        super(POLYGON, nodeId, options);
    }



    copy()
    {
        const copy = new GPolygon(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x      ) copy.x       = this.x      .copy();
        if (this.y      ) copy.y       = this.y      .copy();
        if (this.width  ) copy.width   = this.width  .copy();
        if (this.height ) copy.height  = this.height .copy();
        if (this.angle  ) copy.angle   = this.angle  .copy();
        if (this.round  ) copy.round   = this.round  .copy();
        if (this.corners) copy.corners = this.corners.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x       = this.x       ? (await this.x      .eval(parse)).toValue() : null;
        const y       = this.y       ? (await this.y      .eval(parse)).toValue() : null;
        const width   = this.width   ? (await this.width  .eval(parse)).toValue() : null;
        const height  = this.height  ? (await this.height .eval(parse)).toValue() : null;
        const angle   = this.angle   ? (await this.angle  .eval(parse)).toValue() : null;
        const round   = this.round   ? (await this.round  .eval(parse)).toValue() : null;
        const corners = this.corners ? (await this.corners.eval(parse)).toValue() : null;


        let input = null;
             
        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new PolygonValue(
                this.nodeId,
                x       ?? input.x,
                y       ?? input.y,
                width   ?? input.width,
                height  ?? input.height,
                angle   ?? input.angle,
                round   ?? input.round,
                corners ?? input.corners);
        }
        else
        {
            this.value = new PolygonValue(this.nodeId, x, y, width, height, angle, round, corners);
        }

        
        genPushUpdateValue(parse, this.nodeId, 'value',   this.value        );
        genPushUpdateValue(parse, this.nodeId, 'x',       this.value.x      );
        genPushUpdateValue(parse, this.nodeId, 'y',       this.value.y      );
        genPushUpdateValue(parse, this.nodeId, 'width',   this.value.width  );
        genPushUpdateValue(parse, this.nodeId, 'height',  this.value.height );
        genPushUpdateValue(parse, this.nodeId, 'angle',   this.value.angle  );
        genPushUpdateValue(parse, this.nodeId, 'round',   this.value.round  );
        genPushUpdateValue(parse, this.nodeId, 'corners', this.value.corners);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;
            
            
        if (   this.x 
            && this.y 
            && this.width 
            && this.height 
            && this.angle 
            && this.round
            && this.corners)
        {
            this.objects = 
            [
                new FigmaPolygon(
                                this.nodeId,
                                0,
                                this.x      .toValue().value,
                                this.y      .toValue().value,
                                this.width  .toValue().value,
                                this.height .toValue().value,
                                this.angle  .toValue().value,
                    Math.max(0, this.round  .toValue().value),
                                this.corners.toValue().value)
            ];
        }

        
        super.evalObjects(parse);
    }



    isValid()
    {
        return this.x      .isValid()
            && this.y      .isValid()
            && this.width  .isValid()
            && this.height .isValid()
            && this.angle  .isValid()
            && this.round  .isValid()
            && this.corners.isValid()
            && super.isValid();
    }



    toValue()
    {
        const poly = new PolygonValue(
            this.nodeId,
            this.x      .toValue(),
            this.y      .toValue(),
            this.width  .toValue(),
            this.height .toValue(),
            this.angle  .toValue(),
            this.round  .toValue(),
            this.corners.toValue());

        poly.props = this.props.toValue();

        return poly;
    }
}


class GStar
extends GShape
{
    input  = null;

    x      = null;
    y      = null;
    width  = null;
    height = null;
    angle  = null;
    round  = null;
    points = null;
    convex = null;



    constructor(nodeId, options)
    {
        super(STAR, nodeId, options);
    }



    copy()
    {
        const copy = new GStar(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.x     ) copy.x      = this.x     .copy();
        if (this.y     ) copy.y      = this.y     .copy();
        if (this.width ) copy.width  = this.width .copy();
        if (this.height) copy.height = this.height.copy();
        if (this.angle ) copy.angle  = this.angle .copy();
        if (this.round ) copy.round  = this.round .copy();
        if (this.points) copy.points = this.points.copy();
        if (this.convex) copy.convex = this.convex.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const x      = this.x      ? (await this.x     .eval(parse)).toValue() : null;
        const y      = this.y      ? (await this.y     .eval(parse)).toValue() : null;
        const width  = this.width  ? (await this.width .eval(parse)).toValue() : null;
        const height = this.height ? (await this.height.eval(parse)).toValue() : null;
        const angle  = this.angle  ? (await this.angle .eval(parse)).toValue() : null;
        const round  = this.round  ? (await this.round .eval(parse)).toValue() : null;
        const points = this.points ? (await this.points.eval(parse)).toValue() : null;
        const convex = this.convex ? (await this.convex.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new StarValue(
                this.nodeId,
                x      ?? input.x,
                y      ?? input.y,
                width  ?? input.width,
                height ?? input.height,
                angle  ?? input.angle,
                round  ?? input.round,
                points ?? input.points,
                convex ?? input.convex);
        }
        else
        {
            this.value = new StarValue(this.nodeId, x, y, width, height, angle, round, points, convex);
        }

             
        genPushUpdateValue(parse, this.nodeId, 'value',  this.value       );
        genPushUpdateValue(parse, this.nodeId, 'x',      this.value.x     );
        genPushUpdateValue(parse, this.nodeId, 'y',      this.value.y     );
        genPushUpdateValue(parse, this.nodeId, 'width',  this.value.width );
        genPushUpdateValue(parse, this.nodeId, 'height', this.value.height);
        genPushUpdateValue(parse, this.nodeId, 'angle',  this.value.angle );
        genPushUpdateValue(parse, this.nodeId, 'round',  this.value.round );
        genPushUpdateValue(parse, this.nodeId, 'points', this.value.points);
        genPushUpdateValue(parse, this.nodeId, 'convex', this.value.convex);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
   }



   evalObjects(parse, options = {})
   {
       if (!this.options.enabled)
           return;
           
           
       if (   this.x 
           && this.y 
           && this.width 
           && this.height 
           && this.angle 
           && this.round
           && this.points
           && this.convex)
       {
           this.objects = 
           [
               new FigmaStar(
                               this.nodeId,
                               0,
                               this.x     .toValue().value,
                               this.y     .toValue().value,
                               this.width .toValue().value,
                               this.height.toValue().value,
                               this.angle .toValue().value,
                   Math.max(0, this.round .toValue().value),
                               this.points.toValue().value,
                               this.convex.toValue().value)
           ];
       }

       
       super.evalObjects(parse);
   }



   isValid()
   {
       return this.x     .isValid()
           && this.y     .isValid()
           && this.width .isValid()
           && this.height.isValid()
           && this.angle .isValid()
           && this.round .isValid()
           && this.points.isValid()
           && this.convex.isValid();
   }



   toValue()
   {
       const star = new StarValue(
           this.nodeId,
           this.x     .toValue(),
           this.y     .toValue(),
           this.width .toValue(),
           this.height.toValue(),
           this.angle .toValue(),
           this.round .toValue(),
           this.points.toValue(),
           this.convex.toValue());

        star.props = this.props.toValue();

        return star;
   }
}


class GTextShape
extends GShape
{
    input         = null;

    text          = null;
    x             = null;
    y             = null;
    width         = null;
    height        = null;
    angle         = null;
    font          = null;
    style         = null;
    size          = null;
    alignH        = null;
    alignV        = null;
    lineHeight    = null;
    letterSpacing = null;



    constructor(nodeId, options)
    {
        super(TEXTSHAPE, nodeId, options);
    }



    copy()
    {
        const copy = new GTextShape(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.text         ) copy.text          = this.text         .copy();
        if (this.x            ) copy.x             = this.x            .copy();
        if (this.y            ) copy.y             = this.y            .copy();
        if (this.width        ) copy.width         = this.width        .copy();
        if (this.height       ) copy.height        = this.height       .copy();
        if (this.angle        ) copy.angle         = this.angle        .copy();
        if (this.font         ) copy.font          = this.font         .copy();
        if (this.style        ) copy.style         = this.style        .copy();
        if (this.size         ) copy.size          = this.size         .copy();
        if (this.alignH       ) copy.alignH        = this.alignH       .copy();
        if (this.alignV       ) copy.alignV        = this.alignV       .copy();
        if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();
        if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        const text          = this.text          ? (await this.text         .eval(parse)).toValue() : null;
        const x             = this.x             ? (await this.x            .eval(parse)).toValue() : null;
        const y             = this.y             ? (await this.y            .eval(parse)).toValue() : null;
        const width         = this.width         ? (await this.width        .eval(parse)).toValue() : null;
        const height        = this.height        ? (await this.height       .eval(parse)).toValue() : null;
        const angle         = this.angle         ? (await this.angle        .eval(parse)).toValue() : null;
        const font          = this.font          ? (await this.font         .eval(parse)).toValue() : null;
        const style         = this.style         ? (await this.style        .eval(parse)).toValue() : null;
        const size          = this.size          ? (await this.size         .eval(parse)).toValue() : null;
        const alignH        = this.alignH        ? (await this.alignH       .eval(parse)).toValue() : null;
        const alignV        = this.alignV        ? (await this.alignV       .eval(parse)).toValue() : null;
        const lineHeight    = this.lineHeight    ? (await this.lineHeight   .eval(parse)).toValue() : null;
        const letterSpacing = this.letterSpacing ? (await this.letterSpacing.eval(parse)).toValue() : null;


        let input = null;

        if (this.input)
        {
            input = (await this.input.eval(parse)).toValue();

            this.value = new TextShapeValue(
                this.nodeId,
                text          ?? input.text,
                x             ?? input.x,
                y             ?? input.y,
                width         ?? input.width,
                height        ?? input.height,
                angle         ?? input.angle,
                font          ?? input.font,
                style         ?? input.style,
                size          ?? input.size,
                alignH        ?? input.size,
                alignV        ?? input.size,
                lineHeight    ?? input.size,
                letterSpacing ?? input.size);
        }
        else
        {
            this.value = new TextShapeValue(
                this.nodeId, 
                text, 
                x, 
                y, 
                width, 
                height, 
                angle, 
                font, 
                style,
                size,
                alignH,
                alignV,
                lineHeight,
                letterSpacing);
        }

       
        genPushUpdateValue(parse, this.nodeId, 'value',         this.value              );
        genPushUpdateValue(parse, this.nodeId, 'text',          this.value.text         );
        genPushUpdateValue(parse, this.nodeId, 'x',             this.value.x            );
        genPushUpdateValue(parse, this.nodeId, 'y',             this.value.y            );
        genPushUpdateValue(parse, this.nodeId, 'width',         this.value.width        );
        genPushUpdateValue(parse, this.nodeId, 'height',        this.value.height       );
        genPushUpdateValue(parse, this.nodeId, 'angle',         this.value.angle        );
        genPushUpdateValue(parse, this.nodeId, 'font',          this.value.font         );
        genPushUpdateValue(parse, this.nodeId, 'style',         this.value.style        );
        genPushUpdateValue(parse, this.nodeId, 'size',          this.value.size         );
        genPushUpdateValue(parse, this.nodeId, 'alignH',        this.value.alignH       );
        genPushUpdateValue(parse, this.nodeId, 'alignV',        this.value.alignV       );
        genPushUpdateValue(parse, this.nodeId, 'lineHeight',    this.value.lineHeight   );
        genPushUpdateValue(parse, this.nodeId, 'letterSpacing', this.value.letterSpacing);


        await this.evalBase(parse, input);


        await this.evalObjects(parse);


        this.validate();

        return this;
    }



    async evalObjects(parse, options = {})
    {
        if (!this.options.enabled)
            return;

            
        if (   this.value.text
            && this.value.x 
            && this.value.y 
            && this.value.width 
            && this.value.height 
            && this.value.angle
            && this.value.font
            && this.value.style
            && this.value.size
            && this.value.alignH
            && this.value.alignV
            && this.value.lineHeight
            && this.value.letterSpacing)
        {
            const font = figFonts[this.value.font.value];

            this.objects = 
            [
                new FigmaText(
                    this.nodeId,
                    0,
                    this.value.text         .value,
                    this.value.x            .value,
                    this.value.y            .value,
                    this.value.width        .value,
                    this.value.height       .value,
                    this.value.angle        .value,
                    font.fontName.family,
                    this.value.style        .value,
                    this.value.size         .value,
                    this.value.alignH       .value,
                    this.value.alignV       .value,
                    this.value.lineHeight   .value,
                    this.value.letterSpacing.value)
            ];
        }

        
        await super.evalObjects(parse);
    }



    isValid()
    {
        return this.text         .isValid()
            && this.x            .isValid()
            && this.y            .isValid()
            && this.width        .isValid()
            && this.height       .isValid()
            && this.angle        .isValid()
            && this.font         .isValid()
            && this.style        .isValid()
            && this.size         .isValid()
            && this.alignH       .isValid()
            && this.alignV       .isValid()
            && this.lineHeight   .isValid()
            && this.letterSpacing.isValid()
            && super.isValid();
    }



    toValue()
    {
        const rect = new TextShapeValue(
            this.nodeId,
            this.text         .toValue(),
            this.x            .toValue(),
            this.y            .toValue(),
            this.width        .toValue(),
            this.height       .toValue(),
            this.angle        .toValue(),
            this.font         .toValue(),
            this.style        .toValue(),
            this.size         .toValue(),
            this.alignH       .toValue(),
            this.alignV       .toValue(),
            this.lineHeight   .toValue(),
            this.letterSPacing.toValue());

        rect.props = this.props.toValue();

        return rect;
    }
}


class GColorStyle
extends GShape
{
    id;

    colorStyle;

    existing;
    linked;



    constructor(nodeId, options, styleId)
    {
        super(COLOR_STYLE, nodeId, options);

        this.id == styleId;
    }



    copy()
    {
        const copy = new GColorStyle(this.nodeId, this.options);

        copy.id         = this.id;
        copy.colorStyle = this.colorStyle.copy();
        
        copy.existing   = this.existing;
        copy.linked     = this.linked;

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

            
        this.value = (await this.value.eval(parse)).toValue();


        if (   this.value.isValid()
            && (  !this.existing
                || this.linked))
        {
            if (this.value.type == COLOR_VALUE)
                this.value = FillValue.fromRgb(scaleRgb(this.value.toRgb()), 0xff);

            const rgba       = this.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            this.evalStyle({rgba: rgbaStripe});
        }
        else
            this.value = FillValue.NaN;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    evalStyle(options = {})
    {
        if (!this.options.enabled)
            return;

            
        const colorStyle = new FigmaColorStyle(this.nodeId, this.id, this.name);

        colorStyle.existing = this.existing;


        colorStyle.paints = 
        [
            [ 'SOLID', 
                      Math.round(options.rgba[0] * 0xff)
              + ' ' + Math.round(options.rgba[1] * 0xff)
              + ' ' + Math.round(options.rgba[2] * 0xff)
              + ' ' + Math.round(options.rgba[3] * 100 )]
        ];


        this.colorStyle = colorStyle;
    }
}


class GFill
extends GOperator
{
    input   = null;

    color   = null;
    opacity = null;



    constructor(nodeId, options)
    {
        super(FILL, nodeId, options);
    }



    copy()
    {
        const copy = new GFill(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.color  ) copy.color   = this.color  .copy();
        if (this.opacity) copy.opacity = this.opacity.copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;
``

        const color   = this.color   ? (await this.color  .eval(parse)).toValue() : null;
        const opacity = this.opacity ? (await this.opacity.eval(parse)).toValue() : null;

        
        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new FillValue(
                color   ?? input.color,
                opacity ?? input.opacity);
        }
        else
        {
            this.value = new FillValue(color, opacity);
        }


        genPushUpdateValue(parse, this.nodeId, 'color',   this.value.color  );
        genPushUpdateValue(parse, this.nodeId, 'opacity', this.value.opacity);


        this.validate();

        return this;
    }



    isValid()
    {
        return this.color  .isValid()
            && this.opacity.isValid();
    }



    toValue()
    {
        return this.options.enabled
             ? new FillValue(
                   this.color   ? this.color  .toValue() : this.input.color  .toValue(),
                   this.opacity ? this.opacity.toValue() : this.input.opacity.toValue())
             : FillValue.NaN;
    }
}


class GStroke
extends GShape
{
    input  = null;

    fill   = null;
    weight = null;
    fit    = null;
    join   = null;
    miter  = null;



    constructor(nodeId, options)
    {
        super(STROKE, nodeId, options);
    }



    copy()
    {
        const copy = new GStroke(this.nodeId, this.options);

        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();

        if (this.fill  ) copy.fill   = this.fill  .copy();
        if (this.weight) copy.weight = this.weight.copy();
        if (this.fit   ) copy.fit    = this.fit   .copy();
        if (this.join  ) copy.join   = this.join  .copy();
        if (this.miter ) copy.miter  = this.miter .copy();

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;

        let fill = this.fill ? (await this.fill.eval(parse)).toValue() : null;

        fill = this.validateFill(fill);


        const weight = this.weight ? (await this.weight.eval(parse)).toValue() : null;
        const fit    = this.fit    ? (await this.fit   .eval(parse)).toValue() : null;
        const join   = this.join   ? (await this.join  .eval(parse)).toValue() : null;
        const miter  = this.miter  ? (await this.miter .eval(parse)).toValue() : null;


        if (this.input)
        {
            const input = (await this.input.eval(parse)).toValue();

            this.value = new StrokeValue(
                fill   ?? input.fill,
                weight ?? input.weight,
                fit    ?? input.fit,
                join   ?? input.join,
                miter  ?? input.miter);
        }
        else
        {
            this.value = new StrokeValue(fill, weight, fit, join, miter);
        }


        genPushUpdateValue(parse, this.nodeId, 'fill',   this.value.fill  );
        genPushUpdateValue(parse, this.nodeId, 'weight', this.value.weight);
        genPushUpdateValue(parse, this.nodeId, 'fit',    this.value.fit   );
        genPushUpdateValue(parse, this.nodeId, 'join',   this.value.join  );
        genPushUpdateValue(parse, this.nodeId, 'miter',  this.value.miter );


        this.validate();

        return this;
    }



    validateFill(fill)
    {
        if (!fill)
            return null;


        if (fill.type == COLOR_VALUE)
            return FillValue.fromRgb(scaleRgb(fill.toRgb()), 0xff);
        else
            return fill;
    }



    isValid()
    {
        return this.fill  .isValid()
            && this.weight.isValid()
            && this.fit   .isValid()
            && this.join  .isValid()
            && this.miter .isValid();
    }



    toValue()
    {
        return new StrokeValue(
            this.options.enabled
            ? this.validateFill(this.fill ? this.fill.toValue() : this.input.fill.toValue())
            : FillValue.NaN,
            this.weight ? this.weight.toValue() : this.input.weight.toValue(),
            this.fit    ? this.fit   .toValue() : this.input.fit   .toValue(),
            this.join   ? this.join  .toValue() : this.input.join  .toValue(),
            this.miter  ? this.miter .toValue() : this.input.miter .toValue());
    }                 
}


class GGroupNode
extends GOperator
{
    paramIds = [];
    params   = [];



    constructor(nodeId, options)
    {
        super(GROUP_NODE, nodeId, options);
    }


    
    copy()
    {
        const copy = new GGroupNode(this.nodeId, this.options);

        copy.copyBase(this);

        copy.params = this.params.map(p => p.copy());

        return copy;
    }



    paramFromId(paramId)
    {
        return this.params[this.paramIds.findIndex(id => id == paramId)];
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (!isEmpty(this.params))
        {
            for (let i = 0; i < this.params.length; i++)
            {
                const param = await this.params[i].eval(parse);
                genPushUpdateValue(parse, this.nodeId, this.paramIds[i], param.toValue());
            }
        }
        else
            genPushUpdateValue(parse, this.nodeId, '', NullValue);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



class GGroupParam
extends GOperator
{
    input = null;
    
    dataType = NULL;



    constructor(nodeId, options)
    {
        super(GROUP_PARAM, nodeId, options);
    }



    copy()
    {
        const copy = new GGroupParam(this.nodeId, this.options);
        
        copy.copyBase(this);

        if (this.input) 
            copy.input = this.input.copy();
        
        copy.dataType = this.dataType;
      
        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        if (this.input)
        {
            if (!this.input.value)
                await this.input.eval(parse);

            this.value = this.input.toValue();
        }

        else if (this.dataType != NULL)
            this.value = nullFromType(this.dataType);
        
        else
            this.value = NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);


        this.validate();

        return this;
    }



    toValue()
    {
        return this.value.copy();
    }
}


class GComment
extends GOperator
{
    constructor(nodeId, options)
    {
        super(COMMENT, nodeId, options);
    }


    
    copy()
    {
        const copy = new GComment(this.nodeId, this.options);

        copy.copyBase(this);

        return copy;
    }



    async eval(parse)
    {
        if (this.isCached())
            return this;


        this.value = NullValue;


        genPushUpdateValue(parse, this.nodeId, 'value', this.value);
        
        
        this.validate();

        return this;
    }



    toValue()
    {
        return this.value
             ? this.value.copy() 
             : null;
    }
}



const settings =
{
    dataMode:                      false,
    debugMode:                     false,
        
    enableZoomedOutParams:         false,
    minZoomForParams:              0.35,
    showPages:                     false,
    showAllColorSpaces:            false,
    showBoolValues:                true,
    showOperationResults:          false,
    showClearUndoWarning:          true,
    showDebugMenu:                 false,
        
    showNodeId:                    false, // instead of name

    showTooltipLongText:           true,
    showTooltipColorInterpolation: true,
    showTooltipColorBlindness:     true,
    showTooltipColorContrast:      true,

    enableBetaFeatures:            false,
            
    logMessages:                   false,
    logActions:                    false, 
            
    logLoading:                    false, 
    logRequests:                   false, 
    logValueUpdates:               false, 
    logObjectUpdates:              false,
    logStyleUpdates:               false,
            
    logRawLoadPages:               false, 
    logRawLoadNodes:               false, 
    logRawLoadConnections:         false, 
        
    logRawSavePages:               false, 
    logRawSaveNodes:               false, 
    logRawSaveConnections:         false, 
        
    logRawRequests:                false, 
    logRawValues:                  false    
};



function updateSetting(settingName, value)
{
    switch (settingName)
    {
        case 'dataMode':                      settings.dataMode                      = value;  break;
        case 'debugMode':                     settings.debugMode                     = value;  break;
                
        case 'enableZoomedOutParams':         settings.enableZoomedOutParams         = value;  break;
        case 'minZoomForParams':              settings.minZoomForParams              = value;  break;
        case 'showPages':                     settings.showPages                     = value;  break;
        case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;
        case 'showBoolValues':                settings.showBoolValues                = value;  break;
        case 'showOperationResults':          settings.showOperationResults          = value;  break;
        case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;
        case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;
                        
        case 'showNodeId':                    settings.showNodeId                    = value;  break;

        case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;
        case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;
        case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;
        case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;

        case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;
                   
        case 'logMessages':                   settings.logMessages                   = value;  break;
        case 'logActions':                    settings.logActions                    = value;  break;
        case 'logLoading':                    settings.logLoading                    = value;  break;
        case 'logRequests':                   settings.logRequests                   = value;  break;
        case 'logValueUpdates':               settings.logValueUpdates               = value;  break;
        case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;
        case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;
                   
        case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;
        case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;
        case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;
                
        case 'logRawSavePages':               settings.logRawSavePages               = value;  break;
        case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;
        case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;
                
        case 'logRawRequests':                settings.logRawRequests                = value;  break;
        case 'logRawValues':                  settings.logRawValues                  = value;  break;
    } 
}



function updateSettingAndMenu(settingName, valid, value, save = true)
{
    switch (settingName)
    {
        case 'dataMode':                      updateSettingAndMenu_(valid, settingName, value, menuItemDataMode                     ); break;
        case 'debugMode':                     updateSettingAndMenu_(valid, settingName, value                                       ); break;
              
        case 'enableZoomedOutParams':         updateSettingAndMenu_(valid, settingName, value, menuItemEnableZoomedOutParams        ); break;
        case 'showPages':                     updateSettingAndMenu_(valid, settingName, value, menuItemShowPages                    ); break;
        case 'showAllColorSpaces':            updateSettingAndMenu_(valid, settingName, value, menuItemShowAllColorSpaces           ); break;
        case 'showBoolValues':                updateSettingAndMenu_(valid, settingName, value, menuItemShowBoolValues               ); break;
        case 'showOperationResults':          updateSettingAndMenu_(valid, settingName, value, menuItemShowOperationResults         ); break;
        case 'showClearUndoWarning':          updateSettingAndMenu_(valid, settingName, value, menuItemShowClearUndoWarning         ); break;
        case 'showDebugMenu':                 updateSettingAndMenu_(valid, settingName, value, menuItemShowDebugMenu                ); break;
                      
        case 'showNodeId':                    updateSettingAndMenu_(valid, settingName, value, menuItemShowNodeId                   ); break;
        
        case 'showTooltipLongText':           updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipLongText          ); break;
        case 'showTooltipColorContrast':      updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorContrast     ); break;
        case 'showTooltipColorInterpolation': updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorInterpolation); break;
        case 'showTooltipColorBlindness':     updateSettingAndMenu_(valid, settingName, value, menuItemShowTooltipColorBlindness    ); break;

        case 'enableBetaFeatures':            updateSettingAndMenu_(valid, settingName, value, menuItemEnableBetaFeatures           ); break;
                      
        case 'logMessages':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogMessages                  ); break;
        case 'logActions':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogActions                   ); break;
        case 'logLoading':                    updateSettingAndMenu_(valid, settingName, value, menuItemLogLoading                   ); break;
        case 'logRequests':                   updateSettingAndMenu_(valid, settingName, value, menuItemLogRequests                  ); break;
        case 'logValueUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogValueUpdates              ); break;
        case 'logObjectUpdates':              updateSettingAndMenu_(valid, settingName, value, menuItemLogObjectUpdates             ); break;
        case 'logStyleUpdates':               updateSettingAndMenu_(valid, settingName, value, menuItemLogStyleUpdates              ); break;
                      
        case 'logRawLoadPages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadPages              ); break;
        case 'logRawLoadNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadNodes              ); break;
        case 'logRawLoadConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawLoadConnections        ); break;
                      
        case 'logRawSavePages':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSavePages              ); break;
        case 'logRawSaveNodes':               updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveNodes              ); break;
        case 'logRawSaveConnections':         updateSettingAndMenu_(valid, settingName, value, menuItemLogRawSaveConnections        ); break;
                      
        case 'logRawRequests':                updateSettingAndMenu_(valid, settingName, value, menuItemLogRawRequests               ); break;
        case 'logRawValues':                  updateSettingAndMenu_(valid, settingName, value, menuItemLogRawValues                 ); break;
    } 

    if (   save
        && settingName != 'showAllColorSpaces')
        uiSetLocalData(settingName, boolToString(value));
}



function updateSettingAndMenu_(valid, setting, value, menu)
{
    if (valid) 
        settings[setting] = value;  

    if (menu)
        menu.setChecked(settings[setting]);
}



function updateSettingsMenus()
{
    menuItemDataMode                     .setVisible(settings.dataMode                     );
    menuItemDebug                        .setVisible(settings.debugMode                    );
                
    menuItemEnableZoomedOutParams        .setChecked(settings.enableZoomedOutParams        );
    menuItemShowPages                    .setChecked(settings.showPages                    );
    menuItemShowAllColorSpaces           .setChecked(settings.showAllColorSpaces           );
    menuItemShowBoolValues               .setChecked(settings.showBoolValues               );
    menuItemShowOperationResults         .setChecked(settings.showOperationResults         );
    menuItemShowClearUndoWarning         .setChecked(settings.showClearUndoWarning         );
    menuItemShowDebugMenu                .setChecked(settings.showDebugMenu                );
                
    menuItemShowNodeId                   .setChecked(settings.showNodeId                   );

    menuItemShowTooltipLongText          .setChecked(settings.showTooltipLongText          );
    menuItemShowTooltipColorInterpolation.setChecked(settings.showTooltipColorInterpolation);
    menuItemShowTooltipColorBlindness    .setChecked(settings.showTooltipColorBlindness    );
    menuItemShowTooltipColorContrast     .setChecked(settings.showTooltipColorContrast     );

    menuItemEnableBetaFeatures           .setChecked(settings.enableBetaFeatures           );
                  
    menuItemLogMessages                  .setChecked(settings.logMessages                  );
    menuItemLogActions                   .setChecked(settings.logActions                   );
                  
    menuItemLogLoading                   .setChecked(settings.logLoading                   );
    menuItemLogRequests                  .setChecked(settings.logRequests                  );
    menuItemLogValueUpdates              .setChecked(settings.logValueUpdates              );
    menuItemLogObjectUpdates             .setChecked(settings.logObjectUpdates             );
    menuItemLogStyleUpdates              .setChecked(settings.logStyleUpdates              );
                  
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadPages              );
    menuItemLogRawLoadNodes              .setChecked(settings.logRawLoadNodes              );
    menuItemLogRawLoadConnections        .setChecked(settings.logRawLoadConnections        );
                    
    menuItemLogRawSavePages              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveNodes              .setChecked(settings.logRawSaveNodes              );
    menuItemLogRawSaveConnections        .setChecked(settings.logRawSaveConnections        );
                
    menuItemLogRawRequests               .setChecked(settings.logRawRequests               );
    menuItemLogRawValues                 .setChecked(settings.logRawValues                 );
}



function updateMenuItemShowPages()
{
    uiSetPageData('showPages', boolToString(settings.showPages));
    graph.updatePages();
    graphView.update();
}



function updateMenuItemShowAllColorSpaces()
{
    uiSetPageData('showAllColorSpaces', boolToString(settings.showAllColorSpaces));

    graph.nodes
        .filter(n => COLOR_TYPES.includes(n.type))
        .forEach(n => n.updateNode());
}



function updateMenuItemShowBoolValues()
{
    graph.nodes
        .filter(n => 
                 BOOLEAN_TYPES.includes(n.type)
            || CONDITION_TYPES.includes(n.type)
            || n.type == IF_ELSE)
        .forEach(n => n.updateNode());
}



function updateMenuItemShowOperationResults()
{
    const nodes = graph.nodes
        .filter(n => n.params.find(p => p.isResult));

    nodes.forEach(n => n.updateNode());
    graphView.updateNodeTransforms(nodes);
}



function enableFeatures(subscription, beta)
{
    updateElementDisplay(menuItemShowPages           .div, subscription);
    updateElementDisplay(menuPrefSep1                .div, subscription);
    updateElementDisplay(menuPrefSep2                .div, subscription);
    updateElementDisplay(menuItemEnableBetaFeatures  .div, subscription);

    updateElementDisplay(btnFlow                     .div, subscription);
    updateElementDisplay(btnText                     .div, subscription && beta);
    updateElementDisplay(btnShape                    .div, subscription && beta);
    updateElementDisplay(btnGroup                    .div, subscription && beta);

    updateElementDisplay(menuItemLogObjectUpdates    .div, subscription && beta);
    
    updateElementDisplay(menuItemList                .div, subscription && beta);
    updateElementDisplay(menuFlowSep1                .div, subscription && beta);
    //updateElementDisplay(menuItemExpandList          .div, subscription && beta);
    updateElementDisplay(menuItemItems               .div, subscription && beta);
    updateElementDisplay(menuFlowSep2                .div, subscription && beta);
    updateElementDisplay(menuItemSelect              .div, subscription && beta);
    updateElementDisplay(menuItemCount               .div, subscription && beta);
    updateElementDisplay(menuFlowSep3                .div, subscription && beta);
    updateElementDisplay(menuItemRepeat              .div, subscription && beta);
    // updateElementDisplay(menuItemCache               .div, subscription && beta);
    // updateElementDisplay(menuItemCopy                .div, subscription && beta);
    
    updateElementDisplay(menuItemSeries              .div, subscription && beta);    
    updateElementDisplay(menuItemSolve               .div, subscription && beta);    
    updateElementDisplay(menuItemNumberSep1          .div, subscription && beta);
    updateElementDisplay(menuItemAnimate             .div, subscription && beta);    
    updateElementDisplay(menuItemNumberSep2          .div, subscription && beta);
    updateElementDisplay(menuItemNumberConvertToText .div, subscription && beta);
    
    updateElementDisplay(menuItemCorrectColor        .div, subscription);
    updateElementDisplay(menuItemColorSep1           .div, subscription);
    updateElementDisplay(menuItemColorblind          .div, subscription);
    //updateMenuItemDisplay(menuItemColorBlend        .div, beta);

    //updateMenuItemDisplay(menuItemStyleFill         .div, subscription && beta);
    updateElementDisplay(menuItemStyleStroke         .div, subscription && beta);
    //updateMenuItemDisplay(menuItemStyleSep1         .div, subscription && beta);
    
    //updateMenuItemDisplay(menuItemNodeCopyAsJsCode    .div, subscription && beta);
    updateElementDisplay(menuItemNodeCopyAsJsFunction.div, subscription && beta);

    updateElementDisplay(shortcutCopyAsJavascript        , subscription && beta);


    graph.nodes.forEach(n => n.updateSubscribeStatus(subscription));
}



function updateMenuItemShowDebugMenu()
{
    updateElementDisplay(menuItemDebug.div, settings.showDebugMenu);
}

 

function updateElementDisplay(menuItem, enable)
{
    menuItem.style.display = enable ? 'block' : 'none';
}



function loadLocalSettings()
{
    uiGetLocalData('dataMode'                     );
    uiGetLocalData('debugMode'                    );
        
    uiGetLocalData('enableZoomedOutParams'        );
    uiGetLocalData('minZoomForParams'             );
    uiGetLocalData('showBoolValues'               );
    uiGetLocalData('showPages'                    );
    uiGetLocalData('showOperationResults'         );
    uiGetLocalData('showClearUndoWarning'         );
    uiGetLocalData('showDebugMenu'                );
        
    uiGetLocalData('showNodeId'                   );

    uiGetLocalData('showTooltipLongText'          );
    uiGetLocalData('showTooltipColorInterpolation');
    uiGetLocalData('showTooltipColorBlindness'    );
    uiGetLocalData('showTooltipColorContrast'     );

    uiGetLocalData('enableBetaFeatures'           );
            
    uiGetLocalData('logMessages'                  );
    uiGetLocalData('logActions'                   );
            
    uiGetLocalData('logLoading'                   );
    uiGetLocalData('logRequests'                  );
    uiGetLocalData('logValueUpdates'              );
    uiGetLocalData('logObjectUpdates'             );
    uiGetLocalData('logStyleUpdates'              );
            
    uiGetLocalData('logRawLoadPages'              );
    uiGetLocalData('logRawLoadNodes'              );
    uiGetLocalData('logRawLoadConnections'        );
        
    uiGetLocalData('logRawSavePages'              );
    uiGetLocalData('logRawSaveNodes'              );
    uiGetLocalData('logRawSaveConnections'        );
        
    uiGetLocalData('logRawRequests'               );
    uiGetLocalData('logRawValues'                 );
}


function crashAssert(condition, error)
{
    if (condition) return;

    initCrashDialog(error, null);
    showCrashDialog();

    console.assert(false, error);
}



function initCrashDialog(event, error)
{
    if (error)
    {
        let stack = error.stack
            .replaceAll('<anonymous>', '')
            .replaceAll('.<', '<')
            .replaceAll(/\(?data[a-zA-Z0-9/,;:=]*\)?/g, '')
            .replaceAll('at \n', '')
            .replaceAll('at ', '<br/>&nbsp;&nbsp;&nbsp;&nbsp;at ')
            .replaceAll(/\(:[^\)]*\)/g, '')
            .replaceAll(/at :[0-9]+:[0-9]+/g, '');

        crashDetails.innerHTML += stack + '<br/>';
    }
    else
        crashDetails.innerHTML += event + '<br/>';
        

    if (!crashed)
    {
        crashBack.addEventListener('pointerdown', e => { e.preventDefault(); });

        btnCrashRestart.addEventListener('click', () => uiRestartGenerator(true));

        crashDetails.addEventListener('pointerup', e =>
        {
            if (e.button == 2)
            {
                e.preventDefault();
                e.stopImmediatePropagation();

                initCopyMenu();
                menuCopy.showAt(e.clientX, e.clientY, false, false);
            }
        });
    }
}



function showCrashDialog()
{
    crashed = true;


    if (loadRestartTimer > -1) 
    {
        clearTimeout(loadRestartTimer);
        loadRestartTimer = -1;
    }


    crashBack  .style.display = 'block';
    crashDialog.style.display = 'block';

    dialogShown = true;
}



function hideCrashDialog()
{
    crashBack  .style.display = 'none';
    crashDialog.style.display = 'none';

    dialogShown = false;
}


class Control
extends EventTarget
{
    param;

    id;
    
    name;
    savedName   = '';


    div;

    width;
    height;


    pointerEvents = true;


    measureData = { divBounds: new Rect(0, 0, 0, 0) };
 

    
    constructor(div, param, id, name, width = defNodeWidth, height = defParamHeight)
    {
        super();


        this.div               = div ? div : createDiv();
        this.div.control       = this;
        

        this.param             = param;
        
        
        this.id                = id;
        this.name              = name;


        //this.div.style.display = 'inline';


        this.setSize(width, height);


        this.onstartchange     = new Event('startchange');
        this.onchange          = new Event('change');
        this.onconfirm         = new Event('confirm');
    }



    setSize(w, h)
    {
        this.width            = w;
        this.height           = h;
        
        this.div.style.width  = w;
        this.div.style.height = Math.max(20, h);
    }



    updateMeasureData()
    {
        this.measureData = 
        {
            offsetRect: offsetRect(this.div),
            clientRect: clientRect(this.div)
        };
    }


    
    lockPointer(pointerId)
    {
        clearTimeout(this.clickTimer);

        this.div.requestPointerLock =    
               this.div.      requestPointerLock 
            || this.div.   mozRequestPointerLock
            || this.div.webkitRequestPointerLock;

        this.div.requestPointerLock();
    }



    unlockPointer(pointerId)
    {
        document.exitPointerLock =    
               document.      exitPointerLock    
            || document.   mozExitPointerLock
            || document.webkitExitPointerLock;

        document.exitPointerLock();
    }



    isPointerLocked()
    {
        return (document.      pointerLockElement === this.div 
             || document.   mozPointerLockElement === this.div
             || document.webkitPointerLockElement === this.div);
    }
}



function controlTimer_confirm(control)
{
    if (control.param)
        control.param.changing = false;
}


class EmptyControl
extends Control
{
    constructor(div, param)
    {
        super(div, param, NULL, NULL);
    }



    canReact(e)
    {
        return false;
    }
}



class NumberControl
extends Control
{
    bar;
    text;
    textbox;
    focus;

    extLeft;
    extRight;



    value;
    valueScale            = 1;

    min;
    max;

    displayMin;
    displayMax;

    thinMinus             = false;
    displayAbsolute       = false;
    
    epsilon               = Epsilon;

    acc;
     
    dec;
    displayDec;
    
    
    wrapValue             = false;

    
    showName              = true;
    showHex               = false;

               
    suffix;
    valueCanContainSuffix = false;
     
    dragReverse           = false;
    dragScale;
    wheelScale;
             
    backStyleLight        = 'rgba(255, 255, 255, 0.95)';
    valueStyleLight       = '#7772';
    textStyleLight        = '#000';
                
    backStyleDark         = 'rgba(56, 56, 56, 0.95)';
    valueStyleDark        = '#ffffff20';
    textStyleDark         = '#eee';
                
            
    enableChangeEvent     = true;
    
    successOnFocusOut     = false;
    keyBlur               = false;
    
    readOnly              = false;
     
    allowEditDecimals     = true;
    

    delayUse              = 0;
    delayUseTimer         = null;


    valueText             = '';
    overrideText          = '';

    showNanValueName      = true; // show the name even if the value is NaN
    showBar               = true;

    barTop                = 0;
    barBottom             = 1;
     
    ranges                = [];
    rangeDivs             = [];
    
    showExtRanges         = true;

    options               = []; // if dec == 0, show named choices instead of a value


    mouseOver             = false;
    buttonDown0           = false;
    buttonDown1           = false;
    shiftDown             = false;
    
    clickSize             = 4;
    moved                 = false;
         
    tabIndex              = 0;
    inFocus               = false;
    clicked               = false;
 
    startValue            = 0;
    oldValue; 
 

    confirmTimer          = null;
    
    
    
    constructor(div, param, id, name, showName, defaultValue, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER, dec = 0, dragScale = 0.05, wheelScale = 1, acc = 0, suffix = '')
    {
        super(div, param, id, name);


        this.showName              = showName;
        
        this.value                 = defaultValue;
    
        this.min                   = min;
        this.max                   = max;
    
        this.displayMin            = min;
        this.displayMax            = max;
    
        this.thinMinus             = false;
        this.displayAbsolute       = false;
        
        this.epsilon               = Epsilon;
    
        this.acc                   = acc;
         
        this.dec                   =
        this.displayDec            = dec;
             
        this.valueScale            = 1;
                    
        this.suffix                = suffix;
        this.valueCanContainSuffix = false;
         

        this.dragReverse           = false;
        this.dragScale             = dragScale;
        this.wheelScale            = wheelScale;
    

        this.bar                   = createDiv('numberControlBar');
        this.text                  = createDiv('numberControlText');
        this.focus                 = createDiv('numberControlFocus');
        this.extLeft               = createDiv('numberControlExt numberControlExtLeft');
        this.extRight              = createDiv('numberControlExt numberControlExtRight');


        this.div.appendChild(this.bar);
        this.div.appendChild(this.text);
        this.div.appendChild(this.focus);
        this.div.appendChild(this.extLeft);
        this.div.appendChild(this.extRight);


        this.initTextbox();
        this.initEvents ();
    }



    canReact(e)
    {
        if (   (   settings.enableZoomedOutParams
                || graph.currentPage.zoom > settings.minZoomForParams)
            && !this.delayUseTimer)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.param.node.header);

        return false;
    }



    startDelayUseTimer()
    {
        if (this.delayUseTimer)
            clearTimeout(this.delayTimer);

        this.delayUseTimer = setTimeout(() => 
        {
            this.delayUseTimer = false;
            this.updateCursor();    
        }, 
        this.delayUse);
    }



    setName(name)
    {
        this.name      = name;
        this.savedName = name;
        
        this.update();
    }



    setValue(value, fireChangeEvent = true, confirm = true, fullRange = true)
    {
        if (typeof value != 'number')
            console.assert(false, 'NumberControl.setValue(value) is ' + typeof value + ', must be a number');

            
        const oldValue = this.value;

        
        if (this.wrapValue)
        {
            const range = this.displayMax - this.displayMin;

            value %= range;

            while (value < this.displayMin) value += range;
        }

        else if (fullRange)
            value = Math.min(Math.max(this.min, value), this.max);

        else
            value = Math.min(Math.max(this.displayMin, value), this.displayMax);

         
        if (    isNaN(value) && !isNaN(oldValue)
            || !isNaN(value) &&  isNaN(oldValue)
            || Math.abs(value - oldValue) > Number.EPSILON)
        {
            if (   value > -this.epsilon
                && value <  0) // guard against -0
                value = 0;

            this.value = value;

            this.update();

            if (   fireChangeEvent
                && this.enableChangeEvent
                && value != oldValue)
                this.dispatchEvent(this.onchange);
        }


        if (   confirm
            && this.enableChangeEvent)
            this.dispatchEvent(this.onconfirm);
    }




    setSuffix(suffix, valueCanContainSuffix = false)
    {
        this.suffix                = suffix;
        this.valueCanContainSuffix = valueCanContainSuffix;
    }
    


    setMin(min, displayMin = min)
    {
        this.min        = min;
        this.displayMin = displayMin;
    }



    setMax(max, displayMax = max)
    {
        this.max        = max;
        this.displayMax = displayMax;
    }



    resetMin()
    {
        this.min        = Number.MIN_SAFE_INTEGER;
        this.displayMin = Number.MIN_SAFE_INTEGER;
    }



    resetMax()
    {
        this.max        = Number.MAX_SAFE_INTEGER;
        this.displayMax = Number.MAX_SAFE_INTEGER;
    }



    setDecimals(dec, dspDec = dec)
    {
        this.dec        = dec;
        this.displayDec = dspDec;
    }



    update()
    {
        if (typeof this.value !== 'number')
            console.assert(false, 'NumberControl.update() value is ' + typeof this.value + ', must be a number');

        if (!this.measureData.offsetRect)
            return;

        const sx =  this.measureData.offsetRect.x;
        const sw =  this.measureData.clientRect.width;
        const sh =  this.measureData.clientRect.height;

        const cx = -this.displayMin / (this.displayMax - this.displayMin) * sw;

        const v = 
            this.displayAbsolute
            ?   Math.abs(this.value) 
              / (this.value < 0 
                 ? (-this.displayMin - Math.max(0, this.displayMin))
                 : ( this.displayMax - Math.max(0, this.displayMin)))
            : this.value / (this.displayMax - this.displayMin);


        this.updateBar(sx, cx, v, sw, sh);
        this.updateColors();
        this.updateText();
        this.updateFocus(sw, sh);
        this.updateExt();

        this.updateRanges(sw, sh);
    }



    updateBar(sx, cx, v, sw, sh)
    {
        if (this.dragReverse)
            v *= -1;

            
        if (    isNaN(this.value)
            || !this.showBar)
            this.bar.style.display = 'none';

        else
        {
            this.bar.style.display = 'block';

            const x =
                this.displayAbsolute
                ? 0
                : (v >= 0
                   ? cx
                   : cx + v * sw);

            this.bar.style.left   = Math.max(0, x);
            this.bar.style.width  = Math.min(Math.max(0, Math.round(Math.abs(v) * sw) + Math.min(0, x)), this.measureData.offsetRect.width);

            this.bar.style.top    = sh * this.barTop;
            this.bar.style.height = sh * (this.barBottom - this.barTop);
        }
    }



    updateColors()
    {
        this.div .style.background = darkMode ? this. backStyleDark : this. backStyleLight;
        this.bar .style.background = darkMode ? this.valueStyleDark : this.valueStyleLight;
        this.text.style.color      = darkMode ? this. textStyleDark : this. textStyleLight;
    }



    updateText()
    {
        if (this.overrideText != '')
            this.text.innerHTML = this.overrideText;

        else
        {
            this.text.innerHTML = '';
            
            if (   this.name.length > 0
                && this.showName
                && (  !isNaN(this.value) 
                    || this.showNanValueName))
            {
                const nameStyle = 
                    darkMode 
                    ? rgba2style(rgb_a(style2rgba(this.textStyleDark ), 0.4))
                    : rgba2style(rgb_a(style2rgba(this.textStyleLight), 0.6));

                this.text.innerHTML += '<span style="color: ' + nameStyle + ';">' + this.name + "</span>&nbsp;&nbsp;";
            }
            
            const valueText = this.getValueText();

            this.text.innerHTML += 
                  valueText 
                + (valueText == UNKNOWN_DISPLAY
                   ? ''
                   : this.suffix);
        }
    }



    updateFocus(sw, sh)
    {
        this.focus.style.left   = 0;
        this.focus.style.top    = 0;
        this.focus.style.width  = sw;
        this.focus.style.height = sh;
    }



    updateExt()
    {
        if (this.shiftDown)
        {
            const style = 
                darkMode
                ? this.textStyleDark
                : this.textStyleLight;
                
            this.extLeft .innerHTML =
            this.extRight.innerHTML =
                '<svg width="1" height="10" viewBox="0 0 1 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 4H1V6H0V4Z"  fill="'+style+'"/><path d="M0 8H1V10H0V8Z" fill="'+style+'"/><path d="M0 0H1V2H0V0Z"  fill="'+style+'"/></svg>';

            this.extLeft .style.display = this.min < this.displayMin ? 'block' : 'none';
            this.extRight.style.display = this.max > this.displayMax ? 'block' : 'none';
        }
        else
        {
            this.extLeft .style.display = 'none';
            this.extRight.style.display = 'none';
        }
    }



    updateCursor()
    {
        this.div.style.cursor = 
               this.readOnly 
            || containsChild(this.div, this.textbox)
            || graphView.wheelTimer 
            || this.delayUseTimer
            || overNumberControlCtrl == this
            ? 'default'
            : 'ew-resize';
    };
    
    
    
    getValueText()
    {
        if (this.valueText != '')
        {
            return this.valueText;
        }
        else if (  !isEmpty(this.options)
                 && this.displayDec == 0)
        {
            if (   this.value <  0 
                || this.value >= this.options.length)
                return NAN_DISPLAY;
            else
                return this.options[Math.round(this.value)];
        }
        else
        {
            if (isNaN(this.value))
                return NAN_DISPLAY;


            let str;
          

            const val = this.value * this.valueScale;

            if (Math.abs(val) >= 100_000_000_000)
                str = val.toExponential(1);
            else
            {
                str = numToString(val, this.displayDec, this.showHex);

                if (Math.abs(val) >= 10_000) // add thousand separators
                {
                    for (let i = str.length-3; i > 0; i -= 3)
                        str = str.substring(0, i) + '' + str.substring(i);
                }
                
                str = str.toUpperCase();
            }


            if (this.thinMinus)
                str = str.replace('-', '<span style="font-weight: 300;">-</span>');


            return str;
        }
    }
}



NumberControl.prototype.initTextbox = function()
{
    this.textbox = createTextbox('numberControlTextbox');
    this.textbox.control = this;
    


    this.textbox.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();
    });
    
    
    
    this.textbox.addEventListener('pointerup', e =>
    {
        e.stopPropagation();

        if (e.button == 2)
        {
            initTextMenu(this.textbox);
            menuText.showAt(e.clientX, e.clientY, false, false);
        }
    });



    this.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();

        this.textbox.style.cursor = 'default';
    });



    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyX'
            && getCtrlKey(e)
            && !this.readOnly)
        {
            //
        }

        else if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            //
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !this.readOnly)
        {
            //
        }
        
        else if (   (   e.code == 'Enter'
                || e.code == 'NumpadEnter')
            && !this.readOnly)
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(false);
        }
        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            if (this.param)
            {
                const params = this.param.node.getTabParams();
                let   index  = params.indexOf(this.param);

                this.textbox.keyBlur = true;
                this.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (params[--index].controls[0].readOnly); // ; on purpose
                    params[index].controls[0].showTextbox();
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (params[++index].controls[0].readOnly); // ; on purpose
                    params[index].controls[0].showTextbox();
                }
            }

            // let tabs  = document.querySelectorAll('.numberControl, .selectControl, .select, .menuSelect, button, .menuButton');
            // let index = this.tabIndex;

            // for (let i = 0; i < tabs.length; i++) 
            // {
            //     if (   e.shiftKey && tabs[i].tabIndex == index - 1
            //         ||               tabs[i].tabIndex == index + 1) 
            //     {
            //         if (tabs[i].className == 'slider')
            //             tabs[i].showTextbox();
            //         else 
            //         {
            //             document.activeElement.blur();
            //             tabs[i].focus();
            //         }

            //         break;
            //     }
            // }
        }

        else if ((   e.key == 'ArrowUp'
                  || e.key == 'ArrowDown')
              && !this.readOnly)
        {
            e.preventDefault();

            let text = this.textbox.value;

            if (   this.valueCanContainSuffix   
                && text.length >= this.suffix.length
                && text.substring(text.length - this.suffix.length) == this.suffix)
                text = text.substring(0, text.length - this.suffix.length);


            if (this.textbox.selectionStart != this.textbox.selectionEnd)
                this.textbox.selectionStart =  this.textbox.selectionEnd;

            const pos = Math.min(
                this.textbox.selectionStart,
                text.length);

            const revPos = text.length - pos;

            const val  = parseFloat(text);
            const sign = e.key == 'ArrowUp' ? 1 : -1;

            let decIndex = text.indexOf('.');
            if (decIndex < 0) decIndex = text.indexOf(',');
            
            if (   text[0] != '-'
                || pos > 0)
            {
                if (decIndex < 0) // integer
                {
                    let dec = Math.pow(10, revPos);

                    if (e.shiftKey) 
                        dec *= 10;

                    this.setValue((val + sign * dec) / this.valueScale);
                    this.updateTextbox();
                }
                else // floating point
                {
                    const _edit = pos - decIndex - 1;

                    let  dec  = 
                        _edit < 0
                        ?     Math.pow(10, -_edit - 1)
                        : 1 / Math.pow(10,  _edit    );

                    if (e.shiftKey) 
                        dec *= 10;

                    this.displayDec = text.length-1 - decIndex;
                    this.setValue((val + sign * dec) / this.valueScale);
                    this.updateTextbox();
                }

                this.textbox.selectionStart =
                this.textbox.selectionEnd   = this.textbox.savedValue.length - revPos - this.suffix.length;


                if (this.param) this.param.changing = true;
                if (this.confirmTimer) clearTimeout(this.confirmTimer);
                this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
            }
        }
        // else if (e.code == 'KeyZ'
        //       && getCtrlKey(e))
        // {
        //     // e.preventDefault();
        //     //e.stopImmediatePropagation();

        //     //      if (e.shiftKey && !actionManager.redoing) actionManager.redo();
        //     // else if (              !actionManager.undoing) actionManager.undo();
            
        //     // this.updateTextbox();
        // }
        else if (this.readOnly)
            e.preventDefault();
        //{
        //     let curVal = this.textbox.value;

        //     if (      e.key.length == 1
        //            && !isDigit(e.key)
        //            && e.key != NAN_DISPLAY
        //            && (   !this.valueCanContainSuffix
        //                || !this.suffix.includes(e.key))
        //            && (   !this.showHex 
        //                || !isHexDigit(e.key))
        //            && (   this.showHex
        //                ||    e.key != '.'
        //                   && e.key != ',')
        //            && !(   ((      e.code == 'Minus'
        //                         || e.code == 'NumpadSubtract')
        //                      && !curVal.includes('-'))
        //                 && this.min < 0)
        //         ||     this.readOnly
        //            && !isArrowKey(e.code))
        //         e.preventDefault();

        //     if (    e.key == '.'
        //         &&  this.dec == 0
        //         && !this.allowEditDecimals)
        //         e.preventDefault();
                
                    
        //     curVal =
        //            curVal ==     NAN_DISPLAY
        //         || curVal == UNKNOWN_DISPLAY
        //         ? ''
        //         :   curVal.substring(0, this.textbox.selectionStart) 
        //           + curVal.substring(this.textbox.selectionEnd, curVal.length);

                  
        //     const nextVal = parseFloat(curVal + e.key);

        //     if (   nextVal < this.min - 0.001
        //         || nextVal > this.max)
        //         e.preventDefault();            
        //}
    });



    // this.textbox.addEventListener('paste', e =>
    // {
    //     //e.preventDefault();
    //     //e.stopPropagation();
        

    //     // const str = e.clipboardData.getData('text/plain');

    //     // let val = 
    //     //     this.showHex
    //     //     ? parseInt(str, 16)
    //     //     : parseFloat(str);

    //     // val = Math.min(Math.max(this.min, val), this.max);
        
    //     // const strVal = isNaN(val) ? '' : val;

    //     // this.textbox.value = 
    //     //       this.textbox.value.substring(0, this.textbox.selectionStart)
    //     //     + strVal
    //     //     + this.textbox.value.substring(this.textbox.selectionEnd);

    //     // this.setValue(
    //     //     parseFloat(this.textbox.value), 
    //     //     true, //!this.textbox.managing, 
    //     //     true);
    // });



    
    this.textbox.addEventListener('focus', () =>
    {
        if (currentTooltip) 
            hideTooltip(currentTooltip);
    });
    


    this.textbox.addEventListener('focusout', () =>
    {
        if (!this.textbox.keyBlur) this.textbox.finish(this.textbox.value.trim() != '');
        else                       this.textbox.keyBlur = false;


        if (this.savedSuccessOnFocusOut != null)
        {
            this.successOnFocusOut      = this.savedSuccessOnFocusOut;
            this.savedSuccessOnFocusOut = null;
        }


        this.div.parentNode.removeChild(this.textbox);
        this.clicked = false;
    });
    


    this.textbox.addEventListener('wheel', e =>
    {
        e.stopPropagation();
        forwardEvent(e, this.div);
    });
    


    this.textbox.finish = (success, focusControl = true) =>
    {
        let   value      = this.textbox.value;
        const savedValue = this.textbox.savedValue;

        value = value.replace(this.suffix, '');
        
        
        let isHex = this.showHex;

        if (   value.length >= 2
            && value.substring(0, 2) == '0x')
        {
            isHex = true;
            value = value.substring(2);   
        }

        
        let val = 
            value.trim() == NAN_DISPLAY 
            ? Number.NaN 
            : (isHex
               ? parseInt(value, 16) 
               : parseFloat(value));


        let savedVal = 
            savedValue.trim() == NAN_DISPLAY  
            ? Number.NaN 
            : (isHex
               ? parseInt(savedValue, 16) 
               : parseFloat(savedValue));

        
        if (!isNaN(val))
            val /= this.valueScale;

       
        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           val,
            'oldValue':        savedVal,
            'valueString':     value     .replace(this.suffix, ''),
            'oldValueString':  savedValue.replace(this.suffix, ''),
            'preventSetValue': false }});

        this.dispatchEvent(e);


        if (!e.preventSetValue)
        {
            if (success) 
            {
                this.setValue(
                       value.trim() != '' 
                    && value.trim() != NAN_DISPLAY
                    ? val 
                    : savedVal);
            }
            else
                this.setValue(savedVal);
        }
         
        
        this.textbox.blur();

        this.text.style.display = 'block';

        if (   this.inFocus
            && focusControl)
            this.div.focus();
    };    
};



NumberControl.prototype.showTextbox = function()
{
    this.text.style.display = 'none';

    this.inFocus = 
           hasFocus(this.div)
        && !this.clicked;

        
    this.textbox.style.width     = this.div.offsetWidth;
    this.textbox.style.height    = defParamHeight;
    this.textbox.style.textAlign = 'center';


    this.updateTextbox();
    
    this.div.parentNode.appendChild(this.textbox);
    
    this.textbox.focus();
    this.textbox.select();

    this.textbox.style.cursor = 'default';
};



NumberControl.prototype.updateTextbox = function()
{
    this.textbox.value =
        (   isNaN(this.value)
            ? NAN_DISPLAY
            : numToString(
                  this.value * this.valueScale, 
                  this.displayDec, 
                  this.showHex
              ).toUpperCase())
         + (  !isNaN(this.value)
            && this.valueCanContainSuffix 
            ? this.suffix 
            : '');
        
    this.textbox.savedValue = this.textbox.value;
};


class NumberControlRange
{
    start;
    end;

    background;

    top;
    bottom;


    constructor(start, end = start, background = 'magenta', top = 0, bottom = 1)
    {
        this.start      = start;
        this.end        = end;

        this.background = background;

        this.top        = top;
        this.bottom     = bottom;
    }



    copy()
    {
        return new NumberControlRange(
            this.start,
            this.end,
            this.background,
            this.top,
            this.bottom);
    }
}



NumberControl.prototype.updateRanges = function(controlWidth, controlHeight)
{
    if (this.overrideText != '') // assuming this is only used in emergencies where ranges are irrelevant
        this.resetRangeDivs();

    else
    {
        if (   this.showExtRanges
            && (   this.min < this.displayMin
                || this.max > this.displayMax))
        {
            this.resetRanges();

            const warnLineStyle = getWarningRangeStyle();

            const val = (this.value - this.displayMin) / (this.displayMax - this.displayMin);

            if (this.value < this.displayMin) this.ranges.push(new NumberControlRange(0, Math.min(-val, 1), warnLineStyle, 0.8));
            if (this.value > this.displayMax) this.ranges.push(new NumberControlRange(2-Math.min(val, 2), 1, warnLineStyle, 0.8));    
        }


        if (this.ranges.length == this.rangeDivs.length) // update
        {
            for (let i = 0; i < this.ranges.length; i++)
            {
                updateControlRangeDiv(
                    this.ranges   [i],
                    this.rangeDivs[i],
                    controlWidth,
                    controlHeight);
            }
        }
        else // recreate
        {
            this.resetRangeDivs();

            for (const range of this.ranges)
            {
                const div = createDiv('numberControlRange');
                
                div.style.zIndex = 0;

                this.rangeDivs.push(div);
                this.div.appendChild(div);
            
                updateControlRangeDiv(range, div, controlWidth, controlHeight);
            }
        }
    }
};



NumberControl.prototype.resetRanges = function()
{
    this.ranges = [];
    this.resetRangeDivs();        
};



NumberControl.prototype.resetRangeDivs = function()
{
    for (const div of this.rangeDivs)
        if (this.div.contains(div))
            this.div.removeChild(div);

    this.rangeDivs = [];
};



function getWarningRangeStyle()
{
    return darkMode
        ? 'rgba(255, 96, 96, 0.5)'
        : 'rgba(255, 0, 0, 0.16)';
}



function updateControlRangeDiv(range, div, controlWidth, controlHeight)
{
    if (range.start == range.end)
        div.style.display = 'none';
    else
    {
        div.style.display    = 'block';
        div.style.left       = controlWidth * range.start;  
        div.style.top        = range.top * controlHeight;
        div.style.width      = controlWidth * (range.end - range.start);
        div.style.height     = (range.bottom - range.top) * controlHeight;
        div.style.background = range.background;
    }
};



NumberControl.prototype.initEvents = function()
{
    this.div.addEventListener('pointerenter', e =>
    {
        const param = this.param;
        

        if (this.delayUse > 0)
        {
            this.div.style.cursor = 'default';
            this.startDelayUseTimer();
        }


        if (!this.canReact(e))
            return;


        //tooltip_pointerLeave(currentTooltip);


        overNumberControl = this;


        if (panMode)
        {
            setCursor(panCursor);
            return;
        }


        if (   !graphView.spaceDown
            &&  this.pointerEvents)
        {
            if (   graphView.tempConn
                ||   !settings.enableZoomedOutParams
                   && graph.currentPage.zoom <= settings.minZoomForParams)
                this.div.style.cursor = 'default';
            else
                this.updateCursor();

                    
            const colShadow = 
                darkMode
                ? 'rgba(255, 255, 255, 0.1)'
                : 'rgba(0, 0, 0, 0.1)';

            if (param)
            {
                this.focus.style.boxShadow = '0 1px 0 0 ' + colShadow + ' inset';

                if (    param.node
                    &&  param.node.params.includes(param)
                    && !isLastInArray(param.node.params, param))
                    this.focus.style.boxShadow += ', 0 -1px 0 0 ' + colShadow + ' inset';
            }
            else
            {
                this.focus.style.boxShadow  = '0 0 0 1px ' + colShadow + ' inset ';
            }


            this.focus.style.visibility = 'visible';
            this.focus.style.opacity    = '100%';
    
            this.update();
        }
    });



    this.div.addEventListener('pointerdown', e =>
    {
        const param = this.param;


        if (e.button == 0)
        {
            this.buttonDown0  = true;
            this.buttonDown0_ = true;
        }


        if (!this.canReact(e))
            return;


        if (   graphView.spaceDown
            || panMode)
            return;

        
        window.focus();

        hideAllMenus();


        if (this.param.node.div.style.zIndex < graphView.getTopNodeIndex())
            graphView.putNodeOnTop(this.param.node);


        if (e.button == 0)
        {
            if (!this.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let nodeDiv = 
                   this.parentNode
                && this.parentNode.parentNode
                && this.parentNode.parentNode.parentNode
                ? this.parentNode.parentNode.parentNode
                : null;

            if (   nodeDiv 
                && nodeDiv.className == 'node') 
                graphView.putNodeOnTop(nodeDiv.node);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();
                

            this.moved        = false;
            this.clientX      = e.clientX;
            this.movedX       = 0;


            if (!this.readOnly)
            {
                this.oldValue   = this.value;
                this.startValue = this.value;
                this.prevValue  = this.value;
                this.sx         = e.clientX;

                this.clickTimer = setTimeout(() => 
                {
                    if (!document.menuHadFocus)
                    {
                        numberControlChanging = this;
                        this.shiftDown = e.shiftKey;
                        this.update();

                        this.moved = true;
                        this.lockPointer(e.pointerId);
                    }
                }, 
                500);
            }


            if (   !param
                || !param.node.selected)
                this.focus.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand) inset';

            else
            {
                this.focus.style.boxShadow = '0 1px 0 0 var(--figma-color-bg-brand) inset';
                    
                if (param.index < param.node.params.length-1)
                    this.focus.style.boxShadow += ', 0 -1px 0 0 var(--figma-color-bg-brand) inset';
            }


            // I don't want to focus here, but I do want to take focus away from elsewhere
            document.activeElement.blur();


            if (param)
                param.noUpdate = true;  
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            this.buttonDown1 = true;
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            this.buttonDown2 = true;

            if (    param
                && !isEmpty(this.options))
            {
                initSelectParamMenu(param);
                menuSelectParam.showAt(e.clientX, e.clientY, false);
            }
        }
    });



    this.div.addEventListener('pointermove', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        if (panMode)
        {
            setCursor(panCursor);
            return;
        }

        if (!this.pointerEvents)
            return;
        


        // if (   !document.canResizeL
        //     && !document.canResizeR
        //     && !document.canResizeB)
            this.updateCursor();


        let rect = boundingRect(this.div);
        
        this.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top
            && e.clientY <  rect.bottom;


        this.clientX = e.clientX;

        
        if (    this.buttonDown0
            && !this.readOnly)
        {
            if (this.isPointerLocked())
            {
                numberControlChanging = this;

                this.movedX += e.movementX;
                
                if (!isNaN(this.value))
                {
                    const dx       = this.movedX * (this.dragReverse ? -1 : 1);
                    const adaptive = 10 * Math.pow(Math.abs(dx), this.acc);
                    const grain    = Math.pow(10, -this.dec);
                    const drag     = grain * sqr(this.dragScale);

                    const val      = this.startValue + dx * drag * adaptive;

                    
                    // reset control movement at the limits for better UX
                    const min = e.shiftKey ? this.min : this.displayMin;
                    const max = e.shiftKey ? this.max : this.displayMax;

                    this.setValue(
                        Math.round(val / grain) * grain, 
                        true, 
                        false,
                        e.shiftKey);


                    if (   val <= min
                        || val >= max)
                    {
                        this.movedX     = 0;
                        this.startValue = this.value;
                        this.sx         = e.clientX;
                    }


                    if (this.value != this.prevValue)
                        pushUpdateFromParam(null, [param.node], param);

                    this.prevValue = this.value;
                }


                this.shiftDown = e.shiftKey;
            }
            else
            {
                if (Math.abs(e.clientX - this.sx) > this.clickSize/2)
                {
                    this.moved = true;
                    this.lockPointer(e.pointerId);

                    this.dispatchEvent(this.onstartchange);
                }
            }
        }
        else if (graphView.tempConn
              && param)
        {
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

            if (    graphView.tempConn.output
                &&  param.input
                &&  param.input.canConnectFrom(graphView.tempConn.output)
                && !graphView.tempConn.output.node.isOrFollows(param.node)
                && (  !param.input.connected // not already connected to this input
                    || param.input.connectedOutput != graphView.tempConn.output
                    || param.input == savedInput))
            {
                graphView.overInput = param.input;
                    
                param.input.mouseOver = true;
                param.input.updateControl();

                const rect = boundingRect(param.input.div);

                graphView.tempConn.wire.inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());
            }
            else if ( graphView.tempConn.input
                  &&  param.output
                  &&  graphView.tempConn.input.canConnectFrom(param.output)
                  && !param.node.isOrFollows(graphView.tempConn.input.node))
            {
                graphView.overOutput = param.output;
                    
                param.output.mouseOver = true;
                param.output.updateControl();


                const rect = boundingRect(param.output.div);

                graphView.tempConn.wire .outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());


                graphView.tempConn.input.updateControl();
            }
        }
        else if (this.readOnly)
        {
            this.moved = true;
        }
    });
    
    
    
    this.div.addEventListener('pointerleave', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        overNumberControl = null;


        if (panMode)
            return;


        this.div.style.cursor       = 'default';
        
        this.focus.style.visibility = 'hidden';
        this.focus.style.opacity    = 0;

        this.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }
        }
    });



    this.div.addEventListener('losecapture', () =>
    {
        this.buttonDown0 = false;
        this.buttonDown1 = false;
        this.buttonDown2 = false;
        this.mouseOver   = false;
        this.shiftDown   = false;

        numberControlChanging = null;
        
        this.update();
    });



    this.div.addEventListener('pointerup', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        if (panMode)
            return;


        clearTimeout(this.clickTimer);

  
        if (this.isPointerLocked())
        {
            this.setValue(
                this.value,
                false, 
                true,
                e.shiftKey);
        }


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(param.node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e));
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !param.node.isOrFollows(graphView.tempConn.input.node)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e));
                graphView.overOutput.endConnection();
            }
        }
        
        else if (this.moved
              || document.menuHadFocus)
        {
            this.unlockPointer(e.pointerId);

            if (param)
                param.noUpdate = false;  

            this.shiftDown        = false;
            numberControlChanging = null;
 
            this.update();
            return;            
        }

        else if (this.buttonDown0_)
        {
            this.clicked = true;
            this.showTextbox();
        }


        if (e.button == 0) 
        {
            this.buttonDown0 = false;
            this.shiftDown   = false;

            numberControlChanging = null;


            overNumberControl = null;
            this.updateCursor();
            this.startDelayUseTimer();
        }

        else if (e.button == 1) 
            this.buttonDown1 = false;

        else if (e.button == 2) 
        {
            e.stopPropagation();
            this.buttonDown2 = false;
        }



        this.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', e =>
    {
        if (   e.button == 0 
            && this.buttonDown0)
        {
            this.buttonDown0 = false;
            this.unlockPointer(e.pointerId);

            this.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';
        }
        else if (   e.button == 1
            && this.buttonDown1)
        {
            this.buttonDown1 = false;            
        }
    });


    
    this.div.addEventListener('wheel', e =>
    {
        const param = this.param;


        if (!this.canReact(e))
            return;


        if (  !this.pointerEvents
            || panMode
            || graphView.wheelTimer)
            return;


        const touchpad = isTouchpad(e);

        if (touchpad)
        {
            e.preventDefault();
            return;
        }


        const dWheelX = e.deltaX /  20 * (this.dragReverse ? -1 : 1);
        const dWheelY = e.deltaY / 100 * (this.dragReverse ? -1 : 1);


        if (   !getCtrlKey(e)
            && !this.buttonDown1)
        {
            e.stopPropagation();

            if (!this.readOnly)
            {
                if (   document.activeElement
                    && (   document.activeElement.tagName.toLowerCase() == 'input'
                        || document.activeElement.tagName.toLowerCase() == 'textarea')
                    && document.activeElement.control)
                    document.activeElement.control.textbox.finish(true, false);

                this.oldValue = this.value;

                const dec = Math.pow(10, -this.dec);

                const val =
                    touchpad
                    ? this.value -  dWheelX               * this.wheelScale * dec
                    : this.value + (dWheelY > 0 ? -1 : 1) * this.wheelScale * dec;


                this.setValue(val, true, true, false);

                if (this.param) this.param.changing = true;
                if (this.confirmTimer) clearTimeout(this.confirmTimer);
                this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
            }
        }
    });

    
    
    this.div.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            this.showTextbox();

        // else if (e.key == 'Shift')
        // {
        //     this.shiftDown = true;
        //     this.update();
        // }

    }, true);



    // this.div.addEventListener('keyup', e =>
    // {
    //     // if (e.key == 'Shift')
    //     // {
    //     //     this.shiftDown = true;
    //     //     this.update();
    //     // }

    // }, true);



    this.div.addEventListener('focus', () =>
    {
        if (   !graphView.spaceDown
            && !panMode
            && !this.buttonDown1
            &&  this.pointerEvents)
            this.showTextbox();
    });
}


class TextControl
extends Control
{
    value;


    textbox;
    placeholder;

    valueText         = '';


    enableChangeEvent = true;
    
    successOnFocusOut = false;
    keyBlur           = false;

    
    readOnly          = false;
    

    confirmTimer      = null;
    
    

    constructor(div, param, id, name, defaultValue = '')
    {
        super(div, param, id, name);


        this.value = defaultValue;
        
        
        this.div.className = 'textControl';


        this.initTextarea();
        this.initEvents ();
        

        this.div.appendChild(this.textbox);


        createTooltipSrc(this.div, this.div, () => 
                settings.showTooltipLongText
            &&  scrollbarVisible(this.textbox)
            && !hasFocus(this.textbox)
            ? ttText
            : null);
    }    



    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.param.node.header);

        return false;
    }



    setName(name)
    {
        this.name      = name;
        this.savedName = name;
        
        this.update();
    }



    setSize(w, h)
    {
        super.setSize(w, h);

        if (this.textbox)
        {
            this.textbox.style.left   = (this.param && this.param.input ? 8 : 0) + 'px';
            
            this.textbox.style.width  = this.param && this.param.input ? 'calc(100% - 8px)' : '100%';
            this.textbox.style.height = Math.max(defParamHeight, h);
        }
    }



    setValue(value, fireChangeEvent = true, updateControl = true)
    {
        if (typeof value != 'string')
            console.assert(false, 'TextControl.setValue(value) is ' + typeof value + ', must be a string');

            
        this.value = value;

        if (updateControl)
            this.textbox.value = value;


        this.update();


        if (   fireChangeEvent
            && this.enableChangeEvent)
            this.dispatchEvent(this.onchange);
    }




    update()
    {
        if (typeof this.value !== 'string')
            console.assert(false, 'TextControl.update() value is ' + typeof this.value + ', must be a string');

        if (!this.measureData.offsetRect)
            return;

            
        this.textbox.placeholder = 
            this.value == NAN_CHAR
            ? UNKNOWN_DISPLAY
            : this.textbox.defPlaceholder;


        if (this.valueText != '')
            this.textbox.value = this.valueText;
        else if (this.value == NAN_CHAR)
            this.textbox.value = '';


        const  input = this.param && this.param. input;
        const output = this.param && this.param.output;

        const left  = input ? 12 : 0;
        const dw = 
              ( input ? 12 : 0) 
            + (output ? 12 : 0);

        this.textbox.style.left  = left + 'px';
        this.textbox.style.width = 'calc(100% - ' + dw + 'px)';
    }



    updateCursor()
    {
        this.textbox.style.cursor = 
               hasFocus(this.textbox)
            && graph.currentPage.zoom >= settings.minZoomForParams
            ? 'text'
            : 'default';
    }
}


TextControl.prototype.initTextarea = function()
{
    this.textbox                 = createTextarea('textControlTextarea');

    this.textbox.control         = this;
    this.textbox.defPlaceholder  = '...';
    this.textbox.placeholder     = this.textbox.defPlaceholder;

    this.textbox.style.height    = defParamHeight;
    this.textbox.style.textAlign = 'center';

    this.textbox.savedValue      = this.textbox.value;



    this.textbox.addEventListener('pointerdown', e =>
    {
        if (this.param.node.div.style.zIndex < graphView.getTopNodeIndex())
            graphView.putNodeOnTop(this.param.node);


        if (!this.canReact(e))
            return;

        
        if (this.readOnly)
        {
            e.preventDefault();
            //e.stopPropagation();

            //forwardEvent(e, this.param.node.div);

            return;
        }


        if (e.button == 1)
        {
            e.preventDefault();
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();
        }
        else    
            e.stopPropagation();
    });
    
    
    
    this.textbox.addEventListener('pointermove', e =>
    {
        e.preventDefault();
        //e.stopPropagation();
    });



    this.textbox.addEventListener('pointerup', e =>
    {
        e.stopPropagation();


        if (e.button == 2)
        {
            initTextboxMenu(this.textbox);
            menuTextbox.showAt(e.clientX, e.clientY, false, false);
        }
    });



    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   (      e.code == 'Enter'
                        && getCtrlKey(e)
                     || e.code == 'NumpadEnter')
                 && !this.readOnly)
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Tab')
        {
            e.preventDefault();
        }
    });



    this.textbox.addEventListener('input', e =>
    {
        //console.log('this.textbox.managing =', this.textbox.managing);
        this.setValue(
            this.textbox.value, 
            true, //!this.textbox.managing, 
            true);

        //this.textbox.managing = false;

        // if (this.param) this.param.changing = true;
        // if (this.confirmTimer) clearTimeout(this.confirmTimer);
        // this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
    });



    this.textbox.addEventListener('focus', () =>
    {
        hideAllMenus();

        if (currentTooltip) 
            hideTooltip(currentTooltip);

        this.updateCursor();
    });
    


    this.textbox.addEventListener('focusout', () =>
    {
        if (this.textbox.keyBlur)
            this.textbox.keyBlur = false;


        if (this.savedSuccessOnFocusOut != null)
        {
            this.successOnFocusOut      = this.savedSuccessOnFocusOut;
            this.savedSuccessOnFocusOut = null;
        }


        this.textbox.blur();
        this.clicked = false;

        this.updateCursor();


        window.getSelection().removeAllRanges();
    });
    


    this.textbox.addEventListener('wheel', e =>
    {
        if (graphView.wheelTimer)
            e.preventDefault();

        e.stopPropagation();
        forwardEvent(e, this.div);

        this.updateCursor();
    });
    


    this.textbox.finish = (success, focusControl = true) =>
    {
        let   value      = this.textbox.value;
        const savedValue = this.textbox.savedValue;

        value = value.replace(this.suffix, '');


        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           value     .replace(this.suffix, ''),
            'oldValue':        savedValue.replace(this.suffix, ''),
            'preventSetValue': false }});

        this.dispatchEvent(e);


        if (!e.preventSetValue)
        {
            if (success) 
            {
                this.setValue(
                    value != NAN_CHAR
                    ? value 
                    : savedValue);
            }
            else
                this.setValue(savedVal);
        }
         
        
        this.textbox.blur();


        if (   this.inFocus
            && focusControl)
            this.div.focus();
    };    
};



TextControl.prototype.showTextarea = function()
{
    this.inFocus = 
           hasFocus(this.div)
        && !this.clicked;

        
    this.focus.style.visibility = 'hidden';
    this.focus.style.opacity    = 0;


    this.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
    this.textbox.style.outline   = 'none';


    this.updateTextarea();

    
    this.textbox.focus();
    this.textbox.select();
};



TextControl.prototype.updateTextarea = function()
{
    this.textbox.value      = this.value;
    this.textbox.savedValue = this.value;
};



TextControl.prototype.getTextAlignment = function()
{
    const style = getComputedStyle(this.textbox);

    switch (style.textAlign)
    {
    case '': 
    case 'start': 
    case 'left':    return 'left';
    case 'center':  return 'center';
    case 'right':   return 'right';
    case 'justify': return 'justify';
    }
};


TextControl.prototype.initEvents = function()
{
    this.div.addEventListener('pointerenter', e =>
    {
        if (panMode)
        {
            setCursor(panCursor);
            return;
        }


        if (   !graphView.spaceDown
            &&  this.pointerEvents)
        {
            // if (graphView.tempConn)
            //     this.div.style.cursor = 'default';

                
            // this.textbox.style.visibility = 'visible';
            // this.textbox.style.opacity    = '100%';
    
            this.update();
        }
                else if (!currentTooltip)
            initTextTooltip(this.value);

    });



    this.div.addEventListener('pointermove', e =>
    {
        e.stopPropagation();


        if (panMode)
        {
            setCursor(panCursor);
            return;
        }

        if (!this.pointerEvents)
            return;

            
        let rect = boundingRect(this.div);
        
        this.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        this.clientX = e.clientX;

        
        if (    this.buttonDown0
            && !this.readOnly)
        {
            //forwardEvent(e, this.textbox);
            // ...
        }
        else if (graphView.tempConn
              && this.param)
        {
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;


            //console.log('graphView.tempConn =', graphView.tempConn);
            
            if (    graphView.tempConn.output
                &&  this.param.input
                &&  this.param.input.canConnectFrom(graphView.tempConn.output)
                && !graphView.tempConn.output.node.isOrFollows(this.param.node)
                && (  !this.param.input.connected // not already connected to this input
                    || this.param.input.connectedOutput != graphView.tempConn.output
                    || this.param.input == savedInput))
            {
                graphView.overInput = this.param.input;
                    
                this.param.input.mouseOver = true;
                this.param.input.updateControl();

                const rect = boundingRect(this.param.input.div);

                graphView.tempConn.wire .inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());
            }
            else if ( graphView.tempConn.input
                  &&  this.param.output
                  &&  graphView.tempConn.input.canConnectFrom(this.param.output)
                  && !this.param.node.isOrFollows(graphView.tempConn.input.node))
            {
                graphView.overOutput = this.param.output;
                    
                this.param.output.mouseOver = true;
                this.param.output.updateControl();


                const rect = boundingRect(this.param.output.div);

                graphView.tempConn.wire .outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());


                graphView.tempConn.input.updateControl();
            }
        }
        // else if (this.readOnly)
        // {
        //     this.moved = true;
        // }
    });



    this.div.addEventListener('pointerleave', e =>
    {
        if (panMode)
            return;


        // this.div.style.cursor       = 'default';
        
        // this.textbox.style.visibility = 'hidden';
        // this.textbox.style.opacity    = 0;

        this.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != this.param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire .inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != this.param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire .outputPos = point_NaN;

                graphView.tempConn.input.updateControl();
           }
        }
    });



    this.div.addEventListener('wheel', e =>
    {
        if (  !this.pointerEvents
            || panMode
            || graphView.wheelTimer)
            return;


        const touchpad = isTouchpad(e);

        if (touchpad)
        {
            e.preventDefault();
            return;
        }


        if (   !getCtrlKey(e)
            && !this.buttonDown1)
            e.stopPropagation();
    });
};


class ColorControl
extends Control
{
    showName          = false;
    showColor         = true;

    value;
    acc;
     
     
    dragReverse       = false;
    dragScale;
    wheelScale;
             
    backStyleLight    = 'rgba(255, 255, 255, 0.95)';
    valueStyleLight   = 'transparent';
    textStyleLight    = '#000';
                
    backStyleDark     = 'rgba(56, 56, 56, 0.95)';
    valueStyleDark    = 'transparent';
    textStyleDark     = '#eee';

    //fontSize          = 11;
             
    mouseOver         = false;
    buttonDown0       = false;
    buttonDown1       = false;
             
    clickSize         = 4;
    moved             = false;
         
    tabIndex          = 0;
    inFocus           = false;
    clicked           = false;
 
    oldValue; 
 
    enableChangeEvent = true;
    
    successOnFocusOut = false;
    keyBlur           = false;
    
    readOnly          = false;
     
    valueText         = '';
    
    

    constructor(div, param, id, name, showName, defaultValue, dragScale = 0.05, wheelScale = 1, acc = 0)
    {
        super(div, param, id, name);


        this.showName          = showName;
        this.showColor         = true;
    
        this.value             = defaultValue;
        this.acc               = acc;
         
        
        this.dragReverse       = false;
        this.dragScale         = dragScale;
        this.wheelScale        = wheelScale;
                 

        this.text  = createDiv('colorControlText');
        this.focus = createDiv('colorControlFocus');
    
        this.div.appendChild(this.text);
        this.div.appendChild(this.focus);

        
        this.initTextbox();
        this.initEvents ();
    }    
    

    
    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.param.node.header);

        return false;
    }



    setName(name)
    {
        this.name = name;
        this.update();
    };



    setValue(value, fireChangeEvent = true, confirm = true)
    {
        if (!(value instanceof ColorValue))
            console.assert(false, 'ColorControl.setValue(value) is ' + typeof value + ', must be a ColorValue');


        const oldValue = this.value.copy();

        this.value = value.copy();

        this.update();
        
        this.dispatchSetEvents(fireChangeEvent, value, oldValue, confirm);
    };




    dispatchSetEvents(fireChangeEvent, value, oldValue, confirm)
    {
        if (   fireChangeEvent
            && this.enableChangeEvent
            && !value.equals(this.prevValue))
            this.dispatchEvent(this.onchange);

        if (   confirm
            && this.enableChangeEvent
            && !value.equals(oldValue))
            this.dispatchEvent(this.onconfirm);
    }



    update()
    {
        if (!this.measureData.offsetRect)
            return;

        const sw = this.measureData.clientRect.width;
        const sh = this.measureData.clientRect.height;

        this.updateColors();
        this.updateText();
        this.updateFocus(sw, sh);
    };



    updateColors()
    {
        this.div    .style.background = darkMode ? this.backStyleDark : this.backStyleLight;
        this.textbox.style.background = 'transparent';

        this.text   .style.color = 
        this.textbox.style.color = darkMode ? this.textStyleDark : this.textStyleLight;//rgba2style(rgb_a(getTextColorFromBackColor(rgbStripeBack), 0.7));//rgb2style(rgbStripeBack);
    };



    updateText()
    {
        this.text.innerHTML = '';
        
        if (   this.name.length > 0
            && this.showName)
            this.text.innerHTML += (this.name.trim() != '' ? '<span class="colorControlName">' + this.name + '</span>&nbsp;&nbsp;' : '');

        this.text.innerHTML += 
               this.value.isValid()
            && rgbIsValid(this.value.toRgb())
            ? rgb2hex(this.value.toRgb())
            : UNKNOWN_DISPLAY;

        this.textbox.value = this.text.innerHTML;
    };



    updateFocus(sw, sh)
    {
        this.focus.style.left   = 0;
        this.focus.style.top    = 0;
        this.focus.style.width  = sw;
        this.focus.style.height = sh;
    };



    updateFocusBorder()
    {
        const colShadow = 
            darkMode
            ? 'rgba(255, 255, 255, 0.1)'
            : 'rgba(0, 0, 0, 0.1)';

        if (this.param)
        {
            this.focus.style.boxShadow = '0 1px 0 0 ' + colShadow + ' inset';

            if (    this.param.node
                &&  this.param.node.params.includes(this.param)
                && !isLastInArray(this.param.node.params, this.param))
                this.focus.style.boxShadow += ', 0 -1px 0 0 ' + colShadow + ' inset';
        }
        else
        {
            this.focus.style.boxShadow  = '0 0 0 1px ' + colShadow + ' inset ';
        }
    }
}


ColorControl.prototype.initTextbox = function()
{
    this.textbox = createTextbox('colorControlTextbox');
    this.textbox.control        = this;
    this.textbox.shown          = false;



    this.textbox.addEventListener('pointerdown', e =>
    {
        e.stopImmediatePropagation();
    });



    this.textbox.addEventListener('pointerup', e =>
    {
        e.stopPropagation();

        if (e.button == 0)
        {
            if (!this.textbox.shown)
                this.textbox.select();
    
            this.textbox.shown = true;
        }
        else if (e.button == 2)
        {
            initTextMenu(this.textbox);
            menuText.showAt(e.clientX, e.clientY, false, false);
        }
    });



    this.textbox.addEventListener('pointermove', e =>
    {
        e.stopPropagation();
        this.textbox.style.cursor = 'default';
    });



    this.textbox.addEventListener('focus', e =>
    {
        if (   this.textbox.value ==     NAN_DISPLAY
            || this.textbox.value == UNKNOWN_DISPLAY)
            this.textbox.value = NAN_DISPLAY;
    });



    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyX'
            && getCtrlKey(e)
            && !this.readOnly)
        {
            //
        }

        else if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            // 
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e)
              && !this.readOnly)
        {
            // 
        }
        
        else if (   (   e.code == 'Enter'
                || e.code == 'NumpadEnter')
            && !this.readOnly)
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyBlur = true;
            this.textbox.finish(false);
        }
        else if (e.code == 'Tab')
        {
            e.preventDefault();
            //e.stopPropagation();
            
            if (this.param)
            {
                const params = this.param.node.getTabParams();
                let   index  = params.indexOf(this.param);

                this.textbox.keyBlur = true;
                this.textbox.finish(true, false);

                if (   e.shiftKey 
                    && index > 0)
                {
                    while (params[--index].controls[0].readOnly);
                    params[index].controls[0].showTextbox();
                }
                else if (!e.shiftKey 
                      && index < params.length-1) 
                {
                    while (params[++index].controls[0].readOnly);
                    params[index].controls[0].showTextbox();
                }
            }
        }

        else if ((   e.key == 'ArrowUp'
                  || e.key == 'ArrowDown')
              && !this.readOnly)
        {
            e.preventDefault();

            // let text = this.textbox.value;

            if (   this.textbox.selectionStart == this.textbox.selectionEnd
                && this.textbox.selectionStart % 2 == 0
                && this.textbox.selectionStart > 0)
                this.textbox.selectionStart--;

            const iStart =  Math.floor(this.textbox.selectionStart / 2);
            let   iEnd   =  Math.ceil (this.textbox.selectionEnd   / 2);

            if (iStart == iEnd) iEnd++;


            const rgb = scaleRgb(validHex2rgb(this.textbox.value));
            
            for (let i = iStart; i < iEnd; i++)
                rgb[i] = Math.min(Math.max(0, rgb[i] + (e.key == 'ArrowUp' ? 1 : -1)), 0xff);


            this.setValue(ColorValue.fromRgb(rgb));
            this.updateTextbox();


            this.textbox.selectionStart = iStart * 2;
            this.textbox.selectionEnd   = iEnd   * 2;


            if (this.param) this.param.changing = true;
            if (this.confirmTimer) clearTimeout(this.confirmTimer);
            this.confirmTimer = setTimeout(() => controlTimer_confirm(this), 400);
        }

        else if (e.code == 'KeyZ'
              && getCtrlKey(e))
        {
            if (e.shiftKey)
            {
                if (  !isEmpty(actionManager.redoActions)
                    && actionManager.redoActions.at(-1).type == SET_PARAM_VALUE_ACTION
                    && actionManager.redoActions.at(-1).param == this.param)
                    actionManager.redo();
                else
                {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            }
            else
            {
                if (  !isEmpty(actionManager.actions)
                    && actionManager.actions.at(-1).type == SET_PARAM_VALUE_ACTION
                    && actionManager.actions.at(-1).param == this.param)
                    actionManager.undo();
                else
                {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            }
        }

        else if (this.readOnly)
            e.preventDefault();

        else if (e.key != 'Control'
              && e.key != 'Shift'
              && e.key != 'Alt')           
            actionManager.redoActions = [];
    });



    // this.textbox.addEventListener('paste', e =>
    // {
    //     e.preventDefault();


    //     const oldValue = this.value.copy();


    //     let str = e.clipboardData.getData('text/plain');

    //     const rgb = hex2rgb(
    //           this.textbox.value.substring(0, this.textbox.selectionStart)
    //         + str
    //         + this.textbox.value.substring(this.textbox.selectionEnd));

    //     const value = ColorValue.fromRgb(scaleRgb(rgb));


    //     this.textbox.value = rgb2hex(rgb);


    //     this.setValue(
    //         value, 
    //         true, //!this.textbox.managing, 
    //         true);
    // });



    this.textbox.addEventListener('focus', () =>
    {
        if (currentTooltip) 
            hideTooltip(currentTooltip);
    });
    


    this.textbox.addEventListener('focusout', () =>
    {
        //console.log('this.successOnFocusOut', this.successOnFocusOut);

        if (   !this.textbox.keyBlur
            && !this.readOnly) this.textbox.finish(true);
        else                   this.textbox.keyBlur = false;

        if (this.savedSuccessOnFocusOut != null)
        {
            this.successOnFocusOut      = this.savedSuccessOnFocusOut;
            this.savedSuccessOnFocusOut = null;
        }

        if (this.div.parentNode.contains(this.textbox))
            this.div.parentNode.removeChild(this.textbox);

        this.textbox.shown = false;

        this.text.style.display = 'block';
        
        this.clicked = false;
    });
    


    this.textbox.addEventListener('pointerdown', e =>
    {
        forwardEvent(e, this.div);

        if (e.button == 1)
        {
            e.preventDefault();
            return;
        }

        e.stopPropagation();
    });



    this.textbox.addEventListener('wheel', e =>
    {
        e.stopPropagation();
        forwardEvent(e, this.div);
    });



    this.textbox.finish = (success, focusControl = true) =>
    {
        let   value      = this.textbox.value;
        const savedValue = this.textbox.savedValue;

        
        const e = new CustomEvent('finishedit', { 'detail': {
            'success':         success,
            'value':           value,
            'oldValue':        savedValue,
            'preventSetValue': false }});
            
        this.dispatchEvent(e);
            
        
        // const webColor = webColors.find(wc => wc.name.toLowerCase() == e.detail.value.toLowerCase());

        // const rgb = validHex2rgb(webColor ? webColor.color : e.detail.value);
        // const val = ColorValue.fromRgb(scaleRgb(rgb));


        let rgb      = validHex2rgb(value);
        let savedRgb = validHex2rgb(savedValue);
        

        if (!e.preventSetValue)
        {
            if (success) 
            {
                this.setValue(
                      value.trim() != '' 
                    ? ColorValue.fromRgb(scaleRgb(rgb     )) 
                    : ColorValue.fromRgb(scaleRgb(savedRgb)));
            }
            else
                this.setValue(ColorValue.fromRgb(scaleRgb(savedRgb)));
        }

        
        this.textbox.blur();

        this.text.style.display = 'block';

        if (   this.inFocus
            && focusControl)
            this.div.focus();


        actionManager.redoActions = [];
    };    
};



ColorControl.prototype.showTextbox = function()
{
    this.text.style.display = 'none';

    this.inFocus = 
           hasFocus(this.div)
        && !this.clicked;

    // this.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
    // this.textbox.style.outline   = 'none';

    this.textbox.style.width     = this.div.offsetWidth;
    this.textbox.style.height    = defParamHeight;
    this.textbox.style.textAlign = 'center';

    this.updateTextbox();

    
    this.div.parentNode.appendChild(this.textbox);
    
    this.textbox.focus();
    // this.textbox.select();

    this.textbox.style.cursor = 'default';
};



ColorControl.prototype.updateTextbox = function()
{
    const rgb = this.value.toRgb();

    this.textbox.value =
        !this.value.isValid()
        ? UNKNOWN_CHAR
        : rgbIsValid(rgb)
          ? rgb2hex(rgb).toUpperCase()
          : UNKNOWN_CHAR;
    
    this.textbox.savedValue = this.textbox.value;
};



ColorControl.prototype.initEvents = function()
{
    this.div.addEventListener('pointerenter', e =>
    {
        if (panMode)
        {
            setCursor(panCursor);
            return;
        }


        if (   !graphView.spaceDown
            &&  this.pointerEvents)
        {
            if (graphView.tempConn)
                this.div.style.cursor = 'default';

                
            this.updateFocusBorder();


            this.focus.style.visibility = 'visible';
            this.focus.style.opacity    = '100%';
    
            this.update();
        }
    });



    this.div.addEventListener('pointerdown', e =>
    {
        if (e.button == 1)
        {
            e.preventDefault();
            return;
        }


        if (!this.canReact(e))
            return;
    
    
        if (   graphView.spaceDown
            || panMode)
            return;


        window.focus();
        
        hideAllMenus();


        if (this.param.node.div.style.zIndex < graphView.getTopNodeIndex())
            graphView.putNodeOnTop(this.param.node);


        if (e.button == 0)
        {
            if (!this.pointerEvents)
            {
                e.stopPropagation();
                return;
            }
    
            let nodeDiv = 
                   this.parentNode
                && this.parentNode.parentNode
                && this.parentNode.parentNode.parentNode
                ? this.parentNode.parentNode.parentNode
                : null;

            if (nodeDiv && nodeDiv.className == 'node') 
                graphView.putNodeOnTop(nodeDiv.node);


            e.preventDefault(); // this is fine since I lock the pointer anyway
            e.stopPropagation();

            
            this.buttonDown0  = true;
            this.buttonDown0_ = true;
            //this.moved        = false;
            this.clientX      = e.clientX;
            //this.movedX       = 0;


            if (!this.readOnly)
            {
                this.oldValue   = this.value;
                //this.startValue = this.value;
                //this.prevValue  = this.value;
                //this.sx         = e.clientX;
            }


            this.updateFocusBorder();



            this.textbox.selectionStart = 0;
            this.textbox.selectionEnd   = 0;

            this.showTextbox();

            //forwardEvent(e, this.textbox);


            if (this.param)
                this.param.noUpdate = true;  
        }
        else if (e.button == 1)
        {
            e.preventDefault();
            this.buttonDown1 = true;
        }
        else if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();
            this.buttonDown2 = true;
        }
    });



    this.div.addEventListener('pointermove', e =>
    {
        if (panMode)
        {
            setCursor(panCursor);
            return;
        }

        if (!this.pointerEvents)
            return;
        

        let rect = boundingRect(this.div);
        
        this.mouseOver = 
               e.clientX >= rect.left
            && e.clientX <  rect.right
            && e.clientY >= rect.top                                     
            && e.clientY <  rect.bottom;


        this.clientX = e.clientX;

        
        if (    this.buttonDown0
            && !this.readOnly)
        {
            //forwardEvent(e, this.textbox);
            // ...
        }
        else if (graphView.tempConn
              && this.param)
        {
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;


            //console.log('graphView.tempConn =', graphView.tempConn);
            
            if (    graphView.tempConn.output
                &&  this.param.input
                &&  this.param.input.canConnectFrom(graphView.tempConn.output)
                && !graphView.tempConn.output.node.isOrFollows(this.param.node)
                && (  !this.param.input.connected // not already connected to this input
                    || this.param.input.connectedOutput != graphView.tempConn.output
                    || this.param.input == savedInput))
            {
                graphView.overInput = this.param.input;
                    
                this.param.input.mouseOver = true;
                this.param.input.updateControl();

                const rect = boundingRect(this.param.input.div);

                graphView.tempConn.wire .inputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());
            }
            else if ( graphView.tempConn.input
                  &&  this.param.output
                  &&  graphView.tempConn.input.canConnectFrom(this.param.output)
                  && !this.param.node.isOrFollows(graphView.tempConn.input.node))
            {
                graphView.overOutput = this.param.output;
                    
                this.param.output.mouseOver = true;
                this.param.output.updateControl();


                const rect = boundingRect(this.param.output.div);

                graphView.tempConn.wire .outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());


                graphView.tempConn.input.updateControl();
            }
        }
        // else if (this.readOnly)
        // {
        //     this.moved = true;
        // }
    });
    
    
    
    this.div.addEventListener('pointerleave', e =>
    {
        if (panMode)
            return;


        this.div.style.cursor       = 'default';
        
        this.focus.style.visibility = 'hidden';
        this.focus.style.opacity    = 0;

        this.update();


        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != this.param.node)
            {
                const input = graphView.overInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire .inputPos = point_NaN;
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node != this.param.node)
            {
                const output = graphView.overOutput;
                
                graphView.overOutput = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire .outputPos = point_NaN;

                graphView.tempConn.input.updateControl();
           }
        }
    });



    this.div.addEventListener('losecapture', () =>
    {
        this.buttonDown0 = false;
        this.buttonDown1 = false;
        this.buttonDown2 = false;
        this.mouseOver   = false;
        
        this.update();
    });



    this.div.addEventListener('pointerup', e =>
    {
        clearTimeout(this.clickTimer);


        if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(this.param.node)
                &&  graphView.overInput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e));
                graphView.overInput.endConnection();
            }
            else if (graphView.tempConn.input
                && !this.param.node.isOrFollows(graphView.tempConn.input.node)
                &&  graphView.overOutput)
            {
                graphView.endConnection(e.pointerId, getCtrlKey(e));
                graphView.overOutput.endConnection();
            }
        }
        
        else if (/*this.moved
              ||*/ document.menuHadFocus)
        {
            this.unlockPointer(e.pointerId);

            if (this.param)
                this.param.noUpdate = false;  

            return;            
        }

        else if (this.buttonDown0_)
        {
            this.clicked = true;
            // this.showTextbox();
        }

             if (e.button == 0) this.buttonDown0 = false;
        else if (e.button == 1) this.buttonDown1 = false;
        else if (e.button == 2) this.buttonDown2 = false;

        this.buttonDown0_ = false;
    });    



    document.addEventListener('pointerup', e =>
    {
        e.stopPropagation();


        if (panMode)
            return;

            
        if (   e.button == 0 
            && this.buttonDown0)
        {
            this.buttonDown0 = false;
            this.unlockPointer(e.pointerId);

            this.focus.style.boxShadow = '0 0 0 1px rgba(0, 0, 0, 0.1) inset';

            // if (    this.value != this.oldValue
            //     && !this.readOnly)
            //     this.dispatchEvent(this.onconfirm);
        }
        // else if (   e.button == 1
        //     && this.buttonDown1)
        // {
        //     this.buttonDown1 = false;            
        // }
    });


    
    this.div.addEventListener('wheel', e =>
    {
        if (  !this.pointerEvents
            || panMode
            || graphView.wheelTimer)
            return;


        const touchpad = isTouchpad(e);

        if (touchpad)
        {
            e.preventDefault();
            return;
        }


        // const dWheelX = e.deltaX /  20 * (this.dragReverse ? -1 : 1);
        // const dWheelY = e.deltaY / 100 * (this.dragReverse ? -1 : 1);


        if (   !getCtrlKey(e)
            && !this.buttonDown1)
        {
            e.stopPropagation();

            if (!this.readOnly)
            {
                // if (   document.activeElement
                //     && document.activeElement.tagName.toLowerCase() == 'input'
                //     && document.activeElement.control)
                //     document.activeElement.control.textbox.finish(true, false);

                // this.oldValue = this.value;

                // const dec = Math.pow(10, -this.dec);

                // const val =
                //     touchpad
                //     ? this.value -  dWheelX               * this.wheelScale * dec
                //     : this.value + (dWheelY > 0 ? -1 : 1) * this.wheelScale * dec;
                
                // this.setValue(val, true, true, false, false);
            }
        }
    });



    // graphView.div.addEventListener('touchstart', e =>
    // {
    //     graphView.touches.push(e);
    //     e.preventDefault();
    // });
    
    
    
    // graphView.div.addEventListener('touchmove', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches[i] = e;
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.div.addEventListener('touchend', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    // graphView.div.addEventListener('touchcancel', e =>
    // {
    //     for (let i = 0; i < graphView.touches.length; i++)
    //         if (graphView.touches[i].pointerId == e.pointerId)
    //         {
    //             graphView.touches.splice(i, 1);
    //             break;
    //         }
    
    //     e.preventDefault();
    // });
    
    
    
    this.div.addEventListener('keydown', e =>
    {
        if (   e.code == 'Enter'
            || e.code == 'NumpadEnter')
            this.showTextbox();

        // else if (e.code == 'Space')
        //     setCursor(panCursor, true);
    });



    this.div.addEventListener('focus', () =>
    {
        if (   !graphView.spaceDown
            && !panMode
            && !this.buttonDown1
            && this.pointerEvents)
            this.showTextbox();
    });
};



const iconGenerator         = '<svg width="20" height="10" viewBox="0 0 20 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.4662 3.05966C12.3952 2.82955 12.2972 2.62358 12.1722 2.44176C12.05 2.2571 11.9023 2.09943 11.729 1.96875C11.5585 1.83807 11.3625 1.74006 11.1409 1.67472C10.9193 1.60653 10.6779 1.57244 10.4165 1.57244C9.94775 1.57244 9.53014 1.69034 9.16366 1.92614C8.79718 2.16193 8.50883 2.50852 8.2986 2.96591C8.09122 3.42045 7.98752 3.97443 7.98752 4.62784C7.98752 5.28693 8.09122 5.84517 8.2986 6.30256C8.50599 6.75994 8.79434 7.10795 9.16366 7.34659C9.53298 7.58239 9.96196 7.70028 10.4506 7.70028C10.8938 7.70028 11.2773 7.61506 11.6012 7.4446C11.9279 7.27415 12.1793 7.03267 12.3554 6.72017C12.5316 6.40483 12.6196 6.03551 12.6196 5.61222L12.9776 5.66761H10.6083V4.43182H14.1495V5.48011C14.1495 6.22727 13.9904 6.87358 13.6722 7.41903C13.354 7.96449 12.9165 8.38494 12.3597 8.6804C11.8029 8.97301 11.1637 9.11932 10.4421 9.11932C9.63809 9.11932 8.93213 8.93892 8.32417 8.57812C7.71906 8.21449 7.24605 7.69886 6.90514 7.03125C6.56707 6.3608 6.39804 5.56534 6.39804 4.64489C6.39804 3.94034 6.49747 3.31108 6.69633 2.7571C6.89804 2.20312 7.17929 1.73295 7.54008 1.34659C7.90088 0.957386 8.32417 0.661932 8.80997 0.460227C9.29576 0.255682 9.82417 0.153409 10.3952 0.153409C10.8781 0.153409 11.3284 0.224432 11.746 0.366477C12.1637 0.505682 12.5344 0.704545 12.8583 0.963068C13.185 1.22159 13.4534 1.52841 13.6637 1.88352C13.8739 2.23864 14.0117 2.63068 14.077 3.05966H12.4662Z" fill="white"/><circle cx="2.5" cy="4.5" r="2" stroke="white"/><circle cx="18" cy="4.9" r="2" fill="white"/></svg>';

const iconPage              = '<svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="14" height="14" rx="2.5" fill="#0C8CE9"/><path d="M7.4745 3.79841C7.83778 3.52553 8.2647 3.34457 8.78006 3.32152C8.92706 2.6837 9.49845 2.20813 10.1809 2.20813C10.9749 2.20813 11.6185 2.85175 11.6185 3.64569C11.6185 4.43963 10.9749 5.08325 10.1809 5.08325C9.61362 5.08325 9.12307 4.75465 8.88923 4.2774C8.54486 4.27815 8.28313 4.38963 8.0501 4.56468C7.73976 4.79779 7.47714 5.14458 7.16592 5.57207L7.10258 5.65929C6.7792 6.1051 6.39914 6.62905 5.86696 6.99999C6.39914 7.37093 6.7792 7.89489 7.10258 8.3407L7.16592 8.42792C7.47714 8.85541 7.73976 9.2022 8.0501 9.43531C8.28313 9.61036 8.54486 9.72184 8.88923 9.7226C9.12307 9.24535 9.61362 8.91674 10.1809 8.91674C10.9749 8.91674 11.6185 9.56035 11.6185 10.3543C11.6185 11.1482 10.9749 11.7919 10.1809 11.7919C9.49845 11.7919 8.92706 11.3163 8.78006 10.6785C8.2647 10.6554 7.83778 10.4745 7.4745 10.2016C7.03044 9.86801 6.68787 9.39958 6.39113 8.99198C5.871 8.27753 5.4567 7.71987 4.80484 7.54038C4.59126 8.06653 4.07511 8.43755 3.47231 8.43755C2.67837 8.43755 2.03475 7.79393 2.03475 6.99999C2.03475 6.20605 2.67837 5.56243 3.47231 5.56243C4.07512 5.56243 4.59127 5.93346 4.80485 6.45961C5.4567 6.28012 5.871 5.72245 6.39113 5.00801C6.68787 4.6004 7.03044 4.13197 7.4745 3.79841Z" fill="white"/></svg>';
const iconPageClose         = '<svg width="9" height="10" viewBox="0 0 9 10" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="1.23505" y="9.01202" width="1.6925" height="9.641" transform="rotate(-135 1.23505 9.01202)" fill="white"/><rect x="8.05226" y="7.81525" width="1.6925" height="9.641" transform="rotate(135 8.05226 7.81525)" fill="white"/></svg>';
// const iconAddPage           = '<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M6 0.5H4V4L0.5 4V6H4V9.5H6V6H9.5V4L6 4V0.5Z" fill="white"/></svg>';

const iconList              = '<svg width="12" height="9" viewBox="0 0 12 9" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="1" fill="white"/><rect y="4" width="9" height="1" fill="white"/><rect y="8" width="9" height="1" fill="white"/></svg>';
const iconExpandList        = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 5H9V6H0V5Z" fill="white"/><path d="M13.5 11C12.6716 11 12 10.3284 12 9.5C12 8.67157 12.6716 8 13.5 8C14.3284 8 15 8.67157 15 9.5C15 10.3284 14.3284 11 13.5 11Z" fill="white"/><path d="M13.5 7C12.6716 7 12 6.32843 12 5.5C12 4.67157 12.6716 4 13.5 4C14.3284 4 15 4.67157 15 5.5C15 6.32843 14.3284 7 13.5 7Z" fill="white"/><path d="M13.5 3C12.6716 3 12 2.32843 12 1.5C12 0.671573 12.6716 0 13.5 0C14.3284 0 15 0.671573 15 1.5C15 2.32843 14.3284 3 13.5 3Z" fill="white"/></svg>';
const iconItems             = '<svg width="17" height="11" viewBox="-1 0 17 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="1" transform="matrix(-1 0 0 1 9 1)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 9 5)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 9 9)" fill="white"/><circle r="1.5" transform="matrix(-1 0 0 1 13.5 9.5)" fill="white"/><circle r="1.5" transform="matrix(-1 0 0 1 13.5 5.5)" fill="white"/><circle r="1.5" transform="matrix(-1 0 0 1 13.5 1.5)" fill="white"/></svg>';
const iconSelect            = '<svg width="15" height="9" viewBox="0 0 15 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 0H9V1H0V0Z" fill="white"/><path d="M0 4H9V5H0V4Z" fill="white"/><path d="M0 8H9V9H0V8Z" fill="white"/><path d="M13.5 6C12.6716 6 12 5.32843 12 4.5C12 3.67157 12.6716 3 13.5 3C14.3284 3 15 3.67157 15 4.5C15 5.32843 14.3284 6 13.5 6Z" fill="white"/></svg>';
const iconCount             = '<svg width="16" height="11" viewBox="0 0 16 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.0334 0V11H12.0334V10H14.0667L14.0334 1H12L12.0334 0H15.0334Z" fill="white"/><path d="M0 11V0H3V1H0.966639V10H3V11H0Z" fill="white"/><path d="M7.5 11C6.67157 11 6 10.3284 6 9.5C6 8.67157 6.67157 8 7.5 8C8.32843 8 9 8.67157 9 9.5C9 10.3284 8.32843 11 7.5 11Z" fill="white"/><path d="M7.5 7C6.67157 7 6 6.32843 6 5.5C6 4.67157 6.67157 4 7.5 4C8.32843 4 9 4.67157 9 5.5C9 6.32843 8.32843 7 7.5 7Z" fill="white"/><path d="M7.5 3C6.67157 3 6 2.32843 6 1.5C6 0.671573 6.67157 0 7.5 0C8.32843 0 9 0.671573 9 1.5C9 2.32843 8.32843 3 7.5 3Z" fill="white"/></svg>';
const iconStart             = '<svg width="16" height="8" viewBox="0 0 16 8" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="4.97369" height="1" transform="matrix(-0.707107 0.707107 0.707107 0.707107 14.53 2.86006)" fill="white"/><rect x="6" y="3" width="8" height="1" fill="white"/><circle cx="1.5" cy="3.5" r="1.5" fill="white"/><rect width="5" height="1" transform="matrix(-0.707107 -0.707107 -0.707107 0.707107 15.2426 3.53554)" fill="white"/></svg>';
const iconRepeat            = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle r="1.5" transform="matrix(-1 0 0 1 8.5 13.6003)" fill="white"/><path d="M12.996 11.5078C14.0482 10.4921 14.7227 9.16438 14.9093 7.74161C15.0958 6.31883 14.7834 4.88515 14.023 3.67489C13.2626 2.46463 12.0993 1.54937 10.7232 1.0787C9.34705 0.608019 7.83949 0.609769 6.44689 1.08365C5.05429 1.55754 3.85902 2.47553 3.05643 3.6876C2.25383 4.89967 1.89138 6.33413 2.02832 7.75654C2.12729 8.78463 2.48292 9.76246 3.05643 10.6082" stroke="white"/><rect width="4.97369" height="1" transform="matrix(-1 0 0 1 5.00183 10.0282)" fill="white"/><rect width="4.01843" height="1" transform="matrix(1.19249e-08 -1 -1 -1.19249e-08 5.00183 11.0282)" fill="white"/></svg>';
const iconForEach           = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="9" width="9" height="1" fill="white"/><circle cx="1.5" cy="9.5" r="1.5" fill="white"/><circle cx="1.5" cy="5.5" r="1.5" fill="white"/><circle cx="1.5" cy="1.5" r="1.5" fill="white"/></svg>';
const iconCache             = '<svg width="15" height="11" viewBox="0 0 15 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.30351 1C1.68386 1.65376 1.20533 2.44219 0.906274 3.31653C0.435594 4.69266 0.437344 6.20022 0.911224 7.59282C1.21856 8.49597 1.71269 9.31613 2.35268 10" stroke="white"/><path d="M12.7415 1C13.3612 1.65376 13.8397 2.44219 14.1387 3.31653C14.6094 4.69266 14.6077 6.20022 14.1338 7.59282C13.8265 8.49597 13.3323 9.31613 12.6923 10" stroke="white"/><circle r="1.5" transform="matrix(-1 0 0 1 7.5 5.5)" fill="white"/></svg>';
const iconCopy              = '<svg width="15" height="8" viewBox="0 0 15 8" fill="none" xmlns="http://www.w3.org/2000/svg"><circle r="1.5" transform="matrix(-1 0 0 1 13.5 1.5)" fill="white"/><circle r="1.5" transform="matrix(-1 0 0 1 13.5 6.5)" fill="white"/><path d="M0 1H9V2H0V1Z" fill="white"/></svg>';
const iconIfElse            = '<svg width="16" height="7" viewBox="0 0 16 7" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="1" width="9" height="1" fill="white"/><rect y="5" width="9" height="1" fill="white"/><path d="M13.157 4.8687V4.75547C13.1591 4.36695 13.1911 4.05725 13.253 3.82636C13.317 3.59546 13.4099 3.40898 13.5318 3.26689C13.6536 3.1248 13.8002 2.99604 13.9715 2.88059C14.0995 2.79179 14.2141 2.69965 14.3153 2.60419C14.4165 2.50872 14.497 2.40327 14.5569 2.28782C14.6167 2.17016 14.6467 2.03917 14.6467 1.89486C14.6467 1.74167 14.6126 1.60736 14.5445 1.49191C14.4763 1.37647 14.3845 1.28766 14.2688 1.2255C14.1553 1.16334 14.0293 1.13225 13.891 1.13225C13.7568 1.13225 13.6298 1.16445 13.5101 1.22883C13.3903 1.29099 13.2922 1.38424 13.2159 1.50856C13.1395 1.63067 13.0982 1.78275 13.092 1.9648H11.8284C11.8387 1.52077 11.9378 1.15446 12.1257 0.865842C12.3136 0.575008 12.5624 0.358548 12.8721 0.21646C13.1818 0.0721535 13.5235 0 13.8972 0C14.3081 0 14.6714 0.0732636 14.9873 0.219791C15.3032 0.364098 15.551 0.573898 15.7306 0.849191C15.9102 1.12448 16.0001 1.45639 16.0001 1.84491C16.0001 2.10466 15.9598 2.33555 15.8793 2.53758C15.8008 2.73739 15.6904 2.915 15.5479 3.07041C15.4054 3.2236 15.2372 3.36235 15.0431 3.48668C14.88 3.59102 14.7458 3.69981 14.6405 3.81304C14.5372 3.92626 14.4598 4.05725 14.4082 4.20599C14.3587 4.35474 14.3328 4.5379 14.3308 4.75547V4.8687H13.157ZM13.7702 6.9C13.5638 6.9 13.3872 6.8223 13.2406 6.66689C13.0961 6.50926 13.0249 6.32055 13.0269 6.10076C13.0249 5.88319 13.0961 5.6967 13.2406 5.54129C13.3872 5.38589 13.5638 5.30818 13.7702 5.30818C13.9664 5.30818 14.1388 5.38589 14.2874 5.54129C14.4361 5.6967 14.5114 5.88319 14.5135 6.10076C14.5114 6.24729 14.4753 6.38161 14.4051 6.50371C14.337 6.6236 14.2472 6.72017 14.1357 6.79344C14.0242 6.86448 13.9024 6.9 13.7702 6.9Z" fill="white"/></svg>';
 
const iconNumber            = '<svg width="17" height="7" viewBox="0 0 17 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.4917 7C14.0139 7 13.5892 6.91793 13.2176 6.7538C12.8483 6.58967 12.5563 6.36122 12.3417 6.06844C12.1272 5.77567 12.0133 5.43742 12 5.05371H13.2475C13.2586 5.2378 13.3194 5.39861 13.43 5.53612C13.5406 5.67142 13.6877 5.77677 13.8713 5.85219C14.0548 5.9276 14.2605 5.9653 14.4884 5.9653C14.7317 5.9653 14.9473 5.92316 15.1353 5.83888C15.3234 5.75238 15.4705 5.6326 15.5766 5.47956C15.6828 5.32652 15.7348 5.15019 15.7326 4.95057C15.7348 4.7443 15.6817 4.56242 15.5733 4.40494C15.4649 4.24747 15.3079 4.12437 15.1022 4.03565C14.8987 3.94693 14.6532 3.90257 14.3656 3.90257H13.7651V2.95105H14.3656C14.6023 2.95105 14.8091 2.91001 14.986 2.82795C15.1652 2.74588 15.3057 2.63055 15.4074 2.48194C15.5092 2.33112 15.5589 2.157 15.5567 1.9596C15.5589 1.76664 15.5158 1.59918 15.4273 1.45722C15.3411 1.31305 15.2183 1.20105 15.059 1.1212C14.902 1.04135 14.7173 1.00143 14.505 1.00143C14.297 1.00143 14.1046 1.03913 13.9277 1.11454C13.7507 1.18996 13.608 1.29753 13.4997 1.43726C13.3913 1.57478 13.3338 1.73891 13.3271 1.92966H12.1427C12.1515 1.54816 12.261 1.21324 12.4711 0.924905C12.6835 0.634347 12.9666 0.408112 13.3205 0.246198C13.6744 0.0820661 14.0714 0 14.5116 0C14.965 0 15.3588 0.0853929 15.6927 0.256179C16.029 0.424746 16.2888 0.652091 16.4724 0.938213C16.656 1.22433 16.7478 1.5404 16.7478 1.88641C16.75 2.27012 16.6372 2.59173 16.4094 2.85124C16.1838 3.11074 15.8874 3.28042 15.5202 3.36027V3.4135C15.998 3.48004 16.3641 3.65748 16.6184 3.94582C16.875 4.23194 17.0022 4.58793 17 5.01378C17 5.39528 16.8916 5.73685 16.6748 6.0385C16.4603 6.33793 16.1639 6.57304 15.7856 6.74382C15.4096 6.91461 14.9783 7 14.4917 7Z" fill="white"/><path d="M5.04237 7V6.09634L7.66243 3.75289C7.90254 3.52136 8.10264 3.31567 8.26271 3.13584C8.42279 2.95601 8.54284 2.78179 8.62288 2.6132C8.70292 2.44461 8.74294 2.26477 8.74294 2.0737C8.74294 1.85565 8.69115 1.66908 8.58757 1.51397C8.48399 1.35662 8.34157 1.23523 8.16031 1.14981C7.97905 1.06439 7.66361 1.01493 7.43291 1.01493C7.19515 1.01493 6.98682 1.06214 6.80791 1.15655C6.629 1.24872 6.49011 1.38022 6.39124 1.55106C6.29473 1.7219 6.24647 1.92534 6.24647 2.16137H5C5 1.72302 5.10476 1.342 5.31427 1.0183C5.52378 0.694605 5.81215 0.443963 6.17938 0.266378C6.54896 0.0887927 6.97269 0 7.45056 0C7.9355 0 8.47105 0.0932886 8.83828 0.266378C9.20551 0.439467 9.49035 0.676622 9.6928 0.977842C9.8976 1.27906 10 1.62299 10 2.00963C10 2.26814 9.94821 2.52216 9.84463 2.77168C9.74105 3.02119 9.55862 3.29769 9.29732 3.60116C9.03837 3.90462 8.67467 4.27216 8.20622 4.70376L6.85028 5.90751V5.95472H10V7H5.04237Z" fill="white"/><path d="M3 0V7H1.70882V1.23389H1.66705L0 2.27979V1.11768L1.77146 0H3Z" fill="white"/></svg>';
const iconSign              = '<svg width="7" height="11" viewBox="0 0 7 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.90606 7V0H4.09394V7H2.90606ZM0 4.09394V2.90606H7V4.09394H0Z" fill="white"/><path d="M7 10V11H0V10H7Z" fill="white"/></svg>';
const iconAbsolute          = '<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.40227 4L6.5 5.8457L7.61544 4H8.97167L7.33215 6.5L9 9H7.65085L6.5 7.19987L5.35977 9H4L5.65722 6.5L4.04249 4H5.40227Z" fill="white"/><rect width="1" height="13" transform="matrix(-1 0 0 1 13 0)" fill="white"/><rect width="1" height="13" transform="matrix(-1 0 0 1 1 0)" fill="white"/></svg>';
const iconRound             = '<svg width="17" height="13" viewBox="0 0 17 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.74422 12.2978C3.1 12 1.51382 9.72099 1.51382 6.5C1.51382 3.27901 3.1 1 4.74422 0.702217" stroke="white" stroke-width="1.1"/><path d="M12.3 12.2978C13.9442 12 15.5304 9.72099 15.5304 6.5C15.5304 3.27901 13.9442 1 12.3 0.702217" stroke="white" stroke-width="1.1"/><path d="M7.40227 4L8.5 5.8457L9.61544 4H10.9717L9.33215 6.5L11 9H9.65085L8.5 7.19987L7.35977 9H6L7.65722 6.5L6.04249 4H7.40227Z" fill="white"/></svg>';
const iconLimits            = '<svg width="18" height="14" viewBox="0 0 18 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 0H0.904239L3.03042 5.81055H3.10374L5.22992 0H6.13416V7H5.42543V1.68164H5.36434L3.40922 7H2.72494L0.769825 1.68164H0.708728V7H0V0Z" fill="white"/><path d="M7.9098 7H7.11553L9.41279 0H10.1948L12.4921 7H11.6978L9.82825 1.10742H9.77937L7.9098 7ZM8.20306 4.26563H11.4046V5.01758H8.20306V4.26563Z" fill="white"/><path d="M13.8332 0L15.4461 2.91211H15.495L17.108 0H18L16.0327 3.5L18 7H17.108L15.495 4.14258H15.4461L13.8332 7H12.9412L14.9574 3.5L12.9412 0H13.8332Z" fill="white"/><path d="M1 8H1.85014L3.84911 12.9805H3.91804L5.91702 8H6.76716V14H6.10083V9.44141H6.04339L4.20525 14H3.5619L1.72377 9.44141H1.66632V14H1V8Z" fill="white"/><path d="M9.90758 8V14H9.1953V8H9.90758Z" fill="white"/><path d="M17 8V14H16.3107L13.1054 9.28906H13.048V14H12.3357V8H13.025L16.2418 12.7227H16.2992V8H17Z" fill="white"/></svg>';
const iconRandom            = '<svg width="7" height="11" viewBox="0 0 7 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.57613 7.88313V7.82014C2.58313 7.15175 2.65312 6.61983 2.7861 6.22439C2.91908 5.82895 3.10805 5.50875 3.35302 5.26379C3.59798 5.01883 3.89193 4.79311 4.23488 4.58664C4.44135 4.46066 4.62682 4.31193 4.79129 4.14046C4.95577 3.96549 5.08525 3.76427 5.17973 3.5368C5.27772 3.30934 5.32671 3.05738 5.32671 2.78092C5.32671 2.43797 5.24622 2.14052 5.08525 1.88856C4.92427 1.6366 4.70906 1.44238 4.4396 1.3059C4.17014 1.16942 3.87094 1.10118 3.54199 1.10118C3.25503 1.10118 2.97857 1.16067 2.71261 1.27965C2.44665 1.39863 2.22444 1.58585 2.04597 1.84131C1.86749 2.09677 1.76426 2.43097 1.73626 2.84391H0.413467C0.441463 2.249 0.595439 1.73983 0.875396 1.31639C1.15885 0.89296 1.53155 0.56926 1.99347 0.345294C2.4589 0.121329 2.97507 0.00934601 3.54199 0.00934601C4.15789 0.00934601 4.69331 0.131827 5.14824 0.376789C5.60667 0.621752 5.96011 0.9577 6.20858 1.38463C6.46054 1.81157 6.58652 2.29799 6.58652 2.84391C6.58652 3.22885 6.52703 3.57705 6.40804 3.8885C6.29256 4.19995 6.12459 4.47816 5.90412 4.72312C5.68716 4.96808 5.4247 5.18505 5.11674 5.37402C4.80879 5.56649 4.56208 5.76946 4.37661 5.98293C4.19114 6.19289 4.05641 6.44311 3.97242 6.73356C3.88843 7.02402 3.84294 7.38621 3.83594 7.82014V7.88313H2.57613ZM3.24803 10.9907C2.98907 10.9907 2.76686 10.8979 2.58138 10.7124C2.39591 10.527 2.30318 10.3048 2.30318 10.0458C2.30318 9.78684 2.39591 9.56463 2.58138 9.37915C2.76686 9.19368 2.98907 9.10095 3.24803 9.10095C3.50699 9.10095 3.72921 9.19368 3.91468 9.37915C4.10015 9.56463 4.19289 9.78684 4.19289 10.0458C4.19289 10.2173 4.14914 10.3748 4.06166 10.5182C3.97767 10.6617 3.86394 10.7772 3.72046 10.8647C3.58048 10.9487 3.423 10.9907 3.24803 10.9907Z" fill="white"/></svg>';
const iconSeries            = '<svg width="16" height="11" viewBox="0 0 16 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect y="9" width="1" height="2" fill="white"/><rect x="5" y="6" width="1" height="5" fill="white"/><rect x="10" y="3" width="1" height="8" fill="white"/><rect x="15" width="1" height="11" fill="white"/></svg>';
const iconInterpolate       = '<svg width="19" height="13" viewBox="0 -1 19 13" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="0.284818" y1="10.6077" x2="18.759" y2="0.444666" stroke="white"/><ellipse cx="9.99556" cy="5.22745" rx="1.45202" ry="2.24173" transform="rotate(-25.1301 9.99556 5.22745)" fill="white"/></svg>';
const iconNumberToText      = '<svg width="19" height="12" viewBox="0 0 19 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.2849 0V1.14446C16.2849 1.47359 16.224 1.8158 16.1022 2.17111C15.9839 2.52267 15.8208 2.85928 15.6129 3.18093C15.405 3.49883 15.1685 3.77186 14.9032 4L14 3.3885C14.1971 3.07807 14.3692 2.74334 14.5161 2.38429C14.6631 2.0215 14.7366 1.61197 14.7366 1.15568V0H16.2849ZM19 0V1.14446C19 1.47359 18.9391 1.8158 18.8172 2.17111C18.6989 2.52267 18.5358 2.85928 18.328 3.18093C18.1201 3.49883 17.8853 3.77186 17.6237 4L16.7204 3.3885C16.914 3.07807 17.0842 2.74334 17.2312 2.38429C17.3781 2.0215 17.4516 1.61197 17.4516 1.15568V0H19Z" fill="white"/><path d="M0 4V2.85554C0 2.52641 0.0590129 2.1842 0.177039 1.82889C0.298641 1.46985 0.463162 1.13137 0.670601 0.813464C0.881617 0.491819 1.11767 0.220664 1.37876 0L2.28004 0.6115C2.06903 0.944366 1.89199 1.29219 1.74893 1.65498C1.60944 2.01403 1.54149 2.41047 1.54506 2.84432V4H0ZM2.71996 4V2.85554C2.71996 2.52641 2.77897 2.1842 2.897 1.82889C3.0186 1.46985 3.18312 1.13137 3.39056 0.813464C3.60157 0.491819 3.83763 0.220664 4.09871 0L5 0.6115C4.78898 0.944366 4.61195 1.29219 4.46888 1.65498C4.3294 2.01403 4.26144 2.41047 4.26502 2.84432V4H2.71996Z" fill="white"/><path d="M5.42449 6.07985V11.9202H4.381V7.10932H4.34725L3 7.98194V7.01236L4.43163 6.07985H5.42449Z" fill="white"/><path d="M6.88705 11.9202V11.1559L8.88683 9.16825C9.07809 8.97243 9.23748 8.79848 9.36498 8.64639C9.49249 8.4943 9.58812 8.34696 9.65187 8.20437C9.71562 8.06179 9.7475 7.9097 9.7475 7.7481C9.7475 7.56369 9.70625 7.40589 9.62374 7.27471C9.54124 7.14164 9.4278 7.03897 9.28342 6.96673C9.13903 6.89449 8.97496 6.85836 8.7912 6.85836C8.60182 6.85836 8.43588 6.89829 8.29337 6.97814C8.15086 7.05608 8.04023 7.1673 7.96148 7.31179C7.8846 7.45627 7.84616 7.62833 7.84616 7.82795H6.8533C6.8533 7.45722 6.93674 7.13498 7.10363 6.86122C7.27051 6.58745 7.50021 6.37548 7.79272 6.22529C8.08711 6.0751 8.42463 6 8.80527 6C9.19154 6 9.53093 6.07319 9.82344 6.21958C10.116 6.36597 10.3428 6.56654 10.5041 6.82129C10.6672 7.07605 10.7488 7.36692 10.7488 7.69392C10.7488 7.91255 10.7075 8.12738 10.625 8.3384C10.5425 8.54943 10.3972 8.78327 10.1891 9.03992C9.98282 9.29658 9.69312 9.60741 9.31998 9.97243L8.32712 10.9962V11.0361H10.836V11.9202H6.88705Z" fill="white"/><path d="M13.8736 12C13.4686 12 13.1086 11.9297 12.7936 11.789C12.4804 11.6483 12.2329 11.4525 12.051 11.2015C11.8692 10.9506 11.7726 10.6606 11.7613 10.3317H12.8189C12.8283 10.4895 12.8798 10.6274 12.9736 10.7452C13.0673 10.8612 13.192 10.9515 13.3477 11.0162C13.5033 11.0808 13.6777 11.1131 13.8708 11.1131C14.0771 11.1131 14.2599 11.077 14.4193 11.0048C14.5787 10.9306 14.7034 10.8279 14.7934 10.6968C14.8834 10.5656 14.9274 10.4144 14.9256 10.2433C14.9274 10.0665 14.8824 9.91065 14.7905 9.77566C14.6987 9.64068 14.5655 9.53517 14.3912 9.45913C14.2186 9.38308 14.0105 9.34506 13.7667 9.34506H13.2577V8.52947H13.7667C13.9674 8.52947 14.1427 8.4943 14.2927 8.42395C14.4446 8.35361 14.5637 8.25475 14.6499 8.12738C14.7362 7.9981 14.7784 7.84886 14.7765 7.67966C14.7784 7.51426 14.7418 7.37072 14.6668 7.24905C14.5937 7.12548 14.4896 7.02947 14.3546 6.96103C14.2215 6.89259 14.0649 6.85836 13.8849 6.85836C13.7086 6.85836 13.5455 6.89068 13.3955 6.95532C13.2455 7.01996 13.1245 7.11217 13.0327 7.23194C12.9408 7.34981 12.892 7.49049 12.8864 7.65399H11.8823C11.8898 7.327 11.9826 7.03992 12.1607 6.79278C12.3407 6.54373 12.5808 6.34981 12.8808 6.21103C13.1808 6.07034 13.5174 6 13.8905 6C14.2749 6 14.6087 6.07319 14.8918 6.21958C15.1768 6.36407 15.3971 6.55894 15.5528 6.80418C15.7084 7.04943 15.7862 7.32034 15.7862 7.61692C15.7881 7.94582 15.6925 8.22148 15.4993 8.44392C15.3081 8.66635 15.0568 8.81179 14.7455 8.88023V8.92586C15.1506 8.98289 15.4609 9.13498 15.6765 9.38213C15.894 9.62738 16.0019 9.93251 16 10.2975C16 10.6245 15.9081 10.9173 15.7243 11.1759C15.5425 11.4325 15.2912 11.634 14.9706 11.7804C14.6518 11.9268 14.2861 12 13.8736 12Z" fill="white"/></svg>';
const iconSolve             = '<svg width="18" height="14" viewBox="-4 0 18 14" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="5.5" cy="5.5" r="5" stroke="white"/><rect x="9.44473" y="8.55527" width="6.21958" height="1.25789" transform="rotate(45 9.44473 8.55527)" fill="white"/><path d="M4.40227 3L5.5 4.8457L6.61544 3H7.97167L6.33215 5.5L8 8H6.65085L5.5 6.19987L4.35977 8H3L4.65722 5.5L3.04249 3H4.40227Z" fill="white"/></svg>';
const iconAnimate           = '<svg width="15" height="7" viewBox="0 0 15 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 0H15V1H6V0Z" fill="white"/><path d="M3 3H12V4H3V3Z" fill="white"/><path d="M0 6H9V7H0V6Z" fill="white"/></svg>';
 
const iconMath              = '<svg width="17" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.138 6.57967V0.485922H13.1039V6.57967H14.138ZM16.6678 4.04984V3.01575H10.5741V4.04984H16.6678Z" fill="white"/><path d="M11.3681 15.5004L16.5755 10.293L15.8738 9.59129L10.6664 14.7987L11.3681 15.5004ZM15.8738 15.5004L16.5755 14.7987L11.3681 9.59129L10.6664 10.293L15.8738 15.5004Z" fill="white"/><path d="M0.576652 12.0288V13.0629H6.48574V12.0288H0.576652ZM3.5312 15.7589C3.76202 15.7589 3.95899 15.6789 4.12211 15.5188C4.28214 15.3557 4.36216 15.1588 4.36216 14.9279C4.36216 14.7063 4.28214 14.5155 4.12211 14.3555C3.95899 14.1955 3.76202 14.1154 3.5312 14.1154C3.30961 14.1154 3.11879 14.1955 2.95875 14.3555C2.79872 14.5155 2.7187 14.7063 2.7187 14.9279C2.7187 15.1588 2.79872 15.3557 2.95875 15.5188C3.11879 15.6789 3.30961 15.7589 3.5312 15.7589ZM3.5312 10.9762C3.68508 10.9762 3.82511 10.9393 3.9513 10.8654C4.07748 10.7916 4.1775 10.6915 4.25137 10.5654C4.32523 10.4392 4.36216 10.2991 4.36216 10.1453C4.36216 9.92367 4.28214 9.73286 4.12211 9.57282C3.95899 9.41278 3.76202 9.33276 3.5312 9.33276C3.30961 9.33276 3.11879 9.41278 2.95875 9.57282C2.79872 9.73286 2.7187 9.92367 2.7187 10.1453C2.7187 10.3761 2.79872 10.5731 2.95875 10.7362C3.11879 10.8962 3.30961 10.9762 3.5312 10.9762Z" fill="white"/><path d="M0.576652 3.01575V4.04984H6.48574V3.01575H0.576652Z" fill="white"/></svg>';
const iconAdd               = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.78932 10.1318V0.756822H6.38023V10.1318H4.78932ZM0.897271 6.23978V4.64887H10.2723V6.23978H0.897271Z" fill="white"/></svg>';
const iconSubtract          = '<svg width="10" height="3" viewBox="0 0 10 3" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.13022 0.648869V2.23978H0.0393143V0.648869H9.13022Z" fill="white"/></svg>';
const iconMultiply          = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.05068 9.98978L0.0393206 1.97841L1.11887 0.898868L9.13023 8.91023L8.05068 9.98978ZM1.11887 9.98978L0.0393206 8.91023L8.05068 0.898868L9.13023 1.97841L1.11887 9.98978Z" fill="white"/></svg>';
const iconDivide            = '<svg width="11" height="12" viewBox="0 0 11 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.1054 1.42632L2.05001 11.9731L0.832778 11.1289L8.88819 0.582087L10.1054 1.42632Z" fill="white"/></svg>';
const iconExponent          = '<svg width="15" height="14" viewBox="-2 0 15 14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.24574 13.6818C3.40483 13.6818 2.67945 13.4962 2.0696 13.125C1.46354 12.75 0.995739 12.2273 0.666193 11.5568C0.340436 10.8826 0.177557 10.0985 0.177557 9.20455C0.177557 8.31061 0.340436 7.52273 0.666193 6.84091C0.995739 6.1553 1.45407 5.62121 2.04119 5.23864C2.6321 4.85227 3.3215 4.65909 4.10938 4.65909C4.56392 4.65909 5.01278 4.73485 5.45597 4.88636C5.89915 5.03788 6.30256 5.28409 6.66619 5.625C7.02983 5.96212 7.3196 6.40909 7.53551 6.96591C7.75142 7.52273 7.85938 8.20833 7.85938 9.02273V9.59091H1.1321V8.43182H6.49574C6.49574 7.93939 6.39725 7.5 6.20028 7.11364C6.0071 6.72727 5.73059 6.42235 5.37074 6.19886C5.01468 5.97538 4.59422 5.86364 4.10938 5.86364C3.57528 5.86364 3.11316 5.99621 2.72301 6.26136C2.33665 6.52273 2.0393 6.86364 1.83097 7.28409C1.62263 7.70455 1.51847 8.1553 1.51847 8.63636V9.40909C1.51847 10.0682 1.6321 10.6269 1.85938 11.0852C2.09044 11.5398 2.41051 11.8864 2.8196 12.125C3.22869 12.3598 3.70407 12.4773 4.24574 12.4773C4.59801 12.4773 4.91619 12.428 5.20028 12.3295C5.48816 12.2273 5.73627 12.0758 5.9446 11.875C6.15294 11.6705 6.31392 11.4167 6.42756 11.1136L7.72301 11.4773C7.58665 11.9167 7.35748 12.303 7.03551 12.6364C6.71354 12.9659 6.31581 13.2235 5.84233 13.4091C5.36884 13.5909 4.83665 13.6818 4.24574 13.6818Z" fill="white"/><path d="M9.39205 0.545454L10.6989 2.77557L12.0057 0.545454H12.9716L11.2102 3.27273L12.9716 6H12.0057L10.6989 3.88352L9.39205 6H8.42614L10.1591 3.27273L8.42614 0.545454H9.39205Z" fill="white"/></svg>';
const iconModulo            = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.07556 8.75853V8.21776C6.07556 7.8439 6.15233 7.50175 6.30588 7.19131C6.46277 6.87753 6.68976 6.62718 6.98685 6.44024C7.28728 6.24997 7.65113 6.15484 8.0784 6.15484C8.51235 6.15484 8.8762 6.24997 9.16995 6.44024C9.4637 6.62718 9.68568 6.87753 9.83589 7.19131C9.9861 7.50175 10.0612 7.8439 10.0612 8.21776V8.75853C10.0612 9.1324 9.98444 9.47622 9.83088 9.78999C9.68067 10.1004 9.45702 10.3508 9.15993 10.5411C8.86618 10.728 8.50567 10.8215 8.0784 10.8215C7.64445 10.8215 7.27893 10.728 6.98184 10.5411C6.68475 10.3508 6.45943 10.1004 6.30588 9.78999C6.15233 9.47622 6.07556 9.1324 6.07556 8.75853ZM7.09701 8.21776V8.75853C7.09701 9.06897 7.17044 9.3477 7.31732 9.59472C7.46419 9.8384 7.71789 9.96024 8.0784 9.96024C8.4289 9.96024 8.67591 9.8384 8.81945 9.59472C8.96632 9.3477 9.03976 9.06897 9.03976 8.75853V8.21776C9.03976 7.90732 8.96966 7.63026 8.82946 7.38659C8.68926 7.13957 8.43891 7.01606 8.0784 7.01606C7.7279 7.01606 7.47588 7.13957 7.32233 7.38659C7.17211 7.63026 7.09701 7.90732 7.09701 8.21776ZM0.968313 2.89021V2.34944C0.968313 1.97558 1.04509 1.63342 1.19864 1.32298C1.35553 1.00921 1.58252 0.758851 1.87961 0.571919C2.18003 0.381649 2.54388 0.286514 2.97115 0.286514C3.4051 0.286514 3.76895 0.381649 4.0627 0.571919C4.35645 0.758851 4.57843 1.00921 4.72865 1.32298C4.87886 1.63342 4.95397 1.97558 4.95397 2.34944V2.89021C4.95397 3.26407 4.87719 3.60789 4.72364 3.92167C4.57343 4.23211 4.34978 4.48247 4.05269 4.67274C3.75894 4.85967 3.39843 4.95313 2.97115 4.95313C2.5372 4.95313 2.17169 4.85967 1.8746 4.67274C1.57751 4.48247 1.35219 4.23211 1.19864 3.92167C1.04509 3.60789 0.968313 3.26407 0.968313 2.89021ZM1.98976 2.34944V2.89021C1.98976 3.20065 2.0632 3.47938 2.21007 3.72639C2.35695 3.97007 2.61064 4.09191 2.97115 4.09191C3.32165 4.09191 3.56867 3.97007 3.7122 3.72639C3.85908 3.47938 3.93252 3.20065 3.93252 2.89021V2.34944C3.93252 2.039 3.86242 1.76194 3.72222 1.51826C3.58202 1.27124 3.33167 1.14774 2.97115 1.14774C2.62066 1.14774 2.36863 1.27124 2.21508 1.51826C2.06487 1.76194 1.98976 2.039 1.98976 2.34944ZM1.34885 10.6813L8.39885 0.426713H9.54047L2.49047 10.6813H1.34885Z" fill="white"/></svg>';

const iconBoolean           = '<svg width="13" height="16" viewBox="0 0 13 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.28269 9.19418V15.0124H2.05257V10.3618H2.01848L0.686096 11.197V10.1061L2.12644 9.19418H3.28269Z" fill="white"/><path d="M2.53269 6.02495C2.04405 6.02306 1.6236 5.90279 1.27132 5.66416C0.920945 5.42552 0.651058 5.07988 0.461664 4.62722C0.274164 4.17457 0.181361 3.63006 0.183255 2.9937C0.183255 2.35923 0.277005 1.81851 0.464505 1.37154C0.653899 0.924572 0.923786 0.58461 1.27416 0.351655C1.62644 0.116807 2.04594 -0.000617504 2.53269 -0.000617504C3.01943 -0.000617504 3.43799 0.116807 3.78837 0.351655C4.14064 0.586504 4.41148 0.927413 4.60087 1.37438C4.79026 1.81946 4.88401 2.35923 4.88212 2.9937C4.88212 3.63196 4.78742 4.17741 4.59803 4.63006C4.41053 5.08272 4.14159 5.42836 3.79121 5.667C3.44083 5.90563 3.02132 6.02495 2.53269 6.02495ZM2.53269 5.00506C2.86602 5.00506 3.13212 4.83745 3.33098 4.50222C3.52985 4.167 3.62833 3.66416 3.62644 2.9937C3.62644 2.55241 3.58098 2.18499 3.49007 1.89143C3.40106 1.59787 3.27416 1.37722 3.10939 1.2295C2.94651 1.08177 2.75428 1.00791 2.53269 1.00791C2.20125 1.00791 1.9361 1.17363 1.73723 1.50506C1.53837 1.8365 1.43799 2.33272 1.4361 2.9937C1.4361 3.44067 1.4806 3.81378 1.56962 4.11302C1.66053 4.41037 1.78837 4.63385 1.95314 4.78347C2.11791 4.9312 2.3111 5.00506 2.53269 5.00506Z" fill="white"/><path d="M9.87382 15.0638C9.38518 15.0619 8.96473 14.9416 8.61246 14.703C8.26208 14.4643 7.99219 14.1187 7.8028 13.666C7.6153 13.2134 7.52249 12.6689 7.52439 12.0325C7.52439 11.398 7.61814 10.8573 7.80564 10.4104C7.99503 9.96339 8.26492 9.62343 8.6153 9.39047C8.96757 9.15563 9.38708 9.0382 9.87382 9.0382C10.3606 9.0382 10.7791 9.15563 11.1295 9.39047C11.4818 9.62532 11.7526 9.96623 11.942 10.4132C12.1314 10.8583 12.2251 11.398 12.2233 12.0325C12.2233 12.6708 12.1286 13.2162 11.9392 13.6689C11.7517 14.1215 11.4827 14.4672 11.1323 14.7058C10.782 14.9445 10.3625 15.0638 9.87382 15.0638ZM9.87382 14.0439C10.2072 14.0439 10.4733 13.8763 10.6721 13.541C10.871 13.2058 10.9695 12.703 10.9676 12.0325C10.9676 11.5912 10.9221 11.2238 10.8312 10.9302C10.7422 10.6367 10.6153 10.416 10.4505 10.2683C10.2876 10.1206 10.0954 10.0467 9.87382 10.0467C9.54238 10.0467 9.27723 10.2124 9.07837 10.5439C8.8795 10.8753 8.77912 11.3715 8.77723 12.0325C8.77723 12.4795 8.82174 12.8526 8.91075 13.1518C9.00166 13.4492 9.1295 13.6727 9.29427 13.8223C9.45905 13.97 9.65223 14.0439 9.87382 14.0439Z" fill="white"/><path d="M11.0028 0.181818V6H9.77273V1.34943H9.73864L8.40625 2.18466V1.09375L9.84659 0.181818H11.0028Z" fill="white"/></svg>';
const iconNot               = '<svg width="8" height="4" viewBox="0 0 8 4" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 0V1.59459H0V0H8ZM8 0.729729V4H6.08298V0.729729H8Z" fill="white"/></svg>';
const iconAnd               = '<svg width="9" height="9" viewBox="0 -1 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.93182 2.15577e-07L3.65909 1.59944e-07L-3.29822e-07 7.54545L1.73295 7.54546L4.27273 1.97727L4.17045 2.02841L4.41477 2.02841L4.31818 1.97727L6.85227 7.54546L8.59091 7.54546L4.93182 2.15577e-07Z" fill="white"/></svg>';
const iconOr                = '<svg width="9" height="9" viewBox="0 -1 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4.93182 7.54546L3.65909 7.54546L-3.29822e-07 9.53674e-07L1.73295 8.77924e-07L4.27273 5.56818L4.17045 5.51705L4.41477 5.51705L4.31818 5.56818L6.85227 6.54152e-07L8.59091 5.78154e-07L4.93182 7.54546Z" fill="white"/></svg>';
const iconXor               = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.5 10.2363C8.11581 10.2363 10.2363 8.11581 10.2363 5.5C10.2363 2.88419 8.11581 0.763657 5.5 0.763657C2.88419 0.763657 0.763657 2.88419 0.763657 5.5C0.763657 8.11581 2.88419 10.2363 5.5 10.2363ZM5.5 9C7.433 9 9 7.433 9 5.5C9 3.567 7.433 2 5.5 2C3.567 2 2 3.567 2 5.5C2 7.433 3.567 9 5.5 9Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9 6L2 6L2 5L9 5V6Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 2L6 9L5 9L5 2L6 2Z" fill="white"/></svg>';
 
const iconCondition         = '<svg width="17" height="17" viewBox="0 0 17 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.53875 4.35405L15.9422 7.61541V6.34268L11.0302 3.97621L11.07 4.05575V3.85689L11.0302 3.93643L15.9422 1.56996V0.29723L9.53875 3.55859V4.35405Z" fill="white"/><path d="M13.5986 9.37666H15.1207L12.1775 16.6948H10.6554L13.5986 9.37666ZM9.87942 12.1011V11.0272H16.0044V12.1011H9.87942ZM9.87942 15.0443V13.9704H16.0044V15.0443H9.87942Z" fill="white"/><path d="M7.29069 13.4335V12.638L0.887281 9.37667V10.6494L5.79921 13.0159L5.75944 12.9363V13.1352L5.79921 13.0556L0.887281 15.4221V16.6948L7.29069 13.4335Z" fill="white"/><path d="M6.67738 3.02166V1.9478H0.552379V3.02166H6.67738ZM6.67738 5.96484V4.89098H0.552379V5.96484H6.67738Z" fill="white"/></svg>';
const iconEqual             = '<svg width="9" height="7" viewBox="0 0 9 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.78409 1.98295V0.448863H0.03409V1.98295H8.78409ZM8.78409 6.1875V4.65341H0.03409V6.1875H8.78409Z" fill="white"/></svg>';
const iconNotEqual          = '<svg width="9" height="11" viewBox="0 0 9 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.89773 0.0909088H7.48864L3.28409 10.5455H1.69318L5.89773 0.0909088ZM0.215909 3.98295V2.44886H8.96591V3.98295H0.215909ZM0.215909 8.1875V6.65341H8.96591V8.1875H0.215909Z" fill="white"/></svg>';
const iconLess              = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.0170455 5.88636V4.75L9.16477 0.0909088V1.90909L2.14773 5.28977L2.20455 5.17614V5.46023L2.14773 5.34659L9.16477 8.72727V10.5455L0.0170455 5.88636Z" fill="white"/></svg>';
const iconLessOrEqual       = '<svg width="10" height="12" viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.16477 11.3182H0.0170455V9.72727H9.16477V11.3182ZM0.0170455 5.29545V4.15909L9.16477 0.863636V2.59659L2.77273 4.69886L2.82955 4.58523V4.86932L2.77273 4.75568L9.16477 6.85795V8.59091L0.0170455 5.29545Z" fill="white"/></svg>';
const iconGreater           = '<svg width="10" height="11" viewBox="0 0 10 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9.16477 5.88636L0.0170455 10.5455V8.72727L7.03409 5.34659L6.97727 5.46023V5.17614L7.03409 5.28977L0.0170455 1.90909V0.0909088L9.16477 4.75V5.88636Z" fill="white"/></svg>';
const iconGreaterOrEqual    = '<svg width="10" height="12" viewBox="0 0 10 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.0170455 11.3182V9.72727H9.16477V11.3182H0.0170455ZM9.16477 5.29545L0.0170455 8.59091V6.85795L6.40909 4.75568L6.35227 4.86932V4.58523L6.40909 4.69886L0.0170455 2.59659V0.863636L9.16477 4.15909V5.29545Z" fill="white"/></svg>';
 
const iconText              = '<svg width="19" height="7" viewBox="0 0 19 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 2.39211H17.7568C17.7213 2.18805 17.656 2.00729 17.5607 1.84981C17.4654 1.69011 17.3468 1.55482 17.205 1.44392C17.0632 1.33302 16.9014 1.24984 16.7197 1.19439C16.5402 1.13672 16.3463 1.10789 16.1379 1.10789C15.7679 1.10789 15.4399 1.20105 15.154 1.38736C14.8681 1.57145 14.6443 1.84205 14.4825 2.19914C14.3208 2.55402 14.2399 2.98764 14.2399 3.5C14.2399 4.02123 14.3208 4.46039 14.4825 4.81749C14.6465 5.17237 14.8704 5.44075 15.154 5.62262C15.4399 5.80228 15.7668 5.89211 16.1346 5.89211C16.3385 5.89211 16.5291 5.86549 16.7064 5.81226C16.8859 5.75681 17.0465 5.67586 17.1884 5.56939C17.3324 5.46293 17.4532 5.33207 17.5507 5.17681C17.6504 5.02155 17.7191 4.84411 17.7568 4.64449L19 4.65114C18.9535 4.97497 18.8526 5.27883 18.6975 5.56274C18.5446 5.84664 18.344 6.09727 18.0958 6.31464C17.8476 6.52978 17.5573 6.69835 17.2249 6.82034C16.8925 6.94011 16.5235 7 16.118 7C15.5197 7 14.9856 6.86138 14.5158 6.58413C14.046 6.30688 13.6759 5.90653 13.4055 5.38308C13.1352 4.85963 13 4.23194 13 3.5C13 2.76584 13.1363 2.13815 13.4089 1.61692C13.6814 1.09347 14.0526 0.693124 14.5224 0.415875C14.9922 0.138625 15.5241 0 16.118 0C16.497 0 16.8493 0.0532321 17.1751 0.159696C17.5008 0.26616 17.7911 0.422529 18.046 0.628803C18.3008 0.832858 18.5103 1.08349 18.6742 1.3807C18.8404 1.6757 18.949 2.01283 19 2.39211Z" fill="white"/><path d="M7 7V0H9.56545C10.0497 0 10.4522 0.0797524 10.7729 0.239258C11.0958 0.396484 11.3368 0.611816 11.4961 0.885254C11.6575 1.15869 11.7382 1.46859 11.7382 1.81494C11.7382 2.09977 11.6859 2.34359 11.5812 2.54639C11.4764 2.74691 11.3357 2.90983 11.159 3.03516C10.9823 3.16048 10.7849 3.25049 10.5668 3.30518V3.37354C10.8045 3.38721 11.0325 3.46354 11.2507 3.60254C11.471 3.73926 11.651 3.93294 11.7906 4.18359C11.9302 4.43424 12 4.7373 12 5.09277C12 5.45508 11.916 5.78092 11.748 6.07031C11.5801 6.35742 11.327 6.58415 10.9889 6.75049C10.6507 6.91683 10.2253 7 9.7127 7H7ZM8.21401 5.94043H9.51963C9.9603 5.94043 10.2777 5.8527 10.4719 5.67725C10.6682 5.49951 10.7664 5.27165 10.7664 4.99365C10.7664 4.7863 10.7173 4.59945 10.6191 4.43311C10.5209 4.26449 10.3813 4.13232 10.2003 4.03662C10.0192 3.93864 9.80323 3.88965 9.55236 3.88965H8.21401V5.94043ZM8.21401 2.97705H9.41492C9.62435 2.97705 9.81305 2.93717 9.98102 2.85742C10.149 2.77539 10.281 2.66032 10.377 2.51221C10.4751 2.36182 10.5242 2.18408 10.5242 1.979C10.5242 1.70784 10.4326 1.48454 10.2493 1.30908C10.0683 1.13363 9.79887 1.0459 9.4411 1.0459H8.21401V2.97705Z" fill="white"/><path d="M1.24987 7H0L2.27564 0H3.7212L6 7H4.75013L3.02367 1.43555H2.97317L1.24987 7ZM1.2909 4.25537H4.69963V5.27393H1.2909V4.25537Z" fill="white"/></svg>';
const iconTextSubstring     = '<svg width="17" height="10" viewBox="0 -2 17 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 7V0H8.56544C9.04974 0 9.45223 0.0797524 9.77291 0.239258C10.0958 0.396484 10.3368 0.611816 10.4961 0.885254C10.6575 1.15869 10.7382 1.46859 10.7382 1.81494C10.7382 2.09977 10.6859 2.34359 10.5812 2.54639C10.4764 2.74691 10.3357 2.90983 10.159 3.03516C9.98233 3.16048 9.7849 3.25049 9.56675 3.30518V3.37354C9.80454 3.38721 10.0325 3.46354 10.2507 3.60254C10.471 3.73926 10.651 3.93294 10.7906 4.18359C10.9302 4.43424 11 4.7373 11 5.09277C11 5.45508 10.916 5.78092 10.748 6.07031C10.5801 6.35742 10.327 6.58415 9.98887 6.75049C9.65074 6.91683 9.22535 7 8.7127 7H6ZM7.21401 5.94043H8.51963C8.9603 5.94043 9.2777 5.8527 9.47186 5.67725C9.66819 5.49951 9.76636 5.27165 9.76636 4.99365C9.76636 4.7863 9.71728 4.59945 9.61911 4.43311C9.52094 4.26449 9.38133 4.13232 9.20026 4.03662C9.0192 3.93864 8.80323 3.88965 8.55236 3.88965H7.21401V5.94043ZM7.21401 2.97705H8.41492C8.62435 2.97705 8.81305 2.93717 8.98102 2.85742C9.149 2.77539 9.28098 2.66032 9.37696 2.51221C9.47513 2.36182 9.52421 2.18408 9.52421 1.979C9.52421 1.70784 9.43259 1.48454 9.24935 1.30908C9.06828 1.13363 8.79887 1.0459 8.4411 1.0459H7.21401V2.97705Z" fill="white"/><path d="M1.4991 7.23161C1.29659 7.23161 1.12301 7.16039 0.978358 7.01797C0.833709 6.87554 0.762497 6.70197 0.764722 6.49723C0.762497 6.29695 0.833709 6.12559 0.978358 5.98317C1.12301 5.84074 1.29659 5.76953 1.4991 5.76953C1.69493 5.76953 1.86517 5.84074 2.00982 5.98317C2.1567 6.12559 2.23125 6.29695 2.23347 6.49723C2.23125 6.63298 2.19564 6.75649 2.12665 6.86776C2.05989 6.97902 1.97088 7.06804 1.85961 7.1348C1.75056 7.19934 1.63039 7.23161 1.4991 7.23161Z" fill="white"/><path d="M13.5054 7.23161C13.3029 7.23161 13.1293 7.16039 12.9847 7.01797C12.84 6.87554 12.7688 6.70197 12.7711 6.49723C12.7688 6.29695 12.84 6.12559 12.9847 5.98317C13.1293 5.84074 13.3029 5.76953 13.5054 5.76953C13.7013 5.76953 13.8715 5.84074 14.0162 5.98317C14.163 6.12559 14.2376 6.29695 14.2398 6.49723C14.2376 6.63298 14.202 6.75649 14.133 6.86776C14.0662 6.97902 13.9772 7.06804 13.8659 7.1348C13.7569 7.19934 13.6367 7.23161 13.5054 7.23161Z" fill="white"/><path d="M3.49441 7.23161C3.2919 7.23161 3.11832 7.16039 2.97367 7.01797C2.82902 6.87554 2.75781 6.70197 2.76004 6.49723C2.75781 6.29695 2.82902 6.12559 2.97367 5.98317C3.11832 5.84074 3.2919 5.76953 3.49441 5.76953C3.69025 5.76953 3.86049 5.84074 4.00514 5.98317C4.15201 6.12559 4.22656 6.29695 4.22879 6.49723C4.22656 6.63298 4.19096 6.75649 4.12197 6.86776C4.05521 6.97902 3.96619 7.06804 3.85492 7.1348C3.74588 7.19934 3.62571 7.23161 3.49441 7.23161Z" fill="white"/><path d="M15.5007 7.23161C15.2982 7.23161 15.1247 7.16039 14.98 7.01797C14.8354 6.87554 14.7641 6.70197 14.7664 6.49723C14.7641 6.29695 14.8354 6.12559 14.98 5.98317C15.1247 5.84074 15.2982 5.76953 15.5007 5.76953C15.6966 5.76953 15.8668 5.84074 16.0115 5.98317C16.1583 6.12559 16.2329 6.29695 16.2351 6.49723C16.2329 6.63298 16.1973 6.75649 16.1283 6.86776C16.0615 6.97902 15.9725 7.06804 15.8613 7.1348C15.7522 7.19934 15.632 7.23161 15.5007 7.23161Z" fill="white"/></svg>';
const iconTextReplace       = '<svg width="19" height="16" viewBox="0 0 19 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M19 9.39211H17.7568C17.7213 9.18805 17.656 9.00729 17.5607 8.84981C17.4654 8.69011 17.3468 8.55482 17.205 8.44392C17.0632 8.33302 16.9014 8.24984 16.7197 8.19439C16.5402 8.13672 16.3463 8.10789 16.138 8.10789C15.7679 8.10789 15.4399 8.20105 15.154 8.38736C14.8681 8.57145 14.6443 8.84205 14.4825 9.19914C14.3208 9.55402 14.2399 9.98764 14.2399 10.5C14.2399 11.0212 14.3208 11.4604 14.4825 11.8175C14.6465 12.1724 14.8704 12.4407 15.154 12.6226C15.4399 12.8023 15.7668 12.8921 16.1346 12.8921C16.3385 12.8921 16.5291 12.8655 16.7064 12.8123C16.8859 12.7568 17.0465 12.6759 17.1884 12.5694C17.3324 12.4629 17.4532 12.3321 17.5507 12.1768C17.6504 12.0215 17.7191 11.8441 17.7568 11.6445L19 11.6511C18.9535 11.975 18.8526 12.2788 18.6975 12.5627C18.5446 12.8466 18.344 13.0973 18.0958 13.3146C17.8476 13.5298 17.5573 13.6984 17.2249 13.8203C16.8925 13.9401 16.5235 14 16.118 14C15.5197 14 14.9856 13.8614 14.5158 13.5841C14.046 13.3069 13.6759 12.9065 13.4055 12.3831C13.1352 11.8596 13 11.2319 13 10.5C13 9.76584 13.1363 9.13815 13.4089 8.61692C13.6814 8.09347 14.0526 7.69312 14.5224 7.41587C14.9922 7.13862 15.5241 7 16.118 7C16.497 7 16.8493 7.05323 17.1751 7.1597C17.5008 7.26616 17.7911 7.42253 18.046 7.6288C18.3008 7.83286 18.5103 8.08349 18.6742 8.3807C18.8404 8.6757 18.949 9.01283 19 9.39211Z" fill="white"/><path d="M1.24987 14H0L2.27564 7H3.7212L6 14H4.75013L3.02367 8.43555H2.97317L1.24987 14ZM1.2909 11.2554H4.69963V12.2739H1.2909V11.2554Z" fill="white"/><path d="M8 16V11H10.0759C10.4574 11 10.7755 11.0545 11.0304 11.1636C11.2852 11.2726 11.4768 11.424 11.6051 11.6177C11.7333 11.8097 11.7975 12.0311 11.7975 12.2817C11.7975 12.4771 11.757 12.6488 11.6759 12.7969C11.5949 12.9434 11.4835 13.0638 11.3418 13.1582C11.2017 13.251 11.0414 13.3169 10.8608 13.356V13.4048C11.0582 13.4129 11.243 13.4666 11.4152 13.5659C11.589 13.6652 11.73 13.8044 11.838 13.9834C11.946 14.1608 12 14.3724 12 14.6182C12 14.8835 11.9316 15.1203 11.7949 15.3286C11.6599 15.5353 11.4599 15.6989 11.1949 15.8193C10.93 15.9398 10.6034 16 10.2152 16H8ZM9.0962 15.1357H9.98987C10.2954 15.1357 10.5181 15.0796 10.6582 14.9673C10.7983 14.8534 10.8684 14.702 10.8684 14.5132C10.8684 14.3748 10.8338 14.2528 10.7646 14.147C10.6954 14.0412 10.5966 13.9582 10.4684 13.8979C10.3418 13.8377 10.1907 13.8076 10.0152 13.8076H9.0962V15.1357ZM9.0962 13.0923H9.90886C10.0591 13.0923 10.1924 13.0671 10.3089 13.0166C10.427 12.9645 10.5198 12.8913 10.5873 12.7969C10.6565 12.7025 10.6911 12.5894 10.6911 12.4575C10.6911 12.2769 10.6245 12.1312 10.4911 12.0205C10.3595 11.9098 10.1722 11.8545 9.92911 11.8545H9.0962V13.0923Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9.05758 8.64355L9.23002 8.76764L9.73959 8.05948L11.0933 6.90017L10.4428 6.14064L9.48886 6.95761C9.48453 5.97188 9.30757 4.81845 8.79688 3.77457C8.18769 2.52934 7.10594 1.45073 5.33322 1.02438L5.09938 1.99666C6.54887 2.34526 7.40452 3.20406 7.89862 4.21402C8.33403 5.10405 8.48993 6.11878 8.48896 7.00242L7.35652 6.18756L6.77245 6.99926L8.22215 8.04242L8.00316 8.22997L8.65362 8.9895L9.05758 8.64355Z" fill="white"/></svg>';
const iconTextJoin          = '<svg width="19" height="7" viewBox="0 0 19 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.9328 6V1H10.0672V6H8.9328ZM7 4.0672V2.9328H12V4.0672H7Z" fill="white"/><path d="M14 7V0H16.5654C17.0497 0 17.4522 0.0797524 17.7729 0.239258C18.0958 0.396484 18.3368 0.611816 18.4961 0.885254C18.6575 1.15869 18.7382 1.46859 18.7382 1.81494C18.7382 2.09977 18.6859 2.34359 18.5812 2.54639C18.4764 2.74691 18.3357 2.90983 18.159 3.03516C17.9823 3.16048 17.7849 3.25049 17.5668 3.30518V3.37354C17.8045 3.38721 18.0325 3.46354 18.2507 3.60254C18.471 3.73926 18.651 3.93294 18.7906 4.18359C18.9302 4.43424 19 4.7373 19 5.09277C19 5.45508 18.916 5.78092 18.748 6.07031C18.5801 6.35742 18.327 6.58415 17.9889 6.75049C17.6507 6.91683 17.2253 7 16.7127 7H14ZM15.214 5.94043H16.5196C16.9603 5.94043 17.2777 5.8527 17.4719 5.67725C17.6682 5.49951 17.7664 5.27165 17.7664 4.99365C17.7664 4.7863 17.7173 4.59945 17.6191 4.43311C17.5209 4.26449 17.3813 4.13232 17.2003 4.03662C17.0192 3.93864 16.8032 3.88965 16.5524 3.88965H15.214V5.94043ZM15.214 2.97705H16.4149C16.6243 2.97705 16.813 2.93717 16.981 2.85742C17.149 2.77539 17.281 2.66032 17.377 2.51221C17.4751 2.36182 17.5242 2.18408 17.5242 1.979C17.5242 1.70784 17.4326 1.48454 17.2493 1.30908C17.0683 1.13363 16.7989 1.0459 16.4411 1.0459H15.214V2.97705Z" fill="white"/><path d="M1.24987 7H0L2.27564 0H3.7212L6 7H4.75013L3.02367 1.43555H2.97317L1.24987 7ZM1.2909 4.25537H4.69963V5.27393H1.2909V4.25537Z" fill="white"/></svg>';
const iconTextCharacter     = '<svg width="16" height="11" viewBox="0 0 16 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.0334 0V11H12.0334V10H14.0667L14.0334 1H12L12.0334 0H15.0334Z" fill="white"/><path d="M0 11V0H3V1H0.966639V10H3V11H0Z" fill="white"/><path d="M9.01993 6.08483V2H10V8.91003H9.01993V7.74036H8.95349C8.80399 8.09126 8.57143 8.38968 8.25581 8.6356C7.9402 8.87854 7.54153 9 7.0598 9C6.66113 9 6.30676 8.90553 5.99668 8.71658C5.6866 8.52464 5.44297 8.23672 5.26578 7.85283C5.08859 7.46594 5 6.97858 5 6.39075V2H5.98007V6.31877C5.98007 6.82262 6.11019 7.22451 6.37043 7.52442C6.63344 7.82434 6.96844 7.97429 7.37542 7.97429C7.61905 7.97429 7.86683 7.90681 8.11877 7.77185C8.37348 7.63689 8.58666 7.42995 8.75831 7.15103C8.93272 6.87211 9.01993 6.51671 9.01993 6.08483Z" fill="white"/></svg>';
const iconTextCSV           = '<svg width="19" height="10" viewBox="0 0 19 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M13 3H19V4H13V3Z" fill="white"/><path d="M13 0H19V1H13V0Z" fill="white"/><path d="M13 6H19V7H13V6Z" fill="white"/><path d="M13 9H19V10H13V9Z" fill="white"/><path d="M2.37774 3.5L2.32234 3.96875C2.28257 4.3267 2.21155 4.69034 2.10928 5.05966C2.00984 5.43182 1.90473 5.77415 1.79393 6.08665C1.68314 6.39915 1.10795 6.82102 1.03977 7H0C0.0397727 6.8267 0.579446 6.41477 0.647628 6.11648C0.718651 5.81818 0.786833 5.48296 0.852173 5.1108C0.647628 4.90081 0.210938 5.05966 0 5V3.5H2.37774Z" fill="white"/><path d="M6.37774 3.5L6.32234 3.96875C6.28257 4.3267 6.21155 4.69034 6.10928 5.05966C6.00984 5.43182 5.90473 5.77415 5.79393 6.08665C5.68314 6.39915 5.10795 6.82102 5.03977 7H4C4.03977 6.8267 4.57945 6.41477 4.64763 6.11648C4.71865 5.81818 4.78683 5.48296 4.85217 5.1108C4.64763 4.90081 4.21094 5.05966 4 5V3.5H6.37774Z" fill="white"/><path d="M10.3777 3.5L10.3223 3.96875C10.2826 4.3267 10.2115 4.69034 10.1093 5.05966C10.0098 5.43182 9.90473 5.77415 9.79393 6.08665C9.68314 6.39915 9.10795 6.82102 9.03977 7H8C8.03977 6.8267 8.57945 6.41477 8.64763 6.11648C8.71865 5.81818 8.78683 5.48296 8.85217 5.1108C8.64763 4.90081 8.21094 5.05966 8 5V3.5H10.3777Z" fill="white"/></svg>';
const iconTextFetch         = '<svg width="17" height="11" viewBox="0 0 17 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.5 5.51719V4.98437C1.05152 4.98437 1.93627 4.88411 2.15423 4.68359C2.3755 4.48307 2.48614 4.14792 2.48614 3.67813V2.30313C2.48614 1.90781 2.52907 1.56549 2.61494 1.27617C2.70411 0.986849 2.84777 0.747657 3.04592 0.558594C3.24407 0.369532 3.50827 0.229167 3.83853 0.137501C4.16878 0.0458335 5.51453 0 6 0V0.842188C5.61691 0.842188 4.37684 0.89375 4.15557 0.996875C3.9376 1.1 3.78238 1.26042 3.68991 1.47813C3.60074 1.69297 3.55616 1.96797 3.55616 2.30313V4.02188C3.55616 4.24531 3.52148 4.4487 3.45213 4.63203C3.38608 4.81536 3.26223 4.97292 3.08059 5.10469C2.89896 5.23646 2.63971 5.33815 2.30285 5.40977C1.96929 5.48138 1.03501 5.51719 0.5 5.51719ZM6 11C5.51453 11 4.16878 10.9542 3.83853 10.8625C3.50827 10.7708 3.24407 10.6305 3.04592 10.4414C2.84777 10.2523 2.70411 10.0132 2.61494 9.72383C2.52907 9.4345 2.48614 9.09219 2.48614 8.69687V7.32188C2.48614 6.85208 2.3755 6.51693 2.15423 6.31641C1.93627 6.11589 1.05152 6.01562 0.5 6.01562V5.48281C1.03501 5.48281 1.96929 5.51862 2.30285 5.59023C2.63971 5.66185 2.89896 5.76354 3.08059 5.89531C3.26223 6.02708 3.38608 6.18464 3.45213 6.36797C3.52148 6.5513 3.55616 6.75469 3.55616 6.97813V8.69687C3.55616 9.03203 3.60074 9.30703 3.68991 9.52188C3.78238 9.73672 3.9376 9.8957 4.15557 9.99883C4.37684 10.1048 5.61691 10.1578 6 10.1578V11ZM0.5 6.01562V4.98437H2.1691V6.01562H0.5Z" fill="white"/><path d="M16.5 5.48281V6.01562C15.9485 6.01562 15.0621 6.11589 14.8408 6.31641C14.6228 6.51693 14.5139 6.85208 14.5139 7.32188V8.69687C14.5139 9.09219 14.4693 9.4345 14.3801 9.72383C14.2942 10.0132 14.1522 10.2523 13.9541 10.4414C13.7559 10.6305 13.4917 10.7708 13.1615 10.8625C12.8312 10.9542 11.4855 11 11 11V10.1578C11.3831 10.1578 12.6215 10.1048 12.8395 9.99883C13.0607 9.8957 13.216 9.73672 13.3051 9.52188C13.3976 9.30703 13.4438 9.03203 13.4438 8.69687V6.97813C13.4438 6.75469 13.4769 6.5513 13.5429 6.36797C13.6123 6.18464 13.7378 6.02708 13.9194 5.89531C14.101 5.76354 14.3586 5.66185 14.6922 5.59023C15.0291 5.51862 15.965 5.48281 16.5 5.48281ZM11 0C11.4855 0 12.8312 0.0458335 13.1615 0.137501C13.4917 0.229167 13.7559 0.369532 13.9541 0.558594C14.1522 0.747657 14.2942 0.986849 14.3801 1.27617C14.4693 1.56549 14.5139 1.90781 14.5139 2.30313V3.67813C14.5139 4.14792 14.6228 4.48307 14.8408 4.68359C15.0621 4.88411 15.9485 4.98437 16.5 4.98437V5.51719C15.965 5.51719 15.0291 5.48138 14.6922 5.40977C14.3586 5.33815 14.101 5.23646 13.9194 5.10469C13.7378 4.97292 13.6123 4.81536 13.5429 4.63203C13.4769 4.4487 13.4438 4.24531 13.4438 4.02188V2.30313C13.4438 1.96797 13.3976 1.69297 13.3051 1.47813C13.216 1.26042 13.0607 1.1 12.8395 0.996875C12.6215 0.89375 11.3831 0.842188 11 0.842188V0ZM16.5 4.98437V6.01562H14.8309V4.98437H16.5Z" fill="white"/></svg>';

const iconColor             = '<svg width="13" height="15" viewBox="0 0 13 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.8409 3.43385C10.7465 2.2502 9.18038 1.50909 7.44118 1.50909C4.13249 1.50909 1.45027 4.19132 1.45027 7.5C1.45027 10.8087 4.13249 13.4909 7.44118 13.4909C9.18038 13.4909 10.7465 12.7498 11.8409 11.5662" stroke="white" stroke-width="1.2"/><path d="M7.5 8.57512C8.09377 8.57512 8.57511 8.09378 8.57511 7.50001C8.57511 6.90624 8.09377 6.4249 7.5 6.4249C6.90623 6.4249 6.42489 6.90624 6.42489 7.50001C6.42489 8.09378 6.90623 8.57512 7.5 8.57512Z" fill="white"/></svg>';
const iconRandomColor       = '<svg width="13" height="15" viewBox="0 0 13 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.9099 3.43385C10.8155 2.2502 9.24936 1.50909 7.51016 1.50909C4.20148 1.50909 1.51926 4.19132 1.51926 7.5C1.51926 10.8087 4.20148 13.4909 7.51016 13.4909C9.24936 13.4909 10.8155 12.7498 11.9099 11.5662" stroke="white" stroke-width="1.2"/><path d="M6.77317 8.80159V8.71763C6.77533 8.32795 6.81193 8.01793 6.88297 7.78757C6.95617 7.55721 7.05951 7.37206 7.19299 7.23212C7.32647 7.09003 7.48902 6.95978 7.68063 6.84137C7.81195 6.75956 7.92929 6.67021 8.03263 6.57333C8.13812 6.4743 8.22101 6.3645 8.28129 6.24393C8.34157 6.12122 8.37171 5.98451 8.37171 5.8338C8.37171 5.66372 8.33188 5.51625 8.25222 5.39138C8.17257 5.26651 8.06492 5.16963 7.92929 5.10074C7.79581 5.03184 7.64618 4.9974 7.4804 4.9974C7.32755 4.9974 7.18223 5.03077 7.04444 5.09751C6.90881 5.16209 6.79578 5.26113 6.70536 5.39461C6.61709 5.52594 6.56757 5.69279 6.55681 5.89516H5.40715C5.41791 5.48611 5.51695 5.14379 5.70425 4.86822C5.89371 4.59265 6.14345 4.38597 6.45347 4.24818C6.76564 4.1104 7.1101 4.0415 7.48686 4.0415C7.89807 4.0415 8.25976 4.11363 8.57193 4.25787C8.88626 4.40212 9.13061 4.60772 9.305 4.87468C9.48154 5.13949 9.56981 5.45381 9.56981 5.81766C9.56981 6.06309 9.52998 6.28269 9.45032 6.47645C9.37281 6.67021 9.26194 6.84244 9.11769 6.99315C8.97345 7.14385 8.80229 7.27841 8.60423 7.39682C8.42984 7.50446 8.28667 7.61642 8.17472 7.73267C8.06492 7.84893 7.98311 7.98564 7.92929 8.1428C7.87762 8.29781 7.85071 8.48942 7.84855 8.71763V8.80159H6.77317Z" fill="white"/><path d="M6.7784 10.8136C6.94344 10.9761 7.14021 11.0574 7.36872 11.0574C7.52106 11.0574 7.65943 11.0205 7.78384 10.9469C7.91079 10.8707 8.01235 10.7692 8.08852 10.6422C8.16723 10.5153 8.20658 10.3744 8.20658 10.2195C8.20658 9.99099 8.1228 9.79549 7.95522 9.63299C7.79019 9.4705 7.59469 9.38925 7.36872 9.38925C7.14021 9.38925 6.94344 9.4705 6.7784 9.63299C6.61337 9.79549 6.53085 9.99099 6.53085 10.2195C6.53085 10.4531 6.61337 10.6511 6.7784 10.8136Z" fill="white"/></svg>';
const iconValidColor        = '<svg width="17" height="15" viewBox="-1 0 17 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.8409 11.5662C10.7465 12.7498 9.18038 13.4909 7.44118 13.4909C4.13249 13.4909 1.45027 10.8087 1.45027 7.5C1.45027 4.19131 4.13249 1.50909 7.44118 1.50909C8.66322 1.50909 9.80806 2.02212 10.7556 2.65033" stroke="white" stroke-width="1.2"/><path fill-rule="evenodd" clip-rule="evenodd" d="M15.6832 3.62548L9.18921 10.1195L5.38744 6.31769L6.52965 5.17548L9.18921 7.83504L14.5411 2.48326L15.6832 3.62548Z" fill="white"/></svg>';
const iconCorrectColor      = '<svg width="14" height="15" viewBox="0 0 14 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11.9123 3.43385C10.8179 2.2502 9.25181 1.50909 7.51261 1.50909C4.20392 1.50909 1.5217 4.19132 1.5217 7.5C1.5217 10.8087 4.20392 13.4909 7.51261 13.4909C9.25181 13.4909 10.8179 12.7498 11.9123 11.5662" stroke="white" stroke-width="1.2"/><path d="M6.97348 10.659L7.06123 8.24587L5.02106 9.54017L4.49457 8.61881L6.64443 7.5L4.49457 6.3812L5.02106 5.45983L7.06123 6.75414L6.97348 4.34103H8.02648L7.93873 6.75414L9.9789 5.45983L10.5054 6.3812L8.35554 7.5L10.5054 8.61881L9.9789 9.54017L7.93873 8.24587L8.02648 10.659H6.97348Z" fill="white"/></svg>';
const iconWebContrast       = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 4H8V12H10V11H9V5H11V6.267H12V4Z" fill="white"/><path d="M12 4H8V12H10V11H9V5H11V6.267H12V4Z" fill="white"/><path d="M12 4H8V12H10V11H9V5H11V6.267H12V4Z" fill="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M0 1.5C0 0.671573 0.671573 0 1.5 0H14.5C15.3284 0 16 0.671573 16 1.5V14.5C16 15.3284 15.3284 16 14.5 16H1.5C0.671573 16 0 15.3284 0 14.5V1.5ZM8 1H14.5C14.7761 1 15 1.22386 15 1.5V14.5C15 14.7761 14.7761 15 14.5 15H8V12.2H5.47075V10.8H6.8V5.2H5.22306V6.73713H3.80043V3.8H8V1Z" fill="white"/></svg>';
const iconColorblind        = '<svg width="21" height="21" viewBox="0 0 21 21" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 19.5371C15.491 19.5371 19.5371 15.491 19.5371 10.5C19.5371 5.50898 15.491 1.46295 10.5 1.46295C5.50898 1.46295 1.46295 5.50898 1.46295 10.5C1.46295 15.491 5.50898 19.5371 10.5 19.5371Z" stroke="white"/><path fill-rule="evenodd" clip-rule="evenodd" d="M9.37288 4.83079C9.73798 4.75856 10.1149 4.7208 10.5 4.7208C10.8851 4.7208 11.262 4.75856 11.6271 4.83079L11.3554 6.20417C11.0793 6.14955 10.7934 6.1208 10.5 6.1208C10.2066 6.1208 9.92068 6.14955 9.64458 6.20417L9.37288 4.83079ZM5.69463 7.2885C6.11636 6.65857 6.65856 6.11636 7.28849 5.69464L8.06734 6.85799C7.58948 7.17791 7.17791 7.58948 6.85799 8.06734L5.69463 7.2885ZM13.7115 5.69464C14.3414 6.11636 14.8836 6.65857 15.3054 7.2885L14.142 8.06734C13.8221 7.58948 13.4105 7.17791 12.9327 6.85799L13.7115 5.69464ZM16.1692 9.37289C16.2414 9.73799 16.2792 10.1149 16.2792 10.5C16.2792 10.8851 16.2414 11.262 16.1692 11.6271L14.7958 11.3554C14.8504 11.0793 14.8792 10.7934 14.8792 10.5C14.8792 10.2066 14.8504 9.92068 14.7958 9.64458L16.1692 9.37289ZM4.7208 10.5C4.7208 10.1149 4.75856 9.73799 4.83078 9.37289L6.20417 9.64458C6.14955 9.92068 6.1208 10.2066 6.1208 10.5C6.1208 10.7934 6.14955 11.0793 6.20417 11.3554L4.83078 11.6271C4.75856 11.262 4.7208 10.8851 4.7208 10.5ZM7.28849 15.3054C6.65856 14.8836 6.11636 14.3414 5.69463 13.7115L6.85799 12.9327C7.17791 13.4105 7.58948 13.8221 8.06734 14.142L7.28849 15.3054ZM15.3054 13.7115C14.8836 14.3414 14.3414 14.8836 13.7115 15.3054L12.9327 14.142C13.4105 13.8221 13.8221 13.4105 14.142 12.9327L15.3054 13.7115ZM10.5 16.2792C10.1149 16.2792 9.73798 16.2414 9.37288 16.1692L9.64458 14.7958C9.92068 14.8505 10.2066 14.8792 10.5 14.8792C10.7934 14.8792 11.0793 14.8505 11.3554 14.7958L11.6271 16.1692C11.262 16.2414 10.8851 16.2792 10.5 16.2792Z" fill="white"/><path d="M10.5 11.9909C11.3234 11.9909 11.9909 11.3234 11.9909 10.5C11.9909 9.6766 11.3234 9.0091 10.5 9.0091C9.6766 9.0091 9.0091 9.6766 9.0091 10.5C9.0091 11.3234 9.6766 11.9909 10.5 11.9909Z" fill="white"/></svg>';
const iconColorInterpolate  = '<svg width="18" height="19" viewBox="0 0 18 19" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="2.5" r="2.5" fill="white" fill-opacity="0.1"/><circle cx="9.5" cy="2.5" r="2" stroke="white" stroke-opacity="0.4"/><circle cx="2.5" cy="9.5" r="2.5" fill="white" fill-opacity="0.4"/><circle cx="2.5" cy="9.5" r="2" stroke="white" stroke-opacity="0.61"/><circle cx="9.5" cy="16.5" r="2.5" fill="white" fill-opacity="0.8"/><circle cx="9.5" cy="16.5" r="2" stroke="white" stroke-opacity="0.9"/><circle cx="14.5" cy="14.5" r="2" fill="white" stroke="white"/><circle cx="14.5" cy="4.5" r="2" stroke="white" stroke-opacity="0.4"/><circle cx="4.5" cy="14.5" r="2.5" fill="white" fill-opacity="0.6"/><circle cx="4.5" cy="14.5" r="2" stroke="white" stroke-opacity="0.8"/><circle cx="4.5" cy="4.5" r="2.5" fill="white" fill-opacity="0.2"/><circle cx="4.5" cy="4.5" r="2" stroke="white" stroke-opacity="0.55"/></svg>';
const iconColorBlend        = '<svg width="14" height="15" viewBox="-1 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M-4.02642e-07 9C-5.48785e-07 10.5913 0.63214 12.1174 1.75736 13.2426C2.88258 14.3679 4.4087 15 6 15C7.5913 15 9.11742 14.3679 10.2426 13.2426C11.3679 12.1174 12 10.5913 12 9L6 9L-4.02642e-07 9Z" fill="white"/><path d="M0.499999 9.2647C0.499999 7.80555 0.917848 6.69229 1.85417 5.39097C2.66503 4.26403 3.84136 3.02592 5.4562 1.32626C5.64008 1.13273 5.82964 0.933209 6.02499 0.727189C6.22035 0.933214 6.40992 1.13274 6.5938 1.32628C8.20864 3.02593 9.38496 4.26403 10.1958 5.39097C11.1321 6.69229 11.55 7.80555 11.55 9.26471C11.55 12.1331 9.09987 14.5 6.02499 14.5C2.95012 14.5 0.499998 12.1331 0.499999 9.2647Z" stroke="white"/></svg>';
 
const iconFill              = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="6" cy="6" r="6" fill="white"/></svg>';
const iconStroke            = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="6" cy="6" r="5.4" stroke="white" stroke-width="1.2"/></svg>';
 
const iconStyle             = '<svg width="12" height="9"  viewBox="0 0 12 9"  fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="7.5" cy="1.5" r="1.5" transform="rotate(90 7.5 1.5)" fill="white"/><circle cx="1.5" cy="1.5" r="1.5" transform="rotate(90 1.5 1.5)" fill="white"/><circle cx="7.5" cy="7.5" r="1.5" transform="rotate(90 7.5 7.5)" fill="white"/><circle cx="1.5" cy="7.5" r="1.5" transform="rotate(90 1.5 7.5)" fill="white"/></svg>';
const iconColorStyle        = '<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.53553 9.53552C8.63071 10.4403 7.38071 11 6 11C3.23858 11 1 8.76141 1 6C1 4.61929 1.55965 3.36929 2.46447 2.46448L6 6L9.53553 9.53552ZM12 6C12 9.31372 9.31371 12 6 12C2.68629 12 0 9.31372 0 6C0 4.34314 0.67157 2.84314 1.75735 1.75735C1.77346 1.74124 1.78965 1.72525 1.80592 1.70935C2.88722 0.652252 4.36652 0.000518799 5.99803 0C5.99869 0 5.99934 0 6 0C9.31305 0 11.9989 2.68521 12 5.99802C12 5.99869 12 5.99933 12 6Z" fill="white"/></svg>';
const iconColorStyleReplace = '<svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.18718 13.3189L7.83883 10.6673L8.54594 11.3744L5.89429 14.026C4.62509 15.2952 2.5673 15.2952 1.2981 14.026C0.0288918 12.7568 0.0288916 10.699 1.2981 9.42982L3.94975 6.77817L4.65685 7.48528L2.0052 10.1369C1.12652 11.0156 1.12652 12.4402 2.0052 13.3189C2.88388 14.1976 4.3085 14.1976 5.18718 13.3189ZM11.3744 8.54594L10.6673 7.83883L13.3189 5.18718C14.1976 4.3085 14.1976 2.88388 13.3189 2.0052C12.4402 1.12652 11.0156 1.12652 10.1369 2.0052L7.48528 4.65685L6.77817 3.94975L9.42982 1.2981C10.699 0.0288935 12.7568 0.0288931 14.026 1.2981C15.2952 2.5673 15.2952 4.62509 14.026 5.89429L11.3744 8.54594ZM5.92375 10.1664L10.1664 5.92375L9.40036 5.15772L5.15772 9.40036L5.92375 10.1664Z" fill="white"/></svg>';

const iconShapes            = '<svg width="17" height="19" viewBox="0 -1 17 19" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="1.53844" y="1.49869" width="5" height="5" stroke="white"/><circle cx="12.8668" cy="3.99869" r="3" stroke="white"/><line x1="0.933922" y1="16.7012" x2="7.26322" y2="10.3719" stroke="white"/><path d="M9.61918 15.709L12.8668 10.084L16.1144 15.709H9.61918Z" stroke="white"/></svg>';

const iconRectangle         = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="15" height="15" stroke="white"/></svg>';
const iconLine              = '<svg width="17" height="17" viewBox="0 1 17 18" fill="none" xmlns="http://www.w3.org/2000/svg"><line x1="0.772299" y1="15.9778" x2="15.6598" y2="1.09027" stroke="white" stroke-width="1.3"/></svg>';
const iconEllipse           = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="7.5" stroke="white"/></svg>';
const iconPolygon           = '<svg width="20" height="16" viewBox="0 0 20 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.82238 15.4885L10.0496 1.23853L18.2769 15.4885H1.82238Z" stroke="white"/></svg>';
const iconStar              = '<svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.8156 2.24924L10.4021 7.13198L10.5144 7.47747H10.8776H16.0116L11.8581 10.4952L11.5642 10.7087L11.6765 11.0542L13.263 15.9369L9.10949 12.9192L8.8156 12.7057L8.5217 12.9192L4.3682 15.9369L5.9547 11.0542L6.06695 10.7087L5.77306 10.4952L1.61955 7.47747H6.75357H7.11684L7.2291 7.13198L8.8156 2.24924Z" stroke="white"/></svg>';
const iconTextShape         = '<svg width="13" height="16" viewBox="0 0 13 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0 4V0H13V4H12V1H7V15H10V16H3V15H6V1H1V4H0Z" fill="white"/></svg>';
const iconSelected          = '<svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="4.5" y="4.5" width="4" height="4" stroke="white"/><circle cx="12.5" cy="6.5" r="2" stroke="white"/><line x1="4.4364" y1="15.069" x2="8.9364" y2="10.3022" stroke="white"/><path d="M10.3349 14.75L12.5 11L14.6651 14.75H10.3349Z" stroke="white"/><rect x="0.5" y="0.5" width="2" height="2" stroke="white"/><rect x="0.5" y="16.5" width="2" height="2" stroke="white"/><rect x="16.5" y="16.5" width="2" height="2" stroke="white"/><rect x="16.5" y="0.5" width="2" height="2" stroke="white"/><rect x="3" y="1" width="13" height="1" fill="white"/><rect x="3" y="17" width="13" height="1" fill="white"/><rect x="17" y="16" width="13" height="1" transform="rotate(-90 17 16)" fill="white"/><rect x="1" y="16" width="13" height="1" transform="rotate(-90 1 16)" fill="white"/></svg>';
 
const iconGroup             = '<svg width="17" height="17" viewBox="0 -1 17 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 0.5H14C15.3807 0.5 16.5 1.61929 16.5 3V15.5H0.5V3C0.5 1.61929 1.61929 0.5 3 0.5Z" stroke="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 14 4)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 9 6)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 12 9)" fill="white"/><rect width="4" height="1" transform="matrix(-1 0 0 1 7 11)" fill="white"/></svg>';
const iconGroupNode         = '<svg width="15" height="18" viewBox="0 -3 15 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 0.5H12C13.3807 0.5 14.5 1.61929 14.5 3V14.5H0.5V3C0.5 1.61929 1.61929 0.5 3 0.5Z" stroke="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 12 5)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 12 8)" fill="white"/><rect width="9" height="1" transform="matrix(-1 0 0 1 12 11)" fill="white"/></svg>';
const iconGroupParam        = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="10" height="10" rx="1.5" stroke="white"/><circle cx="5.5" cy="5.5" r="1.5" fill="white"/></svg>';


const iconHand              = '<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.85653 12.2494L1.8554 12.2484C1.32015 11.771 1.2929 10.8911 1.7976 10.3815C2.3023 9.87193 3.1824 9.89065 3.665 10.4213L3.67129 10.4282L3.67773 10.435L4.27294 11.0653L5.99999 12.8943V10.3788V4C5.99999 3.46423 6.46423 3 6.99999 3C7.16906 3 7.33572 3.04789 7.48718 3.13836L7.99999 3.44469V9H8.99999V4.04203V3V2.27986V2C8.99999 1.46423 9.46423 1 9.99999 1C10.4142 1 10.807 1.27942 10.9437 1.66905L11.0597 2H11V9H12V2.4661L12.4437 2.16905C12.6058 2.06052 12.804 2 13 2C13.5358 2 14 2.46423 14 3V4V4.27549V6.02711V9H15V5.43676L15.5084 5.13662C15.6583 5.04814 15.8261 5 16 5C16.5358 5 17 5.46423 17 6V13.5C17 15.6001 15.7227 17.6052 13.812 18.4904C11.8955 19.3783 9.56768 19.0654 7.95351 17.7039L1.85653 12.2494ZM15 4.27549V4V3.17508V3C15 1.91195 14.088 1 13 1C12.9434 1 12.8868 1.00246 12.8304 1.00733C12.4943 1.03638 12.1668 1.15099 11.8873 1.3381C11.7759 1.02046 11.5846 0.741833 11.341 0.522228C10.9792 0.195965 10.5019 0 9.99999 0C9.18005 0 8.46014 0.517876 8.15511 1.23874C8.05538 1.47446 7.99999 1.73188 7.99999 2V2.27986C7.70403 2.10307 7.36184 2.00018 7.00094 2H6.99999C5.91195 2 4.99999 2.91195 4.99999 4V8.92652V9.18641V9.20713V10.3788L4.40481 9.74846C4.2821 9.61355 4.14593 9.49706 3.99999 9.39906C3.11355 8.80379 1.86654 8.89082 1.08709 9.67785C0.179345 10.5944 0.227074 12.136 1.18978 12.9947L7.2972 18.4585C9.20886 20.0788 11.9586 20.4512 14.2324 19.3978C16.4971 18.3486 18 15.989 18 13.5V6C18 4.91195 17.088 4 16 4C15.6382 4 15.2958 4.10085 15 4.27549Z" fill="white"/></svg>';

const iconComment           = '<svg width="18" height="17" viewBox="0 0 18 17" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.92701 11.5375L3.6897 11.045C3.24801 10.1283 3 9.09994 3 8.01086C3 4.14487 6.13401 1.01086 10 1.01086C13.866 1.01086 17 4.14487 17 8.01086C17 11.8769 13.866 15.0109 10 15.0109C8.89526 15.0109 7.85296 14.7557 6.92628 14.302L6.65842 14.1708L6.36249 14.2078L1.94388 14.7601L3.64047 12.0032L3.92701 11.5375ZM0.671856 14.9191L0 16.0109L1.27203 15.8519L6.48652 15.2001C7.5471 15.7194 8.73951 16.0109 10 16.0109C14.4183 16.0109 18 12.4292 18 8.01086C18 3.59258 14.4183 0.0108643 10 0.0108643C5.58172 0.0108643 2 3.59258 2 8.01086C2 9.25344 2.28329 10.4299 2.78881 11.4791L0.671856 14.9191Z" fill="white"/></svg>';

const iconWindowNormal      = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect x="4" y="4" width="7" height="4" fill="white"/></svg>';
const iconWindowMaximize    = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="15" height="12" fill="white"/></svg>';
const iconWindowDockLeft    = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect width="7" height="12" fill="white"/></svg>';
const iconWindowDockRight   = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect x="8" width="7" height="12" fill="white"/></svg>';
const iconWindowDockTop     = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect width="15" height="5" fill="white"/></svg>';
const iconWindowDockBottom  = '<svg width="15" height="12" viewBox="0 0 15 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="14" height="11" stroke="white"/><rect y="7" width="15" height="5" fill="white"/></svg>';


var currentMenus      = [];
var currentMenuButton = null;



class Menu
{
    parentMenu = null;

    name;
    button = null;

    div;
    divArrow;

    showChecks;
    showIcons;

    showOnLeft = false;

    combineChecksAndIcons = false; // conflicts are resolved in favor of icons

    overMenu = false;

    items    = [];
    lastItem = null;

    reverse  = false;
    
    minWidth = 200;

    init     = null; // ()


    onHide   = null; // removes itself after firing



    constructor(name, showIcons = true, showChecks = true)
    {
        this.name       = name;

        this.showIcons  = showIcons;
        this.showChecks = showChecks;

        this.divArrow   = createDiv('menuArrow');
        this.div        = createDiv('menu');
        this.divItems   = createDiv('menuItems');

        this.div.appendChild(this.divItems);

        this.div.addEventListener('pointerenter', () => this.overMenu = true );
        this.div.addEventListener('pointerleave', () => this.overMenu = false);
    }



    clearItems()
    {
        while (this.divItems.firstChild)
            this.divItems.removeChild(this.divItems.firstChild);

        this.items    = [];
        this.lastItem = null;
    }



    addItems(items)
    {
        for (let i = 0; i < items.length; i++)
        {
            const item = items[i];

            if (i > 0) 
                item.div.appendChild(document.createElement('br'));

            if (!this.showIcons ) item.divIcon .style.display = 'none';
            if (!this.showChecks) item.divCheck.style.width   = this.showIcons ? 18 : 15;

            item.parentMenu = this;
            item.index      = i;

            this.items.push(item);
            this.divItems.appendChild(item.div);
        }


        if (   !this.lastItem
            && !isEmpty(this.items))
            this.lastItem = this.items[0];


        if (this.button)
            this.button.update();
    }



    initMenu()
    {
        if (this.init)
            this.init();

            
        utilContext.font = '12px Inter';

        
        let width = 0;

        for (const item of this.items)
        {
            const mesName     = utilContext.measureText(item.name);
            const mesShortcut = utilContext.measureText(item.shortcut);

            let checksAndIcons = 
                  (item.parentMenu.showChecks  ? 32 : 0)
                + (item.parentMenu.showIcons   ? 32 : 0)
                + (item.childMenu != undefined ? 32 : 0);

            if (this.combineChecksAndIcons)
                checksAndIcons = Math.min(checksAndIcons, 32);

            width = Math.max(
                  width, 
                  checksAndIcons
                + mesName.width 
                + 30 
                + mesShortcut.width 
                + (mesShortcut.width > 0 ? 20 : 0));


            if (this.combineChecksAndIcons)
            {
                item.divCheck.style.display = item.icon == NULL ? 'inline-block' : 'none';
                item.divIcon .style.display = item.icon != NULL ? 'inline-block' : 'none';
            }
        }


        this.divItems.style.width = Math.max(this.minWidth, width) + 'px';
    }



    show(srcDiv, subMenu, right = false)
    {
        if (graphView._soloNode);
            graphView.unsoloNode();


        this.initMenu();


        this.div.style.display = 'block';
        this.div.style.opacity = '100%';


        if (!right)
        {
            this.divArrow.style.display = 'block';
            this.divArrow.style.opacity = '100%';
        }


        document.body.appendChild(this.div     );
        document.body.appendChild(this.divArrow);


        let srcRect = srcDiv.getBoundingClientRect();

        srcRect.y -= 5;


        const margin = 8;

        const x = Math.min(Math.max(
            margin, 
            right
            ? (this.showOnLeft ? srcRect.x - this.div.offsetWidth : srcRect.x + srcRect.width)
            : srcRect.x + srcRect.width/2 - this.div.offsetWidth/2),
            graphView.div.offsetWidth - this.div.offsetWidth - margin);


        const dy = subMenu ? 4 : -1;

        const y =
            right
            ? srcRect.y - dy - 3
            : srcRect.y - dy + srcRect.height + this.divArrow.offsetHeight;


        this.showAt(x + 6, y, subMenu, false);
        
            
        const menuRect = this.div.getBoundingClientRect();
        
        this.divArrow.style.left = srcRect.x + srcRect.width/2;
        this.divArrow.style.top  = menuRect.y - this.divArrow.offsetHeight + 2;


        if (this.button)
            this.button.update();
    }



    showAt(x, y, subMenu, hidePrev = true)
    {
        if (graphView._soloNode);
            graphView.unsoloNode();


        if (hidePrev)
            hideAllMenus();


        this.initMenu();


        this.div.style.display = 'block';
        this.div.style.opacity = '100%';

        document.body.appendChild(this.div);


        const margin = 8;

        const  dy    = subMenu ? 0 : 4;
        const _dy    = subMenu ? 4 : 0;

        let   left   = Math.min(Math.max(margin, x), graphView.div.offsetWidth - this.div.offsetWidth - margin) - 6;
        let   top    = y - dy;


        let height = 0;
        
        for (const item of this.items)
            if (item.div.style.display != 'none')
                height += item.separator ? 17 : 25;


        const graphHeight = graphView.div.offsetHeight - getTopHeight();

        if (top + height > graphView.div.offsetHeight-8)
        {
            height = Math.min(height, graphHeight - 16);
            top    = getTopHeight() + Math.max(8, graphHeight - height);
            
            if (!subMenu)
                left  += 10; // so it doesn't hit a menu item by accident once the menu appears
        }


        this.div.style.overflowY = 
            top + height > graphHeight-8 
            ? 'overlay' 
            : 'hidden';

        
        this.div.style.left   = left;
        this.div.style.top    = top + _dy;
        this.div.style.height = height + 'px';


        currentMenus.push(this);
    }



    hide()
    {
        if (this.onHide)
        {
            this.onHide();
            this.onHide = null;
        }


        this.div     .style.display = 'none';
        this.div     .style.opacity = '0%';

        this.divArrow.style.display = 'none';
        this.divArrow.style.opacity = '0%';


        if (    this.button
            && !this.button.overArrow)
        {
            this.button.divArrow.style.transform  = 'translateY(0)';
            this.button.div     .style.background = 'transparent';
        }


        removeFrom(currentMenus, this);
    }
}



function hideAllMenus()
{
    for (let i = currentMenus.length-1; i >= 0; i--)
        currentMenus[i].hide();
}



function hideAllMenusAfter(menu)
{
    const index = currentMenus.indexOf(menu);

    for (let i = currentMenus.length-1; i > index; i--)
        currentMenus[i].hide();
}



function disableCurrentMenuButton()
{
    if (currentMenuButton)
    {
        const curMenuButton = currentMenuButton;
        currentMenuButton = null;
        curMenuButton.update();
    }
}


class MenuButton
{
    name;
    menu;

    icon          = NULL;

    callback;
    highlight;
    useMenuName   = true;
    afterLabel;
    noHighlight   = false;

    selectLast;

    
    div;

    divIcon;
    divArrow;
    
    over          = false;
    overArrow     = false;
    

    tooltip       = null;
    customTooltip = false;



    constructor(name, menu, options = {})
    {
        this.name = name;
        this.menu = menu;

        if (this.menu)
            this.menu.button = this;


        this.initOptions(options);
        
        this.createControls();
        this.createTooltip();

        this.update();
    }



    initOptions(options)
    {
        this.callback    ??= options.callback;
        this.highlight   ??= options.highlight;
        this.useMenuName = options.useMenuName != undefined ? options.useMenuName : true;

        this.selectLast  ??= options.selectLast;
        this.afterLabel  ??= options.afterLabel;
        this.noHighlight = options.noHighlight != undefined ? options.noHighlight : false;


        if (!!options.tooltip)
        {
            this.tooltip = options.tooltip;
            this.customTooltip = true;
        }
    }



    createControls()
    {
        this.div      = createDiv('menuButton');

        this.divIcon  = createDiv('menuButtonIcon');
        this.divArrow = createDiv('menuButtonArrow');


        this.div.addEventListener('pointerenter', () => 
        {
            this.over = true;
            this.update();
        });
   

        this.div.addEventListener('pointerleave', () => 
        {
            this.over = false;
            this.update();
        });


        if (this.menu) 
        {
            this.div.addEventListener('pointerdown', e => 
            {
                if (e.button == 0)
                {
                    disableCurrentMenuButton();

                    e.stopPropagation();
                    this.showMenu();
                    
                    this.update();
                }
            });


            if (this.useMenuName) this.createArrowEvents(this.div);
            else                  this.createArrowEvents(this.divArrow);
            

            this.divArrow.addEventListener('pointerdown', e => 
            {
                if (e.button == 0)
                {
                    e.stopPropagation();
                    this.showMenu();
                    this.update();
                }
            });
        }
        
        
        if (this.callback) 
        {
            this.div.addEventListener('click', () =>
            {
                disableCurrentMenuButton();
                this.callback();
            });
        }


        this.div.appendChild(this.divIcon);

        if (this.menu)
            this.div.appendChild(this.divArrow);


        if (this.afterLabel)
            menuBar.appendChild(this.div);
        else
            menuBar.insertBefore(this.div, pageName);
    }



    createTooltip()
    {
        if (!this.tooltip)
        {
            const ttName = 
                this.menu 
                ? this.menu.name 
                : this.name;

            this.tooltip = createDiv('tooltip', 'ttMenuButtonIcon' + ttName);
        }

        
        document.body.appendChild(this.tooltip);
        

        createTooltip(this.tooltip);

        if (this.name != '-')
            createTooltipSrc(this.div, this.div, () => this.tooltip);
    }



    createArrowEvents(div)
    {
        div.addEventListener('pointerenter', e =>
        {
            this.overArrow = true;
            this.moveArrowDown();
        });


        div.addEventListener('pointerleave', e =>
        {
            if (!currentMenus.includes(this.menu))
                this.moveArrowUp();

            this.overArrow = false;
        });
    }



    moveArrowDown()
    {
        this.divArrow.style.transform = 'translateY(3px)';
    }



    moveArrowUp()
    {
        this.divArrow.style.transform = 'translateY(0)';
    }



    setIcon(icon)
    {
        this.icon = icon;
        this.update();
    }



    showMenu()
    {
        const curMenus = [...currentMenus];

        hideAllMenus();
        
        if (!curMenus.includes(this.menu))
            this.menu.show(this.div, false);
    }



    update()
    {
        this.div.style.background =
               currentMenuButton == this
            ||    this.highlight 
               && this.highlight()
            ? 'var(--figma-color-bg-brand)'
            : (this.over && !this.noHighlight)
              ? '#111'
              : 'transparent';


        const icon = 
            this.icon != NULL
            ? this.icon
            : this.menu
                ? this.menu.lastItem.icon
                : NULL;

        this.divIcon.style.background         = 'url(\'data:image/svg+xml;utf8,' + icon + '\')';
        this.divIcon.style.backgroundPosition = '100% 50%';
        this.divIcon.style.backgroundRepeat   = 'no-repeat';

        this.div.style.width = 
            this.name != '-'
            ? (this.menu ? 50 : 40)
            : 24;


        if (!this.customTooltip)
        {
            if (this.useMenuName)
                this.tooltip.innerHTML = 
                    this.menu 
                    ? this.menu.name 
                    : this.name;
            else
                this.tooltip.innerHTML = 
                    this.menu
                    && this.menu.lastItem
                    ? this.menu.lastItem.name
                    : this.name;        
        }
    }
}


class MenuItem
{
    parentMenu    = null;
    index         = -1;

    enabled       = true;

    checked       = false;
    icon          = ''; // svg
    name          = '';
    shortcut      = '';

    callback      = null;
    checkCallback = null;

    childMenu     = null;

    separator     = false;

    selectOnDrag  = false;

    isSetting     = false;
    disambiguate  = false;

    enteredDiv    = false;
    enteredExpand = false;

    arrowWidth    = 48;


    div;
    divHighlight;

    divCheck;
    divIcon;
    divName;
    divExpand;
    divShortcut;

    divSeparator;


    //button0   = false;
    //dragStart = null;



    constructor(name, options = {})
    {
        this.name = name;

        this.initOptions(options);
        this.createControls();

        this.update();
    }



    initOptions(options)
    {
        if (options.icon          != undefined) this.icon          = options.icon;
        if (options.checkCallback != undefined) this.checkCallback = options.checkCallback;
        if (options.callback      != undefined) this.callback      = options.callback;
        if (options.childMenu     != undefined) 
        { 
            this.childMenu = options.childMenu;  

            if (this.childMenu)
                this.childMenu.parentMenu = this.parentMenu; 
        }
        if (options.separator     != undefined) this.separator     = options.separator;
        if (options.selectOnDrag  != undefined) this.selectOnDrag  = options.selectOnDrag;
        if (options.shortcut      != undefined) this.shortcut      = options.shortcut;
        if (options.enabled       != undefined) this.enabled       = options.enabled;
        if (options.setting       != undefined) this.isSetting     = options.setting;
        if (options.disambiguate  != undefined) this.disambiguate  = options.disambiguate;
    }



    createControls()
    {
        this.div          = createDiv('menuItem' + (this.disambiguate ? ' disambiguate' : ''));
        this.divHighlight = createDiv('menuItemHighlight');

        this.divCheck     = createDiv('menuItemCheck'    );
        this.divIcon      = createDiv('menuItemIcon'     );
        this.divName      = createDiv('menuItemName'     );
        this.divExpand    = createDiv('menuItemExpand'   );
        this.divShortcut  = createDiv('menuItemShortcut' );

        this.divSeparator = createDiv('menuSeparator'    );


        this.div.style.pointerEvents = this.separator ? 'none' : 'all';


        this.setName(this.name);

        
        if (this.childMenu)
            this.divExpand.style.visibility = 'visible';


        this.setIcon(this.icon);

    
        this.divShortcut.innerHTML = this.shortcut;

    
        this.divHighlight.style.zIndex = -2;

        
        if (!this.separator)
        {
            this.div.appendChild(this.divHighlight);

            this.div.appendChild(this.divCheck);
            this.div.appendChild(this.divIcon );

            this.div.appendChild(this.divName    );
            this.div.appendChild(this.divExpand  );
            this.div.appendChild(this.divShortcut);
        }
        else
            this.div.appendChild(this.divSeparator);



        this.div.addEventListener('pointerdown', e => 
        {
            e.stopPropagation();
            e.preventDefault();


            if (e.button == 0)
            {
                this.button0   = true;
                this.dragStart = point(e.clientX, e.clientY);
            }
        });



        this.div.addEventListener('pointerup', e => 
        {
            e.stopPropagation();
            e.preventDefault();


            if (e.button == 0)
            {
                const rect = boundingRect(this.div);

                if (   this.callback
                    && this.childMenu)
                {
                    if (e.clientX - rect.x < rect.width - this.arrowWidth)
                        this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);
                }
                else if (this.callback)
                    this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);

                    
                this.button0 = false;
            }
        });



        this.div.addEventListener('pointermove', e =>
        {
            if (this.enabled)
            {
                this.divHighlight.style.background = 'var(--figma-color-bg-brand)';


                if (   this.button0
                    && distance(this.dragStart, clientPos(e)) > 5)
                {
                    const rect = boundingRect(this.div);

                    if (   this.callback
                        && this.childMenu)
                    {
                        if (e.clientX - rect.x < rect.width - this.arrowWidth)
                            this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);
                    }
                    else if (this.callback)
                        this.select(e.shiftKey, getCtrlKey(e), e.altKey, rect.x, rect.y);

                    
                    this.button0 = false;

                    hideAllMenus();


                    const node = graph.pageNodes.at(-1);

                    node.div.shiftOnPointerDown = false;

                    node.sx  = node.div.offsetLeft;
                    node.sy  = node.div.offsetTop ;

                    node.slx = node.div.offsetLeft - (defNodeWidth    / 2) - (               + graph.currentPage.pan.x) / graph.currentPage.zoom;
                    node.sly = node.div.offsetTop  - (defHeaderHeight / 2) - (getTopHeight() + graph.currentPage.pan.y) / graph.currentPage.zoom;

                    node.div.dragging = true;
                    node.header.setPointerCapture(e.pointerId);
                }
                else
                {
                    if (   this.callback
                        && this.childMenu)
                    {
                        const rect = boundingRect(this.div);

                        if (    e.clientX - rect.x < rect.width - this.arrowWidth
                            && !this.enteredDiv)
                        {
                            this.divHighlight.style.left  = 0;
                            this.divHighlight.style.width = 'calc(100% - ' + (this.childMenu && this.callback ? this.arrowWidth : 0) + 'px)';

                            hideAllMenusAfter(this.parentMenu);

                            this.enteredDiv    = true;
                            this.enteredExpand = false;
                        }
                        else if ( e.clientX - rect.x >= rect.width - this.arrowWidth
                            && !this.enteredExpand)
                        {
                            this.divHighlight.style.left  = 'calc(100% - ' + (this.childMenu && this.callback ? this.arrowWidth : 0) + 'px)';
                            this.divHighlight.style.width = this.arrowWidth + 'px';

                            this.showChildMenu();

                            this.enteredDiv    = false;
                            this.enteredExpand = true;
                        }
                    }
                    else if (!this.enteredDiv)
                    {
                        this.divHighlight.style.left  = 0;
                        this.divHighlight.style.width = '100%';

                        this.showChildMenu();

                        this.enteredDiv    = true;
                        this.enteredExpand = false;
                    }
                }
            }
        });
    

    
        this.div.addEventListener('pointerleave', () =>
        {
            this.divHighlight.style.background = 'transparent';

            this.enteredDiv    = false;
            this.enteredExpand = false;
        });
    }



    setName(name)
    {
        this.name              = name;
        this.divName.innerHTML = name;
    }



    setIcon(icon)
    {
        if (icon != '')
        {
            this.divIcon.style.background         = 'url(\'data:image/svg+xml;utf8,' + icon + '\')';
            this.divIcon.style.backgroundPosition = '50% 50%';
            this.divIcon.style.backgroundRepeat   = 'no-repeat';
        }
        else
            this.divIcon.style.background = 'transparent';
    }



    showChildMenu()
    {
        if (this.childMenu)
        {
            if (!currentMenus.includes(this.childMenu))
            {
                hideAllMenusAfter(this.parentMenu);
                this.childMenu.show(this.div, true, true);
            }
        }
        else
            hideAllMenusAfter(this.parentMenu);
    }



    select(shift = false, ctrl = false, alt = false, x = Number.NaN, y = Number.NaN)
    {
        if (!this.enabled)
            return;


        if (!isEmpty(currentMenus)) // this lets the item be selected without its parent menu being involved
        {
            if (this.parentMenu.button)
                this.parentMenu.button.update();
        }

        if (!shift) 
            hideAllMenus();


        const e = 
        {
            shiftKey: shift,
            ctrlKey:  ctrl,
            altKey:   alt
        };


        if (!isNaN(x)) e.clientX = x;
        if (!isNaN(y)) e.clientY = y;

        if (this.callback)
            this.callback(e);
    }



    setChecked(checked)
    {
        this.checked = checked;
        this.update();
    }



    setEnabled(enabled)
    {
        this.enabled = enabled;
        this.update();
    }



    setVisible(visible)
    {
        menuItemDebug.div.style.display = visible ? 'inline-block' : 'none';
    }



    update()
    {
        this.divCheck.style.visibility = this.checked ? 'visible' : 'hidden';
        this.div     .style.opacity    = this.enabled ? '100%'    : '40%';
    }
}


var btnMain;
var btnFlow;
var btnNumber;
var btnText;
var btnColor;
var btnStyle;
var btnShape;
var btnGroup;
var btnHand;
var btnComment;
var btnPage;
var btnZoom;


var menuMain;
var menuMainPreferences;
var menuMainDebug;
var menuMainHelp;

var menuShowTooltips;

var menuDebugStorage;
var menuDebugGenerator;
var menuDebugDelete;

var menuFlow;
var menuNumber;
var menuString;
var menuColor;
var menuColorStyle;
var menuStyle;
var menuShape;
var menuGroup;

var menuMath;
var menuBoolean;
var menuCondition;

var menuPage;

var menuZoom;
var menuWindow;


var menuGraph;
var menuNode;
var menuNodeCopyAs;
var menuNodeSelect;


var menuLocalStyles;
var menuSelectParam;

var menuRemoveLicense;

var menuText;
var menuTextbox;

var menuCopy;

var menuPageData;
var menuPageDataPages;
var menuNodeData;
var menuNodeDataNodes;
var menuConnData;
var menuConnDataConns;


var menuItemShowTooltipLongText;
var menuItemShowTooltipColorInterpolation;
var menuItemShowTooltipColorContrast;
var menuItemShowTooltipColorBlindness;


var menuItemEnableZoomedOutParams;
var menuItemMinZoomForParams;
var menuItemShowPages;
var menuPrefSep1;
var menuItemShowAllColorSpaces;
var menuItemShowBoolValues;
var menuItemShowOperationResults;
var menuItemShowClearUndoWarning;
var menuItemShowTooltips;
var menuItemShowDebugMenu;
var menuPrefSep2;

var menuItemShowNodeId;

var menuItemDebug;
var menuItemDebugLog;

var menuItemHelp;


var menuItemEnableBetaFeatures;


var menuItemList;  
var menuFlowSep1;
var menuItemExpandList;
var menuItemItems;
var menuItemSelect;
var menuItemCount;
var menuItemIfElse;
var menuFlowSep2;
var menuItemStart;
var menuItemRepeat;
var menuFlowSep3;
var menuItemCache;
var menuItemCopy;

var menuItemSeries;
var menuItemSolve;  
var menuItemAnimate;  
var menuItemNumberSep1;
var menuItemNumberSep2;
var menuItemNumberConvertToText;

var menuItemColor;
var menuItemCorrectColor;
var menuItemColorSep1;
var menuItemColorblind;
var menuItemColorBlend;


var menuItemStyleFill;
var menuItemStyleStroke;
var menuItemStyleSep1;


var menuItemShapeSep1;
var menuItemShapeSelected;


var menuItemDataMode;

var menuItemLogMessages;
var menuItemLogActions;
var menuItemLogLoading;
var menuItemLogRequests;
var menuItemLogValueUpdates;
var menuItemLogObjectUpdates;
var menuItemLogStyleUpdates;
var menuItemLogRawLoadPages;
var menuItemLogRawLoadNodes;
var menuItemLogRawLoadConnections;
var menuItemLogRawSavePages;
var menuItemLogRawSaveNodes;
var menuItemLogRawSaveConnections;
var menuItemLogRawRequests;
var menuItemLogRawValues;

var menuItemZoomTo100;

var menuItemWindowNormal;
var menuItemWindowMaximize;
var menuItemWindowTop;
var menuItemWindowLeft;
var menuItemWindowRight;
var menuItemWindowBottom;

var menuItemGraphPaste;
var menuItemGraphPasteConnected;

var menuItemNodeCopy;
var menuItemNodeCopyAsJsCode;
var menuItemNodeCopyAsJsFunction;
var menuItemNodePaste;
var menuItemNodePasteConnected;
var menuItemNodeRemove;
var menuItemNodeLayout;
var menuItemNodeSep1;
var menuItemNodeRename;
var menuItemNodeEdit;
var menuItemNodeSep2;
var menuItemNodeSelect;
// var menuItemNodeBringToFront;
// var menuItemNodeSendToBack;
//var menuItemNodeActivate;
var menuItemNodeSep3;
var menuItemNodeEnableDisable;


var menuItemLicenseSep1;
var menuItemLicenseRemove;



function initGeneratorMenus()
{
    menuShowTooltips = new Menu('Show tooltips', false);
    menuShowTooltips.addItems([
        menuItemShowTooltipLongText           = new MenuItem('Long text',           {checkCallback: () => settings.showTooltipLongText,           callback: () => { updateSettingAndMenu('showTooltipLongText',           true, !settings.showTooltipLongText          ); }}),
        menuItemShowTooltipColorContrast      = new MenuItem('Color contrast',      {checkCallback: () => settings.showTooltipColorContrast,      callback: () => { updateSettingAndMenu('showTooltipColorContrast',      true, !settings.showTooltipColorContrast     ); }}),
        menuItemShowTooltipColorInterpolation = new MenuItem('Color interpolation', {checkCallback: () => settings.showTooltipColorInterpolation, callback: () => { updateSettingAndMenu('showTooltipColorInterpolation', true, !settings.showTooltipColorInterpolation); }}),
        menuItemShowTooltipColorBlindness     = new MenuItem('Color blindness',     {checkCallback: () => settings.showTooltipColorBlindness,     callback: () => { updateSettingAndMenu('showTooltipColorBlindness',     true, !settings.showTooltipColorBlindness    ); }})]);


    menuMainPreferences = new Menu('Preferences', false);
    menuMainPreferences.addItems([
        menuItemShowPages             = new MenuItem('Show pages',                    {checkCallback: () => settings.showAllColorSpaces,      callback: () => { updateSettingAndMenu('showPages',            true, !settings.showPages);             updateMenuItemShowPages();            }}),
        menuPrefSep1                  = new MenuItem('',                              {separator: true}),    
        menuItemShowAllColorSpaces    = new MenuItem('Show all color spaces',         {checkCallback: () => settings.showAllColorSpaces,     callback: () => { updateSettingAndMenu('showAllColorSpaces',   true, !settings.showAllColorSpaces);    updateMenuItemShowAllColorSpaces();   }}),
        menuItemShowOperationResults  = new MenuItem('Show operation results',        {checkCallback: () => settings.showOperationResults,   callback: () => { updateSettingAndMenu('showOperationResults', true, !settings.showOperationResults);  updateMenuItemShowOperationResults(); }}),
        menuItemShowBoolValues        = new MenuItem('Show boolean values as ', {checkCallback: () => settings.showBoolValues,        callback: () => { updateSettingAndMenu('showBoolValues',       true, !settings.showBoolValues);        updateMenuItemShowBoolValues();       }}),
                                        new MenuItem('',                              {separator: true}),    
        menuItemShowTooltips          = new MenuItem('Show tooltips',                 {childMenu: menuShowTooltips}),
        menuItemShowClearUndoWarning  = new MenuItem('Show clear undo warning',       {checkCallback: () => settings.showClearUndoWarning,  callback: () => { updateSettingAndMenu('showClearUndoWarning',  true, !settings.showClearUndoWarning);                                        }}),
        menuItemShowDebugMenu         = new MenuItem('Show debug menu',               {checkCallback: () => settings.showDebugMenu,         callback: () => { updateSettingAndMenu('showDebugMenu',         true, !settings.showDebugMenu);         updateMenuItemShowDebugMenu();        }}),
        menuPrefSep2                  = new MenuItem('',                              {separator: true}),    
        menuItemEnableBetaFeatures    = new MenuItem('Enable beta features',          {checkCallback: () => settings.enableBetaFeatures,    callback: () => { updateSettingAndMenu('enableBetaFeatures',    true, !settings.enableBetaFeatures);    enableFeatures(true, settings.enableBetaFeatures); }}),
                                        new MenuItem('',                              {separator: true}),    
                                        new MenuItem('Keyboard layout...',            {callback: () => showKeyboardPanel()}),
        menuItemMinZoomForParams      = new MenuItem('Zoom level for values...',      {callback: () => showMinZoomDialog()})]);
        

    menuItemShowBoolValues.divName.innerHTML = 'Show boolean values as<span style="position: relative; top: 1px;">' + TRUE_DISPLAY_MENU + '</span><span>' + FALSE_DISPLAY_MENU + '</span>'


    menuDebugStorage = new Menu('Debug storage', false);
    menuDebugStorage.addItems([
        menuItemLogLoading            = new MenuItem('Load\u2008at start',  {checkCallback: () => settings.logLoading      ,      callback: () => updateSettingAndMenu('logLoading',            true, !settings.logLoading           ), setting: true}),
                                        new MenuItem('',                    {separator: true}),                   
        menuItemLogRawLoadPages       = new MenuItem('Load pages',          {checkCallback: () => settings.logRawLoadPages ,      callback: () => updateSettingAndMenu('logRawLoadPages',       true, !settings.logRawLoadPages      ), setting: true}),
        menuItemLogRawSavePages       = new MenuItem('Save pages',          {checkCallback: () => settings.logRawSavePages ,      callback: () => updateSettingAndMenu('logRawSavePages',       true, !settings.logRawSavePages      ), setting: true}),
                                        new MenuItem('',                    {separator: true}),                   
        menuItemLogRawLoadNodes       = new MenuItem('Load nodes',          {checkCallback: () => settings.logRawLoadNodes ,      callback: () => updateSettingAndMenu('logRawLoadNodes',       true, !settings.logRawLoadNodes      ), setting: true}),
        menuItemLogRawSaveNodes       = new MenuItem('Save nodes',          {checkCallback: () => settings.logRawSaveNodes ,      callback: () => updateSettingAndMenu('logRawSaveNodes',       true, !settings.logRawSaveNodes      ), setting: true}),
                                        new MenuItem('',                    {separator: true}),                   
        menuItemLogRawLoadConnections = new MenuItem('Load connections',    {checkCallback: () => settings.logRawLoadConnections, callback: () => updateSettingAndMenu('logRawLoadConnections', true, !settings.logRawLoadConnections), setting: true}),
        menuItemLogRawSaveConnections = new MenuItem('Save connections',    {checkCallback: () => settings.logRawSaveConnections, callback: () => updateSettingAndMenu('logRawSaveConnections', true, !settings.logRawSaveConnections), setting: true}),
                                        new MenuItem('',                    {separator: true}),
                                        new MenuItem('All page keys',       {callback:      () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllSavedPageKeys', darkMode: darkMode}); }}),
                                        new MenuItem('All connection keys', {callback:      () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllSavedConnKeys', darkMode: darkMode}); }}),
                                        new MenuItem('All local data',      {callback:      () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllLocalData', darkMode: darkMode}); }}),
                                        new MenuItem('',                    {separator: true}),   
                                        new MenuItem('Undo stack',          {callback:      () => { hideAllMenus(); logUndoStack(); }}),
                                        new MenuItem('Redo stack',          {callback:      () => { hideAllMenus(); logRedoStack(); }})]);
                     

    menuDebugGenerator = new Menu('Debug generator', false);
    menuDebugGenerator.addItems([
        menuItemLogRequests           = new MenuItem('Requests',           {checkCallback: () => settings.logRequests     ,      callback: () => updateSettingAndMenu('logRequests',           true, !settings.logRequests          ), setting: true}),
        menuItemLogValueUpdates       = new MenuItem('Values',             {checkCallback: () => settings.logValueUpdates ,      callback: () => updateSettingAndMenu('logValueUpdates',       true, !settings.logValueUpdates      ), setting: true}),
        menuItemLogObjectUpdates      = new MenuItem('Objects',            {checkCallback: () => settings.logObjectUpdates,      callback: () => updateSettingAndMenu('logObjectUpdates',      true, !settings.logObjectUpdates     ), setting: true}),
        menuItemLogStyleUpdates       = new MenuItem('Styles',             {checkCallback: () => settings.logStyleUpdates ,      callback: () => updateSettingAndMenu('logStyleUpdates',       true, !settings.logStyleUpdates      ), setting: true}),
                                        new MenuItem('',                   {separator: true}),                   
        menuItemLogRawRequests        = new MenuItem('Raw\u2008requests',  {checkCallback: () => settings.logRawRequests  ,      callback: () => updateSettingAndMenu('logRawRequests',        true, !settings.logRawRequests       ), setting: true}),
        menuItemLogRawValues          = new MenuItem('Raw\u2008values',    {checkCallback: () => settings.logRawValues    ,      callback: () => updateSettingAndMenu('logRawValues',          true, !settings.logRawValues         ), setting: true}),
                                        new MenuItem('',                   {separator: true}),                   
        menuItemLogMessages           = new MenuItem('Messages',           {checkCallback: () => settings.logMessages     ,      callback: () => updateSettingAndMenu('logMessages',           true, !settings.logMessages          ), setting: true}),
        menuItemLogActions            = new MenuItem('Actions',            {checkCallback: () => settings.logActions      ,      callback: () => updateSettingAndMenu('logActions',            true, !settings.logActions           ), setting: true})]);
                     

    menuDebugDelete = new Menu('Debug generator', false);
    menuDebugDelete.addItems([
        new MenuItem('All saved pages',       {callback: () => { hideAllMenus(); uiRemoveAllSavedPages(); }}),
        new MenuItem('',                      {separator: true}),                   
        new MenuItem('Connections to...',     {callback: () => showDeleteConnectionsDialog()}),                        
        new MenuItem('All saved connections', {callback: () => { hideAllMenus(); uiRemoveAllSavedConnections(); }}),
        new MenuItem('',                      {separator: true}),                   
        new MenuItem('All style links',       {callback: () => { hideAllMenus(); uiRemovePluginDataFromAllLocalStyles(); }}),
        new MenuItem('',                      {separator: true}),                   
        new MenuItem('All local data',        {callback: () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figClearAllLocalData'}); }})]);
                     

    menuMainDebug = new Menu('Debug', false);
    menuMainDebug.addItems([
        menuItemShowNodeId = new MenuItem('Show IDs',
                             {
                                 checkCallback: () => settings.showNodeId, 
                                 callback:      () => 
                                 {
                                     updateSettingAndMenu('showNodeId', true, !settings.showNodeId);
                                     
                                     graph.nodes.forEach(n => n.updateNode());
                                     graph.nodes.forEach(n => n.updateMeasureData());
                                     graph.nodes.forEach(n => n.updateHeaderLabelOffsetX());

                                     graph.updatePages();
                                 }
                             }),
                             new MenuItem('',                             {separator: true}),
                             new MenuItem('Log generator',                {childMenu: menuDebugGenerator}),
                             new MenuItem('Log storage',                  {childMenu: menuDebugStorage}),
                             new MenuItem('',                             {separator: true}),   
                             new MenuItem('Delete',                       {childMenu: menuDebugDelete}),
                             new MenuItem('',                             {separator: true}),   
        menuItemDataMode   = new MenuItem('Restart in debug mode',        {checkCallback: () => settings.dataMode, callback: () => uiRestartGenerator(true)})]);
                     

    menuMainHelp = new Menu('Help and subscription', false);
    menuMainHelp.addItems([
        // new MenuItem('Help page',    {callback:  () => window.open('http://www.bourt.com/generator/help', '_blank')}),
      //new MenuItem('',             {separator: true}),
        new MenuItem('Subscription', {callback:  () => showProductKeyDialog()}),
      //new MenuItem('',             {separator: true}),
        new MenuItem('About',        {callback:  () => showAboutDialog()})]);


    menuMain = new Menu('Main menu', false);
    menuMain.addItems([
                        new MenuItem('Preferences',           {childMenu: menuMainPreferences}),
        menuItemDebug = new MenuItem('Debug',                 {childMenu: menuMainDebug}),
                        new MenuItem('',                      {separator: true}),
        menuItemHelp  = new MenuItem('Help and subscription', {childMenu: menuMainHelp })]);


    menuFlow = new Menu('Data flow', true, false);
    menuFlow.addItems([
        menuItemList          = new MenuItem('List',              {icon: iconList,       callback: e => actionManager.do(getCreateNodeAction(LIST,         btnNumber.div, getCreateOptions(e)))}),
        menuFlowSep1          = new MenuItem('',                  {separator: true}),     
        menuItemItems         = new MenuItem('Items',             {icon: iconItems,      callback: e => actionManager.do(getCreateNodeAction(ITEMS,        btnNumber.div, getCreateOptions(e)))}),
        menuItemSelect        = new MenuItem('Select',            {icon: iconSelect,     callback: e => actionManager.do(getCreateNodeAction(SELECT,       btnNumber.div, getCreateOptions(e)))}),
        menuItemCount         = new MenuItem('Count',             {icon: iconCount,      callback: e => actionManager.do(getCreateNodeAction(LIST_COUNT,   btnNumber.div, getCreateOptions(e)))}),
        //menuItemExpandList    = new MenuItem('Expand',            {icon: iconExpandList, callback: e => actionManager.do(getCreateNodeAction(LIST_EXPAND,  btnNumber.div, getCreateOptions(e)))}),
        menuFlowSep2          = new MenuItem('',                  {separator: true}),
        menuItemIfElse        = new MenuItem('I&hairsp;f / else', {icon: iconIfElse,     callback: e => actionManager.do(getCreateNodeAction(IF_ELSE,      btnNumber.div, getCreateOptions(e))), disambiguate: true}),
        menuFlowSep3          = new MenuItem('',                  {separator: true}),
      //menuItemStart         = new MenuItem('Start',             {icon: iconStart,      callback: e => actionManager.do(getCreateNodeAction(START,        btnNumber.div, getCreateOptions(e)))}),
        menuItemRepeat        = new MenuItem('Repeat',            {icon: iconRepeat,     callback: e => actionManager.do(getCreateNodeAction(REPEAT,       btnNumber.div, getCreateOptions(e)))})]);//,
        // menuFlowSep3          = new MenuItem('',                  {separator: true}),
        // menuItemCache         = new MenuItem('Cache',             {icon: iconCache,  callback: e => actionManager.do(getCreateNodeAction(CACHE,        btnNumber.div, getCreateOptions(e)))}),
        // menuItemCopy          = new MenuItem('Copy',              {icon: iconCopy,   callback: e => actionManager.do(getCreateNodeAction(COPY,         btnNumber.div, getCreateOptions(e)))})]);
    
    
    menuMath = new Menu('Math', true, false);
    menuMath.addItems([
        new MenuItem('Power',       {icon: iconExponent, callback: e => actionManager.do(getCreateNodeAction(NUMBER_EXPONENT, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Multiply',    {icon: iconMultiply, callback: e => actionManager.do(getCreateNodeAction(NUMBER_MULTIPLY, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Divide',      {icon: iconDivide,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_DIVIDE,   btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Remainder',   {icon: iconModulo,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_MODULO,   btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Add',         {icon: iconAdd,      callback: e => actionManager.do(getCreateNodeAction(NUMBER_ADD,      btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Subtract',    {icon: iconSubtract, callback: e => actionManager.do(getCreateNodeAction(NUMBER_SUBTRACT, btnNumber.div, getCreateOptions(e)))})]);
        

    menuBoolean = new Menu('Boolean', true, false);
    menuBoolean.addItems([
        new MenuItem('And', {icon: iconAnd, callback: e => actionManager.do(getCreateNodeAction(NUMBER_AND, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Or',  {icon: iconOr , callback: e => actionManager.do(getCreateNodeAction(NUMBER_OR,  btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Xor', {icon: iconXor, callback: e => actionManager.do(getCreateNodeAction(NUMBER_XOR, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Not', {icon: iconNot, callback: e => actionManager.do(getCreateNodeAction(NUMBER_NOT, btnNumber.div, getCreateOptions(e)))})]);
        
    
    menuCondition = new Menu('Conditional', true, false);
    menuCondition.addItems([
        new MenuItem('Greater',          {icon: iconGreater,        callback: e => actionManager.do(getCreateNodeAction(NUMBER_GREATER,          btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Greater or equal', {icon: iconGreaterOrEqual, callback: e => actionManager.do(getCreateNodeAction(NUMBER_GREATER_OR_EQUAL, btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Equal',            {icon: iconEqual,          callback: e => actionManager.do(getCreateNodeAction(NUMBER_EQUAL,            btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Not equal',        {icon: iconNotEqual,       callback: e => actionManager.do(getCreateNodeAction(NUMBER_NOT_EQUAL,        btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Less or equal',    {icon: iconLessOrEqual,    callback: e => actionManager.do(getCreateNodeAction(NUMBER_LESS_OR_EQUAL,    btnNumber.div, getCreateOptions(e)))}),
        new MenuItem('Less',             {icon: iconLess,           callback: e => actionManager.do(getCreateNodeAction(NUMBER_LESS,             btnNumber.div, getCreateOptions(e)))})]);
        
    
    menuNumber = new Menu('Numbers', true, false);
    menuNumber.addItems([
                                      new MenuItem('Number',          {icon: iconNumber,       shortcut: 'N', callback: e => actionManager.do(getCreateNodeAction(NUMBER,             btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('',                {separator: true}),
                                      new MenuItem('Sign',            {icon: iconSign,         callback: e => actionManager.do(getCreateNodeAction(NUMBER_SIGN,        btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('Absolute',        {icon: iconAbsolute,     callback: e => actionManager.do(getCreateNodeAction(NUMBER_ABSOLUTE,    btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('Round',           {icon: iconRound,        callback: e => actionManager.do(getCreateNodeAction(NUMBER_ROUND,       btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('Limits',          {icon: iconLimits,       callback: e => actionManager.do(getCreateNodeAction(NUMBER_LIMITS,      btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('',                {separator: true}),
                                      new MenuItem('Math',            {icon: iconMath,         childMenu: menuMath,      callback: e => actionManager.do(getCreateNodeAction(NUMBER_MATH,        btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('Boolean',         {icon: iconBoolean,      childMenu: menuBoolean,   callback: e => actionManager.do(getCreateNodeAction(NUMBER_BOOLEAN,     btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('Condition',       {icon: iconCondition,    childMenu: menuCondition, callback: e => actionManager.do(getCreateNodeAction(NUMBER_CONDITION,   btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('',                {separator: true}),
        menuItemSeries              = new MenuItem('Sequence...',     {icon: iconSeries,       callback: e => actionManager.do(getCreateNodeAction(NUMBER_SERIES,      btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('Random...',       {icon: iconRandom,       callback: e => actionManager.do(getCreateNodeAction(NUMBER_RANDOM,      btnNumber.div, getCreateOptions(e)))}),
                                      new MenuItem('',                {separator: true}),
                                      new MenuItem('Interpolate',     {icon: iconInterpolate,  callback: e => actionManager.do(getCreateNodeAction(NUMBER_INTERPOLATE, btnNumber.div, getCreateOptions(e)))}),
        menuItemSolve               = new MenuItem('Solve',           {icon: iconSolve,        callback: e => actionManager.do(getCreateNodeAction(NUMBER_SOLVE,       btnNumber.div, getCreateOptions(e)))}),
        menuItemNumberSep1          = new MenuItem('',                {separator: true}),
        menuItemAnimate             = new MenuItem('Animate',         {icon: iconAnimate,      callback: e => actionManager.do(getCreateNodeAction(NUMBER_ANIMATE,     btnNumber.div, getCreateOptions(e)))}),
        menuItemNumberSep2          = new MenuItem('',                {separator: true}),
        menuItemNumberConvertToText = new MenuItem('Convert to text', {icon: iconNumberToText, callback: e => actionManager.do(getCreateNodeAction(NUMBER_TO_TEXT,     btnNumber.div, getCreateOptions(e)))})]);
        
    
    menuString = new Menu('Text', true, false);
    menuString.addItems([
        new MenuItem('Text',      {icon: iconText,          shortcut: 'T', callback: e => actionManager.do(getCreateNodeAction(TEXT,           btnText.div, getCreateOptions(e)))}),
        new MenuItem('',          {separator: true}),
        new MenuItem('Character', {icon: iconTextCharacter, callback: e => actionManager.do(getCreateNodeAction(TEXT_CHAR,      btnText.div, getCreateOptions(e)))}),
        new MenuItem('',          {separator: true}),
        new MenuItem('Substring', {icon: iconTextSubstring, callback: e => actionManager.do(getCreateNodeAction(TEXT_SUBSTRING, btnText.div, getCreateOptions(e)))}),
        new MenuItem('Join',      {icon: iconTextJoin,      callback: e => actionManager.do(getCreateNodeAction(TEXT_JOIN,      btnText.div, getCreateOptions(e)))}),
        new MenuItem('Replace',   {icon: iconTextReplace,   callback: e => actionManager.do(getCreateNodeAction(TEXT_REPLACE,   btnText.div, getCreateOptions(e)))}),
        new MenuItem('',          {separator: true}),
        new MenuItem('CSV',       {icon: iconTextCSV,       callback: e => actionManager.do(getCreateNodeAction(TEXT_CSV,       btnText.div, getCreateOptions(e)))}),
        new MenuItem('',          {separator: true}),
        new MenuItem('Fetch',     {icon: iconTextFetch,     callback: e => actionManager.do(getCreateNodeAction(TEXT_FETCH,     btnText.div, getCreateOptions(e)))})]);
    

    menuColorStyle = new Menu('Color style', true, false);
    menuColorStyle.addItems([
        new MenuItem('Link existing...', {icon: iconColorStyleReplace, callback: e => actionManager.do(getCreateNodeAction(COLOR_STYLE,  btnColor.div, getCreateOptions(e, {existing: true})))})]);

        
    menuColor = new Menu('Colors', true, true);
    menuColor.addItems([
        menuItemColor        = new MenuItem('Color',         {icon: iconColor,            shortcut: 'C', callback: e => actionManager.do(getCreateNodeAction(COLOR,             btnColor.div, getCreateOptions(e,  {random: e.altKey && !getCtrlKey(e)})))}),
                               new MenuItem('',              {separator: true}),
                               new MenuItem('Valid sRGB',    {icon: iconValidColor,       callback: e => actionManager.do(getCreateNodeAction(VALID_COLOR,       btnColor.div, getCreateOptions(e)))}),
        menuItemCorrectColor = new MenuItem('Correct color', {icon: iconCorrectColor,     callback: e => actionManager.do(getCreateNodeAction(CORRECT_COLOR,     btnColor.div, getCreateOptions(e)))}),
        menuItemColorSep1    = new MenuItem('',              {separator: true}),
                               new MenuItem('Web contrast',  {icon: iconWebContrast,      callback: e => actionManager.do(getCreateNodeAction(COLOR_CONTRAST,    btnColor.div, getCreateOptions(e)))}),
        menuItemColorblind   = new MenuItem('Colorblind',    {icon: iconColorblind,       callback: e => actionManager.do(getCreateNodeAction(COLORBLIND,        btnColor.div, getCreateOptions(e)))}),
                               new MenuItem('',              {separator: true}),
                               new MenuItem('Interpolate',   {icon: iconColorInterpolate, callback: e => actionManager.do(getCreateNodeAction(COLOR_INTERPOLATE, btnColor.div, getCreateOptions(e)))}),
        menuItemColorBlend   = new MenuItem('Blend',         {icon: iconColorBlend,       callback: e => actionManager.do(getCreateNodeAction(COLOR_BLEND,       btnColor.div, getCreateOptions(e)))})]);

    menuColor.init = () => 
    {
        menuItemColor.setIcon(iconColor);
    };

    
    menuStyle = new Menu('Styles', true, false);
    menuStyle.addItems([
        menuItemStyleFill   = new MenuItem('Fill',          {icon: iconFill,       callback: e => actionManager.do(getCreateNodeAction(FILL,   btnColor.div, getCreateOptions(e)))}),
        menuItemStyleStroke = new MenuItem('Stroke',        {icon: iconStroke,     callback: e => actionManager.do(getCreateNodeAction(STROKE, btnColor.div, getCreateOptions(e)))}),
        menuItemStyleSep1   = new MenuItem('',              {separator: true}),
                              new MenuItem('Color style',   {icon: iconColorStyle, callback: e => actionManager.do(getCreateNodeAction(COLOR_STYLE,  btnColor.div, getCreateOptions(e, {existing: true})))})]);
                            //new MenuItem('Color style',   {icon: iconColorStyle, childMenu: menuColorStyle, callback: e => actionManager.do(getCreateNodeAction(COLOR_STYLE,  btnColor.div, getCreateOptions(e)))})]);
    
    
    menuShape = new Menu('Shapes', true, false);
    menuShape.addItems([
                                new MenuItem('Rectangle',           {icon: iconRectangle, callback: e => actionManager.do(getCreateNodeAction(RECTANGLE, btnShape.div, getCreateOptions(e)))}),
                                new MenuItem('Line',                {icon: iconLine,      callback: e => actionManager.do(getCreateNodeAction(LINE,      btnShape.div, getCreateOptions(e)))}),
                                new MenuItem('Ellipse',             {icon: iconEllipse,   callback: e => actionManager.do(getCreateNodeAction(ELLIPSE,   btnShape.div, getCreateOptions(e)))}),
                                new MenuItem('Polygon',             {icon: iconPolygon,   callback: e => actionManager.do(getCreateNodeAction(POLYGON,   btnShape.div, getCreateOptions(e)))}),
                                new MenuItem('Star',                {icon: iconStar,      callback: e => actionManager.do(getCreateNodeAction(STAR,      btnShape.div, getCreateOptions(e)))}),
                                new MenuItem('',                    {separator: true}),
                                new MenuItem('Text',                {icon: iconTextShape, callback: e => actionManager.do(getCreateNodeAction(TEXTSHAPE, btnShape.div, getCreateOptions(e)))}),
        menuItemShapeSep1     = new MenuItem('',                    {separator: true}),
        menuItemShapeSelected = new MenuItem('Selected objects...', {icon: iconSelected,  enabled: false})]);


    menuGroup = new Menu('Groups', true, false);
    menuGroup.addItems([
        new MenuItem('Group',     {icon: iconGroupNode,  callback: e => actionManager.do(getCreateNodeAction(GROUP_NODE,  btnGroup.div, getCreateOptions(e)))}),
        new MenuItem('Parameter', {icon: iconGroupParam, shortcut: 'P', callback: e => actionManager.do(getCreateNodeAction(GROUP_PARAM, btnGroup.div, getCreateOptions(e)))})]);
    

    menuWindow = new Menu('Window options', true, false);
    menuWindow.showOnLeft = true;
    menuWindow.addItems([
        menuItemWindowNormal   = new MenuItem('Normal',   {icon: iconWindowNormal,     shortcut: osAlt() + '0', callback: () => dockWindowNormal  ()}),
        menuItemWindowMaximize = new MenuItem('Maximize', {icon: iconWindowMaximize,   shortcut: osAlt() + '8', callback: () => dockWindowMaximize()}),
        menuItemWindowTop      = new MenuItem('Top',      {icon: iconWindowDockTop,    shortcut: osAlt() + '5', callback: () => dockWindowTop     ()}),
        menuItemWindowLeft     = new MenuItem('Left',     {icon: iconWindowDockLeft,   shortcut: osAlt() + '1', callback: () => dockWindowLeft    ()}),
        menuItemWindowRight    = new MenuItem('Right',    {icon: iconWindowDockRight,  shortcut: osAlt() + '3', callback: () => dockWindowRight   ()}),
        menuItemWindowBottom   = new MenuItem('Bottom',   {icon: iconWindowDockBottom, shortcut: osAlt() + '2', callback: () => dockWindowTop     ()})]);


    menuPage = new Menu('Page menu', false, false);
    menuPage.addItems([
        new MenuItem('Duplicate', {enabled: false, callback: () => {}}),
        new MenuItem('Rename',    {enabled: false, callback: () => {}})]);

        
    menuZoom = new Menu('Zoom/view options');
    menuZoom.combineChecksAndIcons = true;
    menuZoom.addItems([
                            new MenuItem('Zoom in',      {shortcut: osCtrl () + '+', callback: () => graph.currentPage.zoom *= Math.pow(2, 1/2)}),
                            new MenuItem('Zoom out',     {shortcut: osCtrl () + '-', callback: () => graph.currentPage.zoom /= Math.pow(2, 1/2)}),
                            new MenuItem('Zoom to fit',  {shortcut: osShift() + '1', callback: () => graphView.zoomToFit()}),
        menuItemZoomTo100 = new MenuItem('Zoom to 100%', {shortcut: osCtrl () + '0', callback: () => graph.currentPage.zoom = 1})]);//,
                        //  new MenuItem('',             {separator: true}),
                        //  new MenuItem('Window',       {childMenu: menuWindow})]);

        
    menuGraph = new Menu('Graph menu', false, false);
    menuGraph.addItems([
        menuItemGraphPaste          = new MenuItem('Paste here',      {shortcut: osCtrl()      + 'V', callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(false, e.clientX, e.clientY - getTopHeight()); }}),
        menuItemGraphPasteConnected = new MenuItem('Paste connected', {shortcut: osCtrlShift() + 'V', callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(true,  e.clientX, e.clientY - getTopHeight()); }})]);

    menuGraph.init = () => 
    {
        menuItemGraphPaste         .setEnabled(copiedNodesJson != '');
        menuItemGraphPasteConnected.setEnabled(copiedNodesJson != '');
    };


    menuNodeSelect = new Menu('Select nodes menu', false, false);
    menuNodeSelect.addItems([
        new MenuItem('Select left',   {shortcut:  isMac ? osShift() + osAlt ()            : osShift() + osCtrl(false)          , callback: () => graphView.selectedNodes = [graphView.selectedNodes[0], ...getNodesBeforeNode(graphView.selectedNodes[0])] }),
        new MenuItem('Select right',  {shortcut:  isMac ? osShift() + osCtrl()            : osShift() + osAlt (false)          , callback: () => graphView.selectedNodes = [graphView.selectedNodes[0], ...getNodesAfterNode (graphView.selectedNodes[0])] }),
        new MenuItem('Select across', {shortcut:  isMac ? osAlt  () + osCtrl()            : osCtrl () + osAlt (false)          , callback: () => graphView.selectedNodes = [graphView.selectedNodes[0], ...getNodesAcrossNode(graphView.selectedNodes[0])] }),
        new MenuItem('Select tree',   {shortcut:  isMac ? osShift() + osAlt () + osCtrl() : osShift() + osCtrl() + osAlt(false), callback: () => graphView.selectedNodes =                                 getAllNodesFromNode(graphView.selectedNodes[0]) })]);


    menuNodeCopyAs = new Menu('Copy nodes menu', false, false);
    menuNodeCopyAs.addItems([
        //menuItemNodeCopyAsJsCode       = new MenuItem('Copy as JS code',     {shortcut:  osCtrlShift() + 'C',            callback: () => graphView.copySelectedNodesAsJsCode()     }),
        menuItemNodeCopyAsJsFunction   = new MenuItem('Copy as Javascript', {shortcut:  osCtrlShift() /*+ osAlt()*/ + 'C',  callback: () => graphView.copySelectedNodesAsJavascript() })]);


    menuNode = new Menu('Node menu', false, false);
    menuNode.addItems([
        menuItemNodeCopy           = new MenuItem('Copy',            {shortcut:  osCtrl() + 'C',              callback: () => graphView.copySelectedNodes() }),
        menuItemNodePaste          = new MenuItem('Paste here',      {shortcut:  osCtrl() + 'V',              callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(false); }}),
        menuItemNodePasteConnected = new MenuItem('Paste connected', {shortcut:  osCtrlShift() + 'D',  callback: e => { hideAllMenus(); graphView.pasteCopiedNodes(true ); }}),
                                     new MenuItem('Copy/Paste as',   {childMenu: menuNodeCopyAs}),
                                   //new MenuItem('',                {separator: true}),
      //menuItemNodeLayout         = new MenuItem('Layout',          {enabled:   false, shortcut: osCtrl() + 'L', callback: e => { hideAllMenus(); layoutSelectedNodes(); }}),
        menuItemNodeSep1           = new MenuItem('',                {separator: true}),
        menuItemNodeSelect         = new MenuItem('Select',          {childMenu: menuNodeSelect}),
        menuItemNodeSep2           = new MenuItem('',                {separator: true}),
        // menuItemNodeRename      = new MenuItem('Rename',          {shortcut:  osCtrl() + 'R',              callback: e => { hideAllMenus(); graphView.renameSelectedNode(); }}),
        menuItemNodeEdit           = new MenuItem('Edit...',         {callback: e => { hideAllMenus(); graphView.editSelectedCustomNode(); }}),
                                     new MenuItem('',                {separator: true}),
        // menuItemNodeActivate    = new MenuItem('Activate',        {callback: () => makeSelectedNodesActive()}),
        menuItemNodeEnableDisable  = new MenuItem('Enable/Disable',  {shortcut:  osCtrlShift() + 'E',  callback: () => actionManager.do(new ToggleDisableNodesAction(graphView.selectedNodes.map(n => n.id)))}),
        menuItemNodeSep3           = new MenuItem('',                {separator: true}),
        menuItemNodeRemove         = new MenuItem('Remove',          {shortcut:  osCtrl() + '',             callback: e => { hideAllMenus(); graphView.removeSelectedNodes(true); }})]);


    menuNode.init = () => 
    {
        const single   = graphView.selectedNodes.length == 1;
        //const parallel = nodesAreParallel(graphView.selectedNodes);

        const canDisable = !graphView.selectedNodes.find(n => !n.canDisable);


        updateElementDisplay(menuItemNodeSep1         .div, single);
      //updateMenuItemDisplay(menuItemNodeRename       .div, single);
        updateElementDisplay(menuItemNodeEdit         .div, single);
        updateElementDisplay(menuItemNodeSep2         .div, single);
        updateElementDisplay(menuItemNodeSelect       .div, single);
        updateElementDisplay(menuItemNodeSep3         .div, canDisable);
        updateElementDisplay(menuItemNodeEnableDisable.div, canDisable);
    };


    menuRemoveLicense = new Menu('Remove license', false, false);
    menuRemoveLicense.addItems([
                                new MenuItem('Cut',   {callback: () => { hideAllMenus(); document.execCommand('copy' ); clearSelectedText(productKeyInput); updateProductKeyDots(); }}),
                                new MenuItem('Copy',  {callback: () => { hideAllMenus(); document.execCommand('copy' ); }}),
                                new MenuItem('Paste', {callback: () => { hideAllMenus(); document.execCommand('paste'); }}),
        menuItemLicenseSep1   = new MenuItem('', {separator: true}),
        menuItemLicenseRemove = new MenuItem('Remove from this computer', {callback: () => { hideAllMenus(); removeLicense(); }})]);


    menuText    = new Menu('Text menu',    false, false);
    menuTextbox = new Menu('Textbox menu', false, true);

    menuCopy    = new Menu('Copy menu',    false, false);


    menuLocalStyles = new Menu('Local styles',   true,  true);
    menuSelectParam = new Menu('Select options', false, true);

    
    btnMain   = new MenuButton('', menuMain,   {useMenuName: true, highlight: () => currentMenus.includes(menuMain  ), callback: () => updatePanMode(false)});
    btnFlow   = new MenuButton('', menuFlow,   {useMenuName: true, highlight: () => currentMenus.includes(menuFlow  ), callback: () => updatePanMode(false)});
    btnNumber = new MenuButton('', menuNumber, {useMenuName: true, highlight: () => currentMenus.includes(menuNumber), callback: () => updatePanMode(false)});
    btnText   = new MenuButton('', menuString, {useMenuName: true, highlight: () => currentMenus.includes(menuString), callback: () => updatePanMode(false)});
    btnColor  = new MenuButton('', menuColor,  {useMenuName: true, highlight: () => currentMenus.includes(menuColor ), callback: () => updatePanMode(false)});
    btnStyle  = new MenuButton('', menuStyle,  {useMenuName: true, highlight: () => currentMenus.includes(menuStyle ), callback: () => updatePanMode(false)});
    btnShape  = new MenuButton('', menuShape,  {useMenuName: true, highlight: () => currentMenus.includes(menuShape ), callback: () => updatePanMode(false)});
    btnGroup  = new MenuButton('', menuGroup,  {useMenuName: true, highlight: () => currentMenus.includes(menuShape ), callback: () => updatePanMode(false)});

    // btnGroup  = new MenuButton('Node groups', null, {callback: () => 
    // {
    //     const create = new CreateNodeAction(OUP, btnGroup.div);
    //     actionManager.do(create);

    //     graphView.updateNodes([create.node]);
    //     graphView.updateScrollWithBounds();

    //     updatePanMode(false);
    // }});
    
    btnHand = new MenuButton('Hand tool', null, {callback: () => 
    { 
        updatePanMode(!panMode);
    }});

    btnComment = new MenuButton('Add comment', null, {callback: () => 
    {
        const create = new CreateNodeAction(COMMENT, btnComment.div);
        actionManager.do(create);

        graphView.updateNodes([create.node]);
        graphView.updateScrollWithBounds();

        updatePanMode(false);
    }});


    //menuBar.appendChild(createDiv('', 'groupName'));


    btnPage = new MenuButton(
        '-', 
        menuPage, 
        {
            afterLabel:  true,
            useMenuName: false,
            noHighlight: true
        });

    btnPage.divIcon.style.width   = 4;
    
    btnPage.div.style.marginRight = 'auto';
    
    btnPage.div.style.position    = 'relative';
    btnPage.div.style.left        = '-26px';



    btnZoom = new MenuButton(
        '', 
        menuZoom, 
        { 
            useMenuName: true, 
            selectLast:  false, 
            highlight:   () => currentMenus.includes(menuZoom),
            tooltip:     ttMinValueZoom,
            afterLabel:  true
        });

        
    btnZoom.div.appendChild(createDiv('', 'zoomIconOverlay'));

    btnZoom.divIcon.style.textAlign          = 'center';
    btnZoom.divIcon.style.fontVariantNumeric = 'tabular-nums';
    btnZoom.divIcon.style.letterSpacing      = '-0.8px';


    btnMain.div.style.paddingLeft            = '6px';

    btnZoom.div.style.position               = 'absolute';
    btnZoom.div.style.right                  = '0px';
    btnZoom.div.style.paddingRight           = '5px';
    btnZoom.div.style.paddingLeft            = '11px';
    // btnZoom.div.style.boxShadow           = '0 0 0 1px red inset';


    btnMain   .setIcon(iconGenerator);
    btnShape  .setIcon(iconShapes);
    btnStyle  .setIcon(iconStyle);
    btnGroup  .setIcon(iconGroup);
    btnHand   .setIcon(iconHand);
    btnComment.setIcon(iconComment);
}



function initDataModeMenus()
{
    menuPageData = new Menu('Pages menu', false, false);
    menuPageData.addItems([
        // new MenuItem('Delete all pages',  { enabled: false, callback: () => { hideAllMenus(); dataModeDeleteAllPages(); }}),
        // new MenuItem('',                  { enabled: false, separator: true }),
        new MenuItem('Delete page',       { callback: () => { hideAllMenus(); dataModeDeletePage(menuPageData._div.page); }})]);


    menuPageDataPages = new Menu('Pages menu', false, false);
    menuPageDataPages.addItems([
        new MenuItem('Expand all',       { callback: () => { hideAllMenus(); expandAllPageData();   }}),
        new MenuItem('Collapse all',     { callback: () => { hideAllMenus(); collapseAllPageData(); }}),
        new MenuItem('',                 { separator: true }),
        new MenuItem('Delete all pages', { enabled: false, callback: () => { hideAllMenus(); uiRemoveAllSavedPages(); }})]);


    menuNodeData = new Menu('Node menu', false, false);
    menuNodeData.addItems([
        new MenuItem('Remove path from ID',     { callback: () => { hideAllMenus(); dataModeDeletePathFromNodeId(menuNodeData._div.node); }}),
        new MenuItem('',                        { separator: true }),
        new MenuItem('Delete connections from', { callback: () => { hideAllMenus(); dataModeDeleteConnectionsFromNode     (menuNodeData._div.node); }}),
        new MenuItem('Delete connections to'  , { callback: () => { hideAllMenus(); dataModeDeleteConnectionsToNode       (menuNodeData._div.node); }}),
        new MenuItem('Delete all connections',  { callback: () => { hideAllMenus(); dataModeDeleteConnectionsToAndFromNode(menuNodeData._div.node); }}),
        new MenuItem('',                        { separator: true }),
        new MenuItem('Delete node',             { callback: () => { hideAllMenus(); dataModeDeleteNode(menuNodeData._div.node); }})]);


    menuNodeDataNodes = new Menu('Nodes menu', false, false);
    menuNodeDataNodes.addItems([
        new MenuItem('Expand all',       { callback: () => { hideAllMenus(); expandAllNodeData();   }}),
        new MenuItem('Collapse all',     { callback: () => { hideAllMenus(); collapseAllNodeData(); }}),
        new MenuItem('',                 { separator: true }),
        new MenuItem('Delete all nodes', { callback: () => { hideAllMenus(); dataModeDeleteAllNodes(); }})]);


    menuConnData = new Menu('Connection menu', false, false);
    menuConnData.addItems([
        new MenuItem('Delete connection', { callback: () => { hideAllMenus(); dataModeDeleteConnection(menuConnData._div.conn); }})]);


    menuConnDataConns = new Menu('Connections menu', false, false);
    menuConnDataConns.addItems([
        new MenuItem('Expand all',               { callback: () => { hideAllMenus(); expandAllConnData();   }}),
        new MenuItem('Collapse all',             { callback: () => { hideAllMenus(); collapseAllConnData(); }}),
        new MenuItem('',                         { separator: true }),
        // new MenuItem('List all connection keys', { callback: () => { hideAllMenus(); uiQueueMessageToFigma({cmd: 'figLogAllSavedConnKeys', darkMode: darkMode}); }}),
        // new MenuItem('',                         { separator: true }),
        new MenuItem('Delete all connections',   { callback: e => { hideAllMenus(); dataModeDeleteAllConnections(); }})]);
}



function initTextMenu(textbox)
{
    menuText.clearItems();

    menuText.addItems([
        new MenuItem('Cut',   {enabled: !textbox.control || !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('cut'); }}),
        new MenuItem('Copy',  {                                                        callback: () => { hideAllMenus(); document.execCommand('copy'); }}),
        new MenuItem('Paste', {enabled: !textbox.control || !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('paste'); }})]);
}



function initCopyMenu()
{
    menuCopy.clearItems();

    menuCopy.addItems([
        new MenuItem('Copy',       {enabled: elementHasSelectedText(crashDialogBody), callback: () => { hideAllMenus(); document.execCommand('copy'); }}),
        new MenuItem('',           {separator: true }),
        new MenuItem('Select all', {callback: () => { hideAllMenus(); selectDivText(crashDetails); }})]);
}



function initTextboxMenu(textbox)
{
    menuTextbox.clearItems();


    let menuItemLeft,
        menuItemCenter,
        menuItemRight,
        menuItemJustify;


    const param = textbox.control.param;

    menuTextbox.addItems([
                          new MenuItem('Cut',          { enabled: !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('cut'); }}),
                          new MenuItem('Copy',         {                                     callback: () => { hideAllMenus(); document.execCommand('copy'); }}),
                          new MenuItem('Paste',        { enabled: !textbox.control.readOnly, callback: () => { hideAllMenus(); document.execCommand('paste'); }}),
                          new MenuItem('',             { separator: true }),
        menuItemLeft    = new MenuItem('Align left',   { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'left'   )); }}),
        menuItemCenter  = new MenuItem('Align center', { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'center' )); }}),
        menuItemRight   = new MenuItem('Align right',  { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'right'  )); }}),
        menuItemJustify = new MenuItem('Justify',      { callback: () => { hideAllMenus(); actionManager.do(new SetParamSettingAction(param, 'align', 'justify')); }})]);


    const align = textbox.control.getTextAlignment();

    menuItemLeft   .setChecked(align == 'left'   );
    menuItemCenter .setChecked(align == 'center' );
    menuItemRight  .setChecked(align == 'right'  );
    menuItemJustify.setChecked(align == 'justify');
}



function updatePanMode(enabled)
{
    panMode = enabled;  
    currentMenuButton = panMode ? btnHand : null;
    btnHand.update();
}



function getCreateOptions(e, opt = {})
{
    return {
        insert:      e.ctrlKey,
        autoConnect: e.ctrlKey && e.altKey,
        ...opt
    };
}


function createToggleButton(width, height)
{
    const btn = createDiv('toggleButton');
    btn.enabled = false;

    btn.addEventListener('pointerdown', e =>
    {
        e.stopPropagation();

        btn.setPointerCapture(e.pointerId);
        btn.enabled = !btn.enabled;
        btn.updateBackground(true);
    });


    btn.addEventListener('pointerup', e =>
    {
        btn.releasePointerCapture(e.pointerId);
        btn.updateBackground(false);
    });


    btn.updateBackground = (enabled) =>
    {
        const col = darkMode ? 'white' : 'black';

        btn.style.background = 
            btn.enabled 
            ? 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 1C4.10457 1 5 1.89543 5 3V5H6V3C6 1.34315 4.65685 0 3 0C1.34315 0 0 1.34315 0 3V5H1V3C1 1.89543 1.89543 1 3 1Z" fill="'+col+'"/><path d="M5 9H6V11C6 12.6569 4.65685 14 3 14C1.34315 14 0 12.6569 0 11V9H1V11C1 12.1046 1.89543 13 3 13C4.10457 13 5 12.1046 5 11V9Z" fill="'+col+'"/><path d="M2.5 4V10H3.5V4H2.5Z" fill="'+col+'"/></svg>\')'
            : 'url(\'data:image/svg+xml;utf8,<svg width="6" height="14" viewBox="0 -2 6 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 5V3C5 1.89543 4.10457 1 3 1C1.89543 1 1 1.89543 1 3V5H0V3C0 1.34315 1.34315 0 3 0C4.65685 0 6 1.34315 6 3V5H5Z" fill="'+col+'"/><path d="M6 9H5V11C5 12.1046 4.10457 13 3 13C1.89543 13 1 12.1046 1 11V9H0V11C0 12.6569 1.34315 14 3 14C4.65685 14 6 12.6569 6 11V9Z" fill="'+col+'"/></svg>\')';

        btn.style.backgroundPosition = '50% 50%';
        btn.style.backgroundRepeat   = 'no-repeat';

        btn.style.backgroundColor = 
               btn.enabled 
            && enabled 
            ? (darkMode ? '#444' : '#e6e6e6') 
            : 'transparent';
    };


    return btn;
}


function initMenuSelectMenu(select)
{
    select.menu = createDiv('menuSelectMenu');

    select.menu.hoverIndex   = 0;
    select.menu.tabIndex     = 0;

    select.menu.style.left   = select.offsetLeft;
    select.menu.style.zIndex = MAX_INT32;

    select.menu.addEventListener('focus', function() 
    {
         select.menu.style.outline = 'none'; 
    });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });
    
    

    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = '100%';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = 'var(--figma-color-bg-brand)';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = 0; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();

        const onchange = new CustomEvent('change', { detail: 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        }});

        select.dispatchEvent(onchange);

        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initMenuSelectTextbox(select)
{
    select.textbox = createTextbox('menuSelectText');
    
    
    select.textbox.addEventListener('keydown', function(e)
    {
        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }
        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
            select.textbox.finish(true);

        else if (e.code == 'Escape')
            select.textbox.finish(false);

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            let tabs  = document.querySelectorAll('.control, .menuSelect, .select, button, .menuButton');
            let index = select.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'slider')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else 
        {
            if (   e.key.length == 1
                && !isDigit(e.key)
                && e.key != '.'
                && !(   (   e.code == 'Minus'
                         || e.code == 'NumpadSubtract')
                     && select.min < 0))
                e.preventDefault();

            let t = select.textbox;

            let curVal = t.value;

            curVal = 
                  curVal.substring(0, t.selectionStart) 
                + curVal.substring(t.selectionEnd, curVal.length);

            let nextVal = parseFloat(curVal + e.key);

            if (   nextVal < select.min - 0.001
                || nextVal > select.max)
                e.preventDefault();            
        }
    });


    // control.textbox.addEventListener('input', function()
    // {
    //     control.setValue(Number(control.textbox.value));
    // });


    select.textbox.addEventListener('paste', function(e)
    {
        e.preventDefault();

        let val = parseFloat(e.clipboardData.getData('text/plain'));
        val = Math.min(Math.max(select.min, val), select.max);

        select.textbox.value = isNaN(val) ? '' : val;
    });


    select.textbox.addEventListener('focusout', function()
    {
        select.parentNode.removeChild(select.textbox);
        select.clicked = false;
    });
    

    select.textbox.finish = function(success)
    {
        if (success) select.setValue(Number(select.textbox.value     ));
        else         select.setValue(Number(select.textbox.savedValue));

        select.textbox.blur();

        if (select.inFocus)
            select.focus();
    };    
    
    
    select.showTextbox = function()
    {
        select.inFocus = 
               hasFocus(select)
            && !select.clicked;

            
        select.textbox.style.boxShadow = '0 0 0 1px var(--figma-color-bg-brand)';
        select.textbox.style.outline   = 'none';
    
        select.textbox.style.textAlign = 'center';
    
        select.textbox.value = numToString(select.value, select.dec);
        select.textbox.savedValue = select.textbox.value;
        
        select.parentNode.appendChild(select.textbox);
        
        select.textbox.focus();
        select.textbox.select();
    }
}


function initMenuSelect(select)
{
    select.className = 'menuSelect';
    select.tabIndex  = 0;    
    
    initMenuSelectMenu   (select);
    initMenuSelectTextbox(select);

    select.holding = false;

    select.enableChangeEvent = true;


    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function(items)
    {
        select.resetMenu();
        
        
        select.items = items;
        select.update(0);


        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            item.style.border      = 'none';
            item.style.height      = 24;

            item.disabled = false;

            sub.innerHTML = select.items[i].text;

            item.appendChild(sub);

            select.menuWrap.appendChild(item);
        }
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();

            const rect = boundingRect(select);

            if (e.clientX > rect.width - 20)
            {
                select.buttonDown0 = true;        
                select.setPointerCapture(e.pointerId);
                
                select.holding = false;
                setTimeout(function() { onSelectClickTimer(select); }, 200);
                
                select.menu.hoverIndex = select.getSelectedIndex();

                select.showMenu();
            }
            else
                select.showTextbox();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        // let menuTop =
        //     select.offsetTop; 
        //     - 3 // paddingTop
        //     - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
        //     - iy * 24;
        
        menuTop = select.offsetTop + select.offsetHeight + 11;//Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
            iy = Math.min(Math.max(0, iy), select.items.length-1);

        return iy;
    };        
    

    
    select.getSelectedValue = function()
    {
        return select.items[select.getSelectedIndex()].value;
    };        



    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    };



    select.setSelectedIndex = function(index)
    {
        select.value = select.items[index].value;
        select.update(select.getSelectedIndex());
        
        select.enableChangeEvent = false;
        select.dispatchChangeEvent();
        select.enableChangeEvent = true;
    };



    select.dispatchChangeEvent = function()
    {
        if (!select.enableChangeEvent)
            return;
    
        let index = select.getSelectedIndex();
    
        const onchange = new Event('change', 
        {
            selectedIndex: index,
            selectedValue: select.items[index].value
        });

        select.dispatchEvent(onchange);
    };
}



function initSelectMenu(select)
{
    select.menu = createDiv('selectMenu');

    select.menu.hoverIndex       =  0;
    select.menu.tabIndex         =  0;

    select.menu.style.left       =  select.offsetLeft;
    select.menu.style.height     = 'auto';
    select.menu.style.textAlign  = 'center';
    select.menu.style.background = '#222';
    select.menu.style.zIndex     =  MAX_INT32-3;
    


    select.menu.addEventListener('focus', function() { select.menu.style.outline = 'none'; });

    select.menu.addEventListener('keydown', function(e)
    { 
        if (e.code == 'Escape')
            select.menu.blur();
    });        
    

    
    select.menu.tabIndex   = 0;
    
    select.menu.hoverIndex = 0;


    select.selectBox = createDiv();
        
    // width is set with menu width in showMenu()
    select.selectBox.style.display         = 'inline-block';
    select.selectBox.style.width           = 'calc(100% + 1px)';
    select.selectBox.style.height          = 24;
    select.selectBox.style.backgroundColor = 'var(--figma-color-bg-brand)';
    select.selectBox.style.position        = 'absolute';
    select.selectBox.style.left            = -1; // -1 = border
    
    select.menu.appendChild(select.selectBox);
    

    select.menuWrap = createDiv();
    
    select.menuWrap.style.width         = 'auto';
    select.menuWrap.style.height        = '100%';
    select.menuWrap.style.position      = 'relative';
    select.menuWrap.style.paddingLeft   = 4;
    select.menuWrap.style.paddingRight  = 5;
    select.menuWrap.style.paddingTop    = 7;
    select.menuWrap.style.paddingBottom = 7;
    select.menuWrap.style.margin        = 0;
    select.menuWrap.style.marginRight   = 10;
    
    select.menu.appendChild(select.menuWrap);



    select.menu.addEventListener('pointerdown', function(e)
    {
        e.stopPropagation();
    });            
    


    select.menu.addEventListener('pointerup', function(e)
    {
        if (select.holding)
            select.menu.selectCurrent();
    });         



    select.menu.addEventListener('pointermove', function(e)
    {
        select.menu.hoverIndex = select.indexFromY(e.clientY);
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    });                
    


    select.menu.selectCurrent = function()
    {
        select.update(select.menu.hoverIndex);
        select.hideMenu();
        select.dispatchChangeEvent();
        select.focus();

        document.menuHadFocus = false;
    };



    select.menu.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter')
        {
            select.menu.selectCurrent();   
        }
        else if (e.code == 'ArrowUp')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex - 1), select.items.length-1);
            select.updateMenu();
        }
        else if (e.code == 'ArrowDown')
        {
            select.menu.hoverIndex = Math.min(Math.max(0, select.menu.hoverIndex + 1), select.items.length-1);
            select.updateMenu();
        }        
    });        



    select.menu.addEventListener('focusout', function()
    {
        select.hideMenu();

        select.menu.style.display = 'none';
        select.parentNode.removeChild(select.menu);
    });
}


function initSelect(select, items)
{
    select.className = 'menuSelect';
    select.tabIndex = 0;    
    
    initSelectMenu(select);

    select.holding  = false;
    

    
    //////////////////////////////////////////////////////////////////////////////////
    


    select.initMenu = function()
    {
        select.check = createDiv();
        
        select.check.style.width    = 16;
        select.check.style.height   = 16;
        select.check.style.position = 'absolute';
        select.check.style.left     = 8;
        select.check.innerHTML      = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M13.2069 5.20718L7.70694 10.7072L6.99983 11.4143L6.29272 10.7072L3.29272 7.70718L4.70694 6.29297L6.99983 8.58586L11.7927 3.79297L13.2069 5.20718Z" fill="white" fill-opacity="1"/></svg>';
    };



    select.resetMenu = function()
    {
        clearChildren(select.menuWrap);
        select.menuWrap.appendChild(select.check);
    };  



    select.updateItems = function()
    {
        select.resetMenu();
        
        for (let i = 0; i < select.items.length; i++)
        {
            let item = createDiv();
            let sub  = createDiv();
            
            item.style.width       = 'auto';
            item.style.display     = 'block';
            item.style.textAlign   = 'left';
            item.style.paddingLeft = 30;
            
            sub .style.height      = 'auto';
            sub .style.position    = 'relative';
            sub .style.top         = '50%';
            sub .style.transform   = 'translateY(-50%)';
            
            if (select.items[i].value == '-')
            {
                item.style.borderTop = '1px solid white';
                item.style.marginTop = '6px';
                item.style.height    = '4px';
                item.style.position  = 'relative';
                item.style.left      = '6px';
                
                item.disabled = true;
            }
            else
            {
                item.style.border = 'none';
                item.style.height = 24;

                item.disabled = false;

                sub.innerHTML = select.items[i].text;
            }

            item.appendChild(sub);
            select.menuWrap.appendChild(item);
        }


        let options = select.getElementsByTagName('option');

        for (const node of options) 
            node.disabled = node.value == '-';
    };
    


    select.update = function(index)
    {
        select.value     = select.items[index].value;
        select.innerHTML = select.items[index].text;
    };
    

    
    select.addEventListener('pointerdown', function(e)
    {
        if (e.button == 0)
        {
            e.preventDefault();
            e.stopPropagation();
            
            select.buttonDown0 = true;        
            select.setPointerCapture(e.pointerId);
            
            select.holding = false;
            setTimeout(function() { onSelectClickTimer(select); }, 200);
            
            select.menu.hoverIndex = select.getSelectedIndex();

            select.showMenu();
        }        
    });        
    

    
    select.addEventListener('keydown', function(e)
    {
        if (   e.code == 'Enter' 
            || e.code == 'NumpadEnter'
            || e.code == 'ArrowUp'
            || e.code == 'ArrowDown')
        {
            select.showMenu();
        }        
    });        



    select.showMenu = function()
    {  
        select.menu.style.display = 'inline-block';

        select.parentNode.appendChild(select.menu);
        select.updateMenu();
        
        select.menu.focus();

        document.menuHadFocus = true;
    }        
    


    select.hideMenu = function()
    {
        select.menu.blur();
    };    



    select.updateMenu = function()
    {
        let iy = select.getSelectedIndex();
        
        let menuTop =
            select.offsetTop 
            - 3 // paddingTop
            - 4 // hack this for now (select.menu.children[0].offsetHeight - select.menu.children[0].children[0].offsetHeight) / 2;
            - iy * 24;
        
        menuTop = Math.min(Math.max(8, menuTop), document.body.clientHeight - 8 - select.menu.offsetHeight);
        
        select.menu .style.top = menuTop;
        select.check.style.top = 7 + 4 + iy * 24;
        
        select.selectBox.style.top = 7 + select.menu.hoverIndex * 24;
    };
    


    select.indexFromY = function(y)
    {
        let iy = Math.floor((y - 8 - select.menu.offsetTop) / 24);
        iy = Math.min(Math.max(0, iy), select.items.length-1);
        return iy;
    };        
    

    
    select.getSelectedIndex = function()
    {
        return select.items.findIndex(item => item.value == select.value);
    };        



    select.setValue = function(value)
    {
        select.value = value;
        select.update(select.getSelectedIndex());
        select.dispatchChangeEvent();
    }



    select.dispatchChangeEvent = function()
    {
        const onchange = new Event('change', 
        {
            selectedIndex: select.getSelectedIndex(),
            selectedValue: select.items[select.getSelectedIndex()].value
        });

        select.dispatchEvent(onchange);
    };


    //////////////////////////////////////////////////////////////////////////////////

    
    select.items = items;
    
    select.update(0);
    select.updateItems();
}



function onSelectClickTimer(select)
{
    select.holding = true;
}


function initCheckbox(checkbox, name, defaultChecked)
{
    // control is also the div

    checkbox.className     = 'checkbox';
    
    checkbox.checked       = defaultChecked;
    checkbox.name          = name;
    
    checkbox.style.display = 'inline';
             
    checkbox.onchange      = new Event('change');


    checkbox.check         = createDiv('checkboxCheck');
    checkbox.text          = createDiv('checkboxText');

    checkbox.appendChild(checkbox.check);
    checkbox.appendChild(checkbox.text);



    checkbox.addEventListener('pointerup', () =>
    {
        checkbox.setChecked(!checkbox.checked);
    });



    checkbox.setName = function(name)
    {
        checkbox.name = name;
        checkbox.update();
    };



    checkbox.setChecked = function(checked, fireChangeEvent = true)
    {
        const oldChecked = checkbox.checked;

        checkbox.checked = checked;
        checkbox.update();

        if (   fireChangeEvent
            && checked != oldChecked)
            checkbox.dispatchEvent(checkbox.onchange);
    };



    checkbox.update = function()
    {
        if (checkbox.checked)
        {
            checkbox.check.style.backgroundColor    = 'var(--figma-color-bg-brand)';
            checkbox.check.style.backgroundImage    = 'url(\'data:image/svg+xml;utf8,<svg width="8" height="7" viewBox="0 0 8 7" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.17647 1.88236L3.05882 3.76472L6.82353 0L8 1.17648L3.05882 6.11768L0 3.05884L1.17647 1.88236Z" fill="white"/></svg>\')';
            checkbox.check.style.backgroundPosition = '50% 50%';
            checkbox.check.style.backgroundRepeat   = 'no-repeat';
            checkbox.check.style.boxShadow          = 'none';
        }
        else
        {
            checkbox.check.style.background         = 'transparent';
            checkbox.check.style.boxShadow          = '0 0 0 1px var(--figma-color-text) inset';
        }

        checkbox.text.innerHTML = name;
    };



    checkbox.update();
}


class GraphView
{
    div;

    wireContainer;

    scrollbarX;
    scrollbarY;


    wires          = [];
    

    creatingNodes  = false;
    loadingNodes   = false;
    pastingNodes   = false;
    restoringNodes = false;


    canUpdateNodes = true;


    activeNodes    = [];


    overNode       = null;
    overInput      = null;
    overOutput     = null;
        
    headerInput    = null; // same as overInput, but when snapping from a header
    headerOutput   = null; // same as overOutput, but when snapping from a header
        
    tempConn       = null;
    tempConnSwap   = null;
    savedConn      = null;
    tempConnected  = false;

    connPointerId  = -1;

    _soloNode      = null;
    
    selecting      = false;
    selectionRect  = Rect.NaN;

    btn1down       = false; // this is to help deal with mouse wheels that send X values as
                             // sometimes a MMB press is followed by wheelX as a "deeper" middle-click

    altDown        = false;

    panning        = false;
    
    pViewport; 
    pStart         = point(0, 0);
    zoomStart;


    touches        = [];


    wheelTimer     = null;


    measureData    = {};



    panning = false;
    panStart;
    
    spaceDown = false;
    
    
    
    oldZoom = 1;


    zooming       = false;
    zoomStart     = 1;

    zoomSelecting = false;


    panZoomTimer  = null;



    _selectedNodes     = [];
    _prevSelectedNodes = [];
    lastSelectedNodes  = [];
    
    
    get selectedNodes() { return this._selectedNodes; }
    set selectedNodes(nodes)
    {
        this.deselectAll();

        this._selectedNodes = [...nodes];
    
        for (const node of this._selectedNodes)
            node.setSelected(true);
    }



    constructor(div)
    {
        this.div                     = div;
          
        this.wireContainer           = createDiv('wireContainer');
                  
        this.scrollbarX              = createDiv('scrollbar', 'scrollbarX');
        this.scrollbarY              = createDiv('scrollbar', 'scrollbarY');


        this.scrollbarX.style.zIndex = MAX_INT32-1;
        this.scrollbarY.style.zIndex = MAX_INT32-2;

        this.scrollbarX.moving       = false;
        this.scrollbarY.moving       = false;


        this.div.appendChild(this.wireContainer);
        this.div.appendChild(this.scrollbarX);
        this.div.appendChild(this.scrollbarY);


        this.createEvents();
        this.createScrollbarMethods();
    }



    update()
    {
        graphView.updatePanAndZoom(false);
        graphView.updateScrollWithBounds();
        graphView.div.style.height = 'calc(100% - ' + getTopHeight() + 'px)';
        graphView.updateMeasureData();
    }



    updateMeasureData()
    {
        this.measureData.clientRect = clientRect(this.div);
    }



    getAllNodeBounds(onlySelected = false)
    {
        let bounds = Rect.NaN;

        const nodes =
                onlySelected
            && !isEmpty(this.selectedNodes)
            ? this.selectedNodes
            : graph.pageNodes;

        for (const node of nodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        return bounds;
    }



    getAllNodeOffsets(nodes = null)
    {
        let bounds = Rect.NaN;

        if (!nodes)
            nodes = graph.pageNodes;

        for (const node of nodes)
            bounds = expandRect(bounds, offsetRect(node.div));

        return bounds;
    }



    getAllNodeBounds()
    {
        let bounds = Rect.NaN;

        for (const node of graph.pageNodes)
            bounds = expandRect(bounds, boundingRect(node.div));

        return bounds;
    }



    getNodeBounds(node)
    {
        const bounds = boundingRect(node.div);

        return new Rect(
            parseFloat(node.div.style.left ),
            parseFloat(node.div.style.top  ),
            parseFloat(node.div.style.width),
            bounds.h / graph.currentPage.zoom); // node height isn't defined
    }



    getZoomedNodeBounds(node)
    {
        const bounds = this.getNodeBounds(node);

        bounds.x += graph.currentPage.pan.x / graph.currentPage.zoom;
        bounds.y += graph.currentPage.pan.y / graph.currentPage.zoom;
        bounds.w /= graph.currentPage.zoom;
        bounds.h /= graph.currentPage.zoom;

        return bounds;
    }



    getIntersectingNodes(node)
    {
        const nodeBounds = this.getZoomedNodeBounds(node);

        const intersecting = [];
        
        for (const n of graph.pageNodes)
        {
            const nBounds = this.getZoomedNodeBounds(n);
            
            if (   n != node
                && rectsIntersect(nBounds, nodeBounds))
                intersecting.push(n);
        }

        return intersecting;
    }



    placeNewNode(node)
    {
        //console.log('GraphView.placeNewNode()');

        const nodeRect = boundingRect(node.div);
        
        const btn = node._creatingButton;

        if (btn)
        {
            node.div.style.left = (btn.offsetLeft + btn.offsetWidth/2 - graph.currentPage.pan.x) / graph.currentPage.zoom - nodeRect.width/2;
            node.div.style.top  = (20 - graph.currentPage.pan.y) / graph.currentPage.zoom;
        }
        else
        {
            node.div.style.left = (this.div.offsetWidth /2 - graph.currentPage.pan.x                ) / graph.currentPage.zoom - nodeRect.width /2;
            node.div.style.top  = (this.div.offsetHeight/2 - graph.currentPage.pan.y - getTopHeight()) / graph.currentPage.zoom - nodeRect.height/2;
        }
    }



    autoPlaceNewNode(output, input)
    {
        //console.log('GraphView.autoPlaceNewNode()');

        const defaultPlacementGap = 30;

        input.node.div.style.left = output.node.div.offsetLeft + output.node.div.offsetWidth + defaultPlacementGap;
        input.node.div.style.top  = output.node.div.offsetTop;//outputRect.y - graph.currentPage.pan.y/graph.currentPage.zoom - (inputRect.y - inputNodeRect.y);
    }



    putNodeOnTop(node)
    {
        const topIndices = 
               1 
            +  node.inputs.filter(i => i.connected).length 
            + (node.outputs.find(o => o.connected) ? 1 : 0);
            
        for (const n of graph.pageNodes)
            n.div.style.zIndex = Math.max(0, Number(n.div.style.zIndex) - topIndices);
            
        node.div.style.zIndex = MAX_INT32-3; // -3 is for scrollbars;

        this.putWiresOnTop(node);
    }



    putWiresOnTop(node)
    {
        // changing z-index doesn't work so easily with SVG,
        // so reinsert the wires on top instead 

        let z = MAX_INT32;

        for (const input of node.inputs.filter(i => i.connected))
        {
            this.wireContainer.removeChild(input.connection.wire.svg);
            this.wireContainer.appendChild(input.connection.wire.svg);
        }
            
        for (const output of node.outputs)
        {
            for (const connInput of output.connectedInputs)
            {
                this.wireContainer.removeChild(connInput.connection.wire.svg);
                this.wireContainer.appendChild(connInput.connection.wire.svg);
            }
        }
    }



    showCompatibleInputs(output = null)
    {
        for (const node of graph.pageNodes)
            for (const input of node.inputs)
                input.div.style.opacity = 
                       !output 
                    || input.canConnectFrom(output)
                    || input.connected
                    ? 1 
                    : 0;
    }
    
    
    
    hideAllInputs(except = null)
    {
        for (const node of graph.pageNodes)
            for (const input of node.inputs)
                if (    input != except
                    && !input.connected)
                    input.div.style.opacity = 0;
    }
    
    
   
    showCompatibleOutputs(input = null)
    {
        for (const node of graph.pageNodes)
            for (const output of node.outputs)
                output.div.style.opacity = 
                       !input 
                    || input.canConnectFrom(output)
                    || !output.connected
                    ? 1 
                    : 0;
    }
    
    
    
    hideAllOutputs(except = null)
    {
        for (const node of graph.pageNodes)
            for (const output of node.outputs)
                if (    output != except
                    && !output.connected)
                    output.div.style.opacity = 0;
    }
    
    
   
    // point2screen(p)
    // {
    //     return point(
    //         (p.x + graph.currentPage.pan.x / graph.currentPage.zoom) * graph.currentPage.zoom,
    //         (p.y + graph.currentPage.pan.y / graph.currentPage.zoom) * graph.currentPage.zoom);
    // }
    
    
    
    // screen2point(p)
    // {
    //     return point(
    //         p.x / graph.currentPage.zoom - graph.currentPage.pan.x / graph.currentPage.zoom,
    //         p.y / graph.currentPage.zoom - graph.currentPage.pan.y / graph.currentPage.zoom);
    // }
    
    
    
    // rect2screen(rect)
    // {
    //     return new Rect(
    //         (rect.x + graph.currentPage.pan.x / graph.currentPage.zoom) * graph.currentPage.zoom,
    //         (rect.y + graph.currentPage.pan.y / graph.currentPage.zoom) * graph.currentPage.zoom,
    //         rect.width  * graph.currentPage.zoom,
    //         rect.height * graph.currentPage.zoom);
    // }
    
    
    
    screen2rect(rect)
    {
        return new Rect(
            rect.x      / graph.currentPage.zoom - graph.currentPage.pan.x / graph.currentPage.zoom,
            rect.y      / graph.currentPage.zoom - graph.currentPage.pan.y / graph.currentPage.zoom,
            rect.width  / graph.currentPage.zoom,
            rect.height / graph.currentPage.zoom);
    }
    
    
    
    // toJson()
    // {
    //     const tab = '\n' + HTAB;

    //     return '{'
    //         + tab + '"zoom": "' + graph.currentPage.zoom  + '",'
    //         + tab + '"panx": "' + graph.currentPage.pan.x + '",'
    //         + tab + '"pany": "' + graph.currentPage.pan.y + '"'
    //         + '\n}';
    // };
}


GraphView.prototype.updateNodes = function(nodes = null, updateNodes = true)
{
    if (!nodes)
        nodes = graph.pageNodes;
        
    
    documentBodyClient = clientRect(document.body);


    this.updateNodeTransforms(nodes, false);
    this.updateNodeTransforms(nodes); // this has to be done twice //because getAllNodeBounds() forces a reflow

    nodes.forEach(n => n.updateMeasureData());

    if (updateNodes)
    {
        nodes.forEach(n =>
        {
            n.updateHeader(); 
            n.updateHeaderLabel();
            n.updateBorder();
            n.updateDisabled();

            if (n.updateSizers)
                n.updateSizers();
        });
    }


    const x = this.measureData.clientRect.left;
    const w = this.measureData.clientRect.width;
    const h = this.measureData.clientRect.height;
    
    const bounds = this.getAllNodeBounds();

    this.updateScroll(x, w, h, bounds, getTopHeight());
};



GraphView.prototype.updateNodeTransforms = function(nodes, _updateWires = true)
{
    const nodeLeft = nodes.map(n => n.div.offsetLeft);
    const nodeTop  = nodes.map(n => n.div.offsetTop);
    const nodeRect = nodes.map(n => n.getOffsetRect());

    for (let i = 0; i < nodes.length; i++)
        nodes[i].setTransform(nodeLeft[i], nodeTop[i], nodeRect[i]);

    if (_updateWires)
        this.updateNodeWireTransforms(nodes);
};



GraphView.prototype.updateNodeWireTransforms = function(nodes)
{
    const wires = [];

    
    for (const node of nodes)
    {
        for (const input of node.inputs)
            if (   input.connected
                && input.connection
                && !wires.includes(input.connection.wire))
                wires.push(input.connection.wire);        

        for (const output of node.outputs)
            for (const connInput of output.connectedInputs)
                if (    connInput.connection
                    && !wires.includes(connInput.connection.wire))
                    wires.push(connInput.connection.wire);
    }


    this.updateWires(wires);
};



GraphView.prototype.soloNode = function(node)
{
    this._soloNode = node;

    graph.pageNodes.forEach(n => 
        n.div.style.opacity = 
                n == this._soloNode
            || n.isConnectedTo(this._soloNode)
            ? 1 
            : 0.12);

    graph.connections.forEach(c =>
    { 
        c.wire.svg.style.opacity = 
               c.input  && this._soloNode == c.input .node
            || c.output && this._soloNode == c.output.node
            ? 1 
            : 0.09;
    });


    this.updateWires(graph.connections.map(c => c.wire));
};



GraphView.prototype.unsoloNode = function()
{
    this._soloNode = null;

    graph.pageNodes  .forEach(n => n.div     .style.opacity = 1);
    graph.connections.forEach(c => c.wire.svg.style.opacity = 1);

    this.updateWires(graph.connections.map(c => c.wire));
};



GraphView.prototype.updateShowWires = function(updateNodes = true)
{
    graph.connections.forEach(c => showElement(c.wire.svg, true));

    if (updateNodes) 
        graph.pageNodes.forEach(n => n.updateNode());
};



GraphView.prototype.setNodePositions = function(nodes, dx, dy, updateTransform = true)
{
    //console.log('GraphView.setNodePositions()');

    for (const node of nodes)
    {
        node.div.style.left = node.slx + dx + 'px';
        node.div.style.top  = node.sly + dy + 'px';
    }

    if (updateTransform)
        this.updateNodeTransforms(nodes);
};



GraphView.prototype.selectAllNodes = function(invert)
{
    const lastSelected = [...this.selectedNodes];

    this.selectedNodes = 
        invert
        ? graph.pageNodes.filter(n => !lastSelected.includes(n))
        : graph.pageNodes;
        
    actionManager.do(new SelectNodesAction(
        this.selectedNodes.map(n => n.id), 
        lastSelected      .map(n => n.id)));
};



GraphView.prototype.deselectAllNodes = function()
{
    const lastSelected = [...this.selectedNodes];

    this.selectedNodes = [];
        
    actionManager.do(new SelectNodesAction(
        this.selectedNodes.map(n => n.id), 
        lastSelected      .map(n => n.id)));
};



GraphView.prototype.copySelectedNodes = function()
{
    pasteOffset     = point(0, 0);
    copiedNodesJson = uiCopyNodes(this.selectedNodes.map(n => n.id));

    writeTextToClipboard(copiedNodesJson);
};



class GenJS
{
    nodes;
    terminals;

    nTab = 0;
    
    get tab() { return TAB.repeat(this.nTab); }
    get NL () { return '\n' + this.tab; }


    constructor(nodes, terminals)
    {
        this.nodes     = nodes;
        this.terminals = terminals;
    }


    connectedOut(node)
    {
        return node.inputs.find(i => 
                      i.connected 
                   && !this.nodes.includes(i.connectedOutput.node));
    }
};



GraphView.prototype.copySelectedNodesAsJavascript = function()
{
    const terminals = getTerminalsInNodes(this.selectedNodes);

    const gen = new GenJS(this.selectedNodes, terminals);


    let js = '';

    for (const terminal of terminals)
    {
        js += '\n';
        js += terminal.toJavascript(gen);
    }


    console.log(js);
    writeTextToClipboard(js);
};



GraphView.prototype.pasteCopiedNodes = function(pasteConnected, clientX = Number.NaN, clientY = Number.NaN)
{
    readTextFromClipboard().then(text =>
    {
        if (text == '')
            return;

        const x = (clientX - graph.currentPage.pan.x) / graph.currentPage.zoom;
        const y = (clientY - graph.currentPage.pan.y) / graph.currentPage.zoom;
            
        actionManager.do(new PasteNodesAction(text, pasteConnected, false, x, y));
    });
};



GraphView.prototype.duplicateSelectedNodes = function(pasteConnected)
{
    if (!isEmpty(this.selectedNodes))
    {
        pasteOffset = point(0, 0);
        actionManager.do(new PasteNodesAction(uiCopyNodes(this.selectedNodes.map(n => n.id)), pasteConnected, true));
    }
};



GraphView.prototype.deleteSelectedNodes = function(cut = false)
{
    const nodeIds = this.selectedNodes.map(n => n.id);

    if (!isEmpty(nodeIds))
    {
        actionManager.do(new DeleteNodesAction(nodeIds, cut));
        this._selected = [];
    }
};



GraphView.prototype.removeSelectedNodes = function()
{
    const nodeIds = this.selectedNodes.map(n => n.id);

    if (!isEmpty(nodeIds))
    {
        actionManager.do(new RemoveNodesAction(nodeIds));
        this._selected = [];
    }
};



GraphView.prototype.layoutSelectedNodes = function()
{
    
};



GraphView.prototype.renameSelectedNode = function()
{
    if (this.selectedNodes.length == 1)
        this.selectedNodes[0].showLabelTextbox();
};



GraphView.prototype.editSelectedCustomNode = function()
{
    actionManager.do(new SetCurrentGraphAction(this.selectedNodes[0].graph));
};



GraphView.prototype.getTopNodeIndex = function()
{
    let max = 0;
    
    for (const node of graph.pageNodes)
        max = Math.max(max, node.div.style.zIndex);

    return max;
};


GraphView.prototype.startConnectionFromOutput = function(pointerId, output, updateTempWire = true, backInit = false)
{
    this.connPointerId = pointerId;

    this.tempConn          = new Connection(output, null);
    this.tempConn.backInit = backInit;

    //this.tempConnected = false;
    this.addConnWires(this.tempConn, false);

    if (updateTempWire)
        this.tempConn.wire.update(this.pStart.x, this.pStart.y);

    this.showCompatibleInputs(output);
    this.hideAllOutputs(this.tempConn.output);

    output.updateControl();
};



GraphView.prototype.startConnectionFromInput = function(pointerId, input, backInit = false)
{
    this.connPointerId = pointerId;

    this.tempConn          = new Connection(null, input);
    this.tempConn.backInit = backInit;
    
    this.addConnWires(this.tempConn, false);

    this.tempConn.wire.update(this.pStart.x, this.pStart.y);

    this.showCompatibleOutputs(input);
    this.hideAllInputs(this.tempConn.input);

    input.updateControl();
};



GraphView.prototype.cancelConnection = function(pointerId)
{
    const output = this.tempConn.output;
    const input  = this.tempConn.input;

    this.removeConnWires(this.tempConn);    

    if (this.savedConn)
        this.savedConn.wire.update();

    this.savedConn = null;
    this.tempConn  = null;

    if (output) output.updateControl();
    if (input ) input .updateControl();

    if (this.overInput ) this.overInput .updateControl();
    if (this.overOutput) this.overOutput.updateControl();


    if (this.div.hasPointerCapture(pointerId))
        this.div.releasePointerCapture(pointerId);

    this.connPointerId = -1;


    this.showCompatibleInputs();
    this.showCompatibleOutputs();


    newReorderIndex  = Number.NaN;
    prevReorderIndex = Number.NaN;
    oldReorderIndex  = Number.NaN;
};



GraphView.prototype.endConnection = function(pointerId, backInit = false)
{
    if (this.tempConn.output) // FROM OUTPUT
    {
        let output = this.tempConn.output;
        let input  = this.overInput;

        let savedConnInput = 
            this.savedConn
            ? this.savedConn.input
            : null;

        output.connecting = false;
        

        if (   input
            && input.canConnectFrom(output))
        {
            if (  !savedConnInput
                || savedConnInput != input) // TO INPUT
            {
                if (input.node.variableInputs) this.endConnectionFromOutputToVariable(output, input, savedConnInput, backInit);
                else                           this.endConnectionFromOutputToFixed   (output, input, savedConnInput, backInit);
            }
            // if (   !isNaN(newReorderIndex)
            //     && !isNaN(oldReorderIndex)
            //     &&  newReorderIndex != oldReorderIndex
            //     &&  newReorderIndex >= 0
            //     &&  input.node.variableInputs
            //     && !input.param
            //     && !isLastInArray(input.node.headerInputs, input))
            // {
            //     console.log('1 reorder');
            //     actionManager.do(new ReorderInputsAction(input.node.id, oldReorderIndex, newReorderIndex));
            // }
            // else if (savedConnInput
            //       && savedConnInput.connectedOutput == this.tempConn.output
            //       && savedConnInput.index != input.index
            //       && savedConnInput.node.headerInputs.includes(savedConnInput) == savedConnInput.node.headerInputs.includes(input)
            //       && (  !input.node.variableInputs &&  input.index < input.node.inputs.length
            //           || input.node.variableInputs && (input.index < input.node.headerInputs.length-1 || input.index >= input.node.headerInputs.length)))
            // {
            //     console.log('2 reorder');
            //     // if (input.node.variableInputs)
            //     // {
            //     //     moveInArray(
            //     //         input.node.inputs,
            //     //         input.node.inputs.indexOf(savedConnInput),
            //     //         input.index);

            //     //     actionManager.do(new ReorderInputsAction(savedConnInput.node.id, oldReorderIndex, savedConnInput.index));
            //     // }
            //     // else
            //     // {
            //         actionManager.do(new ReorderInputConnectionsAction(savedConnInput.node.id, savedConnInput.id, input.id));
            //     // }
            // }
            // else if (input == savedConnInput
            //       && input.connection) // reconnect old
            // {
            //     console.log('3 reconnect');
            //     this.savedConn = null; // done here to redraw the saved wire correctly
            //     input.connection.wire.show(true);
            // }
            // else if (savedConnInput
            //       && input.node.variableInputs
            //       && savedConnInput.index >= input.node.headerInputs.length
            //       && input.index == input.node.headerInputs.length-1
            //       && input.isNew)
            // {
            //     // reconnect from below header to new variable new input
            //     console.log('4 reconnect');
            //     actionManager.do(new ReconnectAction(output, savedConnInput, input));
            // }
            // else if (savedConnInput
            //       && savedConnInput.connectedOutput == output
            //       && (  !input.node.variableInputs
            //           || input.index >= input.node.headerInputs.length
            //           || (   input.node.variableInputs
            //               && (      input.node.headerInputs.length > 1 
            //                      && input.index < input.node.headerInputs.length-1
            //                   ||    input.node.headerInputs.length == 1 
            //                      && input.index == 0))))
            // {
            //     console.log('5 reconnect');
            //     actionManager.do(new ReconnectAction(output, savedConnInput, input));
            // }
            // else if (   !savedConnInput
            //         && (  !input.connected
            //             || input.connectedOutput != this.tempConn.output)) // connect new
            // {
            //     console.log('6 createConnectAction');
            //     actionManager.do(new ConnectAction(output, input, {backInit: backInit}));
            // }
        }
        else if (savedConnInput)
            actionManager.do(new DisconnectAction(savedConnInput));
        

        if (this.savedConn) this.savedConn.wire.show(true);
        this.cancelConnection(pointerId);
    }
    
    else if (this.tempConn.input) // FROM INPUT
    {
        let input  = this.tempConn.input;
        let output = this.overOutput;

        input.connecting = false;

        if (   output
            && output.canConnectTo(input)) //input.canConnectFrom(output)) // TO OUTPUT
            actionManager.do(new ConnectAction(output, input, {backInit: backInit}));

        this.cancelConnection(pointerId);
    }
};



GraphView.prototype.endConnectionFromOutputToFixed = function(output, input, savedConnInput, backInit = false)
{
    if (   !savedConnInput
        && (  !input.connected
            || input.connectedOutput != this.tempConn.output))
    {
        //console.log('F1 connect new');
        actionManager.do(new ConnectAction(output, input, {backInit: backInit}));
    }
    else if (savedConnInput
          && savedConnInput.connectedOutput == output)
    {
        //console.log('F2 reconnect');
        actionManager.do(new ReconnectAction(output, savedConnInput, input));
    }
    // else if (savedConnInput
    //       && savedConnInput.connectedOutput == this.tempConn.output
    //       && savedConnInput.index != input.index
    //       && savedConnInput.node.inputs.includes(savedConnInput) == savedConnInput.node.inputs.includes(input))
    // {
    //     console.log('2 reorder');
    //     actionManager.do(new ReorderInputConnectionsAction(savedConnInput.node.id, savedConnInput.id, input.id));
    // }
};



GraphView.prototype.endConnectionFromOutputToVariable = function(output, input, savedConnInput, backInit = false)
{
    if (   !savedConnInput
        && (  !input.connected
            || input.connectedOutput != this.tempConn.output))
    {
        //console.log('V1 connect new');
        actionManager.do(new ConnectAction(output, input, {backInit: backInit}));
    }
    else if (savedConnInput
          && savedConnInput.connectedOutput == output
          && (   savedConnInput.node != input.node
              ||    savedConnInput.index < input.node.headerInputs.length-1
                 && input.index >= input.node.headerInputs.length
              ||    savedConnInput.index >= input.node.headerInputs.length 
                 && input.index < input.node.headerInputs.length-1))
    {
        // if (input.index <)
        //console.log('V2 reconnect');
        actionManager.do(new ReconnectAction(output, savedConnInput, input));
    }
};



GraphView.prototype.createTempConnSwap = function(oldInput, newInput)
{
    this.tempConnSwap = new Connection(oldInput.output, newInput);
    this.addConnWires(this.tempConnSwap, false);
    this.tempConnSwap.wire.update();
};



GraphView.prototype.deleteTempConnSwap = function(oldInput, newInput)
{
    this.removeConnWires(this.tempConnSwap);    
    this.tempConnSwap = null;
};


GraphView.prototype.addConnWires = function(conn, updateTransform = true)
{
    this.addWire(conn.wire, updateTransform);
};



GraphView.prototype.addWire = function(wire, updateTransform = true)
{
    this.wires.push(wire);
    this.wireContainer.appendChild(wire.svg);
};



GraphView.prototype.removeConnWires = function(conn)
{
    this.removeWire(conn.wire);
};



GraphView.prototype.removeWire = function(wire)
{
    if (this.wireContainer.contains(wire.svg))
        this.wireContainer.removeChild(wire.svg);    

    if (this.wires.includes(wire))
        removeFromArray(this.wires, wire);
};



GraphView.prototype.updateWires = function(_wires)
{
    //logFunction('GraphView.updateWires()');
    
    const wires = [..._wires];


    const nWires = wires.length;

    for (let i = 0; i < nWires; i++)
    {
        if (wires[i].connection.proxy)
            pushUnique(wires, wires[i].connection.proxy.wire);
    }


    const pOut    = [];
    const pIn     = [];
    
    const cw      = this.measureData.clientRect.width;
    const ch      = this.measureData.clientRect.height;
    
    const yOffset = getTopHeight() + 1;


    wires.forEach(w => 
    {
        const ro = boundingRect(w.connection.output.div);
        const ri = boundingRect(w.connection.input .div);

        pOut.push(point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset));
        pIn .push(point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset));
    });

       
    for (let i = 0; i < wires.length; i++)
    {
        const wire = wires[i];

        // the yOffset is to start wire coords just below the control bar,
        // not at the top of the window

        wire.updateCurve(pOut[i].x, pOut[i].y, pIn[i].x, pIn[i].y);

        if (wire.outBall) wire.updateOutBall(pOut[i].x, pOut[i].y);
        if (wire. inBall) wire.updateInBall (pIn [i].x, pIn [i].y);

        wire.updateStyle();

        wire.svg.setAttribute('width',  cw);
        wire.svg.setAttribute('height', ch);
    
        wire.svg.setAttribute('viewBox',
                    0
            + ' ' + 0
            + ' ' + cw
            + ' ' + ch);
    }
};


GraphView.prototype.createEvents = function()
{
    this.div.addEventListener('pointerenter', e => 
    {
        if (    this.div.hasPointerCapture(e.pointerId)
            && !this.tempConn)
            this.div.releasePointerCapture(e.pointerId);
    });



    this.div.addEventListener('pointerleave', e => 
    {
        if (this.tempConn)
            this.div.setPointerCapture(e.pointerId);
    });



    this.div.addEventListener('pointerdown', e =>
    {
        if (   e.button == 0
            && (   document.canResizeL
                || document.canResizeR
                || document.canResizeB))
        {
            e.stopPropagation();
            forwardEvent(e, document);
        }
    }, 
    true);



    this.div.addEventListener('pointerdown', e =>
    {
        this.pStart = point(e.clientX, e.clientY);

        const sx = e.clientX;
        const sy = e.clientY;

        if (   e.button == 0
            && !this.panning
            && !this.tempConn
            && !this.scrollbarX.moving
            && !this.scrollbarY.moving
            && !document.canResizeL
            && !document.canResizeR
            && !document.canResizeB)
        {
            if (   this.spaceDown
                || panMode)
            {
                if (getCtrlKey(e)) this.startZoomSelection(e.pointerId, e.clientX, e.clientY);
                else               this.startPan(e.pointerId);
            }
            else if (this.overOutput)
            {
                this.overOutput.connecting = true;
                this.startConnectionFromOutput(e.pointerId, this.overOutput, true, getCtrlKey(e));

                this.tempConn.wire.update(sx, sy);
            }
            else if (this.overInput)
            {
                if (this.overInput.connectedOutput) // begin to disconnect
                {
                    oldReorderIndex = this.overInput.index;

                    this.startConnectionFromOutput(e.pointerId, this.overInput.connectedOutput, false, getCtrlKey(e));

                    this.tempConn.wire.update(sx, sy);

                    this.savedConn = this.overInput.connection;
                    this.savedConn.wire.show(false);
                }
                else
                {
                    this.overInput.connecting = true;
                    this.startConnectionFromInput(e.pointerId, this.overInput, getCtrlKey(e));

                    this.tempConn.wire.update(sx, sy);
                }
            }
            else if (document.activeElement.type != 'text') // selection, unless a textbox is in focus
            {
                this.lastSelectedNodes = [...this.selectedNodes];

                this.startSelection(
                    e.pointerId,
                    e.clientX,
                    e.clientY,
                    e.shiftKey,
                    getCtrlKey(e));
            }
        }

        else if (e.button == 1)
        {
            e.preventDefault();
            
            this.btn1down = true;
            setCursor(panCursor);
            this.startPan(e.pointerId);
        }

        else if (e.button == 2)
        {
            e.stopPropagation();

            if (isEmpty(currentMenus)) menuGraph.showAt(e.clientX, e.clientY, false, false);
            else                       hideAllMenus();
        }
    });



    this.div.addEventListener('pointermove', graphView_onpointermove);



    // this.div.addEventListener('pointermove', e =>
    // {
    //     if (   document.canResizeL
    //         || document.canResizeR
    //         || document.canResizeB)
    //     {
    //         //checkResize(e.clientX, e.clientY);
    //         e.stopImmediatePropagation();
    //     }
    // },
    // true);



    this.div.addEventListener('pointerup', e => 
    {
        if (   e.button == 0
            && (   this.spaceDown
                || panMode))
        {
            if (getCtrlKey(e))
            {
                if (    this.selectionRect.w != 0
                    &&  this.selectionRect.h != 0
                    && !this.altDown)
                {
                    this.oldZoom = graph.currentPage.zoom;
                    this.endZoomSelection(e.pointerId, true);
                }
                else if (this.altDown)
                {
                    const wndRect = new Rect(
                        1,
                        getTopHeight() + 1,
                        this.measureData.clientRect.width  - 2,
                        this.measureData.clientRect.height - 5);

                    const selection = Rect.fromTypical(this.selectionRect);


                    this.oldZoom = graph.currentPage.zoom;
                    this.endZoomSelection(e.pointerId, false);

                    graph.currentPage.zoom /= 2;
                    
                    
                    graph.currentPage.pan.x += wndRect.c - selection.c;
                    graph.currentPage.pan.y += wndRect.m - selection.m;


                    this.updateNodes();
                }
                else
                this.endZoomSelection(e.pointerId, false);
            }

            this.endPan(e.pointerId, false);


            if (this.panZoomTimer)
            {
                clearTimeout(this.panZoomTimer); 
                this.panZoomTimer = null;
            };
        }

        else if (e.button == 0
            && !this.selectionRect.isNaN)
            this.endSelection(e.pointerId);

        else if (e.button == 0
            && this.tempConn)
            this.endConnection(e.pointerId, getCtrlKey(e));

        else if (e.button == 1
            && this.panning)
        {
            this.btn1down = false;
            this.endPan(e.pointerId, true);
        }
    });



    this.div.addEventListener('wheel', e =>
    {
        if (this.btn1down)
            return;


        // if button is not pressed wheel pans
        // if button is pressed, wheel does nothing if it's a touchpad

        e.preventDefault();


        const dZoom = Math.log(graph.currentPage.zoom) / Math.log(2);


        const touchpad = isTouchpad(e);

        const dWheelX = e.deltaX / (touchpad ? 20 : 100);
        const dWheelY = e.deltaY / (touchpad ? 20 : 100);


        if (   e.ctrlKey //getCtrlKey(e)
            ||     panMode
               && !touchpad)
        {
            let pos = point(
                e.clientX, 
                e.clientY - getTopHeight());

            const zoom = Math.max(0.0001, Math.pow(2, dZoom - dWheelY / (touchpad ? 4 : 10)));
            const pan  = subv(graph.currentPage.pan, mulvs(subv(pos, graph.currentPage.pan), zoom / graph.currentPage.zoom - 1));

            graph.currentPage.setPanAndZoom(pan, zoom);

            this.updateWheelTimer();
        }
        else
        {
            const dPanX = (e.shiftKey ? dWheelY : dWheelX) * 20 / Math.pow(graph.currentPage.zoom, 0.1);
            const dPanY = (e.shiftKey ? dWheelX : dWheelY) * 20 / Math.pow(graph.currentPage.zoom, 0.1);

            graph.currentPage.pan = point(
                graph.currentPage.pan.x - dPanX,
                graph.currentPage.pan.y - dPanY);

            
            if (this.selecting)
            {
                this.selectionRect.x -= dPanX;
                this.selectionRect.w += dPanX;

                this.selectionRect.y -= dPanY;
                this.selectionRect.h += dPanY;

                this.updateSelection(
                    e.clientX,
                    e.clientY,
                    e.shiftKey);
            } 


            this.updateWheelTimer();
        }


        if (this.tempConn)
            graphView_onpointermove(e);
    });



    this.div.addEventListener('gesturestart', e => { this.zoomStart = graph.currentPage.zoom; });



    this.div.addEventListener('gesturechange', e => 
    {
        const p = point(
            this.p.x,
            this.p.y - getTopHeight());

        const zoom = this.zoomStart * e.scale;
        const pan  = subv(graph.currentPage.pan, mulvs(subv(p, graph.currentPage.pan), zoom / graph.currentPage.zoom - 1));

        graph.currentPage.setPanAndZoom(pan, zoom);
    });



    this.div.addEventListener('touchstart', e =>
    {
        this.touches.push(e);
        e.preventDefault();
    });



    this.div.addEventListener('touchmove', e =>
    {
        for (let i = 0; i < this.touches.length; i++)
            if (this.touches[i].pointerId == e.pointerId)
            {
                this.touches[i] = e;
                break;
            }

        e.preventDefault();
    });



    this.div.addEventListener('touchend', e =>
    {
        for (let i = 0; i < this.touches.length; i++)
            if (this.touches[i].pointerId == e.pointerId)
            {
                this.touches.splice(i, 1);
                break;
            }

        e.preventDefault();
    });



    this.div.addEventListener('touchcancel', e =>
    {
        for (let i = 0; i < this.touches.length; i++)
            if (this.touches[i].pointerId == e.pointerId)
            {
                this.touches.splice(i, 1);
                break;
            }

        e.preventDefault();
    });
}



GraphView.prototype.updateWheelTimer = function()
{
    if (this.wheelTimer) 
        clearTimeout(this.wheelTimer);

    this.wheelTimer = setTimeout(() => 
    {
        this.wheelTimer = null;

        if (overNumberControl)
            overNumberControl.updateCursor();

        setAutoCursor();

        graph.updateSavedPages();
    }, 
    450);
};



function graphView_onpointermove(e)
{
    graphView.p = point(e.clientX, e.clientY);


    if (   (   graphView.panning
            || panMode)
        && graphView.div.hasPointerCapture(e.pointerId))
    {
        setCursor(panCursor);

        const dp = subv(graphView.p, graphView.pStart);

        graph.currentPage.setPanAndZoom(
            addv(graphView.panStart, dp), 
            graph.currentPage.zoom);
    }

    else if (graphView.selecting)
        graphView.updateSelection(e.clientX, e.clientY, e.shiftKey, getCtrlKey(e));

    else if (graphView.zoomSelecting)
        graphView.updateZoomSelection(e.clientX, e.clientY);

    else if (graphView.tempConn)
        graphView.tempConn.wire.update(e.clientX, e.clientY);
}


GraphView.prototype.updatePanAndZoom = function(updateNodes)
{
    this.updateNodes(graph.pageNodes, updateNodes);

    
    setTimeout(() =>
    {
        updateZoomTooltip();
        updateZoomIcon();

        menuItemZoomTo100.setChecked(equal(graph.currentPage.zoom, 1, 0.0001));
    });


    //console.log('pan = %s, zoom = %s', graph.currentPage.pan.x + ', ' + graph.currentPage.pan.y, graph.currentPage.zoom);
};



GraphView.prototype.startPan = function(pointerId)
{
    this.div.setPointerCapture(pointerId);

    this.panning  = true;
    this.panStart = graph.currentPage.pan;

    setCursor(panCursor);
};



GraphView.prototype.endPan = function(pointerId, changeCursor)
{
    this.panning = false;

    this.div.releasePointerCapture(pointerId);

    if (changeCursor)
        setAutoCursor();

    graph.updateSavedPages();
};



GraphView.prototype.isPanning = function(e)
{
    if (panMode)
    {
        e.preventDefault();
        setCursor(panCursor);
        return true;
    }

    if (this.spaceDown)
    {
        e.preventDefault();
        return true;
    }

    return false;
};


GraphView.prototype.startZoomSelection = function(pointerId, x, y)
{
    this.div.setPointerCapture(pointerId);

    this.zoomSelecting = true;
    this.selectionRect = new Rect(x, y, 0, 0);
    
    selectBox.style.visibility = 'visible';
    
    this.updateZoomSelectBox();
};



GraphView.prototype.updateZoomSelection = function(x, y)
{
    if (!this.zoomSelecting) return;

    this.selectionRect.w = x - this.selectionRect.x;
    this.selectionRect.h = y - this.selectionRect.y;

    this.updateZoomSelectBox();
};



GraphView.prototype.updateZoomSelectBox = function()
{
    const selection = Rect.fromTypical(this.selectionRect);

    selectBox.style.left   = selection.x + Math.min(selection.w, 0);
    selectBox.style.top    = selection.y + Math.min(selection.h, 0);
    selectBox.style.width  = Math.abs(selection.w);
    selectBox.style.height = Math.abs(selection.h);

    selectBox.style.zIndex = MAX_INT32-3;
};



GraphView.prototype.endZoomSelection = function(pointerId, zoom)
{
    if (zoom)
    {
        this.oldZoom = graph.currentPage.zoom;


        const wndRect = new Rect(
            1,
            getTopHeight() + 1,
            this.measureData.clientRect.width  - 2,
            this.measureData.clientRect.height - 5);
    
        let selection = validateRect(this.selectionRect);
        selection = clipRect(selection, wndRect);
    
        selection.y -= getTopHeight();

        
        const rect = this.screen2rect(selection);

        for (let i = 0; i < 5; i++)
            this.zoomToRect(rect, 0);
    }


    this.selectionRect = Rect.NaN;


    this.div.releasePointerCapture(pointerId);

    this.zoomSelecting    = false;
    selectBox.style.visibility = 'hidden';


    graph.updateSavedPages();
};



GraphView.prototype.zoomToFit = function()
{
    if (!isEmpty(graph.pageNodes))
        this.zoomToNodes(graph.pageNodes);
    else
        graph.currentPage.setPanAndZoom(point(0, 0), 1);
};



GraphView.prototype.zoomToSelection = function()
{
    if (!isEmpty(this.selectedNodes)) 
        this.zoomToNodes(this.selectedNodes);
};



GraphView.prototype.zoomToNodes = function(nodes)
{
    if (!isEmpty(nodes))
    {
        nodes.forEach(n => n.updateMeasureData());
        const offset = this.getAllNodeOffsets(nodes);

        for (let i = 0; i < 5; i++) // need to do it a few times
            this.zoomToRect(offset);
    }
};



GraphView.prototype.zoomToRect = function(rect, margin = 40)
{
    const viewRect   = this.measureData.clientRect;

    const viewAspect = viewRect.width / viewRect.height;
    const rectAspect = rect.width     / rect.height;


    graph.currentPage.zoom = 
        viewRect.width >= viewRect.height
    
        ? (   rect.width >= rect.height
           && rectAspect > viewAspect
           ? (viewRect.width  - margin*2) / rect.width  
           : (viewRect.height - margin*2) / rect.height)
    
        : (   rect.width <  rect.height
           && rectAspect <= viewAspect
           ? (viewRect.height - margin*2) / rect.height 
           : (viewRect.width  - margin*2) / rect.width );


    graph.currentPage.pan = 
    {
        x: viewRect.width /2 - (rect.x + rect.width /2) * graph.currentPage.zoom,
        y: viewRect.height/2 - (rect.y + rect.height/2) * graph.currentPage.zoom
    };

    
    graph.updateSavedPages();
};



function updateZoomIcon()
{
    if (settings.dataMode)
        return;


    btnZoom.divIcon.innerHTML       =  Math.round(graph.currentPage.zoom * 100) + '%';
    btnZoom.divIcon.style.transform = 'translateX(2px) translateY(-15px)';


    if (   graph.currentPage.zoom < settings.minZoomForParams
        && graph.currentPage.zoom < 1)
    {
        zoomIconOverlay.style.left       = '14px';
        zoomIconOverlay.style.top        = '11px';
        zoomIconOverlay.style.width      = '28';
        zoomIconOverlay.style.background = 'url(\'data:image/svg+xml;utf8,<svg width="28" height="20" viewBox="0 0 28 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 0.5H24C25.933 0.5 27.5 2.067 27.5 4V19.5H0.5V4C0.5 2.067 2.067 0.5 4 0.5Z" stroke="white"/></svg>\')';
    }
    else if (graph.currentPage.zoom < settings.minZoomForParams
          && graph.currentPage.zoom < 10)
    {
        zoomIconOverlay.style.left       = '12px';
        zoomIconOverlay.style.top        = '11px';
        zoomIconOverlay.style.width      = '33';
        zoomIconOverlay.style.background = 'url(\'data:image/svg+xml;utf8,<svg width="33" height="20" viewBox="0 0 33 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 0.5H29C30.933 0.5 32.5 2.067 32.5 4V19.5H0.5V4C0.5 2.067 2.067 0.5 4 0.5Z" stroke="white"/></svg>\')';
    }
    else
        zoomIconOverlay.style.background = 'none';


    zoomIconOverlay.style.backgroundPosition = '50% 50%';
    zoomIconOverlay.style.backgroundRepeat   = 'no-repeat';
    zoomIconOverlay.style.backgroundColor    = 'transparent';
}


GraphView.prototype.deselectAll = function()
{
    for (const node of this._selectedNodes)            
        node.setSelected(false);

    this._selectedNodes = [];
};



GraphView.prototype.selectByIds = function(nodeIds)
{
    this.selectedNodes = nodeIds.map(id => nodeFromId(id));
};



GraphView.prototype.startSelection = function(pointerId, x, y, shiftKey, ctrlKey)
{
    this.div.setPointerCapture(pointerId);

    this.selecting = true;

    this.selectionRect = new Rect(x, y, 0, 0);
    this._prevSelectedNodes = [];
   
    selectBox.style.visibility = 'visible';

    this.updateSelectBox(shiftKey, ctrlKey);
};



GraphView.prototype.updateSelection = function(x, y, shiftKey, ctrlKey)
{
    if (!this.selecting) return;

    this.selectionRect.w = x - this.selectionRect.x;
    this.selectionRect.h = y - this.selectionRect.y;

    setTimeout(() => this.updateSelectBox(shiftKey, ctrlKey));
};

 

GraphView.prototype.updateSelectBox = function(shiftKey, ctrlKey)
{
    if (   isNaN(this.selectionRect.w)
        || isNaN(this.selectionRect.h))
        return;


    const wndRect = new Rect(
        1,
        getTopHeight() + 1,
        this.measureData.clientRect.width  - 2,
        this.measureData.clientRect.height - 5);


    let selection = clipRect(
        validateRect(this.selectionRect), 
        wndRect);
    

    if (!selection.isNaN)
    {
        selectBox.style.left    = selection.x;
        selectBox.style.top     = selection.y;
        selectBox.style.width   = selection.width;
        selectBox.style.height  = selection.height;

        selectBox.style.display = 'block';
        selectBox.style.zIndex  = MAX_INT32-3;


        const selected = [];

        for (const node of graph.pageNodes)
        {
            if (rectsIntersect(
                    node.measureData.divBounds,
                    selection))
                selected.push(node);
        }


        if (shiftKey)
            this.selectedNodes = this.lastSelectedNodes
                .filter(n => !selected.includes(n))
                .concat(selected.filter(n => !this.lastSelectedNodes.includes(n)));
        else
            this.selectedNodes = selected;
        
            
        selectBox.style.zIndex = MAX_INT32-3;
            
            
        const nodes = [
            ...selected,                    
            ...this._prevSelectedNodes,
            ...this.lastSelectedNodes];

        nodes.forEach(n => n.updateBorder());
        updateComments(nodes.map(n => n.id));

        this._prevSelectedNodes = selected;
    }
    else
    {
        selectBox.style.display = 'none';
    }
};



GraphView.prototype.endSelection = function(pointerId)
{
    if (   !isEmpty(this.selectedNodes    )
        || !isEmpty(this.lastSelectedNodes))
    {
        actionManager.do(new SelectNodesAction(
            this.selectedNodes    .map(n => n.id), 
            this.lastSelectedNodes.map(n => n.id)));
    }


    this.div.releasePointerCapture(pointerId);

    this.selecting     = false;
    this.selectionRect = Rect.NaN;
    this._prevSelectedNodes = [];

    selectBox.style.visibility = 'hidden';


    this.selectionRect.w = Number.NaN;
    this.selectionRect.h = Number.NaN;
};



GraphView.prototype.selectFromClick = function(node, ctrl, shift, alt)
{
    node.div.moved = false;


    const nodes = [node];

    // if (node.type == GROUP_NODE)
    //     pushUnique(nodes, node.children);

    if (   ctrl
        && shift
        && alt)
    {
        this.selectedNodes = getAllNodesFromNode(node);
    }
    else if (shift
          && alt)
    {
        if (isMac) this.selectedNodes = [node, ...getNodesBeforeNode(node)];
        else       this.selectedNodes = [node, ...getNodesAfterNode(node)];
    }
    else if (ctrl
          && shift)
    {
        if (isMac) this.selectedNodes = [node, ...getNodesAfterNode(node)];
        else       this.selectedNodes = [node, ...getNodesBeforeNode(node)];
    }
    else if (ctrl
          && alt)
        this.selectedNodes = [node, ...getNodesAcrossNode(node)];

    else if (!node.selected)
    {
        if (shift) node.selected      = true;
        else       this.selectedNodes = [node];
    }
    else if (node.selected)
    {
        if (shift) node.selected = false;
    }
}


GraphView.prototype.updateScrollWithBounds = function()
{
    const bounds = this.getAllNodeBounds();

    this.updateScroll(
        this.div.clientLeft,
        this.div.clientWidth,
        this.div.clientHeight,
        bounds,
        getTopHeight());
};



GraphView.prototype.updateScroll = function(x, w, h, bounds, yOffset)
{
    this.updateScrollX(   w, h, bounds);
    this.updateScrollY(x, w, h, bounds, yOffset);

    this.scrollbarX.style.zIndex = MAX_INT32-1;
    this.scrollbarY.style.zIndex = MAX_INT32-2;
};



GraphView.prototype.updateScrollX = function(w, h, bounds)
{
    if (   bounds.l < 0
        && bounds.r >= w)
    {
        const width = sqr(w) / bounds.width - (smallScrollGap + largeScrollGap);

        this.scrollbarX.style.display = 'inline-block';
        this.scrollbarX.style.width   =  width;
        this.scrollbarX.style.left    =  smallScrollGap + (w - smallScrollGap - largeScrollGap - width) * -bounds.l / (-bounds.l + bounds.r - w);
        this.scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else if (bounds.l < 0)
    {
        const width = sqr(w) / (w - bounds.l) - (smallScrollGap + largeScrollGap);

        this.scrollbarX.style.display = 'inline-block';
        this.scrollbarX.style.width   =  width;
        this.scrollbarX.style.left    =  w - largeScrollGap - width;
        this.scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else if (bounds.r >= w)
    {
        const width = sqr(w) / bounds.r - (smallScrollGap + largeScrollGap);

        this.scrollbarX.style.display = 'inline-block';
        this.scrollbarX.style.width   =  width;
        this.scrollbarX.style.left    =  smallScrollGap;
        this.scrollbarX.style.top     =  h - smallScrollGap - 6;
    }
    else
        this.scrollbarX.style.display = 'none';
};



GraphView.prototype.updateScrollY = function(x, w, h, bounds, yOffset)
{
    if (   bounds.t <  yOffset
        && bounds.b >= h + yOffset)
    {
        const height = sqr(h) / bounds.height - (smallScrollGap + largeScrollGap);

        this.scrollbarY.style.display = 'inline-block';
        this.scrollbarY.style.height  =  height;
        this.scrollbarY.style.top     =  smallScrollGap + (h - height + smallScrollGap) * (yOffset - bounds.t) / (yOffset - bounds.t + bounds.b - h);
        this.scrollbarY.style.left    =  x + w - smallScrollGap - 6;
    }
    else if (bounds.t < yOffset)
    {
        const height = sqr(h) / (h - (bounds.t - yOffset)) - (smallScrollGap + largeScrollGap);

        this.scrollbarY.style.display = 'inline-block';
        this.scrollbarY.style.height  = height;
        this.scrollbarY.style.top     = h - largeScrollGap - height;
        this.scrollbarY.style.left    = x + w - smallScrollGap - 6;
    }
    else if (bounds.b >= h + yOffset)
    {
        const height = sqr(h) / (bounds.b - yOffset) - (smallScrollGap + largeScrollGap);

        this.scrollbarY.style.display = 'inline-block';
        this.scrollbarY.style.height  = height;
        this.scrollbarY.style.top     = smallScrollGap;
        this.scrollbarY.style.left    = x + w - smallScrollGap - 6;
    }
    else
        this.scrollbarY.style.display = 'none';
};



GraphView.prototype.createScrollbarMethods = function()
{
    this.scrollbarX.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            this.scrollbarX.moving = true;
            this.scrollbarX.xStart = this.scrollbarX.offsetLeft;
            this.scrollbarX.wStart = this.scrollbarX.offsetWidth;
            this.scrollbarX.pStart = e.clientX;
            this.scrollbarX.setPointerCapture(e.pointerId);

            this.panStart = graph.currentPage.pan;

            for (const node of graph.pageNodes)
                node.slx = node.div.offsetLeft;
        }
    });



    this.scrollbarX.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && this.scrollbarX.moving)
        {
            this.scrollbarX.moving = false;
            this.scrollbarX.releasePointerCapture(e.pointerId);

            let bounds = Rect.NaN;

            for (const node of graph.pageNodes)
                bounds = expandRect(bounds, boundingRect(node.div));

            if (bounds.l >= 0 && bounds.r < this.clientWidth)
                this.scrollbarX.style.display = 'none';
        }
    });



    this.scrollbarX.addEventListener('pointermove', e =>
    {
        if (this.scrollbarX.moving)
        {
            const x = this.scrollbarX.xStart + e.clientX - this.scrollbarX.pStart;

            let l = x;
            let r = l + this.scrollbarX.wStart;
 
            l = Math.max(smallScrollGap, l);
            r = Math.min(r, this.div.clientWidth - largeScrollGap);
 
            l = Math.max(smallScrollGap, Math.min(l, r - smallScrollGap));
            r = Math.max(l + smallScrollGap, r);
 
            this.scrollbarX.style.left  = l;
            this.scrollbarX.style.width = r-l;

            graph.currentPage.pan = point(
                this.panStart.x - (e.clientX - this.scrollbarX.pStart) / this.scrollbarX.wStart * this.div.clientWidth,
                this.panStart.y);
        }
    });



    /////////////////////////////////////////////////////////////////////////////////////



    this.scrollbarY.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            this.scrollbarY.moving = true;
            this.scrollbarY.yStart = this.scrollbarY.offsetTop;
            this.scrollbarY.hStart = this.scrollbarY.offsetHeight;
            this.scrollbarY.pStart = e.clientY;
            this.scrollbarY.setPointerCapture(e.pointerId);

            for (const node of graph.pageNodes)
                node.div.sly = node.div.offsetTop;

            this.panStart = graph.currentPage.pan;
        }
    });



    this.scrollbarY.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && this.scrollbarY.moving)
        {
            this.scrollbarY.moving = false;
            this.scrollbarY.releasePointerCapture(e.pointerId);

            let bounds = Rect.NaN;

            for (const node of graph.pageNodes)
                bounds = expandRect(bounds, boundingRect(node.div));

            if (bounds.t >= 0 && bounds.b < this.div.clientHeight)
                this.scrollbarY.style.display = 'none';
        }
    });



    this.scrollbarY.addEventListener('pointermove', e =>
    {
        if (this.scrollbarY.moving)
        {
            const y = this.scrollbarY.yStart + e.clientY - this.scrollbarY.pStart;

            let   t = y;
            let   b = t + this.scrollbarY.hStart;

            t = Math.max(smallScrollGap, t);
            b = Math.min(b, this.div.clientHeight - largeScrollGap);

            t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
            b = Math.max(t + smallScrollGap, b);

            this.scrollbarY.style.top    = t;
            this.scrollbarY.style.height = b-t;

            graph.currentPage.pan = point(
                this.panStart.x, 
                this.panStart.y - (e.clientY - this.scrollbarY.pStart) / this.scrollbarY.hStart * this.div.clientHeight);
        }
    });
}


const defParamHeight = 22;



class Parameter
extends EventTarget
{
    #type;     get type()    { return this.#type;    }
    _id;       get id()      { return this._id;      }
    #name;     get name()    { return this.#name;    }
    _node;     get node()    { return this._node;    }
    _div;      get div()     { return this._div;     }


    get index() { return this.node.params.indexOf(this); }


    controls       = [];

    proxy          = null;


    input;
    output;

    
    onbeforechange = new Event('beforechange');
    onchange       = new Event('change');
    onconfirm      = new Event('confirm');
    onchangelock   = new Event('changelock');


    changing       = false;

    volatile       = false;
    noUpdate       = false;
 
    affectsHeader  = true; // indicates whether the parameter contributes to the header's result data

    isResult       = false;
    //managing       = false; // undoing or redoing


    canShow = () => true;



    constructor(type, id, name)
    {
        super();

        this._id                = id;
        this.#name              = name;
        this.#type              = type;

        this._div               = createDiv();

        this.div.style.position = 'relative';
        this.div.style.padding  = 0;
        this.div.style.width    = '100%';

        this.input              = null;
        this.output             = null;
    }



    setName(name, dispatchEvents = true)
    {
        this.#name = name; 
        this.update(dispatchEvents);
    }



    initInput(types, getNodeInputValuesForUndo = null, getBackInitValue = null)
    {
        this.input = new Input(types, getNodeInputValuesForUndo, getBackInitValue);

        this.input._param              = this;

        this.input.div.style.float     = 'left';
        this.input.div.style.position  = 'absolute';
        this.input.div.style.top       = '50%';
        this.input.div.style.transform = 'translateY(-50%)';

        this.input.colorLight          = [0, 0, 0, 0.12];
        this.input.colorDark           = [1, 1, 1, 0.12];
        this.input.overFactor          = 3;

        this.input.canAutoConnect      = false;
        
        this.div.appendChild(this.input.div);

        this.input.addEventListener('connect',    () => this.enableControlText(false));
        this.input.addEventListener('disconnect', () => this.enableControlText(true ));
    }



    initOutput(types, toString, getNodeOutputValuesForUndo = null, backInit = null)
    {
        this.output = new Output(types, toString, getNodeOutputValuesForUndo, backInit);

        this.output._param              = this;

        this.output.div.style.float     = 'right';
        this.output.div.style.position  = 'absolute';
        this.output.div.style.top       = '50%';
        this.output.div.style.transform = 'translateY(-50%)';
        
        this.output.colorLight          = [0, 0, 0, 0.12];
        this.output.colorDark           = [1, 1, 1, 0.12];
        this.output.overFactor          = 3;

        this.div.appendChild(this.output.div);
    }



    isDefault = () => false;


    
    isVisible()
    {
        return true;
    }



    resetControls()
    {
        
    }



    getValueForUndo()
    {
        return {
            paramId: this.id, 
            value:   this.value
        };    
    }    



    update(dispatchEvents)
    {

    }    



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);

        this.controls[0].update();
        
        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    preSetValue(value, createAction, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (!value.equals(this.oldValue))
                this.dispatchEvent(this.onbeforechange);
        }
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (dispatchEvents)
        {
            if (   !this.oldValue
                || !value.equals(this.oldValue))
            {
                this.dispatchEvent(this.onchange);
                
                if (createAction)
                {
                    actionManager.do(
                        new SetParamValueAction(this, value), 
                          !isEmpty(actionManager.actions)
                        && actionManager.actions.at(-1).type == SET_PARAM_VALUE_ACTION
                        && this.changing);

                    this.dispatchEvent(this.onconfirm);
                }
            }
        }


        // if (this.proxy) 
        //     this.proxy.updateControls();
    }



    updateSetting(setting, value)
    {

    }



    textboxHasFocus()
    {
        return false;
    }



    enableControlText(enable)
    {

    }
    
    
    
    toString()
    {
        return this.value.toString();
    }



    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        return pos + '["' + this.type  + '", "' + id  + '", "' + this.value.toJson() + '"]';
    }



    loadParam(_param)
    {
        
    }



    toJsCode(gen)
    {
        return '';
    }
}



function setParamValue(param, value, updateParamId = '')
{
    if (param.id != updateParamId)
        param.setValue(value, false, true, false);
}



function checkControlVisible(param, control)
{
    control.div.style.display = 
          !param.isResult
        || settings.showOperationResults
        ? 'inline-block'
        : 'none';
}



function createParamFromType(type, options = {})
{
    const id        = options.id        != undefined ? options.id        : 'value';
    const name      = options.name      != undefined ? options.name      : '';
    const showName  = options.showName  != undefined ? options.showName  : false;
    const hasInput  = options.hasInput  != undefined ? options.hasInput  : false;
    const hasOutput = options.hasOutput != undefined ? options.hasOutput : false;

         if (NUMBER_TYPES.includes(type)) return new NumberParam(id, name, showName, hasInput, hasOutput);
    else if (  TEXT_TYPES.includes(type)) return new   TextParam(id, name,           hasInput, hasOutput);
    else if ( COLOR_TYPES.includes(type)) return new  ColorParam(id, name, showName, hasInput, hasOutput);
    else if (  FILL_TYPES.includes(type)) return new   FillParam(id, name, showName, hasInput, hasOutput);
    else if (STROKE_TYPES.includes(type)) return new StrokeParam(id, name, showName, hasInput, hasOutput);
    else if (  LIST_TYPES.includes(type)) return new   ListParam(id, name, showName, hasInput, hasOutput);
}


class   NumberParamBase
extends Parameter
{
    showFullPrecision = false;

    
    
    get value() 
    { 
        return new NumberValue(
            this.controls[0].value, 
            this.controls[0].displayDec); 
    }

    oldValue = null;


    defaultValue;
    alwaysSaveValue = false;


    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }


    
    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        console.assert(
            value instanceof NumberValue,
            'value must be a NumberValue');


        this.preSetValue(value, createAction, dispatchEvents);

        
        if (updateControl)
        {
            this.controls[0].setDecimals(value.decimals, value.decimals);
            this.controls[0].setValue(value.value, false, false); 
        }


        super.setValue(value, createAction, updateControl, dispatchEvents);

        
        this.oldValue = this.value.copy();
    }    



    showValue(show)
    {
        this.controls[0].showValue = show;
        this.controls[0].update();
    }



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    resetControls()
    {
        this.controls[0].valueText = '';
    }



    getValueForUndo()
    {
        return {
            paramId:    this.id, 
            value:      this.value,
            min:        this.controls[0].min,
            max:        this.controls[0].max,
            displayMin: this.controls[0].displayMin,
            displayMax: this.controls[0].displayMax
        };
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;

            
        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else if (this.output
              && this.output.paramNode
              && this.output.paramNode.inputs[0].connected)
        {
            request.push(...pushInputOrParam(this.output.paramNode.inputs[0], gen));
            //request.push(...this.output.paramNode.inputs[0].connectedOutput.genRequest(gen));
        }

        else request.push(
            NUMBER_VALUE, 
            new NumberValue(
                this.controls[0].value, 
                this.controls[0].displayDec).toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    textboxHasFocus()
    {
        return hasFocus(this.controls[0].textbox);
    }



    enableControlText(enable)
    {
        enable &= 
               !this.input 
            || !this.input.connected;
            
        enableElementText(this.controls[0].div, enable);

        this.controls[0].readOnly = !enable;

        this.updateValueText();
    }
    
    
    
    updateValueText()
    {
        let unknown = false;

        if (   this.input
            && this.input.connected)
        {
            if (   this.input.isConnectedUncached()
                && this.node.hasMultipliedOutputs())
                unknown = true;
        }


        if (unknown)
            this.controls[0].valueText = UNKNOWN_DISPLAY;

        this.controls[0].showBar = !unknown;
    }



    isDefault = () => 
           !this.alwaysSaveValue
         && this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseNumberValue(_param[2])[0], true, true, false);
    }



    toJsCode(gen)
    {
        return this.input.connected
             ? '(' + this.input.connectedOutput.toJsCode(gen) + ')'
             : this.value.toJsCode(gen);
    }
}


class   NumberParam
extends NumberParamBase
{
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = 0, 
                min          = Number.MIN_SAFE_INTEGER, 
                max          = Number.MAX_SAFE_INTEGER,
                decimals     = 0,
                dragScale    = 0.05)
    {
        super(NUMBER_VALUE, id, name);

        
        this.controls[0] = new NumberControl(
            createDiv('numberControl'),
            this,
            this.id,
            this.name, 
            showName,
            defaultValue,
            min,
            max,
            decimals,   
            dragScale); 

            
        this.controls[0].div.zIndex        = 0;

        this.controls[0].div.style.display = 'inline-block';
        this.controls[0].div.style.width   = '100%';

   
        this.defaultValue = new NumberValue(defaultValue, decimals);


        this.controls[0].successOnFocusOut = true;

        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput(NUMBER_TYPES, getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([NUMBER_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('change', () => 
        { 
            this.setValue(this.value, true, false);
            this.changing = true;
        });


        this.controls[0].addEventListener('confirm', () => 
        { 
            this.changing = false;
        });


        this.controls[0].addEventListener('finishedit', e =>
        { 
            let   dec    = decCount(e.detail.valueString); 
            const oldDec = decCount(e.detail.oldValueString);

            
            if (!e.detail.success)
                return;


            if (   Math.abs(e.detail.value - e.detail.oldValue) > Number.EPSILON
                && dec >= oldDec)
            {
                this.setValue(new NumberValue(e.detail.value, dec), true);
                e.preventSetValue = true;
            }
            else if (this.controls[0].allowEditDecimals)
            {
                if (Math.abs(e.detail.value - e.detail.oldValue) <= Number.EPSILON)
                    dec += Math.log10(this.controls[0].valueScale);
                else
                    dec = oldDec;

                this.setValue(new NumberValue(e.detail.value, dec), true);
                e.preventSetValue = true;
            }
        });



        createTooltipSrc(this.controls[0].div, this.controls[0].div, () => 
        {
            this.controls[0].addEventListener('change', () => 
            {
                const tooltip = this.getTooltip();
                if (tooltip) hideTooltip(tooltip);
            });
            
            return this.getTooltip();
        });
    }



    getTooltip = () => null;


    
    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == NUMBER_VALUE, 'expected NUMBER_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }
}


class   SelectParam
extends NumberParamBase
{
    options          = [];
    excludeFromMenu  = []; // indices
    separatorsBefore = [];
    
    
    reverseMenu     = false;



    constructor(id,
                name,
                showName,
                hasInput,
                hasOutput,
                options,
                defaultValue = 0)
    {
        super(NUMBER_VALUE, id, name);

        this.controls[0] = new NumberControl(
            createDiv(),
            this,
            this.id,
            this.name, 
            showName,
            defaultValue,
            0,
            options.length-1,
            0,   // decimals
            0.02);


        this.controls[0].div.zIndex = 0;


        this.controls[0].div.style.display = 'inline-block';
        this.controls[0].div.style.width   = '100%';

       
        this.defaultValue = new NumberValue(defaultValue);


        this.setOptions(options);

        this.controls[0].allowEditDecimals = false;

        this.controls[0].successOnFocusOut = true;
        this.controls[0].barTop            = 0.8;

        this.div.appendChild(this.controls[0].div);


        if (hasInput)  this.initInput(NUMBER_TYPES, getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([NUMBER_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('change', () => 
        { 
            this.setValue(this.value, true, false, true);
            this.changing = true;
        });
            
        this.controls[0].addEventListener('confirm', () => 
        { 
            this.setValue(this.value, true, true); 
            this.changing = false;
        });


        // this.tooltip = createDiv('tooltip');
        // document.body.appendChild(this.tooltip);

        //createTooltip(this.tooltip);

        createTooltipSrc(this.controls[0].div, this.controls[0].div, () => 
        {
            const tooltip = this.getTooltip();

            if (tooltip)
                this.initTooltip(tooltip, this.options);

            this.controls[0].addEventListener('change', () => 
            {
                if (tooltip) hideTooltip(tooltip);
            });

            return this.getTooltip();
        });
    }



    initTooltip = (tooltip, options) =>
    {
        // let strOptions = '';

        // for (const option of options)
        // {
        //     if (strOptions != '') strOptions += ', ';
        //     strOptions += option;
        // }

        // tooltip.innerHTML = strOptions;
    };


    
    getTooltip = () => null;//this.tooltip;



    setOptions(options)
    {
        this            .options = [...options];
        this.controls[0].options = [...options];
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == NUMBER_VALUE, 'expected NUMBER_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    toString()
    {
        return this.input
            && this.input.connected 

            ? [ ...pushInputOrParam(this.input, createGenObject()) ]

            : [ NUMBER_VALUE, 
                this.value.toString(), 
                this.controls[0].displayDec.toString() ];
    }
}



function initSelectParamMenu(param)
{
    menuSelectParam.clearItems();


    const s = !param.reverseMenu ? 0 : param.controls[0].displayMax;
    const c = !param.reverseMenu ? i => i <= param.controls[0].displayMax : i => i >= 0;
    const d = !param.reverseMenu ? 1 : -1;


    for (let i = s; c(i); i += d)
    {
        const option = param.options[i];
        
        if (param.excludeFromMenu.includes(i))
            continue;


        if (param.separatorsBefore.includes(i))
            menuSelectParam.addItems([new MenuItem(option, {separator: true})]);
        

        const options = { callback: () => param.setValue(new NumberValue(i), true) };

        if (param.controls[0].readOnly)
            options.enabled = false;

            
        const item = new MenuItem(
            option.replaceAll('/', '/'), 
            options);

        item.setChecked(i == param.value.toNumber());

        menuSelectParam.addItems([item]);
    }


    menuSelectParam.minWidth = 120;
}



class   TextParam
extends Parameter
{
    defaultValue;

    oldValue = null;

    
    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }

    
    get value() { return new TextValue(this.controls[0].value); }
    

    
    constructor(id,
                name, 
                hasInput,
                hasOutput,
                defaultValue = '')
    {
        super(TEXT_VALUE, id, name);

        this.defaultValue = defaultValue;


        this.controls[0] = new TextControl(
            null,
            this,
            this.id,
            this.name,
            defaultValue);

        if (name != NULL)
            this.controls[0].textbox.defPlaceholder =
            this.controls[0].textbox.placeholder    = name;
        

        this.controls[0].successOnFocusOut = true;
        this.controls[0].div.zIndex        = 0;

        this.controls[0].div.style.display = 'inline-block';
        this.controls[0].div.style.width   = '100%';


        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput(TEXT_TYPES, getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([TEXT_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('change', () => 
        { 
            this.setValue(this.value, true, false);
            //this.changing = true;
        });
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == TEXT_VALUE, 'expected TEXT_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    isDefault = () => this.value == this.defaultValue;



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        // console.log('TextParam.setValue value =', value);

        if (   !value.type 
            || !value.type == TEXT_VALUE)
        { 
            console.assert(false, 'value.type must be TEXT_VALUE');
            console.trace();
        }


        this.preSetValue(value, createAction, dispatchEvents);


        this.controls[0].value = value.value;

        if (updateControl)
            this.controls[0].setValue(value.value, false);


        super.setValue(value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    updateSetting(setting, value)
    {
        if (setting == 'align')
            this.controls[0].textbox.style.textAlign = value;
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else request.push( 
            TEXT_VALUE, 
            encodeURIComponent(this.controls[0].value.toString()));


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    enableControlText(enable)
    {
        enable &= 
               !this.input 
            || !this.input.connected;

        enableElementText(this.controls[0].textbox, enable);
        
        this.controls[0].textbox.disabled = !enable;
        this.controls[0].readOnly = !enable;
    }
    
    
    
    toJson(nTab = 0, id = '')
    {
        let pos = ' '.repeat(nTab);
        
        if (id == '')
            id = this.id;

        const value = encodeURIComponent(this.value.toString());


        return pos 
            + '["' 
                + this.type  + '", "' 
                + id         + '", "' 
                + value      + '", "' 
                + this.controls[0].getTextAlignment()
            + '"]';
    }



    loadParam(_param)
    {
        this.setValue(parseTextValue(decodeURIComponent(_param[2]))[0], true, false, false);

        if (_param.length >= 4) // legacy
        {
            switch (_param[3])
            {
            case '':
            case 'start':
            case 'left':    this.controls[0].textbox.style.textAlign = 'left';    break;
            case 'center':  this.controls[0].textbox.style.textAlign = 'center';  break;
            case 'right':   this.controls[0].textbox.style.textAlign = 'right';   break; 
            case 'justify': this.controls[0].textbox.style.textAlign = 'justify'; break;
            }
        }
    }
}


class   ColorParam
extends Parameter
{
    defaultValue;

    oldValue = null;

    
    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;


    showColorBack    = true;

    checkers;
    

    
    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }

    
    get value() { return this.controls[0].value; }
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = ColorValue.fromRgb([0x80, 0x80, 0x80]),
                dragScale    = 0.05)
    {
        super(COLOR_VALUE, id, name);

        this.defaultValue = defaultValue;


        this.controls[0] = new ColorControl(
            null,
            this,
            this.id,
            this.name, 
            showName,
            defaultValue,   
            dragScale); 

        this.controls[0].successOnFocusOut = true;
        //this.controls[0].div.style.position        = '100';
        //this.controls[0].div.style.zIndex        = 100;

        this.controls[0].div.style.display = 'inline-block';
        this.controls[0].div.style.width   = '100%';

        
        this._warningOverlay = createDiv('colorValueWarningOverlay');
        this._warningOverlay.style.zIndex  = 21;
        
        this.div.appendChild(this._warningOverlay);


        this.checkers                      = createDiv();
 
        this.checkers.style.position       = 'absolute';
        this.checkers.style.width          = '100%';
        this.checkers.style.height         = '20px';
        this.checkers.style.display        = 'none';
        this.checkers.style.pointerEvents  = 'none';


        this.div.appendChild(this.checkers);
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput(COLOR_TYPES, getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([COLOR_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);


        this.controls[0].addEventListener('confirm', () => 
        {
            this.setValue(this.controls[0].value, true, false); 
        });


        this.controls[0].addEventListener('finishedit', e =>
        { 
            if (!e.detail.success)
                return;

            if (   e.detail.value.trim() != ''
                && e.detail.value != e.detail.oldValue)
            {
                const webColor = webColors.find(wc => wc.name.toLowerCase() == e.detail.value.toLowerCase());
                if (webColor) e.detail.value = webColor.color;

                const rgb = validHex2rgb(e.detail.value);
                const val = ColorValue.fromRgb(scaleRgb(rgb));

                this.setValue(val, true);
                e.preventSetValue = true;
            }
        });
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        if (value.type == FILL_VALUE)
            value = value.color;

        this.param.setValue(value, false, true, false);
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    isDefault = () => this.value.equals(this.defaultValue);



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    resetControls()
    {
        this.controls[0].valueText = '';
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        console.assert(
               value.type 
            && value.type == COLOR_VALUE, 
            'value.type must be COLOR_VALUE');
            
        this.preSetValue(value, createAction, dispatchEvents);

        this.controls[0].value = value.copy();

        if (updateControl)
            this.controls[0].setValue(this.controls[0].value, true, false); 


        super.setValue(value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value.copy();
    }    



    updateControls()
    {
        this.updateWarningOverlay();


        const noColor = 
            darkMode
            ? rgbNoColorDark
            : rgbNoColorLight;


        const rgb        = this.value.toRgb();
        const rgbaStripe = rgb_a(getStripeBackColor(rgb));
        const rgbaText   = getTextColorFromBackColor(rgbaStripe, 1);
        

        if (this.showColorBack)
        {
            this.controls[0].backStyleLight   =
            this.controls[0].backStyleDark    = rgba2style(rgbaStripe);

            this.controls[0].valueStyleLight  = 
            this.controls[0].valueStyleDark   = 'transparent';

            this.controls[0].textStyleLight   = 
            this.controls[0].textStyleDark    = rgba2style(rgbaText);
        }

        
        if (this.input)
        {
            this.input.colorLight  = 
            this.input.colorDark   = rgb_a(rgbaText, 0.2);
            this.input.wireColor   = !rgbIsNaN(rgbaStripe) ? rgbaStripe : noColor;
        }

        if (this.output)
        {
            this.output.colorLight =
            this.output.colorDark  = rgb_a(rgbaText, 0.2);
            this.output.wireColor  = !rgbIsNaN(rgbaStripe) ? rgbaStripe : noColor;
        }


        this.checkers.style.background = 
            darkMode
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.backgroundColor    = darkMode ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '22px 22px';
        this.checkers.style.backgroundPosition = '0 0, 11px 11px';

        this.checkers.style.left               = '-3.5px';
        this.checkers.style.width              = 'calc(100% + 3.5px)';


        super.updateControls();
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];


        if (   this.input
            && this.input.connected)
            request.push(...pushInputOrParam(this.input, gen));

        else request.push( 
            COLOR_VALUE, 
            this.value.toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    textboxHasFocus()
    {
        return hasFocus(this.controls[0].textbox);
    }



    enableControlText(enable)
    {
        enable &= 
               !this.input 
            || !this.input.connected;

        enableElementText(this.controls[0].div, enable);
        
        this.controls[0].readOnly = !enable;
    }
    
    
    
    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgb = this.value.toRgb();

        if (!rgbIsNaN(rgb))
        {
            if (  !rgbIsValid(rgb)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgb);

                this.updateWarningOverlayStyle(rgb);
            }
            else
                this._warningOverlay.style.display = 'none';

            }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgb);
            this.updateWarningOverlayStyle(rgb);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? defParamHeight //this.div.offsetHeight
            : height;


        const [warnStyle1, warnStyle2] = getWarningStyles(colBack);

        this._warningOverlay.style.background =
                rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : getWarningGradient(7.8, warnStyle2, warnStyle1);


        this._warningOverlay.style.backgroundPosition = '-3px 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 8px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
    
    
    
    loadParam(_param)
    {
        this.setValue(parseColorValue(_param[2])[0], true, false, false);
    }
}


class   FillParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;


    checkersHolder;
    checkers;

    controlWrapper;

   
    
    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }

    
    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = FillValue.NaN,
                dragScale    = 0.05)
    {
        super(FILL_VALUE, id, name);

        this.checkersHolder = createDiv();
        this.checkers       = createDiv();

        this.controlWrapper = createDiv();


        this.controls.push(new ColorControl(
            null,
            this,
            this.id,
            'color', 
            showName,
            defaultValue.color,   
            dragScale)); 

        this.controls[0].showColor = false;


        this.controls.push(new NumberControl(
            null,
            this,
            this.id,
            'opacity', 
            false,
            defaultValue.opacity.value,
            0,
            100,
            0));
        
        this.controls[1].setSuffix('%', true);


        // this.controls[0].div.zIndex                 = 100;
        // this.controls[1].div.zIndex                 = 100;
                   
        this.defaultValue                           = defaultValue;
        this.value                                  = defaultValue;

        
        this._warningOverlay                        = createDiv('colorValueWarningOverlay');
        this._warningOverlay.style.zIndex           = 11;

        this.div.appendChild(this._warningOverlay);


        this.checkersHolder.style.position          = 'absolute';
        this.checkersHolder.style.width             = '100%';
        this.checkersHolder.style.height            = defParamHeight;
        this.checkersHolder.style.overflow          = 'hidden';

        this.checkers.style.position                = 'absolute';
        this.checkers.style.width                   = '100%';
        this.checkers.style.height                  = defParamHeight;


        this.controlWrapper.style.position          = 'relative';
        this.controlWrapper.style.display           = 'inline-block';
        this.controlWrapper.style.width             = '100%';
        this.controlWrapper.style.height            = defParamHeight;
        //this.controlWrapper.style.zIndex            = 100;


        this.controls[0].successOnFocusOut          = true;
        this.controls[0].div.style.display          = 'inline';
        this.controls[0].div.style.width            = '55%';
        this.controls[0].div.style.position         = 'absolute';
        this.controls[0].div.style.left             = 0;

    
        this.controls[1].successOnFocusOut          = true;
        this.controls[1].div.style.display          = 'inline';
        this.controls[1].div.style.width            = '45%';
        this.controls[1].div.style.position         = 'absolute';
        this.controls[1].div.style.right            = 0;

        this.controls[1].showBar = false;//barTop                     = 0.8;


        this.controls[0].text.style.transform       = 'translateX(-40%)';

        this.controls[1].text.style.transform       = 'translateX(-68.5%) \
                                                       translateY(-50%)';

        this.controls[0].textbox.style.position     = 'absolute';
        this.controls[0].textbox.style.left         =  0;
        this.controls[0].textbox.style.transform    = 'translateX(0)';
        this.controls[0].textbox.style.textAlign    = 'right';
        this.controls[0].textbox.style.paddingLeft  =  14;
        
        this.controls[1].textbox.style.position     = 'absolute';
        this.controls[1].textbox.style.right        =  0;
        this.controls[1].textbox.style.transform    = 'translateX(6px)';
        this.controls[1].textbox.style.textAlign    = 'left';
        this.controls[1].textbox.style.paddingRight =  10;
        this.controls[1].textbox.style.background   = 'transparent';


        this.controlWrapper.appendChild(this.controls[0].div);
        this.controlWrapper.appendChild(this.controls[1].div);
        
        this.checkersHolder.appendChild(this.checkers);
        this.div.appendChild(this.checkersHolder);

        this.div.appendChild(this.controlWrapper);

       
        if (hasInput)  this.initInput([FILL_VALUE, COLOR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([FILL_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);



        this.controls[0].addEventListener('change', () =>
        { 
            this.setValue(new FillValue(
                this.controls[0].value, 
                new NumberValue(this.controls[1].value, this.controls[1].dec)), 
                true, false);

            this.changing = true;
        });



        this.controls[0].addEventListener('confirm', () =>
        { 
            this.changing = false;
        });



        this.controls[0].addEventListener('finishedit', e =>
        { 
            if (!e.detail.success)
                return;

            if (   e.detail.value.trim() != ''
                && e.detail.value != e.detail.oldValue)
            {
                const webColor = webColors.find(wc => wc.name.toLowerCase() == e.detail.value.toLowerCase());
                if (webColor) e.detail.value = webColor.color;

                const  rgb = validHex2rgb(e.detail.value);
                const _rgb = scaleRgb(rgb);

                this.setValue(FillValue.fromRgb(_rgb, this.controls[1].value), true);
                
                e.preventSetValue = true;
            }
        });



        this.controls[1].addEventListener('change', () =>
        {
            this.setValue(new FillValue(
                this.controls[0].value, 
                new NumberValue(this.controls[1].value, this.controls[1].dec)), 
                true, false);

            this.changing = true;
        });



        this.controls[1].addEventListener('confirm', () =>
        { 
            this.changing = false;
        });
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == FILL_VALUE, 'expected FILL_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        //console.log('FillParam.setValue value =', value);
        if (!(value instanceof FillValue))
            console.assert(false, 'FillParam.setValue(value) is ' + typeof value + ', must be a FillValue');

        console.assert(
               value.type 
            && value.type == FILL_VALUE, 
            'FillParam value.type must be FILL_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        if (updateControl)
        {
            this.controls[0].setValue(this.value.color,         false, false); 
            this.controls[1].setValue(this.value.opacity.value, false, false, false); 
        }


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none'
            || this.controls[1].div.style.display != 'none';
    }



    resetControls()
    {
        this.controls[0].valueText = '';
        this.controls[1].valueText = '';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            // if (this.input.connectedOutput.supportsTypes(COLOR_TYPES))
            // {
            //     request.push(
            //         FILL_VALUE,
            //         FillValue.fromRgb(
            //             scaleRgb(dataColor2rgb(this.input.connectedOutput.node._color)), 0xff)
            //             .toString());
            // }
            // else if (this.input.connectedOutput.supportsTypes(FILL_TYPES))
                
            if (this.input.connectedOutput.supportsTypes([FILL_VALUE, COLOR_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for FillParam');
        }

        else request.push( 
            FILL_VALUE, 
            this.value.toString());


        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        checkControlVisible(this, this.controls[1]);


        const noColor = 
            darkMode
            ? rgbNoColorDark
            : rgbNoColorLight;


        const rgba       = this.value.toRgba();

        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);
        const rgbaBack   = rgbaStripe;
        const rgbaText   = getTextColorFromBackColor(rgbaStripe, rgba[3]);


        this.controlWrapper.style.background =
              !rgbaIsNaN(rgbaBack) 
            && this.value.opacity.isValid()
            ? rgba2style(rgbaBack)
            : noColorStyle(rgbaBack);//'transparent'; 


        this.updateWarningOverlay();


        this.div.style.background = 'transparent';//noColorStyle(rgba);


        if (this.input)
        {
            this.input.colorLight  = 
            this.input.colorDark   = rgb_a(rgbaText, 0.2);
            this.input.wireColor   = !rgbaIsNaN(rgbaBack) ? rgbaBack : noColor;
        }

        if (this.output)
        {
            this.output.colorLight =
            this.output.colorDark  = rgb_a(rgbaText, 0.2);
            this.output.wireColor  = !rgbaIsNaN(rgbaBack) ? rgbaBack : noColor;
        }


        this.checkers.style.background = 
            darkMode
            ?   'linear-gradient(-45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(-45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(-45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(-45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = this.value.isValid() ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = darkMode ? '#444' : '#fff';
   
        this.checkers.style.backgroundSize     = '22px 22px';
        this.checkers.style.backgroundPosition = '0 0, 11px 11px';
   
        this.checkers.style.left               = '-3.5px';
        this.checkers.style.width              = 'calc(100% + 3.5px)';
        
        
        this.controls[0].backStyleLight        = 
        this.controls[0].backStyleDark         = 'transparent';
         
        this.controls[0].textStyleLight        = 
        this.controls[0].textStyleDark         = rgba2style(rgbaText);


        this.controls[1].backStyleLight        = 
        this.controls[1].backStyleDark         = 'transparent';


        this.controls[1].textStyleLight        = 
        this.controls[1].textStyleDark         = rgba2style(rgbaText);

        this.controls[0].update();
        this.controls[1].update();


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    isDefault = () => this.value.equals(this.defaultValue);



    // textboxHasFocus()
    // {
    //     return hasFocus(this.controls[0].textbox)
    //         || hasFocus(this.controls[1].textbox);
    // }



    enableControlText(enable)
    {
        enable &= !this.input || !this.input.connected;

        // const opEnable = 
        //         enable 
        //     || !this.input 
        //     || !this.input.connected;
            //||  this.input.connectedOutput.supportsTypes(COLOR_TYPES);

        enableElementText(this.controls[0].div, enable);
        enableElementText(this.controls[1].div, enable);//opEnable);
        
        this.controls[0].readOnly = !enable;
        this.controls[1].readOnly = !enable;//opEnable;
    }
    
    
    
    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgba = this.value.toRgba();

        if (!rgbaIsNaN(rgba))
        {
            if (  !rgbaIsValid(rgba)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgba);

                this.updateWarningOverlayStyle(rgba);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgba);
            this.updateWarningOverlayStyle(rgba);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? this.div.offsetHeight
            : height;


        const [warnStyle1, warnStyle2] = getWarningStyles(colBack);

        this._warningOverlay.style.background =
                rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : getWarningGradient(7.8, warnStyle2, warnStyle1);

               
        this._warningOverlay.style.backgroundPosition = '0 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 27.6px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
    
    
    
    loadParam(_param)
    {
        this.setValue(parseFillValue(_param[2])[0], true, true, false);
    }
}


class   StrokeParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;

    
    checkersHolder;
    checkers;

    controlWrapper;


    text;

   
    
    get valueText() { return this.controls[0].valueText; }
    set valueText(text) 
    {
        this.controls[0].valueText = text;
        this.controls[0].update();
    }

    
    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = StrokeValue.NaN)
    {
        super(STROKE_VALUE, id, name);

        this.checkersHolder = createDiv();
        this.checkers       = createDiv();

        this.controlWrapper = createDiv();


        this.controls.push(new ColorControl(
            null,
            this,
            this.id,
            'color', 
            showName,
            defaultValue.fill.color)); 

        this.controls[0].showColor = false;


        this.defaultValue                           = defaultValue;
        this.value                                  = defaultValue;


        this.text                                   = createDiv();

        this.text.style.position                    = 'absolute';
        this.text.style.left                        = 0;
        this.text.style.top                         = 0;
        this.text.style.width                       = '100%';
        this.text.style.height                      = defParamHeight - 4;
        this.text.style.background                  = 'transparent';
        this.text.style.fontFamily                  = 'Inter';
        this.text.style.fontSize                    = 11;
        this.text.style.fontWeight                  = '600';
        this.text.style.fontStyle                   = 'italic';
        this.text.style.textAlign                   = 'center';
        this.text.style.paddingTop                  = '4px';

        this.text.addEventListener('pointerdown', e => 
        {
            if (e.button != 1) 
                e.stopPropagation();
        });

        
        this._warningOverlay                        = createDiv('colorValueWarningOverlay');
        this._warningOverlay.style.zIndex           = 11;

        this.div.appendChild(this._warningOverlay);


        this.checkersHolder.style.position          = 'absolute';
        this.checkersHolder.style.width             = '100%';
        this.checkersHolder.style.height            = defParamHeight;
        this.checkersHolder.style.overflow          = 'hidden';

        this.checkers.style.position                = 'absolute';
        this.checkers.style.width                   = '100%';
        this.checkers.style.height                  = defParamHeight;


        this.controlWrapper.style.position          = 'relative';
        this.controlWrapper.style.display           = 'inline-block';
        this.controlWrapper.style.width             = '100%';
        this.controlWrapper.style.height            = defParamHeight;
        //this.controlWrapper.style.zIndex            = 100;


        this.controls[0].successOnFocusOut          = true;
        this.controls[0].div.style.display          = 'inline';
        this.controls[0].div.style.width            = '100%';
        this.controls[0].div.style.position         = 'absolute';
        this.controls[0].div.style.left             = 0;

   
        this.controls[0].text.style.transform       = 'translateX(-50%)';


        this.controls[0].textbox.style.position     = 'absolute';
        this.controls[0].textbox.style.left         =  0;
        this.controls[0].textbox.style.transform    = 'translateX(0)';
        this.controls[0].textbox.style.textAlign    = 'right';
        this.controls[0].textbox.style.paddingLeft  =  14;


        this.controlWrapper.appendChild(this.controls[0].div);
        
        this.checkersHolder.appendChild(this.checkers);
        this.div.appendChild(this.checkersHolder);

        this.div.appendChild(this.controlWrapper);

        this.div.appendChild(this.text);

       
        if (hasInput)  this.initInput([STROKE_VALUE, FILL_VALUE, COLOR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([STROKE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == STROKE_VALUE, 'expected STROKE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof StrokeValue))
            console.assert(false, 'StrokeParam.setValue(value) is ' + typeof value + ', must be a StrokeValue');

        console.assert(
               value.type 
            && value.type == STROKE_VALUE, 
            'StrokeParam value.type must be STROKE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        if (updateControl)
            this.controls[0].setValue(this.value.fill.color, false, false); 


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    resetControls()
    {
        this.controls[0].valueText = '';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            // request.push(...pushInputOrParam(this.input, gen));

            // if (   this.input.connectedOutput.support( FILL_TYPES)
            //     || this.input.connectedOutput.support(COLOR_TYPES))
            // {
            //     const val = noNaN(this.controls[0].value,      1);
            //     const dec = noNaN(this.controls[0].displayDec, 0);
                
            //     request.push(
            //         NUMBER_VALUE, 
            //         new NumberValue(val, dec).toString());
            // }

            if (this.input.connectedOutput.supportsTypes([STROKE_VALUE, FILL_VALUE, COLOR_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for StrokeParam');
        }

        else request.push( 
            STROKE_VALUE, 
            this.value.toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        //checkControlVisible(this, this.controls[1]);


        const noColor = 
            darkMode
            ? rgbNoColorDark
            : rgbNoColorLight;


        const rgba       = this.value.fill.toRgba();

        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);
        const rgbaBack   = rgbaStripe;
        const rgbaText   = getTextColorFromBackColor(rgbaStripe, rgba[3]);


        this.controlWrapper.style.background =
              !rgbaIsNaN(rgbaBack) 
            && this.value.fill.opacity.isValid()
            ? rgba2style(rgbaBack)
            : noColorStyle(rgbaBack);//'transparent'; 


        this.updateWarningOverlay();


        this.div.style.background = 'transparent';//noColorStyle(rgba);


        this.text.innerHTML = 'stroke ' + this.value.weight.value;

        this.text.style.color = rgba2style(rgbaText);


        if (this.input)
        {
            this.input.colorLight  = 
            this.input.colorDark   = rgb_a(rgbaText, 0.2);
            this.input.wireColor   = !rgbaIsNaN(rgbaBack) ? rgbaBack : noColor;
        }

        if (this.output)
        {
            this.output.colorLight =
            this.output.colorDark  = rgb_a(rgbaText, 0.2);
            this.output.wireColor  = !rgbaIsNaN(rgbaBack) ? rgbaBack : noColor;
        }


        this.checkers.style.background = 
            darkMode
            ?   'linear-gradient(-45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(-45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(-45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(-45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = this.value.isValid() ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = darkMode ? '#444' : '#fff';
   
        this.checkers.style.backgroundSize     = '22px 22px';
        this.checkers.style.backgroundPosition = '0 0, 11px 11px';
   
        this.checkers.style.left               = '-3.5px';
        this.checkers.style.width              = 'calc(100% + 3.5px)';
        
        
        this.controls[0].backStyleLight        = 
        this.controls[0].backStyleDark         = 'transparent';
         
        this.controls[0].textStyleLight        = 
        this.controls[0].textStyleDark         = rgba2style(rgbaText);


        // this.controls[1].backStyleLight        = 
        // this.controls[1].backStyleDark         = 'transparent';


        // this.controls[1].textStyleLight        = 
        // this.controls[1].textStyleDark         = rgba2style(rgbaText);

        this.controls[0].update();
        //this.controls[1].update();


        this.controls[0].text.innerHTML = '';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    setName(name, dispatchEvents = true)
    {
        super.setName(name, dispatchEvents);
        this.controls[0].setName(name);
    }



    isDefault = () => this.value.equals(this.defaultValue);



    // textboxHasFocus()
    // {
    //     return hasFocus(this.controls[0].textbox)
    //         || hasFocus(this.controls[1].textbox);
    // }



    enableControlText(enable)
    {
        //enable &= !this.input || !this.input.connected;

        // const opEnable = 
        //         enable 
        //     || !this.input 
        //     || !this.input.connected;
            //||  this.input.connectedOutput.supportsTypes(COLOR_TYPES);

        enableElementText(this.controls[0].div, false);//enable);
        //enableElementText(this.controls[1].div, enable);//opEnable);
        
        this.controls[0].readOnly = true;//!enable;
        //this.controls[1].readOnly = !enable;//opEnable;
    }
    
    
    
    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const rgba = this.value.fill.toRgba();

        if (!rgbaIsNaN(rgba))
        {
            if (  !rgbaIsValid(rgba)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(rgba);

                this.updateWarningOverlayStyle(rgba);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(rgba);
            this.updateWarningOverlayStyle(rgba);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        //console.log('colBack =', colBack);
        
        this._warningOverlay.style.height = 
            height < 0
            ? this.div.offsetHeight
            : height;


        const [warnStyle1, warnStyle2] = getWarningStyles(colBack);

        this._warningOverlay.style.background =
                rgbIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : getWarningGradient(7.8, warnStyle2, warnStyle1);

               
        this._warningOverlay.style.backgroundPosition = '0 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 27.6px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
    
    
    
    loadParam(_param)
    {
        this.setValue(parseStrokeValue(_param[2])[0], true, true, false);
    }
}


class   ListParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    itemName;
   
    
    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new ListValue())
    {
        super(LIST_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;

        this.itemName     = 'item';


        this.controls.push(new TextControl(
            null,
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([LIST_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([LIST_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == LIST_VALUE, 'expected LIST_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof ListValue))
            console.assert(false, 'ListParam.setValue(value) is ' + typeof value + ', must be a ListValue');

        console.assert(
               value.type 
            && value.type == LIST_VALUE, 
            'ListParam value.type must be LIST_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([LIST_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for ListParam');
        }

        else request.push( 
            LIST_VALUE, 
            (new ListValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        const nItems = this.value.items.length;

        this.controls[0].textbox.value = nItems + '' + countString(this.itemName, nItems);


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseListValue(_param[2])[0], true, true, false);
    }
}


class   RectangleParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new RectangleValue())
    {
        super(RECTANGLE_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            null,
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([RECTANGLE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([RECTANGLE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == RECTANGLE_VALUE, 'expected RECTANGLE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof RectangleValue))
            console.assert(false, 'RectangleParam.setValue(value) is ' + typeof value + ', must be a RectangleValue');

        console.assert(
               value.type 
            && value.type == RECTANGLE_VALUE, 
            'RectangleParam value.type must be RECTANGLE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([RECTANGLE_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for RectangleParam');
        }

        else request.push( 
            RECTANGLE_VALUE, 
            (new RectangleValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'rectangle';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseRectangleValue(_param[2])[0], true, true, false);
    }
}


class   LineParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new LineValue())
    {
        super(LINE_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            null,
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([LINE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([LINE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == LINE_VALUE, 'expected LINE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof LineValue))
            console.assert(false, 'LineParam.setValue(value) is ' + typeof value + ', must be a LineValue');

        console.assert(
               value.type 
            && value.type == LINE_VALUE, 
            'LineParam value.type must be LINE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([LINE_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for LineParam');
        }

        else request.push( 
            LINE_VALUE, 
            (new LineValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'line';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseLineValue(_param[2])[0], true, true, false);
    }
}


class   EllipseParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new EllipseValue())
    {
        super(ELLIPSE_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            null,
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([ELLIPSE_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([ELLIPSE_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == ELLIPSE_VALUE, 'expected ELLIPSE_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof EllipseValue))
            console.assert(false, 'EllipseParam.setValue(value) is ' + typeof value + ', must be a EllipseValue');

        console.assert(
               value.type 
            && value.type == ELLIPSE_VALUE, 
            'EllipseParam value.type must be ELLIPSE_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([ELLIPSE_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for EllipseParam');
        }

        else request.push( 
            ELLIPSE_VALUE, 
            (new EllipseValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'ellipse';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseEllipseValue(_param[2])[0], true, true, false);
    }
}


class   PolygonParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new PolygonValue())
    {
        super(POLYGON_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            null,
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([POLYGON_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([POLYGON_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == POLYGON_VALUE, 'expected POLYGON_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof PolygonValue))
            console.assert(false, 'PolygonParam.setValue(value) is ' + typeof value + ', must be a PolygonValue');

        console.assert(
               value.type 
            && value.type == POLYGON_VALUE, 
            'PolygonParam value.type must be POLYGON_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([POLYGON_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for PolygonParam');
        }

        else request.push( 
            POLYGON_VALUE, 
            (new PolygonValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'polygon';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parsePolygonValue(_param[2])[0], true, true, false);
    }
}


class   StarParam
extends Parameter
{
    defaultValue;

    oldValue = null;
    

    value;
    

    
    constructor(id,
                name, 
                showName,
                hasInput,
                hasOutput,
                defaultValue = new StarValue())
    {
        super(STAR_VALUE, id, name);

        this.defaultValue = defaultValue;
        this.value        = defaultValue;


        this.controls.push(new TextControl(
            null,
            this,
            this.id,
            this.name,
            ''));

        this.controls[0].textbox.style.textAlign = 'center';
   
        this.div.appendChild(this.controls[0].div);

       
        if (hasInput)  this.initInput([STAR_VALUE], getParamInputValuesForUndo, this.input_getBackInitValue);
        if (hasOutput) this.initOutput([STAR_VALUE], this.output_genRequest, getParamOutputValuesForUndo, this.output_backInit);
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.param.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == STAR_VALUE, 'expected STAR_VALUE in backInit()');
        
        this.param.setValue(value, false, true, false);
    }



    setValue(value, createAction, updateControl = true, dispatchEvents = true) 
    {
        if (!(value instanceof StarValue))
            console.assert(false, 'StarParam.setValue(value) is ' + typeof value + ', must be a StarValue');

        console.assert(
               value.type 
            && value.type == STAR_VALUE, 
            'StarParam value.type must be STAR_VALUE');


        this.preSetValue(value, createAction, dispatchEvents);


        this.value = value.copy();


        super.setValue(this.value, createAction, updateControl, dispatchEvents);


        this.oldValue = this.value;
    }    



    isVisible()
    {
        return this.controls[0].div.style.display != 'none';
    }



    genRequest(gen)
    {
        // this function exists because a parameter without an output
        // should still be able to generate a request
        
        // 'this' is the param

        if (    this.output
            && !isEmpty(this.output.cache)
            &&  gen.passedNodes.includes(this.node))
            return this.output.cache;


        const request = [];

        if (   this.input
            && this.input.connected)
        {
            if (this.input.connectedOutput.supportsTypes([STAR_VALUE]))
                request.push(...pushInputOrParam(this.input, gen));
            else
                console.assert(false, 'invalid input for StarParam');
        }

        else request.push( 
            STAR_VALUE, 
            (new StarValue()).toString());

        return request;
    }



    output_genRequest(gen)
    {
        return this.param.genRequest(gen);
    }



    updateControls()
    {
        checkControlVisible(this, this.controls[0]);
        

        enableElementText(this.controls[0].div, false);

        this.controls[0].readOnly = true;
        
        this.controls[0].textbox.style.fontStyle  = 'italic';
        this.controls[0].textbox.style.fontWeight = '500';

        this.controls[0].textbox.value            = 'star';


        if (this.input ) this.input .updateControl();
        if (this.output) this.output.updateControl();
    }



    isDefault = () => this.value.equals(this.defaultValue);



    loadParam(_param)
    {
        this.setValue(parseStarValue(_param[2])[0], true, true, false);
    }
}





class   Input
extends EventTarget
{
    types = []; // an input can accept multiple types


    _node  = null; get node () { return this._param ? this._param.node : this._node; }
    _param = null; get param() { return this._param; }


    get id()   
    { 
        return this.node
             ? this.node.getInputId(this)
             : this.param
               ? this.param.id
               : '';     
    }
    
    get index() { return this.node.inputs.indexOf(this); }

    
    colorLight;
    colorDark;

    wireColor;

    
    div;
    hitbox;
    wireBall;


    measureData = { divBounds: new Rect(0, 0, 0, 0) };


    _connectedOutput = null;
    
    get connectedOutput() { return this._connectedOutput; }
    set connectedOutput(output)
    {
        if (this._connectedOutput)
        {
            this                 .dispatchEvent(new CustomEvent('disconnect', { detail: { input:  this   }}));
            this._connectedOutput.dispatchEvent(new CustomEvent('disconnect', { detail: { output: output }}));
        }

        this._connectedOutput = output;

        if (this._connectedOutput)
        {
            this  .dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this }}));
            output.dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this }}));
        }
    }


    get connected() { return this.connectedOutput != null; }


    canConnect         = true; // all connections master switch for minimum zoom
    canAutoConnect     = true;
    outputMustBeCached = false;


    connection         = null;
           
    connecting         = false;
    mouseOver          = false;

    overFactor         = 1.7;
           
    
    initialSeed        = 0;
    currentSeed        = 0;
       
       
    isNew              = false; // this indicates that the input is the empty "new" input of a variable node


    getValuesForUndo; // function pointer, return array of [index,value] tuples

    getBackInitValue   = null;
    
    feedback           = false; // sends data back to the output



    constructor(types, getValuesForUndo = null, getBackInitValue = null)
    {
        super();
        

        this.types            = [...types];
        this.getValuesForUndo = getValuesForUndo;
        this.getBackInitValue = getBackInitValue;


        this.div              = createDiv('input');
        this.hitbox           = createDiv('inputHitbox');
        this.wireBall         = createDiv('inputBall');
        
        this.div.input        = this;
        
        
        this.colorLight       = [0, 0, 0, 1];
        this.colorDark        = [1, 1, 1, 1];

        this.wireColor        = rgbFromType(this.types[0], true);

        
        this.div.appendChild(this.hitbox);
        this.div.appendChild(this.wireBall);


                
        this.hitbox.addEventListener('pointerenter', e => 
        {
            if (!this.canReact(e))
                return;


            if (graphView.headerInput)
            {
                graphView.headerInput.updateControl();
                graphView.headerInput = null;
                //console.log('headerInput = ', graphView.headerInput);
            }

            
            let savedInput = 
                graphView.savedConn
                ? graphView.savedConn.input
                : null;

                
            this.mouseOver = true;
            this.updateControl();


            const tc = graphView.tempConn;

            if (   tc
                && tc.output
                && this.canConnectFrom(tc.output)
                && (  !this.connected
                    || this.connectedOutput != tc.output
                    || this == savedInput))
            {
                const rect = boundingRect(this.div);
                const loop = tc.output.node.isOrFollows(this.node);

                if (!loop)
                {
                    tc.wire.inputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - getTopHeight());
                }

                graphView.overInput = !loop ? this : null;
                this.node.inputs.forEach(i => i.updateControl());
            }
            else if (!tc
                   ||    tc.output
                      && this.canConnectFrom(tc.output))
                graphView.overInput = this;
        });

        

        this.hitbox.addEventListener('pointerdown', e => 
        { 
            if (!this.canReact(e)) 
                return false; 
        });



        this.hitbox.addEventListener('pointerleave', e => 
        {
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overInput = null;

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.output)
            graphView.tempConn.wire.inputPos = point_NaN;
    }



    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.node ? this.node.header : this.param.node.header);

        return false;
    }



    updateMeasureData()
    {
        this.measureData = 
        {
            divBounds: boundingRect(this.div)
        };
    }


    
    // updateColor()
    // {
    //     this.colorDark = rgbFromTypeMode(
    //         !isEmpty(this.types) 
    //         ? this.types[0] 
    //         : NUMBER_VALUE, 
    //         true);

    //     this.colorLight = rgbFromTypeMode(
    //         !isEmpty(this.types) 
    //         ? this.types[0] 
    //         : NUMBER_VALUE, 
    //         false);
    // }



    updateControl()
    {
        const tc = graphView.tempConn;

        const mouseOver =
               this.mouseOver
            && !(   tc 
                 && tc.input)
            && !(   tc
                 && tc.output
                 && (  !this.canConnectFrom(tc.output)
                     || tc.output.node.isOrFollows(this.node)));

        const color = 
               this.param
            && this.param.type != COLOR_VALUE
            && this.param.type !=  FILL_VALUE
            ? rgb_a(rgbFromType(this.param.type, true), 0.5)
            : (darkMode
               ? this.colorDark
               : this.colorLight);

        const colorStyle = 
            rgba2style(rgb_a(
                color,
                mouseOver 
                ? (tc ? tc.wire.color : Math.min(color[3] * this.overFactor, 1))
                : color[3]));


        const isConnected =
               this.connected
            ||     tc
               && (   tc.input == this
                   ||    graphView.overInput == this
                      && !tc.input)
               && !(    tc.output
                    && !this.canConnectFrom(tc.output));

        this.div.style.transform = 
              'translateX(' + (isConnected ? -1 : 0) + 'px)'
            + 'translateY(-50%)';
        
        this.div.style.width                = (isConnected ? 8 : 6) + 'px';
        this.div.style.height               = (isConnected ? 8 : 6) + 'px';
        this.div.style.borderRadius         = (isConnected ? 4 : 4) + 'px';
        this.div.style.marginBottom         = (isConnected ? 4 : 6) + 'px';
        this.div.style.boxShadow            = '0 0 0 1px ' + colorStyle;
        this.div.style.pointerEvents        = 'auto';

        this.hitbox.style.left              = isConnected ? -2 : -3;
        this.hitbox.style.top               = isConnected ? -2 : -3;

        this.wireBall.style.left            = '1px';
        this.wireBall.style.top             = 'calc(50% - 3px)';

        this.wireBall.style.backgroundColor = [255, 0, 255];

        this.wireBall.style.zIndex          = MAX_INT32;


        showElement(this.wireBall, isConnected); 
    }



    supportsTypes(types)
    {
        return this.types.includes(ANY_TYPE)
             ? true
             : arraysIntersect(this.types, types);
    }



    canConnectFrom(output)
    {
        if (   output.supportsTypes([ANY_TYPE])
            && this.types[0] != ANY_TYPE)
            return false;

        if (   !this.canConnect
            || !this.supportsTypes(output.types))
            return false;

        if (    this.outputMustBeCached 
            && !output.node.isCached())
            return false;

        if (output.node.isOrFollows(this.node))
            return false;


        return true;
    }



    isConnectedUncached()
    {
        return  this.connected 
            && !this.connectedOutput.node.isCached()
            && !this.connectedOutput.node.isOrPrecededByMultiplier();
    }




    isMultiplied()
    {
        if (   this.connectedOutput
            && this.connectedOutput.node.isMultiplier())
            return true;

        else if (   this.connectedOutput
                 && this.connectedOutput.node.hasMultipliedInputs())
            return true;

        return false;
    }



    toJsDef(gen)
    {
        let js = '';


        js += gen.NL + 'const ' + this.name + ' = ';

        js += 
            this.connected
            ? this.connectedOutput.toJsCode(gen)
            : this.param
                ? this.param.toJsCode(gen)
                : 'Number.NaN';
                
        js += ';';


        return js;
    }
}


// class   InputProxy
// extends EventTarget
// {
//     input = null;


//     types = []; // an input can accept multiple types


//     _node  = null; get node () { return this._param ? this._param.node : this._node; }
//     _param = null; get param() { return this._param; }


//     get id()   
//     { 
//         return this.node
//              ? this.node.getInputId(this)
//              : this.param
//                ? this.param.id
//                : '';     
//     }
    
//     get index() { return this.node.inputs.indexOf(this); }

    
//     colorLight;
//     colorDark;

//     wireColor;

    
//     div;
//     hitbox;
//     wireBall;


//     measureData = { divBounds: new Rect(0, 0, 0, 0) };


//     _connectedOutput = null;
    
//     get connectedOutput() { return this.input._connectedOutput; }
//     set connectedOutput(output)
//     {
//         if (this.input._connectedOutput)
//         {
//             this.input                 .dispatchEvent(new CustomEvent('disconnect', { detail: { input:  this.input   }}));
//             this.input._connectedOutput.dispatchEvent(new CustomEvent('disconnect', { detail: { output: output }}));
//         }

//         this.input._connectedOutput = output;

//         if (this.input._connectedOutput)
//         {
//             this.input.dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this.input }}));
//             output.dispatchEvent(new CustomEvent('connect', { detail: { output: output, input: this.input }}));
//         }
//     }


//     get connected() { return this.input.connectedOutput != null; }


//     canConnect         = true; // all connections master switch for minimum zoom
//     canAutoConnect     = true;
//     outputMustBeCached = false;


//     connection         = null;
           
//     connecting         = false;
//     mouseOver          = false;

//     overFactor         = 1.7;
           
    
//     initialSeed        = 0;
//     currentSeed        = 0;
       
       
//     isNew              = false; // this indicates that the input is the empty "new" input of a variable node


//     getValuesForUndo; // function pointer, return array of [index,value] tuples

//     getBackInitValue   = null;
    
//     feedback           = false; // sends data back to the output



//     constructor(input)//types, getValuesForUndo = null, getBackInitValue = null)
//     {
//         super();
        

//         this.types            = [...input.types];
//         this.getValuesForUndo = input.getValuesForUndo;
//         this.getBackInitValue = input.getBackInitValue;


//         this.div              = createDiv('input');
//         this.hitbox           = createDiv('inputHitbox');
//         this.wireBall         = createDiv('inputBall');
        
//         this.div.input        = this;
        
        
//         this.colorLight       = [0, 0, 0, 1];
//         this.colorDark        = [1, 1, 1, 1];

//         this.wireColor        = rgbFromType(this.types[0], true);

        
//         this.div.appendChild(this.hitbox);
//         this.div.appendChild(this.wireBall);


                
//         this.hitbox.addEventListener('pointerenter', e => 
//         {
//             if (!this.canReact(e))
//                 return;


//             if (graphView.headerInput)
//             {
//                 graphView.headerInput.updateControl();
//                 graphView.headerInput = null;
//                 //console.log('headerInput = ', graphView.headerInput);
//             }

            
//             let savedInput = 
//                 graphView.savedConn
//                 ? graphView.savedConn.input
//                 : null;

                
//             this.mouseOver = true;
//             this.updateControl();


//             const tc = graphView.tempConn;

//             if (   tc
//                 && tc.output
//                 && this.canConnectFrom(tc.output)
//                 && (  !this.connected
//                     || this.connectedOutput != tc.output
//                     || this == savedInput))
//             {
//                 const rect = boundingRect(this.div);
//                 const loop = tc.output.node.isOrFollows(this.node);

//                 if (!loop)
//                 {
//                     tc.wire.inputPos = point(
//                         rect.x + rect.w/2,
//                         rect.y + rect.h/2 - getTopHeight());
//                 }

//                 graphView.overInput = !loop ? this : null;
//                 this.node.inputs.forEach(i => i.updateControl());
//             }
//             else if (!tc
//                    ||    tc.output
//                       && this.canConnectFrom(tc.output))
//                 graphView.overInput = this;
//         });

        

//         this.hitbox.addEventListener('pointerdown', e => 
//         { 
//             if (!this.canReact(e)) 
//                 return false; 
//         });



//         this.hitbox.addEventListener('pointerleave', e => 
//         {
//             this.endConnection();
//         });
//     }



//     endConnection()
//     {
//         graphView.overInput = null;

//         this.mouseOver = false;
//         this.updateControl();

//         if (   graphView.tempConn
//             && graphView.tempConn.output)
//             graphView.tempConn.wire.inputPos = point_NaN;
//     }



//     canReact(e)
//     {
//         if (   settings.enableZoomedOutParams
//             || graph.currentPage.zoom > settings.minZoomForParams)
//             return true;

//         e.preventDefault();
//         e.stopPropagation();

//         forwardEvent(e, this.node ? this.node.header : this.param.node.header);

//         return false;
//     }



//     updateMeasureData()
//     {
//         this.measureData = 
//         {
//             divBounds: boundingRect(this.div)
//         };
//     }


    
//     // updateColor()
//     // {
//     //     this.colorDark = rgbFromTypeMode(
//     //         !isEmpty(this.types) 
//     //         ? this.types[0] 
//     //         : NUMBER_VALUE, 
//     //         true);

//     //     this.colorLight = rgbFromTypeMode(
//     //         !isEmpty(this.types) 
//     //         ? this.types[0] 
//     //         : NUMBER_VALUE, 
//     //         false);
//     // }



//     updateControl()
//     {
//         const tc = graphView.tempConn;

//         const mouseOver =
//                this.mouseOver
//             && !(   tc 
//                  && tc.input)
//             && !(   tc
//                  && tc.output
//                  && (  !this.canConnectFrom(tc.output)
//                      || tc.output.node.isOrFollows(this.node)));

//         const color = 
//                this.param
//             && this.param.type != COLOR_VALUE
//             && this.param.type !=  FILL_VALUE
//             ? rgb_a(rgbFromType(this.param.type, true), 0.5)
//             : (darkMode
//                ? this.colorDark
//                : this.colorLight);

//         const colorStyle = 
//             rgba2style(rgb_a(
//                 color,
//                 mouseOver 
//                 ? (tc ? tc.wire.color : Math.min(color[3] * this.overFactor, 1))
//                 : color[3]));


//         const isConnected =
//                this.connected
//             ||     tc
//                && (   tc.input == this
//                    ||    graphView.overInput == this
//                       && !tc.input)
//                && !(    tc.output
//                     && !this.canConnectFrom(tc.output));

//         this.div.style.transform = 
//               'translateX(' + (isConnected ? -1 : 0) + 'px)'
//             + 'translateY(-50%)';
        
//         this.div.style.width                = (isConnected ? 8 : 6) + 'px';
//         this.div.style.height               = (isConnected ? 8 : 6) + 'px';
//         this.div.style.borderRadius         = (isConnected ? 4 : 4) + 'px';
//         this.div.style.marginBottom         = (isConnected ? 4 : 6) + 'px';
//         this.div.style.boxShadow            = '0 0 0 1px ' + colorStyle;
//         this.div.style.pointerEvents        = 'auto';

//         this.hitbox.style.left              = isConnected ? -2 : -3;
//         this.hitbox.style.top               = isConnected ? -2 : -3;

//         this.wireBall.style.left            = '1px';
//         this.wireBall.style.top             = 'calc(50% - 3px)';

//         this.wireBall.style.backgroundColor = [255, 0, 255];

//         this.wireBall.style.zIndex          = MAX_INT32;


//         showElement(this.wireBall, isConnected); 
//     }



//     supportsTypes(types)
//     {
//         return this.types.includes(ANY_TYPE)
//              ? true
//              : arraysIntersect(this.types, types);
//     }



//     canConnectFrom(output)
//     {
//         if (   output.supportsTypes([ANY_TYPE])
//             && this.types[0] != ANY_TYPE)
//             return false;

//         if (   !this.canConnect
//             || !this.supportsTypes(output.types))
//             return false;

//         if (    this.outputMustBeCached 
//             && !output.node.isCached())
//             return false;

//         if (output.node.isOrFollows(this.node))
//             return false;


//         return true;
//     }



//     isConnectedUncached()
//     {
//         return  this.connected 
//             && !this.connectedOutput.node.isCached();
//     }



//     toJsDef(gen)
//     {
//         let js = '';


//         js += gen.NL + 'const ' + this.name + ' = ';

//         js += 
//             this.connected
//             ? this.connectedOutput.toJsCode(gen)
//             : this.param
//                 ? this.param.toJsCode(gen)
//                 : 'Number.NaN';
                
//         js += ';';


//         return js;
//     }
// }


class Output
extends EventTarget
{
    types = []; // an output can have multiple types

    
    _node  = null; get node () { return this._param && this._param.node ? this._param.node : this._node; }
    _param = null; get param() { return this._param; }
    
    
    get id()    
    { 
        return this.node 
             ? this.node.getOutputId(this) 
             : this.param
               ? this.param.id
               : ''; 
    }

    get index() { return this.node ? this.node.outputs.indexOf(this) : ''; }


    colorLight;
    colorDark;

    wireColor;


    div;
    hitbox;
    wireBall;


    measureData = { divBounds: new Rect(0, 0, 0, 0) };


    connectedInputs = [];

    get connectedHeaderInputs() { return this.connectedInputs.filter(i => !i.param); }
    get connected() { return !isEmpty(this.connectedInputs); }


    mouseOver  = false;
    connecting = false;
 
    overFactor = 1.7;
 
 
    genRequest = null; // function pointer, must be implemented
    cache      = [];


    getValuesForUndo; // function pointer, return array of [index,value] tuples

    backInit   = null;




    constructor(types, genRequest, getValuesForUndo = null, backInit = null)
    {
        super();

        
        this.types            = [...types];
        this.genRequest       = genRequest;
        this.getValuesForUndo = getValuesForUndo;
        this.backInit         = backInit;

        
        this.div              = createDiv('output');
        this.hitbox           = createDiv('outputHitbox');
        this.wireBall         = createDiv('outputBall');
              
        this.div.output       = this;
              
              
        this.colorLight       = [0, 0, 0, 1];
        this.colorDark        = [1, 1, 1, 1];
      
        this.wireColor        = rgb_NaN;
        

        this.div.appendChild(this.hitbox);
        this.div.appendChild(this.wireBall);



        this.hitbox.addEventListener('pointerenter', e => 
        { 
            if (!this.canReact(e))
                return false;


            if (graphView.headerOutput)
            {
                graphView.headerOutput.updateControl();
                graphView.headerOutput = null;
                //console.log('headerOutput = ', graphView.headerOutput);
            }


            this.mouseOver = true;
            this.updateControl();


            if (   graphView.tempConn
                && graphView.tempConn.input
                && this.supportsTypes(graphView.tempConn.input.types))//.includes(this.type))
            {
                const rect = boundingRect(this.div);
                const loop = this.node.isOrFollows(graphView.tempConn.input.node);

                if (!loop)
                {
                    graphView.tempConn.wire.outputPos = point(
                        rect.x + rect.w/2,
                        rect.y + rect.h/2 - getTopHeight());
                }

                graphView.overOutput = !loop ? this : null;
                this.node.outputs.forEach(o => o.updateControl());
            }
            else
                graphView.overOutput = this; 
        });



        this.hitbox.addEventListener('pointerdown', e => 
        { 
            if (!this.canReact(e)) 
                return false; 
        });



        this.hitbox.addEventListener('pointerleave', e => 
        { 
            this.endConnection();
        });
    }



    endConnection()
    {
        graphView.overOutput = null; 

        this.mouseOver = false;
        this.updateControl();

        if (   graphView.tempConn
            && graphView.tempConn.input)
            graphView.tempConn.wire.outputPos = point_NaN;
    }



    updateSavedConnectionOrder(orderAfter, delta)
    {
        // update output order on existing connections created after this one
        
        const afterConns = this.connectedInputs
            .map   (i => i.connection)
            .filter(c => delta < 1 
                         ? (c.outputOrder >  orderAfter) 
                         : (c.outputOrder >= orderAfter));

        const oldKeys = afterConns.map(c => getConnKey(c));
        afterConns.forEach(c => c.outputOrder += delta);
        
        const newKeys = afterConns.map(c => getConnKey(c));

        uiUpdateSavedConnections(oldKeys, newKeys, afterConns);
    }



    canReact(e)
    {
        if (   settings.enableZoomedOutParams
            || graph.currentPage.zoom > settings.minZoomForParams)
            return true;

        e.preventDefault();
        e.stopPropagation();

        forwardEvent(e, this.node ? this.node.header : this.param.node.header);

        return false;
    }



    updateMeasureData()
    {
        this.measureData = 
        {
            divBounds: clientRect(this.div)
        };
    }


    
    updateControl()
    {
        const mouseOver =
               this.mouseOver
            && !(   graphView.tempConn
                 && graphView.tempConn.output)
            && !(   graphView.tempConn
                 && graphView.tempConn.input
                 && (  !graphView.tempConn.input.types.includes(this.type)
                     || this.node.isOrFollows(graphView.tempConn.input.node)));


        const color = 
               this.param
            && this.param.type != COLOR_VALUE
            && this.param.type !=  FILL_VALUE
            ? rgb_a(rgbFromType(this.param.type, true), 0.38)
            : (darkMode
               ? this.colorDark
               : this.colorLight);

        const colorStyle = 
            rgba2style(rgb_a(
                color, 
                mouseOver 
                ? Math.min(color[3] * this.overFactor, 1) 
                : color[3]));


        const isConnected =
               !isEmpty(this.connectedInputs)
            ||     graphView.tempConn
               && (   graphView.tempConn.output == this
                   ||     graphView.overOutput == this
                      && !graphView.tempConn.output)
               && !(    graphView.tempConn.input
                    && !graphView.tempConn.input.types.includes(this.type));

        this.div.style.transform = 
            //  'translateX(' + (isConnected ? -1 : 0) + 'px)'
            //+ 
            'translateY(-50%)';

        this.div.style.pointerEvents   = 'auto';
        this.div.style.backgroundColor = colorStyle;

        this.div.style.boxShadow = 
               !isEmpty(this.connectedInputs)
            ||    graphView.tempConn
               && (   graphView.tempConn.output == this
                   || graphView.overOutput == this)
            ? '0 0 0 1px ' + colorStyle
            : 'none';


        this.wireBall.style.zIndex = MAX_INT32;


        showElement(this.wireBall, isConnected);
    }



    supportsTypes(types)
    {
        return this.types.includes(ANY_TYPE)
             ? true
             : arraysIntersect(this.types, types);
    }



    canConnectTo(input)
    {
        // console.log('this.supportsTypes([ANY_TYPE] =', this.supportsTypes([ANY_TYPE]));

        if (this.supportsTypes([ANY_TYPE]))
            return true;

        return arraysIntersect(this.types, input.types);
    }



    isMultiplied()
    {
        if (this.connectedInputs.length > 1)
            return true;

        for (const input of this.connectedInputs)
        {
            if (input.node.isMultiplier())
                return true;

            else if (input.node.hasMultipliedOutputs())
                return true;
        }

        return false
    }



    toJsCode(gen)
    {
        return this.param
             ? this.param.toJsCode(gen)
             : this.node .toJsCode(gen);
    }
}





class Connection
{
    static nextId = 0;

    id;

    output;
    outputOrder; // in which connections FROM THIS OUTPUT were made
    
    input;

    list           = false;

    wire;
    
    backInit       = false; // if true, on connection the value is possibly copied from the input to the output

    // proxy          = null;

    
    stripIdForCopy = false;



    constructor(output, input)
    {
        this.id          = Connection.nextId++;

        this.output      = output;
        this.outputOrder = -1;
                 
        this.input       = input;

        this.wire        = new Wire(this);
    }



    toJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        const json = formatConnJson(
            pos, 
            tab,
            (this.stripIdForCopy ? this.output.node.nodeId : this.output.node.id),
            (this.output.param ? this.output.param.id : this.output.index),
            this.outputOrder,
            (this.stripIdForCopy ? this.input.node.nodeId : this.input.node.id),
            (this.input.param ? this.input.param.id : this.input.index),
            boolToString(arraysIntersect(this.output.types, LIST_TYPES))); // not supportsTypes() here, because that allows LIST in case of ANY_TYPE

        this.stripIdForCopy = false;

        return json;
    }



    toDataObject()
    {
        return {
            id:           this.id,
            outputNodeId: this.output.node.id,
            outputId:     this.output.id,
            outputOrder:  this.outputOrder,
            inputNodeId:  this.input.node.id,
            inputId:      this.input.id,
            list:         this.list
        };
    }
}



function parseConnectionJsonAndConnect(_conn, pasteConnected)
{
    const outputNode  = nodeFromId(pageIdFromPath(_conn.outputNodeId) == NULL ? makeNodePath(_conn.outputNodeId) : _conn.outputNodeId);
    const outputId    = _conn.outputId;
    const outputOrder = parseInt(_conn.outputOrder);

    const inputNode   = nodeFromId(pageIdFromPath(_conn.inputNodeId) == NULL ? makeNodePath(_conn.inputNodeId) : _conn.inputNodeId);
    const inputId     = _conn.inputId;


    if (   !outputNode 
        ||  isDigit(outputId[0]) && parseInt(outputId) >= outputNode.outputs.length
        || !isDigit(outputId[0]) && !outputNode.params.find(p => p.id == outputId && p.output)
        || !inputNode  
        ||  isDigit(inputId[0]) && parseInt(inputId) >= inputNode.inputs.length
        || !isDigit(inputId[0]) && !inputNode.params.find(p => p.id == inputId && p.input))
    {
        uiError(
            'Cannot connect ' + connToString(_conn),
            {
                buttonText:   'Remove connection',
                buttonAction: 'removeConnection,' + getStorageConnKey(_conn)
            });

        return null;
    }
    else
    {
        const conn = uiVariableConnect(
            outputNode, isDigit(outputId[0]) ? parseInt(outputId) : outputNode.params.find(p => p.id == outputId).output.id,
             inputNode, isDigit( inputId[0]) ? parseInt( inputId) :  inputNode.params.find(p => p.id ==  inputId). input.id,
            pasteConnected ? -1 : outputOrder);

        _conn.outputOrder = conn.outputOrder;

        return conn;
    }
}



function connDataObject(output, input)
{
    return {
        connection:   input.connection,
        id:           -1,
        outputNodeId: output.node.id,
        outputId:     output.id,
        outputOrder:  input.connection.outputOrder,
        inputNodeId:  input.node.id,
        inputId:      input.id
    };
}



function formatConnJson(pos, tab, outputNodeId, outputId, outputOrder, inputNodeId, inputId, list)
{
    return pos
         + '{'
         +       NL + pos + tab + '"outputNodeId": "' + outputNodeId + '"'
         + ',' + NL + pos + tab + '"outputId": "'     + outputId     + '"'
         + ',' + NL + pos + tab + '"outputOrder": "'  + outputOrder  + '"'
         + ',' + NL + pos + tab + '"inputNodeId": "'  + inputNodeId  + '"'
         + ',' + NL + pos + tab + '"inputId": "'      + inputId      + '"'
         + ',' + NL + pos + tab + '"list": "'         + list         + '"'
         +       NL + pos
         + '}';
}


class Wire
{
    connection;

    outputPos = point_NaN;
    inputPos  = point_NaN;


    clientX;
    clientY;


    svg;
    
    curve;
    curve2;
    
    xp1;
    xp2;

    outBall;
    inBall;

    arrow1;
    arrow2;
   


    constructor(connection)
    {
        this.connection             = connection;
 
        this.svg                    = createSvg('svg');
        this.svg.style.position     = 'absolute';
        this.svg.style.left         = 0;
        this.svg.style.top          = 0;
        this.svg.style.overflow     = 'hidden';
     
        this.curve                  = createSvg('path');
        this.curve.style.position   = 'absolute';
        this.curve.style.fill       = 'none';
 
        this.curve2                 = createSvg('path');
        this.curve2.style.position  = 'absolute';
        this.curve2.style.fill      = 'none';
 
        this.xp1                    = createSvg('path');
        this.xp1.style.position     = 'absolute';
        this.xp1.style.fill         = 'none';
     
        this.xp2                    = createSvg('path');
        this.xp2.style.position     = 'absolute';
        this.xp2.style.fill         = 'none';


        this.outBall                = createSvg('circle');
        this.outBall.style.position = 'absolute';
    
        this.inBall                 = createSvg('circle');
        this.inBall.style.position  = 'absolute';
    
        this.arrow1                 = createSvg('polygon');
        this.arrow1.style.position  = 'absolute';

        this.arrow2                 = createSvg('polygon');
        this.arrow2.style.position  = 'absolute';


        this.svg.appendChild(this.curve  );
        this.svg.appendChild(this.curve2 );
        this.svg.appendChild(this.xp1    );
        this.svg.appendChild(this.xp2    );
        this.svg.appendChild(this.arrow1 );
        this.svg.appendChild(this.arrow2 );
        this.svg.appendChild(this.outBall);
        this.svg.appendChild(this.inBall );
    }



    getColor()
    {
        const types = [];


        const output = this.connection.output;
        const input  = this.connection.input;
        

        if (output)
        {
            if (!isEmpty(output.types)) types.push(...output.types);
            else if (output)            types.push(output.node.type);
        }
        else if (input)
        {
            if (   graphView.overOutput
                && input.canConnectFrom(graphView.overOutput)) 
                types.push(...graphView.overOutput.types);
            else
            {
                if (!isEmpty(input.types)) types.push(...input.types);
                else if (input)            types.push(input.node.type);
            }
        }


        if (   output
            && arraysIntersect(output.types, [COLOR_VALUE, FILL_VALUE, STROKE_VALUE]))
            return output.wireColor;

        else if (input
              && arraysIntersect(input.types, [COLOR_VALUE, FILL_VALUE, STROKE_VALUE]))
            return input.wireColor;

        else if (!isEmpty(types))
            return rgb_a(rgbFromType(types[0], true));

        else 
            return rgbaInvalid;
    }



    update(x = 0, y = 0)
    {
        //logFunction('Wire.update()');
        
        this.clientX = x;
        this.clientY = y;
    
    
        const yOffset = getTopHeight() + 1;
    
        let pOut = point(0, 0),
            pIn  = point(0, 0);
    
    
        if (this.connection.output)
        {
            const ro = boundingRect(this.connection.output.div);
            pOut = point(ro.x + ro.w/2, ro.y + ro.h/2 - yOffset);
        }
        else
            pOut = point(x, y - yOffset);
    
    
        if (this.connection.input)
        {
            const ri = boundingRect(this.connection.input.div);
            pIn = point(ri.x + ri.w/2, ri.y + ri.h/2 - yOffset);
        }
        else
            pIn = point(x, y - yOffset);
    

        this.updateSvg(pOut.x, pOut.y, pIn.x, pIn.y);        
    }

    
    
    updateSvg(x1, y1, x2, y2)
    {
        this.updateCurve  (x1, y1, x2, y2);
        this.updateOutBall(x1, y1        );
        this.updateInBall (        x2, y2);
        this.updateStyle  ();

        this.svg.setAttribute('width',  graphView.div.clientWidth);
        this.svg.setAttribute('height', graphView.div.clientHeight);

        this.svg.style.zIndex = 1;
    }



    updateCurve(x1, y1, x2, y2)
    {
        if (!pointIsNaN(this.outputPos))
        {
            x1 = this.outputPos.x;
            y1 = this.outputPos.y;
        }
    
        if (!pointIsNaN(this.inputPos))
        {
            x2 = this.inputPos.x;
            y2 = this.inputPos.y;
        }
    
        
        const _x0 = x1;
        const _y0 = y1;
    
        const _x3 = x2;
        const _y3 = y2;
    
    
        const tx  = 600 * graph.currentPage.zoom;
        const ty  = 300 * graph.currentPage.zoom;
        const ecc = 100 * graph.currentPage.zoom;
    
        const yf  = (0.3 + Math.min(Math.abs(y2 - y1) / ty, 0.8));
    
        const df  = Math.pow((1 - Math.min(Math.abs(_x3 - _x0) / tx, 0.65)), 0.5)
                  * yf;
    
        const dx = 
              (_x3 - _x0) * df 
            * (_x3 < _x0 ? -1 : 1);
    
    
        let _x1 = Math.max(_x0 + ecc * Math.pow(0.1 + yf*0.9, 1.5), _x0 + dx);
        let _y1 = _y0;
    
        let _x2 = Math.min(_x3 - ecc * Math.pow(0.1 + yf*0.9, 1.5), _x3 - dx);
        let _y2 = _y3;
    
    
        if (   this.tempConn        == this.connection
            && this.tempConn.output == this.overOutput)
        {
            _x1 += (_x0 - _x1) * 5/8;
            _y1 += (_y0 - _y1) * 5/8;
        }
    
        if (   this.tempConn       == this.connection
            && this.tempConn.input == this.overInput)
        {
            _x2 += (_x3 - _x2) * 5/8;
            _y2 += (_y3 - _y2) * 5/8;
        }
    
        
        const points =
               'M ' + _x0 + ',' + _y0
            + ' C ' + _x1 + ',' + _y1
            + ' '   + _x2 + ',' + _y2
            + ' '   + _x3 + ',' + _y3;
    
        this.xp1   .setAttribute('d', points);
        this.xp2   .setAttribute('d', points);
        this.curve .setAttribute('d', points);
        this.curve2.setAttribute('d', points);
    
    
        this.updateArrows(
            _x0, _y0, 
            _x1, _y1, 
            _x2, _y2, 
            _x3, _y3);

        
        const fb = 
               this.connection.input
            && this.connection.input.feedback;

        const back = _x0 - _x3 > defNodeWidth * 1.5;

        this.arrow1.setAttribute('display', fb || this.connection.backInit ? 'inline' : 'none');
        this.arrow2.setAttribute('display', fb || back                     ? 'inline' : 'none');
    }
    
    
    
    updateOutBall(x, y)
    {
        this.outBall.setAttribute('cx', x);
        this.outBall.setAttribute('cy', y);
    }
    
    
    
    updateInBall(x, y)
    {
        this.inBall.setAttribute('cx', x);
        this.inBall.setAttribute('cy', y);
    }
    
    
    
    updateArrows(x0, y0, x1, y1, x2, y2, x3, y3)
    {
        if (!pointIsNaN(this.outputPos))
        {
            x0 = this.outputPos.x;
            y0 = this.outputPos.y;
        }
    
        if (!pointIsNaN(this.inputPos))
        {
            x3 = this.inputPos.x;
            y3 = this.inputPos.y;
        }
    
    
        const p0 = point(x0, y0);
        const p1 = point(x1, y1);
        const p2 = point(x2, y2);
        const p3 = point(x3, y3); 
    
    
        const fb = 
               this.connection.input
            && this.connection.input.feedback;

        const back = x0 - x3 > defNodeWidth * 1.5;


        this.updateArrow(p0, p1, p2, p3, this.arrow1, fb ? -25 : 25, 9, 0, fb, back);
        this.updateArrow(p0, p1, p2, p3, this.arrow2,      -35     , 9, 1, fb, back);
    }
    
    

    updateArrow(p0, p1, p2, p3, arrow, dist, size, index, fb, back)
    {
        let al = 
            dist >= 0
            ? arcLength(p0, p1, p2, p3) - dist * graph.currentPage.zoom
            : -dist * graph.currentPage.zoom;
    
        if (al <= 0)
        {
            arrow.setAttribute('display', 'none');
            return;
        }
        
    
        let t = positionOnSegment(p0, p1, p2, p3, al);
        
        if (isNaN(t))
        {
            arrow.setAttribute('display', 'none');
            return;
        }
        

        if (  !back
            || fb)
        {
            if (dist >= 0) t = Math.max(this.connection.backInit ? 0 : 0.5, t);
            else           t = Math.min(t, 0.5 - (index == 0 ? 0.15 : 0));
        }
        else
            t = 0.5;
           
    
        const pt = lerpv3(p0, p1, p2, p3, t);
    
        const tx = pt.x;
        const ty = pt.y;
    
        const tw = size * graph.currentPage.zoom;
        const th = size * graph.currentPage.zoom;
    
        const points =
                     (tx - tw/2) + ',' + (ty + th/2)
            + ' '  + (tx + tw/2) + ',' + (ty + th/2)
            + ' '  + (tx       ) + ',' + (ty - th/2);
    
        arrow.setAttribute('points', points);
        arrow.setAttribute('display', 'inline');
    
    
        const ct = bezierTangent(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, t);
    
        arrow.style.transformBox    = 'fill-box';
        arrow.style.transformOrigin = 'center';
        arrow.style.transform       = 'rotate(' + (angle(ct) - Tau/4 + (!back || fb ? 0 : Tau/2)) + 'rad)';
    }



    updateStyle()
    {
        const conn  = this.connection;
        let   color = rgb_a(this.getColor());
    

        const l = rgb2hclok(color)[2];
        
        let bright = Math.min(Math.max(0, (l-0.6) / 0.4), 1);
        if (darkMode) bright = 1-bright;
    
        
        // const innerOpacity = Math.round(bright * (darkMode ? 88 : 66) * Math.min(graph.currentPage.zoom, 5)).toString(16).padStart(2, '0');
        //'+(Math.min(Math.max(1, 1/graph.currentPage.zoom), 5))+'
        
        // this.curve.style.filter = 
        //     this.needsFilter
        //     ? darkMode
        //         ? (isDark(color, 0.65)
        //             ?    'drop-shadow(0px 0px 1px #ffffff' + innerOpacity + ')'
        //             :   ' drop-shadow(0px 0px 1px #000000' + innerOpacity + ')')
        //         : (!isDark(color)
        //             ?    'drop-shadow(0px 0px 1px #000000' + innerOpacity + ')'
        //             :   ' drop-shadow(0px 0px 1px #ffffff' + innerOpacity + ')')
        //     : 'none';
    
         
        //let showCurve = true;
    

        if (   conn.output && color[3] < 1
            || conn. input && color[3] < 1)
        {
            // const showCurve = 
            //        conn.output && color[3] > 0
            //     || conn. input && color[3] > 0;
    
            this.xp1.style.display          = 'inline';
            this.xp1.style.stroke           = rgba2style(rgb_a(darkMode ? [0.067, 0.067, 0.067] : [0.784, 0.784, 0.784], 1 - color[3]));
            this.xp1.style.strokeDasharray  = 9 * graph.currentPage.zoom;
    
            this.xp2.style.display          = 'inline';
            this.xp2.style.stroke           = rgba2style(rgb_a(darkMode ? [0.302, 0.302, 0.302] : [1, 1, 1], 1 - color[3]));//darkMode ? '#4d4d4d' : '#fff';
            this.xp2.style.strokeDasharray  = 9 * graph.currentPage.zoom;
            this.xp2.style.strokeDashoffset = 9 * graph.currentPage.zoom;
        }
        else
        {
            this.xp1.style.display = 'none';
            this.xp2.style.display = 'none';
        }
    
    
        if (darkMode)
        {
            const hcl = rgb2hclok(color);
    
            let dl = 0.05;
    
            dl /= Math.min(1 - (1 - graph.currentPage.zoom) / 1.75, 1);
    
            if (hcl[2] > 0.27 - dl && hcl[2] <= 0.27)
                color = invalid2validRgb(hclok2rgb([hcl[0], hcl[1], 0.27 - dl]));
            if (hcl[2] > 0.27 && hcl[2] < 0.27 + dl)
                color = invalid2validRgb(hclok2rgb([hcl[0], hcl[1], 0.27 + dl]));
        }
        else
        {
            const hcl = rgb2hclok(color);
    
            if (hcl[2] > 0.97)
                color = invalid2validRgb(hclok2rgb([hcl[0], hcl[1], 0.97]));
        }
    
    
        const wireStyle = rgba2style(color);

        const arrowStyle = rgba2style(
            rgbaLerp(
                darkMode 
                ? [0.5, 0.5, 0.5, 0.65] 
                : [0.5, 0.5, 0.5, 0.5 ], 
                color, 
                color[3]));

                
        const isNotCached = 
                   conn.output
               &&  conn.output.node
               && !conn.output.node.isCached()
            ||     conn.output
               &&  conn.output.param
               &&  conn.output.param._nodeId != undefined
               &&  nodeFromId(conn.output.param._nodeId)
               && !nodeFromId(conn.output.param._nodeId).isCached();
        
        const unknown =
                isNotCached
            &&  conn.output
            && (  !conn.output.node.isOrPrecededByMultiplier()
                ||   !conn.output.node.isMultiplier()
                   && conn.output.node.inputs.find(i => i.isConnectedUncached()))
            &&  conn.input
            &&  conn.input.node.isOrFollowedByMultiplier()
            && (  !conn.input.param 
                || conn.input.param.affectsHeader);
    
    
        this.curve  .style.stroke          = wireStyle;
        this.curve2 .style.stroke          = rgb2style(rgbDocumentBody);
    
        this.curve  .style.strokeDasharray = unknown ? (2.7 * graph.currentPage.zoom) + ' ' + (2.7 * graph.currentPage.zoom) : '0';
    
        this. inBall.style.fill            = wireStyle;
        this.outBall.style.fill            = wireStyle;

        this.arrow1 .style.fill            = arrowStyle;
        this.arrow2 .style.fill            = arrowStyle;
    
    
        if (conn.output) conn.output.wireBall.style.background = wireStyle;
        if (conn. input) conn. input.wireBall.style.background = wireStyle;
    
    
        const listType = 
               conn.output
            && arraysIntersect(conn.output.types, LIST_TYPES);//supportsTypes(LIST_TYPES);
    
    
        let width = 
            graph.currentPage.zoom < 1
            ? graph.currentPage.zoom + (Math.pow(2, graph.currentPage.zoom - 1) - graph.currentPage.zoom) * 0.333
            : graph.currentPage.zoom;
    
        width *= 1.6;
    
    
        //      if (graph.currentPage.zoom < 1/7) width += 1 * (1 - graph.currentPage.zoom) * (7 * graph.currentPage.zoom);
        // else if (graph.currentPage.zoom < 1  ) width += 1 * (1 - graph.currentPage.zoom);
    
    
        this.curve .setAttribute('stroke-width', width * (listType ? (unknown ? 3.6 : 3.2) : (unknown ? 1.3 : 1)));
        this.curve2.setAttribute('stroke-width', width * 1.4);

        this.xp1   .setAttribute('stroke-width', width * (listType ? (unknown ? 3.6 : 3.2) : (unknown ? 1.3 : 1)));
        this.xp2   .setAttribute('stroke-width', width * 1.4);
    
        this.curve2.setAttribute('display', listType ? 'inline' : 'none');
    
    
        this. inBall.style.r = 3 * graph.currentPage.zoom;
        this.outBall.style.r = 3 * graph.currentPage.zoom;
    }
    
    
    
    show(show, update = true)
    {
        // const isReordering =   
        //        isNaN(newReorderIndex)
        //     || isNaN(oldReorderIndex);
    
        showElement(this.svg, show);//(this != this.savedConn || isReordering));
        //showElement(this.curve,   show);//show && (this != this.savedConn || isReordering));
        //showElement(this.xp1,     show);//(this != this.savedConn || isReordering));
        //showElement(this.xp2,     show);//(this != this.savedConn || isReordering));
        //showElement(this.outBall, show);//(!this.tempConn || this.tempConn.output));
        //showElement(this. inBall, show);//(!this.tempConn || this.tempConn. input));
    
    
        if (update)
            this.update();
            // updateWire(wire);
    }
}


const connectionSize = 9;
const connectionGap  = 4;

const defHeaderHeight = 32;



class Operator
{
    subscription = false;


    #type; // used in the code, not for generation
    get type() { return this.#type; }
    

    id;

    get pageId() 
    { 
        return pageIdFromPath(this.id);
    }

    get nodeId() { return this.id.split('/').at(-1); }


    _name;
    get name()     { return this._name;  }
    set name(name) { this.setName(name); }


    defId;
    defName;


    enabled;
    cached;
    
    inert; // doesn't eval inputs if values exist
    slow;  // takes a while to finish operation, shows a progress bar

    renamed            = false;     


    inputs             = [];
    outputs            = [];
  
    params             = [];
    hiddenParams       = [];
  
      
    variableInputs     = false;

    alwaysLoadParams   = false;
    alwaysSaveParams   = false;

    saveParams         = true;  // master switch to not save any params

    canDisable         = false;


    scrollName         = true;

    showActiveArrow    = false;

    sharpBottomCorners = false;

    stripIdForCopy     = false; // one-time flag
    

    defaultWidth;
    labelOffsetFactor;


    _creatingButton    = null; // this is used to place the node under its creating button

    
    requestCache       = []; // for nodes without an output


    // node UI

    div;
    inner;
    header;

    divDisabled;
    
    progressWrapper    = null;
    progressBar        = null;
   
    hasProgressBar     = false;


    labelWrapper;
    label;
    labelText;
    textbox;
    inputControls;
    outputControls;

    paramHolder;
    //hiddenParamBack;

    subscribeCover;
    subscribeLabel;

    reorderArrows;
    showReorderArrows  = false;


    valid;

    
    measureData = { divBounds: new Rect(0, 0, 0, 0) };



    _selected;
    get selected() { return this._selected; }
    set selected(sel) 
    {
        if (this._selected)
            removeFromArray(graphView.selectedNodes, this);

        this.setSelected(sel);     

        if (this._selected)
            graphView.selectedNodes.push(this);
    }        



    _active = false;
    get active() { return this._active; }


    get headerConnected       () { return !isEmpty(this.headerInputs.filter(i => i.connected)); }

    get headerInputs          () { return this.inputs .filter(i => !i.param);                   }
    get headerOutputs         () { return this.outputs.filter(o => !o.param);                   }
   
    get connectedHeaderInputs () { return this.inputs .filter(i => !i.param && i.connected);    }
    get connectedHeaderOutputs() { return this.outputs.filter(o => !o.param && o.connected);    }



    constructor(type, id, name, defWidth = defNodeWidth, progressBar = false)
    {
        this.#type             = type;
        this.id                = makeNodePath(id);
        
        this.enabled           = true;
        this.cached            = true;
        this.inert             = false;
        this.slow              = false;

        this.defId             = id;
        this.defName           = name;

        this.defaultWidth      = defWidth;
        this.labelOffsetFactor = 0;
        
        this.valid             = false;

        this.createNode();

        if (progressBar)
            this.createProgressBar();

        this.setName(name);
    }    



    getInputId(input)
    {
        return input.param
             ? input.param.id
             : input.index.toString();
    }



    inputFromId(id)
    {
        return this.inputs.find(i => i.id == id);
    }



    addInput(input, assign = true)
    {
        if (assign)
            input._node = this;

        const index = this.headerInputs.length;

        this.inputs.splice(index, 0, input);
        this.inputControls.insertBefore(input.div, this.inputControls.children[index]);
    }



    removeInput(input)
    {
        input._node = null;

        removeFromArray(this.inputs, input);
        this.inputControls.removeChild(input.div);

        return input;
    }



    createInputForObjects(types, getValuesForUndo)
    {
        return new Input(types, getValuesForUndo);
    }



    getAutoInput(output)
    {
        const inputs = this.headerInputs.filter(i => 
               i.canAutoConnect
            && i.canConnectFrom(output));

        
        if (   graphView.overInput
            && inputs.includes(graphView.overInput))
            return graphView.overInput;


        if (   graphView.savedConn
            && graphView.savedConn.input
            && graphView.savedConn.input.node == this)
            return graphView.savedConn.input;
        
        else if (!graphView.tempConn.output.node.isOrFollows(this))
        {
            if (this.variableInputs)
                return inputs.filter(i => !i.param).at(-1);

            else if (!isEmpty(inputs))
            {
                for (const input of inputs)
                {
                    if (!input.connected)
                        return input;
                }

                // at this point no empty inputs were found, so connect to the first one
                return inputs[0];
            }
        }


        return null;
    }



    getOutputId(output)
    {
        return output.param
             ? output.param.id
             : output.index.toString();
    }



    outputFromId(id)
    {
        return this.outputs.find(o => o.id == id);
    }



    addOutput(output, assign = true)
    {
        if (assign)
            output._node = this;

        this.outputs.push(output);
        this.outputControls.appendChild(output.div);
    }



    removeOutput(output)
    {
        output._node = null;

        removeFromArray(this.outputs, output);
        this.outputControls.removeChild(output.div);

        return output;
    }



    getUncachedInputNodes()
    {
        const uncachedNodes = [];

        for (const input of this.inputs)
        {
            if (input.connected)
            {
                const node = input.connectedOutput.node;

                if (!node.cached) pushUnique(uncachedNodes, node);
                pushUnique(uncachedNodes, node.getUncachedInputNodes());
            }
        }
        
        return uncachedNodes;
    }
 
 
 
    getAutoOutput(inputTypes)
    {
        const outputs = this.headerOutputs.filter(o => 
               o.types.includes(ANY_TYPE)
            || arraysIntersect(o.types, inputTypes));

        return  outputs.length == 1
            && !this.isOrFollows(graphView.tempConn.input.node)
            ? outputs[0]
            : null;
    }



    addBaseParams()
    {

    }



    paramFromId(id)
    {
        return this.params.find(p => p.id == id);
    }



    addParam(param, volatile = false)
    {
        param._node    = this;
        param.volatile = volatile;

        this.params.push(param);
        this.paramHolder.appendChild(param.div);

        if (param. input) this. inputs.push(param. input);
        if (param.output) this.outputs.push(param.output);

        return param;
    }
 
    

    insertParam(index, param, volatile = false)
    {
        param._node    = this;
        param.volatile = volatile;

        this.params.splice(index, 0, param);
        this.paramHolder.insertBefore(param.div, this.paramHolder.children[index]);

        if (param. input) this. inputs.splice(index, 0, param. input);
        if (param.output) this.outputs.splice(index, 0, param.output);

        return param;
    }
 
    

    createAndAddParamByType(type, id, showName, hasInput, hasOutput, volatile = false)
    {
             if (type ==    NUMBER_VALUE) return this.addParam(new    NumberParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      TEXT_VALUE) return this.addParam(new      TextParam(id, id,           hasInput, hasOutput), volatile);
        else if (type ==     COLOR_VALUE) return this.addParam(new     ColorParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      FILL_VALUE) return this.addParam(new      FillParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==    STROKE_VALUE) return this.addParam(new    StrokeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      LIST_VALUE) return this.addParam(new      ListParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type == RECTANGLE_VALUE) return this.addParam(new RectangleParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      LINE_VALUE) return this.addParam(new      LineParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   ELLIPSE_VALUE) return this.addParam(new   EllipseParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   POLYGON_VALUE) return this.addParam(new   PolygonParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      STAR_VALUE) return this.addParam(new      StarParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type == TEXTSHAPE_VALUE) return this.addParam(new TextShapeParam(id, id, showName, hasInput, hasOutput), volatile);

        else console.assert(false, 'cannot add parameter of type \'' + type + '\'');

        return null;
    }



    createAndInsertParamByType(index, type, id, showName, hasInput, hasOutput, volatile = false)
    {
             if (type ==    NUMBER_VALUE) return this.insertParam(index, new    NumberParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      TEXT_VALUE) return this.insertParam(index, new      TextParam(id, id,           hasInput, hasOutput), volatile);
        else if (type ==     COLOR_VALUE) return this.insertParam(index, new     ColorParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      FILL_VALUE) return this.insertParam(index, new      FillParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==    STROKE_VALUE) return this.insertParam(index, new    StrokeParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      LIST_VALUE) return this.insertParam(index, new      ListParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type == RECTANGLE_VALUE) return this.insertParam(index, new RectangleParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      LINE_VALUE) return this.insertParam(index, new      LineParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   ELLIPSE_VALUE) return this.insertParam(index, new   EllipseParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==   POLYGON_VALUE) return this.insertParam(index, new   PolygonParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type ==      STAR_VALUE) return this.insertParam(index, new      StarParam(id, id, showName, hasInput, hasOutput), volatile);
        else if (type == TEXTSHAPE_VALUE) return this.insertParam(index, new TextShapeParam(id, id, showName, hasInput, hasOutput), volatile);

        else console.assert(false, 'cannot insert parameter of type \'' + type + '\'');

        return null;
    }



    removeParam(param)
    {
        if (param.input)
        {
            if (param.input.connected)
                uiDisconnect(param.input);

            param.input._node = null;
            removeFromArray(this.inputs, param.input);
        }

        if (param.output)
        {
            for (const input of param.output.connectedInputs)
                uiDisconnect(input);

            param.output._node = null;
            removeFromArray(this.outputs, param.output);
        }


        if (this.paramHolder.contains(param.div))
            this.paramHolder.removeChild(param.div);
    
        removeFromArray(this.params, param);

        param._node = null;
    }



    getAllParamConnections()
    {
        const conns = [];

        for (let i = 0; i < this.params.length; i++)
        {
            const param = this.params[i];

            if (   param.input 
                && param.input.connected)
                conns.push(param.input.connection.toDataObject());

            if (param.output)
            {
                for (const input of param.output.connectedInputs)
                    conns.push(input.connection.toDataObject());
            }
        }

        return conns;
    }



    disconnectAllParams(deleteSavedConnections = false)
    {
        for (let i = this.params.length-1; i >= 0; i--)
        {
            const param = this.params[i];

            if (param.input && param.input.connected)
            {
                if (deleteSavedConnections)
                    uiDeleteSavedConn(param.input.connection);

                uiDisconnect(param.input);
            }

            if (param.output)
            {
                for (const input of param.output.connectedInputs)
                {
                    if (deleteSavedConnections)
                        uiDeleteSavedConn(input.connection);

                    uiDisconnect(input);
                }
            }
        }
    }



    removeAllParams()
    {
        for (let i = this.params.length-1; i >= 0; i--)
            this.removeParam(this.params[i]);
    }



    updateParamDisplay() // must be called at the end of each final Op constructor
    {
        for (const param of this.params)
            param.div.style.display = param.canShow() ? 'inline-block' : 'none';
    }



    getTabParams()
    {
        return this.params.filter(p => p.canShow());
    }



    setSelected(sel)
    {
        this._selected = sel;

        this.updateBorder();

        //if (deleteConnectionsDialogVisible)
        if (minZoomDialogVisible)
            hideDeleteConnectionsDialog();
    }
    


    makeActive()
    {
        this._active = true;

        if (    graphView
            &&  graphView.activeNodes
            && !graphView.activeNodes.includes(this))
            graphView.activeNodes.push(this);
    }



    makePassive()
    {
        if (!this._active) 
            return;
            
        if (graphView.activeNodes.includes(this))
            removeFromArray(graphView.activeNodes, this);

        this._active = false;
    }



    setName(newName, options = {})
    {
        this._name = newName;

        this.updateMeasureData();
        this.updateHeaderLabelOffsetX();

        return true;
    }



    setPosition(x, y, updateTransform = true)
    {
        //console.log('Operator.setPosition()');
   
        this.div.style.left = x + 'px';
        this.div.style.top  = y + 'px';

        if (updateTransform)
        {
            this.div.style.display = 'block';
            this.updateTransform();
        }

        this.updateMeasureData();
    }



    setSize(w, h, updateTransform = true)
    {
        this.div.style.width  = w + 'px';
        this.div.style.height = h + 'px';

        if (updateTransform)
        {
            this.div.style.display = 'block';
            this.updateTransform();
        }
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        console.log('Operator.setRect()');

        this.div.style.left   = x + 'px';
        this.div.style.top    = y + 'px';
        this.div.style.width  = w + 'px';
        this.div.style.height = h + 'px';

        if (updateTransform)
        {
            this.div.style.display = 'block';
            this.updateTransform();
        }
    }



    canAutoConnectFrom(output)
    {
        return false;
    }



    isCached()
    {
        for (const input of this.inputs)
        {
            if (    input.connected
                && !input.connectedOutput.node.isCached())
                return false;
        }

        return this.cached;
    }



    isConnectedUncached()
    {
        return this.inputs.find(i => i.isConnectedUncached());
    }



    isConnectedTo(node)
    {
        return this. inputs.find(i => i.connected && i.connectedOutput.node == node)
            || this.outputs.find(o => o.connected && o.connectedInputs.find(i => i.node == node));
    }



    isParallelTo(node)
    {
        return !this.follows(node)
            && !node.follows(this);
    }



    follows(node) 
    { 
        return this.isOrFollows(node, false); 
    }



    isOrFollows(node, considerIs = true)
    {
        if (   this == node
            && considerIs)
            return true;

        for (const input of this.inputs)
        {
            if (   input.connected
                && input.connectedOutput.node.isOrFollows(node))
                return true;
        }

        return false;
    }



    immediatelyFollows(node, headerOnly = false)
    {
        const inputs = 
            headerOnly 
            ? this.headerInputs 
            : this.inputs;

        for (const input of inputs)
        {
            if (   input.connected
                && input.connectedOutput.node == node)
                return true;
        }

        return false;
    }



    isMultiplier()
    {
        return false;
    }



    isOrPrecededByMultiplier()
    {
        return this.isMultiplier()
             ? true
             : this.hasMultipliedInputs();
    }



    isOrFollowedByMultiplier()
    {
        return this.isMultiplier()
             ? true
             : this.hasMultipliedOutputs();
    }



    hasMultipliedInputs()
    {
        for (const input of this.inputs)
            if (input.isMultiplied())
                return true;

        return false;
    }



    hasMultipliedOutputs()
    {
        for (const output of this.outputs)
            if (output.isMultiplied())
                return true;

        return false;
    }



    isUnknown()
    {
        return this.isConnectedUncached()
            && this.hasMultipliedOutputs();
    }



    paramCanBeUnknown(param)
    {
        return false;
    }



    paramIsConsideredDefault(param) // this has to be an op virtual method, not a param method
    {
        return param.isDefault()
            && (   !param.input 
                || !param.input.connected);
    }



    restoreParamUndoValue(value)
    {
        const param = this.params.find(p => p.id == value.paramId);

        if (value.type == NUMBER_VALUE)
        {
            param.controls[0].setMin(value.min, value.displayMin);
            param.controls[0].setMax(value.max, value.displayMax);
        }
            
        param.setValue(value.value, true, true, false);
    }
    
    

    reset() // for the entire generation run
    {
        for (const input of this.inputs)
        {
            input.currentSeed = input.initialSeed;
            
            if (input.connected)
                input.connectedOutput.node.reset();
        }
    }



    invalidate()
    {
        this.valid        = false;
        this.requestCache = [];

        for (const output of this.outputs)
        {
            output.cache = [];
            
            for (const input of output.connectedInputs)
                input.node.invalidate();
        }
    }



    genRequest(gen)
    {
        // this function exists because a node without outputs
        // should still be able to generate a request
        
        return [];
    }



    genRequestStart(gen, nodeOptions = 0)
    {
        const request = [
            this.type, 
            this.id,
            this.name ];


        const ignore = gen.passedNodes.includes(this);

        if (!ignore)
        {
            const nextActive   = getActiveAfterNode(this);
            const beforeActive = nextActive && nextActive.follows(this);

            const options =
                  ((this.active  ? 1 : 0) << 0)
                | ((beforeActive ? 1 : 0) << 1)
                | ((this.enabled ? 1 : 0) << 2)
                | ((this.cached  ? 1 : 0) << 3)
                //| ((this.isCached() ? 1 : 0) << 3)
                | nodeOptions;

            request.push(options);
        }


        return [request, ignore];
    }



    setTransform(nodeLeft, nodeTop, nodeRect)
    {
        this.div.style.transform =
              'translate(' 
            + (graph.currentPage.pan.x * graph.currentPage.zoom) + 'px, '
            + (graph.currentPage.pan.y * graph.currentPage.zoom) + 'px) '
            + 'scale(' + graph.currentPage.zoom + ')';

        this.div.style.transformOrigin = 
              ((graph.currentPage.pan.x - nodeLeft) / nodeRect.width  * 100) + '% ' 
            + ((graph.currentPage.pan.y - nodeTop ) / nodeRect.height * 100) + '%';  
    }



    getOffsetRect()
    {
        const ox   = -graph.currentPage.pan.x / graph.currentPage.zoom;
        const oy   = -graph.currentPage.pan.y / graph.currentPage.zoom;

        const rect = boundingRect(this.div);

        return new DOMRect(
            ox + (rect.left / graph.currentPage.zoom),
            oy + (rect.top  / graph.currentPage.zoom),
            rect.width      / graph.currentPage.zoom, 
            rect.height     / graph.currentPage.zoom);
    }



    getHeaderColors(options = {})
    {
        const rgbaBack = 
            this.inert
            ? rgb_a(rgbDocumentBody, 0.95)
            : rgb_a(rgbFromType(this.type, this.active), 0.95);

            
        const rgbaBorder = rgb_a(rgbFromType(this.type, this.active), 0.95);

        const rgbaText   = isDark(rgbaBack) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        const colInput   = this.active ? rgb_a(rgbaText, 0.4 ) : rgb_a(rgbSaturateHsv(rgbFromType(this.type, true), 0.5), 0.8);
        const colOutput  = this.active ? rgb_a(rgbaText, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(this.type, true), 0.5), 0.7);
        
        const colWire    = rgbFromType(this.type, true);

        
        return {
            back:   rgbaBack, 
            border: rgbaBorder,
            text:   rgbaText,
            input:  colInput,
            output: colOutput,
            wire:   colWire };
    }



    getActiveOffset()
    {
        return 4;
    }



    getDefaultOffset()
    {
        return 0;
    }



    connectToSelected(selected)
    {
        console.assert(!isEmpty(selected));

        const node   = selected[0];
        const inputs = this.inputs.filter(i => i.types.includes(node.type));
    
        if (   node
            && !isEmpty(node.outputs)
            && !isEmpty(inputs))
            actionManager.do(new ConnectAction(node.outputs[0], inputs[0]), true);
    }



    updateConnectedInputValueText() {}



    toJson(nTab = 0) 
    {
        let pos = ' '.repeat(nTab);
        

        let json = 
              pos + '{\n'
            + this.toJsonBase(nTab);

        const nonDefaultParams = this.params.filter(p => !this.paramIsConsideredDefault(p));

        if (    (  !isEmpty(nonDefaultParams) // don't include empty param section
                 || this.alwaysSaveParams)
             && this.saveParams)
            json += this.paramsToJson(nTab);

        json += '\n' + pos + '}';


        return json;
    }



    toJsonBase(nTab)
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let json =
              pos + tab + '"type": "'    + this.type                                     + '",\n'
            + pos + tab + '"id": "'      + (this.stripIdForCopy ? this.nodeId : this.id) + '",\n'
            + pos + tab + '"name": "'    + this.name.replace('"', '\\\"')                + '",\n'
            + pos + tab + '"renamed": "' + boolToString(this.renamed)                    + '",\n'
            + pos + tab + '"enabled": "' + boolToString(this.enabled)                    + '",\n'
            + pos + tab + '"x": "'       + parseFloat(this.div.style.left)               + '",\n'
            + pos + tab + '"y": "'       + parseFloat(this.div.style.top )               + '",\n'
            + pos + tab + '"z": "'       + graph.nodes.indexOf(this)                     + '"';

        if (this.active)
            json += ',\n' + pos + tab + '"active": "' + this.active + '"';

        this.stripIdForCopy = false;

        return json;
    }



    paramsToJson(nTab = 0)
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;


        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
        
            
        let first = true;
        for (const param of this.params)
        {
            if (  !param.isDefault()
                || this.alwaysSaveParams)
            {
                if (!first) json += ',\n'; first = false;
                json += pos + tab + tab + param.toJson(nTab);
            }
        }


        if (!first)
            json += '\n';

        json += pos + tab + ']';

        
        return json;
    }



    loadFromParsedJson(_node, pasting)
    {
        this.id   = _node.id;
        this.name = _node.name;
    
        if (_node.renamed != undefined)
            this.renamed = parseBool(_node.renamed);

        if (_node.enabled)
            this.enabled = parseBool(_node.enabled);
    
        if (   _node.params
            || this.alwaysLoadParams)
            this.loadParams(_node, pasting);
    }



    loadParams(_node, pasting)
    {
        if (!_node.params)
            return;
            
        for (const _param of _node.params)
        {
            let index = this.params.findIndex(p => p.id == _param[1]);

            if (index < 0)
            {
                this.createAndAddParamByType(_param[0], _param[1], false, false, true, true);
                index = this.params.length-1;
            }

            this.params[index].loadParam(_param);
        }
    }



    toString() 
    { 
        // create the generator string here

        return '';
    }



    toJavascript(gen)
    {
        return '';
    }



    toJsDefs(gen)
    {
        return '';
    }



    toJsCode(gen)
    {
        return '';
    }
}



function getHeaderConnY(conns)//, padding, offset)
{
    const y      = [];
    let   height = 0;
    
    for (let i = 0; i < conns.length; i++)
    {
        if (i > 0) height += connectionGap;
        y.push(/*offset + padding*/ + height);
        height += connectionSize;
    }

    return [y, height];
}



function createGenObject(paramNode, terminals)
{
    return {
        terminals:   terminals,
        scope:       paramNode ? [{nodeId: paramNode.id, paramId: NULL}] : [],
        passedNodes: [],
        paramNodes:  [],
        markParams:  true
    };    
}



function areConnected(node1, node2)
{
    return node1.isOrFollows(node2)
        || node2.isOrFollows(node1);
}



function onVariableConnectInput(node)
{
    node.addNewInput();
}



function onVariableDisconnectInput(node, input)
{
    removeFromArray(node.inputs, input);
    node.inputControls.removeChild(input.div);
}



function getNodeInputValuesForUndo(input)
{
    const values = []; 

    for (const param of input.node.params)
        values.push(param.getValueForUndo());

    return values;
}



function getNodeOutputValuesForUndo(output)
{
    const values = []; 

    for (const param of output.node.params)
        values.push(param.getValueForUndo());

    return values;
}



function getParamInputValuesForUndo(input)
{
    return [input.param.getValueForUndo()];
}



function getParamOutputValuesForUndo(output)
{
    return [output.param.getValueForUndo()];
}



function nodesAreParallel(nodes)
{
    for (let i = 0; i < nodes.length-1; i++)
        for (let j = i + 1; j < nodes.length; j++)
            if (!nodes[i].isParallelTo(nodes[j]))
                return false;

    return true;
}



// function restoreNodeUndoValues(node, values)
// {
//     for (const value of values)
//     {
//         const param = node.params.find(p => p.id == value.paramId);

//         if (param)
//         {
//             if (   value.min != undefined
//                 && value.max != undefined)
//             {
//                 param.controls[0].setMin(value.min);
//                 param.controls[0].setMax(value.max);
//             }
                
//             param.setValue(value.value, true, true, false);
//         }
//     }
// }



function makeNodePath(id)
{
    return graph.currentPage.id + '/' + id;
}



function idFromNodePath(path)
{
    return path.split('/').at(-1);
}


var  newReorderIndex = Number.NaN;
var prevReorderIndex = Number.NaN;
var  oldReorderIndex = Number.NaN;



Operator.prototype.createNode = function()
{
    this.div                    = createDiv('node');
    this.div.node               = this;
       
    this.div.style.width        = this.defaultWidth + 'px';
           
    this.div.over               = false;
    this.div.dragging           = false;
    this.div.shiftOnPointerDown = false;
    this.div.moved              = false;
    
    this.enterTimer             = null;


    this.inner = createDiv('nodeInner');
    this.div.appendChild(this.inner);


    this.div.addEventListener('pointerenter', e =>
    {
        this.div.over      = true;
        graphView.overNode = this;
        
        if (    e.altKey
            && !getCtrlKey(e)
            && !e.shiftKey
            &&  graphView._soloNode != this
            && !altPressedInMenu) 
            graphView.soloNode(this);
        
        this.updateNode();
    });

    
    this.div.addEventListener('pointerleave', e =>
    {
        this.div.over      = false;
        graphView.overNode = null;
        
        if (   (  !e.altKey
                || getCtrlKey(e)
                || e.shiftKey)
            && graphView._soloNode == this)
            graphView.unsoloNode();

        this.updateNode();
    });

    
    this.paramHolder = createDiv('nodeParamBack');


    this.createHeader();
    this.createInfo();


    this.inner.appendChild(this.paramHolder);


    this.subscribeCover = createDiv('subscribeCover');

    this.subscribeCover.addEventListener('pointerenter', e => { e.preventDefault(); e.stopImmediatePropagation(); });
    this.subscribeCover.addEventListener('pointermove',  e => { e.preventDefault(); e.stopImmediatePropagation(); });
    this.subscribeCover.addEventListener('pointermove',  e => { e.preventDefault(); e.stopImmediatePropagation(); });

    this.subscribeLabel = createDiv('subscribeLabel');
    this.subscribeLabel.innerHTML = 'SUBSCRIBE';

    this.div.appendChild(this.subscribeCover);
    this.div.appendChild(this.subscribeLabel);
}     



Operator.prototype.createHeader = function()
{
    this.header = createDiv('nodeHeader');
    
    this.header.connectionPadding = 8;
    this.header.ignoreDoubleClick = false; // used by child objects that need to be double clicked


    this.createLabel();
    this.initLabelTextbox();

    
    this. inputControls = createDiv('inputControls' );
    this.outputControls = createDiv('outputControls');
    this.reorderArrows  = createDiv('reorderArrows' );

    this.header.appendChild(this. inputControls);
    this.header.appendChild(this.outputControls);
    this.header.appendChild(this. reorderArrows);

    
    this.inner.appendChild(this.header);



    this.header.addEventListener('pointerdown', e =>
    {
        if (graphView.isPanning(e))
            return;


        window.focus();


        e.preventDefault();


        // I don't want to focus here, but I do want to take focus away from elsewhere
        document.activeElement.blur();


        graphView.lastSelectedNodes = [...graphView.selectedNodes];
        
        graphView.putNodeOnTop(this);


        for (const param of this.params)
        {
            if (param.textboxHasFocus())
                param.controls[0].textbox.finish(true);
        }


        if (e.button == 0)
            hideAllMenus();


        if (   e.button == 0
            || e.button == 2)
        {
            this.div.shiftOnPointerDown = 
                    e.shiftKey
                && !getCtrlKey(e)
                && !e.altKey;
        }


        if (    e.button == 0
            && !graphView.overOutput
            && !graphView.overInput)
        {
            e.stopPropagation();

            graphView.selectFromClick(this, getCtrlKey(e), e.shiftKey, e.altKey);
                        
            this.sx = e.clientX;
            this.sy = e.clientY;

            for (const n of graphView.selectedNodes)
            {
                n.slx = n.div.offsetLeft;
                n.sly = n.div.offsetTop;
            }

            this.div.dragging = true;
            this.header.setPointerCapture(e.pointerId);
        }

        else if (e.button == 2)
        {
            e.stopPropagation();

            graphView.selectFromClick(this, getCtrlKey(e), e.shiftKey, e.altKey);

            menuNode.showAt(e.clientX, e.clientY, false);
        }

        
        updateGraphNodes();
    });



    this.header.addEventListener('pointermove', e =>
    {
        if (graphView.isPanning(e))
            return;


        const headerRect = boundingRect(this.header);

        const rightOfInputs = e.clientX - headerRect.x > 12 * graph.currentPage.zoom;
        const leftOfOutputs = e.clientX - headerRect.x < headerRect.width - 12 * graph.currentPage.zoom;

        const tempConn  = graphView. tempConn;
        let   savedConn = graphView.savedConn;


        if (this.div.dragging)
        {
            const x       = graphView.div.clientLeft;
            const w       = graphView.div.clientWidth;
            const h       = graphView.div.clientHeight;
            const bounds  = graphView.getAllNodeBounds();

            const yOffset = getTopHeight();

            graphView.setNodePositions(
                graphView.selectedNodes,
                (e.clientX - this.sx) / graph.currentPage.zoom,
                (e.clientY - this.sy) / graph.currentPage.zoom);
            
            this.div.moved = true;

            graphView.updateScroll(x, w, h, bounds, yOffset);
        }
        else if (   tempConn
                 && rightOfInputs
                 && leftOfOutputs)
        {
            if (    tempConn.output
                && !tempConn.output.node.isOrFollows(this))
            {
                if (   this.variableInputs
                    && savedConn
                    && this == savedConn.input.node)
                {
                    const rect    = boundingRect(this.div);
                    const padding = this.header.connectionPadding;


                    const index = Math.min(Math.max(0, Math.round(
                          ((e.clientY - rect.y) / graph.currentPage.zoom - padding - (connectionSize + connectionGap)/2) 
                        / (connectionSize + connectionGap))),
                        this.headerInputs.length-(this.headerInputs.length > 1 ? 2 : 1));

                    if (index != prevReorderIndex)
                    {
                        newReorderIndex = index;

                        moveInArray(
                            this.inputs, 
                            this.inputs.indexOf(savedConn.input),
                            newReorderIndex);

                        this.updateNode();
                         
                        prevReorderIndex = newReorderIndex;
                    }

                    
                    graphView.overInput   = savedConn.input;
                    graphView.headerInput = savedConn.input;

                    graphView.overInput.updateControl();

                    
                    const inputRect = boundingRect(savedConn.input.div);

                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - getTopHeight());
                }
                else
                {
                    const input = this.getAutoInput(tempConn.output);
                    if (!input) return;

                    graphView.overInput   = input;
                    graphView.headerInput = input;
                    //console.log('headerInput = ', graphView.headerInput);
                        
                    input.mouseOver = true;
                    input.updateControl();

                    const inputRect = boundingRect(input.div);
                    
                    tempConn.wire.inputPos = point(
                        inputRect.x + inputRect.w/2,
                        inputRect.y + inputRect.h/2 - getTopHeight());
                }
            }
            else if ( tempConn.input
                  && !this.isOrFollows(tempConn.input.node))
            {
                const output = this.getAutoOutput(tempConn.input.types);
                if (!output) return;

                graphView.overOutput   = output;
                graphView.headerOutput = output;
                //console.log('headerOutput = ', graphView.headerOutput);
                    
                output.mouseOver = true;
                output.updateControl();


                const rect = boundingRect(output.div);

                tempConn.wire.outputPos = point(
                    rect.x + rect.w/2,
                    rect.y + rect.h/2 - getTopHeight());


                tempConn.input.updateControl();
            }
        }
    });



    this.header.addEventListener('pointerup', e =>
    {
        if (graphView.isPanning(e))
            return;


        if (   e.button == 0
            && this.div.dragging)
        {
            if (this.div.moved)
            {
                actionManager.do(new SelectMoveNodesAction(
                    graphView.lastSelectedNodes.map(n => n.id), 
                    graphView.selectedNodes.map(n => n.id), 
                    point(this.slx, this.sly),
                    point(this.div.offsetLeft, this.div.offsetTop),
                    this.div.shiftOnPointerDown));
            }
            else if (!arraysAreEqual(graphView.selectedNodes, graphView.lastSelectedNodes))
            {
                actionManager.do(new SelectNodesAction(
                    graphView.selectedNodes    .map(n => n.id), 
                    graphView.lastSelectedNodes.map(n => n.id)));
            }

            this.div.dragging = false;
            this.header.releasePointerCapture(e.pointerId);
        }

        else if (graphView.tempConn)
        {
            if (    graphView.tempConn.output
                && !graphView.tempConn.output.node.isOrFollows(this)
                &&  graphView.overInput)
            {
                const overInput = graphView.overInput;

                graphView          .endConnection(e.pointerId, getCtrlKey(e));
                graphView.overInput.endConnection();

                if (!graphView.headerInput)
                    graphView.overInput = overInput; // to be able to use the input again immediately
            }
            else if ( graphView.tempConn.input
                  && !this.isOrFollows(graphView.tempConn.input.node)
                  &&  graphView.overOutput)
            {
                const overOutput = graphView.overOutput;

                graphView           .endConnection(e.pointerId, getCtrlKey(e));
                graphView.overOutput.endConnection();

                if (!graphView.headerOutput)
                    graphView.overOutput = overOutput; // to be able to use the output again immediately
            }
        }


        this.div.shiftOnPointerDown = false;
    });
    
    

    this.header.addEventListener('pointerleave', e => 
    { 
        if (graphView.tempConn)
        {
            if (   graphView.tempConn.output
                && graphView.tempConn.output.node != this)
            {
                const input = graphView.headerInput;
                
                graphView.overInput   = null;
                
                if (input) // will be null if data types don't match or there's no auto input for someo other reason
                {
                    input.mouseOver = false;
                    input.updateControl();
                }
                
                graphView.tempConn.wire.inputPos = point_NaN;
                graphView.tempConn.output.updateControl();
            }
            else if (graphView.tempConn.input
                  && graphView.tempConn.input.node !=  this)
            {
                const output = graphView.headerOutput;
                
                graphView.overOutput   = null;

                if (output) // will be null if data types don't match or there's no auto output for someo other reason
                {
                    output.mouseOver = false;
                    output.updateControl();
                }

                graphView.tempConn.wire.outputPos = point_NaN;
                graphView.tempConn.input.updateControl();
           }

           graphView.headerInput  = null;
           graphView.headerOutput = null;
        }
    });



    this.header.addEventListener('dblclick', e =>
    {
        e.preventDefault();

        
        const bounds = boundingRect(this.label);

        if (  !getCtrlKey(e)
            && e.clientX >= bounds.left && e.clientX < bounds.right
            && e.clientY >= bounds.top  && e.clientY < bounds.bottom)
            this.showLabelTextbox();
        else if (!this.header.ignoreDoubleClick)
            actionManager.do(new MakeActiveNodesAction([this.id]));

        this.header.ignoreDoubleClick = false;
    });
};



Operator.prototype.createInfo = function()
{
    this.divDisabled = createDiv();
    this.div.appendChild(this.divDisabled);

    this.divDisabled.style.display       = 'none';
    this.divDisabled.style.position      = 'absolute';
    this.divDisabled.style.width         =  5;
    this.divDisabled.style.height        =  100;
    this.divDisabled.style.background    = '#e88b';
    this.divDisabled.style.pointerEvents = 'none';
    //this.divDisabled.style.zIndex        = 100;
};



Operator.prototype.createProgressBar = function()
{
    this.hasProgressBar  = true;

    this.progressWrapper = createDiv('progressWrapper');
    this.progressBar     = createDiv('progressBar');

    this.progressWrapper.appendChild(this.progressBar);
    this.header         .appendChild(this.progressWrapper);
};



Operator.prototype.initProgress = function()
{
    this.progressWrapper.style.display = 'block';

    this.progressBar    .style.left    = '0%';
    this.progressBar    .style.width   = '100%';
};



Operator.prototype.updateProgress = function(progress)
{
    this.progressBar.style.left  = (   progress  * 100) + '%';
    this.progressBar.style.width = ((1-progress) * 100) + '%';
};



Operator.prototype.endNodeProgress = function()
{
    this.progressWrapper.style.display = 'none';
};


Operator.prototype.createLabel = function()
{
    this.labelWrapper   = createDiv('nodeLabelWrapper');
  
    this.label          = createDiv('nodeLabel');
    this.label.node     = this;
    
    this.labelText      = createDiv('nodeLabelText');
    this.labelText.node = this;
    
    this.label       .appendChild(this.labelText);
    this.labelWrapper.appendChild(this.label);
    this.header      .appendChild(this.labelWrapper);


    this.labelWrapper.addEventListener('pointerdown', e =>
    {
        e.preventDefault();
    });

    
    this.labelWrapper.addEventListener('pointermove', e =>
    {
        if (!this.scrollName)
            return;

        const wrect      = boundingRect(this.labelWrapper);
        const margin     = 14;
        const viewMargin = margin * graph.currentPage.zoom;
        
        const x          = e.clientX - wrect.x;

             if (x <  viewMargin)               this.updateHeaderLabelOffsetX(0);
        else if (x >= wrect.width - viewMargin) this.updateHeaderLabelOffsetX(1);
        else if (x >= viewMargin
              && x <  wrect.width - viewMargin) this.updateHeaderLabelOffsetX((x - viewMargin) / (wrect.width - viewMargin*2));
        else                                    this.updateHeaderLabelOffsetX();
    });
};



Operator.prototype.updateHeaderLabelOffsetX = function(f = this.labelOffsetFactor)
{
    //console.log('updateHeaderLabelOffsetX()');

    this.labelOffsetFactor = Math.min(Math.max(0, f), 1);


    const margin     = 15;
    const viewMargin = margin * graph.currentPage.zoom;

    const wrect      = this.measureData.labelWrapperBounds;
    const rect       = this.measureData.labelBounds;

    const rw         = wrect.width - viewMargin*2;
    const sf         = rw / nozero(rect.width);
    const df         = viewMargin / rect.width / 2;
        
    const s1         = this.labelOffsetFactor * (rect.width - rw) / rect.width;
    const s0         = s1 - df;
    const s2         = s1 + sf;
    const s3         = s2 + df;


    const activeOffset = this.getActiveOffset();
    const defOffset    = this.getDefaultOffset();


    if (rect.width > rw)
    {
        this.label.style.left = 
            11 
            - this.labelOffsetFactor * (rect.width - rw - 1) / graph.currentPage.zoom
            + (this.active ? activeOffset : 0);
            
        this.label.style.transform = 'none';
    }
    else
    {
        this.label.style.left = 
              'calc(50%' 
            + (this.active && this.showActiveArrow ? (' + ' + activeOffset + 'px') : (' + ' + defOffset + 'px')) 
            + ')';

        this.label.style.transform = 'translateX(-50%)';
    }


    const color = 
        this.label.style.color.trim() != ''
        ?  this.label.style.color
        : 'black';

    this.label.style.background = 
          'linear-gradient(90deg, '
        + '#0000 '     + (s0 * 100) + '%, '
        +  color + ' ' + (s1 * 100) + '%, '
        +  color + ' ' + (s2 * 100) + '%, '
        + '#0000 '     + (s3 * 100) + '%)';

    this.label.style.WebkitBackgroundClip = 'text';
    this.label.style.WebkitTextFillColor  = 'transparent';
};


Operator.prototype.initLabelTextbox = function()
{
    this.textbox = createTextbox('nodeLabelTextbox');
    
    this.textbox.spellcheck     = false;
    this.textbox.keyboardFinish = false;
    


    this.textbox.addEventListener('keydown', e =>
    {
        e.stopPropagation();


        if (   e.code == 'KeyC'
            && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('copy');
        }

        else if (e.code == 'KeyV'
              && getCtrlKey(e))
        {
            e.preventDefault();
            document.execCommand('paste');
        }
        
        else if (e.code == 'Enter'
              || e.code == 'NumpadEnter')
        {
            this.textbox.keyboardFinish = true;
            this.textbox.finish(true);
        }

        else if (e.code == 'Escape')
        {
            this.textbox.keyboardFinish = true;
            this.textbox.finish(false);
        }

        else if (e.code == 'Tab')
        {
            e.preventDefault();
            
            const tabs  = document.querySelectorAll('.node, .figmaSelect, .menuSelect #hexValue, button');
            const index = this.tabIndex;

            for (let i = 0; i < tabs.length; i++) 
            {
                if (   e.shiftKey && tabs[i].tabIndex == index - 1
                    ||               tabs[i].tabIndex == index + 1) 
                {
                    if (tabs[i].className == 'node')
                        tabs[i].showTextbox();
                    else 
                    {
                        document.activeElement.blur();
                        tabs[i].focus();
                    }

                    break;
                }
            }
        }

        else if (e.key == 'Alt')
            e.preventDefault();
    });


    
    // this.textbox.addEventListener('input', function()
    // {
    //     this.setValue(parseFloat(this.textbox.value));
    // });



    this.textbox.addEventListener('pointerdown', e => e.stopPropagation());
    this.textbox.addEventListener('pointermove', e => this.textbox.style.cursor = 'default');



    this.textbox.addEventListener('pointerup', e =>
    {
        e.stopPropagation();

        if (e.button == 2)
        {
            initTextMenu(this.textbox);
            menuText.showAt(e.clientX, e.clientY, false, false);
        }
    });



    // this.textbox.addEventListener('paste', e =>
    // {
    //     e.preventDefault();
    //     this.textbox.value = e.clipboardData.getData('text/plain');
    // });

    
    
    this.textbox.addEventListener('focus', () => this.textbox.keyboardFinish = false);

    
    
    this.textbox.addEventListener('focusout', () =>
    {
        if (    this.textbox.value != ''
            && !this.textbox.keyboardFinish)
            this.textbox.finish(true);

            this.label.style.display = 'block';

        this.header.removeChild(this.textbox);
        this.clicked = false;
    });
    


    this.textbox.finish = success =>
    {
        const enteredValue = this.textbox.value     .trim();
        const   savedValue = this.textbox.savedValue.trim();

        if (success) 
        {
            if (   enteredValue != ''
                && enteredValue != savedValue)
            {
                const newName = this.textbox.value;
                setTimeout(() => this.setName(newName));
                actionManager.do(new RenameNodeAction(this.id, newName));
            }
        }
        else
            this.textbox.value = this.textbox.savedValue;


        this.textbox.dispatchEvent(new CustomEvent('finishedit', { 'detail': {
            'success':  success,
            'value':    enteredValue,
            'oldValue': savedValue }}));
    

        this.textbox.blur();
        
        this.label.style.display = 'block';

        setTimeout(() => 
        {
            this.updateHeaderLabel();
            
            if (this.inFocus)
                this.div.focus();
        });
    };    
}



Operator.prototype.showLabelTextbox = function()
{
    this.inFocus = 
            hasFocus(this.div)
        && !this.clicked;

    this.textbox.style.width           = this.header.offsetWidth  - 2;
    this.textbox.style.height          = this.header.offsetHeight - 4;
    this.textbox.style.position        = 'absolute';
    this.textbox.style.left            = '50%';
    this.textbox.style.top             = '50%';
    this.textbox.style.transform       = 'translateX(-50%) translateY(-50%)';
    this.textbox.style.textAlign       = 'center';
  //this.textbox.style.boxShadow       = '0 0 0 1px #a0a inset';

    this.textbox.style.backgroundColor = this.header.style.backgroundColor;
    this.textbox.style.color           = this.label.style.color;

    this.textbox.value                 = this.name;
    this.textbox.savedValue            = this.textbox.value;
    
    this.header.appendChild(this.textbox);

    this.label.style.display           = 'none';
    
    this.updateNode();
    
    this.textbox.focus();
    this.textbox.select();
}



Operator.prototype.updateTransform = function()
{
    const nodeLeft = this.div.offsetLeft;
    const nodeTop  = this.div.offsetTop;
    const nodeRect = this.getOffsetRect();
    
    this.setTransform(nodeLeft, nodeTop, nodeRect);
    this.updateWireTransform();
}



Operator.prototype.updateWireTransform = function()
{
    const wires = [];

    for (const input of this.inputs)
        if (   input.connected
            && input.connection)
            wires.push(input.connection.wire);        

    for (const output of this.outputs)
        for (const connInput of output.connectedInputs)
            if (connInput.connection)
                wires.push(connInput.connection.wire);

    graphView.updateWires(wires);
}



Operator.prototype.updateNode = function() 
{
    this.updateHeader();
    this.updateHeaderLabel();
    this.updateBorder();
    this.updateParams();
    this.updateDisabled();
    this.updateSubscribe();


    if (  !isEmpty(this.params.filter(p => p.isVisible()))
        || this.sharpBottomCorners)
    {
        this.div   .style.borderBottomLeftRadius  = '0px';        
        this.inner .style.borderBottomLeftRadius  = '0px';        
        this.header.style.borderBottomLeftRadius  = '0px';        

        this.div   .style.borderBottomRightRadius = '0px';        
        this.inner .style.borderBottomRightRadius = '0px';        
        this.header.style.borderBottomRightRadius = '0px';        
    }
    else
    {
        this.div   .style.borderRadius = '4px';        
        this.inner .style.borderRadius = '4px';        
        this.header.style.borderRadius = '4px';        
    }
}



Operator.prototype.updateBorder = function()
{
    const scale = 
        graph.currentPage.zoom >= 1
        ? 3
        : 3 * (((1 / graph.currentPage.zoom - 1) / 2) + 1);

    this.div.style.boxShadow = 
        this._selected
        ? '0 0 0 ' + scale + 'px var(--figma-color-bg-brand)'
        : 'none';
}



Operator.prototype.updateHeader = function()
{
    //console.log(this.id + '.Operator.updateHeader()');
    
    const height = this.updateHeaderInputsAndOutputs();

    this.header.style.height = height;

    
    this.updateHeaderLabel();
    this.updateReorderArrows();


    const colors = this.getHeaderColors();


    if (this.progressBar)
    {
        this.progressBar.style.background = 
            !rgbIsNaN(colors.back) 
            ? rgb2style_a(colors.text, 0.5) 
            : 'var(--figma-color-bg-brand)';
    }
}



Operator.prototype.updateParams = function()
{
    for (const param of this.params)
        param.enableControlText(true);

    this.updateParamControls();
}



Operator.prototype.updateParamControls = function()
{
    for (const param of this.params)
        param.updateControls();
}



Operator.prototype.updateDisabled = function()
{
    if (!this.measureData)
        return;

    const height = Math.min(this.measureData.divOffset.width, this.measureData.divOffset.height) + 70;

    this.divDisabled.style.display   = this.enabled ? 'none' : 'inline-block';
    this.divDisabled.style.zIndex    = 10000;
    this.divDisabled.style.height    = height;
    this.divDisabled.style.transform = 'rotate(45deg)';
    this.divDisabled.style.left      = (this.measureData.divOffset.width  - this.measureData.disabledOffset.width ) / 2;
    this.divDisabled.style.top       = (this.measureData.divOffset.height - height) / 2;
}



Operator.prototype.updateSubscribe = function()
{
    if (!this.measureData)
        return;

    this.subscribeCover.style.top    = this.measureData.headerOffset.height;
    this.subscribeCover.style.height = this.measureData.divOffset.height - this.measureData.headerOffset.height;
}



Operator.prototype.updateSubscribeStatus = function(subscribed)
{
    const sub = 
            subscribed
        || !this.subscription;


    this.subscribeCover.style.display = !sub ? 'block' : 'none';
    this.subscribeLabel.style.display = !sub ? 'block' : 'none';

    this.inner.style.opacity = !sub ? '50%' : '100%';


    if (!sub)
        this.updateSubscribe();
}



Operator.prototype.updateMeasureData = function()
{
    this.measureData = 
    {
        divBounds:          boundingRect(this.div),
        divOffset:          offsetRect  (this.div),
        innerOffset:        offsetRect  (this.inner),
        headerOffset:       offsetRect  (this.header),
        labelWrapperBounds: boundingRect(this.labelWrapper),
        labelWrapperOffset: offsetRect  (this.labelWrapper),
        labelBounds:        boundingRect(this.label),
        labelOffset:        offsetRect  (this.label),
        disabledOffset:     offsetRect  (this.divDisabled),
        subscribeOffset:    offsetRect  (this.subscribeLabel)
    };

    this.params
        .forEach(p =>
        {
            for (const control of p.controls)
                control.updateMeasureData();

            if (p. input) p. input.updateMeasureData();
            if (p.output) p.output.updateMeasureData();
        });
}



Operator.prototype.updateHeaderLabel = function()
{
    this.updateHeaderLabelText();

    
    this.label.style.top = 
          (  Math.floor(this.measureData.labelWrapperOffset.height/2 - this.measureData.labelOffset.height/2)
           + Math.min(Math.max(1, 1/graph.currentPage.zoom), 2)
           - (settings.showNodeId ? 1 : 0))
        + 'px';


    this.updateHeaderLabelOffsetX();


    const colors = this.getHeaderColors();

    
    let fontSize = 11;

    // compensate for bold active header names look THINNER when zoomed out
         if (graph.currentPage.zoom < 0.5 ) fontSize = 17;
    else if (graph.currentPage.zoom < 0.75) fontSize = 15;
    else if (graph.currentPage.zoom < 1   ) fontSize = 13;
    else if (graph.currentPage.zoom < 1.5 ) fontSize = 12;

    this.label.style.color      = rgba2style(colors.text);
    this.label.style.fontSize   = this.active ? fontSize : 11;
    this.label.style.height     = this.active ? fontSize * 15 / 11 : 15;

    this.label.style.fontWeight = graph.currentPage.zoom < 1.2 ? '600' : 'normal';
}



Operator.prototype.updateHeaderLabelText = function()
{
    this.labelText.innerHTML = 
          (settings.showNodeId ? '/'+this.nodeId : this.name + (this.cached ? '' : '...'))
        + (this.active && this.showActiveArrow ? (settings.showNodeId ? ' ' : '') + '' : '');

    this.labelText.style.fontFamily = 
        settings.showNodeId 
        ? 'Roboto Mono' 
        : 'Inter';
}



Operator.prototype.updateReorderArrows = function()
{
    if (this.showReorderArrows)
    {
        const colors     = this.getHeaderColors();
        const arrowStyle = rgba2style(rgb_a(isDark(colors.back) ? [1, 1, 1] : [0, 0, 0], 0.5));

        this.reorderArrows.style.display            = 'inline-block';
        this.reorderArrows.style.background         = 'url(\'data:image/svg+xml;utf8,<svg width="5" height="8" viewBox="0 0 5 8" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 8L5 5H0L2.5 8Z" fill="'+arrowStyle+'"/><path d="M2.5 0L5 3H0L2.5 0Z" fill="'+arrowStyle+'"/></svg>\')';
        this.reorderArrows.style.backgroundPosition = '50% 50%';
        this.reorderArrows.style.backgroundRepeat   = 'no-repeat';
    }
    else
        this.reorderArrows.style.display            = 'none';    
};



Operator.prototype.updateHeaderInputsAndOutputs = function()
{
    let height = defHeaderHeight;


    const inputs  = this.headerInputs;
    const outputs = this.headerOutputs;

    let [ inputY,  inputHeight] = getHeaderConnY(inputs);
    let [outputY, outputHeight] = getHeaderConnY(outputs);


     inputHeight += this.header.connectionPadding * 2;
    outputHeight += this.header.connectionPadding * 2;


         if ( inputHeight > outputHeight) for (let i = 0; i < outputs.length; i++) outputY[i] += (inputHeight - outputHeight)/2;
    else if (outputHeight >  inputHeight) for (let i = 0; i < inputs .length; i++)  inputY[i] += (outputHeight - inputHeight)/2;     


    const maxHeight = Math.max(inputHeight, outputHeight);

    if (maxHeight > height) 
        height = maxHeight;
    else
    {
        for (let i = 0; i < inputs .length; i++)  inputY[i] += (height - maxHeight)/2;
        for (let i = 0; i < outputs.length; i++) outputY[i] += (height - maxHeight)/2;
    }


    for (let i = 0; i < inputs .length; i++)  inputY[i] += connectionSize/2 + this.header.connectionPadding;
    for (let i = 0; i < outputs.length; i++) outputY[i] += connectionSize/2 + this.header.connectionPadding;


    for (let i = 0; i < inputs.length; i++)
    {
        inputs[i].div.style.top = inputY[i];
        inputs[i].updateControl();
    }

    for (let i = 0; i < outputs.length; i++) 
    {
        outputs[i].div.style.top = outputY[i];
        outputs[i].updateControl();
    }


    return height;
}



Operator.prototype.updateValues = function(requestId, actionId, updateParamId, paramIds, values) // virtual
{
    for (let i = 0; i < paramIds.length; i++)
    {
        const index = this.params.findIndex(p => p.id == paramIds[i]);

        if (   paramIds[index] != updateParamId
            && index > -1)
            this.params[index].setValue(values[i], false, true, false);
    }
}


class OperatorBase
extends Operator
{
    canAutoConnectFrom(output)
    {
        return this.inputs[0].canConnectFrom(output);
    }



    updateHeader()
    {
        //console.log(this.id + '.OperatorBase.updateHeader()');

        super.updateHeader();

        
        const colors = this.getHeaderColors();


        this.header.style.backgroundColor = rgba2style(colors.back);
        this.label .style.color           = rgba2style(colors.text);


        for (const input of this.headerInputs)
        {
            input.colorLight = 
            input.colorDark  = colors.input;
            input.wireColor  = colors.wire;
        }

        
        for (const output of this.headerOutputs) 
        {
            output.colorLight =
            output.colorDark  = colors.output;
            output.wireColor  = colors.wire;
        }
    }
}


class   OperatorWithValue
extends OperatorBase
{
    paramValue;
    


    constructor(type, id, name, defWidth = defNodeWidth, progressBar = false)
    {
        super(type, id, name, defWidth, progressBar);

        this.paramValue          = createParamFromType(type);
        this.paramValue.isResult = true;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramValue.setValue(value, false, true, false);

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


class   OperatorWithSymbol
extends OperatorWithValue
{
    _symbol;
    _showOnlySymbol;

    

    constructor(type, id, name, symbol)
    {
        super(type, id, name);

        
        this._showOnlySymbol  = true;


        this._symbol           = createDiv('operatorSymbol');
        this._symbol.innerHTML = symbol;
        this._symbol.clicked0  = false;
        
        this._symbol.addEventListener('pointerenter', () => this._symbol.style.opacity = this._showOnlySymbol ? 1 : 0.65);
        this._symbol.addEventListener('pointerleave', () => this._symbol.style.opacity = 1);

        this._symbol.addEventListener('pointerdown', e => 
        { 
            if (e.button == 0)
            {
                if (this._symbol.clicked0) // finish double click on small symbol
                {
                    this._symbol.clicked0      = false;
                    this._symbol.style.opacity = 1;

                    actionManager.do(new ToggleOperatorSymbolAction(this.id, true));

                    this.header.ignoreDoubleClick = true;
                }
                else if (!this._showOnlySymbol) // start double cick on small symbol
                {
                    this._symbol.clicked0 = true;
                    setTimeout(() => this._symbol.clicked0 = false, 250); // seems like a good default guess
                }
            }
        });

        this.header.appendChild(this._symbol);

        
        this.textbox.addEventListener('finishedit', e => 
        {
            if (this._showOnlySymbol)
                actionManager.do(new ToggleOperatorSymbolAction(this.id, false), e.detail.value != e.detail.oldValue);
        });
    }
    
    
    
    updateHeaderLabel()
    {
        //console.log('OperatorWithSymbol.updateHeaderLabel()');
        
        super.updateHeaderLabel();


        const colBack = rgbFromType(this.type, this.active);
        const colText = isDark(colBack) ? [1, 1, 1] : [0, 0, 0];

        this._symbol.style.fontSize   = this._showOnlySymbol ? 17 : 12;
        this._symbol.style.fontWeight = this.active ? 'bold' : 'normal';
        this._symbol.style.color      = rgb2style(colText);
        this._symbol.style.left       = 'calc(50% + 1px)';
        

        //const padding = this.header.connectionPadding;
        const inputs  = this.headerInputs;


        const [inputY, inputHeight] = getHeaderConnY(inputs);//, padding, 5);

        if (this._showOnlySymbol)
        {
            this._symbol.style.top = inputY[0]/2 + inputHeight/2 - 3;
        }
        else
        {
            this._symbol.style.top = inputY[0]/2 + inputHeight/2 - 13;
            this.label  .style.top = 'calc(50% - 2px)';
        }
        

        this.label.style.visibility = this._showOnlySymbol ? 'hidden'  : 'visible';
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"onlySymbol": "' + boolToString(this._showOnlySymbol) + '"';
    }



    loadParams(_node, pasting)
    {
        if (_node.onlySymbol != undefined)
            this._showOnlySymbol = isTrue(_node.onlySymbol);

        super.loadParams(_node, pasting);
    }
}


const sizeBorderWidth = 4;



class   ResizableBase
extends OperatorBase
{
    sizerL;
    sizerR;
    sizerT;
    sizerB;

    sizerTL;
    sizerTR;
    sizerBL;
    sizerBR;



    constructor(type, id, name)
    {
        super(type, id, name);

        this.initSizer();
    }



    initSizer()
    {
        this.sizerL   = createDiv('sizerEdge sizerH sizerL');
        this.sizerR   = createDiv('sizerEdge sizerH sizerR');
        this.sizerT   = createDiv('sizerEdge sizerV sizerT');
        this.sizerB   = createDiv('sizerEdge sizerV sizerB');

        this.sizerTL  = createDiv('sizerCorner sizerTL');
        this.sizerTR  = createDiv('sizerCorner sizerTR');
        this.sizerBL  = createDiv('sizerCorner sizerBL');
        this.sizerBR  = createDiv('sizerCorner sizerBR');


        this.div.appendChild(this.sizerL);
        this.div.appendChild(this.sizerR);
        //this.div.appendChild(this.sizerT);
        this.div.appendChild(this.sizerB);

        //this.div.appendChild(this.sizerTL);
        //this.div.appendChild(this.sizerTR);
        this.div.appendChild(this.sizerBL);
        this.div.appendChild(this.sizerBR);


        this.initSizerEvents(this.sizerL,  this.setRectL );
        this.initSizerEvents(this.sizerR,  this.setRectR );
        //this.initSizerEvents(this.sizerT,  this.setRectT );
        this.initSizerEvents(this.sizerB,  this.setRectB );

        //this.initSizerEvents(this.sizerTL, this.setRectTL);
        //this.initSizerEvents(this.sizerTR, this.setRectTR);
        this.initSizerEvents(this.sizerBL, this.setRectBL);
        this.initSizerEvents(this.sizerBR, this.setRectBR);
   }



    initSizerEvents(sizer, setRect)
    {
        sizer.resizing = false;


        sizer.addEventListener('pointerdown', e =>
        {
            if (e.button == 0)
            {
                if (document.activeElement)
                    document.activeElement.blur();

                hideAllMenus();
                
                    
                e.stopImmediatePropagation();


                if (graph.currentPage.zoom < settings.minZoomForParams)
                {
                    forwardEvent(e, this.header);
                    return;
                }

                   
                e.preventDefault();


                sizer.startRect = offsetRect(this.div);
                sizer.resizing  = true;

                
                sizer.setPointerCapture(e.pointerId);

                sizer.sx = e.clientX;
                sizer.sy = e.clientY;
            }        
        });



        sizer.addEventListener('pointermove', e =>
        {
            if (!sizer.resizing)
                return;


            const dx = (e.clientX - sizer.sx) / graph.currentPage.zoom;
            const dy = (e.clientY - sizer.sy) / graph.currentPage.zoom;
        
            setRect(sizer, dx, dy);
                

            e.preventDefault();
            e.stopImmediatePropagation();

            this.updateMeasureData();
        });
        

        
        sizer.addEventListener('pointerup', e =>
        {
            if (e.button == 0)
            {
                if (sizer.resizing)
                {
                    actionManager.do(new SetNodeRectAction(
                        this.id, 
                        sizer.startRect, 
                        offsetRect(this.div)));

                    sizer.resizing = false;
                }


                if (sizer.hasPointerCapture(e.pointerId))
                    sizer.releasePointerCapture(e.pointerId);
            }
        });
    }



    setRectL = (sizer, dx, dy) => // these have to be lambdas for 'this'
    {
        this.setRect(
            sizer.startRect.x + dx,
            sizer.startRect.y, 
            sizer.startRect.w - dx, 
            sizer.startRect.h);
    };



    setRectR = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y, 
            sizer.startRect.w + dx, 
            sizer.startRect.h);
    }



    setRectT = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y + dy, 
            sizer.startRect.w, 
            sizer.startRect.h - dy);
    };



    setRectB = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y, 
            sizer.startRect.w, 
            sizer.startRect.h + dy);
    }



    setRectTL = (sizer, dx, dy) => // these have to be lambdas for 'this'
    {
        this.setRect(
            sizer.startRect.x + dx,
            sizer.startRect.y + dy, 
            sizer.startRect.w - dx, 
            sizer.startRect.h - dy);
    };



    setRectTR = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y + dy, 
            sizer.startRect.w + dx, 
            sizer.startRect.h - dy);
    }



    setRectBL = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x + dx, 
            sizer.startRect.y, 
            sizer.startRect.w - dx, 
            sizer.startRect.h + dy);
    };



    setRectBR = (sizer, dx, dy) =>
    {
        this.setRect(
            sizer.startRect.x, 
            sizer.startRect.y, 
            sizer.startRect.w + dx, 
            sizer.startRect.h + dy);
    }



    setSize(w, h, updateTransform = true)
    {
        let headerHeight = getStyleValue(this.header, 'offset-height');
        if (typeof headerHeight == 'string') headerHeight = defHeaderHeight;

        const paramHeight  = settings.showOperationResults ? defParamHeight : 0;


        const _w = Math.max(60, w);
        const _h = Math.max(parseFloat(headerHeight) + paramHeight, h);

        super.setSize(_w, _h, updateTransform);

        this.updateSizers();

        this.inner.style.height = _h;
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        const headerHeight = getStyleValue(this.header, 'height');
        const paramHeight  = settings.showOperationResults ? defParamHeight : 0;

        const _w = Math.max(60, w);
        const _h = Math.max(parseFloat(headerHeight) + paramHeight, h);

        super.setRect(x, y, _w, _h, updateTransform);
        
        this.updateSizers();
    
        this.inner.style.height = _h;
    }



    updateSizers()
    {
        const edge   = Math.ceil(sizeBorderWidth / graph.currentPage.zoom);
        const corner = Math.max(4, edge);

        this.sizerL .style.width  = edge; 
        this.sizerR .style.width  = edge; 

        this.sizerT .style.height = edge; 
        this.sizerB .style.height = edge; 

        this.sizerTL.style.width  = corner; 
        this.sizerTL.style.height = corner; 

        this.sizerTR.style.width  = corner; 
        this.sizerTR.style.height = corner; 

        this.sizerBL.style.width  = corner; 
        this.sizerBL.style.height = corner; 

        this.sizerBR.style.width  = corner; 
        this.sizerBR.style.height = corner; 


        const canReact = graph.currentPage.zoom >= settings.minZoomForParams;

        this.sizerL.style.cursor  = canReact ? 'ew-resize'   : 'default';
        this.sizerR.style.cursor  = canReact ? 'ew-resize'   : 'default';
        this.sizerT.style.cursor  = canReact ? 'ns-resize'   : 'default';
        this.sizerB.style.cursor  = canReact ? 'ns-resize'   : 'default';
        
        this.sizerTL.style.cursor = canReact ? 'nwse-resize' : 'default';
        this.sizerTR.style.cursor = canReact ? 'nesw-resize' : 'default';
        this.sizerBL.style.cursor = canReact ? 'nesw-resize' : 'default';
        this.sizerBR.style.cursor = canReact ? 'nwse-resize' : 'default';
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let json = super.toJsonBase(nTab);

        json += 
              ',\n' + pos + tab + '"width": "'  + this.div.offsetWidth  + '"'
            + ',\n' + pos + tab + '"height": "' + this.div.offsetHeight + '"';

        return json;
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);


        if (   _node.width
            && _node.height)
        {
            this.setSize(
                parseFloat(_node.width), 
                parseFloat(_node.height),
                false);
        }
    }
}



class   ResizableOperatorWithValue
extends ResizableBase
{
    paramValue;
    


    constructor(type, id, name, defWidth = defNodeWidth, progressBar = false)
    {
        super(type, id, name, defWidth, progressBar);

        this.paramValue          = createParamFromType(type);
        this.paramValue.isResult = true;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this.paramValue.setValue(value, false, true, false);

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


class   OpList
extends OperatorBase
{
    constructor()
    {
        super(LIST, 'list', 'list');

        this.canDisable     = true;
        this.variableInputs = true;


        this.addNewInput();
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input([ANY_TYPE]);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(this); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(this, e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}



class   OpExpandList
extends OperatorBase
{
    constructor()
    {
        super(LIST_EXPAND, 'expand', 'expand');

        this.addInput (new Input([LIST_VALUE]));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }
}


class   OpItems
extends OperatorBase
{
    constructor()
    {
        super(ITEMS, 'items', 'items');


        this.addInput (new Input([LIST_VALUE]));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));

        this.alwaysLoadParams = true;
        this.alwaysSaveParams = true;
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

    //     return this.node.genRequest(gen);
    // }



    // genRequest(gen)
    // {
    //     // 'this' is the node

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        //logFunction('OpItems.updateValues()');

        const oldParams = [...this.params];
        //console.log('oldParams =', [...oldParams]);

        const action = actionFromId(actionId);

        if (action)
            pushUnique(oldParams, action.oldOutputParams);

        // console.log('action =', action);

        const oldParamConns = this.getAllParamConnections();


        this.disconnectAllParams(true);
        this.removeAllParams();


        if (   paramIds.length > 1
            ||    paramIds.length == 1 
               && paramIds[0] != '')
        {
            for (let i = 0; i < values.length; i++) 
            {
                const value = values[i];
                if (!value.isValid()) continue;


                const id    = 'item' + i;

                const param = oldParams.find(p => 
                       p.id == id
                    && p.type == value.type);

                if (   param
                    && paramIds.includes(param.id)) 
                {
                    this.addParam(param, true);

                    const _conn = oldParamConns.find(c =>
                           c.outputNodeId == this.id
                        && c.outputId     == param.id);

                    if (_conn)
                    {
                        const conn = uiConnect(param.output, nodeFromId(_conn.inputNodeId).inputFromId(_conn.inputId));
                        uiSaveConn(conn);
                    }
                }
                else       
                    this.createAndAddParamByType(value.type, id, false, false, true, true);
            }
        }

        else if (isEmpty(paramIds))
            this.removeAllParams();
    
        
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateParams()
    {
        for (const param of this.params)
            param.enableControlText(false);

        this.updateParamControls();
    }
}


class   OpSelect
extends OperatorBase
{
    paramIndex;



    constructor()
    {
        super(SELECT, 'select', 'select');

        this.alwaysSaveParams = true;


        this.addInput(new Input(LIST_TYPES, getNodeInputValuesForUndo));

        this.addParam(this.paramIndex = new NumberParam('index', 'index', true, true, false, 0, 0));
        this.paramIndex.controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        return this.node.genRequest(gen);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.paramIndex.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const val    = values[paramIds.findIndex(id => id == 'value' )];
        const length = values[paramIds.findIndex(id => id == 'length')];


        let paramValue = this.params.find(p => p.id == 'value');

        if (   paramValue
            && (  !val
                || paramValue.type != val.type))
            this.removeParam(paramValue);


        if (!paramValue && val)
            paramValue = this.createAndInsertParamByType(0, val.type, 'value', false, false, true, true);

        
        this.paramIndex.controls[0].setMax(
               length
            && length.value > 0
            ? length.value-1
            : Number.MAX_SAFE_INTEGER);
  
        
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateParams()
    {
        //const paramValue = this.params.find(p => p.id == 'value');

        this.paramIndex.enableControlText(true);


        // if (paramValue)
        // {
        //     paramValue.enableControlText(true);
        //     paramValue.controls[0].valueText = this.paramIndex.value < 0 ? UNKNOWN_DISPLAY : '';
        // }


        this.updateParamControls();
    }



    loadParams(_node, pasting)
    {
        if (!_node.params)
            return;

        const _paramValue = _node.params.find(p => p[1] == 'value');
        const _paramIndex = _node.params.find(p => p[1] == 'index');

        this.createAndInsertParamByType(0, _paramValue[0], _paramValue[1], false, false, true, true);
        this.params[0].loadParam(_paramValue);
 
        this.paramIndex.loadParam(_paramIndex);
    }
}


class   OpListCount
extends OperatorBase
{
    paramValue;


    
    constructor()
    {
        super(LIST_COUNT, 'count', 'count');


        this.addInput (new Input([LIST_VALUE]));

        this.addParam(this.paramValue = new NumberParam('value', 'value', false, false, true, 0, 0));
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        return this.node.genRequest(gen);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected) 
            request.push(...pushInputOrParam(input, gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);

        this.updateParamControls();
    }
}


class   OpIfElse
extends OperatorBase
{
    paramCondition;


    menuBool;



    constructor()
    {
        super(IF_ELSE, 'ifElse', 'if/else');


        this.addInput (new Input([ANY_TYPE]));
        this.addInput (new Input([ANY_TYPE]));
        this.addOutput(new Output([ANY_TYPE], this.output_genRequest));


        this.addParam(this.paramCondition = new NumberParam('condition', 'condition', true, true, true, 1, 0, 1));


        this.inputs[0].addEventListener('connect',    () => OpIfElse_onConnectInput(this, 0));
        this.inputs[0].addEventListener('disconnect', () => OpIfElse_onDisconnectInput(this, 0));

        this.inputs[1].addEventListener('connect',    () => OpIfElse_onConnectInput(this, 1));
        this.inputs[1].addEventListener('disconnect', () => OpIfElse_onDisconnectInput(this, 1));


        let menuItemTrue;
        let menuItemFalse;

        this.menuBool = new Menu('L', true, false);
        this.menuBool.minWidth = 130;
        this.menuBool.addItems([
            menuItemTrue  = new MenuItem('true',  {icon:  TRUE_DISPLAY_MENU, callback: () => { hideAllMenus(); this.paramCondition.setValue(new NumberValue(1), true); }}),
            menuItemFalse = new MenuItem('false', {icon: FALSE_DISPLAY_MENU, callback: () => { hideAllMenus(); this.paramCondition.setValue(new NumberValue(0), true); }})]);

        this.paramCondition.controls[0].div.addEventListener('pointerdown', e => this.showParamMenu(e, this.paramCondition, this.menuBool));
    }
    
    

    showParamMenu(e, param, menu)
    {
        if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            param.controls[0].buttonDown2 = true;

            menu.showAt(e.clientX, e.clientY, false);
        }
    }



    canAutoConnectFrom(output)
    {
        return true; //!getTerminalsAfterNode(this.node).find(n => n.inputs.canConnectFrom(output));
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
          if (   input0.connected
              && input1.connected) request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, 0, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, 1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);

        
        request.push(...this.node.paramCondition.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramCondition.enableControlText(true);

        updateParamConditionText(this.paramCondition, this.isUnknown(), 1);


        if (this.outputs[0].supportsTypes([COLOR_VALUE]))
        {
            if (   this.inputs[0].connected
                && this.paramCondition.value.value > 0)
                this.outputs[0].wireColor = this.inputs[0].wireColor;
            else if (this.inputs[1].connected
                  && this.paramCondition.value.value == 0)
                this.outputs[0].wireColor = this.inputs[1].wireColor;
            else
                this.outputs[0].wireColor = rgbFromType(ANY_TYPE, true);

            // console.log('this.inputs[0] =', this.inputs[0]);
            // console.log('this.outputs[0] =', this.outputs[0]);
        }

        else if (this.outputs[0].supportsTypes([FILL_VALUE]))
        {
            const colors = this.getHeaderColors();

            if (   this.inputs[0].connected
                && this.paramCondition.value.value > 0)
                this.outputs[0].wireColor = colors.outputWire;
            else if (this.inputs[1].connected
                  && this.paramCondition.value.value == 0)
                this.outputs[0].wireColor = colors.outputWire;
            else
                this.outputs[0].wireColor = rgbFromType(ANY_TYPE, true);

            // console.log('this.inputs[0] =', this.inputs[0]);
            // console.log('this.outputs[0] =', this.outputs[0]);
        }
        
        else
            this.outputs[0].wireColor = rgbFromType(ANY_TYPE, true);


        this.updateParamControls();
    }



    // updateHeader()
    // {
    //     super.updateHeader();


    //     const colors = super.getHeaderColors();

    //     const type =
    //         this.inputs[0].connected
    //         ? this.inputs[0].types[0]
    //         : this.inputs[1].connected
    //           ? this.inputs[1].types[0]
    //           : ANY_TYPE;


    //     if (COLOR_TYPES.includes(type))
    //     {
    //         colors.output =
    //             this.inputs[0].connected
    //             ? this.inputs[0].connectedOutput.wireColor
    //             : this.inputs[1].connected
    //               ? this.inputs[1].connectedOutput.wireColor
    //               : rgbFromType(IF_ELSE, true);

    //         colors.wire = colors.output;
    //     }
    // }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        const type =
            this.inputs[0].connected
            ? this.inputs[0].types[0]
            : this.inputs[1].connected
              ? this.inputs[1].types[0]
              : ANY_TYPE;


        let colorActive  = rgbFromType(type, true);
        let colorPassive = rgbFromType(type, false);


        if (NUMBER_TYPES.includes(type))
        {
            colors.input  = this.active ? rgb_a(colorPassive, 0.55) : rgb_a(colorActive, darkMode ? 0.65 : 0.5);
            colors.output = this.active ? rgb_a(colorPassive, 0.5 ) : rgb_a(colorActive, darkMode ? 0.6  : 0.4);
            colors.wire   = colorActive;
        }
        else if (TEXT_TYPES.includes(type))
        {
            colors.input  = this.active ? rgb_a(colorActive, 0.55) : rgb_a(darkMode ? colorActive : colorPassive, darkMode ? 0.55 : 1);
            colors.output = this.active ? rgb_a(colorActive, 0.45) : rgb_a(darkMode ? colorActive : colorPassive, darkMode ? 0.45 : 0.9);
            colors.wire   = colorActive;
        }
        else if (SHAPE_TYPES.includes(type))
        {
            colors.input  = this.active ? rgb_a(colorPassive, 0.65) : rgb_a(colorActive, darkMode ? 0.6 : 0.5 );
            colors.output = this.active ? rgb_a(colorPassive, 0.65) : rgb_a(colorActive, darkMode ? 0.5 : 0.45);
            colors.wire   = colorActive;
        }
        else if (COLOR_TYPES.includes(type))
        {
            if (   this.inputs[0].connected
                && this.inputs[1].connected)
            {
                colors.output = 
                    this.paramCondition.value.value > 0
                    ? this.inputs[0].connectedOutput.wireColor
                    : this.inputs[1].connectedOutput.wireColor;
            }

            else if (this.inputs[0].connected
                  && this.paramCondition.value.value > 0)
                colors.output = this.inputs[0].connectedOutput.wireColor;

            else if (this.inputs[1].connected
                  && this.paramCondition.value.value == 0)
                colors.output = this.inputs[1].connectedOutput.wireColor;


            colors.wire = colors.output;
        }
        else if (FILL_TYPES.includes(type))
        {
            if (   this.inputs[0].connected
                && this.inputs[1].connected)
            {
                const wireColor =
                    this.paramCondition.value.value > 0
                    ? this.inputs[0].connectedOutput.wireColor
                    : this.inputs[1].connectedOutput.wireColor;

                colors.outputWire = wireColor;
                colors.output = rgbaLerp(
                    rgb_a(getTextColorFromBackColor(rgbFromType(ANY_TYPE, true)), 0.3),
                    wireColor,
                    wireColor[3]);
            }

            else if (this.inputs[0].connected
                  && this.paramCondition.value.value > 0)
            {
                const wireColor = this.inputs[0].connectedOutput.wireColor;

                colors.outputWire = wireColor;
                colors.output = rgbaLerp(
                    rgb_a(getTextColorFromBackColor(rgbFromType(ANY_TYPE, true)), 0.3),
                    wireColor,
                    wireColor[3]);
            }
            else if (this.inputs[1].connected
                  && this.paramCondition.value.value == 0)
            {
                const wireColor = this.inputs[1].connectedOutput.wireColor;

                colors.outputWire = wireColor;
                colors.output = rgbaLerp(
                    rgb_a(getTextColorFromBackColor(rgbFromType(ANY_TYPE, true)), 0.3),
                    wireColor,
                    wireColor[3]);
            }


            colors.wire = colors.output;
        }

        
        
        return colors;
    }
}



function OpIfElse_onConnectInput(node, inputIndex)
{
    const otherIndex = inputIndex == 0 ? 1 : 0;

    const firstInput = node.inputs[inputIndex];
    const otherInput = node.inputs[otherIndex];

    const firstOut   = firstInput.connectedOutput;
    const firstTypes = [...firstOut.types];
    

    firstInput.types     = [...firstTypes];
    firstInput.wireColor = [...firstOut.wireColor];

    
    if (!node.inputs[otherIndex].connected)
    {
        otherInput.types      = [...firstTypes];
        otherInput.wireColor  = [...firstOut.wireColor];

        node.outputs[0].types = 
            firstTypes.includes(ANY_TYPE)
            ? [ANY_TYPE]
            : [...firstTypes];
    }

    
    for (const output of node.outputs)
        for (const input of output.connectedInputs)
            if (input.node.type == IF_ELSE)
                OpIfElse_onConnectInput(input.node, input.index);


    // if there is an outgoing connection from the node of a different type than
    // the incoming connection, delete the outgoing connection

    if (    node.outputs[0].connected
        && !node.outputs[0].connectedInputs[0].canConnectFrom(firstOut))
        node.outputs[0].connectedInputs.forEach(i => uiDisconnect(i));
}



function OpIfElse_onDisconnectInput(node, inputIndex)
{
    const otherIndex = inputIndex == 0 ? 1 : 0;
    
    const firstInput = node.inputs[inputIndex];
    //const firstOut   = firstInput.connectedOutput;

    const otherInput = node.inputs[otherIndex];
    const otherOut   = otherInput.connectedOutput;
    const otherTypes = otherOut ? otherOut.types : [];


    if (!node.inputs[otherIndex].connected)
        node.inputs[inputIndex].types = [ANY_TYPE];

    node.inputs[otherIndex].types = 
        otherInput.connected 
        ? [...otherTypes]
        : [ANY_TYPE];

    node.outputs[0].types = 
        otherInput.connected
        ? [...otherTypes]
        : [ANY_TYPE];


    // const connectedInputs = node.headerInputs.filter(i => i.connected);

    // if (connectedInputs.length == 1)
    // {
    //     const input = connectedInputs[0];

    //     uiDisconnect(input);

    //     // if (input.node.type == IF_ELSE)
    //     //     OpIfElse_onDisconnectInput(input.node, input.index);
    // }
    {
        for (const output of node.outputs)
            for (const input of output.connectedInputs)
                if (input.node.type == IF_ELSE)
                    OpIfElse_onConnectInput(input.node, input.index);
    }
}


class   OpStart
extends OperatorBase
{
    constructor()
    {
        super(START, 'start', 'start');

        this.addInput (new Input ([ANY_TYPE]));
        this.addOutput(new Output([], this.output_genRequest));

        this.inputs[0].addEventListener('connect',    e => { OpStart_onConnectInput(this); });
        this.inputs[0].addEventListener('disconnect', e => OpStart_onDisconnectInput(this));
    }



    isCached()
    {
        return false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });
        
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}



function OpStart_onConnectInput(node)
{
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
}



function OpStart_onDisconnectInput(node)
{
    node.outputs[0].types = [];
}


class   OpRepeat
extends OperatorBase
{
    paramCount;



    constructor()
    {
        super(REPEAT, 'repeat', 'repeat');

        
        this.addInput (new Input([ANY_TYPE]));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));

        this.addParam(this.paramCount = new NumberParam('count', 'count', true, true, false, 1, 0, 1000, 0));


        this.paramCount.controls[0].allowEditDecimals = false;
        this.paramCount.affectsHeader = false;
    }
    
    

    isMultiplier()
    {
        return true;
    }


    
    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCount.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const count = values[paramIds.findIndex(id => id == 'count')];

        if (count) this.paramCount.setValue(count, false, true, false);
    }



    updateParams()
    {
        this.paramCount.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpCache
extends OperatorBase
{
    paramNumber;
    paramColor;

    //headerColor = null;


    constructor()
    {
        super(CACHE, 'cache', 'cache');

        this.cached = true;
        

        this.addInput(new Input([ANY_TYPE]));
        //this.addOutput(new Output([], this.output_genRequest));


        this.paramNumber = new NumberParam('value', '', false, false, true);
        this.paramColor  = new  ColorParam('value', '', false, false, true);

        this.paramNumber.volatile = true;
        this.paramColor .volatile = true;

        
        this.inputs[0].addEventListener('connect',    () => OpCache_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpCache_onDisconnectInput(this));
    }
    
    

    isCached()
    {
        return true;
    }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });

        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        const input = this.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values) // virtual
    {
        const val = values[paramIds.findIndex(id => id == 'value')];

        // this.headerColor =
        //     val && val.type == COLOR_VALUE
        //     ? rgb_a(val.toRgb())
        //     : null;

        if (!isEmpty(this.params)) 
        {
            this.params[0].setValue(val);
            this.params[0].enableControlText(false);
        }
    }



    // getHeaderColors()
    // {
    //     const colors = super.getHeaderColors();

    //     const type = 
    //         this.inputs[0].connected 
    //         ? this.inputs[0].connectedOutput.node.type 
    //         : this.type;

    //     // colors.back = 
    //     //     this.headerColor
    //     //     ? this.headerColor
    //     //     : this.inert
    //     //     ? rgb_a(rgbDocumentBody, 0.95)
    //     //     : rgb_a(rgbFromType(type, this.active), 0.95);

    //     // colors.border = rgb_a(rgbFromType(this.type, this.active), 0.95);

    //     colors.text    = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

    //     colors.input   = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
    //     colors.output  = this.active ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
    //     colors.wire    = rgbFromType(type, true);

    //     return colors;
    // }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}



function OpCache_onConnectInput(node)
{
    const inOutput = node.inputs[0].connectedOutput;

    // node.outputs[0].types = [...inOutput.types];

         if (inOutput.supportsTypes(NUMBER_TYPES)) node.addParam(node.paramNumber);
    else if (inOutput.supportsTypes(  TEXT_TYPES)) node.addParam(node.paramText  );
    else if (inOutput.supportsTypes( COLOR_TYPES)) node.addParam(node.paramColor );
}



function OpCache_onDisconnectInput(node)
{
    // node.outputs[0].types = [];
    
    node.removeAllParams();
}


class   OpCopy
extends OperatorBase
{
    paramNumber;
    paramColor;

    headerColor = null;


    constructor()
    {
        super(COPY, 'copy', 'copy');

        //this.cached = true;
        

        this.addInput (new Input([ANY_TYPE]));
        this.addOutput(new Output([], this.output_genRequest));


        this.paramNumber = new NumberParam('copy', '', false, false, true);
        this.paramColor  = new  ColorParam('copy', '', false, false, true);

        
        this.inputs[0].addEventListener('connect',    () => OpCopy_onConnectInput(this));
        this.inputs[0].addEventListener('disconnect', () => OpCopy_onDisconnectInput(this));
    }
    
    

    // isCached()
    // {
    //     return true;
    // }



    canAutoConnectFrom(output)
    {
        return true;
    }

    

    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);

        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values) // virtual
    {
        //super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        const val = values[paramIds.findIndex(id => id == 'copy')];

        this.headerColor =
            val && val.type == COLOR_VALUE
            ? rgb_a(val.toRgb())
            : null;

        if (!isEmpty(this.params)) 
        {
            this.params[0].setValue(val);
            this.params[0].enableControlText(false);
        }
    }



    updateParams()
    {
        const paramValue = this.params.find(p => p.id == 'copy');

        if (paramValue)
        {
            paramValue.enableControlText(false);

            paramValue.controls[0].valueText =  this.isUnknown() ? UNKNOWN_DISPLAY : '';
            paramValue.controls[0].showBar   = !this.isUnknown();
        }

        
        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        const type = 
            this.inputs[0].connected 
            ? this.inputs[0].connectedOutput.node.type 
            : this.type;

        colors.back = 
            this.headerColor
            ? this.headerColor
            : this.inert
            ? rgb_a(rgbDocumentBody, 0.95)
            : rgb_a(rgbFromType(type, this.active), 0.95);

        // colors.border = rgb_a(rgbFromType(this.type, this.active), 0.95);

        colors.text    = isDark(colors.back) ? [1, 1, 1, 1] : [0, 0, 0, 1]; 

        colors.input   = this.active ? rgb_a(colors.text, 0.4)  : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.8);
        colors.output  = this.active ? rgb_a(colors.text, 0.35) : rgb_a(rgbSaturateHsv(rgbFromType(type, true), 0.5), 0.7);
        colors.wire    = rgbFromType(type, true);

        return colors;
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}



function OpCopy_onConnectInput(node)
{
    const inOutput = node.inputs[0].connectedOutput;

    node.outputs[0].types = [...inOutput.types];

         if (inOutput.supportsTypes(NUMBER_TYPES)) node.addParam(node.paramNumber);
    else if (inOutput.supportsTypes( COLOR_TYPES)) node.addParam(node.paramColor);
}



function OpCopy_onDisconnectInput(node)
{
    node.outputs[0].types = [];
    
    node.removeAllParams();
}


class   OpNumber
extends OperatorBase
{
    paramValue;



    constructor()
    {
        super(NUMBER, 'num', 'number');

        this.addInput (new Input (NUMBER_TYPES, getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));

        this.addParam(this.paramValue = new NumberParam('value', '', false, false, false));

        this.alwaysLoadParams = true;
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.node.paramValue.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == NUMBER_VALUE, 'expected NUMBER_VALUE in backInit()');
        
        this.node.paramValue.setValue(value, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });
        
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        if (input.connected) request.push(...pushInputOrParam(input, gen));
        else                 request.push(...this.node.paramValue.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        const input = this.inputs[0];
        
        this.paramValue.enableControlText(!input.connected);

        this.paramValue.controls[0].valueText =  this.isUnknown() ? UNKNOWN_DISPLAY : '';
        this.paramValue.controls[0].showBar   = !this.isUnknown();


        this.updateParamControls();
    }



    paramIsConsideredDefault(param)
    {
        return  param.isDefault()
            && !this.inputs[0].connected;
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';
        
        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;


        js += gen.NL + 'return ';
        js += conn ? 'input' : this.toJsCode(gen);
        js += ';'


        gen.nTab--;
        js += gen.NL + '}';


        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';


        return js;
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
             ? this.inputs[0].connectedOutput.toJsCode(gen)
             : this.paramValue.value.toJsCode(gen);
    }
}


class   OpSign
extends OperatorWithValue
{
    constructor()
    {
        super(NUMBER_SIGN, 'sign', 'sign');

        this.canDisable = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);

        this.updateParamControls();
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';

        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;
        
        
        js += gen.NL + 'return ';
        js += conn ? 'Math.sign(input)' : this.toJsCode();
        js += ';'


        gen.nTab--;
        js += gen.NL + '}';


        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';


        return js;
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
            ? 'Math.sign(' + this.inputs[0].connectedOutput.toJsCode(gen) + ')'
            : 'Number.NaN';
    }
}


class   OpAbsolute
extends OperatorWithValue
{
    constructor()
    {
        super(NUMBER_ABSOLUTE, 'abs', 'absolute');

        this.canDisable = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);

        this.updateParamControls();
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';

        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;
        
        
        js += gen.NL + 'return ';
        js += conn ? 'Math.abs(input)' : this.toJsCode();
        js += ';'


        gen.nTab--;
        js += gen.NL + '}';


        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';


        return js;
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
            ? 'Math.abs(' + this.inputs[0].connectedOutput.toJsCode(gen) + ')'
            : 'Number.NaN';
    }
}


class   OpRound
extends OperatorWithValue
{
    paramType;
    paramDecimals;



    constructor()
    {
        super(NUMBER_ROUND, 'round', 'round');

        this.canDisable = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramType  = new SelectParam('type',     'type',     false, true,  true, ['floor', 'round', 'ceiling'], 1));
        this.addParam(this.paramDecimals   = new NumberParam('decimals', 'decimals', true,  true,  true, 0, 0, 10));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramType    .genRequest(gen));
        request.push(...this.node.paramDecimals.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramType    .enableControlText(true);
        this.paramDecimals.enableControlText(true);

        this.updateParamControls();
    }



    toJavascript(gen)
    {
        const conn = this.inputs[0].connected;


        gen.nTab++;
        const defs = this.toJsDefs(gen);
        gen.nTab--;


        let js = gen.NL + 'function ' + this.name + '(';

        if (   conn 
            && defs == NULL)
            js += 'input';

        js += ')';


        js += gen.NL + '{';
        gen.nTab++;


        js += defs;
        
        
        if (this.inputs[0].connected)
        {
            js += gen.NL + 'const input = ' + this.inputs[0].connectedOutput.toJsCode(gen) + ';';
            js += '\n';
            js += gen.NL + 'switch (' + this.paramType.toJsCode(gen) + ')';
            js += gen.NL + '{ ';
            js += gen.NL + TAB + 'case 0: return Math.floor(input);';
            js += gen.NL + TAB + 'case 1: return Math.round(input);';
            js += gen.NL + TAB + 'case 2: return Math.ceil (input);';
            js += gen.NL + '}';
        }
        else
            js += gen.NL + 'return Number.NaN;';


        gen.nTab--;
        js += gen.NL + '}';

        
        return js;
    }



    toJsDefs(gen)
    {
        if (  !this.inputs[0].connected
            || gen.connectedOut(this))
            return '';

        
        let js = '';


        js += gen.NL + 'const input    = ';
        js += this.inputs[0].connectedOutput.toJsCode(gen);
        js += ';';

        js += this.paramType    .input.toJsDef(gen);
        js += this.paramDecimals.input.toJsDef(gen);


        return js;
    }



    toJsCode(gen)
    {
        let js = '';


        if (this.inputs[0].connected)
        {
            js += '() => { ';

            js += 'const input = ' + this.inputs[0].connectedOutput.toJsCode(gen) + ';';
            js += ' ';

            js += 'switch (' + this.paramType.toJsCode(gen) + ')';
            js += ' {';
            js += ' case 0: return Math.floor(input);';
            js += ' case 1: return Math.round(input);';
            js += ' case 2: return Math.ceil(input);';
            js += ' }';


            js += ' }';
        }
        else
            js += 'Number.NaN';

      
        return js;
    }
}


class   OpLimits
extends OperatorWithValue
{
    paramMin;
    paramMax;



    constructor()
    {
        super(NUMBER_LIMITS, 'limits', 'limits');

        this.canDisable = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramMin = new NumberParam('min', 'min', true,  true,  true,    0));
        this.addParam(this.paramMax = new NumberParam('max', 'max', true,  true,  true, 1000));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramMin.genRequest(gen));
        request.push(...this.node.paramMax.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramMin  .enableControlText(true);
        this.paramMax  .enableControlText(true);
        this.paramValue.enableControlText(false);

        this.updateParamControls();
    }



    toJsCode(gen)
    {
        return this.inputs[0].connected
             ? 'Math.min(Math.max(' 
                    + this.paramMin.toJsCode(gen) + ', ' + this.inputs[0].connectedOutput.toJsCode(gen) + '), ' 
                    + this.paramMax.toJsCode(gen) + ')'
             : 'Number.NaN';
    }
}


class   OpRandom
extends OperatorBase
{
    paramSeed;
    paramMin;
    paramMax;



    constructor()
    {
        super(NUMBER_RANDOM, 'random', 'random');

        this.cached = false;
        
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramSeed = new NumberParam('seed', 'seed', true, true, true, Math.floor(Math.random() * 10000), 0, 0x7fffffff));
        this.addParam(this.paramMin  = new NumberParam('min',  'min',  true, true, true,   0));
        this.addParam(this.paramMax  = new NumberParam('max',  'max',  true, true, true, 255));

        this.paramSeed.controls[0].allowEditDecimals = false;
        this.paramSeed.isDefault = () => false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramSeed.genRequest(gen));
        request.push(...this.node.paramMin .genRequest(gen));
        request.push(...this.node.paramMax .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpSeries
extends OperatorBase
{
    paramStart;
    paramStep;



    constructor()
    {
        super(NUMBER_SERIES, 'sequence', 'sequence');

        this.cached = false;
        
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramStart = new NumberParam('start', 'start', true, true, false, 0));
        this.addParam(this.paramStep  = new NumberParam('step',  'step',  true, true, false, 1));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramStart.genRequest(gen));
        request.push(...this.node.paramStep .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }
}


class   OpInterpolate
extends OperatorWithValue
{
    paramAmount;
    


    constructor()
    {
        super(NUMBER_INTERPOLATE, 'inter', 'interpolate');

        this.addInput(new Input(NUMBER_TYPES));
        this.addInput(new Input(NUMBER_TYPES));

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramAmount = new NumberParam('amount', '', true, true, true, 50, 0, 100, 0));

        
        this.paramAmount.controls[0].min = Number.MIN_SAFE_INTEGER; // allow
        this.paramAmount.controls[0].max = Number.MAX_SAFE_INTEGER; // extrapolation
        
        this.paramAmount.controls[0].setSuffix('%', true);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramAmount.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue .enableControlText(false);
        this.paramAmount.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpNumberToText
extends OperatorBase
{
    paramValue;
    paramFormat;
    paramDigits;



    constructor()
    {
        super(NUMBER_TO_TEXT, 'toText', 'to text');


        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue  = new   TextParam('value',  '',              false, true));
        this.addParam(this.paramFormat = new SelectParam('format', 'format', false, true,  true, ['decimal', 'hex', 'float']));
        this.addParam(this.paramDigits = new NumberParam('digits', 'digits', true,  true,  true, 0, 0, 10));

        this.paramValue .controls[0].textbox.style.textAlign = 'center';
        
        this.paramDigits.controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramFormat.genRequest(gen));
        request.push(...this.node.paramDigits.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue .enableControlText(false);
        this.paramFormat.enableControlText(true);
        this.paramDigits.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpSolve
extends OperatorWithValue
{
    paramCurrent;
    paramTarget;



    constructor()
    {
        super(NUMBER_SOLVE, 'solve', 'solve', defNodeWidth, true);

        this.canDisable = true;
        

        this.addInput (new Input (NUMBER_TYPES));
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.inputs[0].feedback = true;


        this.addParam(this.paramValue);
        this.addParam(this.paramCurrent = new NumberParam('current', 'current', true,  true,  true, Number.NaN));
        this.addParam(this.paramTarget  = new NumberParam('target',  'target',  true,  true,  true));
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCurrent.genRequest(gen));
        request.push(...this.node.paramTarget .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        this.endNodeProgress();
    }



    updateParams()
    {
        this.paramValue  .enableControlText(false);
        this.paramCurrent.enableControlText(false);
        this.paramTarget .enableControlText(true);

        this.updateParamControls();
    }



    toJsCode(gen)
    {
        return '';//this.inputs[0].connected
            //  ? 'Math.min(Math.max(' 
            //         + this.paramCurrent.toJsCode(gen) + ', ' + this.inputs[0].connectedOutput.toJsCode(gen) + '), ' 
            //         + this.paramTarget.toJsCode(gen) + ')'
            //  : 'Number.NaN';
    }
}


class   OpAnimate
extends OperatorWithValue
{
    paramFrom;
    paramTo
    paramCurve;
    paramType;
    paramLength;
    paramTime;


    btnPlay;

    playing = false;

    startTime;
    //prevTime;



    constructor()
    {
        super(NUMBER_ANIMATE, 'anim', 'animate');

        //this.cached = false;
        

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramFrom   = new NumberParam('from',   'from',   true,  true, true, 0, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 2));
        this.addParam(this.paramTo     = new NumberParam('to',     'to',     true,  true, true, 1, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, 2));
        this.addParam(this.paramType   = new SelectParam('type',   'type',   false, true, true, ['once', 'repeat', 'ping-pong']));
        this.addParam(this.paramCurve  = new SelectParam('curve',  'curve',  false, true, true, ['step', 'linear', 'ease in', 'ease out', 'smooth'], 1));
        this.addParam(this.paramLength = new NumberParam('length', 'length', true,  true, true, 1, 0, Number.MAX_SAFE_INTEGER, 1));
        this.addParam(this.paramTime   = new NumberParam('time',   'time',   true,  true, true, 0, 0));


        this.paramLength.controls[0].suffix = ' sec';
        this.paramTime    .controls[0].suffix = ' sec';


        this.btnPlay = createDiv('btnAnimatePlay');
        this.btnPlay.over = false;
        this.btnPlay.down = false;


        this.btnPlay.addEventListener('pointerenter', e => 
        { 
            console.log('pointerenter');
            this.btnPlay.over = true;  
            this.updateHeader(); 
        });


        this.btnPlay.addEventListener('pointerleave', e => 
        { 
            this.btnPlay.over = false; 
            this.updateHeader(); 
        });


        this.btnPlay.addEventListener('pointerdown',  e => 
        { 
            e.stopPropagation();

            if (e.button == 0)
            {
                hideAllMenus();

                this.playing = !this.playing;
                this.updateHeader();


                if (this.playing) // start playback
                {
                    this.startTime = Date.now();
                    //this.prevTiime = this.startTime;

                    this.updatePlayback();
                }
            }
            else
                e.preventDefault();
        });


        this.label.insertBefore(this.btnPlay, this.labelText);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        request.push(...this.node.paramFrom  .genRequest(gen));
        request.push(...this.node.paramTo    .genRequest(gen));
        request.push(...this.node.paramCurve .genRequest(gen));
        request.push(...this.node.paramType  .genRequest(gen));
        request.push(...this.node.paramLength.genRequest(gen));
        request.push(...this.node.paramTime  .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        if (this.playing)
            this.updatePlayback();
    }



    updateParams()
    {
        this.paramValue .enableControlText(false);
        this.paramFrom  .enableControlText(true);
        this.paramTo    .enableControlText(true);
        this.paramCurve .enableControlText(true);
        this.paramType  .enableControlText(true);
        this.paramLength.enableControlText(true);
        this.paramTime  .enableControlText(true);

        this.paramTime.controls[0].setMax(this.paramLength.value.value);
        this.paramTime.controls[0].setDecimals(2);

        this.updateParamControls();
    }



    updateHeader()
    {
        super.updateHeader();

        this.updatePlayIcon();
    }



    updatePlayIcon()
    {
        const colors = this.getHeaderColors();

        const rgba       = rgb_a(rgbFromType(ANY_TYPE));
        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

        const headerStyle = rgba2style(
            rgb_a(
                rgbFromType(ANY_TYPE) //this.paramValue.value.isValid()
                ? (isDark(rgbaStripe) ? [1, 1, 1] : [0, 0, 0])
                : colors.text, 
                this.btnPlay.down 
                ? 1 
                : this.btnPlay.over
                  ? 0.7 
                  : 0.5));

        this.btnPlay.style.display            = 'inline-block';
        this.btnPlay.style.background         = !this.playing
                                                ? 'url(\'data:image/svg+xml;utf8,<svg width="9" height="13" viewBox="0 0 9 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 6.5L1.47008e-07 13L7.15256e-07 -3.93402e-07L9 6.5Z" fill="'+headerStyle+'"/></svg>\')'
                                                : 'url(\'data:image/svg+xml;utf8,<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><rect width="9" height="9" fill="'+headerStyle+'"/></svg>\')';

        this.btnPlay.style.backgroundPosition = '50% 50%';
        this.btnPlay.style.backgroundRepeat   = 'no-repeat';
    }



    updatePlayback()
    {
        let   time   = (Date.now() - this.startTime) / 1000;
        const length = this.paramLength.value.value;


        switch (this.paramType.value.value)
        {
            case 0:
                if (time >= length)
                {
                    time = length;
                    this.playing = false;
                }
                
                break;

            case 1:
                if (time > length)
                    time %= length;

                break;

            case 2:
                if (Math.floor(time / length) % 2 > 0)
                    time = length - (time % length);
                if (time > length)
                    time %= length;

                break;
        }


        this.paramTime.setValue(
            new NumberValue(
                time, 
                this.paramTime.controls[0].decimals),
            false);

        pushUpdateFromParam(null, [this], this.paramTime);
    }
}


class   OpMath
extends OperatorWithValue
{
    paramOperation;



    constructor()
    {
        super(NUMBER_MATH, 'math', 'math');

        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true, true, MATH_OPS.map(s => s[1]), 1));

        this.paramOperation.reverseMenu = true;
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input(NUMBER_TYPES);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(this); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(this, e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramOperation.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false);
        this.paramOperation.enableControlText(true);

        this.updateParamControls();
    }
}



class   OpArithmetic
extends OperatorWithSymbol
{
    constructor(type, id, name, symbol)
    {
        super(type, id, name, symbol);
        
        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input(NUMBER_TYPES);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(this); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(this, e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            

        const connectedInputs = this.node.inputs.filter(i => i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
                
        this.paramValue.controls[0].valueText =  this.isUnknown() ? UNKNOWN_DISPLAY : '';
        this.paramValue.controls[0].showBar   = !this.isUnknown();

        this.updateParamControls();
    }



    updateHeaderLabel()
    {
        //console.log('OperatorWithSymbol.updateHeaderLabel()');
        
        OperatorWithValue.prototype.updateHeaderLabel.call(this);


        const colBack = rgbFromType(this.type, this.active);
        const colText = isDark(colBack) ? [1, 1, 1] : [0, 0, 0];

        this._symbol.style.fontSize   = this._showOnlySymbol ? 17 : 12;
        this._symbol.style.fontWeight = this.active ? 'bold' : 'normal';
        this._symbol.style.color      = rgb2style(colText);
        this._symbol.style.left       = 'calc(50%)';
        

        //const padding = this.header.connectionPadding;
        const inputs  = this.headerInputs;


        const [inputY, inputHeight] = getHeaderConnY(inputs);//, padding, 5);

        if (this._showOnlySymbol)
        {
            this._symbol.style.top = inputY[0]/2 + inputHeight/2;
        }
        else
        {
            this._symbol.style.top = inputY[0]/2 + inputHeight/2 - 4;
            this.label  .style.top = 'calc(50% - 1px)';
        }
        

        this.label.style.visibility = this._showOnlySymbol ? 'hidden'  : 'visible';
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}



class   OpAdd
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_ADD, 'add', 'add', '+');
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' + ');
        
        js += ')';


        return js;
    }
}


class   OpSubtract
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_SUBTRACT, 'sub', 'subtract', '');
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' - ');
        
        js += ')';

        
        return js;
    }
}


class   OpMultiply
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_MULTIPLY, 'mul', 'multiply', '');
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' * ');
        
        js += ')';

        
        return js;
    }
}


class   OpDivide
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_DIVIDE, 'div', 'divide', '/');//'');
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' / ');
        
        js += ')';

        
        return js;
    }
}


class   OpModulo
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_MODULO, 'rem', 'remainder', '%');
    }
    
    
    
    updateNode()
    {
        super.updateNode();

        // this._symbol.innerHTML =
        //     this._showOnlySymbol
        //     ? '<span style="font-size: 14px;">x</span><span style="position: relative; left: -1px; top: -7px; font-size: 7px; font-weight: bold;">y</span>'
        //     : '<span style="position: relative; top: -1.5px; font-size: 8px;">x</span><span style="position: relative; left: -0.5px; top: -5.15px; font-size: 3.75px; font-weight: bold;">y</span>';

        this._symbol.style.fontSize   = this._showOnlySymbol ? 11 : 8;
        this._symbol.style.fontWeight = 'bold';
        this._symbol.style.left       = 'calc(50% + ' + (this._showOnlySymbol ? 1.5 : 1) + 'px)';
        this._symbol.style.top        = parseFloat(this._symbol.style.top) + (this._showOnlySymbol ? 4 : 4.5);
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';

        js += '(';

        js += this.connectedHeaderInputs
            .map(i => i.connectedOutput.toJsCode)
            .join(' % ');
        
        js += ')';

        
        return js;
    }
}


class   OpExponent
extends OpArithmetic
{
    constructor()
    {
        super(NUMBER_EXPONENT, 'pow', 'power', 'e'); // placeholder symbol, actual symbol set in updateNode()
    }



    toJsCode(gen)
    {
        if (isEmpty(this.connectedHeaderInputs))
            return 'Number.NaN';


        let js = '';


        this.connectedHeaderInputs
            .forEach(i => 
            {
                js += 'Math.pow(';
                js += i.connectedOutput.toJsCode(gen);
                js += ', ';
            });

        this.connectedHeaderInputs
            .forEach(i => ')');

        
        return js;
    }
}


class   OpBoolean
extends OperatorWithValue
{
    paramOperation;



    constructor()
    {
        super(NUMBER_BOOLEAN, 'bool', 'boolean');

        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true, true, BOOLEAN_OPS.map(s => s[1]), 3));


        this.paramOperation.reverseMenu = true;
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input(NUMBER_TYPES);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(this); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(this, e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        request.push(...this.node.paramOperation.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false);
        this.paramOperation.enableControlText(true);

        this.paramValue.controls[0].text.style.fontStyle = 
               settings.showBoolValues 
            && this.paramValue.value.isValid()
            ? 'normal' 
            : 'italic';


        const v = Math.round(this.paramValue.value.value);

             if (this.isUnknown())        this.paramValue.controls[0].valueText = UNKNOWN_DISPLAY;
        else if (settings.showBoolValues
              && !isNaN(v))               this.paramValue.controls[0].valueText = v != 0 ? getTrueDisplay() : getFalseDisplay();
        else                              this.paramValue.controls[0].valueText = '';

        this.paramValue.controls[0].text.style.letterSpacing = settings.showBoolValues ? '0.1em' : 0;

        this.paramValue.controls[0].showBar = !this.isUnknown();


        this.updateParamControls();
    }
}


class   OpBooleanBase
extends OperatorWithValue
{
    constructor(type, id, name)
    {
        super(type, id, name);

        
        this.variableInputs   = true;
        this.alwaysLoadParams = true;


        this.addNewInput();
        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));
        
        this.addParam(this.paramValue);
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input(NUMBER_TYPES);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(this); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(this, e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
            

        const connectedInputs = this.node.inputs.filter(i => i.connected);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        connectedInputs.forEach(input => 
            request.push(...pushInputOrParam(input, gen)));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);
        
        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        

        const v = Math.round(this.paramValue.value.value);

             if (this.isUnknown())        this.paramValue.controls[0].valueText = UNKNOWN_DISPLAY;
        else if (settings.showBoolValues
              && !isNaN(v))               this.paramValue.controls[0].valueText = v != 0 ? getTrueDisplay() : getFalseDisplay();
        else                              this.paramValue.controls[0].valueText = '';


        this.paramValue.controls[0].text.style.fontStyle = 
               settings.showBoolValues 
            && this.paramValue.value.isValid()
            ? 'normal' 
            : 'italic';


        //this.paramValue.controls[0].text.style.letterSpacing = settings.showBoolValues ? '0.1em' : 0; // this is if "true" and "false" are used
        
        this.paramValue.controls[0].showBar = !this.isUnknown();


        this.updateParamControls();
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}



class   OpNot
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_NOT, 'not', 'not');
    }
}


class   OpAnd
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_AND, 'and', 'and');
    }
}


class   OpOr
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_OR, 'or', 'or');
    }
}


class   OpXor
extends OpBooleanBase
{
    constructor()
    {
        super(NUMBER_XOR, 'xor', 'xor');
    }
}


class   OpCondition
extends OperatorWithValue
{
    paramOperation;



    constructor()
    {
        super(NUMBER_CONDITION, 'cond', 'condition');

        this.addInput(new Input(NUMBER_TYPES));
        this.addInput(new Input(NUMBER_TYPES));

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramOperation = new SelectParam('operation', '', false, true, true, CONDITION_OPS.map(s => s[1]), 2));

        this.paramOperation.reverseMenu = true;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramOperation.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false);
        this.paramOperation.enableControlText(true);


        updateParamConditionText(this.paramValue, this.isUnknown());


        this.updateParamControls();
    }
}



function updateParamConditionText(param, unknown, offsetY = 0)
{
    const v = Math.round(param.value.value);

         if (unknown)        param.controls[0].valueText = UNKNOWN_DISPLAY;
    else if (settings.showBoolValues
          && !isNaN(v))      param.controls[0].valueText = '<span style="position: relative; top: ' + offsetY + 'px">' + (v != 0 ? getTrueDisplay() : getFalseDisplay()) + '</span>';
    else                     param.controls[0].valueText = '';

    param.controls[0].showBar = !settings.showBoolValues;//unknown;
}


class   OpConditionBase
extends OperatorWithSymbol
{
    constructor(type, id, name, symbol)
    {
        super(type, id, name, symbol);

        this.alwaysLoadParams = true;

        
        this.addInput(new Input(NUMBER_TYPES));
        this.addInput(new Input(NUMBER_TYPES));

        this.addOutput(new Output([NUMBER_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);


        const v = Math.round(this.paramValue.value.value);

             if (this.isUnknown())       this.paramValue.controls[0].valueText = UNKNOWN_DISPLAY;
        else if (settings.showBoolValues
              && !isNaN(v))              this.paramValue.controls[0].valueText = v != 0 ? getTrueDisplay() : getFalseDisplay();
        else                             this.paramValue.controls[0].valueText = '';


        this.paramValue.controls[0].text.style.fontStyle = 
               settings.showBoolValues 
            && this.paramValue.controls[0].valueText != UNKNOWN_DISPLAY
            ? 'normal' 
            : 'italic';


        //this.paramValue.controls[0].text.style.letterSpacing = settings.showBoolValues ? '0.1em' : 0; // this is if "true" and "false" are used
        
        this.paramValue.controls[0].showBar = !this.isUnknown();


        this.updateParamControls();
    }



    updateHeaderLabel()
    {
        //console.log('OperatorWithSymbol.updateHeaderLabel()');
        
        OperatorWithValue.prototype.updateHeaderLabel.call(this);


        const colBack = rgbFromType(this.type, this.active);
        const colText = isDark(colBack) ? [1, 1, 1] : [0, 0, 0];

        this._symbol.style.fontSize   = this._showOnlySymbol ? 17 : 12;
        this._symbol.style.fontWeight = this.active ? 'bold' : 'normal';
        this._symbol.style.color      = rgb2style(colText);
        this._symbol.style.left       = 'calc(50%)';
        

        //const padding = this.header.connectionPadding;
        const inputs  = this.headerInputs;


        const [inputY, inputHeight] = getHeaderConnY(inputs);//, padding, 5);

        if (this._showOnlySymbol)
        {
            this._symbol.style.top = inputY[0]/2 + inputHeight/2 - 3;
        }
        else
        {
            this._symbol.style.top = inputY[0]/2 + inputHeight/2 - 9;
            this.label  .style.top = 'calc(50% - 2px)';
        }
        

        this.label.style.visibility = this._showOnlySymbol ? 'hidden'  : 'visible';
    }



    paramsToJson(nTab = 0)
    {
        return '';
    }
}


class   OpEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_EQUAL, 'equal', 'equal', '=');
    }
}


class   OpNotEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_NOT_EQUAL, 'notEqual', 'not equal', '');
    }
}


class   OpLess
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_LESS, 'less', 'less', '<');
    }
}


class   OpLessOrEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_LESS_OR_EQUAL, 'lessOrEqual', 'less or equal', '');
    }
}


class   OpGreater
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_GREATER, 'greater', 'greater', '>');
    }
}


class   OpGreaterOrEqual
extends OpConditionBase
{
    constructor()
    {
        super(NUMBER_GREATER_OR_EQUAL, 'greaterOrEqual', 'greater or equal', '');
    }
}


class   OpText
extends ResizableBase
{
    paramValue;



    constructor()
    {
        super(TEXT, 'text', 'text');

        this.alwaysSaveParams = true;
        this.alwaysLoadParams = true;


        this.addInput (new Input (TEXT_TYPES, getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));

        this.addParam(this.paramValue = new TextParam('value', '', false, false));

        this.paramValue.controls[0].textbox.defPlaceholder  = '...';
        this.paramValue.controls[0].textbox.style.textAlign = 'center';


        this.header.addEventListener('pointerdown', e => this.paramValue.controls[0].textbox.blur());
    }



    setSize(w, h, updateTransform = true)
    {
        super.setSize(w, h, updateTransform);
        this.updateValueParam();
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        super.setRect(x, y, w, h, updateTransform);
        this.updateValueParam();
    }

    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return this.node.paramValue.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == TEXT_VALUE, 'expected TEXT_VALUE in backInit()');
        
        this.node.paramValue.setValue(value, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output        

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });
        
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];

        if (input.connected) request.push(...pushInputOrParam(input, gen));
        else                 request.push(...this.node.paramValue.genRequest(gen));

            
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(!this.inputs[0].connected);
        this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.updateValueParam();

        this.updateParamControls();
    }



    updateValueParam()
    {
        this.paramValue.controls[0].setSize(
            this.div.offsetWidth,
            this.div.offsetHeight - Math.max(defHeaderHeight, this.header.offsetHeight));
    }



    paramIsConsideredDefault(param)
    {
        return  param.isDefault()
            && !this.inputs[0].connected;
    }
}


class   OpTextSubstring
extends OperatorWithValue
{
    paramStart;
    paramEnd;



    constructor()
    {
        super(TEXT_SUBSTRING, 'substring', 'substring');

        this.canDisable = true;
        

        this.addInput (new Input (TEXT_TYPES));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramStart = new NumberParam('start', 'start', true, true, true, 0, 0));
        this.addParam(this.paramEnd   = new NumberParam('end',   'end',   true, true, true, 0, 0));


        this.paramValue.controls[0].textbox.style.textAlign = 'center';
        this.paramValue.controls[0].textbox.defPlaceholder  = '';

        this.paramStart.controls[0].allowEditDecimals = false;
        this.paramEnd  .controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramStart.genRequest(gen));
        request.push(...this.node.paramEnd  .genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        const length = values[paramIds.findIndex(id => id == 'length')];

        if (length.value > 0)
        {
            this.paramStart.controls[0].setMax(length.value-1);
            this.paramEnd  .controls[0].setMax(length.value-1);
        }
        else
        {
            this.paramStart.controls[0].resetMax();
            this.paramEnd  .controls[0].resetMax();
        }
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramStart.enableControlText(true);
        this.paramEnd  .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextCharacter
extends OperatorWithValue
{
    paramCode;



    constructor()
    {
        super(TEXT_CHAR, 'char', 'character');


        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramCode = new NumberParam('code', 'unicode', true,  true,  true, 32, 0, 0xFFFF));


        this.paramValue.controls[0].textbox.style.textAlign = 'center';

        this.paramCode.controls[0].showHex           = true;
        this.paramCode.controls[0].allowEditDecimals = false;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramCode.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramCode .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextReplace
extends OperatorWithValue
{
    paramWhat;
    paramWith;



    constructor()
    {
        super(TEXT_REPLACE, 'replace', 'replace');

        this.canDisable       = true;
        
        this.alwaysLoadParams = true;
        this.alwaysSaveParams = true;
        

        this.addInput (new Input (TEXT_TYPES));
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramWhat = new TextParam('what', 'what', true,  true));
        this.addParam(this.paramWith = new TextParam('with', 'with', true,  true));


        this.paramValue.controls[0].textbox.style.textAlign = 'center';
        this.paramWhat .controls[0].textbox.style.textAlign = 'center';
        this.paramWith .controls[0].textbox.style.textAlign = 'center';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramWhat.genRequest(gen));
        request.push(...this.node.paramWith.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramWhat .enableControlText(true);
        this.paramWith .enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextJoin
extends ResizableOperatorWithValue
{
    constructor()
    {
        super(TEXT_JOIN, 'join', 'join');

        this.variableInputs   = true;
        this.alwaysLoadParams = true;

        this.addNewInput();
        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);


        this.paramValue.controls[0].textbox.style.textAlign = 'center';
    }
    
    
    
    addNewInput()
    {
        const newInput = new Input(TEXT_TYPES);
        newInput.isNew = true;

        newInput.addEventListener('connect',    e => { onVariableConnectInput(this); e.detail.input.isNew = false; });
        newInput.addEventListener('disconnect', e => onVariableDisconnectInput(this, e.detail.input));

        this.addInput(newInput);

        return newInput;
    }



    setSize(w, h, updateTransform = true)
    {
        super.setSize(w, h, updateTransform);
        this.updateValueParam();
    }



    setRect(x, y, w, h, updateTransform = true)
    {
        super.setRect(x, y, w, h, updateTransform);
        this.updateValueParam();
    }

    
    
    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const connectedInputs = this.node.inputs.filter(i => i.connected && !i.param);


        request.push(connectedInputs.length); // utility values like param count are stored as numbers
        
        for (const input of connectedInputs)
            request.push(...pushInputOrParam(input, gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        this.updateValueParam();

        this.updateParamControls();
    }



    updateValueParam()
    {
        this.paramValue.controls[0].setSize(
            this.div.offsetWidth,
            this.div.offsetHeight - Math.max(defHeaderHeight, this.header.offsetHeight));
    }
}



class   OpTextCSV
extends OperatorBase
{
    paramValue;
    paramSeparator;



    constructor()
    {
        super(TEXT_CSV, 'csv', 'csv');


        this.addInput (new Input (TEXT_TYPES));
        this.addOutput(new Output([LIST_VALUE], this.output_genRequest));

        this.addParam(this.paramValue     = new ListParam('value',     '',          true, true));
        this.addParam(this.paramSeparator = new TextParam('separator', 'separator', true, true, ','));


        this.paramSeparator.controls[0].textbox.style.textAlign = 'center';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramSeparator.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        this.paramValue    .enableControlText(false);
        this.paramSeparator.enableControlText(true);

        this.updateParamControls();
    }
}


class   OpTextFetch
extends OperatorWithValue
{
    paramRequest;



    constructor()
    {
        super(TEXT_FETCH, 'fetch', 'fetch', defNodeWidth, true);

        this.canDisable       = true;

        this.alwaysLoadParams = true;
        this.alwaysSaveParams = true;


        this.addOutput(new Output([TEXT_VALUE], this.output_genRequest));

        this.addParam(this.paramValue);
        this.addParam(this.paramRequest = new TextParam('request', 'request', true,  true));


        this.paramValue  .controls[0].textbox.style.textAlign = 'center';
        this.paramRequest.controls[0].textbox.style.textAlign = 'center';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);
        
        if (input.connected)
            request.push(...pushInputOrParam(input, gen));

        request.push(...this.node.paramRequest.genRequest(gen));

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
        this.endNodeProgress();
    }



    updateParams()
    {
        this.paramValue.enableControlText(false);
        this.paramValue.controls[0].valueText = this.isUnknown() ? UNKNOWN_DISPLAY : '';

        this.paramRequest.enableControlText(true);

        this.updateParamControls();
    }
}


class OpColorBase
extends Operator
{
    _color = dataColor_NaN;

    _warningOverlay;
    
    forceShowWarning = false;
    warningStyle;
    


    constructor(type, id, name, progressBar = false, defWidth = defNodeWidth)
    {
        super(type, id, name, defWidth, progressBar);

        this.showActiveArrow = true;
        

        this._warningOverlay = createDiv('colorWarningOverlay');
        //this._warningOverlay.style.zIndex = 1;
        
        this.inner.appendChild(this._warningOverlay);


        this.header.addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.header.addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });
    }



    invalidate()
    {
        super.invalidate();

        //this._color = dataColor_NaN;
    }



    // updateValues(requestId, actionId, updateParamId, paramIds, values)
    // {
    //     //logFunction('OpColorBase.updateValues()');

    //     super.updateValues(requestId, actionId, updateParamId, paramIds, values);
        
    //     //this.updateHeader();
    // }



    canAutoConnectFrom(output)
    {
        return this.inputs[0].canConnectFrom(output);
    }



    updateHeader()
    {
        //console.log(this.id + '.OpColorBase.updateHeader()');

        super.updateHeader();


        const colors = this.getHeaderColors();

        this.header.style.background = 
            !rgbIsNaN(colors.stripeBack) //  rgbIsOk(colors.back)
            ? rgb2style(colors.stripeBack)
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));
            //: 'transparent';

        // this.colorBack.style.backgroundImage = 
        //     this.isUnknown()
        //     ? 'url(\'data:image/svg+xml;utf8,<svg width="8" height="13" viewBox="0 0 8 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.65341V8.54545C3.00758 7.84091 3.07765 7.2803 3.21023 6.86364C3.34659 6.44697 3.53977 6.10985 3.78977 5.85227C4.03977 5.5947 4.34091 5.35985 4.69318 5.14773C4.92045 5.00379 5.125 4.8428 5.30682 4.66477C5.48864 4.48674 5.63258 4.2822 5.73864 4.05114C5.8447 3.82008 5.89773 3.56439 5.89773 3.28409C5.89773 2.94697 5.81818 2.6553 5.65909 2.40909C5.5 2.16288 5.28788 1.97348 5.02273 1.84091C4.76136 1.70455 4.4697 1.63636 4.14773 1.63636C3.85606 1.63636 3.57765 1.69697 3.3125 1.81818C3.04735 1.93939 2.82765 2.12879 2.65341 2.38636C2.47917 2.64015 2.37879 2.9678 2.35227 3.36932H0.625C0.651515 2.6875 0.823864 2.11174 1.14205 1.64205C1.46023 1.16856 1.88068 0.810606 2.40341 0.568181C2.92992 0.325757 3.51136 0.204545 4.14773 0.204545C4.8447 0.204545 5.45455 0.335227 5.97727 0.596591C6.5 0.854166 6.9053 1.21591 7.19318 1.68182C7.48485 2.14394 7.63068 2.68371 7.63068 3.30114C7.63068 3.72538 7.56439 4.10795 7.43182 4.44886C7.29924 4.78598 7.10985 5.08712 6.86364 5.35227C6.62121 5.61742 6.32955 5.85227 5.98864 6.05682C5.66667 6.25758 5.4053 6.46591 5.20455 6.68182C5.00758 6.89773 4.86364 7.15341 4.77273 7.44886C4.68182 7.74432 4.63258 8.10985 4.625 8.54545V8.65341H3ZM3.85795 12.108C3.54735 12.108 3.2803 11.9981 3.05682 11.7784C2.83333 11.5549 2.72159 11.286 2.72159 10.9716C2.72159 10.661 2.83333 10.3958 3.05682 10.1761C3.2803 9.95265 3.54735 9.84091 3.85795 9.84091C4.16477 9.84091 4.42992 9.95265 4.65341 10.1761C4.88068 10.3958 4.99432 10.661 4.99432 10.9716C4.99432 11.1799 4.94129 11.3712 4.83523 11.5455C4.73295 11.7159 4.59659 11.8523 4.42614 11.9545C4.25568 12.0568 4.06629 12.108 3.85795 12.108Z" fill="white"/></svg>\')'
        //     : 'none';


        // this.colorBack.style.boxShadow =
        //     this.isUnknown()
        //     ? '0 0 0 1px ' + rgb2style(colors.border) + ' inset'
        //     : 'none';


        for (const input of this.headerInputs)
        {
            input.colorLight =
            input.colorDark  = colors.input;

            input.wireColor  = colors.wire;
        }


        for (const output of this.headerOutputs)
        {
            output.colorLight = 
            output.colorDark  = colors.output;

            output.wireColor  = colors.wire;
        }


        this.updateWarningOverlay();
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        const colors = this.getHeaderColors();
        this.label.style.color = rgba2style(colors.text);
    }



    getHeaderColors(options = {})
    {
        const noColor = 
            darkMode
            ? rgbNoColorDark
            : rgbNoColorLight;


        const rgbBack = 
            dataColorIsNaN(this._color)
            ? rgb_NaN
            : dataColor2rgb(this._color);
            

        let rgbStripeBack = getStripeBackColor(rgbBack);
        

        const rgbaBorder = rgb_a(rgbFromType(this.type, this.active), 0.95);

        const rgbText  = getTextColorFromBackColor(rgbStripeBack);

        const rgbaWire = 
            !rgbIsNaN(rgbStripeBack)   
            ? rgbStripeBack 
            : noColor;

        return {
            back:       rgb_a(rgbBack), 
            stripeBack: rgb_a(rgbStripeBack),
            border:     rgbaBorder,
            text:       rgb_a(rgbText, 0.9),
            input:      rgb_a(rgbText, 0.2),
            output:     rgb_a(rgbText, 0.2),
            wire:       rgbaWire };
    }



    updateWarningOverlay() 
    {
        //console.log(this.id + '.updateWarningOverlay()');

        const colors = this.getHeaderColors();
        

        if (!rgbaIsNaN(colors.back))
        {
            if (  !rgbIsValid(colors.back)
                || this.forceShowWarning)
            {
                if (!this.forceShowWarning)
                    this.warningStyle = getDefaultWarningStyle(colors.back);

                this.updateWarningOverlayStyle(colors.back);
            }
            else
                this._warningOverlay.style.display = 'none';
        }
        else
        {
            this.warningStyle = getDefaultWarningStyle(colors.back);
            this.updateWarningOverlayStyle(colors.back);
        }
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        this._warningOverlay.style.height = 
            height < 0
            ? this.measureData.headerOffset.height
            : height;

            
        const [warnStyle1, warnStyle2] = getWarningStyles(colBack);

        this._warningOverlay.style.background =
                rgbaIsOk(colBack)
            && !this.forceShowWarning
            ? 'transparent'
            : getWarningGradient(7.8, warnStyle1, warnStyle2);

            this._warningOverlay.style.backgroundPosition = '-6px 0';
            this._warningOverlay.style.backgroundSize     = 'calc(100% + 11px) 100%';
            this._warningOverlay.style.display            = 'block';
    }
}


class   OpColor
extends OpColorBase
{
    paramSpace;
    param1;
    param2;
    param3;
    paramColor;

    colorBack;


    prevSpace;
    prevSpaceConnections = [];


    _colorBeforeNaN = dataColor_NaN;



    constructor(options = {})
    {
        super(COLOR, 'color', 'color');

        this.canDisable = true;

        
        const defColor = ['hex', 0.85, 0.85, 0.85];

        this._color = 
            !!options.random
            ? ['hex', Math.random(), Math.random(), Math.random()]
            : [...defColor];
        
        this.prevSpace = 'hex';


        this.colorBack = createDiv('colorBack');
        this.inner.insertBefore(this.colorBack, this.paramHolder);


        this.addInput(new Input(COLOR_TYPES, getColorInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest, getColorOutputValuesForUndo, this.output_backInit));

        
        this.addParam(this.paramSpace = new SelectParam('space', 'space', false, true,  true,  ColorSpaces.map(s => s[1]), 0));
        this.addParam(this.param1     = new NumberParam('c1',    '',      true,  true,  true));
        this.addParam(this.param2     = new NumberParam('c2',    '',      true,  true,  true));
        this.addParam(this.param3     = new NumberParam('c3',    '',      true,  true,  true));
        
        this.addParam(this.paramColor = new ColorParam ('color', '',      false, false, false, ColorValue.fromRgb(scaleRgb(dataColor2rgb(this._color)))));


        this.paramSpace.alwaysSaveValue = true;
        this.param1    .alwaysSaveValue = true;
        this.param2    .alwaysSaveValue = true;
        this.param3    .alwaysSaveValue = true;

        this.param1.controls[0].epsilon = ColorEpsilon;
        this.param2.controls[0].epsilon = ColorEpsilon;
        this.param3.controls[0].epsilon = ColorEpsilon;

        this.paramSpace.controls[0].delayUse = 100; // so that you carelessly drag it by grabbing the space param
                                                    // while already moving the mouse with an aim to drag
        this.paramSpace.input.outputMustBeCached = true;

        this.paramSpace.addEventListener('change', () => 
        {
            if (this.paramSpace.value.toNumber() == 0)
            {
                if (this.param1.output.connected) this.param1.output.connectedInputs.forEach(i => uiDisconnect(i));
                if (this.param2.output.connected) this.param2.output.connectedInputs.forEach(i => uiDisconnect(i));
                if (this.param3.output.connected) this.param3.output.connectedInputs.forEach(i => uiDisconnect(i));

                if (this.param1.input.connected) uiDisconnect(this.param1.input);
                if (this.param2.input.connected) uiDisconnect(this.param2.input);
                if (this.param3.input.connected) uiDisconnect(this.param3.input);
            }
        });


        this.param1.setValue(new NumberValue(roundTo(this._color[1] * rgbFactor[0], this.param1.controls[0].dec)), false, true, false);
        this.param2.setValue(new NumberValue(roundTo(this._color[2] * rgbFactor[1], this.param2.controls[0].dec)), false, true, false);
        this.param3.setValue(new NumberValue(roundTo(this._color[3] * rgbFactor[2], this.param3.controls[0].dec)), false, true, false);


        this.paramSpace.controls[0].barTop = 0.8;

        this.paramSpace.controls[0].addEventListener('pointerenter', () => { this.header.over = true;  this.updateHeader(); });
        this.paramSpace.controls[0].addEventListener('pointerleave', () => { this.header.over = false; this.updateHeader(); });


        this.paramSpace.controls[0].wheelScale = 1;
        this.param1    .controls[0].wheelScale = 1;
        this.param2    .controls[0].wheelScale = 1;
        this.param3    .controls[0].wheelScale = 1;


        // hex is default, remove default sliders
        this.paramHolder.removeChild(this.param1.div);
        this.paramHolder.removeChild(this.param2.div);
        this.paramHolder.removeChild(this.param3.div);

        
        this.paramColor.controls[0].showColor = false;
        this.paramColor.showColorBack         = false;

        this.paramColor.addEventListener('change', () => 
        {
            this._color = this.paramColor.value.toDataColor();

            this.param1.setValue(new NumberValue(this._color[1] * rgbFactor[0]), false, true, false);
            this.param2.setValue(new NumberValue(this._color[2] * rgbFactor[1]), false, true, false);
            this.param3.setValue(new NumberValue(this._color[3] * rgbFactor[2]), false, true, false);
        });
    }



    input_getBackInitValue()
    {
        // 'this' is the input

        return this.node.paramColor.value;
    }



    output_backInit(value)
    {
        // 'this' is the output

        if (value.type == FILL_VALUE)
            value = value.color;


        console.assert(value.type == COLOR_VALUE, 'expected COLOR_VALUE in backInit()');

        const _color = convertDataColorToSpace(
            value.toDataColor(), 
            colorSpace(this.node.paramSpace.value.value));

        const _value = ColorValue.fromDataColor(_color);

        //this.node.paramSpace.setValue(value.space, false, true, false);
        this.node.param1.setValue(_value.c1, false, true, false);
        this.node.param2.setValue(_value.c2, false, true, false);
        this.node.param3.setValue(_value.c3, false, true, false);
    }



    getDataColorFromParams()
    {
        const col = getNormalColor_(
            colorSpace(this.paramSpace.value),
            this.param1.value,
            this.param2.value,
            this.param3.value);
    
        return [
            colorSpace(this.paramSpace.value),
            col[0],
            col[1],
            col[2] ];
    }
    
    
    
    setColorParams(color, fireChangeEvent = false)
    {
        const col = getScaledDataColor(color);

        this.param1.setValue(new NumberValue(col[1]), fireChangeEvent);
        this.param2.setValue(new NumberValue(col[2]), fireChangeEvent);
        this.param3.setValue(new NumberValue(col[3]), fireChangeEvent);
    }



    getTabParams()
    {
        return this.paramSpace.value.value == 0
            ? [this.paramSpace, this.paramColor]
            : this.params;
    }



    isConnected()
    {
        return this.inputs[0].connected
            //   skipping [1]
            || this.inputs[2].connected
            || this.inputs[3].connected
            || this.inputs[4].connected;
    }



    paramCanBeUnknown(param)
    {
        return param.id != this.paramSpace.id;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.param1.input.connected
            || this.node.param2.input.connected
            || this.node.param3.input.connected;

        const options = (hasInputs ? 1 : 0) << 20;

                
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));
            

            const paramIds = [];

            paramIds.push(this.node.paramSpace.id);

            for (const param of this.node.params.filter(p => p.id != this.node.paramSpace.id))
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));
            
                                                  request.push(...this.node.paramSpace.genRequest(gen));
            if (this.node.param1.input.connected) request.push(...this.node.param1    .genRequest(gen));
            if (this.node.param2.input.connected) request.push(...this.node.param2    .genRequest(gen));
            if (this.node.param3.input.connected) request.push(...this.node.param3    .genRequest(gen));
        }
        else
        {
            if (this.node.paramSpace.value == 0) // hex
            {
                request.push(
                    ...this.node.paramSpace.genRequest(gen),
                    NUMBER_VALUE, this.node.prevSpace.isValid() ? numToString(colorSpaceIndex(this.node.prevSpace)) : NAN_DISPLAY,
                    NUMBER_VALUE, numToString(this.node._color[1] * rgbScale[0]),
                    NUMBER_VALUE, numToString(this.node._color[2] * rgbScale[1]),
                    NUMBER_VALUE, numToString(this.node._color[3] * rgbScale[2]));
            }
            else
            {
                request.push(
                    ...this.node.paramSpace.genRequest(gen),
                    NUMBER_VALUE, this.node.prevSpace != NAN_DISPLAY ? numToString(colorSpaceIndex(this.node.prevSpace)) : NAN_DISPLAY,
                    ...this.node.param1.genRequest(gen),
                    ...this.node.param2.genRequest(gen),
                    ...this.node.param3.genRequest(gen));
            }
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const convert = values[paramIds.findIndex(id => id == 'convert')];
        const space   = values[paramIds.findIndex(id => id == 'space'  )];
        const c1      = values[paramIds.findIndex(id => id == 'c1'     )];
        const c2      = values[paramIds.findIndex(id => id == 'c2'     )];
        const c3      = values[paramIds.findIndex(id => id == 'c3'     )];

        if (space.isValid())
        {
            this.paramSpace.setValue(space, false, true, false);


            if (   convert.value != space.value
                || graphView.pastingNodes
                || graphView.loadingNodes
                || graphView.restoringNodes)
                switchToSpace(this, colorSpace(space.value));
            

            if (c1) this.param1.setValue(c1, false, true, false);
            if (c2) this.param2.setValue(c2, false, true, false);
            if (c3) this.param3.setValue(c3, false, true, false);


            const _space = this.paramSpace.value;
            const _c1    = this.param1    .value;
            const _c2    = this.param2    .value;
            const _c3    = this.param3    .value;

            const valid =
                   _space && _space.isValid()
                && _c1    && _c1   .isValid()
                && _c2    && _c2   .isValid()
                && _c3    && _c3   .isValid();


            if (valid)
            {
                this._color =
                    this.isUnknown()
                    ? dataColor_NaN
                    : makeDataColor(_space, _c1, _c2, _c3);

                this.outputs[0].wireColor = 
                    this.isUnknown()
                    ? rgbFromType(CACHE, true)
                    : dataColor2rgb(this._color);

                this.prevSpace = colorSpace(_space.value);
            }
            else
            {
                this.paramColor.setValue(ColorValue.NaN, false, true, false);

                this._color    = dataColor_NaN;
                this.prevSpace = NAN_DISPLAY;

                this.outputs[0].wireColor = rgb_NaN;
            }
        }
        else
        {
            this.paramSpace.setValue(NumberValue.NaN, false, true, false);
            removeParamDivs(this);

            this._color    = dataColor_NaN;
            this.prevSpace = NAN_DISPLAY;
        }
    }



    updateNode()
    {
        if (!hasFocus(this.paramColor.controls[0]))
            this.paramColor.setValue(ColorValue.fromRgb(scaleRgb(dataColor2rgb(this._color))), false, true, false);// = 
        

        const colors = this.getHeaderColors();

        const colSpaceBar = 
              !rgbIsNaN(colors.back)
            && isDark(colors.back)
            ? [1, 1, 1, 0.12]
            : [0, 0, 0, 0.09]; 


        this.paramSpace.controls[0].setMax(colorSpaceCount()-1);


        this.paramSpace.controls[0].backStyleLight  =
        this.paramSpace.controls[0].backStyleDark   = 'transparent';

        this.paramSpace.controls[0].valueStyleLight =
        this.paramSpace.controls[0].valueStyleDark  = rgba2style(colSpaceBar);

        this.paramSpace.controls[0].textStyleLight  =
        this.paramSpace.controls[0].textStyleDark   = rgba2style(colors.text);


        this.paramSpace. input.colorLight           =
        this.paramSpace. input.colorDark            = colors.input;

        this.paramSpace.output.colorLight           =
        this.paramSpace.output.colorDark            = colors.output;


        super.updateNode();
    }



    updateHeader()
    {
        super.updateHeader();

        
        this.header.style.background = 'transparent';

        
        const colors = this.getHeaderColors();

        const unknownBackStyle = darkMode ? '#444' : '#ccc';


        this.colorBack.style.background = 
            this.isUnknown()
            ? unknownBackStyle
            : !rgbIsNaN(colors.stripeBack)
              ? rgba2style(colors.stripeBack)
              : rgba2style(rgb_a(rgbDocumentBody, 0.95));

        this.colorBack.style.backgroundImage = 
            this.isUnknown()
            ? 'url(\'data:image/svg+xml;utf8,<svg width="45" height="65" viewBox="0 0 9 13" fill="none" xmlns="http://www.w3.org/2000/svg"><path opacity="0.1" d="M3.04545 8.51136V8.31818C3.04924 7.6553 3.10795 7.12689 3.22159 6.73295C3.33902 6.33902 3.50947 6.02083 3.73295 5.77841C3.95644 5.53598 4.22538 5.31629 4.53977 5.11932C4.77462 4.9678 4.98485 4.81061 5.17045 4.64773C5.35606 4.48485 5.50379 4.30492 5.61364 4.10795C5.72349 3.9072 5.77841 3.68371 5.77841 3.4375C5.77841 3.17614 5.71591 2.94697 5.59091 2.75C5.46591 2.55303 5.29735 2.40151 5.08523 2.29545C4.87689 2.18939 4.64583 2.13636 4.39205 2.13636C4.14583 2.13636 3.91288 2.19129 3.69318 2.30114C3.47348 2.4072 3.29356 2.56629 3.15341 2.77841C3.01326 2.98674 2.9375 3.24621 2.92614 3.55682H0.607955C0.626894 2.79924 0.808712 2.17424 1.15341 1.68182C1.49811 1.18561 1.95455 0.816288 2.52273 0.573863C3.09091 0.327651 3.7178 0.204545 4.40341 0.204545C5.1572 0.204545 5.82386 0.329545 6.40341 0.579545C6.98295 0.825757 7.4375 1.18371 7.76705 1.65341C8.09659 2.12311 8.26136 2.68939 8.26136 3.35227C8.26136 3.79545 8.1875 4.18939 8.03977 4.53409C7.89583 4.875 7.69318 5.17803 7.43182 5.44318C7.17045 5.70455 6.86174 5.94129 6.50568 6.15341C6.20644 6.33144 5.96023 6.51705 5.76705 6.71023C5.57765 6.90341 5.43561 7.12689 5.34091 7.38068C5.25 7.63447 5.20265 7.94697 5.19886 8.31818V8.51136H3.04545ZM4.17045 12.1477C3.79167 12.1477 3.4678 12.0152 3.19886 11.75C2.93371 11.4811 2.80303 11.1591 2.80682 10.7841C2.80303 10.4129 2.93371 10.0947 3.19886 9.82955C3.4678 9.56439 3.79167 9.43182 4.17045 9.43182C4.5303 9.43182 4.84659 9.56439 5.11932 9.82955C5.39205 10.0947 5.5303 10.4129 5.53409 10.7841C5.5303 11.0341 5.46402 11.2633 5.33523 11.4716C5.21023 11.6761 5.04545 11.8409 4.84091 11.9659C4.63636 12.0871 4.41288 12.1477 4.17045 12.1477Z" fill="' + (darkMode ? 'white' : 'black') + '"/></svg>\')'
            : 'none';

        this.colorBack.style.height = defHeaderHeight + defParamHeight;

        this.colorBack.style.backgroundPosition = '50% 50%';
        this.colorBack.style.backgroundRepeat   = 'no-repeat';


        this.label.style.color = rgba2style(colors.text);

         
        this. inputs[0].colorLight =
        this. inputs[0].colorDark  = colors.input;
        this. inputs[0].wireColor  = rgb_a(colors.wire);

        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = colors.output; 
        this.outputs[0].wireColor  = rgb_a(colors.wire);


        if (this.isUnknown())
            this._warningOverlay.style.display = 'none';

        else
        {
            const colWarning = 
                isDark(colors.back)
                ? [1, 1, 1, 0.2 ]
                : [0, 0, 0, 0.12];

            this.warningStyle = 
                rgbIsValid(colors.back) 
                ? 'transparent' 
                :  rgba2style(colWarning);

                
            this.updateWarningOverlay();
            this.updateWarningOverlayStyle(colors.back, defHeaderHeight + defParamHeight);
        }
    }



    updateParams()
    {
        this.updateAllControlRanges();


        const enable = !this.inputs[0].connected;

        this.paramSpace.enableControlText(!this.paramSpace.input.connected);
        this.param1    .enableControlText(enable);
        this.param2    .enableControlText(enable);
        this.param3    .enableControlText(enable);


        enableElementText(this.paramColor.controls[0].div, !this.isConnected());


        const colors = this.getHeaderColors();

        this.paramSpace.controls[0].textbox.style.color      = rgba2style(colors.text);
        this.paramSpace.controls[0].textbox.style.background = 'transparent';


        this.updateParamControls();


        this.paramColor._warningOverlay.style.display = 'none';
    }



    resetAllControlRanges()
    {
        this.param1.controls[0].resetRanges();
        this.param2.controls[0].resetRanges();
        this.param3.controls[0].resetRanges();
    }



    updateAllControlRanges()
    {
        //const warnLineStyle = getWarningRangeStyle();

        const space = this.paramSpace.value.value;

        if (    (   space == 1  // RGB
                 || space == 2  // HSV
                 || space == 3) // HSL
             && !dataColorIsNaN  (this._color)
             && !dataColorIsValid(this._color))
        {
            this.showExtRanges(true);
        }
        else if ( space > 3 // HCL
              && !dataColorIsNaN(this._color))
        {
            this.showExtRanges(false);

            this.updateControlRanges(this.param1.controls[0], f =>
                dataColor2rgb([
                    this._color[0],
                    (this.param1.controls[0].displayMin + f * (this.param1.controls[0].displayMax - this.param1.controls[0].displayMin)) / colorSpaceFactor(this._color[0])[0],
                    this._color[2],
                    this._color[3]]));

            this.updateControlRanges(this.param2.controls[0], f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    (this.param2.controls[0].displayMin + f * (this.param2.controls[0].displayMax - this.param2.controls[0].displayMin)) / colorSpaceFactor(this._color[0])[1],
                    this._color[3]]));

            this.updateControlRanges(this.param3.controls[0], f =>
                dataColor2rgb([
                    this._color[0],
                    this._color[1],
                    this._color[2],
                    (this.param3.controls[0].displayMin + f * (this.param3.controls[0].displayMax - this.param3.controls[0].displayMin)) / colorSpaceFactor(this._color[0])[2]]));
        }
        else // no warning ranges
        {
            this.resetAllControlRanges();
            this.showExtRanges(false);
        }
    }



    showExtRanges(show)
    {
        this.param1.controls[0].showExtRanges = show;
        this.param2.controls[0].showExtRanges = show;
        this.param3.controls[0].showExtRanges = show;
    }



    updateControlRanges(control, getRgb)
    {
        const warnLineStyle = getWarningRangeStyle();


        const ranges    = [];
 
        
        const precision = 0.01;
        let   open      = false;

        for (let f = 0; f <= 1; f += precision)
        {
            const rgb = getRgb(f);

            if (!open && !rgbIsValid(rgb))
            {
                ranges.push(new NumberControlRange(f, f, warnLineStyle, 0.8));
                open = true;
            }
            else if (open && rgbIsValid(rgb)) 
            {
                ranges.at(-1).end = f;
                open = false;
            }
        }

        
        if (open)
            ranges.at(-1).end = 1;
        else if (!open
              && isEmpty(ranges))
            control.resetRanges();


        control.ranges = ranges;
    }



    paramIsConsideredDefault(param)
    {
        return super.paramIsConsideredDefault(param)
            && !this.inputs[0].connected
            && (  !this.paramSpace.input.connected
                || this.paramSpace.value == 0);
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let json = super.toJsonBase(nTab);

        json += ',\n' + pos + tab + '"prevSpace": "' + this.prevSpace + '"';

        if (!dataColorIsNaN(this._colorBeforeNaN))
            json += ',\n' + pos + tab + '"colorBeforeNaN":\n' + dataColorToJson(this._colorBeforeNaN, 4);

        return json;
    }



    paramsToJson(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;


        let json =
             ',\n'
            + pos + tab + '"params":\n'
            + pos + tab + '[\n';
        

        let first = true;
        for (let i = 0; i < this.params.length-1; i++) // -1 is for paramColor
        {
            const param = this.params[i];

            if (!this.paramIsConsideredDefault(param))
            {
                if (!first) json += ',\n'; first = false;

                json += 
                      pos + tab + tab 
                    + param.toJson(nTab, i > 0 ? 'c' + i : '');
            }
        }


        if (!first)
            json += '\n';

        json += pos + tab + ']';


        return json;
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);


        if (_node.colorBeforeNaN)
            this._colorBeforeNaN = _node.colorBeforeNaN;

        this.prevSpace = _node.prevSpace;    


        if (this.paramSpace.value.isValid())
        {
            const space  = colorSpace(Math.max(1, this.paramSpace.value.value));
            const factor = colorFactor(space);

            this._color = [
                space,
                this.param1.value.value / factor[0],
                this.param2.value.value / factor[1],
                this.param3.value.value / factor[2]];
        }
        else
            this._color = dataColor_NaN;
    }



    restoreParamUndoValue(value)
    {
        if (value.paramId == 'color')
        {
            super.restoreParamUndoValue({paramId: 'space', value: value.value.space});
            super.restoreParamUndoValue({paramId: 'c1',    value: value.value.c1   });
            super.restoreParamUndoValue({paramId: 'c2',    value: value.value.c2   });
            super.restoreParamUndoValue({paramId: 'c3',    value: value.value.c3   });
        }
        else
            super.restoreParamUndoValue(value);
    }
}



function getColorInputValuesForUndo(input)
{
    return [{
        paramId: 'color', 
        value:    ColorValue.fromDataColor(input.node._color)
    }];
}



function getColorOutputValuesForUndo(output)
{
    return [{
        paramId: 'color', 
        value:   ColorValue.fromDataColor(output.node._color)
    }];
}


function colorSpace     (index) { return ColorSpaces[index][0]; }
function colorSpaceIndex(space) { return ColorSpaces.findIndex(s => s[0] == space); }

function colorSpaceCount(parse = null)
{ 
    const set = parse ? parse.settings : settings;

    return set.showAllColorSpaces 
           ? ColorSpaces.length
        : ColorSpaces.length - 5; 
}



const rgbFactor  = [255, 255, 255];
const hs_Factor  = [360, 100, 100];
const hclFactor  = [360, 100, 100];
const oppFactor  = [100, 100, 100];
  
 
const rgbScale   = [255, 255, 255];
  
const hs_Scale   = [360, 100, 100];
 
const hclokScale = [360, 50,  100];
const hclabScale = [360, 400, 100];
const hcluvScale = [360, 330, 100];
 
 
const oklabScale = [100,  30,  30];
const labScale   = [100, 100, 100];
const luvScale   = [100, 150, 150];
 


function colorFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':
        case 'hsl':   return hs_Factor;

        case 'hclok':
        case 'hclab':
        case 'hcluv': return hclFactor;

        case 'oklab':  
        case 'lab':      
        case 'luv':   return oppFactor;   
        
        default:      console.assert(false, 'invalid color factor from space \''+space+'\''); break;
    }
}



function scaleColor(col, space)
{
    let scale;

    switch (space)
    {
        case 'hex':    
        case 'rgb':   scale = rgbScale;   break;

        case 'hsv':    
        case 'hsl':   scale = hs_Scale;   break;

        case 'hclok': scale = hclokScale; break;
        case 'hclab': scale = hclabScale; break;
        case 'hcluv': scale = hcluvScale; break;

        case 'oklab': scale = oklabScale; break;
        case 'lab':   scale = labScale;   break;
        case 'luv':   scale = luvScale;   break;
    }

    return [
        col[0] * scale[0],
        col[1] * scale[1],
        col[2] * scale[2] ];
}



function scaleRgb(rgb)
{
    return scaleColor(rgb, 'rgb');
}



function switchToSpace(node, space)
{
    switch (space)
    {
        case 'hex':   switchToHex   (node); break;
        case 'rgb':   switchToRgb   (node); break;

        case 'hsv':   switchToHsv   (node); break;
        case 'hsl':   switchToHsl   (node); break;

        case 'hclok': switchToHclok (node); break;
        case 'hclab': switchToHclab (node); break;
        case 'hcluv': switchToHcluv (node); break;

        case 'oklab': switchToOklab (node); break;
        case 'lab':   switchToLab   (node); break;
        case 'luv':   switchToLuv   (node); break;
    }

    node.resetAllControlRanges();
}



function switchToHex  (node) { switchToRgbControls   (node); switchToTextbox(node); }
function switchToRgb  (node) { switchToRgbControls   (node);                        }

function switchToHsv  (node) { switchToHs_Controls   (node, 'V');                   }
function switchToHsl  (node) { switchToHs_Controls   (node, 'L');                   }
             
function switchToHclok(node) { switchToHclOklControls(node);                        }
function switchToHclab(node) { switchToHclLabControls(node);                        }
function switchToHcluv(node) { switchToHclLuvControls(node);                        }
             
function switchToOklab(node) { switchToOklabControls (node, 'a', 'b');              }
function switchToLab  (node) { switchToLabControls   (node, 'a', 'b');              }
function switchToLuv  (node) { switchToLuvControls   (node, 'u', 'v');              }
   


function switchToRgbControls(node)
{
    switchToControls(node, 
        'R', 0, rgbScale[0], '', false, 
        'G', 0, rgbScale[1], 
        'B', 0, rgbScale[2]);  

    node.param1.controls[0].min = 
    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param1.controls[0].max = 
    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false);    
}



function switchToHs_Controls(node, v_or_l) 
{ 
    switchToControls(node, 
        'H',    0, hs_Scale[0], '', true,  
        'S',    0, hs_Scale[1], 
        v_or_l, 0, hs_Scale[2]);  

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclControls(node, scale) 
{ 
    switchToControls(node, 
        'H', 0, scale[0], '', true,  
        'C', 0, scale[1], 
        'L', 0, scale[2]);  

    node.param2.controls[0].min = 
    node.param3.controls[0].min = Number.MIN_SAFE_INTEGER; // allow extrapolation

    node.param2.controls[0].max = 
    node.param3.controls[0].max = Number.MAX_SAFE_INTEGER; // allow extrapolation

    showRgbControlHex(node, false); 
}



function switchToHclOklControls(node) { switchToHclControls(node, hclokScale); }
function switchToHclLabControls(node) { switchToHclControls(node, hclabScale); }
function switchToHclLuvControls(node) { switchToHclControls(node, hcluvScale); }



function switchToOppControls(node, c2, c3, scale)
{ 
    switchToControls(node, 
        'L', 0,        scale[0], '', false,  
        c2, -scale[1], scale[1], 
        c3, -scale[2], scale[2]);  

    showRgbControlHex(node, false); 
}



function switchToOklabControls(node) { switchToOppControls(node, 'a', 'b', oklabScale); }
function switchToLabControls  (node) { switchToOppControls(node, 'a', 'b', labScale  ); }
function switchToLuvControls  (node) { switchToOppControls(node, 'u', 'v', luvScale  ); }



function showRgbControlHex(node, show)
{
    node.param1.controls[0].showHex = show;
    node.param2.controls[0].showHex = show;
    node.param3.controls[0].showHex = show;
}



function switchToControls(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max)
{
    switchToSliders(node);

    node.param1.setName(c1, false); 
    node.param2.setName(c2, false); 
    node.param3.setName(c3, false);

    node.param1.controls[0].wrapValue = c1wrap;
    node.param1.controls[0].setSuffix(c1suffix, c1suffix != '');

    node.param1.controls[0].setMin(c1min); 
    node.param2.controls[0].setMin(c2min);
    node.param3.controls[0].setMin(c3min);
    
    node.param1.controls[0].setMax(c1max); 
    node.param2.controls[0].setMax(c2max); 
    node.param3.controls[0].setMax(c3max); 
    
    node.param1.updateControls();
    node.param2.updateControls();
    node.param3.updateControls();
}



function switchToTextbox(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div, node.paramHolder);
    removeDivFrom(node.param2.div, node.paramHolder);
    removeDivFrom(node.param3.div, node.paramHolder);
        
    appendDivTo(node.paramColor.div, node.paramHolder);
}



function removeParamDivs(node)
{
    removeOpColorParamWires(node);

    removeDivFrom(node.param1.div,     node.paramHolder);
    removeDivFrom(node.param2.div,     node.paramHolder);
    removeDivFrom(node.param3.div,     node.paramHolder);
    
    removeDivFrom(node.paramColor.div, node.paramHolder);
}



function removeOpColorParamWires(node)
{
    for (let i = node.inputs.length-1; i >= 2; i--)
        if (node.inputs[i].connected)
            uiDisconnect(node.inputs[i]);

    for (let i = node.outputs.length-1; i >= 2; i--)
        for (const input of node.outputs[i].connectedInputs)
            uiDisconnect(input);
}



function switchToSliders(node)
{
    removeDivFrom(node.paramColor.div, node.paramHolder);

    appendDivTo(node.param1.div, node.paramHolder);
    appendDivTo(node.param2.div, node.paramHolder);
    appendDivTo(node.param3.div, node.paramHolder);
}



function rgb2dataColor(rgb)
{
    return [
       'rgb',
        rgb[0],
        rgb[1],
        rgb[2] ];
}



function getNormalColorValue(value, space, chan)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalValueRgb_(value, chan);

        case 'hsv':   
        case 'hsl':   return getNormalValueHs_ (value, chan);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalValueHcl (value, chan);

        case 'oklab':  
        case 'lab':    
        case 'luv':   return getNormalValueOpp (value, chan);
    }
}



function getNormalValueRgb_(value, chan)
{
    switch (chan)
    {
        case 0: return value / rgbFactor[0];
        case 1: return value / rgbFactor[1]; 
        case 2: return value / rgbFactor[2];
    }
}



function getNormalValueHs_(value, chan)
{
    switch (chan)
    {
        case 0: return value / hs_Factor[0];
        case 1: return value / hs_Factor[1]; 
        case 2: return value / hs_Factor[2];
    }
}



function getNormalValueOpp(value, chan)
{
    switch (chan)
    {
        case 0: return value / oppFactor[0];
        case 1: return value / oppFactor[1]; 
        case 2: return value / oppFactor[2];
    }
}



function getNormalValueHcl(value, chan)
{
    switch (chan)
    {
        case 0: return value / hclFactor[0];
        case 1: return value / hclFactor[1]; 
        case 2: return value / hclFactor[2];
    }
}



function getNormalColor(color)
{
    return getNormalColor_(
        color[0], 
        color[1], 
        color[2], 
        color[3])
}



function getNormalColor_(space, c1, c2, c3)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return getNormalColorRgb_(c1, c2, c3);

        case 'hsv':   
        case 'hsl':   return getNormalColorHs_(c1, c2, c3);

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return getNormalColorHcl(c1, c2, c3);

        case 'oklab': 
        case 'lab': 
        case 'luv':   return getNormalColorOpp(c1, c2, c3);
    }
}



function getNormalColorRgb_(c1, c2, c3)
{
    return [
        c1 / rgbFactor[0], 
        c2 / rgbFactor[1], 
        c3 / rgbFactor[2]];
}



function getNormalColorHs_(c1, c2, c3)
{
    return [
        c1 / hs_Factor[0], 
        c2 / hs_Factor[1], 
        c3 / hs_Factor[2]];
}



function getNormalColorHcl(c1, c2, c3)
{
    return [
        c1 / hclFactor[0], 
        c2 / hclFactor[1], 
        c3 / hclFactor[2]];
}



function getNormalColorOpp(c1, c2, c3)
{
    return [
        c1 / oppFactor[0], 
        c2 / oppFactor[1], 
        c3 / oppFactor[2]];
}



function getScaledDataColor(color)
{
    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return getScaledDataColorRgb(         color[1], color[2], color[3]);

        case 'hsv':   return getScaledDataColorHs_('hsv',   color[1], color[2], color[3]);
        case 'hsl':   return getScaledDataColorHs_('hsl',   color[1], color[2], color[3]);

        case 'hclok': return getScaledDataColorHcl('hclok', color[1], color[2], color[3]);
        case 'hclab': return getScaledDataColorHcl('hclab', color[1], color[2], color[3]);
        case 'hcluv': return getScaledDataColorHcl('hcluv', color[1], color[2], color[3]);

        case 'oklab': return getScaledDataColorOpp('oklab', color[1], color[2], color[3]);
        case 'lab':   return getScaledDataColorOpp('lab',   color[1], color[2], color[3]);
        case 'luv':   return getScaledDataColorOpp('luv',   color[1], color[2], color[3]);
    }
}



function getScaledDataColorRgb(c1, c2, c3)
{
    return [
       'rgb',
        c1 * rgbFactor[0], 
        c2 * rgbFactor[1], 
        c3 * rgbFactor[2] ];
}



function getScaledDataColorHs_(space, c1, c2, c3)
{
    return [
        space,
        c1 * hs_Factor[0], 
        c2 * hs_Factor[1], 
        c3 * hs_Factor[2] ];
}



function getScaledDataColorHcl(space, c1, c2, c3)
{
    return [
        space,
        c1 * hclFactor[0], 
        c2 * hclFactor[1], 
        c3 * hclFactor[2] ];
}



function getScaledDataColorOpp(space, c1, c2, c3)
{
    return [
        space,
        c1 * oppFactor[0], 
        c2 * oppFactor[1], 
        c3 * oppFactor[2] ];
}



function setDataColorToCurrentSpace(node, color)
{
    const toSpace = colorSpace(node.paramSpace.value);
    node._color   = convertDataColorToSpace(color, toSpace);

    node.setColorParams(node._color);
}



function colorSpaceFactor(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbFactor;

        case 'hsv':   
        case 'hsl':   return hs_Factor;

        case 'hclok': 
        case 'hclab': 
        case 'hcluv': return hclFactor;

        case 'oklab': 
        case 'lab': 
        case 'luv':   return oppFactor;
    }    
}



function getColorSpaceScale(space)
{
    switch (space)
    {
        case 'hex':
        case 'rgb':   return rgbScale;

        case 'hsv':   
        case 'hsl':   return hs_Scale;

        case 'hclok': return hclokScale;
        case 'hclab': return hclabScale;
        case 'hcluv': return hcluvScale;

        case 'oklab': return oklabScale;
        case 'lab':   return labScale;
        case 'luv':   return luvScale;
    }    
}


function dataColor2array(color)
{
    return [
        color[1], 
        color[2], 
        color[3]];
}



function dataColor2rgb(color)
{
    const col = dataColor2array(color);

    switch (color[0])
    {
        case 'hex':
        case 'rgb':   return           col;

        case 'hsv':   return hsv2rgb  (col);
        case 'hsl':   return hsl2rgb  (col);

        case 'hclok': return hclok2rgb(col);
        case 'hclab': return hclab2rgb(col);
        case 'hcluv': return hcluv2rgb(col);

        case 'oklab': return oklab2rgb(col);
        case 'lab':   return lab2rgb  (col);
        case 'luv':   return luv2rgb  (col);
    }
}



function convertDataColorToSpace(color, toSpace)
{
    switch (toSpace)
    {
        case 'hex':    
        case 'rgb':   return convert2rgb    (color);

        case 'hsv':   return convert2hsv    (color);
        case 'hsl':   return convert2hsl    (color);

        case 'hclok': return convert2hclok  (color);
        case 'hclab': return convert2hclab  (color);
        case 'hcluv': return convert2hcluv  (color);

        case 'oklab': return dataColor2oklab(color);
        case 'lab':   return convert2lab    (color);
        case 'luv':   return convert2luv    (color);
    }
}



function convert2rgb(fromColor)
{
    const col = dataColor2array(fromColor);

    let rgb;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   rgb =           col;  break;

        case 'hsv':   rgb = hsv2rgb  (col); break;
        case 'hsl':   rgb = hsl2rgb  (col); break;

        case 'hclok': rgb = hclok2rgb(col); break;
        case 'hclab': rgb = hclab2rgb(col); break;
        case 'hcluv': rgb = hcluv2rgb(col); break;

        case 'oklab': rgb = oklab2rgb(col); break;
        case 'lab':   rgb = lab2rgb  (col); break;
        case 'luv':   rgb = luv2rgb  (col); break;
    }

    return rgb2dataColor(rgb);
}



function convert2hsv(fromColor)
{
    const col = dataColor2array(fromColor);
    
    let hsv;
    
    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsv = rgb2hsv(          col ); break;

        case 'hsv':   hsv =                   col;   break;
        case 'hsl':   hsv = rgb2hsv(hsl2rgb  (col)); break;

        case 'hclok': hsv = rgb2hsv(hclok2rgb(col)); break;
        case 'hclab': hsv = rgb2hsv(hclab2rgb(col)); break;
        case 'hcluv': hsv = rgb2hsv(hcluv2rgb(col)); break;

        case 'oklab': hsv = rgb2hsv(oklab2rgb(col)); break;
        case 'lab':   hsv = rgb2hsv(lab2rgb  (col)); break;
        case 'luv':   hsv = rgb2hsv(luv2rgb  (col)); break;
    }
    
    if (isNaN(hsv[0]))
        hsv[0] = 5/6;
    
    return [
       'hsv',
        hsv[0],
        hsv[1],
        hsv[2] ];
}



function convert2hsl(fromColor)
{
    const col = dataColor2array(fromColor);

    let hsl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hsl = rgb2hsl(          col ); break;

        case 'hsv':   hsl = rgb2hsl(hsv2rgb  (col)); break;
        case 'hsl':   hsl =                   col;   break;

        case 'hclok': hsl = rgb2hsl(hclok2rgb(col)); break;
        case 'hclab': hsl = rgb2hsl(hclab2rgb(col)); break;
        case 'hcluv': hsl = rgb2hsl(hcluv2rgb(col)); break;

        case 'oklab': hsl = rgb2hsl(oklab2rgb(col)); break;
        case 'lab':   hsl = rgb2hsl(lab2rgb  (col)); break;
        case 'luv':   hsl = rgb2hsl(luv2rgb  (col)); break;
    }

    return [
       'hsl',
        hsl[0],
        hsl[1],
        hsl[2] ];
}



function dataColor2oklab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2oklab(          col ); break;

        case 'hsv':   lab = rgb2oklab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2oklab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2oklab(hclok2rgb(col)); break;
        case 'hclab': lab = rgb2oklab(hclab2rgb(col)); break;
        case 'hcluv': lab = rgb2oklab(hcluv2rgb(col)); break;

        case 'oklab': lab =                     col;   break;
        case 'lab':   lab = rgb2oklab(lab2rgb  (col)); break;
        case 'luv':   lab = rgb2oklab(luv2rgb  (col)); break;
    }

    return [
       'oklab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2lab(fromColor)
{
    const col = dataColor2array(fromColor);

    let lab;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   lab = rgb2lab(          col ); break;

        case 'hsv':   lab = rgb2lab(hsv2rgb  (col)); break;
        case 'hsl':   lab = rgb2lab(hsl2rgb  (col)); break;

        case 'hclok': lab = rgb2lab(hclok2rgb(col)); break;
        case 'hclab': lab =         hclab2lab(col);  break;
        case 'hcluv': lab = rgb2lab(hcluv2rgb(col)); break;

        case 'oklab': lab = rgb2lab(oklab2rgb(col)); break;
        case 'lab':   lab =                   col;   break;
        case 'luv':   lab = rgb2lab(luv2rgb  (col)); break;
    }

    return [
       'lab',
        lab[0],
        lab[1],
        lab[2] ];
}



function convert2luv(fromColor)
{
    const col = dataColor2array(fromColor);

    let luv;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   luv = rgb2luv(          col ); break;

        case 'hsv':   luv = rgb2luv(hsv2rgb  (col)); break;
        case 'hsl':   luv = rgb2luv(hsl2rgb  (col)); break;

        case 'hclok': luv = rgb2luv(hclok2rgb(col)); break;
        case 'hclab': luv = rgb2luv(hclab2rgb(col)); break;
        case 'hcluv': luv =         hcluv2luv(col);  break;

        case 'oklab': luv = rgb2luv(oklab2rgb(col)); break;
        case 'lab':   luv = rgb2luv(lab2rgb  (col)); break;
        case 'luv':   luv =                   col;   break;
    }

    return [
       'luv',
        luv[0],
        luv[1],
        luv[2] ];
}



function convert2hclok(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclok(          col);  break;

        case 'hsv':   hcl = rgb2hclok(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclok(hsl2rgb  (col)); break;

        case 'hclok': hcl =                     col;   break;
        case 'hclab': hcl = rgb2hclok(hclab2rgb(col)); break;
        case 'hcluv': hcl = rgb2hclok(hcluv2rgb(col)); break;

        case 'oklab': hcl = rgb2hclok(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hclok(lab2rgb  (col)); break;
        case 'luv':   hcl = rgb2hclok(luv2rgb  (col)); break;
    }

    return [
       'hclok',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hclab(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hclab(          col) ; break;
        
        case 'hsv':   hcl = rgb2hclab(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hclab(hsl2rgb  (col)); break;
        
        case 'hclok': hcl = rgb2hclab(hclok2rgb(col)); break;
        case 'hclab': hcl =                     col;   break;
        case 'hcluv': hcl = rgb2hclab(hcluv2rgb(col)); break;
        
        case 'oklab': hcl = rgb2hclab(oklab2rgb(col)); break;
        case 'lab':   hcl = lab2hclab(          col ); break;
        case 'luv':   hcl = rgb2hclab(luv2rgb  (col)); break;
    }

    return [
       'hclab',
        hcl[0],
        hcl[1],
        hcl[2] ];
}



function convert2hcluv(fromColor)
{
    const col = dataColor2array(fromColor);

    let hcl;

    switch (fromColor[0])
    {
        case 'hex':
        case 'rgb':   hcl = rgb2hcluv(          col ); break;

        case 'hsv':   hcl = rgb2hcluv(hsv2rgb  (col)); break;
        case 'hsl':   hcl = rgb2hcluv(hsl2rgb  (col)); break;

        case 'hclab': hcl = rgb2hcluv(hclab2rgb(col)); break;
        case 'hcluv': hcl =                     col;   break;
        case 'hclok': hcl = rgb2hcluv(hclok2rgb(col)); break;

        case 'oklab': hcl = rgb2hcluv(oklab2rgb(col)); break;
        case 'lab':   hcl = rgb2hcluv(lab2rgb  (col)); break;
        case 'luv':   hcl = luv2hcluv(          col ); break;
    }

    return [
       'hcluv',
        hcl[0],
        hcl[1],
        hcl[2] ];
}


class   OpValidColor
extends OpColorBase
{
    paramQuality;

    corrections = [];

    

    constructor()
    {
        super(VALID_COLOR, 'valid', 'valid', true);

        this.canDisable = true;
        this.slow       = true;

        
        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));

        this.alwaysSaveParams = true;

        
        this.addParam(this.paramQuality = new SelectParam('quality', '', false, true, true, ['clip sRGB', 'clip chroma', 'find closest'], 1));


        this.initCorrections('');
        this.updateCorrections();


        this.header.connectionPadding = 18;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen, 0);
        if (ignore) return request;


        const input = this.node.inputs[0];

        request.push(input.connected ? 1 : 0);


        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramQuality.genRequest(gen));


        const cached = 
            (input.connected
             ?  input.node.valid
             : !dataColorIsNaN(this.node._color))
            || !this.node.enabled;

        request.push(COLOR_VALUE, (
            cached
            ? ColorValue.fromDataColor(this.node._color)
            : ColorValue.NaN).toString()); // value


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;


        this.initCorrections(this._color[0]);
        this.endNodeProgress();


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    // updateHeader()
    // {
    //     super.updateHeader();

    //     const colors = this.getHeaderColors();

    //     // this.progressBar.style.background = 
    //     //     !rgbIsNaN(colors.back) 
    //     //     ? rgb2style_a(colors.text, 0.5) 
    //     //     : 'var(--figma-color-bg-brand)';
    // }



    initCorrections(colorSpace)
    {
        if (colorSpace == '')
            return;

        this.corrections = getColorCorrections(colorSpace);
    }



    updateCorrections()
    {
        this.updateColorSpace();
    }



    updateColorSpace()
    {
        if (dataColorIsValid(this._color))
            this.initCorrections(this._color[0]);
    }



    isConnected()
    {
        return this.inputs[0].connected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"_color": "' + ColorValue.fromDataColor(this._color).toString() + '"';
    }



    loadParams(_node, pasting)
    {
        if (_node._color != undefined)
        {
            this._color = parseColorValue(_node._color)[0].toDataColor();
            this.valid = true;
        }

        if (!dataColorIsValid(this._color))
            this.initProgress();

        super.loadParams(_node, pasting);
    }
}


class   OpCorrectColor
extends OpColorBase
{
    paramOrder;

    param1;
    param2;
    param3;

    corrections = [];



    constructor()
    {
        super(CORRECT_COLOR, 'corrected', 'corrected', true);

        this.slow         = true;
        this.canDisable   = true;
        this.subscription = true;

        
        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));

        this.alwaysSaveParams = true;

        
        this.addParam(this.paramOrder = new SelectParam('order', '', false, true, true, [0, 1, 2, 3, 4, 5], 2));
        
        this.paramOrder.addEventListener('change', () => this.updateCorrections());
        
        
        this.addParam(this.param1 = new NumberParam('margin1', '', true, true, true, 0));
        this.addParam(this.param2 = new NumberParam('margin2', '', true, true, true, 0));
        this.addParam(this.param3 = new NumberParam('margin3', '', true, true, true, 0));
        
        this.param1.controls[0].showNaNValueName = false;
        this.param2.controls[0].showNaNValueName = false;
        this.param3.controls[0].showNaNValueName = false;


        this.initCorrections('');
        this.updateCorrections();


        this.header.connectionPadding = 18;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramOrder.input.connected
            || this.node.param1    .input.connected
            || this.node.param2    .input.connected
            || this.node.param3    .input.connected;

        const options = (hasInputs ? 1 : 0) << 20;


        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];

        request.push(input.connected ? 1 : 0);


        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        const cached = 
               (input.connected
                ?    input.node.valid
                  //|| !dataColorIsNaN(this.node._color)
                : !dataColorIsNaN(this.node._color))
            || !this.node.enabled;


        const paramIds = [];

        for (const param of this.node.params)
            if (      param.input 
                   && param.input.connected
                || cached)
                paramIds.push(param.id);

        paramIds.push('value');

        request.push(paramIds.join(','));

        
        if (this.node.paramOrder.input.connected || cached) request.push(...this.node.paramOrder.genRequest(gen));
        if (this.node.param1    .input.connected || cached) request.push(...this.node.param1    .genRequest(gen));
        if (this.node.param2    .input.connected || cached) request.push(...this.node.param2    .genRequest(gen));
        if (this.node.param3    .input.connected || cached) request.push(...this.node.param3    .genRequest(gen));

 
        request.push(COLOR_VALUE, (
            cached
            ? ColorValue.fromDataColor(this.node._color)
            : ColorValue.NaN).toString()); // value


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;


        this.initCorrections(this._color[0]);
        this.endNodeProgress();


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateParams()
    {
        this.paramOrder.enableControlText(false);
        this.param1    .enableControlText(false);
        this.param2    .enableControlText(false);
        this.param3    .enableControlText(false);

        this.updateCorrections();

        this.updateParamControls();
    }



    updateHeader()
    {
        super.updateHeader();

        const colors = this.getHeaderColors();

        this.progressBar.style.background = 
            !rgbIsNaN(colors.back) 
            ? rgb2style_a(colors.text, 0.5) 
            : 'var(--figma-color-bg-brand)';
    }



    initCorrections(colorSpace)
    {
        if (colorSpace == '')
        {
            this.paramOrder.setValue(NumberValue.NaN);
            this.param1    .setValue(NumberValue.NaN);
            this.param2    .setValue(NumberValue.NaN);
            this.param3    .setValue(NumberValue.NaN);

            return;
        }


        switch (colorSpace)
        {
        case 'hex':
        case 'rgb':    this.paramOrder.setOptions(makeOptions('RGB')); break;
        case 'hsv':    this.paramOrder.setOptions(makeOptions('HSV')); break;
        case 'hsl':    this.paramOrder.setOptions(makeOptions('HSL')); break;
        case 'hclok':
        case 'hclab':
        case 'hcluv': this.paramOrder.setOptions(makeOptions('HCL')); break;
        case 'oklab':  
        case 'lab':    this.paramOrder.setOptions(makeOptions('Lab')); break;
        case 'luv':    this.paramOrder.setOptions(makeOptions('Luv')); break;
        }


        this.corrections = getColorCorrections(colorSpace);
    }



    updateCorrections()
    {
        this.updateColorSpace();

        if (this.paramOrder.value.isValid())
        {
            const [i1, i2, i3] = getCorrectionsInOrder(this.paramOrder.value.value);

            this.updateMargin(this.param1, this.corrections[i1]);
            this.updateMargin(this.param2, this.corrections[i2]);
            this.updateMargin(this.param3, this.corrections[i3]);
        }
        else
        {
            this.resetMargin(this.param1);
            this.resetMargin(this.param2);
            this.resetMargin(this.param3);
        }
    }



    updateColorSpace()
    {
        if (dataColorIsValid(this._color))
            this.initCorrections(this._color[0]);
    }



    updateMargin(margin, correction)
    {
        const correctionName = '<span style="position: relative; top: -1px; font-weight: 200;"></span>&thinsp;' + correction.name;

        margin.setName(correctionName, false);
        margin.controls[0].name = correctionName;

        margin.controls[0].setMin(0);
        margin.controls[0].setMax(correction.max);
    }



    resetMargin(margin)
    {
        margin.setName('', false);
        margin.controls[0].name = '';
        margin.controls[0].setMin(0);
        margin.controls[0].setMax(Number.MAX_SAFE_INTEGER);
    }



    isConnected()
    {
        return this.inputs[0].connected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"_color": "' + ColorValue.fromDataColor(this._color).toString() + '"';
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);

        if (_node._color != undefined)
        {
            this._color = parseColorValue(_node._color)[0].toDataColor();
            this.valid = true;
        }

        if (!dataColorIsValid(this._color))
            this.initProgress();
    }
}



function makeOptions(c)
{
    return ([
        c[0]+','+c[1]+','+c[2], 
        c[1]+','+c[0]+','+c[2], 
        c[1]+','+c[2]+','+c[0], 
        c[0]+','+c[2]+','+c[1], 
        c[2]+','+c[0]+','+c[1], 
        c[2]+','+c[1]+','+c[0]]);
}



const rgb2dark1  = [255/255,  64/255,  96/255];
const rgb2dark2  = [255/255, 255/255,  0/255];
const rgb2dark3  = [ 64/255, 220/255, 64/255];

const rgb2light1 = [255/255,  50/255, 50/255];
const rgb2light2 = [200/255, 195/255,  0/255];
const rgb2light3 = [ 64/255, 220/255, 64/255];


const rgb3dark1  = [255/255,  64/255,  96/255];
const rgb3dark2  = [255/255, 128/255,  24/255];
const rgb3dark3  = [255/255, 185/255,   0/255];
const rgb3dark4  = [255/255, 255/255,   0/255];
const rgb3dark5  = [ 64/255, 255/255,  64/255];
const rgb3dark6  = [  0/255, 164/255, 255/255];
const rgb3dark7  = [230/255, 230/255, 230/255];

const rgb3light1 = [255/255,   0/255,  64/255];
const rgb3light2 = [255/255, 112/255,   0/255];
const rgb3light3 = [220/255, 150/255,   0/255];
const rgb3light4 = [210/255, 205/255,   0/255];
const rgb3light5 = [ 30/255, 220/255,  30/255];
const rgb3light6 = [128/255, 128/255, 255/255];
const rgb3light7 = [255/255, 255/255, 255/255];



class   OpColorContrast
extends OpColorBase
{
    paramStandard;
    paramContrast;

    labelColor = [0, 0, 0];


    _rgbText   = [0, 0, 0];
    _rgbBack   = [0, 0, 0];


    constructor()
    {
        super(COLOR_CONTRAST, 'contrast', 'contrast');


        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));

        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));
        //this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramContrast = new NumberParam('contrast', '', false, false, true, 0));
        this.addParam(this.paramStandard = new SelectParam('standard', '', false, true,  true, ['WCAG 2', 'APCA'], 1));
      
        this.paramContrast.controls[0].thinMinus     = true;
        this.paramContrast.controls[0].showExtRanges = false;


        this.paramStandard.getTooltip = () => null;

        this.paramContrast.getTooltip = () => 
            settings.showTooltipColorContrast ? 
            (this.paramStandard.value.value == 1 ? ttWcag3 : ttWcag2) 
            : null;


        this.header.connectionPadding = 12.5;
    }



    output_genRequest(gen)
    {
        // console.trace();
        if (gen.passedNodes.includes(this.node))
        {
            return [
                this.node.type, 
                this.node.id, 
                this.node.name];
        }


        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;

        
        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, 0, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, 1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramStandard.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        console.assert(
            paramIds.length == values.length,
            'paramIds.length must equal values.length');

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);


        const colText  = values[paramIds.findIndex(id => id == 'text'    )];
        const colBack  = values[paramIds.findIndex(id => id == 'back'    )];
        const standard = values[paramIds.findIndex(id => id == 'standard')];
        const contrast = values[paramIds.findIndex(id => id == 'contrast')];

        console.assert(isValid(colText), 'colText is not valid');
        console.assert(isValid(colBack), 'colBack is not valid');

        console.assert(colText.type == COLOR_VALUE, 'colText.type = ' + colText.type);
        console.assert(colBack.type == COLOR_VALUE, 'colBack.type = ' + colBack.type);


        this.labelColor = 
            colText.isValid()
            ? colText.toRgb()
            : getTextColorFromBackColor(colBack);

        this._color = colBack.toDataColor();


        this._rgbText = colText.toRgb();
        this._rgbBack = colBack.toRgb();


        if (   standard
            && contrast)
        {
            if (standard.value == 0)
            {
                let rating = getContrastRating2(contrast.value);

                if (rating != '')
                    rating = '&nbsp;&nbsp;' + rating;

                this.paramContrast.controls[0].min        = 
                this.paramContrast.controls[0].displayMin = 0;

                this.paramContrast.controls[0].max        = 
                this.paramContrast.controls[0].displayMax = 21;

                this.paramContrast.controls[0].setDecimals(2);
                this.paramContrast.controls[0].setSuffix(rating);

                this.paramContrast.controls[0].displayAbsolute = false;
            }
            else
            {
                this.paramContrast.controls[0].min        = -108;
                this.paramContrast.controls[0].max        =  106;
                
                this.paramContrast.controls[0].displayMin = -105;
                this.paramContrast.controls[0].displayMax =  105;

                this.paramContrast.controls[0].displayAbsolute = true;

                this.paramContrast.controls[0].setDecimals(1);
                this.paramContrast.controls[0].setSuffix('<span style="font-size: 5; position: relative; top: -7px; left: 2px;">L</span><span style="font-size: 3; font-weight: bold; position: relative; top: -9px; left: 2px;">c</span>');

                this.paramContrast.controls[0].setValue(contrast.value, false, false);
            }


            if (   this.inputs[0].connected
                && this.inputs[1].connected)
            {
                const rgb0 = colText.toRgb();
                const rgb1 = colBack.toRgb();

                if (  !rgbIsOk(rgb0)
                    && rgbIsOk(rgb1))
                {
                    this.warningStyle     = rgb2style_a(invalid2validRgb(rgb0), 0.3);
                    this.forceShowWarning = true;
                }
                else if (rgbIsOk(rgb0)
                     && !rgbIsOk(rgb1))
                {
                    this.warningStyle     = getDefaultWarningStyle(rgb1);
                    this.forceShowWarning = true;
                }
                else
                    this.forceShowWarning = false;
            }
            else
            {
                this.forceShowWarning = false;
            }
        }
    }



    updateParams()
    {
        this.paramContrast.enableControlText(false);
        this.paramStandard.enableControlText(true);

        this.setRanges(this.paramStandard.value);

        this.updateParamControls();
    }



    updateHeader()
    {
        super.updateHeader();


        this.outputs[0].lightColor =
        this.outputs[0]. darkColor =
        this.outputs[0]. wireColor = this._rgbText;

        this.outputs[1].lightColor =
        this.outputs[1]. darkColor =
        this.outputs[1]. wireColor = this._rgbBack;
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();

        const colors = this.getHeaderColors();

          if (   this.inputs[0].connected 
              && this.inputs[1].connected) this.label.style.color = rgb2style(this.labelColor);
        else if (this.inputs[1].connected) this.label.style.color = rgba2style(colors.text);
        else                               this.label.style.color = darkMode ? 'white' : 'black';
    }



    setRanges(standard)
    {
        if (standard.value == 0)
        {
            const contrast = Math.abs(this.paramContrast.value.value) / 21;

            const is1 = contrast > 0  /21 && contrast <=  3  /21;
            const is2 = contrast > 3  /21 && contrast <=  4.5/21;
            const is3 = contrast > 4.5/21 && contrast <=  7  /21;
           
            if (darkMode)
            {
                this.paramContrast.controls[0].ranges = [ 
                    new NumberControlRange(0  /21,  3  /21, rgb2style_a(rgb2dark1, is1 ? 1 : 0.2 ), 0.8),
                    new NumberControlRange(3  /21,  4.5/21, rgb2style_a(rgb2dark2, is2 ? 1 : 0.27), 0.8),
                    new NumberControlRange(4.5/21,  7  /21, rgb2style_a(rgb2dark3, is3 ? 1 : 0.27), 0.8),
                    new NumberControlRange(7  /21, 21  /21, 'transparent') ];
            }
            else
            {
                this.paramContrast.controls[0].ranges = [ 
                    new NumberControlRange(0  /21,  3  /21, rgb2style_a(rgb2light1, is1 ? 1 : 0.2 ), 0.8),
                    new NumberControlRange(3  /21,  4.5/21, rgb2style_a(rgb2light2, is2 ? 1 : 0.27), 0.8),
                    new NumberControlRange(4.5/21,  7  /21, rgb2style_a(rgb2light3, is3 ? 1 : 0.27), 0.8),
                    new NumberControlRange(7  /21, 21  /21, 'transparent') ];
            }
        }
        else
        {
            const contrast = Math.abs(this.paramContrast.value.value) / 100;

            const is1 = contrast >=  0/100 && contrast <=  15/100;
            const is2 = contrast >  15/100 && contrast <=  30/100;
            const is3 = contrast >  30/100 && contrast <=  45/100;
            const is4 = contrast >  45/100 && contrast <=  60/100;
            const is5 = contrast >  60/100 && contrast <=  75/100;
            const is6 = contrast >  75/100 && contrast <=  90/100;
            const is7 = contrast >  90/100;

            if (darkMode)
            {
                this.paramContrast.controls[0].ranges = [ 
                    new NumberControlRange( 0/105,  15/105, rgb2style_a(rgb3dark1, is1 ? 1 : 0.2), 0.8),
                    new NumberControlRange(15/105,  30/105, rgb2style_a(rgb3dark2, is2 ? 1 : 0.2), 0.8),
                    new NumberControlRange(30/105,  45/105, rgb2style_a(rgb3dark3, is3 ? 1 : 0.2), 0.8),
                    new NumberControlRange(45/105,  60/105, rgb2style_a(rgb3dark4, is4 ? 1 : 0.2), 0.8),
                    new NumberControlRange(60/105,  75/105, rgb2style_a(rgb3dark5, is5 ? 1 : 0.2), 0.8),
                    new NumberControlRange(75/105,  90/105, rgb2style_a(rgb3dark6, is6 ? 1 : 0.4), 0.8),
                    new NumberControlRange(90/105, 105/105, rgb2style_a(rgb3dark7, is7 ? 1 : 0  ), 0.8) ];
            }
            else
            {
                this.paramContrast.controls[0].ranges = [
                    new NumberControlRange( 0/105,  15/105, rgb2style_a(rgb3light1, is1 ? 1 : 0.2), 0.8),
                    new NumberControlRange(15/105,  30/105, rgb2style_a(rgb3light2, is2 ? 1 : 0.2), 0.8),
                    new NumberControlRange(30/105,  45/105, rgb2style_a(rgb3light3, is3 ? 1 : 0.2), 0.8),
                    new NumberControlRange(45/105,  60/105, rgb2style_a(rgb3light4, is4 ? 1 : 0.2), 0.8),
                    new NumberControlRange(60/105,  75/105, rgb2style_a(rgb3light5, is5 ? 1 : 0.2), 0.8),
                    new NumberControlRange(75/105,  90/105, rgb2style_a(rgb3light6, is6 ? 1 : 0.1), 0.8),
                    new NumberControlRange(90/105, 105/105, 'transparent') ];
            }
        }
    }
}


class   OpColorBlind
extends OpColorBase
{
    paramL;
    paramM;
    paramS;


    symbol;

    ringL;
    ringM;
    ringS;

    menuL;
    menuM;
    menuS;


    constructor()
    {
        super(COLORBLIND, 'colorblind', 'colorblind');

        this.canDisable = true;
        

        this.addInput(new Input(COLOR_TYPES));
        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramL = new NumberParam('l', 'L', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.paramM = new NumberParam('m', 'M', false, true, true, 2, 0, 2, 0, 0.02));
        this.addParam(this.paramS = new NumberParam('s', 'S', false, true, true, 2, 0, 2, 0, 0.02));

        this.paramL.addEventListener('change', () => this.paramL.controls[0].dragScale = decCount(numToString(this.paramL.value, this.paramL.controls[0].displayDec)) == 0 ? 0.02 : 0.05);
        this.paramM.addEventListener('change', () => this.paramM.controls[0].dragScale = decCount(numToString(this.paramM.value, this.paramM.controls[0].displayDec)) == 0 ? 0.02 : 0.05);
        this.paramS.addEventListener('change', () => this.paramS.controls[0].dragScale = decCount(numToString(this.paramS.value, this.paramS.controls[0].displayDec)) == 0 ? 0.02 : 0.05);


        this.header.connectionPadding = 18;


        this.symbol = createDiv('colorblindSymbol');
        
        this.ringL = createDiv('colorblindRing');
        this.ringM = createDiv('colorblindRing');
        this.ringS = createDiv('colorblindRing');
        
        this.symbol.appendChild(this.ringS);
        this.symbol.appendChild(this.ringM);
        this.symbol.appendChild(this.ringL);

        this.header.appendChild(this.symbol);


        createTooltipSrc(
            this.symbol, 
            this.symbol, 
            () => settings.showTooltipColorBlindness 
            ? ttColorblind 
            : null);


        this.menuL = new Menu('L', false, true);
        this.menuL.addItems([
            new MenuItem('L',       {callback: () => { hideAllMenus(); this.paramL.setValue(new NumberValue(2), true); }}),
            new MenuItem('L weak',  {callback: () => { hideAllMenus(); this.paramL.setValue(new NumberValue(1), true); }}),
            new MenuItem('L blind', {callback: () => { hideAllMenus(); this.paramL.setValue(new NumberValue(0), true); }})]);

        this.menuM = new Menu('M', false, true);
        this.menuM.addItems([
            new MenuItem('M',       {callback: () => { hideAllMenus(); this.paramM.setValue(new NumberValue(2), true); }}),
            new MenuItem('M weak',  {callback: () => { hideAllMenus(); this.paramM.setValue(new NumberValue(1), true); }}),
            new MenuItem('M blind', {callback: () => { hideAllMenus(); this.paramM.setValue(new NumberValue(0), true); }})]);

        this.menuS = new Menu('S', false, true);
        this.menuS.addItems([
            new MenuItem('S',       {callback: () => { hideAllMenus(); this.paramS.setValue(new NumberValue(2), true); }}),
            new MenuItem('S weak',  {callback: () => { hideAllMenus(); this.paramS.setValue(new NumberValue(1), true); }}),
            new MenuItem('S blind', {callback: () => { hideAllMenus(); this.paramS.setValue(new NumberValue(0), true); }})]);


        this.menuL.minWidth = 120;
        this.menuM.minWidth = 120;
        this.menuS.minWidth = 120;


        this.paramL.controls[0].div.addEventListener('pointerdown', e => this.showParamMenu(e, this.paramL, this.menuL));
        this.paramM.controls[0].div.addEventListener('pointerdown', e => this.showParamMenu(e, this.paramM, this.menuM));
        this.paramS.controls[0].div.addEventListener('pointerdown', e => this.showParamMenu(e, this.paramS, this.menuS));
    }



    showParamMenu(e, param, menu)
    {
        if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            param.controls[0].buttonDown2 = true;

            menu.showAt(e.clientX, e.clientY, false);
        }
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

            
        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input = this.node.inputs[0];

        request.push(input.connected ? 1 : 0);


        if (input.connected)
            request.push(...pushInputOrParam(input, gen));


        request.push(...this.node.paramL.genRequest(gen));
        request.push(...this.node.paramM.genRequest(gen));
        request.push(...this.node.paramS.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const value = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            value
            ? value.toDataColor()
            : dataColor_NaN;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        super.updateHeader();

        const colors    = this.getHeaderColors();
        const ringStyle = rgba2style(colors.text);

        const valL = Math.round(this.paramL.value.value);
        const valM = Math.round(this.paramM.value.value);
        const valS = Math.round(this.paramS.value.value);


        if (   valL == 0
            && valM == 0
            && valS == 0)
        {
            this.ringL.style.display      = 'none';
            this.ringS.style.display      = 'none';

            this.ringM.style.display      = 'block';
            this.ringM.style.width        = '14px';
            this.ringM.style.height       = '14px';
            this.ringM.style.borderRadius = '14px';
            this.ringM.style.background   = ringStyle;
            this.ringM.style.border       = 'none';
        }
        else
        {
            const lDisplay     = valL >= 1 ? 'block' : 'none';
            const lBorderStyle = valL == 2 ? 'solid' : 'dashed';

            this.ringL.style.width        = '16px';
            this.ringL.style.height       = '16px';
            this.ringL.style.borderRadius = '16px';
            this.ringL.style.border       = '1.5px solid ' + ringStyle;
            this.ringL.style.display      = lDisplay;
            this.ringL.style.borderStyle  = lBorderStyle;


            const mDisplay     = valM >= 1 ? 'block' : 'none';
            const mBorderStyle = valM == 2 ? 'solid' : 'dashed';

            this.ringM.style.width        = '8px';
            this.ringM.style.height       = '8px';
            this.ringM.style.borderRadius = '8px';
            this.ringM.style.border       = '1.5px solid ' + ringStyle;
            this.ringM.style.background   = 'none';
            this.ringM.style.display      = mDisplay;
            this.ringM.style.borderStyle  = mBorderStyle;
            

            const sDisplay      = valS >= 1 ? 'block' : 'none';
            const sBorderRadius = valS == 2 ? 3 : 1;

            this.ringS.style.width        = sBorderRadius + 'px';
            this.ringS.style.height       = sBorderRadius + 'px';
            this.ringS.style.background   = ringStyle;
            this.ringS.style.display      = sDisplay;
            this.ringS.style.borderRadius = sBorderRadius + 'px';
        }
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        this.label.style.top = '59%';
    }



    updateParams()
    {
        this.updateParamText(this.paramL, 'L');
        this.updateParamText(this.paramM, 'M');
        this.updateParamText(this.paramS, 'S');

        this.updateParamControls();
    }



    updateParamText(param, cone)
    {
        const v = Math.round(param.value.value);

             if (v == 2) param.controls[0].valueText = cone;
        else if (v == 1) param.controls[0].valueText = cone + ' weak';
        else             param.controls[0].valueText = cone + ' blind';
    }
}


class   OpColorInterpolate
extends OpColorBase
{
    paramSpace;
    paramAmount;
    paramGamma;



    constructor()
    {
        super(COLOR_INTERPOLATE, 'inter', 'interpolate');

        
        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));

        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramSpace  = new SelectParam('space',  '',  false, true, true, ColorSpaces.map(s => s[1]), 1));
        this.addParam(this.paramAmount = new NumberParam('amount', '',  true,  true, true, 50, 0,  100, 0));
        this.addParam(this.paramGamma  = new NumberParam('gamma',  '', true,  true, true, 1,  0.01, 4, 2));
      
        
        this.paramSpace.controls[0].setMin(1);
        this.paramSpace.excludeFromMenu.push(0);
        this.paramSpace.input.outputMustBeCached = true;

        
        this.paramAmount.controls[0].min = Number.MIN_SAFE_INTEGER; // allow
        this.paramAmount.controls[0].max = Number.MAX_SAFE_INTEGER; // extrapolation

        this.paramAmount.controls[0].setSuffix('%', true);
        

        this.header.connectionPadding = 12.5;

        
        this.paramSpace.getTooltip = () => 
            settings.showTooltipColorInterpolation 
            ? ttInterpolationSpace 
            : null;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramSpace .genRequest(gen));
        request.push(...this.node.paramAmount.genRequest(gen));
        request.push(...this.node.paramGamma .genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


class   OpColorBlend
extends OpColorBase
{
    paramMode;
    paramOpacity;



    constructor()
    {
        super(COLOR_BLEND, 'blend', 'blend');

        
        this.addInput(new Input(COLOR_TYPES));
        this.addInput(new Input(COLOR_TYPES));

        this.addOutput(new Output([COLOR_VALUE], this.output_genRequest));


        this.addParam(this.paramMode    = new SelectParam('mode',    '',        false, true, true, BlendModes.map(bm => bm[1]), 0));
        this.addParam(this.paramOpacity = new NumberParam('opacity', 'opacity', true,  true, true, 100, 0,  100, 0));
      
        
        this.paramMode.separatorsBefore.push(1, 4, 7, 10, 12);
        this.paramMode.input.outputMustBeCached = true;

        
        this.paramOpacity.controls[0].min = Number.MIN_SAFE_INTEGER; // allow
        this.paramOpacity.controls[0].max = Number.MAX_SAFE_INTEGER; // extrapolation

        this.paramOpacity.controls[0].setSuffix('%', true);
        

        this.header.connectionPadding = 12.5;
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        const input0 = this.node.inputs[0];
        const input1 = this.node.inputs[1];

        
        if (   input0.connected
            && input1.connected)   request.push(2,
                                       ...pushInputOrParam(input0, gen),
                                       ...pushInputOrParam(input1, gen));

        else if (input0.connected) request.push(1, ...pushInputOrParam(input0, gen));
        else if (input1.connected) request.push(1, ...pushInputOrParam(input1, gen));
            
        else                       request.push(0);


        request.push(...this.node.paramMode   .genRequest(gen));
        request.push(...this.node.paramOpacity.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const col = values[paramIds.findIndex(id => id == 'value')];

        this._color = 
            col
            ? col.toDataColor()
            : dataColor_NaN;

        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }
}


class   OpShapeBase
extends OperatorBase
{
    paramProperties;


    constructor(type, id, name, defWidth = defNodeWidth)
    {
        super(type, id, name, defWidth);
    }



    addBaseParams()
    {
        this.addParam(this.paramProperties = new ListParam('props', 'styles', true, true, true));

        this.paramProperties.itemName = 'style';
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });

        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;
                
        
        const paramIds = [];
        
        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected
                    && param.canShow())
                    paramIds.push(param.id);
        }
        else
        {
            for (const param of this.node.params)
                if (param.canShow())
                    paramIds.push(param.id);
        }


        request.push(paramIds.length);

        for (const paramId of paramIds)
            request.push(paramId, ...this.node.params.find(p => p.id == paramId).genRequest(gen));            


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateParams()
    {
        const enable = !this.inputs[0].connected;
        
        for (const param of this.params)
            param.enableControlText(enable);

        this.updateParamControls();
    }
}



class   OpRectangle
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;
    paramRound;


    
    constructor()
    {
        super(RECTANGLE, 'rect', 'rectangle');

        this.canDisable = true;
        

        this.addInput (this.createInputForObjects([RECTANGLE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([RECTANGLE_VALUE], this.output_genRequest));


        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        this.addParam(this.paramRound  = new NumberParam('round',  'round',  true, true, true,   0,    0));


        this.paramWidth .addEventListener('change', () => this.updateRound());
        this.paramHeight.addEventListener('change', () => this.updateRound());

        this.paramAngle.controls[0].setSuffix('', true);
        this.paramAngle.controls[0].wrapValue   = true;
        this.paramAngle.controls[0].dragReverse = true;


        this.addBaseParams();
    }



    updateRound()
    {
        const min = Math.min(this.paramWidth.value.value, this.paramHeight.value.value);

        this.paramRound.controls[0].displayMin = 0;
        this.paramRound.controls[0].displayMax = min/2;

        this.paramRound.controls[0].update();
    }
}


class   OpLine
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramAngle;


    
    constructor()
    {
        super(LINE, 'line', 'line');

        this.canDisable = true;

        
        this.addInput (this.createInputForObjects([LINE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([LINE_VALUE], this.output_genRequest));

        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        

        this.paramAngle.controls[0].setSuffix('', true);
        this.paramAngle.controls[0].wrapValue   = true;
        this.paramAngle.controls[0].dragReverse = true;


        this.addBaseParams();
    }
}


class   OpEllipse
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;


    
    constructor()
    {
        super(ELLIPSE, 'ellipse', 'ellipse');

        this.canDisable = true;
        

        this.addInput (this.createInputForObjects([ELLIPSE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([ELLIPSE_VALUE], this.output_genRequest));


        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        

        this.paramAngle.controls[0].setSuffix('', true);
        this.paramAngle.controls[0].wrapValue   = true;
        this.paramAngle.controls[0].dragReverse = true;


        this.addBaseParams();
    }
}


class   OpPolygon
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;
    paramRound;
    paramCorners;


    
    constructor()
    {
        super(POLYGON, 'poly', 'polygon');

        this.canDisable = true;

        
        this.addInput (this.createInputForObjects([POLYGON_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([POLYGON_VALUE], this.output_genRequest));

        this.addParam(this.paramX       = new NumberParam('x',       'x',       true, true, true,   0));
        this.addParam(this.paramY       = new NumberParam('y',       'y',       true, true, true,   0));
        this.addParam(this.paramWidth   = new NumberParam('width',   'width',   true, true, true, 100,    0.01));
        this.addParam(this.paramHeight  = new NumberParam('height',  'height',  true, true, true, 100,    0.01));
        this.addParam(this.paramAngle   = new NumberParam('angle',   'angle',   true, true, true,   0, -180,   180));
        this.addParam(this.paramRound   = new NumberParam('round',   'round',   true, true, true,   0,    0));
        this.addParam(this.paramCorners = new NumberParam('corners', 'corners', true, true, true,   3,    3));
        

        this.paramAngle.controls[0].setSuffix('', true);
        this.paramAngle.controls[0].wrapValue   = true;
        this.paramAngle.controls[0].dragReverse = true;


        this.addBaseParams();
    }



    updateRound()
    {
        const control = this.paramRound.controls[0];
        const min     = Math.min(this.paramWidth.value, this.paramHeight.value);

        control.setMin(0);
        control.setMax(min/2);

        control.update();
    }
}


class   OpStar
extends OpShapeBase
{
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;
    paramRound;
    paramPoints;
    paramConvex;


    
    constructor()
    {
        super(STAR, 'star', 'star');

        this.canDisable = true;

        
        this.addInput (this.createInputForObjects([STAR_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([STAR_VALUE], this.output_genRequest));

        this.addParam(this.paramX      = new NumberParam('x',      'x',      true, true, true,   0));
        this.addParam(this.paramY      = new NumberParam('y',      'y',      true, true, true,   0));
        this.addParam(this.paramWidth  = new NumberParam('width',  'width',  true, true, true, 100,    0.01));
        this.addParam(this.paramHeight = new NumberParam('height', 'height', true, true, true, 100,    0.01));
        this.addParam(this.paramAngle  = new NumberParam('angle',  'angle',  true, true, true,   0, -180,   180));
        this.addParam(this.paramRound  = new NumberParam('round',  'round',  true, true, true,   0,    0));
        this.addParam(this.paramPoints = new NumberParam('points', 'points', true, true, true,   5,    3));
        this.addParam(this.paramConvex = new NumberParam('convex', 'convex', true, true, true,   38.2, 0, 100));
        

        this.paramAngle.controls[0].setSuffix('', true);
        this.paramAngle.controls[0].wrapValue   = true;
        this.paramAngle.controls[0].dragReverse = true;

        this.paramConvex.controls[0].setSuffix('%', true);


        this.addBaseParams();
    }



    updateRound()
    {
        const control = this.paramRound.controls[0];
        const min     = Math.min(this.paramWidth.value, this.paramHeight.value);

        control.setMin(0);
        control.setMax(min/2);

        this.paramRound.controls[0].update();
    }
}


class   OpTextShape
extends OpShapeBase
{
    paramText;
    paramX;
    paramY;
    paramWidth;
    paramHeight;
    paramAngle;
    paramFont;
    paramStyle;
    paramSize;
    paramAlignH;
    paramAlignV;
    paramLineHeight;
    paramLetterSpacing;


    
    constructor()
    {
        super(TEXTSHAPE, 'text', 'text');

        this.canDisable = true;
        

        this.addInput (this.createInputForObjects([TEXTSHAPE_VALUE], getNodeInputValuesForUndo));
        this.addOutput(new Output([TEXTSHAPE_VALUE], this.output_genRequest));


        const fonts      = figFonts.map(f => f.fontName.family);
        const interIndex = fonts.findIndex(f => f == 'Inter');

      
        this.addParam(this.paramText          = new   TextParam('text',          '',       true,  true));
        this.addParam(this.paramX             = new NumberParam('x',             'x',      true,  true, true,   0));
        this.addParam(this.paramY             = new NumberParam('y',             'y',      true,  true, true,   0));
        this.addParam(this.paramWidth         = new NumberParam('width',         'width',  true,  true, true, 100,    0.01));
        this.addParam(this.paramHeight        = new NumberParam('height',        'height', true,  true, true, 100,    0.01));
        this.addParam(this.paramAngle         = new NumberParam('angle',         'angle',  true,  true, true,   0, -180,   180));
        this.addParam(this.paramFont          = new SelectParam('font',          'font',   false, true, true, [...new Set(fonts)], interIndex));
        this.addParam(this.paramStyle         = new SelectParam('style',         'style',  false, true, true, [''], 0));
        this.addParam(this.paramSize          = new NumberParam('size',          'size',   true,  true, true,  12,  0));
        this.addParam(this.paramAlignH        = new SelectParam('alignH',        'align',  true,  true, true, ['left', 'center', 'right', 'justify'], 0));
        this.addParam(this.paramAlignV        = new SelectParam('alignV',        'align',  true,  true, true, ['bottom', 'middle', 'top'], 1));
        this.addParam(this.paramLineHeight    = new NumberParam('lineHeight',    'line',   true,  true, true, 100));
        this.addParam(this.paramLetterSpacing = new NumberParam('letterSpacing', 'letter', true,  true, true, 0));


        this.paramText.controls[0].textbox.style.textAlign = 'center';

        this.paramAngle.controls[0].setSuffix('', true);
        this.paramAngle.controls[0].wrapValue   = true;
        this.paramAngle.controls[0].dragReverse = true;

        this.paramLineHeight   .controls[0].setSuffix('%', true);
        this.paramLetterSpacing.controls[0].setSuffix('%', true);

        this.addBaseParams();
    }
}


class   OpColorStyle
extends OperatorBase
{
    paramValue;

    styleCircle;

    circleBack;
    circleCheckers;
    circle;
    link;

    existing        = true;

    linkedStyleId   = NULL;
    linkedStyleName = NULL;




    constructor(options = {})
    {
        super(COLOR_STYLE, 'style', 'style');

        this.inert = true;


        this.addParam(this.paramValue = new FillParam('value', '', false, true, true, FillValue.NaN));

        this.paramValue.input.getValuesForUndo = getNodeInputValuesForUndo;
        this.paramValue.input.addEventListener('disconnect', e => OpColorStyle_value_onDisconnectInput(this, e.detail.input));

        
        if (!!options.existing)
        {
            this.existing = true;
            this.paramValue.setValue(FillValue.NaN, false, false, false);
        }


        this.circleBack     = createDiv('styleCircleBack');
        this.circleCheckers = createDiv('styleCircleCheckers');
        this.circle         = createDiv('styleCircle');

        this.styleCircle    = createDiv('styleCircleWrapper');;
        this.styleCircle.over = false;

        this.styleCircle.addEventListener('pointerenter', e => { this.styleCircle.over = true;  this.updateLinkIcon(); });
        this.styleCircle.addEventListener('pointerleave', e => { this.styleCircle.over = false; this.updateLinkIcon(); });

        this.styleCircle.addEventListener('pointerdown',  e => 
        { 
            e.stopPropagation();

            if (   (  e.button == 0 
                   || e.button == 2)
                && this.existing)
            {
                hideAllMenus(); 

                uiQueueMessageToFigma({
                    cmd:   'figGetAllLocalColorStyles',
                    nodeId: this.id,
                    px:     e.clientX,
                    py:     e.clientY }); 
            }
            else
                e.preventDefault();
        });


        this.link = createDiv('styleLink');


        this.styleCircle.appendChild(this.circleBack);
        this.styleCircle.appendChild(this.circleCheckers);
        this.styleCircle.appendChild(this.circle);
        this.styleCircle.appendChild(this.link);
        
        this.label.insertBefore(this.styleCircle, this.labelText);


        this.updateParams();
    }



    setName(newName, options = {})
    {
        super.setName(newName, options);

        if (isValid(options.updateNodes))
            pushUnique(options.updateNodes, this);
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: NULL });


        const options = (this.existing ? 1 : 0) << 21;


        const [request, ignore] = this.genRequestStart(gen, options);
        if (ignore) return request;

                
        request.push(this.linkedStyleId);
        request.push(...this.paramValue.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        const enabled =
              !this.existing 
            || this.linkedStyleId != NULL;

        this.paramValue.enableControlText(enabled);

        this.paramValue.controls[0].valueText =  this.isUnknown() ? UNKNOWN_DISPLAY : '';
        this.paramValue.controls[0].showBar   = false;//!this.isUnknown();


        //const colors   = this.getHeaderColors();
        //const rgbaBack = rgb_a(colors.stripeBack, colors.back[3]);

        //this.paramValue.controlWrapper.style.background = rgba2style(rgbaBack);
            //   !rgbaIsNaN(rgbaBack) 
            // && this.paramValue.value.opacity.isValid()
            // ?  rgba2style(rgbaBack)
            // : 'transparent'; 

        this.updateParamControls();
    }



    updateHeader()
    {
        super.updateHeader();


        if (this.paramValue.value.isValid()
            && (  !this.existing
                || this.linkedStyleId != NULL))
        {
            const rgba       = this.paramValue.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);
            
            this.circleBack    .style.visibility = 'visible';
            this.circleCheckers.style.visibility = 'visible';
            this.circle        .style.background = rgba2style(rgbaStripe);

            this.styleCircle.style.boxShadow = 
                    darkMode &&  isDark(rgbaStripe, 0.4)
                || !darkMode && !isDark(rgbaStripe, 0.9)
                ? '0 0 0 1px var(--figma-color-bg-tertiary) inset'
                : 'none';
        }
        else
        {
            this.circleBack    .style.visibility = 'hidden';
            this.circleCheckers.style.visibility = 'hidden';
            this.circle        .style.background = 'transparent';
            this.styleCircle   .style.boxShadow  = '0 0 0 1px var(--figma-color-bg-tertiary) inset';
        }


        this.updateLinkIcon();
    }

    

    updateLinkIcon()
    {
        if (this.existing)
        {
            const colors = this.getHeaderColors();

            const rgba       = this.paramValue.value.toRgba();
            const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

            const linkStyle = rgba2style(
                rgb_a(
                       this.paramValue.value.isValid()
                    && this.linkedStyleId != NULL
                    ? (isDark(rgbaStripe) ? [1, 1, 1] : [0, 0, 0])
                    : colors.text, 
                    this.linkedStyleId != NULL
                    ? (this.styleCircle.over ? 0.5 : 0)
                    : (this.styleCircle.over ? 1 : 0.5)));

            this.circleBack.style.background             = darkMode ? '#2c2c2c' : '#ffffff';

            const rgb0 = hex2rgb('d9d9d9');
            const rgb1 = hex2rgb('f6f6f6');

            this.circleCheckers.style.display            = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';
            this.circleCheckers.style.background         =
                  'linear-gradient(45deg, #'+rgb2hex(rgb0)+' 25%, transparent 25%, transparent 75%, #'+rgb2hex(rgb0)+' 75%), '
                + 'linear-gradient(45deg, #'+rgb2hex(rgb0)+' 25%, transparent 25%, transparent 75%, #'+rgb2hex(rgb0)+' 75%)';

            this.circleCheckers.style.backgroundColor    = '#'+rgb2hex(rgb1);
            this.circleCheckers.style.opacity            = 1 - this.paramValue.value.opacity.value / 100;
            this.circleCheckers.style.backgroundSize     = '6px 6px';
            this.circleCheckers.style.backgroundPosition = '0 0, 3px 3px';

            this.link.style.display                      = 'inline-block';
            this.link.style.background                   = 'url(\'data:image/svg+xml;utf8,<svg width="10" height="10" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.5962 8.54594C3.01041 9.13173 2.06066 9.13173 1.47488 8.54594C0.889091 7.96015 0.889091 7.01041 1.47488 6.42462L2.88909 5.01041L2.18198 4.3033L0.767771 5.71751C-0.20854 6.69382 -0.20854 8.27674 0.767771 9.25305C1.74408 10.2294 3.32699 10.2294 4.3033 9.25305L5.71752 7.83883L5.01041 7.13173L3.5962 8.54594ZM6.77818 3.94975L3.94975 6.77817L3.24264 6.07107L6.07107 3.24264L6.77818 3.94975ZM9.25305 4.3033L7.83884 5.71751L7.13173 5.01041L8.54595 3.59619C9.13173 3.01041 9.13173 2.06066 8.54595 1.47487C7.96016 0.889085 7.01041 0.889085 6.42462 1.47487L5.01041 2.88909L4.3033 2.18198L5.71752 0.767765C6.69383 -0.208546 8.27674 -0.208546 9.25305 0.767765C10.2294 1.74408 10.2294 3.32699 9.25305 4.3033Z" fill="' + linkStyle + '"/></svg>\')';
            this.link.style.backgroundPosition           = '50% 50%';
            this.link.style.backgroundRepeat             = 'no-repeat';
        }
        else
        {
            this.circleBack.style.display = 'none';    
            this.link      .style.display = 'none';    
        }
    }



    getActiveOffset()
    {
        return -2;
    }



    // getHeaderColors(options = {})
    // {
    //     const colors = super.getHeaderColors();

    //     colors.stripeBack = getStripeBackColor(colors.back);

    //     return colors;
    // }



    paramIsConsideredDefault(param)
    {
        return  param.isDefault()
            && !this.inputs[0].connected;
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        return super.toJsonBase(nTab)
             + ',\n' + pos + tab + '"existing": "'      + boolToString(this.existing) + '"'
             + ',\n' + pos + tab + '"linkedStyleId": "' + this.linkedStyleId          + '"';
    }



    loadParams(_node, pasting)
    {
        if (!pasting)
        {
            if (_node.existing != undefined) 
               this.existing = isTrue(_node.existing);
            
            this.linkedStyleId = _node.linkedStyleId;
     
            super.loadParams(_node, pasting);
        }
        else
        {
            this.name            = this.defName;
            this.existing        = true;
            this.linkedStyleId   = NULL;
            this.linkedStyleName = '';
        }
    }
}



function OpColorStyle_value_onDisconnectInput(node, input)
{
    if (   node.existing
        && node.linkedStyleId == NULL)
        node.paramValue.setValue(FillValue.NaN, false, false, false);
}


class OpFill
extends OpColorBase
{
    paramColor;
    paramOpacity;

    checkersHolder;
    checkers;
    colorBack;



    constructor()
    {
        super(FILL, 'fill', 'fill');

        this.canDisable = true;
        

        this.colorBack      = createDiv('colorBack');
        this.checkersHolder = createDiv('nodeHeaderCheckersHolder');
        this.checkers       = createDiv('nodeHeaderCheckers');

        this.inner.appendChild(this.colorBack);
        this.inner.insertBefore(this.checkersHolder, this.header);

        this.checkersHolder.appendChild(this.checkers);


        this.addInput (new Input(FILL_TYPES, getNodeInputValuesForUndo, this.input_getBackInitValue));
        this.addOutput(new Output([FILL_VALUE], this.output_genRequest, getNodeOutputValuesForUndo, this.output_backInit));


        this.addParam(this.paramColor   = new ColorParam ('color',   '',        false, true, true, ColorValue.fromRgb(rgbDefaultFill)));
        this.addParam(this.paramOpacity = new NumberParam('opacity', 'opacity', true,  true, true, 100, 0, 100));

        this.paramOpacity.controls[0].suffix = '%';
    }
    
    
    
    input_getBackInitValue()
    {
        // 'this' is the input

        return new FillValue(
            node.paramColor  .value,
            node.paramOpacity.value);
    }



    output_backInit(value)
    {
        // 'this' is the output

        console.assert(value.type == FILL_VALUE, 'expected FILL_VALUE in backInit()');

        this.node.paramColor  .setValue(value.color,   false, true, false);
        this.node.paramOpacity.setValue(value.opacity, false, true, false);
    }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramColor  .input.connected
            || this.node.paramOpacity.input.connected;

        const options = (hasInputs ? 1 : 0) << 20;
    
    
        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;


        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }

        
        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const color = values[paramIds.findIndex(id => id == 'color')];

        this._color = 
            color.isValid()
            ? color.toDataColor()
            : dataColor_NaN;


        this.outputs[0].types =
               this.inputs[0].connected
            && this.inputs[0].connectedOutput.supportsTypes(SHAPE_TYPES)
            ? [...this.inputs[0].connectedOutput.types, FILL_VALUE]
            : [FILL_VALUE];


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateColorControl()
    {
        const colors = this.getHeaderColors({color: true});

        colors.text = getTextColorFromBackColor(
            colors.stripeBack, 
            this.inputIsShape 
            ? colors.stripeBack[3] 
            : 1);

        colors.input  = rgb_a(colors.text, 0.2);
        colors.output = rgb_a(colors.text, 0.2);


        this.paramColor.checkers.style.display = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';

        if (this.paramOpacity.value.isValid())
            this.paramColor.checkers.style.opacity = 
                this.inputIsShape 
                ? (100 - this.paramOpacity.value.toNumber()) + '%'
                : 0;


        // this.paramColor.controls[0]. backStyleLight = 
        // this.paramColor.controls[0]. backStyleDark  = 
        //     !rgbIsNaN(colors.stripeBack)
        //     ? rgb2style(colors.stripeBack, 1)
        //     : noColorStyle(colors.stripeBack);

              
        // this.paramColor.controls[0].valueStyleLight = 
        // this.paramColor.controls[0].valueStyleDark  = 'transparent';//rgba2style(rgb_a(colors.back));

        // this.paramColor.controls[0].textStyleLight  = 
        // this.paramColor.controls[0].textStyleDark   = rgba2style(colors.text);

        // this.paramColor. input.colorLight           =
        // this.paramColor. input.colorDark            = colors.input;
        
        // this.paramColor.output.colorLight           =
        // this.paramColor.output.colorDark            = colors.output;

        // this.paramColor.output.wireColor            = colors.stripeBack;
    }



    updateNode()
    {
        this.updateColorControl();

        super.updateNode();
    }



    updateHeader()
    {
        //console.log(this.id + '.OpFill.updateHeader()');
        
        Operator.prototype.updateHeader.call(this);


        const colors = this.getHeaderColors();


        this.header.style.background = 
            !rgbaIsNaN(colors.stripeBack)
            ? rgba2style(colors.stripeBack) 
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));

        this.colorBack.backStyleLight =
        this.colorBack.backStyleDark  =
            rgbaIsOk(colors.stripeBack)
            ? rgba2style(colors.stripeBack)
            : 'transparent';


        this.checkers.style.height = this.header.offsetHeight;

        this.checkers.style.background =
            darkMode
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = darkMode ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '22px 22px';
        this.checkers.style.backgroundPosition = '0 0, 11px 11px';

        this.checkers.style.left               = '-3px';
        this.checkers.style.width              = 'calc(100% + 3px)';
                       

        this.inputs[0] .colorLight = 
        this.inputs[0] .colorDark  = colors.input;
        this.inputs[0] .wireColor  = colors.wire;

        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = colors.output;
        this.outputs[0].wireColor  = colors.wire;


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colors.back);
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        const colors = this.getHeaderColors();
        this.label.style.color = rgb2style(colors.text);
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors();

        const opacity = 
            this.paramOpacity.value.isValid() 
            ? this.paramOpacity.value.value/100 
            : Number.NaN;


        colors.back       = rgb_a(colors.back,       opacity);
        colors.stripeBack = rgb_a(colors.stripeBack, opacity);
        colors.text       = getTextColorFromBackColor(colors.stripeBack, colors.back[3]);
        colors.input      = rgb_a(colors.text, 0.2);
        colors.output     = rgb_a(colors.text, 0.2);

        colors.wire = 
            !rgbaIsNaN(colors.stripeBack)
            ? colors.stripeBack
            : rgb_a(rgbFromType(ANY_TYPE, false));


        return colors;
    }



    updateParams()
    {
        const enable = 
              !this.inputs[0].connected
            || this.inputs[0].connectedOutput.supportsTypes(SHAPE_TYPES);

        this.paramColor  .enableControlText(enable);
        this.paramOpacity.enableControlText(enable);

        this.updateParamControls();
    }
}


class OpStroke
extends OpColorBase
{
    paramFill;
    paramWeight;
    paramFit;
    paramJoin;
    paramMiter;

    checkers;
    colorBack;


    
    constructor()
    {
        super(STROKE, 'stroke', 'stroke');

        this.canDisable = true;
        

        this.colorBack      = createDiv('colorBack');
        this.checkersHolder = createDiv('nodeHeaderCheckersHolder');
        this.checkers       = createDiv('nodeHeaderCheckers');
        
        this.inner.appendChild(this.colorBack);
        this.inner.insertBefore(this.checkersHolder, this.header);

        this.checkersHolder.appendChild(this.checkers);


        this.addInput (new Input(STROKE_TYPES, getNodeInputValuesForUndo));
        this.addOutput(new Output([STROKE_VALUE], this.output_genRequest, getNodeOutputValuesForUndo));


        this.addParam(this.paramFill   = new FillParam  ('fill',   'fill',   false, true, true, FillValue.create(0, 0, 0, 100)));
        this.addParam(this.paramWeight = new NumberParam('weight', 'weight', true,  true, true, 1, 0));
        this.addParam(this.paramFit    = new SelectParam('fit',    'align',  true,  true, true, ['inside', 'center', 'outside'], 0));
        this.addParam(this.paramJoin   = new SelectParam('join',   'join',   true,  true, true, ['miter', 'bevel', 'round'], 0));
        this.addParam(this.paramMiter  = new NumberParam('miter',  'miter',  true,  true, true, 28.96, 0, 180, 2));

        this.paramMiter.controls[0].setSuffix('', true);
        this.paramMiter.canShow = () => this.paramJoin.value == 0;
    }
    
    
    
    // canAutoConnectFrom(output)
    // {
    //     return output.supportsTypes(FILL_TYPES)
    //         || output.supportsTypes(COLOR_TYPES);
    // }



    output_genRequest(gen)
    {
        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const hasInputs =
               this.node.paramFill  .input.connected
            || this.node.paramWeight.input.connected
            || this.node.paramFit   .input.connected
            || this.node.paramJoin  .input.connected
            || this.node.paramMiter .input.connected;

        const options = (hasInputs ? 1 : 0) << 20;


        const [request, ignore] = this.node.genRequestStart(gen, options);
        if (ignore) return request;

        
        const input = this.node.inputs[0];


        request.push(input.connected ? 1 : 0);


        if (input.connected)
        {
            request.push(...pushInputOrParam(input, gen));


            const paramIds = [];

            for (const param of this.node.params)
                if (   param.input 
                    && param.input.connected)
                    paramIds.push(param.id);

            request.push(paramIds.join(','));


            for (const param of this.node.params)
                if (param.input.connected) request.push(...param.genRequest(gen));            
        }
        else
        {
            for (const param of this.node.params)
                request.push(...param.genRequest(gen));            
        }


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        const fill = values[paramIds.findIndex(id => id == 'fill')];

        this._color = 
               fill
            && fill.isValid()
            ? fill.color.toDataColor()
            : dataColor_NaN;

            
        this.outputs[0].types =
               this.inputs[0].connected
            && this.inputs[0].connectedOutput.supportsTypes(SHAPE_TYPES)
            ? [...this.inputs[0].connectedOutput.types, STROKE_VALUE]
            : [STROKE_VALUE];


        super.updateValues(requestId, actionId, updateParamId, paramIds, values);
    }



    updateHeader()
    {
        //console.log(this.id + '.OpStroke.updateHeader()');

        Operator.prototype.updateHeader.call(this);


        const colors = this.getHeaderColors();


        this.header.style.background = 
            !rgbaIsNaN(colors.stripeBack)
            ? rgba2style(colors.stripeBack) 
            : 'transparent';

        this.colorBack.style.background = 
            rgbIsOk(colors.stripeBack) //!rgbIsNaN(colors.back)
            ? rgb2style(colors.stripeBack)
            : rgba2style(rgb_a(rgbDocumentBody, 0.95));


        this.colorBack.style.height = this.measureData.headerOffset.height;

            
        this.checkers.style.height = this.header.offsetHeight;

        this.checkers.style.background =
            darkMode
            ?   'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%), '
              + 'linear-gradient(45deg, #222 25%, transparent 25%, transparent 75%, #222 75%)'
            :   'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%), '
              + 'linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%)';

        this.checkers.style.display            = !rgbIsNaN(colors.back) ? 'inline-block' : 'none';
        this.checkers.style.backgroundColor    = darkMode ? '#444' : '#fff';

        this.checkers.style.backgroundSize     = '22px 22px';
        this.checkers.style.backgroundPosition = '0 0, 11px 11px';
                        
        this.checkers.style.left               = '-3px';
        this.checkers.style.width              = 'calc(100% + 3px)';


        this.header.style.background = 
            !rgbIsNaN(colors.stripeBack)
            ? rgba2style(colors.stripeBack) 
            : 'transparent';


        this.inputs[0] .colorLight = 
        this.inputs[0] .colorDark  = colors.input;
        this.inputs[0] .wireColor  = colors.wire;

        this.outputs[0].colorLight =
        this.outputs[0].colorDark  = colors.output;
        this.outputs[0].wireColor  = colors.wire;


        this.updateWarningOverlay();
        this.updateWarningOverlayStyle(colors.back, this.inputIsShape ? -1 : 45);
    }



    updateHeaderLabel()
    {
        super.updateHeaderLabel();
        
        const colors = this.getHeaderColors();
        this.label.style.color = rgba2style(colors.text);
    }



    updateParams()
    {
        const enableFill = !this.paramFill.input.connected;
 
        const enable = 
               !this.inputs[0].connected
            || !this.inputs[0].connectedOutput.supportsTypes(STROKE_TYPES);

        this.paramFill  .enableControlText(enableFill);
        this.paramWeight.enableControlText(enable);
        this.paramFit   .enableControlText(enable);
        this.paramJoin  .enableControlText(enable);
        this.paramMiter .enableControlText(enable);

        this.updateParamControls();
    }

    

    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors();

        colors.back       = rgb_a(colors.back, this.paramFill.value.opacity.value/100);
        colors.stripeBack = rgb_a(colors.stripeBack, this.paramFill.value.opacity.value/100);
        colors.text       = getTextColorFromBackColor(colors.stripeBack, this.paramFill.value.opacity.value/100);
        colors.input      = rgb_a(colors.text, 0.2);
        colors.output     = rgb_a(colors.text, 0.2);

        colors.wire = 
            !rgbaIsNaN(colors.stripeBack)
            ? colors.stripeBack
            : rgbFromType(ANY_TYPE, false);

        return colors;
    }



    updateWarningOverlayStyle(colBack, height = -1)
    {
        super.updateWarningOverlayStyle(colBack, height);
        
        this._warningOverlay.style.backgroundPosition = '-1.5px 0';
        this._warningOverlay.style.backgroundSize     = 'calc(100% + 16px) 100%';
        this._warningOverlay.style.display            = 'block';
    }
}


class   OpGroupNode
extends OperatorBase
{
    constructor()
    {
        super(GROUP_NODE, 'group', 'group');


        this.saveParams = false;


        graph.currentPage.groupId = this.id;
        graph.updateSavedPages();
    }



    output_genRequest(gen)
    {
        // 'this' is the output        
        if (   this.paramNode
            && this.paramNode.inputs[0].connected)
            return this.paramNode.inputs[0].connectedOutput.genRequest(gen);

            
        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL }); 


        const [request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return request;


        request.push(this.params.length);

        for (const param of this.params)
            request.push(param.name, ...param.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);

        return request;
    }



    genRequest(gen) // for when there are no header outputs
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: null });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        request.push(this.params.length);

        for (const param of this.params)
            request.push(param.name, ...param.genRequest(gen));


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateParams()
    {
        for (const param of this.params)
        {
            param.enableControlText(param.input ? true : false);
            param.controls[0].showName = param.paramNode.name[0] != '.';
        }

            
        const paramNodes = this.params.map(p => p.paramNode);

        paramNodes.sort((a, b) => 
        {
            // if (a.inputs[0].connected && b.outputs[0].connected) return -1;
            // if (b.inputs[0].connected && a.outputs[0].connected) return  1;
            return a.div.offsetTop - b.div.offsetTop;
        });

        paramNodes.sort((a, b) => 
                a.div.offsetTop - b.div.offsetTop
            && !a.inputs[0].connected 
            &&  b.inputs[0].connected);


        for (let i = 0; i < paramNodes.length; i++)
            paramNodes[i].groupParam.div.style.order = i;


        this.updateParamControls();
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);

        if (!isEmpty(this.headerInputs))
        {
            colors.input  = 
            colors.output =
            colors.wire   = rgbFromType(this.headerInputs[0].types[0], true);
        }
        else if (!isEmpty(this.headerOutputs))
        {
            colors.input  = 
            colors.output =
            colors.wire   = rgbFromType(this.headerOutputs[0].types[0], true);
        }

        return colors;
    }
}


class   OpGroupParam
extends OperatorBase
{
    headerCircle;

    circleBack;
    circle;
    icon;

    paramType = 0; // 0 = param
                   // 1 = header
                   // 2 = variable header


    groupParam  = null;
    groupInput  = null;
    groupOutput = null;


    get groupNode() 
    { 
        return graph.currentPage.groupId != NULL
             ? nodeFromId(graph.currentPage.groupId)
             : null;
    }



    constructor()
    {
        super(GROUP_PARAM, 'param', 'parameter');

        this.alwaysLoadParams = true;


        this.addInput (new Input ([ANY_TYPE]));
        this.addOutput(new Output([ANY_TYPE], this.output_genRequest));


        this. inputs[0].addEventListener('connect',    e =>  input_onconnect   (this));
        this. inputs[0].addEventListener('disconnect', e =>  input_ondisconnect(this));

        this.outputs[0].addEventListener('connect',    e => output_onconnect   (this));
        this.outputs[0].addEventListener('disconnect', e => output_ondisconnect(this));


        this.circleBack        = createDiv('headerCircleBack');
        this.circle            = createDiv('headerCircle');

        this.headerCircle      = createDiv('headerCircleWrapper');
        this.headerCircle.over = false;
        this.headerCircle.down = false;


        this.headerCircle.addEventListener('pointerenter', e => 
        { 
            if (   this. inputs[0].connected
                || this.outputs[0].connected)
                return;

            this.headerCircle.over = true;  
            this.updateHeader(); 
        });


        this.headerCircle.addEventListener('pointerleave', e => 
        { 
            this.headerCircle.over = false; 
            this.updateHeader(); 
        });


        this.headerCircle.addEventListener('pointerdown',  e => 
        { 
            e.stopPropagation();
``
            if (e.button == 0)
            {
                hideAllMenus();

                if (   !this. inputs[0].connected
                    && !this.outputs[0].connected)
                {
                    let paramType = this.paramType + 1;
                    if (paramType == 2 /*3*/) paramType = 0;

                    actionManager.do(new ToggleParamHeaderAction(this.id, paramType));
                }
            }
            else
                e.preventDefault();
        });


        this.icon = createDiv('headerIcon');


        this.headerCircle.appendChild(this.circleBack);
        this.headerCircle.appendChild(this.circle);
        this.headerCircle.appendChild(this.icon);
        
        this.label.insertBefore(this.headerCircle, this.labelText);
    }



    getDefaultOffset()
    {
        return -1.5;
    }



    output_genRequest(gen)
    {
        const request = [];


        if (this.node.groupInput)
        {
            if (this.node.groupParam)
            {
                //if (!gen.passedNodes.includes(this.node.groupParam.input.connectedOutput.node))
                    return this.node.groupParam.genRequest(gen);
                // else
                //     return [];
            }

            else if (this.node.groupInput.connected
                 && !gen.passedNodes.includes(this.node.groupInput.connectedOutput.node))
            {
                const _request = this.node.groupInput.connectedOutput.genRequest(gen);
                return _request;
            }
        }


        // 'this' is the output

        gen.scope.push({
            nodeId:  this.node.id, 
            paramId: NULL });


        const [_request, ignore] = this.node.genRequestStart(gen);
        if (ignore) return _request;
        console.log('param id =', this.node.id);


        request.push(..._request);


        const groupInput = this.node.groupInput;

        const output = 
            !isEmpty(this.node.outputs)
            ? this.node.outputs[0]
            : null;


        request.push(groupInput && groupInput.connected ? 1 : 0);
        request.push(output && output.connected ? 1 : 0);


        if (groupInput && groupInput.connected)
        {
            request.push(...pushInputOrParam(groupInput, gen));
            request.push(groupInput.connectedOutput.types[0]);
        }

        else if (output && output.connected)
            request.push(output.connectedInputs[0].types[0]);


        gen.scope.pop();
        pushUnique(gen.passedNodes, this.node);


        return request;
    }


    
    updateValues(requestId, actionId, updateParamId, paramIds, values)
    {
        super.updateValues(requestId, actionId, updateParamId, paramIds, values);

        if (   graphView.creatingNodes
            || graphView.pastingNodes
            || graphView.loadingNodes
            || graphView.restoringNodes)
            this.setName(this.name);
    }



    updateHeader()
    {
        super.updateHeader();


        if (true) //this.paramValue.value.isValid()
        {
            const colors = this.getHeaderColors();

            //const rgb        = rgbFromType(ANY_TYPE);//this.paramValue.value.toRgba();
            //const rgbaStripe = rgb_a(getStripeBackColor(rgb));
            
            this.circleBack.style.visibility = 'hidden';//'visible';
            //this.circle    .style.background = rgba2style(rgbaStripe);

            // this.headerCircle.style.boxShadow = 
            //     //     darkMode &&  isDark(rgbaStripe, 0.4)
            //     // || !darkMode && !isDark(rgbaStripe, 0.9)
            //     //? 
            //     '0 0 0 1px ' + rgba2style(rgb_a(colors.text, this.headerCircle.over ? 0.7 : 0.35)) +' inset'
                // : 'none';
        }
        else
        {
            this.circleBack  .style.visibility = 'hidden';
            this.circle      .style.background = 'transparent';
            this.headerCircle.style.boxShadow  = '0 0 0 1px var(--figma-color-bg-tertiary) inset';
        }


        this.updateHeaderIcon();
    }

    

    updateHeaderIcon()
    {
        const colors = this.getHeaderColors();

        const rgba       = rgb_a(rgbFromType(ANY_TYPE));
        const rgbaStripe = rgb_a(getStripeBackColor(rgba), rgba[3]);

        const headerStyle = rgba2style(
            rgb_a(
                rgbFromType(ANY_TYPE) //this.paramValue.value.isValid()
                ? (isDark(rgbaStripe) ? [1, 1, 1] : [0, 0, 0])
                : colors.text, 
                this.headerCircle.down 
                ? 1 
                : this.headerCircle.over
                  ? 0.7 
                  : 0.5));

        this.icon.style.display            = 'inline-block';
        this.icon.style.background         = this.paramType == 2
                                             ? 'url(\'data:image/svg+xml;utf8,<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 3C0 1.34314 1.34314 0 3 0H9C10.6569 0 12 1.34314 12 3V9C12 10.6569 10.6569 12 9 12H3C1.34314 12 0 10.6569 0 9V3ZM5 2.5H7V5H9.5V7H7V9.5H5V7H2.5V5H5V2.5Z" fill="'+headerStyle+'"/></svg>\')'
                                             : this.paramType == 1
                                               ? 'url(\'data:image/svg+xml;utf8,<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 3C0 1.34314 1.34314 0 3 0H9C10.6569 0 12 1.34314 12 3V6H0V3Z" fill="'+headerStyle+'"/></svg>\')'
                                               : 'url(\'data:image/svg+xml;utf8,<svg width="12" height="12" viewBox="0 -5 12 12" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="0.5" y="0.5" width="11" height="6" stroke="'+headerStyle+'"/></svg>\')';

        this.icon.style.backgroundPosition = '50% calc(50% + 1px)';
        this.icon.style.backgroundRepeat   = 'no-repeat';
    }



    getHeaderColors(options = {})
    {
        const colors = super.getHeaderColors(options);


        if (this.inputs[0].connected)
        {
            if (   this.inputs[0].supportsTypes([COLOR_VALUE])
                || this.inputs[0].supportsTypes([ FILL_VALUE]))
                colors.input  =
                colors.output =
                colors.wire   = this.inputs[0].connectedOutput.wireColor;
            else
                colors.input  =
                colors.output =
                colors.wire   = rgbFromType(this.inputs[0].types[0], true);
        }
        else if (this.outputs[0].connected)
        {
            if (   this.outputs[0].supportsTypes([COLOR_VALUE])
                || this.outputs[0].supportsTypes([ FILL_VALUE]))
                colors.input  =
                colors.output =
                colors.wire   = this.outputs[0].connectedInputs[0].wireColor;
            else
                colors.input  =
                colors.output =
                colors.wire   = rgbFromType(this.outputs[0].types[0], true);
        }


        return colors;
    }



    setName(newName, options = {})
    {
        if (this.paramType == 0)
        {
            const paramNodes = graph.pageNodes.filter(n => 
                   n.type == GROUP_PARAM
                && n != this);

            newName = getNewNumberId(
                paramNodes, 
                name => paramNodes.find(n => n.name == name), 
                newName, 
                newName, 
                '');


            if (this.groupParam)
            {
                //const param = this.groupNode.paramFromId(this.name);

                // if (param)
                // {
                    this.groupParam._id = newName;
                    this.groupParam.setName(newName);
                // }
            }

        
            if (this.groupNode)
            {
                const id      = makeNodePath(idFromNodePath(this.id));
                const groupId = makeNodePath(idFromNodePath(this.groupNode.id));


                uiSaveNodes([id]);
                uiSaveNodes([groupId]);
                
                uiUpdateSavedConnectionsToNodeId  ([id], true);
                uiUpdateSavedConnectionsFromNodeId([id], true);
                
                uiUpdateSavedConnectionsToNodeId  ([groupId], true);
                uiUpdateSavedConnectionsFromNodeId([groupId], true);


                nodeFromId(groupId).updateParams();
            }
        }


        super.setName(newName, options);
    }



    setPosition(x, y, updateTransform = true)
    {
        super.setPosition(x, y, updateTransform);

        if (this.groupNode)
        {
            this.groupNode.updateNode();
            graphView.updateNodeWireTransforms([this.groupNode]);
        }
    }



    toJsonBase(nTab = 0) 
    {
        let   pos = ' '.repeat(nTab);
        const tab = HTAB;

        let  json = super.toJsonBase(nTab);

        json += ',\n' + pos + tab + '"paramType": "' +  this.paramType                                 + '"';

        return json;
    }



    loadParams(_node, pasting)
    {
        super.loadParams(_node, pasting);

        if (_node.paramType != undefined) 
            this.paramType = parseInt(_node.paramType);
    }
}



function input_onconnect(node)
{
    // if (   !node.inputs [0].connected
    //     && !node.outputs[0].connected)
        node.inputs[0].types = [...node.inputs[0].connectedOutput.types];
    
        
    node. inputs[0].types =
    node.outputs[0].types = [...node.inputs[0].connectedOutput.types];
    
    node.outputs[0].div.style.display = 'none';


    if (node.paramType == 0)
    {
        node.groupParam = createParamFromType(
            node.inputs[0].types[0], 
            {
                hasOutput: true,
                id:        node.name,
                name:      node.name,
                showName:  node.name[0] != '.'
            });

        node.groupParam.paramNode = node;

        node.groupOutput = node.groupParam.output;
        node.groupNode.addParam(node.groupParam);
    }
    else if (node.paramType == 1)
    {
        node.groupOutput = new Output([...node.inputs[0].types], node.groupNode.output_genRequest);
        node.groupNode.addOutput(node.groupOutput);
    }
    

    node.groupOutput.paramNode = node;
    node.groupNode.updateNode();
}



function input_ondisconnect(node)
{
    // if (!graph.pageNodes.find(n => 
    //            n.type      == GROUP_PARAM
    //         && n.paramType == 1
    //         && (   !isEmpty(n. inputs) && n. inputs[0].connected 
    //             || !isEmpty(n.outputs) && n.outputs[0].connected)))
    //     node.inputs[0].types = [ANY_TYPE];


    node.outputs[0].types = [ANY_TYPE];
    node. inputs[0].types = [ANY_TYPE];

    node.outputs[0].div.style.display = 'inline-block';


    if (node.groupOutput.connected)
        node.groupOutput.connectedInputs.forEach(i => uiDisconnect(i));


    if (node.paramType == 0)
    {
        node.groupNode.removeParam(node.groupParam);
        node.groupOutput.paramNode = null;
    }
    else if (node.paramType == 1)
    {
        node.groupNode.removeOutput(node.groupOutput);
        node.groupOutput.paramNode = null;
    }


    node.groupNode.updateNode();
}



function output_onconnect(node)
{
    // console.log('XXX =', node.outputs[0].connectedInputs[0]);
    // if (   !node.inputs [0].connected
    //     && !node.outputs[0].connected)
        node.outputs[0].types = [...node.outputs[0].connectedInputs[0].types];

    node.inputs[0].div.style.display = 'none';


    if (node.paramType == 0)
    {
        node.groupParam = createParamFromType(
            node.outputs[0].types[0], 
            {
                hasInput: true,
                id:       node.name,
                name:     node.name,
                showName: node.name[0] != '.'
            });

        node.groupParam.paramNode = node;

        node.groupInput = node.groupParam.input;
        node.groupNode.addParam(node.groupParam);
    }
    else if (node.paramType == 1)
    {
        node.groupInput = new Input([...node.outputs[0].types]);
        node.groupNode.addInput(node.groupInput);
    }
    
    
    node.groupInput.paramNode = node;
    node.groupNode.updateNode();
}



function output_ondisconnect(node)
{
    // if (!graph.pageNodes.find(n => 
    //            n.type      == GROUP_PARAM
    //         && n.paramType == 1
    //         && (   !isEmpty(n. inputs) && n. inputs[0].connected 
    //             || !isEmpty(n.outputs) && n.outputs[0].connected)))
    //     node.outputs[0].types = [ANY_TYPE];

    node.outputs[0].types = [ANY_TYPE];
    node. inputs[0].types = [ANY_TYPE];

    node.inputs[0].div.style.display = 'inline-block';

    
    if (node.groupInput.connected)
        uiDisconnect(node.groupInput);


    if (node.paramType == 0) 
    {
        node.groupParam.paramNode = null;

        node.groupNode.removeParam(node.groupParam);
        node.groupParam = null;
    }
    else if (node.paramType == 1) 
        node.groupNode.removeInput(node.groupInput);


    node.groupInput.types     = [ANY_TYPE];
    node.groupInput.paramNode = null;
    node.groupInput           = null;


    node.groupNode.updateNode();
}


class   OpComment
extends OperatorBase
{
    constructor()
    {
        super(COMMENT, 'comment', 'comment', 0);

        this.scrollName = false;


        this.textbox.addEventListener('input', e =>
        {
            this.updateNode();
            this.updateTransform();
        });


        this.textbox.addEventListener('change', e =>
        {
            if (this.textbox.value.trim() == '')
                actionManager.do(new DeleteNodesAction([this.id]), true);
        });
    }



    setSelected(sel)
    {
        this._selected = sel;
    }



    genRequest(gen)
    {
        // 'this' is the node

        gen.scope.push({
            nodeId:  this.id, 
            paramId: null });


        const [request, ignore] = this.genRequestStart(gen);
        if (ignore) return request;


        gen.scope.pop();
        pushUnique(gen.passedNodes, this);

        return request;
    }



    updateNode()
    {
        super.updateNode();


        this.inner.style.boxShadow = 'none';


        utilContext.font = '11px Inter';
        
        const mes = utilContext.measureText(
            hasFocus(this.textbox) 
            ? this.textbox.value 
            : this.name);


        const width = Math.max(1, mes.width + 2);

        this.div    .style.width   = 
        this.textbox.style.width   = width + 'px';

        this.textbox.style.height  = this.div.offsetHeight;
        this.textbox.style.padding = '0';
        this.textbox.style.margin  = '0';
    }



    updateHeader()
    {
        this.header.style.overflow   = 'visible';
        this.header.style.background = 'transparent';
       
        this.updateHeaderLabel();
    }



    updateHeaderLabel()
    {
        this.labelText.innerHTML = this.name;


        if (this.selected)
        {
            this.label.style.color        = 'var(--figma-color-bg-brand)';//rgb2style_a(hex2rgb(colFigmaBlue), 0.7);
            this.label.style.textShadow   = '0 0 0 var(--figma-color-bg-brand)';// + colFigmaBlue;

            this.textbox.style.color      = rgb2style_a(hex2rgb(colFigmaBlue), 0.7);
            this.textbox.style.textShadow = '0 0 0 ' + colFigmaBlue;
        }
        else
        {
            this.label.style.color        = 'var(--figma-color-bg-disabled-secondary)';
            this.label.style.textShadow   = 'none';

            this.textbox.style.color      = 'var(--figma-color-bg-disabled-secondary)';
            this.textbox.style.textShadow = 'none';
        }
    

        this.labelWrapper.style.overflow      = 'visible';

        this.label.style.background           = 'transparent';
        this.label.style.textAlign            = 'left';

        this.label.style.left                 = '0';
        this.label.style.top                  = '0';

        this.label.style.transform            = 'none';

        this.label.style.WebkitBackgroundClip = 'inherit';
        this.label.style.WebkitTextFillColor  = 'inherit';
    }



    updateBorder()
    {
        this.div.style.boxShadow = 'none';
    }
}


class GraphPage
{
    id;
    name;


    groupId;


    button;

    btnIcon;
    btnName;
    btnClose;


    groupId; // a page with a group ID makes it a group



    _pan = point(0, 0);
        
    get pan() { return this._pan; }
    set pan(pan)
    {
        if (this._pan == pan) return;

        this._pan = pan;
        
        graphView.updatePanAndZoom(true);
    }
    

    _zoom = 1;
    
    get zoom() { return this._zoom; }
    set zoom(zoom)
    {
        if (this._zoom == zoom) return;

        let pos = point(
            window.innerWidth /2,
            window.innerHeight/2);

        pos.y -= getTopHeight();

        const _pan = subv(this.pan, mulvs(subv(pos, this.pan), zoom / this.zoom - 1));

        this.setPanAndZoom(_pan, zoom);
    }


    setPanAndZoom(pan, zoom)
    {
        if (  (   pan  != this._pan
               || zoom != this._zoom)
            && zoom >= 0.02
            && zoom <= 50)
        {
            graphView.oldZoom = this.zoom;
    
            this._zoom = zoom;
            this._pan  = pan;
    
            
            graphView.panZoomTimer = setTimeout(() => 
            {
                graphView.updatePanAndZoom(this.zoom != graphView.oldZoom);
                graphView.panZoomTimer = null;
            });
        }
    };
    
    
    
    constructor(id, name, groupId = '')
    {
        this.id       = id;
        this.name     = name;
    

        this.groupId  = groupId;


        this.button   = createDiv('page');

        this.btnIcon  = createDiv('pageIcon');
        this.btnName  = createDiv('pageName');
        this.btnClose = createDiv('pageClose');


        this.button.appendChild(this.btnIcon);
        this.button.appendChild(this.btnName);
        this.button.appendChild(this.btnClose);



        this.button.addEventListener('pointerenter', e => 
        { 
            graph.overIndex = graph.pages.indexOf(this); 
            graph.updatePages(); 
        });
        
        
        this.button.addEventListener('pointerleave', e => 
        { 
            graph.overIndex = -1;
            graph.updatePages(); 
        });
        
        
        this.button.addEventListener('pointerdown' , e => 
        { 
            if (e.button == 0)
            {
                graph.pageIndex = graph.pages.indexOf(this); 
                graph.updatePages(); 
                
                graph.updateSavedPages();
            }
        });



        this.btnClose.addEventListener('pointerenter', e => 
        { 
            this.btnClose.style.opacity = 1;    
        });
        
        
        this.btnClose.addEventListener('pointerleave', e => 
        { 
            this.btnClose.style.opacity = 0.65; 
        });
        
        
        this.btnClose.addEventListener('pointerdown', e =>
        {
            e.stopPropagation();
        });


        this.btnClose.addEventListener('pointerup', e => 
        { 
            if (e.button == 0)
            {
                graph.removePage(this);

                uiRemoveSavedPage(this.id);
                uiRemoveSavedNodesAndConns(graph.nodes.filter(n => n.pageId == this.id).map(n => n.id));

                graph.updatePages();
            }
        });
    }



    update()
    {
        const index = graph.pages.indexOf(this);

        const isCurrent = 
               index == graph.pageIndex
            || index == graph.overIndex;

        this.btnIcon .innerHTML           = iconPage;
        this.btnName .innerHTML           = settings.showNodeId ? this.id : this.name;
        this.btnClose.innerHTML           = iconPageClose;
        
        this.button  .style.background    = isCurrent ? '#2c2c2c' : (document.hasFocus() ? '#202020' : '#383838');
        
        this.btnIcon .style.display       = this.button.offsetWidth >= 75 ? 'inline-block' : 'none';
        this.btnIcon .style.opacity       = isCurrent ? 1 : 0.35;
        
        this.btnName .style.color         = isCurrent ? '#fffffff0' : '#fff6';

        this.btnClose.style.pointerEvents = isCurrent && graph.pages.length > 1 ? 'all' : 'none';
        this.btnClose.style.opacity       = isCurrent && graph.pages.length > 1 ? 0.65 : 0;    
    }



    toJson()
    {
        const tab = '\n' + HTAB;

        return '{'
            + tab + '"id": "'      + this.id      + '",'
            + tab + '"name": "'    + this.name    + '",'
            + tab + '"zoom": "'    + this.zoom    + '",'
            + tab + '"panx": "'    + this.pan.x   + '",'
            + tab + '"pany": "'    + this.pan.y   + '",'
            + tab + '"groupId": "' + this.groupId + '"'
            + '\n}';
    }


    
    load(json)
    {
        this._pan  = point(0, 0);
        this._zoom = 1;
    
        
        if (json)
        {
            const data = JSON.parse(json);

            this.id   = data.id;
            this.name = data.name;


            this._pan = point( 
                parseFloat(data.panx), 
                parseFloat(data.pany));
    
            if (isNaN(this.pan.x)) this._pan.x = 0;
            if (isNaN(this.pan.y)) this._pan.y = 0;
    
            
            this._zoom = parseFloat(data.zoom);
            if (isNaN(this.zoom)) this._zoom = 1;


            this.groupId = data.groupId;
        }
    }
}


class Graph
{
    parentNodeGroup = null;


    pages           = [];

    pageIndex       = -1;
    overIndex       = -1;
    
    
    
    nodes           = [];
    deferNodeIds    = [];
    
    connections     = [];
    
    
    get currentPage() { return this.pages[this.pageIndex]; }
    get pageNodes  () { return this.nodes.filter(n => n.pageId == this.currentPage.id); }



    clear()
    {
        this.deleteNodes(this.nodes.map(n => n.id));
        this.connections = [];
    }



    addNodes(nodes, placeNode = true)
    {
        for (const node of nodes)
            this.addNode(node, placeNode);
    }



    addNode(node, placeNode = true, updateLabel = true)
    {
        node.graph = this;

        node.id = getNewNumberId(
            this.nodes, 
            id => this.nodes.find(n => n.id == id), 
            node.id);
        
        this.nodes.push(node);
        graphView.div.appendChild(node.div);
        
        if (placeNode)
            graphView.placeNewNode(node);

        node.div.style.zIndex = graph.nodes.length-1;
        graphView.putNodeOnTop(node);


        graphView.updateScrollWithBounds();
    }
    


    deleteNodes(nodeIds)
    {
        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            for (let i = node.inputs.length-1; i >= 0; i--) // backwards for the sake of variable inputs
            {
                const input = node.inputs[i];
                if (!input.connected) continue;

                uiMakeNodeActive(input.connectedOutput.node);
                this.disconnect(input, true);
            }
            
            for (let i = node.outputs.length-1; i >= 0; i--)
            {
                const output = node.outputs[i];
                
                for (const connInput of output.connectedInputs)
                    this.disconnect(connInput, true);
            }
        }


        for (const id of nodeIds)
        {
            const node = this.nodes.find(n => n.id == id);

            node.selected    = false;
            node.graph = null;

            node.div.style.display = 'none';

            removeFromArray(this.nodes, node);  
            graphView.div.removeChild(node.div);
        }


        graphView.updateScrollWithBounds();
    }



    connect(output, input, inputId = '', outputOrder = -1)
    {
        //console.log('graph.connect()');

        if (input.connectedOutput == output)
            return null;
            

        if (input.connectedOutput)
        {
            const output = input.connectedOutput;
            this.disconnect(input);
            output.updateControl();
        }


        if (    input.node.variableInputs
            && !input.param
            &&  inputId != '')
        {
            input = input.node.headerInputs.at(-1);
            
            const inputIndex = 
                   inputId != ''
                && isDigit(inputId[0])
                ? parseInt(inputId)
                : input.index;

            // move new input back to correct index
            moveInArray(
                input.node.inputs, 
                input.node.headerInputs.length-1, 
                inputIndex);

            input.node.inputControls.insertBefore(
                lastOf(input.node.inputControls.childNodes), 
                input.node.inputControls.childNodes[inputIndex]);
        }


        const conn = new Connection(output, input);

        conn.outputOrder = 
            outputOrder > -1
            ?  outputOrder
            : !isEmpty(output.connectedInputs)
            ? Math.max(...output.connectedInputs.map(i => i.connection.outputOrder)) + 1
            : 0;

        output.connection = conn;

        if (outputOrder > -1) output.connectedInputs.splice(outputOrder, 0, input);
        else                  output.connectedInputs.push(input);
        
        input.connection      = conn;
        input.connectedOutput = output;

        
        graphView.addConnWires(conn);

        this.connections.push(conn);

        
        output.updateControl();


        return conn;
    }



    disconnect(input)
    {
        const output = input.connectedOutput;
        if (!output) return false;


        graphView.removeConnWires(input.connection);

        removeFromArray(this.connections, input.connection);
        removeFromArray(output.connectedInputs, input);


        input.connectedOutput = null;
        input.connection      = null;


        if (input.param)
            input.param.resetControls();


        return true;
    }
}



function nodeFromId(id)
{
    return graph.nodes.find(n => n.id == id);
}



function nodesFromIds(ids)
{
    return ids.map(id => nodeFromId(id));
}



function setNodeId(nodeId, newId)
{
    const node = nodeFromId(nodeId);
    node.id = newId;
}



function getActiveFromNodeId(nodeId, alreadyChecked = [])
{
    return getActiveFromNode(nodeFromId(nodeId), alreadyChecked);
}



function getActiveNodesAfterNodeId(nodeId, alreadyChecked = [])
{
    const rightActive = [];
    
   
    const node = nodeFromId(nodeId);
    
    if (node.active) 
        rightActive.push(node);


    for (const output of node.headerOutputs)
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                rightActive.push(...getActiveNodesAfterNodeId(
                    input.node.id, 
                    [...alreadyChecked, node]));
            }
        }
    }


    return rightActive;
}



function getActiveNodesFromNodeId(nodeId, alreadyChecked = [])
{
    return getActiveNodesFromNode(nodeFromId(nodeId), alreadyChecked);
}



function pageIdFromPath(_path)
{
    const path = _path.split('/');
    return path.length > 1 ? path[0] : '';
}



function stripPathFromId(path)
{
    return path.split('/').at(-1);
}


// function activeNode(node) 
// { 
//     const left  = activeNodeLeft(node);  if (!!left ) return left;
//     const right = activeNodeRight(node); if (!!right) return right;

//     return null;
// }



// function activeNodeLeft(node)
// {
//     if (node.active) return node;

//     for (const input of node.inputs)
//     {
//         if (input.connected)
//         {
//             const left = activeNodeLeft(input.connectedOutput.node);
//             if (left) return left;
//         }
//     }

//     return null;
// }



// function activeNodeRight(node)
// {
//     if (node.active) return node;

//     for (const output of node.outputs)
//     {
//         for (const connInput of output.connectedInputs)
//         {
//             const right = activeNodeRight(connInput.node);
//             if (right) return right;
//         }
//     }

//     return null;
// }



function getAllNodesFromNode(node, ignore = [])
{
    const nodes = [node];

    if (!ignore.includes(node)) 
        ignore.push(node);


    for (const input of node.inputs.filter(i => i.connected))
    {
        const _node = input.connectedOutput.node;
        if (ignore.includes(_node)) continue;

        nodes.push(...getAllNodesFromNode(_node, ignore));
    }


    for (const output of node.outputs)
    {
        for (const _input of output.connectedInputs)
        {
            const _node = _input.node;
            if (ignore.includes(_node)) continue;

            nodes.push(...getAllNodesFromNode(_node, ignore));
        }
    }


    return nodes;
}



function getNodesAcrossNode(node)
{
    return [...getNodesBeforeNode(node),
            ...getNodesAfterNode (node)];
}



function getNodesBeforeNode(node)
{
    let before = [];

    for (const input of node.inputs.filter(i => i.connected))
    {
        if (!before.includes(input.connectedOutput.node)) // avoid including diamond tips twice
            before.push(input.connectedOutput.node);
    
        before.push(...getNodesBeforeNode(input.connectedOutput.node));
    }

    return before;
}



function getNodesAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
    {
        for (const input of output.connectedInputs)
        {
            if (!after.includes(input.node)) // avoid including diamond tips twice
                after.push(input.node);

            after.push(...getNodesAfterNode(input.node));
        }
    }

    return after;
}



function getProgressNodesAfterNode(node)
{
    let after = [];

    for (const output of node.outputs)
    {
        for (const input of output.connectedInputs)
        {
            if (input.node.hasProgressBar)
                pushUnique(after, input.node);

            pushUnique(after, getProgressNodesAfterNode(input.node));
        }
    }

    return after;
}



function getTerminalsInNodes(nodes)
{
    return nodes.filter(n => 
           !n.outputs.find(o => o.connected)
        || !n.outputs.find(o => arraysIntersect(
               o.connectedInputs.map(i => i.node),
               nodes)));
}



function getTerminalsAfterNode(node)
{
    let after = [];


    if (node.type == GROUP_NODE)
    {
        for (const input of node.inputs)
            pushUnique(after, getTerminalsAfterNode(input.paramNode));
            
        for (const output of node.outputs) 
            for (const input of output.connectedInputs) 
                pushUnique(after, getTerminalsAfterNode(input.node));//input.node);
    }

    else if (node.type == GROUP_PARAM)
    {
        // if (   !isEmpty(node.inputs)
        //     && !isEmpty(node.outputs))
        // {
        //     pushUnique(after, node);
        // }

        //else 
        if (!isEmpty(node.outputs))
        {
            const afterNode = [];

            for (const output of node.outputs)
            {
                for (const input of output.connectedInputs)
                    pushUnique(afterNode, getTerminalsAfterNode(input.node));
            }

            if (isEmpty(afterNode))
               pushUnique(afterNode, node);

            pushUnique(after, afterNode);
        }

        
        if (!isEmpty(node.inputs))
        {
            const afterGroupNode = [];

            for (const output of node.groupNode.outputs)
            {
                for (const input of output.connectedInputs)
                    pushUnique(afterGroupNode, getTerminalsAfterNode(input.node));
            }

            if (isEmpty(afterGroupNode))
                pushUnique(afterGroupNode, node.groupNode);

            pushUnique(after, afterGroupNode);
        }
    }
    
    else
    {
        for (const output of node.outputs)
        {
            for (const input of output.connectedInputs)
                pushUnique(after, getTerminalsAfterNode(input.node));
        }
    }


    return !isEmpty(after) ? after : [node];
}



function getTerminalsAfterParam(param)
{
    if (!param.output)
        return getTerminalsAfterNode(param.node);


    let after = [];

    for (const input of param.output.connectedInputs)
        pushUnique(after, getTerminalsAfterNode(input.node));


    return !isEmpty(after) ? after : [];
}



function updateTerminalsAfterNodes(nodes, updateNodes)
{
    for (const node of nodes)
        pushUnique(updateNodes, getTerminalsAfterNode(node));
}



function getActiveInBranchFromNode(node, alreadyChecked = [])
{
    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    const nodeInputs = [...node.inputs.filter(i => i.connected)];

    if (    nodeInputs.length == 1
        && !nodeInputs[0].connectedOutput.param
        && !alreadyChecked.includes(nodeInputs[0].connectedOutput.node))
    {
        const leftActive = getActiveInBranchFromNode(
            nodeInputs[0].connectedOutput.node, 
            [...alreadyChecked, node]);

        if (leftActive) return leftActive;
    }


    const nodeOutputs = node.headerOutputs
        .filter(o => o.connectedInputs.length == 1);

    if (    nodeOutputs.length == 1
        && !nodeOutputs[0].connectedInputs[0].param
        && !alreadyChecked.includes(nodeOutputs[0].connectedInputs[0].node))
    {
        const rightActive = getActiveInBranchFromNode(
            nodeOutputs[0].connectedInputs[0].node, 
            [...alreadyChecked, node]);

        if (rightActive) return rightActive;
    }


    return null;
}



function getActiveFromNode(node, alreadyChecked = [])
{
    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    const leftActive = getActiveBeforeNode(node, [...alreadyChecked]);
    if (leftActive) return leftActive;


    for (const output of node.headerOutputs)
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                const rightActive = getActiveFromNode(
                    input.node, 
                    [...alreadyChecked, node]);

                if (rightActive) return rightActive;
            }
        }
    }


    return null;
}



function getActiveBeforeNode(node, alreadyChecked = [])
{
    //  this is different from LeftOnly in that it will check the left node, 
    //  but then it will also check the right nodes of that left node

    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    for (const input of node.headerInputs)
    {
        if (    input.connected
            && !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
        {
            const leftActive = getActiveFromNode(
                input.connectedOutput.node, 
                [...alreadyChecked, node]);

            if (leftActive) return leftActive;
        }
    }


    return null;
}



function getActiveOnlyBeforeNode(node, alreadyChecked = [])
{
    // this is different from Left in that it will only check left nodes

    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    for (const input of node.headerInputs)
    {
        if (    input.connected
            && !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
        {
            const leftActive = getActiveOnlyBeforeNode(
                input.connectedOutput.node, 
                [...alreadyChecked, node]);

            if (leftActive) return leftActive;
        }
    }


    return null;
}



function getActiveAfterNode(node, includeParams = false, alreadyChecked = [])
{
    if (    node.active
        && !alreadyChecked.includes(node)) 
        return node;


    const outputs = 
        includeParams 
        ? node.outputs 
        : node.headerOutputs;

    for (const output of outputs)
    {
        const connectedInputs = 
            includeParams 
            ? output.connectedInputs
            : output.connectedHeaderInputs;

        for (const input of connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
            {
                const rightActive = getActiveAfterNode(
                    input.node, 
                    includeParams,
                    [...alreadyChecked, node]);

                if (rightActive) return rightActive;
            }
        }
    }


    return null;
}



function getActiveNodesFromNode(node, alreadyChecked = [])
{
    const activeNodes = [];


    if (node.active)
        activeNodes.push(node);


    for (const input of node.headerInputs)
    {
        if (    input.connected
            && !input.connectedOutput.param
            && !alreadyChecked.includes(input.connectedOutput.node))
            pushUnique(activeNodes, getActiveNodesFromNode(input.connectedOutput.node, [...alreadyChecked, node]));
    }


    for (const output of node.headerOutputs)
    {
        for (const input of output.connectedInputs.filter(i => !i.param))
        {
            if (!alreadyChecked.includes(input.node))
                pushUnique(activeNodes, getActiveNodesFromNode(input.node, [...alreadyChecked, node]));
        }
    }


    return activeNodes;
}


Graph.prototype.createPage = function(name)
{
    this.addPage(new GraphPage(
        name.substring(0, 1).toLowerCase() + name.substring(1),
        name));
};



Graph.prototype.addPage = function(page)
{
    page.id = getNewNumberId(
        graph.pages, 
        id => graph.pages.find(p => p.id == id), 
        page.id);

    page.name = getNewNumberId(
        graph.pages, 
        name => graph.pages.find(p => p.name == name), 
        page.name, 
        page.name, 
        ' ');

    this.pages.push(page);

    pagesBar.insertBefore(page.button, btnAddPage);

    this.pageIndex = this.pages.length-1;
};



Graph.prototype.removePage = function(page)
{
    removeFromArray(this.pages, page);

    pagesBar.removeChild(page.button);

    if (this.pageIndex >= this.pages.length)
        this.pageIndex--;
};



Graph.prototype.updatePages = function()
{
    pagesBar.style.background = document.hasFocus() ? '#202020' : '#383838';
    pagesBar.style.display    = settings.showPages ? 'inline-block' : 'none';
    
    this.pages.forEach(p => p.update());
    
    updateAddButton(false);


    
    for (const node of graph.nodes)
    {
        const current = node.pageId == graph.currentPage.id;

        node.div.style.display = current ? 'block' : 'none';

        node.inputs .filter (i => i.connected)     .forEach(i => i.connection.wire.svg.style.display = current ? 'block' : 'none');
        node.outputs.forEach(o => o.connectedInputs.forEach(i => i.connection.wire.svg.style.display = current ? 'block' : 'none'));
    }


    graphView.updateNodeTransforms(graph.nodes.filter(n => n.pageId == graph.currentPage.id));
    graphView.updateNodes();


    pageName.innerHTML = 
        this.currentPage 
        ? (settings.showNodeId 
           ? this.currentPage.id
           : this.currentPage.name)
        : '';


    updateZoomIcon();
}



Graph.prototype.updateSavedPages = function()
{
    uiSavePages(
        this.pages.map(p => p.id), 
        this.pages.map(p => p.toJson()),
        graph.currentPage.id);
}



function updateAddButton(over)
{
    btnAddPage.style.background = over ? '#2c2c2c' : (document.hasFocus() ? '#202020' : '#383838');
    btnAddPlus.style.fill       = over ? '#ffffffe0' : 'rgba(255, 255, 255, 0.35)';
}    



btnAddPage.addEventListener('pointerenter', e => updateAddButton(true ));
btnAddPage.addEventListener('pointerleave', e => updateAddButton(false));

btnAddPage.addEventListener('pointerup', e => 
{
    graph.createPage('Graph');
    graph.updatePages();
    graph.updateSavedPages();
});


class Action
{
    manager;
 
    id;
    type;
    name;

    
    prevAction = null; // these are used to link actions into sequences
    nextAction = null; 
  
    data;
  
    onBefore;
    onAfter;

    onBeforeUndo;
    onAfterUndo;

    
    selfUpdate         = false;
    affectsConnections = true;

    _linkWithNext      = false;

    
    oldConnectionData  = []; // [{outputNodeId, outputId, outputOrder, inputNodeId, inputId}]
    newConnectionData  = []; // [{outputNodeId, outputId, outputOrder, inputNodeId, inputId}]
    
    oldOutputParams    = []; // actual Parameter objects
    newOutputParams    = []; // copies of old params for paste/duplicate



    constructor(type, name)
    {
        this.type  = type;
        this.name  = name;

        console.assert(
               this.name != undefined
            && this.name != null
            && this.name != '',
            'cannot create user action');
    }



    do  (updateNodes) {}
    undo(updateNodes) {}
    redo(updateNodes) { this.do(updateNodes); }



    initSaveArrays()
    {
        this.oldConnectionData = [];
        this.newConnectionData = [];

        this.oldOutputParams   = [];
        this.newOutputParams   = [];
    }



    saveOldConnections()
    {
        for (const conn of graph.connections)
        {
            this.oldConnectionData.push(conn.toDataObject());
 
            if (conn.output.param)
            {
                conn.output.param._nodeId = conn.output.param.node.id;
                this.oldOutputParams.push(conn.output.param);
            }
        }
    }



    updateOldConnections()
    {
        this.oldConnectionData = this.oldConnectionData
            .filter(c => 
                  !graph.connections.find(gc => 
                         gc.id == c.id
                      && (   !gc.output.param
                          || !gc.output.param.volatile)));

        const oldOutputParams = this.oldOutputParams.filter(p => 
            this.oldConnectionData.find(c =>
                       p._nodeId   == c.outputNodeId
                    && p.output.id == c.outputId));

        this.oldOutputParams = oldOutputParams;
    }



    deleteNewConnections()
    {
        for (const _conn of this.newConnectionData)
        {
            uiDeleteSavedConnection(
                getConnectionKey(
                    _conn.outputNodeId, _conn.outputId, _conn.outputOrder,
                    _conn.inputNodeId,  _conn.inputId),
                _conn.outputNodeId,
                _conn.outputId,
                _conn.outputOrder,
                _conn.inputNodeId,
                _conn.inputId,
                _conn.list);
  
            uiDisconnect(nodeFromId(_conn.inputNodeId).inputFromId(_conn.inputId));
        }

        this.newConnectionData = [];
    }



    restoreOldConnections()
    {
        for (const _conn of this.oldConnectionData)
        {
            const outputNode = nodeFromId(_conn.outputNodeId);
            let   output     = outputNode.outputFromId(_conn.outputId);

            if (!isValid(output))
            {
                const param = this.oldOutputParams.find(p => 
                       p._nodeId == _conn.outputNodeId
                    && p.id      == _conn.outputId); 

                output = param.output;

                const node = nodeFromId(_conn.outputNodeId);
                
                param ._node = node;
                output._node = node; 
            }

            console.assert(isValid(output), 'output should be found at this point');


            output.updateSavedConnectionOrder(_conn.outputOrder, +1);


            const oldConn = uiVariableConnectFromOutput(
                output,
                nodeFromId(_conn.inputNodeId), _conn.inputId,
                _conn.outputOrder);

 
            uiSaveConn(oldConn);
        }


        // at this point a request should be sent 
        // and the update received with some flag to indicate that this is that kind of an update
        // at the end of the update reconnect the connections to the real connections and save them


        this.oldConnectionData = [];
    }



    deactivateNewActiveNodes()
    {
        for (const id of this.newActiveNodeIds)
            uiMakeNodePassive(nodeFromId(id));
    
        uiDeleteObjectsAndStyles(this.newActiveNodeIds, false); 
    }



    getPrevLinkString()
    {
        return this.prevAction ? ' ' : '';
    }

    

    getNextLinkString()
    {
        return this.nextAction ? ' ' : '';
    }
}



function linkActions(prevAction, nextAction)
{
    prevAction.nextAction = nextAction;
    nextAction.prevAction = prevAction;
}


/*
    when deleting parameters, store them in a parameter trash bin
    when looking for nodes and params during undo, check that bin also
    but also when just changing values or connecting etc params could come back,
        maybe the actions themselves should store deleted params along with
        deleted connections
    this will also come into play with copy/paste/duplicating
    when performing an action, clear that bin
*/



class ActionManager
{
    actions       = [];
    redoActions   = [];
    updateActions = [];
    
    nextActionId  = 0;



    undoing       = false;
    redoing       = false;
   
    
    
    do(act, linkWithPrevious = false, linkWithNext = false, putBeforeLast = false)
    {
        // this is a fresh new action so any 
        // old redo queue is no longer relevant
        this.redoActions = [];


        act.id            = this.nextActionId++;
        act.manager       = this;
        act._linkWithNext = linkWithNext;


        this.actions.push(act);

        
        if (this.actions.length > 1)
        {
            const before = this.actions.at(-2);
            const last   = this.actions.at(-1);

            if (   linkWithPrevious
                || before._linkWithNext)
            {
                linkActions(before, last);
                before._linkWithNext = false;
            }
        }


        this.doAction(act, false);
    }



    undo()
    {
        if (isEmpty(this.actions))
            return;

            
        this.undoing = true;


        for (;;)
        {
            let last = removeLast(this.actions);
            this.redoActions.push(last);


            this.undoAction(last);


            if (   isEmpty(this.actions)
                || last.prevAction != this.actions.at(-1))
                break;
        }
    }



    redo()
    {
        if (isEmpty(this.redoActions))
            return;

            
        this.redoing = true;


        for (;;)
        {
            let last = removeLast(this.redoActions);
            this.actions.push(last);


            this.doAction(last, true);


            if (   isEmpty(this.redoActions)
                || last.nextAction != this.redoActions.at(-1))
                break;
        }
    }



    clear()
    {
        this.actions       = [];
        this.redoActions   = [];
        this.updateActions = [];
    }



    doAction(act, redo)
    {
        if (settings.logActions)
        {
            const prevLink = act.getPrevLinkString();
            const nextLink = act.getNextLinkString();

            if (redo) console.log("%cREDO %s", 'background: #ffd;    color: #b80;', prevLink + act.name + nextLink);
            else      console.log("%c%s",      'background: #e8ffe8; color: #282;', prevLink + act.name + nextLink);
        }


        const updateNodes = [];


        if (act.affectsConnections)
        {
            act.initSaveArrays();
            act.saveOldConnections();
        }


        if (!redo) 
            act.do  (updateNodes);

        else
        {
            act.redo(updateNodes);

            if (isEmpty(updateNodes))
                this.redoing = false;
        }


        if (act.affectsConnections)
            act.updateOldConnections();


        if (!act.selfUpdate)
            pushUpdate(act, updateNodes);
    }



    undoAction(act)
    {
        if (settings.logActions)
        {
            const prevLink = act.getPrevLinkString();
            const nextLink = act.getNextLinkString();

            console.log("%cUNDO %s", 'background: #fff4e8; color: #c64;', prevLink + act.name + nextLink);
        }

            
        if (act.affectsConnections)
            act.deleteNewConnections();
            
            
        const updateNodes = [];

        act.undo(updateNodes); 


        if (isEmpty(updateNodes))
            this.undoing = false;


         if (act.affectsConnections)
            act.restoreOldConnections();


        if (!act.selfUpdate)
            pushUpdate(act, updateNodes);
    }
}



const actionManager = new ActionManager();



function actionFromId(actionId)
{
    let action = actionManager.actions.find(a => a.id == actionId);

    if (!isValid(action))
        action = actionManager.redoActions.find(a => a.id == actionId);

    return action;
}


class ConnectAction
extends Action
{
    outputNodeId;
    outputId;
    outputOrder           = -1;
    outputValues          = []; // in id,value pairs, to be restored on undo
    
    inputNodeId;
    inputId;
    inputActiveNodeIds    = [];
    inputValues           = []; // in id,value pairs, to be restored on undo

    newActiveNodeIds      = [];
    
    oldOutputNodeId       = NULL;
    oldOutputId;
    oldOutputOrder        = -1;
    oldOutputActiveNodeId = NULL;
    
    backInit              = false;
   

    get outputNode()    { return nodeFromId(this.outputNodeId); }
    get output()        { return this.outputNode.outputFromId(this.outputId); }
    
    get inputNode()     { return nodeFromId(this.inputNodeId); }
    get input()         { return this.inputNode.inputFromId(this.inputId); }
    

    get oldOutputNode() { return nodeFromId(this.oldOutputNodeId); }
    get oldOutput()     { return this.oldOutputNode.outputFromId(this.oldOutputId); }



    constructor(output, input, options = {})
    {
        super(
            CONNECT_ACTION,
             'CONNECT '
            + output.node.id + '.' + output.id
            + ' ' + rightArrowChar(output.supportsTypes(LIST_TYPES)) + ' '
            + input.node.id + '.' + input.id);


        this.outputNodeId    = output.node.id;
        this.outputId        = output.id;
   
        this.inputNodeId     = input.node.id;
        this.inputId         = input.id;


        this.oldOutputNodeId = input.connected ? input.connectedOutput.node.id : NULL;
        this.oldOutputId     = input.connected ? input.connectedOutput.id      : NULL;
        this.oldOutputOrder  = input.connected ? input.connection.outputOrder  : -1;


        if (   options 
            && isValid(options.backInit))
            this.backInit = options.backInit;
    }


    
    do(updateNodes)
    {
        this.oldOutputActiveNodeId = NULL;
        this.inputActiveNodeIds    = [];


        connectAction_saveOutputActiveNodes(this);
        connectAction_saveInputActiveNodes(this);

        connectAction_saveOutputValues(this);
        connectAction_saveInputValues(this);
        
        if (this.backInit)
            connectAction_backInitOutputValue(this);

        connectAction_removeOldOutputConnection(this);
        
        connectAction_makeNewConnection(this);

        connectAction_updateOldOutput(this, updateNodes);
        connectAction_updateInputActiveNodes(this, updateNodes);

        connectAction_updateNodes(this, updateNodes);
        connectAction_cleanup(this);
    }



    undo(updateNodes)
    {
        connectAction_restoreInputValues(this);
        connectAction_restoreOutputValues(this);

        this.deactivateNewActiveNodes();
        connectAction_activateOldActiveNodes(this, updateNodes); 

        connectAction_restoreCleanup(this);
    }
}



function connectAction_backInitOutputValue(act)
{
    if (    act.output.backInit
        &&  act.input.getBackInitValue)
        act.output.backInit(act.input.getBackInitValue());
}



function connectAction_saveOutputActiveNodes(act)
{
    act.oldOutputActiveNodeId = idFromNode(getActiveFromNodeId(act.outputNodeId));
}



function connectAction_saveInputActiveNodes(act)
{
    act.inputActiveNodeIds = getActiveNodesAfterNodeId(act.inputNodeId).map(n => n.id);
}



function connectAction_saveOutputValues(act)
{
    act.outputValues = act.output.getValuesForUndo ? act.output.getValuesForUndo(act.output) : [];
}



function connectAction_saveInputValues(act)
{
    act.inputValues = act.input.getValuesForUndo ? act.input.getValuesForUndo(act.input) : [];
}



function connectAction_makeNewConnection(act)
{
    const conn = uiConnect(act.output, act.input, act.inputId);
            
    pushUnique(act.newConnectionData, conn.toDataObject());
    act.outputOrder = conn.outputOrder;

    uiSaveConn(conn);
}



function connectAction_removeOldOutputConnection(act)
{
    if (act.oldOutputNode)
        uiDeleteSavedConn(act.input.connection);
}



function connectAction_updateOldOutput(act, updateNodes)
{
    if (!act.oldOutputNode)
        return;

        
    act.oldOutput.updateSavedConnectionOrder(act.oldOutputOrder, -1);

    pushUnique(updateNodes, act.oldOutputNode);

    
    if (!getActiveFromNode(act.oldOutputNode))
    {
        uiMakeNodeActive(act.oldOutputNode);

        act.newActiveNodeIds.push(act.oldOutputNodeId);

        if (act.oldOutputActiveNodeId != NULL)
            pushUnique(updateNodes, nodeFromId(act.oldOutputActiveNodeId));
    }
}



function connectAction_updateInputActiveNodes(act, updateNodes)
{
    const inputActiveNodeIds = [...act.inputActiveNodeIds].sort((x, y) => 
        (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

    for (const id of inputActiveNodeIds)
    {
        act.newActiveNodeIds.push(id);

        const node = nodeFromId(id);

        uiMakeNodeActive(node);
        pushUnique(updateNodes, node);
    }
}



function connectAction_updateNodes(act, updateNodes)
{
    pushUnique(updateNodes, act.outputNode);
    pushUnique(updateNodes, act. inputNode);

    if (!act.outputNode.cached) 
        pushUnique(updateNodes, act.outputNode.getUncachedInputNodes());

    if (    act.oldOutputNode
        && !act.oldOutputNode.cached) 
        pushUnique(updateNodes, act.oldOutputNode.getUncachedInputNodes());
}



function connectAction_cleanup(act)
{
    const nodeIds = 
        act.oldOutputActiveNodeId != ''
        ? [act.oldOutputActiveNodeId]
        : [];

    nodeIds.push(...act.inputActiveNodeIds.filter(id => 
        !act.newActiveNodeIds.includes(id)));

    uiDeleteObjectsAndStyles(nodeIds, false);
}



// function connectAction_removeNewConnection(act)
// {
//     const input = act.inputNode.inputFromId(act.inputId);

//     uiDeleteSavedConn(input.connection);
//     uiDisconnect(input);
// }



// function connectAction_restoreOldConnection(act)
// {
//     if (act.oldOutputNodeId != NULL)
//     {
//         act.oldOutput.updateSavedConnectionOrder(act.oldOutputOrder, +1);

//         const oldConn = uiVariableConnect(
//             act.oldOutputNode, act.oldOutputId, 
//             act.inputNode,     act.inputId,
//             act.oldOutputOrder);

//         uiSaveConn(oldConn);
//     }
// }



function connectAction_restoreInputValues(act)
{
    for (const undoValue of act.inputValues)
    {
        const param = act.inputNode.params.find(p => p.id == undoValue.paramId);
        if (param) param.node.restoreParamUndoValue(undoValue);
    }
}



function connectAction_restoreOutputValues(act)
{
    for (const undoValue of act.outputValues)
    {
        const param = act.outputNode.params.find(p => p.id == undoValue.paramId);
        if (param) param.node.restoreParamUndoValue(undoValue);
    }
}



function connectAction_activateOldActiveNodes(act, updateNodes)
{
    pushUnique(updateNodes, act.outputNode);


    for (const id of act.inputActiveNodeIds)
    {
        const oldInputActiveNode = nodeFromId(id);
        
        uiMakeNodeActive(oldInputActiveNode);
        pushUnique(updateNodes, oldInputActiveNode);
    }

    
    if (    act.oldOutputActiveNodeId != NULL
        && !act.inputActiveNodeIds.includes(act.oldOutputActiveNodeId))
    {
        console.assert(act.oldOutputActiveNodeId != NULL, 'there should be an old output active node ID at this point')

        const oldOutputActiveNode = nodeFromId(act.oldOutputActiveNodeId);

        uiMakeNodeActive(oldOutputActiveNode);
        pushUnique(updateNodes, oldOutputActiveNode);
    }
}



function connectAction_restoreCleanup(act)
{
    act.oldOutputActiveNodeId = NULL;
    act.inputActiveNodeIds    = [];
}


class CreateInsertNodeAction
extends Action
{
    nodeType;
    createdNodeId;

    options;


    prevSelectedIds      = []; // currently selected nodes that are deselected as a result of creation

    oldInputActiveNodeId = NULL;


    prevConnections      = []; // [{outputNodeId, outputId, outputOrder, inputNodeId, inputId}]


    creatingButton;
    


    constructor(nodeType, creatingButton, options)
    {
        super(
            CREATE_INSERT_ACTION, 
            'CREATE/INSERT \'' + nodeType + '\'');
        
        this.nodeType       = nodeType;
        this.creatingButton = creatingButton;

        this.options        = options;
    }



    do(updateNodes)
    {
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);

        createInsertNodeAction_savePrevConnections(this);


        graphView.creatingNodes = true;

        const node = createNode(this.nodeType, this.creatingButton, this.createdId, this.options);


        const insert = 
               this.prevSelectedIds.length == 1
            && canAutoConnectNode(node);
   
            
        graph.addNode(node, !insert);
        
        this.createdNodeId = node.id;


        if (insert)
        {
            const selNode   = nodeFromId(this.prevSelectedIds[0]);
            const selOutput = selNode.headerOutputs[0];


            for (let i = selOutput.connectedInputs.length-1; i >= 0; i--)
            {
                const input = selOutput.connectedInputs[i];

                uiDeleteSavedConn(input.connection);
                uiDisconnect(input);
            }


            const inputs = node.headerInputs.filter(i => i.canConnectFrom(selNode.headerOutputs[0]));

            if (!isEmpty(inputs))
            {
                const newConn = createNodeAction_connect(this, selNode.outputs[0], node, inputs[0].id);
                graphView.autoPlaceNewNode(newConn.output, newConn.input);


                for (const _conn of this.prevConnections)
                {
                    const _output    = node.headerOutputs[0];
                    const _inputNode = nodeFromId(_conn.inputNodeId);
                    const _input     = _inputNode.inputFromId(_conn.inputId);

                    if (_input.canConnectFrom(_output))
                        createNodeAction_connect(this, _output, _inputNode, _conn.inputId, _conn.outputOrder);
                }
            }
        }

            
        graphView.lastSelectedNodes = graphView.selectedNodes;
        graphView.selectedNodes     = [node];


        if (!getActiveAfterNode(node))
            uiMakeNodeActive(node);


        pushUnique(updateNodes, node);
    }



    undo(updateNodes)
    {
        uiDeleteNodes([this.createdNodeId]);

        createNodeAction_activateOldInput(this, updateNodes);

        this.prevConnections = [];
            
        graphView.selectByIds(this.prevSelectedIds);
    }
}



function createInsertNodeAction_savePrevConnections(act)
{
    if (act.prevSelectedIds.length == 0)
        return;
        
    act.oldInputActiveNodeId = idFromNode(getActiveFromNodeId(act.prevSelectedIds[0]));

    const selNode = nodeFromId(act.prevSelectedIds[0]);
    const output  = selNode.outputs[0];

    for (const input of output.connectedInputs)
        act.prevConnections.push(input.connection.toDataObject());
}


class CreateNodeAction
extends Action
{
    nodeType;
    createdNodeId;

    options;


    node;


    prevSelectedIds      = []; // currently selected nodes that are deselected as a result of creation

    oldInputActiveNodeId = NULL;


    autoConnect;


    creatingButton;
    


    constructor(nodeType, creatingButton, options, autoConnect)
    {
        super(
            CREATE_ACTION, 
            'CREATE \'' + nodeType + '\'');

        this.nodeType       = nodeType;
        this.creatingButton = creatingButton;

        this.options        = options;

        this.autoConnect    = autoConnect;
    }



    do(updateNodes)
    {
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);


        graphView.creatingNodes = true;

        this.node = createNode(this.nodeType, this.creatingButton, this.createdId, this.options);
        

        const autoConnect = 
                this.autoConnect
            && !isEmpty(this.prevSelectedIds)
            &&  canAutoConnectNode(this.node)
            && !!this.options.autoConnect;

            
        graph.addNode(this.node, !autoConnect);

        this.createdNodeId = this.node.id;
        

        if (autoConnect)
        {
            this.oldInputActiveNodeId = idFromNode(getActiveFromNodeId(this.prevSelectedIds[0]));

            const selNode = nodeFromId(this.prevSelectedIds[0]);
            const inputs  = this.node.headerInputs.filter(i => i.canConnectFrom(selNode.headerOutputs[0]));
            
            if (!isEmpty(inputs))
            {
                const conn = createNodeAction_connect(this, selNode.outputs[0], this.node, inputs[0].id);
                graphView.autoPlaceNewNode(conn.output, conn.input);
            }
        }


        graphView.lastSelectedNodes = graphView.selectedNodes;
        graphView.selectedNodes     = [this.node];

        uiMakeNodeActive(this.node);
        pushUnique(updateNodes, this.node);
    }



    undo(updateNodes)
    {
        uiDeleteNodes([this.createdNodeId]);

        createNodeAction_activateOldInput(this, updateNodes);
        
        graphView.selectByIds(this.prevSelectedIds);
    }
}



function createNodeAction_connect(act, output, inputNode, inputId, outputOrder = -1)
{
    const conn = uiVariableConnect(
        output.node, output.id,
        inputNode,   inputId,
        outputOrder);
        
    uiSaveConn(conn);

    pushUnique(act.newConnectionData, conn.toDataObject());

    return conn;
}



function createNodeAction_activateOldInput(act, updateNodes)
{
    if (act.oldInputActiveNodeId == NULL)
        return;

    const oldInputActiveNode = nodeFromId(act.oldInputActiveNodeId);
    
    uiMakeNodeActive(oldInputActiveNode);
    pushUnique(updateNodes, oldInputActiveNode);

    act.oldInputActiveNodeId = NULL;
}


class DeleteNodesAction
extends Action
{
    nodeIds          = [];
    nodes            = [];
    nodePos          = [];
    
    prevSelectedIds  = [];

    oldActiveNodeIds = [];
    newActiveNodeIds = [];
   


    constructor(nodeIds, cut = false)
    {
        super(
            DELETE_ACTION, 
            (cut ? 'CUT ' : 'DELETE ') + nodeIds.length + ' ' + countString('node', nodeIds.length));

        this.nodeIds         = [...nodeIds];
        this.nodes           = nodeIds.map(id => nodeFromId(id));
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);
    }



    do(updateNodes)
    {
        this.oldActiveNodeIds = [];
        this.newActiveNodeIds = [];

        deleteNodesAction_saveNodePositions(this);
        deleteNodesAction_saveOldActiveNodes(this);
        
        deleteNodesAction_getUpdateNodes(this, updateNodes);
        deleteNodesAction_deleteNodes(this);

        DisconnectAction_activateNewNodes(this);

        uiSaveNodes(this.newActiveNodeIds);
    }



    undo(updateNodes)
    {
        deleteNodesAction_restoreNodes(this);
        
        this.deactivateNewActiveNodes();
        deleteNodesAction_activateOldActiveNodes(this, updateNodes);

        uiSaveNodes(
            [...this.nodeIds,
             ...this.newActiveNodeIds]);
    }
}



function deleteNodesAction_saveOldActiveNodes(act)
{
    for (const nodeId of act.nodeIds)
        pushUnique(act.oldActiveNodeIds, getActiveNodesFromNodeId(nodeId).map(n => n.id));
}



function deleteNodesAction_saveNodePositions(act)
{
    act.nodePos = [];

    for (const nodeId of act.nodeIds)
    {
        const node = nodeFromId(nodeId);

        act.nodePos.push(point(
            node.div.offsetLeft, 
            node.div.offsetTop));
    }
}



function deleteNodesAction_getUpdateNodes(act, updateNodes)
{
    for (const node of act.nodes)
    {
        const nodeInputs = node.inputs.filter(i => i.connected);
        
        for (let i = nodeInputs.length-1; i >= 0; i--)
        {
            const input       = nodeInputs[i];
            const output      = input.connectedOutput;
            const outputOrder = input.connection.outputOrder;
            
            uiDeleteSavedConn(input.connection);
            pushUnique(updateNodes, deleteNodesAction_disconnect(act, input, act.nodeIds));

            output.updateSavedConnectionOrder(outputOrder, -1);
        }


        for (const output of node.outputs)
        {
            const connectedInputs = [...output.connectedInputs];
            removeFromArrayWhere(connectedInputs, i => i.node == node);

            // connected inputs need to be sorted by input index
            connectedInputs.sort((i1, i2) => 
            {
                const node1  = i1.node;
                const node2  = i2.node;
                    
                const index1 = node1.inputs.indexOf(i1);
                const index2 = node2.inputs.indexOf(i2);
                
                if (node1.id != node2.id) return node1.id - node2.id;
                if (index1   != index2)   return index1   - index2;

                return 0;
            });


            for (const input of connectedInputs)
            {
                uiDeleteSavedConn(input.connection);
                pushUnique(updateNodes, deleteNodesAction_disconnect(act, input, act.nodeIds));
                // don't need to update order as the output is deleted
            }
        }
    }
}



function deleteNodesAction_disconnect(act, input, ignoreNodeIds = [])
{
    // console.log('deleteNodesAction_disconnect');

    const output            = input.connectedOutput;

    const updateNodes       = [];        


    const activeLeft        = getActiveBeforeNode    (input.node, [input.node]);
    const activeLeftOnly    = getActiveOnlyBeforeNode(input.node, [input.node]);
    const activeRightHeader = getActiveAfterNode     (output.node, false, [output.node]);
    const terminalsRight    = getTerminalsAfterNode  (input.node);


    uiDisconnect(input);
    
    
    if (   !activeLeftOnly
        && !activeLeft)
    {
        if (!ignoreNodeIds.includes(output.node.id))
        {
            pushUnique(act.newActiveNodeIds, output.node.id);
            pushUnique(updateNodes, output.node);
        }
    }


    if (!activeRightHeader)
    {
        const _activeLeft = getActiveBeforeNode(input.node, [input.node]);

        if (   !ignoreNodeIds.includes(input.node.id)
            && !_activeLeft)
        {
            uiMakeNodeActive(input.node);
            pushUnique(act.newActiveNodeIds, input.node.id);
            pushUnique(updateNodes, input.node);
        }
    }


    pushUnique(updateNodes, terminalsRight);

    
    return updateNodes;
}



function deleteNodesAction_deleteNodes(act)
{
    uiDeleteNodes(act.nodeIds);
    uiDeleteObjectsAndStyles(act.oldActiveNodeIds); // clean up now irrelevant objects
}



function deleteNodesAction_restoreNodes(act)
{
    // console.log('act.nodes', act.nodes);

    graphView.restoringNodes = true;

    graph.addNodes(act.nodes);

    graphView.putNodeOnTop(act.nodes.at(-1));
    graphView.selected = act.nodes;


    for (let i = 0; i < act.nodes.length; i++)
    {
        const node = act.nodes[i];
        node.id = act.nodeIds[i];

        node.setPosition(
            act.nodePos[i].x, 
            act.nodePos[i].y);

        node.updateMeasureData();
    }
}



function deleteNodesAction_activateOldActiveNodes(act, updateNodes)
{
    let oldActiveNodeIds = [...act.oldActiveNodeIds].sort((x, y) => 
        (nodeFromId(x) === nodeFromId(y)) 
        ? 0 
        : nodeFromId(y).isOrFollows(nodeFromId(x)) 
          ? -1 
          :  1);
    
    
    const oldActiveNodes = oldActiveNodeIds.map(id => nodeFromId(id));
    
    graphView.selectByIds(act.prevSelectedIds);
    uiMakeNodesActive(oldActiveNodes);

    pushUnique(updateNodes, oldActiveNodes);
}


class DisconnectAction
extends Action
{
    outputNodeId;
    outputId;
    outputOrder      = -1;
    
    inputNodeId;
    inputId;

    
    get outputNode() { return nodeFromId(this.outputNodeId); }
    get output()     { return this.outputNode.outputFromId(this.outputId); }
    
    get inputNode()  { return nodeFromId(this.inputNodeId); }
    get input()      { return this.inputNode.inputFromId(this.inputId); }
    
    
    oldActiveNodeIds = [];
    newActiveNodeIds = [];



    constructor(input)
    {
        super(
            DISCONNECT_ACTION,
             'DISCONNECT '
            + input.connectedOutput.node.id + '.' + input.connectedOutput.id
            + ' ' + rightArrowChar(input.connectedOutput.supportsTypes(LIST_TYPES)) 
            + ' ' + input.node.id + '.' + input.id);


        this.outputNodeId = input.connectedOutput.node.id;
        this.outputId     = input.connectedOutput.id;
        this.outputOrder  = input.connection.outputOrder;

        this.inputNodeId  = input.node.id;
        this.inputId      = input.id;
    }



    do(updateNodes)
    {
        this.newActiveNodeIds = [];

        this.saveOldActiveNodes();
        this.removeConnection();        

        DisconnectAction_activateNewNodes(this);
        this.updateNodes(updateNodes);

        this.cleanup();
    }
    
    
    
    undo(updateNodes)
    {
        this.deactivateNewActiveNodes();

        this.activateOldActiveNodes(updateNodes);
        pushUnique(updateNodes, this.outputNode);

        this.oldActiveNodeIds = [];
    }



    saveOldActiveNodes()
    {
        this.oldActiveNodeIds = [...getActiveNodesFromNodeId(this.inputNodeId).map(n => n.id)];

        if (!getActiveFromNode(this.outputNode, [this.inputNode]))
            this.newActiveNodeIds.push(this.outputNodeId);

        if (   !getActiveOnlyBeforeNode(this.inputNode)
            && !getActiveAfterNode     (this.inputNode))
            this.newActiveNodeIds.push(this.inputNodeId);
    }



    removeConnection()
    {
        uiDeleteSavedConn(this.input.connection);
        uiDisconnect(this.input);


        this.output.updateSavedConnectionOrder(this.outputOrder, -1);
    }



    updateNodes(updateNodes)
    {
        pushUnique(updateNodes, [this.inputNode, this.outputNode]);

        if (!this.outputNode.cached)
            pushUnique(updateNodes, this.outputNode.getUncachedInputNodes());
    }



    cleanup()
    {
        const nodeIds = [];

        nodeIds.push(this.oldActiveNodeIds.filter(id => 
            !this.newActiveNodeIds.includes(id)));

        uiDeleteObjectsAndStyles(nodeIds, false);
    }



    deactivateNewActiveNodes()
    {
        for (const id of this.newActiveNodeIds)
            uiMakeNodePassive(nodeFromId(id));

        uiDeleteObjectsAndStyles(this.newActiveNodeIds, false);
    }



    activateOldActiveNodes(updateNodes)
    {
        const oldActiveNodeIds = [...this.oldActiveNodeIds].sort((x, y) => 
            (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

        pushUnique(updateNodes, oldActiveNodeIds.map(id => nodeFromId(id)));

        for (const id of oldActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));
    }
}



function DisconnectAction_activateNewNodes(act)
{
    for (const id of act.newActiveNodeIds)
        uiMakeNodeActive(nodeFromId(id));
}


class EmptyAction
extends Action
{
    constructor()
    {
        super(EMPTY_ACTION, 'DO NOTHING');

        this.affectsConnections = false;
    }
}



class LinkExistingStyleAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    get  inputNode() { return this.node; } // dummy for ConnectAction_...
    get outputNode() { return this.node; } // dummy for ConnectAction_...

    get  input() { return this.node.paramValue. input; } // dummy for ConnectAction_...
    get output() { return this.node.paramValue.output; } // dummy for ConnectAction_...

    styleId;
    styleName;
    paints;

    prevStyleId;
    prevStyleName;
    prevPaints;

    outputValues = []; // in id,value pairs, to be restored on undo
    inputValues  = []; // in id,value pairs, to be restored on undo


    constructor(nodeId, styleId, styleName, paints)
    {
        super(
            LINK_STYLE_ACTION, 
            'LINK STYLE \'' + nodeId + '  ' + styleName + ')');
        
        this.affectsConnections = false;

        this.nodeId    = nodeId;
        this.styleId   = styleId;
        this.styleName = styleName;

        this.paints    = [...paints];
    }



    do(updateNodes)
    {
        this.prevStyleId   = this.node.linkedStyleId;
        this.prevStyleName = this.node.linkedStyleName;
        this.prevPaints    = [this.node.paramValue.value.toRgba()];
        
        connectAction_saveOutputValues(this);
        connectAction_saveInputValues(this);

        uiLinkNodeToExistingColorStyle(
            this.node,
            this.styleId,
            this.styleName,
            [...this.paints]);

        pushUnique(updateNodes, this.node);

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        connectAction_restoreInputValues(this);
        connectAction_restoreOutputValues(this);

        uiLinkNodeToExistingColorStyle(
            this.node,
            this.prevStyleId,
            this.prevStyleName,
            [...this.prevPaints]);

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);

        if (this.node.paramValue.input.connected)
            uiTriggerUndo();
    }    
}


class MakeActiveNodesAction
extends Action
{
    newActiveNodeIds = [];

    oldActiveNodeIds = [];



    constructor(activeNodeIds)
    {
        super(
            MAKE_ACTIVE_ACTION, 
            'MAKE ACTIVE ' + nodeIdArrayToString(activeNodeIds));

        this.newActiveNodeIds = [...activeNodeIds];
        this.affectsConnections = false;
    }



    do(updateNodes)
    {
        this.oldActiveNodeIds = [];

        this.newActiveNodeIds.forEach(id =>
            pushUnique(
                this.oldActiveNodeIds, 
                getActiveNodesFromNodeId(id).map(n => n.id))); 

        uiDeleteObjectsAndStyles(this.oldActiveNodeIds, false);

        const newActiveNodes = this.newActiveNodeIds.map(id => nodeFromId(id));

        uiMakeNodesActive(newActiveNodes);
        pushUnique(updateNodes, newActiveNodes);

        uiSaveNodes(filterUnique([...this.newActiveNodeIds, ...this.oldActiveNodeIds]));
    }



    undo(updateNodes)
    {
        for (const id of this.newActiveNodeIds)
            if (!this.oldActiveNodeIds.includes(id))
                uiMakeNodePassive(nodeFromId(id));

        for (const id of this.oldActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));

        pushUnique(updateNodes, this.oldActiveNodeIds.map(id => nodeFromId(id)));

        uiSaveNodes(filterUnique([...this.newActiveNodeIds, ...this.oldActiveNodeIds]));
    }
}


class PasteNodesAction
extends Action
{
    copiedNodesJson;

    pasteConnected;

    pastedNodeIds = [];
    pastedNodePos = [];

    x;
    y;

    prevSelectedNodeIds = [];

    oldActiveNodeIds    = [];



    constructor(copiedNodesJson, pasteConnected, isDuplicate = false, x = Number.NaN, y = Number.NaN)
    {
        const data = JSON.parse(copiedNodesJson);

        super(
            PASTE_ACTION,
            'PASTE ' + data.nodes.length + ' ' + countString('node', data.nodes.length));

        this.copiedNodesJson = copiedNodesJson;
        this.pasteConnected  = pasteConnected;

        this.isDuplicate     = isDuplicate;
        
        this.x               = x;
        this.y               = y;
    }



    do(updateNodes)
    {
        this.prevSelectedNodeIds = graphView.selectedNodes.map(n => n.id);


        this.oldActiveNodeIds = [];

        for (const nodeId of this.prevSelectedNodeIds)
            pushUnique(this.oldActiveNodeIds, getActiveNodesFromNodeId(nodeId).map(n => n.id));


        const [nodes, _conns] = uiPasteNodes(this.copiedNodesJson, this.pasteConnected, this.x, this.y, updateNodes);

        pushUnique(this.newConnectionData, _conns);


        const terminals = getTerminalsInNodes(nodes);

        for (const terminal of terminals)
            if (!getActiveFromNode(terminal))
                uiMakeNodeActive(terminal);


        for (const conn of _conns)
        {
            if (   this.pasteConnected
                ||    nodes.find(n => n.id == conn.outputNodeId)
                   && nodes.find(n => n.id == conn.inputNodeId ))
                uiSaveConnection(
                    conn.outputNodeId, conn.outputId, conn.outputOrder,
                    conn.inputNodeId,  conn.inputId,
                    formatConnJson(
                        '', 
                        HTAB,
                        conn.outputNodeId,
                        conn.outputId,
                        conn.outputOrder,
                        conn.inputNodeId,
                        conn.inputId,
                        boolToString(
                            nodeFromId(conn.outputNodeId)
                            .outputFromId(conn.outputId)
                            .supportsTypes(LIST_TYPES))));
        }


        this.pastedNodeIds = nodes.map(n => n.id);
        this.pastedNodePos = nodes.map(n => point(n.div.offsetLeft, n.div.offsetTop));


        this.notify(nodes, this.isDuplicate, this.pasteConnected && !isEmpty(_conns));
    }



    undo(updateNodes)
    {
        uiDeleteNodes(this.pastedNodeIds);
        
        pasteOffset.x -= pasteOffsetDelta.x;
        pasteOffset.y -= pasteOffsetDelta.y;

        graphView.selectedNodes = graph.nodes.filter(n => this.prevSelectedNodeIds.includes(n.id));


        let oldActiveNodeIds = [...this.oldActiveNodeIds];
        oldActiveNodeIds.sort((x, y) => (nodeFromId(x) === nodeFromId(y)) ? 0 : nodeFromId(y).isOrFollows(nodeFromId(x)) ? -1 : 1);

        for (const id of oldActiveNodeIds)
            uiMakeNodeActive(nodeFromId(id));
    }



    notify(nodes, isDuplicate, pasteConnected)
    {
        let action = isDuplicate ? 'Duplicated' : 'Pasted';

        if (pasteConnected)
            action += ' & connected';

        uiNotify(
            action + ' ' + nodes.length + ' ' + countString('node', nodes.length), 
            {delay: 2500});
    }
}


class ReconnectAction
extends Action
{
    outputNodeId;
    outputId;
    outputOrder            = -1;
    outputValues           = [];
    
    prevInputNodeId        = NULL;
    prevInputId;
    prevInputOutputOrder   = -1; // output order of previous connection
    prevInputActiveNodeIds = [];
    prevInputValues        = []; // in id,value pairs, to be restored on undo

    inputNodeId;
    inputId;
    inputActiveNodeIds     = [];
    inputValues            = []; // in id,value pairs, to be restored on undo
    
    inputIsNew             = false;

    newActiveNodeIds       = [];
        
    oldOutputNodeId        = NULL;
    oldOutputId;
    oldOutputOrder;
    oldOutputActiveNodeId  = NULL;

    backInit               = false;

    

    
    get outputNode()    { return nodeFromId(this.outputNodeId); }
    get output()        { return this.outputNode.outputs.find(o => o.id == this.outputId); }

    get prevInputNode() { return nodeFromId(this.prevInputNodeId); }
    get prevInput()     { return this.prevInputNode.inputFromId(this.prevInputId); }
    
    get inputNode()     { return nodeFromId(this.inputNodeId); }
    get input()         { return this.inputNode.inputFromId(this.inputId); }


    get oldOutputNode() { return nodeFromId(this.oldOutputNodeId); }
    get oldOutput()     { return this.oldOutputNode.outputFromId(this.oldOutputId); }
    


    constructor(output, prevInput, input, options = {})
    {
        super(
            RECONNECT_ACTION,
             'RECONNECT '
            + output.node.id + '.' + output.id
            + ' (' + leftArrowChar(prevInput.supportsTypes(LIST_TYPES)) + ' '
            + prevInput.node.id + '.' + prevInput.id
            + ') ' + rightArrowChar(output.supportsTypes(LIST_TYPES)) + ' '
            + input.node.id + '.' + input.id);


        this.outputNodeId         = output.node.id;
        this.outputId             = output.id;
        
        this.prevInputNodeId      = prevInput.node.id;
        this.prevInputId          = prevInput.id;
        this.prevInputOutputOrder = this.prevInput.connection.outputOrder;

        this.inputNodeId          = input.node.id;
        this.inputId              = input.id;
        
        this.oldOutputNodeId      = input.connected ? input.connectedOutput.node.id : NULL;
        this.oldOutputId          = input.connected ? input.connectedOutput.id      : NULL;
        this.oldOutputOrder       = input.connected ? input.connection.outputOrder  : -1;

        this.inputIsNew           = input.isNew;
        

        if (   options 
            && isValid(options.backInit))
            this.backInit = options.backInit;
    }



    do(updateNodes)
    {
        this.newActiveNodeIds = [];

        connectAction_saveOutputActiveNodes(this);
        connectAction_saveInputActiveNodes(this);

        connectAction_saveOutputValues(this);
        connectAction_saveInputValues(this);

        this.savePrevInputActiveNodes();

        if (this.backInit)
            connectAction_backInitOutputValue(this);

        this.removePrevInputConnection(updateNodes);
        connectAction_removeOldOutputConnection(this);

        connectAction_makeNewConnection(this);

        connectAction_updateOldOutput(this, updateNodes);
        connectAction_updateInputActiveNodes(this, updateNodes);

        connectAction_updateNodes(this, updateNodes);
        connectAction_cleanup(this);
    }



    undo(updateNodes)
    {
        connectAction_restoreInputValues(this);
        this.restorePrevInputValues();

        connectAction_restoreOutputValues(this);
        
        this.deactivateNewActiveNodes();
        connectAction_activateOldActiveNodes(this, updateNodes); 

        connectAction_restoreCleanup(this);
    }



    savePrevInputActiveNodes()
    {
        this.prevInputActiveNodeIds = getActiveNodesAfterNodeId(this.prevInputNodeId).map(n => n.id);
    }
    
    
    
    removePrevInputConnection(updateNodes)
    {
        uiDeleteSavedConn(this.prevInput.connection);
        uiDisconnect(this.prevInput);//, this.inputIsNew);

        pushUnique(updateNodes, this.prevInput.node);
    }
    
    
    
    restorePrevInputValues()
    {
        for (const param of this.prevInputValues)
        {
            this.prevInputNode.params[this.prevInputNode.params.findIndex(p => p.id == param[0])]
                .setValue(param[1], true, true, false);
        }
    }
    
    
    
    restorePrevConnection()
    {
        this.output.updateSavedConnectionOrder(this.prevInputOutputOrder, +1);
    
        const prevConn = uiVariableConnect(
            this.outputNode,    this.outputId, 
            this.prevInputNode, this.prevInputId,
            this.prevInputOutputOrder);
    
        uiSaveConn(prevConn);
    }}


class RemoveNodesAction
extends Action
{
    nodeIds            = [];
    nodes              = [];
    nodePos            = [];
    
    prevSelectedIds    = [];
    
    oldActiveNodeIds   = [];
    newActiveNodeIds   = [];
    
    clusterActiveLeft  = [];
    clusterActiveRight = [];
    


    constructor(nodeIds)
    {
        super(
            REMOVE_ACTION,
            'REMOVE ' + nodeIds.length + ' ' + countString('node', nodeIds.length));

        this.nodeIds         = [...nodeIds];
        this.nodes           = nodeIds.map(id => nodeFromId(id));
        this.prevSelectedIds = graphView.selectedNodes.map(n => n.id);
    }



    do(updateNodes)
    {
        this.oldActiveNodeIds = [];
        this.newActiveNodeIds = [];

        deleteNodesAction_saveNodePositions(this);
        deleteNodesAction_saveOldActiveNodes(this);

        this.prepareNewReconnections();

        deleteNodesAction_getUpdateNodes(this, updateNodes);
        deleteNodesAction_deleteNodes(this);

        removeNodesAction_makeNewConnections(this);

        uiSaveNodes(this.newActiveNodeIds);
    }



    undo(updateNodes)
    {
        deleteNodesAction_restoreNodes(this);
        
        this.deactivateNewActiveNodes();
        deleteNodesAction_activateOldActiveNodes(this, updateNodes);

        uiSaveNodes([...this.nodeIds, ...this.newActiveNodeIds]);
    }



    addOldConnection(conn)
    {
        if (!this.oldConnectionData.find(c => 
                   c.outputNodeId == conn.output.node.id
                && c.outputId     == conn.output.id
                && c.outputOrder  == conn.outputOrder
                && c. inputNodeId == conn. input.node.id
                && c. inputId     == conn. input.id))
            this.oldConnectionData.push(conn.toDataObject());
    }



    prepareNewReconnections()
    {
        const clusters = findConnectedClusters(this.nodeIds.map(n => nodeFromId(n)));

        
        for (const cluster of clusters)
        {
            const first = cluster.at(0);
            const last  = cluster.at(-1);

            if (   first.headerInputs .length == 1
                &&  last.headerOutputs.length == 1
                && first.inputs [0].connected
                &&  last.outputs[0].connected)
            {
                const input  = first.inputs [0];
                const output =  last.outputs[0];

                for (const connectedInput of output.connectedInputs)
                {
                    if (input.connectedOutput.canConnectTo(connectedInput))
                        this.newConnectionData.push(connDataObject(input.connectedOutput, connectedInput));
                }
            }
        }


        this.clusterActiveLeft  = [];
        this.clusterActiveRight = [];

        for (const cluster of clusters)
        {
            this.clusterActiveLeft .push(getActiveBeforeNode(cluster.at( 0),        [cluster.at( 0)]));
            this.clusterActiveRight.push(getActiveAfterNode (cluster.at(-1), false, [cluster.at(-1)]));
        }
    }



    disconnect(input, ignoreNodeIds = [])
    {
        uiDisconnect(input);
        return [input.node];
    }
}



function removeNodesAction_makeNewConnections(act)
{
    for (let i = 0; i < act.newConnectionData.length; i++)
    {
        const _conn = act.newConnectionData[i];
        
        const conn = uiVariableConnect(
             nodeFromId(_conn.outputNodeId), _conn.outputId, 
             nodeFromId(_conn. inputNodeId), _conn. inputId,
            _conn.outputOrder);

        uiSaveConn(conn);


             if (act.clusterActiveLeft [i]) pushUpdate(act, [act.clusterActiveLeft [i]]);
        else if (act.clusterActiveRight[i]) pushUpdate(act, [act.clusterActiveRight[i]]);
        else                                uiMakeNodeActive(nodeFromId(_conn.inputNodeId));
    }
}


class RenameNodeAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    oldName;
    newName;



    constructor(nodeId, newName)
    {
        super(
            RENAME_ACTION,
            'RENAME \'' + nodeId + '\' to \'' + newName + '\'');

        this.affectsConnections = false;

        this.nodeId  = nodeId;
        this.newName = newName;
    }



    do(updateNodes)
    {
        this.oldName = this.node.name;

        this.node.setName(this.newName, {updateNodes: updateNodes});
        this.node.renamed = true;

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        this.node.setName(this.oldName, {updateNodes: updateNodes});
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    redo(updateNodes)
    {
        this.node.setName(this.newName, {updateNodes: updateNodes});
        this.node.updateNode();
        
        uiSaveNodes([this.nodeId]);
    }
}


class ReorderInputConnectionsAction
extends Action
{
    nodeId;

    oldInputId;
    newInputId;
 


    constructor(nodeId, oldInputId, newInputId)
    {
        super(
            REORDER_CONNECTIONS_ACTION,
              'REORDER CONNECTIONS ' + nodeFromId(nodeId).id 
            + '.' + oldInputId
            + ' to .' + newInputId);

        this.nodeId     = nodeId;

        this.oldInputId = oldInputId;
        this.newInputId = newInputId;
    }



    do(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        this.swapConnections();
        
        uiSaveNodes([this.nodeId]);

        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    undo(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        this.swapConnections();

        uiSaveNodes([this.nodeId]);
        
        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    swapConnections()
    {
        const node = nodeFromId(this.nodeId);

        const oldInput = node.inputFromId(this.oldInputId);
        const newInput = node.inputFromId(this.newInputId);

        const oldConn  = oldInput.connection;
        const newConn  = newInput.connection;

        const oldOutputInputIndex = oldConn.output.connectedInputs.indexOf(oldInput);
        const newOutputInputIndex = newConn.output.connectedInputs.indexOf(newInput);


        const tempInput = newConn.input;
        newConn.input = oldConn.input;
        oldConn.input = tempInput;

        const tempOrder = newConn.outputOrder;
        newConn.outputOrder = oldConn.outputOrder;
        oldConn.outputOrder = tempOrder;
        
        
        oldConn.input._connectedOutput = oldConn.output;
        newConn.input._connectedOutput = newConn.output;

        oldConn.input.connection = oldConn;
        newConn.input.connection = newConn;

        oldConn.output.connectedInputs.splice(oldOutputInputIndex, 1, oldConn.input);
        newConn.output.connectedInputs.splice(newOutputInputIndex, 1, newConn.input);
    }



    saveInputConnections()
    {
        uiDeleteSavedConnectionsToNodeId(this.nodeId);
        
        const node = nodeFromId(this.nodeId);

        for (const input of node.inputs.filter(i => i.connected))
            uiSaveConn(input.connection);
    }
}


class ReorderInputsAction
extends Action
{
    nodeId;

    oldIndex;
    newIndex;
 


    constructor(nodeId, oldIndex, newIndex)
    {
        super(
            REORDER_INPUTS_ACTION,
              'REORDER INPUTS ' + nodeFromId(nodeId).id 
            + '.' + oldIndex
            + ' to .' + newIndex);

        this.nodeId   = nodeId;
        this.oldIndex = oldIndex;
        this.newIndex = newIndex;
    }



    do(updateNodes)
    {
        // .. already done

        this.saveInputConnections();
        
        pushUnique(updateNodes, nodeFromId(this.nodeId));
    }



    undo(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        moveInArray(node.inputs, this.newIndex, this.oldIndex);
        uiSaveNodes([this.nodeId]);
        
        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    redo(updateNodes)
    {
        const node = nodeFromId(this.nodeId);

        moveInArray(node.inputs, this.oldIndex, this.newIndex);
        uiSaveNodes([this.nodeId]);

        this.saveInputConnections();

        pushUnique(updateNodes, node);
    }



    saveInputConnections()
    {
        uiDeleteSavedConnectionsToNodeId(this.nodeId);
        
        const node = nodeFromId(this.nodeId);

        for (const input of node.inputs.filter(i => i.connected))
            uiSaveConn(input.connection);
    }
}


class SelectMoveNodesAction
extends Action
{
    newSelectedIds  = [];
    prevSelectedIds = [];

    shiftPressed;

    fromPos;
    toPos;

    from;
    to;



    constructor(prevSelectedIds, newSelectedIds, fromPos, toPos, shiftPressed)
    {
        super(
            SELECT_MOVE_ACTION,
              'SELECT MOVE ' + newSelectedIds.length 
            + ' ' + countString('node', newSelectedIds.length));

        this.affectsConnections = false;


        this.prevSelectedIds    = [...prevSelectedIds];
        this.newSelectedIds     = [...newSelectedIds];
             
        this.shiftPressed       = shiftPressed;
   
        this.fromPos            = fromPos;
        this.toPos              = toPos;

                
        const dx = this.toPos.x - this.fromPos.x;
        const dy = this.toPos.y - this.fromPos.y;


        this.from = []; // these hold tuples
        this.to   = []; // [id, pos]

        for (const id of this.getMovedIds())
        {
            const node = nodeFromId(id);

            this.from.push([id, point(node.slx,      node.sly     )]);
            this.to  .push([id, point(node.slx + dx, node.sly + dy)]);
        }
    }



    getMovedIds()
    {
        const movedIds = [];

        if (this.shiftPressed)
            movedIds.push(...this.prevSelectedIds);
        
        movedIds.push(...this.newSelectedIds);

        return movedIds;
    }


    
    do(updateNodes)
    {
        const movedIds   = [...this.getMovedIds()];
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (let i = 0; i < movedNodes.length; i++)
        {
            const p = this.to.find(t => t[0] == movedNodes[i].id)[1];
            movedNodes[i].setPosition(p.x, p.y);
        }

        for (const node of movedNodes)
        {
            node.updateMeasureData();
            node.updateNode();
        }


        uiSaveNodes(movedIds);
    }



    undo(updateNodes)
    {
        const movedIds   = [...this.getMovedIds()];
        const movedNodes = graph.nodes.filter(n => movedIds.includes(n.id));

        for (let i = 0; i < movedNodes.length; i++)
        {
            const p = this.from.find(t => t[0] == movedNodes[i].id)[1];
            movedNodes[i].setPosition(p.x, p.y);
        }

        for (const node of movedNodes)
            node.updateNode();
            
        graphView.selectByIds(this.prevSelectedIds);

        uiSaveNodes(movedIds);
    }



    redo(updateNodes)
    {
        this.do(updateNodes);

        graphView.selectByIds(this.getMovedIds());
    }
}



class SelectNodesAction
extends Action
{
    selectedIds     = [];
    prevSelectedIds = [];



    constructor(selectedIds, prevSelectedIds)
    {
        super(
            SELECT_ACTION,
              'SELECT ' + selectedIds.length 
            + ' ' + countString('node', selectedIds.length));

        this.affectsConnections = false;

        this.selectedIds        = [...selectedIds];
        this.prevSelectedIds    = [...prevSelectedIds];
    }



    do(updateNodes)
    {
        // this happens in the UI
        updateComments(this.prevSelectedIds);
    }



    undo(updateNodes)
    {
        graphView.selectByIds(this.prevSelectedIds);
        updateComments(this.selectedIds);
    }



    redo(updateNodes)
    {
        graphView.selectByIds(this.selectedIds);

        updateComments(this.selectedIds);
        updateComments(this.prevSelectedIds);
    }
}



function updateComments(nodeIds)
{
    nodeIds
        .map(id => nodeFromId(id))
        .filter(n => n.type == COMMENT)
        .forEach(n => n.updateNode());
}


class SetCurrentGraphAction
extends Action
{
    graph;
    oldGraph;



    constructor()
    {
        const graphName =
            graph.parentNodeGroup
            ? (settings.showNodeId ? graph.parentNodeGroup.id : graph.parentNodeGroup.name)
            : '';

        super(
            SET_CURRENT_GRAPH_ACTION,
            'SET CURRENT GRAPH TO \'' + graphName + '\'');

        this.affectsConnections = false;

        this.oldGraph = currentGraph;
    }



    do(updateNodes)
    {
        setCurrentGraph(this.graph);
    }



    undo(updateNodes)
    {
        setCurrentGraph(this.oldGraph);
    }
}


class SetNodeRectAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    oldRect;
    newRect;



    constructor(nodeId, oldRect, newRect)
    {
        super(
            SET_NODE_RECT_ACTION,
           'SET NODE ' + nodeId + ' RECT to \'' + newRect.toString() + '\'');

        this.affectsConnections = false;

        this.nodeId  = nodeId;

        this.oldRect = Rect.fromTypical(oldRect);
        this.newRect = Rect.fromTypical(newRect);
    }



    do(updateNodes)
    {
        // this.node.setRect( // already done
        //     this.newRect.x,
        //     this.newRect.y,
        //     this.newRect.w,
        //     this.newRect.h);

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        this.node.setRect(
            this.oldRect.x,
            this.oldRect.y,
            this.oldRect.w,
            this.oldRect.h);

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    redo(updateNodes)
    {
        this.node.setRect(
            this.newRect.x,
            this.newRect.y,
            this.newRect.w,
            this.newRect.h);

        this.node.updateNode();
        
        uiSaveNodes([this.nodeId]);
    }
}


class SetParamSettingAction
extends Action
{
    nodeId;
    paramId;


    get param() 
    { 
        return nodeFromId(this.nodeId).params
               .find(p => p.id == this.paramId); 
    } 

    get node() { return this.param.node; } 


    setting;

    oldValue;
    newValue;



    constructor(param, setting, value)
    {
        super(
            SET_PARAM_SETTING_ACTION,
            'SET PARAM SETTING ' + param.node.id + '.' + param.id + '[' + setting + '] = ' + value);

        this.nodeId     = param.node.id;
        this.paramId    = param.id;
  
        this.setting    = setting;
        this.newValue   = value;

        this.selfUpdate = true;
    }



    do(updateNodes)
    {
        switch (this.setting)
        {
            case 'align': 
                this.oldValue = this.param.controls[0].getTextAlignment();
                break;
        }


        this.name = 
             'SET PARAM SETTING ' 
            + this.param.node.id 
            + '.' + this.param.id 
            + '[' + this.setting + ']'
            + ' = ' + this.newValue
            + ' (old value = ' + this.oldValue + ')';


        this.param.updateSetting(this.setting, this.newValue);
        this.node.updateNode();
        
        uiSaveNodes([this.nodeId]);

        //pushUpdateFromParam(this, [this.param.node], this.param);
    }



    undo(updateNodes)
    {
        this.param.updateSetting(this.setting, this.oldValue);
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    redo(updateNodes)
    {
        this.param.updateSetting(this.setting, this.newValue);
        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
   }
}


class SetParamValueAction
extends Action
{
    nodeId;
    paramId;


    get param() 
    { 
        return nodeFromId(this.nodeId).params
               .find(p => p.id == this.paramId); 
    } 


    oldValue; // decimal
    newValue; // decimal



    constructor(param, value)
    {
        super(
            SET_PARAM_VALUE_ACTION,
            'SET PARAM VALUE ' + param.node.id + '.' + param.id + ' = ' + value.toDisplayString());

        this.nodeId     = param.node.id;
        this.paramId    = param.id;
  
        this.newValue   = value;

        this.selfUpdate = true;
    }



    do(updateNodes)
    {
        this.oldValue = this.param.oldValue;

        this.name = 
              'SET PARAM VALUE ' 
            + this.param.node.id 
            + '.' + this.param.id 
            + ' = ' + this.newValue.toDisplayString() 
            + ' (old value = ' + (this.oldValue ? this.oldValue.toDisplayString() : '') + ')';

        pushUpdateFromParam(this, [this.param.node], this.param);
    }



    undo(updateNodes)
    {
        // if (this.oldValue.type == TEXT_VALUE)
        // {
        //     console.log('this.param.controls[0] =', this.param.controls[0]);
        //     this.param.controls[0].textbox.managing = true;
        // }

        this.param.setValue(this.oldValue, false, true);
        pushUpdateFromParam(this, [this.param.node], this.param);
    }



    redo(updateNodes)
    {
        this.param.setValue(this.newValue);
        pushUpdateFromParam(this, [this.param.node], this.param);
    }
}


class ToggleDisableNodesAction
extends Action
{
    selectedIds = [];



    constructor(selectedIds)
    {
        super(
            TOGGLE_DISABLE_ACTION,
              'TOGGLE DISABLE ' + selectedIds.length 
            + ' ' + countString('node', selectedIds.length));

        this.selectedIds = [...selectedIds];
    }



    do(updateNodes)
    {
        const nodes = this.selectedIds.map(id => nodeFromId(id));

        uiToggleDisableNodes(nodes);
        uiSaveNodes(nodes.map(n => n.id));

        pushUnique(updateNodes, nodes);
    }



    undo(updateNodes)
    {
        this.do(updateNodes);
    }
}


class ToggleOperatorSymbolAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    showOnlySymbol;



    constructor(nodeId, showOnlySymbol)
    {
        super(
            TOGGLE_SYMBOL_ACTION,
            'TOGGLE MATH SYMBOL ' + boolToString(showOnlySymbol));
        
        this.affectsConnections = false;

        this.nodeId         = nodeId;
        this.showOnlySymbol = showOnlySymbol;
    }



    do(updateNodes)
    {
        this.node._showOnlySymbol = this.showOnlySymbol;

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        this.node._showOnlySymbol = !this.showOnlySymbol;

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }    
}


class ToggleParamHeaderAction
extends Action
{
    nodeId;
    get node() { return nodeFromId(this.nodeId) } 

    prevParamType;
    paramType;



    constructor(nodeId, paramType)
    {
        super(
            TOGGLE_PARAM_HEADER_ACTION,
            'TOGGLE PARAM HEADER ' + boolToString(paramType));
        
        this.affectsConnections = false;

        this.nodeId    = nodeId;
        this.paramType = paramType;
    }



    do(updateNodes)
    {
        this.prevParamType  = this.paramType;
        this.node.paramType = this.paramType;

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }



    undo(updateNodes)
    {
        this.node.paramType = this.prevParamType;

        this.node.updateNode();

        uiSaveNodes([this.nodeId]);
    }    
}


function initAboutDialog()
{
    // initCheckbox(chkAboutHideWhatsNew, 'Show what\'s new at startup', settings.showWhatsNew);
    // chkAboutHideWhatsNew.addEventListener('change', () => uiSetLocalData('showWhatsNew', chkAboutHideWhatsNew.checked ? (generatorVersion-1) : (generatorVersion)));

    aboutBack.addEventListener('pointerdown', e => { e.preventDefault(); });

    aboutVersion.innerHTML = 'Generator&nbsp;&hairsp;version&nbsp;&thinsp;' + generatorVersion;
}



function showAboutDialog()
{
    aboutBack  .style.display = 'block';
    aboutDialog.style.display = 'block';

    dialogShown = true;
}



function hideAboutDialog()
{
    aboutBack  .style.display = 'none';
    aboutDialog.style.display = 'none';

    dialogShown = false;
}



aboutClose.addEventListener('pointerdown', e => e.stopPropagation());
aboutBack.addEventListener('pointerdown', () => { hideAboutDialog(); });



aboutBack.addEventListener('pointerdown', () =>
{
    hideAboutDialog();
});



const colFigmaBlue         = '#0c8ce9';



const rgbActiveFlowLight   = hex2rgb('#969696');
const rgbFlowLight         = hex2rgb('#D1D1D1');
  
const rgbActiveNumberLight = hex2rgb('#369FE5');
const rgbNumberLight       = hex2rgb('#B8D4F2');

const rgbActiveGroupLight  = hex2rgb('#3AAB5A');
const rgbGroupLight        = hex2rgb('#B9D9BF');

const rgbActiveShapeLight  = hex2rgb('#E1765F');
const rgbShapeLight        = hex2rgb('#F0C7C0');

const rgbActiveTextLight   = hex2rgb('#F6C953');
const rgbTextLight         = hex2rgb('#FBE6BE');


const rgbActiveFlowDark    = hex2rgb('#8B8B8B');
const rgbFlowDark          = hex2rgb('#4D4D4D');

const rgbActiveNumberDark  = hex2rgb('#1785CE');
const rgbNumberDark        = hex2rgb('#2B4E6E');

const rgbActiveGroupDark   = hex2rgb('#33AD55');
const rgbGroupDark         = hex2rgb('#365E3F');

const rgbActiveShapeDark   = hex2rgb('#E1765F');
const rgbShapeDark         = hex2rgb('#734B43');

const rgbActiveTextDark    = hex2rgb('#F4C855');
const rgbTextDark          = hex2rgb('#7E6E48');


const rgbColor             = hex2rgb('#c38fc5');   
const rgbActiveColor       = hex2rgb('#df2ae2');



const rgbNoColorLight      = [0.95, 0.95, 0.95];
const rgbNoColorDark       = [0.3,  0.3,  0.3 ];

const rgbaNoColorTextLight = [0, 0, 0, 0.6];
const rgbaNoColorTextDark  = [1, 1, 1, 0.4];



const rgbDefaultFill       = [0xD9, 0xD9, 0xD9];


var rgbDocumentBody;



function initThemeColors()
{
    rgbDocumentBody = computedStyle2rgba(document.body, 'background-color');

    darkMode = isDarkMode();
}


const panCursor = 
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3Ln'
    + 'czLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMzJweCIgaGVpZ2h0PSIzMnB4Ij48aW1hZ2UgeGxpbms6aHJlZj0i'
    + 'ZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFFQUFBQUJBQ0FZQUFBQ3FhWE'
    + 'hlQUFBSHFrbEVRVlI0WHUyYWY4aVY1Um5IUDlhbXpjM0tkRERkSDJ2WitpUEQvdEJTSEtLQ1EyVmJaTWdnbDAx'
    + 'TENUUmJ0Q1hLSFA1Z1N1UWZNZGtmZ3lrMkZLTWtjU0wrV0RKbExOU2xwaWtSaEdRU1VTMU4zV2JiYW5OOG50M1'
    + 'h1N3ZIOXpYUE9jOXp3dDczZ3B2M25QT2U4enpQOWIyLzE4Lzc2a1UzbDE3ZFhIOTZBT2hoUURkSG9NY0V1amtC'
    + 'ZXB4Z2p3bTAwUVFFTzFiYzlnSVFxNDJQOHY5YnRZTUIzdU9xdEs0R0JnRTNBdThBYndML1R1cy9nS3V0VWpjQV'
    + 'hsK2x2d0I4RVZnRXpNODBmQkZZRFR3UGZGd0NvaTNNcUJzQWxWZnhQc0R2Z0xFcVAyVElFSTRmUDU3djlGVGdq'
    + 'OEJOd0YrQk54SWJaRWV0ektnRGdMQnphYS95MXdEZkIzNnJ4cHMyYldMS2xDbWNPSEdDdVhQbnNtM2JOai9lQl'
    + 'h3TnVDMmhjaEJZRE93QlBrcnNxTVU4cWdTZ2JPdlMzcDN2Qzh3R2ZqNXk1RWoyN2R2WHNmT3JWNjltOW16LzFh'
    + 'VThEdndhK0ZkZElGUUZRRGc1ZDF6RjF3SERnZXVBVjREWGdBZVhMRm5DNHNWdTdQOWt6NTQ5akI4L3ZuanQ1K1'
    + 'BHamFOZnYzNXMzYm9Wdnd1OEM0d0FQZ0QrbVh5RXZxRXlxUUtBY0hTOTA0NmY3dXJwTGdYQXNXUEhHRHAwYU1k'
    + 'UGUvWHFlTFFKd0NIZ2ZES0hTazJoQ2dEQzBYMEplQWFZcUJaYnRteGgrUERoTEZpd2dIWHJKQVRGcm5iRmdBc1'
    + 'hQcm14TWtPR0FQY0RMd0IvU3l3d1dsVEdnbFlCOFBkU1h1Vy9BdndaK1BxcVZhdVlOMjlleDI0T0dEQ0EwNmRQ'
    + 'Tnd2QVE4bEpHaDFrZ2Y1QUZnaEN5MnhvRlFCdFgrcC9PZGw3RWR2S3U3bDA2ZEpDK1NZWjhDandUV0JrOGlWUE'
    + 'F5K1Y4b2FtR1ZFRkFJYTVmc0FOd0tzMUFOQ1pTM2tTK0VVV0hjd1htcEpXQWREK3BmKzF3SURrOGF0bUFLTkhq'
    + 'MmI1OHVYSXBPUVhWRlpmc3pmNUJYT0ZwbGpRS2dCaC80YTdnY0RMVlROZzJMQmhIRGx5cEdOM1I0MGF4Zjc5Kz'
    + 'MwdkEzNlovRUtFeUlaWlVBVUFKam9CZ09HcVN3WVlBVko4dnlnUDZDb0s3TjY5dThnUFFzS2ZKRDh3SmFYT0g2'
    + 'WVErWmtDOEZYQUZMWmRBSGl2SHdCbmdMOG5mOUN3R1ZURmdPdVRDYlFUQU0zdFhzREV5eHpoSDgzNGdTc1pnTV'
    + 'BBRHhNQTV4SUFEZWNGVnpJQWVzYjdnRk9BQU9nSGFnY2dBSXUvRmorR3dYQ0NCenJ6QVRvK25WZkZUckN0QU9T'
    + 'bGJsUis2aHIxZmlSQ3BzS2RPa0hqOTlpeFl5K0tBZ0tqNk8xektWZUpuVVFCQVpoZVlrRERDZEhsbUVBb2JNen'
    + 'ZiMDBEV0tHNTY2YSttNjE5QUIzaG56b0RvT0hZZElrZlpHR3dMUUJFc2VOT1c2ditDcml6aytjek0xbWJtaGNY'
    + 'TWVCS0JzQlUxMkpITy84TmNJL0tyRnk1a2hFalJuRDQ4T0hDcnMrZDB3Y1ZEUXM3UUxVQ0VQNEVxSjBCN3I3S1'
    + 'creVlkeityY3VYR3hjR0RCMW0wYUJFN2R1em8yT2h5VmxjbEE5b0pnTHZ2amxycVBnQThZVXBhZGxhaDNMSmx5'
    + 'enFhSFo4WEFLTFEwY1BQQVg1V0xrektPN3RyMXk3bXo1L1BvVU5GU1ZDTHRKTUJPajRMSFV2ZE85TGhSY0dBdk'
    + 'RncGEzbisvSG42OXZWbjljaG5CWUNsN25KZ3NtcHQzNzZkU1pNbTFhUGhwMXkxblFEa0ptQ3o0MmJnS2VBYlB1'
    + 'UEdqUnVaT3RVRG5mWktPd0hJbmFCSmp1V3VKemNMMCtFbWE5ZXVaY2FNR1cxRm9BUkExQUkyVEswRktzMEVEWU'
    + '9SNjBlcWE5L3ZGdUNud0xmVXZOd0JyaHVOVWlhWUYwT1d3NVVDb0M2UkNJVXpOQlYyYVFZL0FXNzFTeXRXckdE'
    + 'aFFvbFJ2OHlhTllzMWE5WjRvejhBUDY2N0dveFVPRnJmTWtGekVBUVBNMlhDN1Q2TkFBaEUzYUx6M2JsenA3ZD'
    + 'VEbGlXQUFnVHFLVWN0aGpTSVFxQ1RBZ1FCRUxuS0FpR3llSXdSSk9vVXdZT0hNaXBVN1lBaXFKTUVPd0lDWUFt'
    + 'VUFzQTNxd3pFS3dHZ3cyUEFhUDlvazVSNTFpSDdOMjd0MmlSSi9rZThIbzZPQlVBYTVGYWU0S0NFSkhCNGtnbU'
    + 'NJTG1JQkNQeEFDRTRkRXdXYlZNbno2ZDlldlhlMW1yVCszL0wxbFRWQUFhbHN2cEIrUVhEUkRDSER3UHpFRXda'
    + 'YlpYd01TSkV6OVJJRFg4WktVZmJONjh1UmlzU0xJQStEM3dQbkEyaFVBUFJ4cVdSZ0h3QnJsakRDYVlMa2VFZU'
    + 'JENHJsLzBkUGpBZ2FKTDFwS2NPWE9HL3YyOWZDRk9rM2dvOGw2cEk5eHdDQXhsbW5tNHZGR2lZd3dtaEUvNEVY'
    + 'QjNGVXpJaHlpQXQ0RlppZnA2UW5lLzZUT0JWZ0NJMytZTmt6SUltc0xEZm5ITW1ERkZtSnc4dVNnbExrdk9uaj'
    + 'NMaGcwYm1ETkhxeXJFM244a1BpcnYxRWljQnpnejBKUTBZd0w1amZMcGtKZ1IwQnhrZ2tzUXpKWDlqSmt6WnpK'
    + 'dDJqUW1UQ2pjUktkeTlPalJRbkhYeVpNbjR6c2VoeitSS0cvWVUvbUkvZHArdytFdkx0d3FBRGtUSW0yV0NTcX'
    + 'NjM1E1K25ZWDhKMjRhZS9ldlJrOGVEQ0RCZzJpVDUraWk0WjI3dVNZZnpQeGplMWlSMHg4cmVMU1BzNEJtajRV'
    + 'clJLQU1naTIwT3dpR1NZRndpVW8xZzdmVGtOUGd6K0ZyOGRTejg4dTgxdHB0MVhjSmUxalVxVGxjWmtxR0pDRE'
    + 'dWT2hnaEFtb2ZJdVFmRXp0OXoza1QrWVpTcFdjOUpiKzViV1puWXFxcE9UN2k1Zit6M0haR0tJc2luYnI1b0Ir'
    + 'Zlh5ckZHRlhVYUtlQzBBNWhHQzVYSVRZaXhXcGR4VkZSUUFsUlVFbDYvOVRIQXFVVDZvMnhLQ1hmdzRRTkF2cU'
    + 'd5TTBJWHlmcTd5Zmk5WUdDT3hBcUNTZ3FDTng0cGhTWlZ2T09YdFNza3FUYUI4ajRnUStiQjBERTNudXgvUEVG'
    + 'TmZ3WUlBd3IvNUlIVmx5dGZKZ0J5TU9GcUxORHAvci9JNUFEa0lNaUlmbHE1VThicDh3S1hNS1pUTi8rYWJFQW'
    + '9HQ0orTGNmazYvRXVsMTZ6VEIxVDZvSFZkckFlQXVwQzlVcTdiN1Jud1g2cWNXVzY0MVZ5REFBQUFBRWxGVGtT'
    + 'dVFtQ0MiIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIvPjwvc3ZnPg==) 15 15, auto';


const zoomInCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBmaWx0ZXI9InVybCgjZmlsdGVyMF9kKSI+PHBhdGgg'
    + 'ZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC41IDhDMTQuNSAxMS4wMzggMT'
    + 'IuMDM4IDEzLjUgOSAxMy41QzUuOTYyIDEzLjUgMy41IDExLjAzOCAzLjUgOEMzLjUgNC45NjIgNS45NjIgMi41'
    + 'IDkgMi41QzEyLjAzOCAyLjUgMTQuNSA0Ljk2MiAxNC41IDhaIiBmaWxsPSJ3aGl0ZSIvPjxwYXRoIGZpbGwtcn'
    + 'VsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAzOCAx'
    + 'My41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5IDIuNU'
    + 'MxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPjxwYXRoIGZpbGwtcnVsZT0i'
    + 'ZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNTg1NyAxOC4wMDAyTDE4Ljk5OTcgMTYuNTg2Mk'
    + 'wxMy41NTA3IDExLjEzNzJMMTIuMTM2NyAxMi41NTEyTDE3LjU4NTcgMTguMDAwMloiIGZpbGw9ImJsYWNrIi8+'
    + 'PC9nPjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0gxMFY1SD'
    + 'hWN0g2VjguOThIOFYxMUgxMFY4Ljk4SDEyVjdaIiBmaWxsPSJibGFjayIvPjxkZWZzPjxmaWx0ZXIgaWQ9ImZp'
    + 'bHRlcjBfZCIgeD0iMCIgeT0iMCIgd2lkdGg9IjIxLjk5OTciIGhlaWdodD0iMjIuMDAwMiIgZmlsdGVyVW5pdH'
    + 'M9InVzZXJTcGFjZU9uVXNlIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9InNSR0IiPjxmZUZsb29kIGZs'
    + 'b29kLW9wYWNpdHk9IjAiIHJlc3VsdD0iQmFja2dyb3VuZEltYWdlRml4Ii8+PGZlQ29sb3JNYXRyaXggaW49Il'
    + 'NvdXJjZUFscGhhIiB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMTI3IDAiLz48ZmVPZmZzZXQgZHk9IjEiLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSIxLj'
    + 'UiLz48ZmVDb2xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAg'
    + 'MCAwIDAgMCAwIDAgMC4zNSAwIi8+PGZlQmxlbmQgbW9kZT0ibm9ybWFsIiBpbjI9IkJhY2tncm91bmRJbWFnZU'
    + 'ZpeCIgcmVzdWx0PSJlZmZlY3QxX2Ryb3BTaGFkb3ciLz48ZmVCbGVuZCBtb2RlPSJub3JtYWwiIGluPSJTb3Vy'
    + 'Y2VHcmFwaGljIiBpbjI9ImVmZmVjdDFfZHJvcFNoYWRvdyIgcmVzdWx0PSJzaGFwZSIvPjwvZmlsdGVyPjwvZG'
    + 'Vmcz48L3N2Zz4=) 8 8, auto';


const zoomOutCursor =
      'url(data:image/svg+xml;base64,'
    + 'PHN2ZyB3aWR0aD0iMjIiIGhlaWdodD0iMjIiIHZpZXdCb3g9IjAgMCAyMiAyMiIgZmlsbD0ibm9uZSIgeG1sbn'
    + 'M9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgZmlsdGVyPSJ1cmwoI2ZpbHRlcjBfZCkiPgo8cGF0'
    + 'aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjUgOEMxNC41IDExLjAzOC'
    + 'AxMi4wMzggMTMuNSA5IDEzLjVDNS45NjIgMTMuNSAzLjUgMTEuMDM4IDMuNSA4QzMuNSA0Ljk2MiA1Ljk2MiAy'
    + 'LjUgOSAyLjVDMTIuMDM4IDIuNSAxNC41IDQuOTYyIDE0LjUgOFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGZpbG'
    + 'wtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuNSA4QzE0LjUgMTEuMDM4IDEyLjAz'
    + 'OCAxMy41IDkgMTMuNUM1Ljk2MiAxMy41IDMuNSAxMS4wMzggMy41IDhDMy41IDQuOTYyIDUuOTYyIDIuNSA5ID'
    + 'IuNUMxMi4wMzggMi41IDE0LjUgNC45NjIgMTQuNSA4WiIgc3Ryb2tlPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1'
    + 'bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE3LjU4NTcgMTguMDAwMkwxOC45OTk3IDE2Lj'
    + 'U4NjJMMTMuNTUwNyAxMS4xMzcyTDEyLjEzNjcgMTIuNTUxMkwxNy41ODU3IDE4LjAwMDJaIiBmaWxsPSJibGFj'
    + 'ayIvPgo8L2c+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTIgN0'
    + 'g2VjguOThIMTJWN1oiIGZpbGw9ImJsYWNrIi8+CjxkZWZzPgo8ZmlsdGVyIGlkPSJmaWx0ZXIwX2QiIHg9IjAi'
    + 'IHk9IjAiIHdpZHRoPSIyMS45OTk3IiBoZWlnaHQ9IjIyLjAwMDIiIGZpbHRlclVuaXRzPSJ1c2VyU3BhY2VPbl'
    + 'VzZSIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KPGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0i'
    + 'MCIgcmVzdWx0PSJCYWNrZ3JvdW5kSW1hZ2VGaXgiLz4KPGZlQ29sb3JNYXRyaXggaW49IlNvdXJjZUFscGhhIi'
    + 'B0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAi'
    + 'Lz4KPGZlT2Zmc2V0IGR5PSIxIi8+CjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjEuNSIvPgo8ZmVDb2'
    + 'xvck1hdHJpeCB0eXBlPSJtYXRyaXgiIHZhbHVlcz0iMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAw'
    + 'IDAgMC4zNSAwIi8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW4yPSJCYWNrZ3JvdW5kSW1hZ2VGaXgiIHJlc3'
    + 'VsdD0iZWZmZWN0MV9kcm9wU2hhZG93Ii8+CjxmZUJsZW5kIG1vZGU9Im5vcm1hbCIgaW49IlNvdXJjZUdyYXBo'
    + 'aWMiIGluMj0iZWZmZWN0MV9kcm9wU2hhZG93IiByZXN1bHQ9InNoYXBlIi8+CjwvZmlsdGVyPgo8L2RlZnM+Cj'
    + 'wvc3ZnPgo=) 8 8, auto';


var _dataModePages = [];
var _dataModeNodes = [];
var _dataModeConns = [];



function initDataMode()
{
    btnDataModeRestart.addEventListener('click', () => uiRestartGenerator(false));
}



dataModePagesWrapper.addEventListener('pointerdown', e =>
{
    e.preventDefault();

    if (e.button == 2)
    {
        e.stopPropagation();
        menuPageDataPages.showAt(e.clientX, e.clientY, false);
    }
});



dataModeNodesWrapper.addEventListener('pointerdown', e =>
{
    e.preventDefault();

    if (e.button == 2)
    {
        e.stopPropagation();
        menuNodeDataNodes.showAt(e.clientX, e.clientY, false);
    }
});



dataModeConnsWrapper.addEventListener('pointerdown', e =>
{
    e.preventDefault();

    if (e.button == 2)
    {
        e.stopPropagation();
        menuConnDataConns.showAt(e.clientX, e.clientY, false);
    }
});



function loadNodesAndConnsData(_pages, _nodes, _conns)
{
    _dataModePages = _pages;
    _dataModeNodes = _nodes;
    _dataModeConns = _conns;


    _dataModeNodes.sort((n1, n2) => 
    {
        if (n1.y != n2.y ) return parseFloat(n1.value.y) - parseFloat(n2.value.y);
        if (n1.x != n2.x ) return parseFloat(n1.value.x) - parseFloat(n2.value.x);
        return 0;
    });

    _dataModeConns.sort((c1, c2) => 
    {
        if (c1.value.outputNodeId != c2.value.outputNodeId) return c1.value.outputNodeId < c2.value.outputNodeId ? -1 : 1;
        if (c1.value.outputId     != c2.value.outputId    ) return c1.value.outputId     < c2.value.outputId     ? -1 : 1;
        if (c1.value.outputOrder  != c2.value.outputOrder ) return parseInt(c1.value.outputOrder) - parseInt(c2.value.outputOrder);
        return 0;
    });

    
    for (const _page of _dataModePages) dataModePages.appendChild(createPageDataDiv(_page));
    for (const _node of _dataModeNodes) dataModeNodes.appendChild(createNodeDataDiv(_node));
    for (const _conn of _dataModeConns) dataModeConns.appendChild(createConnDataDiv(_conn));


    updateDataModeInfo();

    
    loadingOverlay.style.display = 'none';
}



function updateDataModeInfo()
{
    dataModePagesTitle.innerHTML = dataModePages.children.length + '&thinsp;&nbsp;' + countString('page',       dataModePages.children.length);
    dataModeNodesTitle.innerHTML = dataModeNodes.children.length + '&thinsp;&nbsp;' + countString('node',       dataModeNodes.children.length);
    dataModeConnsTitle.innerHTML = dataModeConns.children.length + '&thinsp;&nbsp;' + countString('connection', dataModeConns.children.length);
}



function createPageDataDiv(_page)
{
    const div    = createDiv('dataModePage');
    
    const page   = JSON.parse(_page.value);
    page._key    = _page.key;


    div._page    = _page.value;
    div. page    =  page;

    div.showJson = false;


    expandPageData(div);


    div.addEventListener('dblclick', () =>
    {
        div.showJson = !div.showJson;
        expandPageData(div, page, _page);
    });


    div.addEventListener('pointerenter', () => div.style.background = 'var(--data-mode-node-active)');
    div.addEventListener('pointerleave', () => { if (!menuPageData._div) div.style.background = 'var(--data-mode-node)'; });


    div.addEventListener('pointerdown', e =>
    {
        e.preventDefault();

        if (e.button == 2)
        {
            e.stopPropagation();

            // div.style.background = 'var(--data-mode-node-active)';

            createDataMenuOnHide(
                menuPageData,
                div,
                'var(--data-mode-node)'); 

            menuPageData.showAt(e.clientX, e.clientY, false);
        }
    });


    return div;
}



function createNodeDataDiv(_node)
{
    const div    = createDiv('dataModeNode');
    
    const node   = JSON.parse(_node.value);
    node._key    = _node.key;
    node .div    = div;


    div._node    = _node.value;
    div. node    =  node;

    div.showJson = false;

    expandNodeData(div);


    div.addEventListener('dblclick', () =>
    {
        div.showJson = !div.showJson;
        expandNodeData(div, node, _node);
    });


    div.addEventListener('pointerenter', () => div.style.background = 'var(--data-mode-node-active)');
    div.addEventListener('pointerleave', () => { if (!menuNodeData._div) div.style.background = 'var(--data-mode-node)'; });


    div.addEventListener('pointerdown', e =>
    {
        e.preventDefault();

        if (e.button == 2)
        {
            e.stopPropagation();

            // div.style.background = 'var(--data-mode-node-active)';

            createDataMenuOnHide(
                menuNodeData,
                div,
                'var(--data-mode-node)'); 

            menuNodeData.showAt(e.clientX, e.clientY, false);
        }
    });


    return div;
}



function createConnDataDiv(_conn)
{
    const div    = createDiv('dataModeConn');

    const conn   = JSON.parse(_conn.value);
    conn._key    = _conn.key;

    div._conn    = _conn.value;
    div. conn    =  conn;

    div.showJson = false;

    expandConnData(div);


    div.addEventListener('dblclick', () =>
    {
        div.showJson = !div.showJson;
        expandConnData(div, conn, _conn);
    });


    div.addEventListener('pointerenter', () => div.style.background = 'var(--data-mode-conn-active)');
    div.addEventListener('pointerleave', () => { if (!menuConnData._div) div.style.background = 'var(--data-mode-conn)'; });


    div.addEventListener('pointerdown', e =>
    {
        e.preventDefault();
        
        if (e.button == 2)
        {
            e.stopPropagation();

            div.style.background = 'var(--data-mode-conn-active)';

            createDataMenuOnHide(
                menuConnData,
                div,
                'var(--data-mode-conn)');

            menuConnData.showAt(e.clientX, e.clientY, false);
        }
    });


    return div;
}



function createDataMenuOnHide(menu, div, normal)
{
    menu._div = div;
    
    menu.onHide = () =>
    { 
        menu._div.style.background = normal;
        setTimeout(() => menu._div = null);
    };
}



function expandPageData(div)
{
    if (div.showJson)
    {
        div.innerHTML =
              '<div class="pageDataHeader">' + div.page._key + '</div>'
            + '<div class="pageDataBody">' + formatSavedDataJson(div._page) + '</div>';

        div.style.paddingLeft   = '0px';
        div.style.paddingRight  = '0px';
        div.style.textAlign     = 'left';
        div.style.fontFamily    = 'Roboto Mono';
        div.style.letterSpacing = '-0.06em';
    }
    else
    {
        div.innerHTML = div.page.id;

        div.style.paddingLeft   = '6px';
        div.style.paddingRight  = '6px';
        div.style.textAlign     = 'center';
        div.style.fontFamily    = 'Inter';
        div.style.letterSpacing = 0;
    }
}



function expandNodeData(div)
{
    if (div.showJson)
    {
        div.innerHTML =
        //   '<div>' + div._key + '</div><div>'
        // + (div.node.loading ? '&nbsp;<br/>' : '')
              '<div class="nodeDataHeader">' + (div.node.loading ? '&nbsp;' : '') + div.node._key + '</div>'
            + '<div class="nodeDataBody">' + formatSavedDataJson(div._node) + '</div>';

        div.style.paddingLeft   = '0px';
        div.style.paddingRight  = '0px';
        div.style.textAlign     = 'left';
        div.style.fontFamily    = 'Roboto Mono';
        div.style.letterSpacing = '-0.06em';
    }
    else
    {
        div.innerHTML = 
             (div.node.loading ? '&nbsp;&nbsp' : '')
            + div.node.id;

        div.style.paddingLeft   = '6px';
        div.style.paddingRight  = '6px';
        div.style.textAlign     = 'center';
        div.style.fontFamily    = 'Inter';
        div.style.letterSpacing = 0;
    }
}



function expandConnData(div)
{
    if (div.showJson)
    {
        div.innerHTML =
                '<div class="connDataHeader">' 
                  + (div.conn.loading ? '&nbsp;' : '') 
                  + div.conn._key.replaceAll('undefined', '<span class="dataUndefined">undefined</span>') 
              + '</div>'
              + '<div class="connDataBody">' + formatSavedDataJson(div._conn) + '</div>';

        div.style.paddingLeft   = '0px';
        div.style.paddingRight  = '0px';
        div.style.textAlign     = 'left';
        div.style.fontFamily    = 'Roboto Mono';
        div.style.letterSpacing = '-0.06em';
    }
    else
    {
        div.innerHTML = 
             (div.conn.loading ? '&nbsp;&nbsp' : '')
            + connToString(div.conn);

        div.style.paddingLeft   = '6px';
        div.style.paddingRight  = '6px';
        div.style.textAlign     = 'center';
        div.style.fontFamily    = 'Inter';
        div.style.letterSpacing = 0;
    }
}



function expandAllPageData()
{
    for (const div of dataModePages.children)
    {
        div.showJson = true;
        expandPageData(div, div.page, div._page);
    }
}



function collapseAllPageData()
{
    for (const div of dataModePages.children)
    {
        div.showJson = false;
        expandPageData(div, div.page, div._page);
    }
}



function expandAllNodeData()
{
    for (const div of dataModeNodes.children)
    {
        div.showJson = true;
        expandNodeData(div, div.node, div._node);
    }
}



function collapseAllNodeData()
{
    for (const div of dataModeNodes.children)
    {
        div.showJson = false;
        expandNodeData(div, div.node, div._node);
    }
}



function expandAllConnData()
{
    for (const div of dataModeConns.children)
    {
        div.showJson = true;
        expandConnData(div, div.conn, div._conn);
    }
}



function collapseAllConnData()
{
    for (const div of dataModeConns.children)
    {
        div.showJson = false;
        expandConnData(div, div.conn, div._conn);
    }
}



function dataModeDeletePage(page)
{
    for (let i = dataModePages.children.length-1; i >= 0; i--)
    {
        const div = dataModePages.children[i];

        if (div.page.id == page.id)
            dataModePages.removeChild(div);
    }


    uiRemoveSavedPage(page.id);

    graph.nodes
        .filter (n => n.pageId == page.id)
        .forEach(n => dataModeDeleteNode(n));


    let notice = 'Deleted page \'' + page.id + '\'';

    updateDataModeInfo();

    uiNotify(notice);
}



function dataModeDeleteNode(node)
{
    uiRemoveSavedNodesAndConns([node.id]);


    for (let i = dataModeNodes.children.length-1; i >= 0; i--)
    {
        const div = dataModeNodes.children[i];

        if (div.node.id == node.id)
            dataModeNodes.removeChild(div);
    }


    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (   div.conn.outputNodeId == node.id
            || div.conn. inputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    let notice = 'Deleted node \'' + node.id + '\'';

    if (nRemovedConns > 0)
        notice += ' and ' + nRemovedConns + ' ' + countString('connection', nRemovedConns);


    updateDataModeInfo();

    uiNotify(notice);
}



function dataModeDeleteAllNodes()
{
    uiRemoveAllSavedNodesAndConns();


    let nRemovedNodes = dataModeNodes.children.length;

    for (let i = dataModeNodes.children.length-1; i >= 0; i--)
        dataModeNodes.removeChild(dataModeNodes.children[i]);


    let nRemovedConns = dataModeConns.children.length;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
        dataModeConns.removeChild(dataModeConns.children[i]);


    let notice = 'Deleted ' + nRemovedNodes + ' ' + countString('node', nRemovedNodes);

    if (nRemovedConns > 0)
        notice += ' and ' + nRemovedConns + ' ' + countString('connection', nRemovedConns);


    updateDataModeInfo();

    uiNotify(notice);
}



function dataModeDeleteAllConnections()
{
    uiRemoveAllSavedConnections();


    let nRemovedConns = dataModeConns.children.length;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
        dataModeConns.removeChild(dataModeConns.children[i]);


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString('connection', nRemovedConns));
}



function dataModeDeleteConnectionsToAndFromNode(node)
{
    uiDeleteSavedConnectionsToNodeId  (node.id);
    uiDeleteSavedConnectionsFromNodeId(node.id);

    
    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (   div.conn.outputNodeId == node.id
            || div.conn. inputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString('connection', nRemovedConns) + ' to and from \'' + node.id + '\'');
}



function dataModeDeletePathFromNodeId(node)
{
    console.log('node ', node);

    uiRemoveSavedNodesAndConns([node.id]);
    uiDeleteObjectsAndStyles([node.id], true);


    const div = node.div;
    

    node.id = stripPathFromId(node.id);

    delete node.loading;
    delete node._key;
    delete node.div;

    uiSaveNodesJson([node.id], [node]);

    //div.innerHTML = 
}



function dataModeDeleteConnectionsFromNode(node)
{
    uiDeleteSavedConnectionsFromNodeId(node.id);


    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (div.conn.outputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString('connection', nRemovedConns) + ' from \'' + node.id + '\'');
}



function dataModeDeleteConnectionsToNode(node)
{
    uiDeleteSavedConnectionsToNodeId(node.id);


    let nRemovedConns = 0;

    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (div.conn. inputNodeId == node.id)
        {
            dataModeConns.removeChild(div);
            nRemovedConns++;
        }
    }


    updateDataModeInfo();

    if (nRemovedConns > 0)
        uiNotify('Deleted ' + nRemovedConns + ' ' + countString('connection', nRemovedConns) + ' to \'' + node.id + '\'');
}



function dataModeDeleteConnection(conn)
{
    uiDeleteSavedConnection(
        conn._key,
        conn.outputNodeId,
        conn.outputId,
        conn.outputOrder,
        conn.inputNodeId,
        conn.inputId,
        conn.list);


    for (let i = dataModeConns.children.length-1; i >= 0; i--)
    {
        const div = dataModeConns.children[i];

        if (div.conn._key == conn._key)
            dataModeConns.removeChild(div);
    }


    updateDataModeInfo();

    uiNotify('Deleted connection' + connToString(conn));
}



var deleteConnectionsDialogVisible = false;



function showDeleteConnectionsDialog()
{
    deleteConnectionsDialog.style.left      = '50%';
    deleteConnectionsDialog.style.top       = '50%';
    deleteConnectionsDialog.style.transform = 'translateX(-50%) translateY(-50%)';

    deleteConnectionsDialog.style.display   = 'block';
    deleteConnectionsDialogVisible          = true;
  
    deleteConnectionsTitle.buttonDown0      = false;
       
    deleteConnectionsTitle.moveStart        = point_NaN;
    deleteConnectionsTitle.pStart           = point_NaN;
    
    deleteConnectionsInput.value            = graphView.selectedNodes.map(n => n.id).join(', ');

    updateDeleteConnectionsInputBack();


    window.setTimeout(() => document.getElementById('deleteConnectionsInput').focus(), 0);
}



function hideDeleteConnectionsDialog()
{
    deleteConnectionsDialog.style.display = 'none';
    deleteConnectionsDialogVisible        = false;
}



deleteConnectionsClose.addEventListener('pointerdown', e => e.stopPropagation());



deleteConnectionsTitle.addEventListener('pointerdown', e => 
{
    deleteConnectionsTitle.setPointerCapture(e.pointerId);
    deleteConnectionsTitle.buttonDown0 = true;

    deleteConnectionsTitle.moveStart = point(deleteConnectionsDialog.offsetLeft, deleteConnectionsDialog.offsetTop);
    deleteConnectionsTitle.pStart    = point(e.clientX, e.clientY);
});



deleteConnectionsTitle.addEventListener('pointermove', e =>
{
    if (deleteConnectionsTitle.buttonDown0)
    {
        deleteConnectionsDialog.style.left = (deleteConnectionsTitle.moveStart.x + (e.clientX - deleteConnectionsTitle.pStart.x)) + 'px';
        deleteConnectionsDialog.style.top  = (deleteConnectionsTitle.moveStart.y + (e.clientY - deleteConnectionsTitle.pStart.y)) + 'px';
    }
});



deleteConnectionsTitle.addEventListener('pointerup', e =>
{
    deleteConnectionsTitle.buttonDown0 = false;
    deleteConnectionsTitle.releasePointerCapture(e.pointerId);
});



deleteConnectionsInput.addEventListener('input', () =>
{
    updateDeleteConnectionsInputBack();
});



function updateDeleteConnectionsInputBack()
{
    deleteConnectionsInputBack.innerHTML          = deleteConnectionsInput.value == '' ? 'Node IDs' : '';
    deleteConnectionsInputBack.style.borderBottom = deleteConnectionsInput.value == '' ? '1px solid var(--figma-color-bg-tertiary)' : 'none';
}



deleteConnectionsInput.addEventListener('pointerup', () =>
{
    deleteConnectionsInput.select();
});



function deleteConnectionsToNodes(str)
{
    str = str.replace(',', ' ');
    
    const nodeIds = str.split(' ').filter(i => i);

    uiRemoveConnsToNodes(nodeIds);

    if (!isEmpty(nodeIds))
        hideDeleteConnectionsDialog();
}


var documentBodyClient = null;
var enteredDragging    = false;


document.button0 = false;


// document.addEventListener('dragenter', function(e)
// {
//     console.log('dragenter');
//     e.preventDefault();
//     // e.stopImmediatePropagation();
//     return false;
//     // return false;
//     // if (   e.buttons[0] 
//     //     || e.buttons[1] 
//     //     || e.buttons[2])
//     //     enteredDragging = true;
// });



// document.addEventListener('drag', function(e)
// {
//     e.preventDefault();
//     // e.stopImmediatePropagation();
//     return false;
//     // return false;
//     // if (   e.buttons[0] 
//     //     || e.buttons[1] 
//     //     || e.buttons[2])
//     //     enteredDragging = true;
// });



// document.addEventListener('pointerenter', function(e)
// {
//     if (   e.buttons[0] 
//         || e.buttons[1] 
//         || e.buttons[2])
//         enteredDragging = true;
// });



document.addEventListener('pointerdown', function(e)
{
    if (e.button == 0)
        document.button0 = true;
}, 
true);



document.addEventListener('pointerdown', function(e)
{
    if (e.button == 0)
    {
        if (   document.canResizeL
            || document.canResizeR
            || document.canResizeB)
        {
            document.sx = e.clientX;
            document.sy = e.clientY;

            document.startPan = graph.currentPage.pan;


            uiPostMessageToFigma({
                cmd:           'figGetMousePosition',
                clientPosition: point(e.clientX, e.clientY)});


            document.body.setPointerCapture(e.pointerId);

            document.resizingL = document.canResizeL;
            document.resizingR = document.canResizeR;
            document.resizingB = document.canResizeB;


            document.startRectIsValid = false;
        }
    }


    hideAllMenus();
});



document.addEventListener('pointermove', function(e)
{
    if (enteredDragging)
    {
        e.preventDefault();
        return false;
    }


    if (   document.resizingR
        && document.resizingB
        && document.startRectIsValid)
    {
        uiResizeWindow(
            document.startRect.w + e.clientX - document.sx,
            document.startRect.h + e.clientY - document.sy);
    }
    else if (document.resizingL
          && document.resizingB
          && document.startRectIsValid)
    {
        uiSetWindowRect(
            e.clientX,
            e.clientY,
            document.startRect.w - e.clientX + document.startRect.x,
            document.startRect.h + e.clientY - document.startRect.y);
    }
    else if (document.resizingL
          && document.startRectIsValid)
    {
        uiSetWindowRect(
            document.startRect.x + (e.clientX - document.sx) / viewportZoom,
            document.startRect.y,
            document.startRect.width - e.clientX + document.sx,
            document.startRect.height);

        //graph.currentPage.pan = point(document.startPan.x - e.clientX, document.startPan.y);
    }
    else if (document.resizingR
          && document.startRectIsValid)
    {
        uiResizeWindow(
            document.startRect.w + e.clientX - document.sx,
            window.innerHeight);
    }
    else if (document.resizingB
          && document.startRectIsValid)
    {
        uiResizeWindow(
            window.innerWidth,
            document.startRect.h + e.clientY - document.sy);
    }
    else if (!graphView.selecting)
    {
        checkResize(e.clientX, e.clientY);
        //e.stopPropagation();
    }
});



document.addEventListener('pointerup', function(e)
{
    if (e.button == 0)
        document.button0 = false;
},
true);



document.addEventListener('pointerup', function(e)
{
    enteredDragging = false;

     if (   document.resizingL
         || document.resizingR
         || document.resizingB)
    {
        checkResize(e.clientX, e.clientY);
        document.body.releasePointerCapture(e.pointerId);
    }

    document.resizingL = false;
    document.resizingR = false;
    document.resizingB = false;

    graphView.scrollbarX.moving  = false;
    graphView.scrollbarY.moving  = false;
});



window.addEventListener('focus', () => graph.updatePages());
window.addEventListener('blur',  () => graph.updatePages());

document.addEventListener('contextmenu', e => e.preventDefault());



var generatorStarted = false;


var uiFigMessages    = []; // messages from UI to Figma
var genMessages      = []; // messages from UI to Generator

var genMessagePosted = false;


var allUpdateNodes   = [];



// uiClearAllLocalData();
//uiQueueMessageToFigma({cmd: 'figLogAllLocalData', darkMode: darkMode});

// uiClearLocalData('windowWidth');
// uiClearLocalData('windowHeight');
//uiClearLocalData('productKey');

// uiClearLocalData('showRequests');
// uiClearLocalData('showWhatsNew');

//uiSetLocalData('enableBetaFeatures', 'true');
//uiSetLocalData('logLoading', 'true');

//uiRemoveConnsToNodes(['num3']);
//uiRemoveSavedNodesAndConns(['color']);
//uiRemovePluginDataFromAllLocalStyles();



//uiRemoveAllSavedNodesAndConns();
//uiRemoveAllSavedPages();



var currentUser = null;
var productKey  = NULL;


const generator = new Worker(
    window.URL.createObjectURL(
        new Blob([generatorScript.textContent])));
        

var panMode             = false;        

var     copiedNodesJson = '';
var duplicatedNodesJson = '';

var pasteOffset         = point(0,  0);
var pasteOffsetDelta    = point(50, 50);



clearConsole();


initUtilContext();


initLoadingOverlay();
initDataMode();
initWhatsNewDialog();
initAboutDialog();


uiQueueMessageToFigma({cmd: 'figStartGenerator'});



function uiReturnFigStartGenerator(msg)
{
    initThemeColors();
    loadLocalSettings();

    initKeyboardPanel();

 
    figFonts = msg.fonts;
    uiQueueMessageToGenerator({cmd: 'initFonts', fonts: figFonts});
    


    graphView.updateMeasureData();

    viewportRect = msg.viewportRect;

    
    uiGetLocalData('showWhatsNew');


    currentUser  = msg.currentUser;
    productKey   = msg.productKey;

    startupValidateLicense();
    // enableFeatures() is called when loading is done


    setTimeout(() => loadingGraphic.style.display = 'block', 300);

    uiQueueMessageToFigma({
        cmd:     'figLoadNodesAndConns',
        dataMode: settings.dataMode });
}


var altPressedInMenu = false;



document.addEventListener('keydown', e =>
{
    if (crashed)
    {
        e.preventDefault();
        e.stopPropagation();
        return;
    }


    let setLastKeyDown = true;


    // cut
    if (   e.code == 'KeyX'
        && getCtrlKey(e))
    {
        graphView.copySelectedNodes();
        graphView.deleteSelectedNodes(true);
    }

    // copy
    else if (   e.code == 'KeyC'
        && getCtrlKey(e))
    {
        e.preventDefault();

        if (e.shiftKey) graphView.copySelectedNodesAsJavascript();
        else            graphView.copySelectedNodes();
    }

    // paste
    else if (e.code == 'KeyV'
          && getCtrlKey(e)
          && !e.altKey)
    {
        e.preventDefault();
        graphView.pasteCopiedNodes(e.shiftKey);
    }

    // duplicate
    else if (e.code == 'KeyD'
          && getCtrlKey(e)
          && !e.altKey)
    {
        if (e.shiftKey)
            e.preventDefault();
            
        graphView.duplicateSelectedNodes(e.shiftKey);
        return false;
    }

    // disable nodes
    else if (e.code == 'KeyE'
          && getCtrlKey(e)
          && e.shiftKey)
    {
        e.preventDefault();

        if (!graphView.selectedNodes.find(n => !n.canDisable))
            actionManager.do(new ToggleDisableNodesAction(graphView.selectedNodes.map(n => n.id)));
            
        return false;
    }

    // select all
    else if (e.code == 'KeyA'
          && getCtrlKey(e))
        graphView.selectAllNodes(e.shiftKey);

    // undo/redo
    else if (e.code == 'KeyZ'
          && getCtrlKey(e)
          && !document.button0
          && isEmpty(currentMenus))
    {
             if (e.shiftKey && !actionManager.redoing) actionManager.redo();
        else if (              !actionManager.undoing) actionManager.undo();

        setLastKeyDown = false;
    }

    // delete / backspace
    else if (   e.key == 'Delete'
             || e.key == 'Backspace')
    {
        if (getCtrlKey(e)) graphView.removeSelectedNodes();
        else               graphView.deleteSelectedNodes();
    }

    // // select all
    // else if (e.code == 'KeyL'
    //       && getCtrlKey(e))
    //     layoutSelectedNodes();

    // toggled operation results
    else if (e.code == 'KeyR'
          && getCtrlKey(e)
          && e.shiftKey)
    {
        updateSettingAndMenu('showOperationResults',  true, !settings.showOperationResults);  
        updateMenuItemShowOperationResults();          
    }

    // escape
    else if (e.key == 'Escape')
    {
        if (!isEmpty(currentMenus))
            hideAllMenus();


        else if (graphView.tempConn)
        {
            if (graphView.savedConn)
            {
                const savedConn = graphView.savedConn;

                setTimeout(() => 
                {
                    savedConn.wire.update();
                    savedConn.input.updateControl();
                });
            }

            graphView.cancelConnection(graphView.connPointerId);
        }


        else if (isVisible(whatsNewDialog         )) hideWhatsNewDialog();
        else if (isVisible(minZoomDialog          )) hideMinZoomDialog();
        else if (isVisible(productKeyDialog       )) hideProductKeyDialog();
        else if (isVisible(aboutDialog            )) hideAboutDialog();
        else if (isVisible(deleteConnectionsDialog)) hideDeleteConnectionsDialog();

        else if (!isEmpty(graphView.selectedNodes))
            graphView.deselectAllNodes(e.shiftKey);
    }

    //
    else if (e.code == 'Minus'
          || e.code == 'NumpadSubtract')
    {
        graph.currentPage.zoom /= Math.pow(2, 1/2);
    }

    else if (e.code == 'Equal'
          || e.code == 'NumpadAdd')
    {
        graph.currentPage.zoom *= Math.pow(2, 1/2);
    }

    else if ((   e.code == 'Digit0'
              || e.code == 'Numpad0')
          && getCtrlKey(e))
    {
        graph.currentPage.zoom = 1;
        uiNotify('Zoom to 100%');
    }

    else if (e.code == 'Digit1'
          && e.shiftKey)
    {
        graphView.zoomToFit();
        uiNotify('Zoom to fit');
    }

    else if (e.code == 'Digit2'
          && e.shiftKey)         
    {
        graphView.zoomToSelection();

        if (!isEmpty(graphView.selectedNodes))
            uiNotify('Zoom to selection');
    }

    else if (e.code == 'Space'
         && !getCtrlKey(e))
    {
        if (   !graphView.selecting
            && !graphView.spaceDown
            && !panMode)
        {
            graphView.spaceDown = true;
            setCursor(panCursor);
        }
    }

    else if (e.key == 'Shift')
    {
        if (graphView._soloNode)
            graphView.unsoloNode();
        
        if (    numberControlChanging
            && !numberControlChanging.shiftDown)
        {
            numberControlChanging.shiftDown = true;
            numberControlChanging.update();
        }
    }

    else if (e.key == 'Control')
    {
        if (graphView._soloNode)
            graphView.unsoloNode();

        if (graphView.spaceDown)
        {
            graphView.zoomSelecting = true;
            graphView.altDown = e.altKey;

            if (e.altKey) setCursor(zoomOutCursor);
            else          setCursor(zoomInCursor);
        }

        else if (graphView.tempConn)
        {
            graphView.tempConn.backInit = true;

            const tc = graphView.tempConn;

            tc.wire.update(
                tc.wire.clientX,
                tc.wire.clientY);
        }

        else if (overNumberControl
              && overNumberControl.param)
        {
            if (overNumberControlCtrl)
            {
                overNumberControlCtrl.param.showFullPrecision = false;
                overNumberControlCtrl.update();
            }

            overNumberControlCtrl = overNumberControl;

            overNumberControlCtrl.param.showFullPrecision = true;
            overNumberControlCtrl.update();
        }
    }

    else if (    e.key == 'Alt'
             && !e.shiftKey
             && !getCtrlKey(e))
    {
        if ( graphView.overNode
              &&  isEmpty(currentMenus)
              && !altPressedInMenu)
            graphView.soloNode(graphView.overNode);

        else if (currentMenus.length == 1
              && currentMenus[0] == menuColor)
        {
              menuItemColor.setIcon(iconRandomColor);
              altPressedInMenu = true;
        }
    }

    else if (    e.key == 'Alt'
             && !e.shiftKey
             &&  graphView.spaceDown
             &&  getCtrlKey(e))
    {
        setCursor(zoomOutCursor);
        graphView.altDown = true;
    }

    else if (e.code == 'Tab')
        e.preventDefault();

    else if (e.code == 'KeyN') actionManager.do(getCreateNodeAction(NUMBER,      null, getCreateOptions(e)));
    else if (e.code == 'KeyT') actionManager.do(getCreateNodeAction(TEXT,        null, getCreateOptions(e)));
    else if (e.code == 'KeyC') actionManager.do(getCreateNodeAction(COLOR,       null, getCreateOptions(e, {random: e.altKey && !getCtrlKey(e)})));
    else if (e.code == 'KeyG') actionManager.do(getCreateNodeAction(GROUP_NODE,  null, getCreateOptions(e)));
    else if (e.code == 'KeyP') actionManager.do(getCreateNodeAction(GROUP_PARAM, null, getCreateOptions(e)));

    // graph.nodes.at(-1).div.style.left = e.clientX - (defNodeWidth    / 2) - (               + graph.currentPage.pan.x) / graph.currentPage.zoom;
    // graph.nodes.at(-1).div.style.top  = e.clientY - (defHeaderHeight / 2) - (getTopHeight() + graph.currentPage.pan.y) / graph.currentPage.zoom;
});



document.addEventListener('keyup', e =>
{
    graphView.altDown = false;


    if (e.code == 'Space')
    {
        if (graphView.spaceDown)
        {
            graphView.spaceDown     = false;
            graphView.zoomSelecting = false;
            setAutoCursor();
        }
    }

    else if (e.key == 'Alt')
    {
        if (graphView.spaceDown)
        {
            if (getCtrlKey(e)) 
                setCursor(zoomInCursor);
            else
            {
                setCursor(panCursor);
                graphView.zoomSelecting = false;
            }
        }
        else if (graphView._soloNode
              && isEmpty(currentMenus))
            graphView.unsoloNode();

        else if (currentMenus.length == 1
            && currentMenus[0] == menuColor)
            menuItemColor.setIcon(iconColor);


        altPressedInMenu = false;
    }

    else if (e.key == 'Control')
    {
        if (graphView.spaceDown)
        {
            graphView.zoomSelecting = false;
            setCursor(panCursor);
        }
        else if (graphView.tempConn)
        {
            graphView.tempConn.backInit = false;

            const tc = graphView.tempConn;

            tc.wire.update( 
                tc.wire.clientX,
                tc.wire.clientY);
        }
        else if (overNumberControlCtrl)
        {
            overNumberControlCtrl.param.showFullPrecision = false;
            overNumberControlCtrl.update();
            overNumberControlCtrl.updateCursor();

            overNumberControlCtrl = null;
        }
    }

    else if (e.key == 'Shift')
    {
        if (numberControlChanging)
        {
            numberControlChanging.shiftDown = null;
            numberControlChanging.update();
        }
    }
},
false);


var currentKeyboardTab = 0;


function initKeyboardPanel()
{
    if (isMac)
    {
        const _ctrlShift = document.getElementsByClassName('ctrlShift');
        const  ctrlShift = Array.prototype.slice.call(_ctrlShift);
    
        const ctrlKeys  = ctrlShift.filter(k => k.innerHTML == 'Ctrl' );
        const shiftKeys = ctrlShift.filter(k => k.innerHTML == 'Shift');

        ctrlKeys .forEach(k => k.innerHTML = 'Shift');
        shiftKeys.forEach(k => k.innerHTML = 'Ctrl' );


        document.getElementsByClassName('treeLeftCtrl'  )[0].innerHTML = 'Alt';

        document.getElementsByClassName('newBranch1'    )[0].innerHTML = 'Alt';
        document.getElementsByClassName('newBranch2'    )[0].innerHTML = 'Ctrl';
        
        document.getElementsByClassName('treeRightCtrl1')[0].innerHTML = 'Shift';
        document.getElementsByClassName('treeRightCtrl2')[0].innerHTML = 'Ctrl';
        
        document.getElementsByClassName('treeAcross1'   )[0].innerHTML = 'Alt';
        document.getElementsByClassName('treeAcross2'   )[0].innerHTML = 'Ctrl';
    }


    const keys = document.getElementsByClassName('shortcutKey');

    for (const key of keys)
    {
             if (key.innerHTML == 'Ctrl' ) key.innerHTML = osCtrl (false);
        else if (key.innerHTML == 'Shift') key.innerHTML = osShift(false);
        else if (key.innerHTML == 'Alt'  ) key.innerHTML = osAlt  (false);
    }
}



function showKeyboardPanel()
{
    setCurrentKeyboardTab(0);
    keyboardPanel.style.display = 'block';
}



function hideKeyboardPanel()
{
    keyboardPanel.style.display = 'none';
}



function setCurrentKeyboardTab(tab)
{
    currentKeyboardTab = tab;

    for (let i = 0; i < keyboardPanelTabs.children.length; i++)
    {
        keyboardPanelTabs.children[i].style.background = i == currentKeyboardTab ? '#1E1E1E' : 'none';
        keyboardPanelTabs.children[i].style.boxShadow  = i == currentKeyboardTab ? '0 0 0 0.5px #ffffff2b' : 'none';

        keyboardPanelContent.children[i].style.display = i == currentKeyboardTab ? 'flex' : 'none';
    }
}


var loadRestartTimer = -1;



function initLoadingOverlay()
{
    btnLoadingRestart .style.display = 'none';
    btnLoadingRestart.addEventListener('click', () => uiRestartGenerator(true));
}



function restartLoadingTimer()
{
    if (loadRestartTimer > -1) 
        clearTimeout(loadRestartTimer);

    loadRestartTimer = setTimeout(() => 
    {
        btnLoadingRestart.style.display = 'inline-block';
        loadRestartTimer = -1;
    }, 
    5000);
}


var uiFigMessagePosted = false;



// --> from Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

onmessage = e =>
{
    let msg = JSON.parse(e.data.pluginMessage);


    if (settings.logMessages)
    {
        let _msg = msg.cmd;

        if (msg.cmd == 'uiEndFigMessage')
            _msg += ': ' + msg.msgCmd;

        console.log('%cFIG '+_msg+' -- UI', 'background: #08f; color: white;');
    }


    switch (msg.cmd)
    {
        case 'uiForwardToGenerator':              uiPostMessageToGenerator         (msg.msg);      break;

        case 'uiStylePropertyChange':             uiStylePropertyChange            (msg);          break;
        case 'uiStyleDelete':                     uiStyleDelete                    (msg);          break;
            
        case 'uiEndFigMessage':                   uiEndFigMessage                  (msg.msgCmd);   break;
                                    
        case 'uiReturnFigStartGenerator':         uiReturnFigStartGenerator        (msg);          break;
                                             
        case 'uiReturnFigLoadNodesAndConns':      uiReturnFigLoadNodesAndConns     (msg);          break;
                                             
        case 'uiReturnFigGetLocalData':           uiReturnFigGetLocalData          (msg);          break;
        case 'uiReturnFigGetPageData':            uiReturnFigGetPageData           (msg);          break;
                                                   
        case 'uiReturnFigResizeWindow':           uiReturnFigResizeWindow          ();             break;
                           
        case 'uiReturnFigGetAllLocalColorStyles': uiReturnFigGetAllLocalColorStyles(msg);          break;

        case 'uiReturnFigGetMousePosition':       uiUpdateWindowStartRect          (msg);          break;

        case 'uiSetStyleId':                      uiSetStyleId                     (msg);          break;
        case 'uiHideClearUndoWarning':            uiHideClearUndoWarning           ();             break;
    }
}    

///////////////////////////////////////////////////////////////////////////////////////////////////



// <-- to Figma
///////////////////////////////////////////////////////////////////////////////////////////////////

function uiPostMessageToFigma(msg)
{
    uiFigMessagePosted = true;
    parent.postMessage({pluginMessage: JSON.stringify(msg)}, '*');

    if (settings.logMessages)
        console.log('%c%s FIG -- UI '+msg.cmd, 'background: #bef; color: black;', '\n            ');
}



function uiQueueMessageToFigma(msg)
{
    uiFigMessages.push(msg);
    uiPostNextMessageToFigma();
}



function uiPostNextMessageToFigma()
{
    if (   !isEmpty(uiFigMessages)
        && !uiFigMessagePosted)
    {
        let msg = uiFigMessages.shift();


        if (   msg.cmd == 'figResizeWindow'
            || msg.cmd == 'figSetWindowRect')
        {
            // move along the queue since only the last message is important
            while (!isEmpty(uiFigMessages)
                &&  uiFigMessages[0].cmd == msg.cmd)
                msg = uiFigMessages.shift();
        }


        uiPostMessageToFigma(msg);    
    }
}



function uiEndFigMessage(msgCmd)
{
    uiFigMessagePosted = false;

    //if (msgCmd == 'figUpdateObjectsAndStyles')
    //{
        uiPostMessageToGenerator({
            cmd:      'genEndFigMessage',
            msgCmd:    msgCmd });
    //}

    uiPostNextMessageToFigma();
}

///////////////////////////////////////////////////////////////////////////////////////////////////



//                                                                               from Generator <--
///////////////////////////////////////////////////////////////////////////////////////////////////

generator.onmessage = function(e)
{
    //console.log('e =', e);
    const msg = JSON.parse(e.data);

    if (settings.logMessages)
    {
        let _msg = msg.cmd;

        if (msg.cmd == 'uiEndGenMessage')
            _msg += ': ' + msg.msgCmd;

        console.log('%c%sUI -- GEN '+_msg, 'background: #ca0; color: white;', '\n                        ');
    }

    switch (msg.cmd)
    {
        case 'uiEndGenMessage': uiEndGenMessage(); break;
        
        case 'uiUpdateValuesAndObjects': 
            uiUpdateValuesAndObjects(
                parseInt(msg.requestId), 
                msg.actionId, 
                msg.updateNodeId, 
                msg.updateParamId, 
                msg.values, 
                msg.objects, 
                msg.styles,
                msg.updatedNodes,
                msg.totalNodes,
                msg.isLastChunk);  
                
            break;
        
        case 'uiInitNodeProgress':   nodeFromId(msg.nodeId).initProgress();                break;
        case 'uiUpdateNodeProgress': nodeFromId(msg.nodeId).updateProgress(msg.progress);  break;
        
        case 'uiForwardToFigma':     uiPostMessageToFigma(msg.msg);                                        break;
    }
};



function uiEndGenMessage()
{
    genMessagePosted = false;
    uiPostNextMessageToGenerator();
}

///////////////////////////////////////////////////////////////////////////////////////////////////



//                                                                                 to Generator -->
///////////////////////////////////////////////////////////////////////////////////////////////////

function uiQueueMessageToGenerator(msg)
{
    genMessages.push(msg);
    uiPostNextMessageToGenerator();
}



function uiPostNextMessageToGenerator()
{
    if (isEmpty(genMessages))
        return;


    let msg = genMessages[0];
    
    if (msg.cmd == 'genRequest')
    {
        // move along the queue since only the last message is important
        while (genMessages.length > 1
            && genMessages[1].cmd        == msg.cmd
            && genMessages[1].request[2] == msg.request[2]
            && genMessages[1].request[3] == msg.request[3])
        {
            genMessages.shift();
            msg = genMessages[0];
        }
    }

    
    if (!genMessagePosted)
    {
        genMessages.shift();
        uiPostMessageToGenerator(msg);

        genMessagePosted = true;
    }
}



function uiPostMessageToGenerator(msg)
{
    generator.postMessage(JSON.stringify(msg));

    if (settings.logMessages)
        console.log('%c%s UI '+msg.cmd+' -- GEN', 'background: #ffb; color: black;', '\n            ');
}

///////////////////////////////////////////////////////////////////////////////////////////////////


var minZoomDialogVisible = false;



function showMinZoomDialog()
{
    minZoomDialog.style.left      = '50%';
    minZoomDialog.style.top       = '50%';
    minZoomDialog.style.transform = 'translateX(-50%) translateY(-50%)';

    minZoomDialog.style.display   = 'block';
    minZoomDialogVisible          = true;
  
    minZoomTitle.buttonDown0      = false;
       
    minZoomTitle.moveStart        = point_NaN;
    minZoomTitle.pStart           = point_NaN;
    
    minZoomInput.value = numToString(settings.minZoomForParams * 100, -1) + '%';
    minZoomInput.select();

    window.setTimeout(() => document.getElementById('minZoomInput').focus(), 0);
}



function hideMinZoomDialog()
{
    minZoomDialog.style.display = 'none';
    minZoomDialogVisible        = false;
}



minZoomClose.addEventListener('pointerdown', e => e.stopPropagation());



minZoomTitle.addEventListener('pointerdown', e => 
{
    minZoomTitle.setPointerCapture(e.pointerId);
    minZoomTitle.buttonDown0 = true;

    minZoomTitle.moveStart = point(minZoomDialog.offsetLeft, minZoomDialog.offsetTop);
    minZoomTitle.pStart    = point(e.clientX, e.clientY);
});



minZoomTitle.addEventListener('pointermove', e =>
{
    if (minZoomTitle.buttonDown0)
    {
        minZoomDialog.style.left = (minZoomTitle.moveStart.x + (e.clientX - minZoomTitle.pStart.x)) + 'px';
        minZoomDialog.style.top  = (minZoomTitle.moveStart.y + (e.clientY - minZoomTitle.pStart.y)) + 'px';
    }
});



minZoomTitle.addEventListener('pointerup', e =>
{
    minZoomTitle.buttonDown0 = false;
    minZoomTitle.releasePointerCapture(e.pointerId);
});



minZoomInput.addEventListener('keydown', e => 
{
    if (   (   e.key < '0' 
            || e.key > '9')
        &&  e.key != '.'
        &&  e.key != '%'
        &&  e.code != 'Backspace'
        &&  e.code != 'Delete'
        &&  e.code != 'Enter'
        &&  e.code != 'NumpadEnter'
        && !isArrowKey(e.code))
        e.preventDefault();    
        
        
    switch (e.code)
    {
        case 'Enter':
        case 'NumpadEnter':
        {
            const minZoom = parseFloat(minZoomInput.value.replace('%', ''));

            if (!isNaN(minZoom))
            {
                updateSetting('minZoomForParams', minZoom / 100);
                uiSetLocalData('minZoomForParams', settings.minZoomForParams);
                
                updateZoomIcon();
            }

            hideMinZoomDialog();
            break;
        }
    }
});



minZoomInput.addEventListener('pointerup', e =>
{
    e.stopPropagation();

    if (e.button == 2)
    {
        initTextMenu(minZoomInput);
        menuText.showAt(e.clientX, e.clientY, false, false);
    }
});



function setCursor(cursor, forceAsync = true)
{
    document.body.style.cursor = cursor;
    if (forceAsync) setTimeout(null, 0);
}



function setAutoCursor()
{
    if (graphView.zoomSelecting)
        setCursor(graphView.altDown 
                ? zoomOutCursor 
                : zoomInCursor);
    else if (graphView.spaceDown
          || panMode
          || graphView.panning)
        setCursor(panCursor);
    else
        setCursor('default'); // 'auto');
};


var productKey = NULL;



function onValidateClick(key)
{
    if (productKeyInput.disabled)
    {
        licenseInfo.innerHTML = '';

        validateProductKeyButton.innerHTML = 'Validate';

        productKeyInput.disabled = false
        productKeyInput.style.display = 'inline-block';

        setDefaultProductKeyInput();

        productKeyInput.focus();
        productKeyInput.select();

        licenseWatermark.style.display = 'none';
        licenseInfo.innerHTML = '';
    }
    else
    {
        tryValidateLicense(key);
    }
}



function removeLicense()
{
    productKey = NULL;
    uiSetLocalData('productKey', NULL);

    productKeyInputBack.innerHTML = ''.repeat(13);
    productKeyInput.value         = '';

    updateLicenseInfo();
    enableFeatures(false, settings.enableBetaFeatures);
}



function showProductKeyDialog()
{
    productKeyBack  .style.display = 'block';
    productKeyDialog.style.display = 'block';


    productKeyUserId.innerHTML = '<span style="user-select: none; color: var(--figma-color-bg-disabled-secondary);">User ID:&nbsp;&nbsp;</span>' + currentUser.id;
    
    
    const license = 
        productKey != NULL
        ? validateLicense(currentUser.id, productKey)
        : null;

    
    productKeyInputBack.innerHTML = license ? '' : ''.repeat(13);
    
    productKeyInput.value         = productKey;
    productKeyInput.disabled      = license;
    
    productKeyInput.style.display = license ? 'none' : 'inline'

    updateLicenseInfo(license);
    
    productKeyTextBack.style.display   = license ? 'none' : 'inline';
    validateProductKeyButton.innerHTML = license ? 'Edit' : 'Validate';


    if (license) setDisabledProductKeyInput();
    else         setDefaultProductKeyInput();
    
    window.setTimeout(() => document.getElementById('productKeyInput').focus(), 0);

    dialogShown = true;
}



function copyUserId()
{
    writeTextToClipboard(currentUser.id);
    selectElementText('productKeyUserId');
    uiNotify('Copied user ID');
}



function hideProductKeyDialog()
{
    productKeyBack  .style.display = 'none';
    productKeyDialog.style.display = 'none';

    dialogShown = false;
}



productKeyClose.addEventListener('pointerdown', e => e.stopPropagation());
productKeyBack.addEventListener('pointerdown', () => { hideProductKeyDialog(); });

productKeyInput.addEventListener('pointerdown', e => 
{ 
    if (!productKeyInput.disabled)
    {
        setDefaultProductKeyInput(); 

        const subscribed = 
               productKey != NULL
            && (      productKeyInput.selectionStart == productKeyInput.selectionEnd
                   && productKeyInput.value == productKey
                || getSelectedText(productKeyInput) == productKey);

        if (e.button == 2)
        {
            e.preventDefault();
            e.stopPropagation();

            updateElementDisplay(menuItemLicenseSep1  .div, subscribed);
            updateElementDisplay(menuItemLicenseRemove.div, subscribed);

            menuRemoveLicense.showAt(e.clientX, e.clientY, false, false);
        }
    }
});



productKeyInput.addEventListener('keydown', e =>
{
    if (e.code == 'Escape')
        productKeyInput.blur();

    e.stopPropagation();
});



productKeyInput.addEventListener('input', () =>
{
    let val = productKeyInput.value;
    
    val = val.toUpperCase();
    val = val.replace(/[^12345679ABCDEFGHJKLMNPQRSTUVWXYZ]/g, '');
    val = val.substring(0, Math.min(val.length, 13));
    
    productKeyInput.value = val;

    updateProductKeyDots();
});



function updateProductKeyDots()
{
    productKeyInputBack.innerHTML = 
          '&nbsp;'.repeat(productKeyInput.value.length)
        + ''.repeat(13 - productKeyInput.value.length);
}



function setBadProductKeyInput()
{
    productKeyInput.style.outline   = '2px dashed #e00';        
    productKeyTextBack.style.display = 'none';
}



function setDefaultProductKeyInput()
{
    productKeyInput.style.outline    = 'none';
    productKeyTextBack.style.display = 'inline';
}



function setDisabledProductKeyInput()
{
    productKeyInput.style.outline   = 'none';
}



function tryValidateLicense(key)
{
    let license;

    if (license = validateLicense(currentUser.id, key))
    {
        productKey = key;
        uiSetLocalData('productKey', key);

        enableFeatures(productKey != NULL, settings.enableBetaFeatures);
        
        setDisabledProductKeyInput();
        updateLicenseInfo(license);

        productKeyInput.disabled           = true;
        productKeyTextBack.style.display   = 'none';
        productKeyInput   .style.display   = 'none';

        validateProductKeyButton.innerHTML = 'Edit';

        uiNotify('Thank you for subscribing to Generator!', {delay: 6000});
    }
    else
    {
        setBadProductKeyInput();
    }
}



function updateLicenseInfo(license)
{
    if (license)
    {
        const strPrep =
                    license.lastYear
            + '-' + license.lastMonth.toString().padStart(2, '0')
            + '-' + license.lastDay  .toString().padStart(2, '0');

        const date    = new Date(Date.parse(strPrep));
        const strDate = date.toLocaleString('en-UK', {dateStyle: 'medium'});

        licenseWatermark    .style.display    = 'none';//'block';
        licenseWatermark    .style.outline    = '2px dashed var(--figma-color-text-disabled)';
        licenseWatermark    .style.background = 'transparent';//darkMode ? '#ffffff0f' : '#0000000a';
        licenseWatermarkPath.style.fill       = 'transparent';//darkMode ? '#2e2e2e50' : '#ffffff80';

        licenseInfo.innerHTML = '<span style="user-select: one; color: ' + (darkMode ? '#fffa' : '#000c') + ';">License valid until:&nbsp;&thinsp;</span><span style="font-weight: 700">' + strDate.replaceAll('/', '&hairsp;/&hairsp;') + '</span>';

        subscribeWebsite.style.display = 'none';
    }
    else
    {
        licenseWatermark.style.display = 'none';
        licenseInfo.innerHTML = '';

        subscribeWebsite.style.display = 'inline-block';
    }
}



function startupValidateLicense()
{
    if (!validateLicense(currentUser.id, productKey))
    {
        productKey = NULL;
        uiSetLocalData('productKey', NULL);
    }
}



var nextRequestId   =  0;
var lastRequestedId = -1;



function pushUpdate(action, nodes)
{
    pushUpdateFromParam(action, nodes, null);
}



function pushUpdateFromParam(action, nodes, param)
{
    // first check if any nodes to the left are uncached
    // and replace in update array as necessary

    for (let i = nodes.length-1; i >= 0; i--)
    {
        const node               = nodes[i];
        const uncachedInputNodes = node.getUncachedInputNodes();
        
        if (!isEmpty(uncachedInputNodes))
        {
            removeFromArray(nodes, node);

            pushUnique(nodes, uncachedInputNodes);

            for (const uncached of uncachedInputNodes)
                pushUnique(nodes, getTerminalsAfterNode(uncached));

            param = null;
        }
    }

    
    const set =
          ((settings.showAllColorSpaces ? 1 : 0) << 0)
        | ((settings.logRequests        ? 1 : 0) << 1);


    if (action)
        actionManager.updateActions.push(action);
        

    lastRequestedId = nextRequestId++;

    const request = 
    [
        lastRequestedId,
        action ? action.id : -1,
        set.toString()
    ];


    if (param) request.push(param.node.id, param.id);
    else       request.push(NULL, NULL);


    if (   !graphView.loadingNodes
        && !graphView.pastingNodes
        && !graphView.restoringNodes)
        nodes.forEach(n => n.invalidate());


    const terminals = [];
    nodes.forEach(n => pushUnique(terminals, getTerminalsAfterNode(n)));

    
    const uncachedInputNodes = [];
    terminals.forEach(n => pushUnique(uncachedInputNodes, n.getUncachedInputNodes()));
    uncachedInputNodes.forEach(n => pushUnique(terminals, getTerminalsAfterNode(n)));

    const progressNodes = [];
    nodes.forEach(n => pushUnique(progressNodes, getProgressNodesAfterNode(n)));


    // if (!isEmpty(progressNodes))
    // {
    //     //genMessages = [];
    //     uiPostMessageToGenerator({cmd: 'genStopGenerate'});
    // }


    const gen = createGenObject(
        param ? param.node : null,
        terminals);


    for (const node of terminals)
    {
        if (gen.passedNodes.includes(node))
            continue;

        request.push(...getNodeRequest(node, gen));
        
        pushUnique(gen.passedNodes, node);
    }


    for (const node of gen.paramNodes)
    {
        if (   !terminals.includes(node)
            && !gen.passedNodes.includes(node))
            request.push(...getNodeRequest(node, gen));
    }


    if (settings.logRawRequests)
        console.log(
            '%c%s%s', 
            'background: #60aa60; color: #cfd', 
            'raw request = ', 
            request.toString());


    uiQueueMessageToGenerator({
        cmd:     'genRequest',
        request:  request
    });
}



function pushInputOrParam(input, gen)
{
    if (    input.connectedOutput.param
        &&  gen.markParams
        &&  gen.scope.at(-1).nodeId != input.connectedOutput.node.id)
    {
        pushUnique(gen.paramNodes, input.connectedOutput.node);

        return [ PARAM,
                 input.connectedOutput.types[0],
                 input.connectedOutput.node.id,
                 input.connectedOutput.param.id ];
    }
    else
        return input.connectedOutput.genRequest(gen);
}



function getNodeRequest(node, gen)
{
    const request = [];


    if (!isEmpty(node.headerOutputs))
    {
        node.headerOutputs
            .forEach(o =>
            {
                const _r = o.genRequest(gen);
                const  r = [..._r];
                request.push(...r);
            });
    }
    else
    {
        request.push(...node.genRequest(gen));
    }


    return request;
}





function      uiGetLocalData(key)        { uiQueueMessageToFigma({ cmd:      'figGetLocalData', key: key               }); }
function      uiSetLocalData(key, value) { uiQueueMessageToFigma({ cmd:      'figSetLocalData', key: key, value: value }); }
function    uiClearLocalData(key)        { uiQueueMessageToFigma({ cmd:      'figSetLocalData', key: key, value: ''    }); }
function uiClearAllLocalData(key)        { uiQueueMessageToFigma({ cmd: 'figClearAllLocalData', key: key, value: ''    }); }

function       uiGetPageData(key)        { uiQueueMessageToFigma({ cmd:       'figGetPageData', key: key               }); } 
function       uiSetPageData(key, value) { uiQueueMessageToFigma({ cmd:       'figSetPageData', key: key, value: value }); }
function     uiClearPageData(key)        { uiQueueMessageToFigma({ cmd:       'figSetPageData', key: key, value: ''    }); }



// function saveToLocalFile(filename, str) 
// {
//     const link = document.createElement('a');
//     link.style.display = 'none';
    
//     link.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(str));
//     link.setAttribute('download', filename);
    
//     document.body.appendChild(link);
//     link.click();
//     document.body.removeChild(link);
// }



///////////////////////////////////////////////////////////////////////////////////////////////////
   


function uiReturnFigGetLocalData(msg)
{
    switch (msg.key)
    {
        case 'minZoomForParams':
            if (!isNaN(msg.value))
                updateSetting(msg.key, parseFloat(msg.value));
    
            break;

        case 'dataMode':
        case 'debugMode':

        case 'enableZoomedOutParams':
        case 'showPages':
        case 'showBoolValues':
        case 'showOperationResults':
        case 'showClearUndoWarning':
        case 'showDebugMenu':

        case 'showNodeId':       

        case 'showTooltipLongText':
        case 'showTooltipColorInterpolation':
        case 'showTooltipColorBlindness':
        case 'showTooltipColorContrast':

        case 'enableBetaFeatures':       

        case 'logMessages':      
        case 'logActions':       

        case 'logLoading':       
        case 'logRequests':      
        case 'logValueUpdates':  
        case 'logObjectUpdates': 
        case 'logStyleUpdates': 

        case 'logRawLoadPages':    
        case 'logRawLoadNodes':    
        case 'logRawLoadConnections':    

        case 'logRawSavePages': 
        case 'logRawSaveNodes': 
        case 'logRawSaveConnections': 

        case 'logRawRequests':   
        case 'logRawValues':     
            updateSettingAndMenu(
                msg.key, 
                msg.value, 
                msg.value 
                    ? parseBool(msg.value) 
                    : false,
                false); 

            break;

        case 'showWhatsNew':
            if (  !msg.value
                || parseInt(msg.value) < generatorVersion)
                showWhatsNewDialog();

            break;
    }


    if (    msg.key == 'dataMode'
        && !generatorStarted)
    {
        if (settings.dataMode)
        {
            dataModeView.style.display = 'block';
            initDataModeMenus();
        }
        else
            initGeneratorMenus();
     
        
        onClassChange(document.childNodes[0], () =>
        { 
            initThemeColors();

            updateLicenseInfo(
                productKey != NULL
                ? validateLicense(currentUser.id, productKey)
                : null);
           
            if (!settings.dataMode)
            {
                graph.nodes.forEach(n => n.updateNode());
                graphView.updateNodeWireTransforms(graph.nodes);
            }
        });
    }


    if (!settings.dataMode)
    {
        if (msg.key == 'enableBetaFeatures')
            enableFeatures(true, settings.enableBetaFeatures); 

        if (msg.key == 'showDebugMenu')
            updateMenuItemShowDebugMenu();
    }

    
    if (   msg.key == 'logLoading'
        && settings.logLoading)
        uiLogAllSavedNodesAndConns();
}



function uiReturnFigGetPageData(msg)
{
    // switch (msg.key)
    // {
    // }
}



///////////////////////////////////////////////////////////////////////////////////////////////////



function uiReturnFigLoadNodesAndConns(msg)
{
    if (settings.logRawLoadNodes)
    {
        for (const json of msg.nodeJson)
        {
            console.log(
                '%cnodes JSON = %s', 
                'background: #fed; color: black;',
                json.replaceAll('\\n', '\n')
                    .replaceAll('\\"', '"'));
        }
    }


    if (settings.logRawLoadConnections)
    {
        for (const json of msg.connJson)
        {
            console.log(
                '%cconnections JSON = %s', 
                'background: #fed',
                json.replaceAll('\\n', '\n')
                    .replaceAll('\\"', '"'));
        }
    }

    
    //const _graphView          = msg.graphView;
    const _showAllColorSpaces = msg.showAllColorSpaces;


    updateSettingAndMenu(
        'showAllColorSpaces',
        _showAllColorSpaces, 
        _showAllColorSpaces ? parseBool(_showAllColorSpaces) : false,
        false); 


    graphView.loadingNodes   = true;
    graphView.canUpdateNodes = false;


    if (!isEmpty(msg.pageKeys))
    {
        if (settings.logRawLoadPages)
        {
            for (const json of msg.pageJson)
            {
                console.log(
                    '%cpages JSON = %s', 
                    'background: #fee; color: black;',
                    json.replaceAll('\\n', '\n')
                        .replaceAll('\\"', '"'));
            }
        }

        const pages = [];

        for (let i = 0; i < msg.pageKeys.length; i++)
        {
            const page = new GraphPage();
            page.load(msg.pageJson[i]);
            pages.push(page);
        }

        for (const id of msg.pageOrder)
            graph.addPage(pages.find(p => p.id == id));

        if (msg.currentPageId != NULL)
            graph.pageIndex = graph.pages.findIndex(p => p.id == msg.currentPageId);
    }
    else
    {
        graph.createPage('Graph');
        graph.updateSavedPages();
    }



    if (!settings.dataMode)
        graphView.updatePanAndZoom(true);


    let _pageKeys  = msg.pageKeys;
    let _pages     = msg.pageJson;

    let _nodeKeys  = msg.nodeKeys;
    let _nodes     = msg.nodeJson;

    let _connKeys  = msg.connKeys;
    let _conns     = msg.connJson;

    
    const _p = [];
    const _n = [];
    const _c = [];

    for (let i = 0; i < _pages.length; i++) _p.push({key: _pageKeys[i], value: _pages[i]});
    for (let i = 0; i < _nodes.length; i++) _n.push({key: _nodeKeys[i], value: _nodes[i]});
    for (let i = 0; i < _conns.length; i++) _c.push({key: _connKeys[i], value: _conns[i]});
    

    _n.sort((a, b) => a.value.z - b.value.z);


    if (settings.dataMode)
    {
        menuBar.style.display = 'none';

        loadNodesAndConnsData(_p, _n, _c);
    }
    else
    {
        _nodes = _nodes.map(n => JSON.parse(n));
        _conns = _conns.map(c => JSON.parse(c));
            
        graph.clear();

        loadNodesAndConnsAsync(_nodes, _conns, setLoadingProgress);
    }
}



function setLoadingProgress(progress)
{
    if (graphView.loadingNodes) 
        progress *= 0.7;

    loadingProgress.style.width = (progress * 100) + '%';
}



function loadNodesAndConnsAsync(_nodes, _conns, setProgress)
{
    loadingProgress.style.width   = 0;
    loadingOverlay .style.display = 'block';


    let promise = Promise.resolve([]);


    _nodes = _nodes.sort((a, b) => a.type == GROUP_NODE && b.type != GROUP_NODE);


    const chunkSize = 10; // nodes

    for (let i = 0; i < _nodes.length; i += chunkSize)
    {
        restartLoadingTimer();
        
        promise = promise.then(nodes => 
        {
            const res = resolveNodes(
                _nodes, 
                i, 
                Math.min(i + chunkSize, _nodes.length), // exclusive
                nodes,
                false);

            setProgress(i / (_nodes.length + (_conns ? _conns.length : 0)));
            return res;
        });
    }


    promise.then(nodes => 
    {
        graph.addNodes(nodes, false, false);
        loadConnectionsAsync(_nodes, _conns, nodes, setProgress);    
    });
}



function loadConnectionsAsync(_nodes, _conns, loadedNodes, setProgress)
{
    let promise = Promise.resolve([]);


    if (_conns)
    {
        // variable inputs connections must be sorted by input index
        // as well as connection position left to right

        _conns.sort((c1, c2) => 
        {
            if (c1.inputNodeId != c2.inputNodeId ) return c1.inputNodeId < c2.inputNodeId ? -1 : 1;
            if (c1.inputId     != c2.inputId     ) return c1.inputId     < c2.inputId     ? -1 : 1;
            
            if (c1.inputNodeId == c2.outputNodeId) return -1;
            if (c2.inputNodeId == c1.outputNodeId) return  1;

            return 0;
        });
        

        // first resolve group parameter connections,
        // as they create inputs and outputs in other nodes
        
        restartLoadingTimer();


        const _paramConns = _conns.filter(c => 
               nodeFromId(c. inputNodeId).type == GROUP_PARAM
            || nodeFromId(c.outputNodeId).type == GROUP_PARAM);

        const _otherConns = _conns.filter(c => !_paramConns.includes(c));

        
        const chunkSize = 10; // connections

        for (let i = 0; i < _paramConns.length; i += chunkSize)
        {
            promise = promise.then(() => 
            {
                const res = resolveConnections(
                    _nodes,
                    _paramConns, 
                    i, 
                    Math.min(i + chunkSize, _paramConns.length)); // exclusive

                return res;
            });
        }

        for (let i = 0; i < _otherConns.length; i += chunkSize)
        {
            promise = promise.then(() => 
            {
                const res = resolveConnections(
                    _nodes,
                    _otherConns, 
                    i, 
                    Math.min(i + chunkSize, _otherConns.length)); // exclusive

                setProgress((_nodes.length + i) / nozero(_nodes.length + _otherConns.length * 19/20)); // the proportion is arbitrary
                return res;
            });
        }
    }


    promise.then(() => 
    {
        const updateNodes = [];
        
        finishLoadingNodes(_nodes, loadedNodes, updateNodes);
        finishLoading(_nodes);
        
        pushUpdate(null, updateNodes);
    });
}



function finishLoading(_nodes)
{
    if (isEmpty(_nodes))
    {
        clearTimeout(loadRestartTimer);
        loadRestartTimer = -1;

        loadingOverlay.style.display = 'none';
    }


    graphView.canUpdateNodes = true;
    graphView.updateShowWires(false);

    generatorStarted = true;


    enableFeatures(productKey != NULL, settings.enableBetaFeatures); 
    
    graphView.update();

    
    window.focus();
}



function finishLoadingNodes(_nodes, loadedNodes, updateNodes, duplicates = false)
{
    _nodes
        .filter(_n => _n.active)
        .map   (_n => nodeFromId(duplicates ? _n.newId : (pageIdFromPath(_n.id) == NULL ? makeNodePath(_n.id) : _n.id)))
            .forEach(n => n.makeActive());

    updateTerminalsAfterNodes(loadedNodes, updateNodes);
}



function resolveNodes(_nodes, first, last, nodes, pasting)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
                nodes.push(loadNode(_nodes[i], pasting));

            resolve(nodes);
        }));
}



function resolveConnections(nodes, _connections, first, last)
{
    return new Promise(resolve => 
        requestAnimationFrame(() => 
        {
            for (let i = first; i < last; i++)
            {
                const _conn = _connections[i];

                const outputNode = nodes.find(n => (n.newId ?? n.id) == _conn.outputNodeId);
                const  inputNode = nodes.find(n => (n.newId ?? n.id) == _conn. inputNodeId);


                const strConn = connToString(_conn);

                if (!outputNode)
                { 
                    uiError(
                        'Cannot connect' + strConn + ',\'' + _conn.outputNodeId + '\' not found', 
                        {
                            buttonText:   'Remove connection',
                            buttonAction: 'removeConnection,' + getStorageConnKey(_conn)
                        });

                    continue; 
                }

                if (!inputNode) 
                { 
                    uiError(
                        'Cannot connect' + strConn + ',\'' + _conn.inputNodeId + '\' not found',
                        {
                            buttonText:   'Remove connection',
                            buttonAction: 'removeConnection,' + getStorageConnKey(_conn)
                        });
 
                    continue; 
                }


                parseConnectionJsonAndConnect(_conn, false);
            }

            resolve();
        }));
}



function loadNodes(data, pasting)
{
    const nodes = [];
    
    for (let i = 0; i < data.nodes.length; i++)
        nodes.push(loadNode(data.nodes[i], pasting));

    return nodes;
}



function loadNode(_node, pasting)
{
    const node = createNode(_node.type);
    node.div.style.display = 'none';


    node.loadFromParsedJson(_node, pasting);

    if (node.pageId == NULL)
        node.id = makeNodePath(node.id);

        
    node.setPosition(
        parseFloat(_node.x), 
        parseFloat(_node.y),
        false);

        
    return node;
}



function parseConnectionsAndConnect(data, pasteConnected, setProgress = null)
{
    data.connections.sort((c1, c2) =>
    {
        if (c1.outputOrder != c2.outputOrder) return c1.outputOrder - c2.outputOrder;
        if (c1.inputNodeId != c2.inputNodeId) return c1.inputNodeId - c2.inputNodeId;
        if (c1.inputId     != c2.inputId    ) return c1.inputId     - c2.inputId;
        return 0;
    });


    const connections = [];
    
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];
        
        if (      data.nodes.find(n => (n.newId ?? n.id) == _conn.outputNodeId)
               && data.nodes.find(n => (n.newId ?? n.id) == _conn. inputNodeId)
            || pasteConnected)
        {
            parseConnectionJsonAndConnect(_conn, pasteConnected);
            connections.push(_conn);
        }

        if (setProgress)
            setProgress(((data.nodes.length + i) / (data.nodes.length + data.connections.length)));
    }


    return connections;
}



// function uiSaveGraphView()
// {
//     uiSetPageData(currentUser.id + ',graphView', graphView.toJson());
// }



function dataColorToJson(color, nTab)
{
    let   pos = ' '.repeat(nTab);
    const tab = HTAB;

    let json =
          pos + tab + '[\n'
        + pos + tab + tab + '"'+color[0] +'",\n'
        + pos + tab + tab +     color[1] + ',\n'
        + pos + tab + tab +     color[2] + ',\n'
        + pos + tab + tab +     color[3] +  '\n'
        + pos + tab + ']';

    return json;
}


var tooltipTimer    = -1;
var tooltipOutTimer = -1;

var inTooltip = null;


var currentTooltipSource = null;
var currentTooltip       = null;

    

function createTooltipSrc(source, ref, getTooltip)
{
    source.addEventListener('pointerenter', () =>
    {
        if (tooltipTimer >= 0) 
            clearTimeout(tooltipTimer);


        if (tooltipTimer < 0)
        {
            tooltipTimer = setTimeout(() =>
            {
                const tooltip = getTooltip();

                if (tooltip) 
                    showTooltip(ref, tooltip);

                tooltipTimer = -1;
            }, 
               currentTooltip 
            && currentTooltip != getTooltip() 
            ? 0 
            : 1000);
        }
    });
      
    
    source.addEventListener('pointerleave', () =>
    {
        if (tooltipTimer >= 0)
        {
            clearTimeout(tooltipTimer);
            tooltipTimer = -1;
        }
    
        
        if (tooltipOutTimer >= 0)
            clearTimeout(tooltipOutTimer);
        
    
        tooltipOutTimer = setTimeout(() => 
        {
            if (currentTooltip) 
                hideTooltip(currentTooltip);
    
            currentTooltipSource = null;
    
            tooltipOutTimer      = -1;
        }, 
        400);
    });
}



function createTooltip(tooltip)
{
    tooltip.trap = false;
    

    tooltip.addEventListener('pointerenter', () => inTooltip = tooltip);
    tooltip.addEventListener('pointerleave', () => inTooltip = null   );


    hideTooltip(tooltip);
}



function createTooltipPointerTrap(tooltip)
{
    tooltip.addEventListener('pointerenter', e =>
    {
        //if (tooltipOutTimer >= 0)
        //{
            clearTimeout(tooltipOutTimer);
            tooltipOutTimer = -1;
        //}
    });

    
    tooltip.addEventListener('pointerleave', e =>
    {
        // if (tooltipOutTimer < 0)
        //     hideTooltip(tooltip);

        if (tooltipTimer >= 0)
        {
            clearTimeout(tooltipTimer);
            tooltipTimer = -1;
        }


        tooltipOutTimer = setTimeout(() => 
        {
            if (currentTooltip) 
                hideTooltip(currentTooltip);

            currentTooltipSource = null;

            tooltipOutTimer      = -1;
        }, 
        400);
    });
}



function showTooltip(source, tooltip)
{
    if (!isEmpty(currentMenus))
        return;

        
    if (   currentTooltip
        && currentTooltip != tooltip)
        hideTooltip(currentTooltip);


    tooltip     .style.display = 'block';
    tooltip     .style.opacity = '100%';

    tooltipArrow.style.display = 'block';
    tooltipArrow.style.opacity = '100%';

    let srcRect = source.getBoundingClientRect();

    srcRect.y -= 5;


    const margin = 10;
 
    tooltip.style.left = Math.min(Math.max(
        margin, 
        srcRect.x + srcRect.width/2 - tooltip.offsetWidth/2), 
        graphView.div.offsetWidth - tooltip.offsetWidth - margin);

    tooltipArrow.style.left = srcRect.x + srcRect.width/2;// - tooltipArrow.offsetWidth/2;

    
    const graphHeight = graphView.div.offsetHeight - getTopHeight();


    let top = srcRect.y;

    if (srcRect.y + tooltip.offsetHeight > graphView.div.offsetHeight-8)
        top = getTopHeight() + Math.max(8, graphHeight - tooltip.offsetHeight);
        
    tooltip.style.top = top + srcRect.height + tooltipArrow.offsetHeight - 3;
    
    
    const ttRect = tooltip.getBoundingClientRect();

    
    if (ttRect.bottom > graphView.div.offsetHeight + getTopHeight() - 8)
    {
        tooltipArrow.style.borderColor = '#1e1e1e transparent transparent transparent';
        tooltipArrow.style.top         = srcRect.y;

        tooltip.style.top = srcRect.y - ttRect.height + 1;
    }
    else
    {
        tooltipArrow.style.borderColor = 'transparent transparent #1e1e1e transparent';
        tooltipArrow.style.top         = ttRect.y - tooltipArrow.offsetHeight + 1;
    }


    // const graphHeight = graphView.div.offsetHeight - getTopHeight();

    // if (top + tooltip.offsetHeight > graphView.div.offsetHeight-8)
    //     top = getTopHeight() + Math.max(8, graphHeight - tooltip.offsetHeight);

    // tooltip.style.top = top;

    
    currentTooltip = tooltip;
}



function hideTooltip(tooltip)
{
    tooltip     .style.display = 'none';
    tooltip     .style.opacity = '0%';

    tooltipArrow.style.display = 'none';
    tooltipArrow.style.opacity = '0%';

    clearTimeout(tooltipTimer);
    clearTimeout(tooltipOutTimer);

    tooltipTimer   = -1;
    currentTooltip = null;
}


function updateZoomTooltip()
{
    if (graph.currentPage.zoom < settings.minZoomForParams)
    {
        ttMinValueZoom.innerHTML =
              '<p style="margin-top: 1px; width: 100%; text-align: center; position: relative; left: -2px;">Zoom/view options</p>'
            + '<p style="margin-top: 1.25em">'
            + '    An outline around the zoom means<br/>'
            + '    that value controls are too small<br/>'
            + '    to be adjusted and the whole node<br/>'
            + '    is moved instead.'
            + '</p>'
            + '<p style="margin-top: 1.25em">The threshold can be set in the<br/>preferences menu.</p>';

        ttMinValueZoom.style.height = '130px';
    }
    else
    {
        ttMinValueZoom.innerHTML = 'Zoom/view options';
        ttMinValueZoom.style.height = '15px';
    }
}


// function initPermanentTooltip(tooltip)
// {
//     tooltip.addEventListener('pointerenter', e =>
//     {
//         e.preventDefault();
//         e.stopImmediatePropagation();

//         clearTimeout(tooltipOutTimer);
//         tooltipOutTimer = null;
//     });
    
    
    
//     tooltip.addEventListener('pointerleave', e =>
//     {
//         e.preventDefault();
//         e.stopImmediatePropagation();

//         if (!tooltipOutTimer)
//             hideTooltip(tooltip);
//     });
// }



function initTextTooltip(str)
{
    ttTextString.innerHTML = str;
}



createTooltip(ttText);
createTooltip(ttWcag2);
createTooltip(ttWcag3);
createTooltip(ttInterpolationSpace);
createTooltip(ttColorblind);

//createTooltipPointerTrap(ttText);
createTooltipPointerTrap(ttWcag2);
createTooltipPointerTrap(ttWcag3);
createTooltipPointerTrap(ttInterpolationSpace);
createTooltipPointerTrap(ttColorblind);



// menuSelect.addEventListener('change', async function(e) 
// {
//     switch (e.detail.selectedValue)
//     {
//         case 'saveLocal':  saveToLocalFile('graph.json'); break;
//         case 'loadLocal':  loadFromLocalFile();           break;
//         case 'duplicate':  console.log(graph.toJson());     break;
//         case 'productKey': showProductKeyDialog();        break;
//     }
// });



productKeyClose.addEventListener('click', e =>
{
    hideProductKeyDialog();
});



// btnToggleWires.addEventListener('pointerenter', () => { btnToggleWires.mouseOver = true;  updateToggleShowWiresButton(); });
// btnToggleWires.addEventListener('pointerleave', () => { btnToggleWires.mouseOver = false; updateToggleShowWiresButton(); });


var requestObjects = [];



function createNode(nodeType, creatingButton = null, createdNodeId = -1, options = {})
{
    let node;
 
    switch (nodeType)
    {
        case LIST:                    node = new OpList();              break;
        case LIST_EXPAND:             node = new OpExpandList();        break;
        case ITEMS:                   node = new OpItems();             break;
        case SELECT:                  node = new OpSelect();            break;
        case LIST_COUNT:              node = new OpListCount();         break;
        case IF_ELSE:                 node = new OpIfElse();            break;
        case START:                   node = new OpStart();             break;
        case REPEAT:                  node = new OpRepeat();            break;
        case CACHE:                   node = new OpCache();             break;
        case COPY:                    node = new OpCopy();              break;
      
        case NUMBER:                  node = new OpNumber();            break;
        case NUMBER_SIGN:             node = new OpSign();              break;
        case NUMBER_ABSOLUTE:         node = new OpAbsolute();          break;
        case NUMBER_ROUND:            node = new OpRound();             break;
        case NUMBER_LIMITS:           node = new OpLimits();            break;
        case NUMBER_RANDOM:           node = new OpRandom();            break;
        case NUMBER_SERIES:           node = new OpSeries();            break;
        case NUMBER_INTERPOLATE:      node = new OpInterpolate();       break;
        case NUMBER_TO_TEXT:          node = new OpNumberToText();      break;
        case NUMBER_SOLVE:            node = new OpSolve();             break;
        case NUMBER_ANIMATE:          node = new OpAnimate();           break;
             
        case NUMBER_MATH:             node = new OpMath();              break;
        case NUMBER_ADD:              node = new OpAdd();               break;
        case NUMBER_SUBTRACT:         node = new OpSubtract();          break;
        case NUMBER_MULTIPLY:         node = new OpMultiply();          break;
        case NUMBER_DIVIDE:           node = new OpDivide();            break;
        case NUMBER_MODULO:           node = new OpModulo();            break;
        case NUMBER_EXPONENT:         node = new OpExponent();          break;
             
        case NUMBER_BOOLEAN:          node = new OpBoolean();           break;
        case NUMBER_NOT:              node = new OpNot();               break;
        case NUMBER_AND:              node = new OpAnd();               break;
        case NUMBER_OR:               node = new OpOr();                break;
        case NUMBER_XOR:              node = new OpXor();               break;
         
        case NUMBER_CONDITION:        node = new OpCondition();         break;
        case NUMBER_EQUAL:            node = new OpEqual();             break;
        case NUMBER_NOT_EQUAL:        node = new OpNotEqual();          break;
        case NUMBER_LESS:             node = new OpLess();              break;
        case NUMBER_LESS_OR_EQUAL:    node = new OpLessOrEqual();       break;
        case NUMBER_GREATER:          node = new OpGreater();           break;
        case NUMBER_GREATER_OR_EQUAL: node = new OpGreaterOrEqual();    break;
         
        case TEXT:                    node = new OpText();              break;
        case TEXT_SUBSTRING:          node = new OpTextSubstring();     break;
        case TEXT_CHAR:               node = new OpTextCharacter();     break;
        case TEXT_REPLACE:            node = new OpTextReplace();       break;
        case TEXT_JOIN:               node = new OpTextJoin();          break;
        case TEXT_CSV:                node = new OpTextCSV();           break;
        case TEXT_FETCH:              node = new OpTextFetch();         break;
        
        case COLOR:                   node = new OpColor(options);      break;
        case VALID_COLOR:             node = new OpValidColor();        break;
        case CORRECT_COLOR:           node = new OpCorrectColor();      break;
        case COLOR_CONTRAST:          node = new OpColorContrast();     break;
        case COLORBLIND:              node = new OpColorBlind();        break;
        case COLOR_INTERPOLATE:       node = new OpColorInterpolate();  break;
        case COLOR_BLEND:             node = new OpColorBlend();        break;
             
        case COLOR_STOP:              node = new OpColorStop();         break;
        case GRADIENT:                node = new OpGradient();          break;
      
        case FILL:                    node = new OpFill();              break;
        case STROKE:                  node = new OpStroke();            break;

        case COLOR_STYLE:             node = new OpColorStyle(options); break;
     
        case RECTANGLE:               node = new OpRectangle();         break;
        case LINE:                    node = new OpLine();              break;
        case ELLIPSE:                 node = new OpEllipse();           break;
        case POLYGON:                 node = new OpPolygon();           break;
        case STAR:                    node = new OpStar();              break;
        case TEXTSHAPE:               node = new OpTextShape();         break;
      
        case GROUP_NODE:              node = new OpGroupNode();         break;
        case GROUP_PARAM:             node = new OpGroupParam();        break;

        case COMMENT:                 node = new OpComment();           break;
     
        default:                      console.assert(false, 'Graph.js/createNode() cannot create type ' + nodeType);
    }
    
    node._creatingButton = creatingButton;

    return node;
}



function idFromNode(node)
{
    return node ? node.id : '';
}



function nodesToJson(nodes, encloseBraces = true, connOutputMustBeInNodes = true)
{
    const tab = HTAB;
    
    let json = 
          (encloseBraces ? '{\n' : '')
          + tab + '"nodes":\n'
          + tab + '[';

    let first = true;
    for (let i = 0; i < nodes.length; i++)
    {
        if (!first) json += ','; first = false;

        nodes[i].stripIdForCopy = true;
        json += NL + nodes[i].toJson(4);
    }

    json += NL + tab + ']';
    json += connectionsToJson(nodes, connOutputMustBeInNodes);
    json += (encloseBraces ? '\n}' :'');

    return json;
}



function connectionsToJson(nodes, connOutputMustBeInNodes)
{
    const connections = [];


    for (let i = 0; i < nodes.length; i++)
    {
        let node = nodes[i];

        // if (node.variableInputs)
        //     continue;

        for (let j = 0; j < node.inputs.length; j++)
        {
            if (   !node.inputs[j].connected
                ||     connOutputMustBeInNodes
                   && !nodes.includes(node.inputs[j].connectedOutput.node))
                continue;

            connections.push(node.inputs[j].connection);
        }
    }
    

    if (isEmpty(connections))
        return '';


    const tab = HTAB;

    let json = 
          ',\n'
        + tab + '"connections":\n'
        + tab + '[';
    
    for (let i = 0; i < connections.length; i++)
    {
        if (i > 0) json += ',';

        connections[i].stripIdForCopy = true;
        json += NL + connections[i].toJson(4);
    }

    json += NL + tab + ']';

    return json;
}



function canAutoConnectNode(node)
{
    const selNode = graph.pageNodes.find(n => n.selected);

    if (  !selNode
        || isEmpty(selNode.headerOutputs))
        return false;

    const inputs = node.headerInputs.filter(i => i.canConnectFrom(selNode.headerOutputs[0]));

    return !isEmpty(inputs)
         && node.canAutoConnectFrom(selNode.headerOutputs[0]);
}



function uiDeleteNodes(nodeIds)
{
    nodeIds.forEach(id => nodeFromId(id).makePassive());

    graph.deleteNodes(nodeIds);

    uiRemoveSavedNodesAndConns(nodeIds);
    uiDeleteObjectsAndStyles(nodeIds, true);
}



function uiDeleteObjectsAndStyles(nodeIds, mustDelete = true)
{
    uiQueueMessageToFigma({
        cmd:       'figDeleteObjectsAndStyles',
        nodeIds:    nodeIds,
        mustDelete: mustDelete
    });
}



function uiCommitFigmaUndo()
{
    uiQueueMessageToFigma({cmd: 'figCommitUndo'});
}



function uiVariableConnect(outputNode, outputId, inputNode, inputId, outputOrder = -1)
{
    //console.log('uiVariableConnect()');

    const output = outputNode.outputFromId(outputId);
    return uiVariableConnectFromOutput(output, inputNode, inputId, outputOrder);
}



function uiVariableConnectFromOutput(output, inputNode, inputId, outputOrder = -1)
{
    //console.log('uiVariableConnectFromOutput()');

    const input = inputNode.inputFromId( inputId);


    if (    inputNode.variableInputs
        && (!input || !input.param))
    {
        const conn = uiConnect(
            output,
            inputNode.headerInputs.at(-1),
            inputId,
            outputOrder);

        if (outputOrder > -1)
            conn.outputOrder = outputOrder;

        if (   !graphView.loadingNodes
            && !graphView.pastingNodes
            && !graphView.restoringNodes)
            uiUpdateSavedConnectionsToNodeId(inputNode.id, true);

        return conn;
    }
    else
        return uiConnect(output, input, '', outputOrder);
}



function uiConnect(output, input, inputId = '', outputOrder = -1)
{
    return output.node.graph.connect(output, input, inputId, outputOrder);
}



function uiDisconnect(input, saveOld = true)
{
    //console.log('uiDisconnect()');
    
    const node = input.node;

    node.graph.disconnect(input);

    if (node.variableInputs)
        uiUpdateSavedConnectionsToNodeId(node.id, saveOld);
}



function uiDisconnectAny(input)
{
    //console.log('uiDisconnect()');
    
    uiDeleteSavedConnectionsToNodeId(input.node.id);

    input.node.graph.disconnect(input);
}



function uiUpdateSavedConnectionsToNodeId(nodeId, saveOld)
{
    const node = nodeFromId(nodeId);


    uiDeleteSavedConnectionsToNodeId(node.id);


    if (saveOld)
    {
        for (const input of node.inputs.filter(i => i.connected))
        {
            uiSaveConnection(
                input.connectedOutput.node.id,
                input.connectedOutput.id,
                input.connection.outputOrder,
                node .id,
                input.id,
                input.connection.toJson());
        }
    }
}



function uiUpdateSavedConnectionsFromNodeId(nodeId, saveOld)
{
    const node = nodeFromId(nodeId);


    uiDeleteSavedConnectionsFromNodeId(node.id);


    if (saveOld)
    {
        for (const output of node.outputs)
        {
            for (const input of output.connectedInputs)
            {
                uiSaveConnection(
                    output.node.id,
                    output.id,
                    input.connection.outputOrder,
                    input.node.id,
                    input.id,
                    input.connection.toJson());
            }
        }
    }
}



function makeSelectedNodesActive()
{
    if (graphView.selectedNodes.find(n => !n.active))
        actionManager.do(new MakeActiveNodesAction(graphView.selectedNodes.map(n => n.id)));
}



function uiMakeNodeActive(node)
{
    uiMakeNodeLeftPassive (node);
    uiMakeNodeRightPassive(node);

    node.makeActive();
}    



function uiMakeNodesActive(nodes)
{
    for (const node of nodes)
    {
        if (node.active) continue;

        uiMakeNodePassive(node);
        uiMakeNodeLeftPassive (node);
        uiMakeNodeRightPassive(node);
    }

    for (const node of nodes)
    {
        if (node.active) continue;
        
        pushUnique(graphView.activeNodes, node);
        node._active = true;
    }
}



function uiMakeNodePassive(node)
{
    if (node.active)
        node.makePassive();
}



function uiMakeNodeLeftPassive(node, fromNode = null)
{
    for (const input of node.headerInputs)
    {
        if (    input.connected
            && !input.connectedOutput.param
            && (  !fromNode
                || input.connectedOutput.node != fromNode))
        {
            uiMakeNodePassive(input.connectedOutput.node);
            uiMakeNodeLeftPassive(input.connectedOutput.node, node);
        }
    }
}



function uiMakeNodeRightPassive(node, fromNode = null)
{
    for (const output of node.headerOutputs)
    {
        for (const connInput of output.connectedInputs.filter(i => !i.param))
        {
            uiMakeNodePassive(connInput.node);
            uiMakeNodeRightPassive(connInput.node, node);
        }
    }

    //uiMakeNodeLeftPassive(node, fromNode);//
}



function uiShowParamValue(nodeId, paramName, value)
{
    const node = nodeFromId(nodeId);

    if (!!node) // this is for deleted nodes which still exist
    {           // in genGraph but no longer in graph
        const param = node.params.find(p => p.name == paramName);
        param.controls[0].setValue(value, false);
    }
}



function uiCopyNodes(nodeIds)
{
    const nodes      = graph.nodes.filter(n => nodeIds.includes(n.id));
    const copiedJson = nodesToJson(nodes, true, false);

    // console.log(copiedJson);

    return copiedJson;
}



function uiPasteNodes(nodesJson, pasteConnected, x, y, updateNodes)
{
    //console.log(nodesJson);

    graphView.pastingNodes = true;


    pasteOffset.x += pasteOffsetDelta.x;
    pasteOffset.y += pasteOffsetDelta.y;


    const data = JSON.parse(nodesJson);


    if (   !isNaN(x) 
        && !isNaN(y)) // position new nodes
    {
        const positions = data.nodes.map(n => point(parseFloat(n.x), parseFloat(n.y)));

        for (let i = 0; i < data.nodes.length; i++)
        {
            data.nodes[i].x = x + positions[i].x - positions[0].x + 5 / graph.currentPage.zoom;
            data.nodes[i].y = y + positions[i].y - positions[0].y;
        }
    }
    else // offset new nodes (must be done before loading)
    {
        for (let i = 0; i < data.nodes.length; i++)
        {
            data.nodes[i].x = parseFloat(data.nodes[i].x) + pasteOffset.x;
            data.nodes[i].y = parseFloat(data.nodes[i].y) + pasteOffset.y;
        }
    }


    // if new nodes are outside of viewport, move them to center of viewport

    // const viewRect = graphView.measureData.clientRect;

    // let l = Number.MAX_SAFE_INTEGER;
    // let t = Number.MAX_SAFE_INTEGER;
    // let r = Number.MIN_SAFE_INTEGER;
    // let b = Number.MIN_SAFE_INTEGER;
    
    // for (let i = 0; i < data.nodes.length; i++)
    // {
    //     console.log('data.nodes[i] =', data.nodes[i]);

    //     l = Math.min(l, data.nodes[i].x);
    //     t = Math.min(t, data.nodes[i].y);
    //     r = Math.max(r, data.nodes[i].x + data.nodes[i].width);
    //     b = Math.max(b, data.nodes[i].y + data.nodes[i].height);
    // }
    
    // console.log('l =', l);
    // console.log('t =', t);
    // console.log('r =', r);
    // console.log('b =', b);

    // if (   l >  viewRect.r 
    //     || t >  viewRect.b 
    //     || r <= viewRect.l
    //     || b <= viewRect.t)
    // {
    //     const cx = (l + r) / 2;
    //     const cy = (t + b) / 2;
        
    //     const vx = viewRect.c;
    //     const vy = viewRect.m;
        
    //     for (let i = 0; i < data.nodes.length; i++)
    //     {
    //         data.nodes[i].x -= vx - cx;
    //         data.nodes[i].y -= vy - cy;

    //         console.log('data.nodes[i] =', data.nodes[i]);
    //     }
    // }


    const nodes = loadNodes(data, true);
    nodes.forEach(n => n.div.style.display ='none');

    
    // get the new names of the nodes after they've been added
    for (let i = 0; i < nodes.length; i++)
    {
        graph.addNode(nodes[i], false);
        data.nodes[i].newId = nodes[i].id;
    }


    if (data.connections)
    {
        correctNodeNamesInConnections(data);
        data.connections = parseConnectionsAndConnect(data, pasteConnected);
    }
    else
        data.connections = []; // return an empty array if no data was loaded


    graphView.selectedNodes = nodes;


    finishLoadingNodes(data.nodes, nodes, updateNodes, true);


    return [nodes, data.connections];
}



function correctNodeNamesInConnections(data)
{
    for (let i = 0; i < data.connections.length; i++)
    {
        const _conn = data.connections[i];

        let outputNode = data.nodes.find(n => n.id == _conn.outputNodeId);
        if (outputNode) data.connections[i].outputNodeId = outputNode.newId;

        const inputNode = data.nodes.find(n => n.id == _conn.inputNodeId);

        data.connections[i].inputNodeId = inputNode.newId;
    }

    for (let i = 0; i < data.nodes.length; i++)
    {
        const _node = data.nodes[i];

        if (_node.newId && _node.newId != _node.id)
            _node.id = _node.newId;
    }
}



function updateGraphNodes()
{
    [...graphView.selectedNodes,     
     ...graphView._prevSelectedNodes,
     ...graphView.lastSelectedNodes]
       .forEach(n => n.updateNode());
}



function findConnectedClusters(nodes)
{
    let clusters = nodes.map(n => [n]);
    let first    = 0;


    while (true)
    {
        let moved = false;
        
        for (let i = clusters.length-1; i > first; i--)
        {
            if (clusters[i].at(0).immediatelyFollows(clusters[i-1].at(-1), true))
            {
                clusters[i-1].push(...clusters[i]);
                removeAt(clusters, i);
                moved = true;
            }
            else if (clusters[i-1].at(-1).immediatelyFollows(clusters[i].at(0)), true)
            {
                clusters[first] = [...clusters[i], ...clusters[i-1]];
                removeAt(clusters, i);
                moved = true;
            }
        }

        first++;

        if (  !moved
            || first >= clusters.length)
            break;
    }


    return clusters;
}



function uiUpdateValuesAndObjects(requestId, actionId, updateNodeId, updateParamId, values, objects, styles, updatedNodes, totalNodes, isLastChunk)
{
    // console.log('requestId =',       requestId);
    // console.log('lastRequestedId =', lastRequestedId);


    if (requestId < lastRequestedId) 
        return;
    
    lastRequestedId = -1;

        
    if (loadRestartTimer > -1)
    {
        clearTimeout(loadRestartTimer);
        loadRestartTimer = -1;
    }


    if (settings.logRawValues)  
        console.log('raw values = ', values);

    if (settings.logValueUpdates)  
        logValueUpdates(updateNodeId, updateParamId, values);


    const nodes = [];

    let i = 0;
    while (i < values.length)
    {
        const nodeId = values[i++];
        const count  = values[i++];

        const node   = nodeFromId(nodeId);


        if (node)
            pushUnique(nodes, node);


        if (count > 0)
        {
            const _ids    = [];
            const _values = [];


            for (let j = 0; j < count; j++)
            {
                const id   = values[i++];
                const type = values[i++];

                _ids.push(id);

                let value;

                switch (type)
                {
                    case    NUMBER_VALUE:  value = parseNumberValue   (values[i++])[0];  break;
                    case      TEXT_VALUE:  value = parseTextValue     (values[i++])[0];  break;
                    case     COLOR_VALUE:  value = parseColorValue    (values[i++])[0];  break;
                    case      FILL_VALUE:  value = parseFillValue     (values[i++])[0];  break;
                    case    STROKE_VALUE:  value = parseStrokeValue   (values[i++])[0];  break;
                    case RECTANGLE_VALUE:  value = parseRectangleValue(values[i++])[0];  break;
                    case      LINE_VALUE:  value = parseLineValue     (values[i++])[0];  break;
                    case   ELLIPSE_VALUE:  value = parseEllipseValue  (values[i++])[0];  break;
                    case   POLYGON_VALUE:  value = parsePolygonValue  (values[i++])[0];  break;
                    case      STAR_VALUE:  value = parseStarValue     (values[i++])[0];  break;
                    case TEXTSHAPE_VALUE:  value = parseTextShapeValue(values[i++])[0];  break;
                    case      LIST_VALUE:  value = parseListValue     (values[i++])[0];  break;
                    
                    default: console.assert(false, 'unknown type \'' + type + '\'');
                }

                if (value.nodeId)
                    value.nodeId = nodeId; 
    
                _values.push(value);
            }


            if (node)
            {
                node.updateValues( 
                    requestId,
                    actionId,
                    updateNodeId == nodeId ? updateParamId : '',
                    _ids,
                    _values);

                node.valid = true;
            }
        }
    }

    
    if (   !isEmpty(objects)
        || !isEmpty(styles))
    {
        if (settings.logObjectUpdates) logObjectUpdates([...objects]);
        if (settings.logStyleUpdates)  logStyleUpdates ([...styles ]);

        objects = objects.filter(o => nodeFromId(o.nodeId).active);

        uiQueueMessageToFigma({
            cmd:          'figUpdateObjectsAndStyles',
            updateNodeId:  updateNodeId,
            updateParamId: updateParamId,
            nodeIds:       nodes.map(n => n.id),
            objects:       [...objects],
            styles:        [...styles ]});

        requestObjects.push(...objects);
    }


    if (!graphView.loadingNodes)
        uiSaveNodes(nodes.map(n => n.id));


    for (const node of nodes)
    {
        if (   graphView.creatingNodes
            || graphView.loadingNodes
            || graphView.pastingNodes
            || graphView.restoringNodes)
            node.div.style.display = 'block';

        node.updateMeasureData();
        node.updateNode();
    }


    graphView.updateNodes(nodes);
    graphView.updateScrollWithBounds();


    if (graphView.loadingNodes)
        setLoadingProgress((0.7 + 0.3 * updatedNodes / totalNodes) / 0.7)


    if (isLastChunk)
    {
        uiQueueMessageToFigma({
            cmd:          'figDeleteObjectsExcept',
            updateNodeId:  updateNodeId,
            updateParamId: updateParamId,
            nodeIds:       nodes.map(n => n.id),
            ignoreObjects: [...requestObjects]});

        requestObjects = [];


        if (graphView.loadingNodes)
        {
            uiSaveNodes(graph.nodes.map(n => n.id));
            
            graph.updatePages();
            //graph.updateSavedPages();
        }

        graphView.creatingNodes      = false;
        graphView.pastingNodes       = false;
        graphView.loadingNodes       = false;
        graphView.restoringNodes     = false;

        actionManager.undoing        = false;
        actionManager.redoing        = false;
        
        loadingOverlay.style.display = 'none'; // for loading
    }
}



function uiToggleDisableNodes(nodes)
{
    nodes.forEach(n => { n.enabled = !n.enabled; });
}



function uiSavePages(pageIds, pageJson, currentPageId)
{
    if (settings.logRawSavePages)
        logSavePages(pageJson.join('\n'));

    uiQueueMessageToFigma({
        cmd:          'figSavePages',
        pageIds:       pageIds,
        pageJson:      pageJson,
        currentPageId: currentPageId });
}



function uiSaveNodes(nodeIds)
{
    const nodeJson = [];

    for (const id of nodeIds)
    {
        const node = nodeFromId(id);
        nodeJson.push(node.toJson());
    }

    uiSaveNodesJson(nodeIds, nodeJson);
}



function uiSaveNodesJson(nodeIds, nodeJson)
{
    if (isEmpty(nodeJson))
        return;

    if (settings.logRawSaveNodes)
        logSaveNodes(nodeJson.join('\n'));

    uiQueueMessageToFigma({
        cmd:     'figSaveNodes',
        nodeIds:  nodeIds,
        nodeJson: nodeJson });
}



function uiSaveConn(conn)
{
    if (settings.logRawSaveConnections)
        console.log('%cSAVING CONN\n' + conn.toJson(), 'color: black; background: #ddffee;');

    uiQueueMessageToFigma({
        cmd: 'figSaveConnection',
        key:  getConnKey(conn),
        json: conn.toJson()
    });
}



function uiSaveConnection(outputNodeId, outputId, outputOrder, inputNodeId, inputId, connJson)
{
    if (settings.logRawSaveConnections)
        console.log('%cSAVING CONNECTION\n' + connJson, 'color: black; background: #ddffee;');

    uiQueueMessageToFigma({
        cmd: 'figSaveConnection',
        key:  getConnectionKey(
                  outputNodeId, outputId, outputOrder,
                  inputNodeId, inputId),
        json: connJson
    });
}



function uiSaveConnections(conns)
{
    if (settings.logRawSaveConnections)
        logSaveConnections(conns);


    const keys     = [];
    const connJson = [];

    for (const conn of conns)
    {
        keys.push(getConnKey(conn));
        connJson.push(conn.toJson());
    }


    uiQueueMessageToFigma({
        cmd: 'figSaveConnections',
        keys: JSON.stringify(keys),
        json: JSON.stringify(connJson)
    });
}



function uiUpdateSavedConnections(curKeys, newKeys, conns)
{
    if (settings.logRawSaveConnections)
        logUpdateSavedConnections(conns);


    const connJson = [];

    for (const conn of conns)
        connJson.push(conn.toJson());


    uiQueueMessageToFigma({
        cmd:    'figUpdateSavedConnections',
        curKeys: JSON.stringify(curKeys),
        newKeys: JSON.stringify(newKeys),
        json:    JSON.stringify(connJson)
    });
}



function uiDeleteSavedConn(conn)
{
    if (settings.logRawSaveConnections)
    {
        console.log(
             '%cDELETING SAVED CONNE '
            + getConnString(conn, true),
            'color: black; background: #ddeeff;');
    }


    uiQueueMessageToFigma({
        cmd: 'figDeleteSavedConnection',
        key:  getConnKey(conn)
    });
}



function uiDeleteSavedConnection(key, outputNodeId, outputId, outputOrder, inputNodeId, inputId, list)
{
    if (settings.logRawSaveConnections)
    {
        console.log(
             '%cDELETING SAVED CONNECTION ' 
            + getConnectionString(
                outputNodeId,
                outputId,
                outputOrder,
                inputNodeId,
                inputId,
                list,
                true), 
            'color: black; background: #ddeeff;');
    }


    uiQueueMessageToFigma({
        cmd: 'figDeleteSavedConnection',
        key:  key
    });
}



function uiRemoveSavedPage(pageId)
{
    uiQueueMessageToFigma({
        cmd:   'figRemoveSavedPage',
        pageId: pageId
    });
}



function uiRemoveAllSavedPages()
{
    uiQueueMessageToFigma({
        cmd: 'figRemoveAllSavedPages'
    });
}



function uiRemoveAllSavedConnections()
{
    for (const node of graph.nodes)
        for (const input of node.inputs)
            if (input.connected)
                uiDisconnectAny(input);

    uiQueueMessageToFigma({
        cmd: 'figRemoveAllSavedConnections'
    });
}



function uiDeleteSavedConnectionsToNodeId(nodeId)
{
    if (settings.logRawSaveConnections)
    {
        console.log(
            '%cDELETING SAVED CONNECTIONS TO ' + nodeId, 
            'color: black; background: #ddeeff;');
    }


    uiQueueMessageToFigma({
        cmd:   'figDeleteSavedConnectionsToNode',
        nodeId: nodeId
    });
}



function uiDeleteSavedConnectionsFromNodeId(nodeId)
{
    uiQueueMessageToFigma({
        cmd:   'figDeleteSavedConnectionsFromNode',
        nodeId: nodeId
    });
}



function uiRemoveSavedNodesAndConns(nodeIds)
{
    uiQueueMessageToFigma({
        cmd:    'figRemoveSavedNodesAndConns',
        nodeIds: nodeIds
    });
}



function uiRemoveConnsToNodes(nodeIds)
{
    const nodes = nodeIds.map(id => nodeFromId(id));

    for (const node of nodes)
        for (const input of node.inputs)
            if (input.connected)
                uiDisconnectAny(input);

                
    uiQueueMessageToFigma({
        cmd:    'figRemoveConnsToNodes',
        nodeIds: nodeIds
    });
}



function uiRemoveAllSavedNodesAndConns()
{
    uiQueueMessageToFigma({
        cmd: 'figRemoveAllSavedNodesAndConns'
    });
}



function uiRemovePluginDataFromAllLocalStyles()
{
    uiQueueMessageToFigma({
        cmd: 'figRemovePluginDataFromAllLocalStyles'
    });
}



function uiLogAllSavedNodesAndConns()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedNodesAndConns',
        darkMode: darkMode,
        settings: settings
    });
}



function uiLogAllSavedNodes()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedNodes',
        darkMode: darkMode,
        settings: settings
    });
}



function uiLogAllSavedConns()
{
    uiQueueMessageToFigma({
        cmd:     'figLogAllSavedConns',
        settings: settings
    });
}



function uiTriggerUndo()
{
    uiQueueMessageToFigma({
        cmd: 'figTriggerUndo'
    });
}



function uiUpdateViewportRect()
{
    uiQueueMessageToFigma({
        cmd: 'figUpdateViewportRect'
    });
}




function uiLinkNodeToExistingColorStyle(node, styleId, styleName, paints)
{
    node.linkedStyleId   = styleId;
    node.linkedStyleName = styleName;


    if (styleName != NULL)
        node.name = styleName;

    // node.name =
    //     styleName != NULL
    //     ? styleName
    //     : node.defName;

        
    if (styleId != NULL)
    {
        if (!isEmpty(paints))
        {
            const c = paints[0];

            node.paramValue.setValue(FillValue.create(
                Math.round(c[0] * 0xff),
                Math.round(c[1] * 0xff),
                Math.round(c[2] * 0xff),
                Math.round(c[3] * 100 )));
        }
    }
    else
    {
        node.paramValue.setValue(FillValue.NaN);

        // if (node.paramValue.input.connected)
        //     actionManager.do(new DisconnectAction(node.paramValue.input), true);
    }


    pushUpdate(null, [node]);


    uiQueueMessageToFigma({
        cmd:    'figLinkNodeToExistingColorStyle',
        nodeId:  node.id,
        styleId: styleId});
}



function uiStylePropertyChange(msg)
{
    const node = graph.nodes.find(n => 
           n.type == COLOR_STYLE 
        && n.linkedStyleId == cleanStyleId(msg.styleId));

    if (!node)
        return;
    
    
    for (const prop of msg.properties)
    {
        switch (prop)
        {
            case 'name':
                node.name = msg.name;
                break;

            case 'paint':
                if (!isEmpty(msg.paints))
                {
                    const paint = msg.paints[0];

                    if (paint.type == 'SOLID')
                    {
                        node.paramValue.setValue(FillValue.create(
                            Math.round(paint.color.r * 0xff),
                            Math.round(paint.color.g * 0xff),
                            Math.round(paint.color.b * 0xff),
                            Math.round(paint.opacity * 100 )));
                    }
                }

                break;
        }
    }


    if (node)
    {
        pushUpdate(null, [node]);

        actionManager.clear();
        uiShowClearUndoWarning();
    }
}



function uiStyleDelete(msg)
{
    const node = graph.nodes.find(n => 
           n.type == COLOR_STYLE 
        && n.linkedStyleId == cleanStyleId(msg.styleId));


    if (node)
    {
        uiLinkNodeToExistingColorStyle(node, NULL, '', []);
        
        actionManager.clear();
        uiShowClearUndoWarning();
    }
}



function uiReturnFigGetAllLocalColorStyles(msg)
{
    const styles = JSON.parse(msg.styles);

    initLocalStylesMenu(styles, msg.nodeId);

    menuLocalStyles.showAt(msg.px, msg.py, false);
}



function uiSetStyleId(msg)
{
    nodeFromId(msg.nodeId).linkedStyleId = msg.styleId;
}



function initLocalStylesMenu(styles, nodeId)
{
    const node = nodeFromId(nodeId);
    console.assert(node.type == COLOR_STYLE, 'node must be COLOR_STYLE');


    menuLocalStyles.clearItems();

    for (const style of styles)
    {
        const options = {};

        if (style.paints.length == 1)
        {
            const rgba = style.paints[0];
            options.icon = createStyleIcon(rgba);//'<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="8" cy="8" r="8" fill="' + rgb2style(rgb) + '"/></svg>';
        }

        if (   style.existing == undefined
            || style.existing)
            options.enabled = false;

        options.callback = () => actionManager.do(
            new LinkExistingStyleAction(
                nodeId,
                style.id, 
                style.name,
                style.paints));
            
        const item = new MenuItem(style.name.replaceAll('/', '/'), options);

        item.setChecked(style.nodeId == node.id);

        menuLocalStyles.addItems([item]);
    }


    if (!isEmpty(styles))
        menuLocalStyles.addItems([new MenuItem('', {separator: true})]);

        
    menuLocalStyles.addItems([
        new MenuItem('None', {
            callback: e => actionManager.do(new LinkExistingStyleAction(nodeId, NULL, '', [])),
            enabled:  node.linkedStyleId != NULL})
    ]);
}



function createStyleIcon(rgba)
{
    const rgba0 = hex2rgb('d9d9d9');
    const rgba1 = hex2rgb('f6f6f6');

    rgba0[3] = 1 - rgba[3];
    rgba1[3] = 1 - rgba[3];

    const icon = 
        '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"> \
            <g clip-path="url(#clip0_1300_182)"> \
            <rect width="16" height="16" rx="8" fill="#'+rgba2hex(rgba1)+'"/> \
            <path fill-rule="evenodd" clip-rule="evenodd" d="M3 0H0V3H3V6H0V9H3V12H0V15H3V18H6V15H9V18H12V15H15V18H18V15H15V12H18V9H15V6H18V3H15V0H12V3H9V0H6V3H3V0ZM6 6V3H9V6H6ZM6 9H3V6H6V9ZM9 9H6V12H3V15H6V12H9V15H12V12H15V9H12V6H15V3H12V6H9V9ZM9 9V12H12V9H9Z" fill="#'+rgba2hex(rgba0)+'"/> \
            <path d="M0 16V0L16 16H0Z" fill="#2C2C2C"/> \
            <rect width="16" height="16" fill="' + rgba2style(rgba) + '"/> \
            </g> \
            <defs> \
            <clipPath id="clip0_1300_182"> \
            <rect width="16" height="16" rx="8" fill="white"/> \
            </clipPath> \
            </defs> \
        </svg>';

    return icon.replaceAll('#', '%23');
}


const defNodeWidth          = 114;
const resizeEdgeWidth       = 8;


var   overNumberControl     = null;
var   numberControlChanging = null;
var   overNumberControlCtrl = null;


const graph                 = new Graph();
var   graphView             = new GraphView(_graphView);
         
var   viewportZoom          = 1;
var   viewportRect          = new Rect();


const smallScrollGap        =  6;
const largeScrollGap        = 14;
       
var   menuBarHeight         = 40;
var   pagesBarHeight        = 36;


var   figFonts              = [];



function getTopHeight() 
{ 
    return menuBarHeight 
        + (settings.showPages ? pagesBarHeight : 0);
}



function uiError(text, options = {}, delay = 6000)
{
    uiNotify(
        text, 
        {
            delay: delay,
            error: true,
            ...options
        });
}



function uiNotify(text, options = {})
{
    if (options.delay        == undefined) options.delay        = 4000;
    if (options.error        == undefined) options.error        = false;
    if (options.prefix       == undefined) options.prefix       = '';
    if (options.buttonText   == undefined) options.buttonText   = '';
    if (options.buttonAction == undefined) options.buttonAction = NULL;


    uiQueueMessageToFigma({ 
        cmd:         'figNotify',
        text:         text,
        prefix:       options.prefix,
        delay:        options.delay,
        error:        options.error,
        buttonText:   options.buttonText,
        buttonAction: options.buttonAction
    });        
}



function uiShowClearUndoWarning(deleting)
{
    if (settings.showClearUndoWarning)
    {
        uiNotify(
            'Changing or deleting linked styles in Figma clears undo in Generator', 
            {
                buttonText:   'Ignore',
                buttonAction: 'hideClearUndoWarning',
                delay:         8000 
            });
    }
}



function uiHideClearUndoWarning()
{
    updateSettingAndMenu(
        'showClearUndoWarning',  
         true, 
        !settings.showClearUndoWarning);
}



function uiRestartGenerator(dataMode)
{
    uiSetLocalData('dataMode', boolToString(dataMode));
    uiPostMessageToFigma({cmd: 'figRestartGenerator'});
}





// function setCurrentGraph(graph)
// {
//     console.assert(graphView, 'there should be a valid graphView');

//     const elements = Array.prototype.slice.call(document.children);
//     const index    = elements.indexOf(graphView.div);

//     document.body.removeChild(graphView.div);
//     document.body.insertBefore(graphView.div, document.children[index]);

//     graphView.updateMeasureData();
// }


function initWhatsNewDialog()
{
    //whatsNew0.innerHTML = whatsNew0.innerHTML.replace('%Ctrl%', osCtrl());


    initCheckbox(chkHideWhatsNew, 'Don\'t show again', false);
    chkHideWhatsNew.addEventListener('change', () => uiSetLocalData('showWhatsNew', generatorVersion));


    whatsNewBack.addEventListener('pointerdown', e => { e.preventDefault(); });


    whatsNewDialog.mouseOver = false;

    whatsNewDialog.addEventListener('pointerenter', e => { whatsNewDialog.mouseOver = true;  updateWhatsNewScroll(); });
    whatsNewDialog.addEventListener('pointerleave', e => { whatsNewDialog.mouseOver = false; updateWhatsNewScroll(); });
    

    let r = simpleIntHash(generatorVersion);
    r = 3*r*r - 2*r*r*r;

    whatsNewWatermark.style.left = Math.round(r * 100) + '%';


    whatsNewDialogContainer.addEventListener('wheel', e =>
    {    
        const bounds = whatsNewDialogContent.getBoundingClientRect();

        if (bounds.bottom - bounds.top <= whatsNewDialogContainer.clientHeight)
            return;


        let oy = whatsNewDialogContent.style.top = whatsNewDialogContent.offsetTop - e.deltaY / 3;

        oy = Math.max(oy, whatsNewDialogContainer.clientHeight - whatsNewDialogContent.clientHeight + whatsNewTitle.clientHeight);
        whatsNewDialogContent.style.top = Math.min(oy, getTopHeight());

        updateWhatsNewScroll();
    });



    whatsNewScrollbarY.addEventListener('pointerdown', e =>
    {
        if (e.button == 0)
        {
            whatsNewScrollbarY.moving = true;
            whatsNewScrollbarY.yStart = whatsNewScrollbarY.offsetTop;
            whatsNewScrollbarY.hStart = whatsNewScrollbarY.offsetHeight;
            whatsNewScrollbarY.pStart = e.clientY;
            whatsNewScrollbarY.setPointerCapture(e.pointerId);
    
            for (const node of graph.nodes)
                node.div.sly = node.div.offsetTop;
    
            whatsNewDialogContent.topStart = whatsNewDialogContent.offsetTop;
        }
    });
    
    
    
    whatsNewScrollbarY.addEventListener('pointerup', e =>
    {
        if (   e.button == 0
            && whatsNewScrollbarY.moving)
        {
            whatsNewScrollbarY.moving = false;
            whatsNewScrollbarY.releasePointerCapture(e.pointerId);
 
            let bounds = Rect.NaN;
    
            for (const node of graph.nodes)
                bounds = expandRect(bounds, boundingRect(node.div));
    
            // if (bounds.t >= 0 && bounds.b < whatsNewDialog.clientHeight)
            //     whatsNewScrollbarY.style.display = 'none';
        }
    });
    
    
    
    whatsNewScrollbarY.addEventListener('pointermove', e =>
    {
        if (whatsNewScrollbarY.moving)
            updateWhatsNewScrollbar(e.clientY);
    });


    whatsNewTitleText.innerHTML = 'Version ' + generatorVersion;
}



function showWhatsNewDialog()
{
    whatsNewBack  .style.display = 'block';
    whatsNewDialog.style.display = 'block';

    updateWhatsNewScroll();

    dialogShown = true;
}



function hideWhatsNewDialog()
{
    whatsNewBack  .style.display = 'none';
    whatsNewDialog.style.display = 'none';

    dialogShown = false;
}



whatsNewClose.addEventListener('pointerdown', e => e.stopPropagation());



whatsNewBack.addEventListener('pointerdown', () =>
{
    hideWhatsNewDialog();
});



/////////////////////////////////////////////////////////////////////////////////////



function updateWhatsNewScrollbar(clientY)
{
    let t = whatsNewScrollbarY.yStart + clientY - whatsNewScrollbarY.pStart;
    let b = t + whatsNewScrollbarY.hStart;

    t = Math.max(whatsNewTitle.clientHeight + smallScrollGap, t);
    b = Math.min(b, whatsNewDialogContainer.clientHeight - largeScrollGap);

    t = Math.max(smallScrollGap, Math.min(t, b - smallScrollGap));
    b = Math.max(t + smallScrollGap, b);


    let oy = 
          whatsNewDialogContent.topStart 
        - (clientY - whatsNewScrollbarY.pStart) / whatsNewScrollbarY.hStart * whatsNewDialogContainer.clientHeight;

    oy = Math.max(oy, whatsNewDialogContainer.clientHeight - whatsNewDialogContent.clientHeight + whatsNewTitle.clientHeight);


    whatsNewDialogContent.style.top = Math.min(
        oy,
        getTopHeight());


    updateWhatsNewScroll();
}



function updateWhatsNewScroll()
{
    const x       = whatsNewDialog.clientLeft;
    const w       = whatsNewDialog.clientWidth;
    const h       = whatsNewDialogContainer.clientHeight;
    const yOffset = getTopHeight();
    
    const bounds = whatsNewDialogContent.getBoundingClientRect();
    
    updateWhatsNewScrollY(x, w, h, bounds, yOffset);
}



function updateWhatsNewScrollY(x, w, h, bounds, yOffset)
{
    if (   whatsNewDialog.mouseOver
        && bounds.bottom - bounds.top > h)
    {
        const height = sqr(h) / bounds.height - 2*smallScrollGap;

        whatsNewScrollbarY.style.display = 'inline-block';
        whatsNewScrollbarY.style.height  =  height;
        whatsNewScrollbarY.style.left    =  x + w - smallScrollGap - 6;
        whatsNewScrollbarY.style.top     =  yOffset - (bounds.top - 100) * h / bounds.height;
    }
    else
       whatsNewScrollbarY.style.display = 'none';
}


document.canResizeL = false;
document.canResizeR = false;
document.canResizeB = false;
   
document.resizingL  = false;
document.resizingR  = false;
document.resizingB  = false;

document.startRect  = new Rect();



//window.addEventListener('keydown',       e => e.preventDefault());

window.addEventListener('gesturestart',  e => e.preventDefault());
window.addEventListener('gesturechange', e => e.preventDefault());
window.addEventListener('gestureend',    e => e.preventDefault());



var crashed     = false;
var dialogShown = false;

var darkMode;



function checkResize(x, y)
{
    if (!documentBodyClient)
    {
        setAutoCursor();
        return;
    }


    document.canResizeL = false;//!dialogShown &&                      x <= resizeEdgeWidth;
    document.canResizeR = !dialogShown && window.innerWidth  - x <= resizeEdgeWidth;
    document.canResizeB = !dialogShown && window.innerHeight - y <= resizeEdgeWidth;

    
    if (     document.canResizeR
          && document.canResizeB) setCursor('nwse-resize', false); 
    else if (document.canResizeL
          && document.canResizeB) setCursor('nesw-resize', false); 
    else if (document.canResizeL
          || document.canResizeR) setCursor('ew-resize',   false);   
    else if (document.canResizeB) setCursor('ns-resize',   false);   
    else                          setAutoCursor();
}



function uiSetWindowRect(x, y, width, height)
{
    uiQueueMessageToFigma({ 
        cmd:   'figSetWindowRect', 
        x:      x,
        y:      y,
        width:  Math.max(500, width),
        height: height
    });
}



function uiResizeWindow(width, height)
{
    uiQueueMessageToFigma({ 
        cmd:   'figResizeWindow', 
        width:  Math.max(500, width),
        height: height
    });
}



function uiReturnFigResizeWindow()
{
    if (settings.dataMode)
        return;

    graphView.update();
    updateWhatsNewScrollbar(0);

    pageName   .style.display =
    btnPage.div.style.display = window.innerWidth > 590 ? 'inline-block' : 'none';
}



function uiUpdateWindowStartRect(msg)
{
    document.startRect = new Rect(
        msg.position.x - msg.clientPosition.x,
        msg.position.y - msg.clientPosition.y,
        window.innerWidth,
        window.innerHeight);

    // console.log('position       =', position);
    // console.log('clientPosition =', clientPosition);

    viewportZoom = msg.viewportZoom;
    viewportRect = msg.viewportRect;
    
    document.startRectIsValid = true;
}



function isDarkMode()
{
    const style = window.getComputedStyle(document.body);
    return isDark(style2rgba(style.backgroundColor));
}



// create an observer for when the UI theme changes

function onClassChange(element, callback) 
{
    const observer = new MutationObserver((mutations) => 
    {
        mutations.forEach((mutation) => 
        {
            if (   mutation.type          == 'attributes' 
                && mutation.attributeName == 'class'    ) 
                callback(mutation.target);
        });
    });

    observer.observe(element, { attributes: true });

    return observer.disconnect;
}



function dockWindowNormal  () { uiQueueMessageToFigma({cmd: 'figDockWindowNormal'  }); }
function dockWindowMaximize() { uiQueueMessageToFigma({cmd: 'figDockWindowMaximize'}); }
function dockWindowTop     () { uiQueueMessageToFigma({cmd: 'figDockWindowTop'     }); }
function dockWindowLeft    () { uiQueueMessageToFigma({cmd: 'figDockWindowLeft'    }); }
function dockWindowRight   () { uiQueueMessageToFigma({cmd: 'figDockWindowRight'   }); }
function dockWindowBottom  () { uiQueueMessageToFigma({cmd: 'figDockWindowBottom'  }); }




////////////////////////////////////////////////////

</script>
