<script id="generatorScript" type="javascript/worker"> 'use strict';  


const generatorVersion = 435;   const e869        = 2147483647;    const NULL             = '';    const t870             = '  ';  const q871              = '    '; const u872               = '\n';    const f873   = '◦ G •'; const v874    = f873 + ' ';  const c875          = 'G_NODE'; const q876          = 'G_CONN'; const h877          = 'G_PAGE'; const y878          = 'G_TEMP';  const minWindowWidth   = 602; const minWindowHeight  =  39;   const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var enableAsserts = false;    function x879(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function y880(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function q881(f) { return Math.floor(f) | 0; }    function i882(x) {     x = q881(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distv(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function m883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function anglev2(v1, v2) {     return anglev2_(v1.x, v1.y, v2.x, v2.y); }    function anglev2_(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function s885(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function lengthv_(x, y) {     return Math.sqrt(x*x + y*y); }    function w886(v) {     return point(         v.x == 0 ? 0 : v.x / s885(v),         v.y == 0 ? 0 : v.y / s885(v)); }    function dotv(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function a887(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function y888(v, m) {     let v3 = [v.x, v.y, 1];     let r  = b948(v3, m);      return point(r[0], r[1]); }    function y889(...mm) {     g952(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function w890(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function f891(m) {     return w890(adjugate(m), determinant(m)); }    function y892(angle) {     const cosA = x879(Math.cos(angle));     const sinA = x879(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function b893(x = 0, y = 0, scaleX = 1, scaleY = 1, angle = 0, skewX = 0, skewY = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[scaleX*cosA -  skewY*sinA, -skewX*cosA + scaleY*sinA, x],             [ skewY*cosA + scaleX*sinA, scaleY*cosA +  skewX*sinA, y],             [0,                         0,                         1]]; }    function r894(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function h895(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function sqrv(v) {     return d896(v, v); }    function d896(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function n897(v, s) {     return point(         v.x * s,         v.y * s); }	    function d898(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function z899(v, s) {     return point(         v.x / s,         v.y / s); }	    function p900(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function a901(str)  {     return decodeURI(encodeURIComponent(str)); }    function w902(str)  {     return decodeURIComponent(encodeURI(str)); }    function d903(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function l904(str) {     return Array.from(w902(str), c => c.charCodeAt(0)); }    function f905(array, size)  {     const newArray = new Uint8Array(size);     n906(array, newArray);     return newArray; }    function n906(src, dst) {     d907(         src, 0, src.length,         dst, 0, dst.length); }    function d907(src, i908, c909, dst, b910, k911) {     const size = Math.min(c909, k911);      for (let i = 0; i < size; i++)         dst[b910 + i] = src[i908 + i]; }    function y912(l913, a914) {     if (l913.length != a914.length)         return false;      for (let i = 0; i < l913.length; i++)     {         if (l913[i] != a914[i])             return false;     }      return true; }    function a915(m916, d917) {     return m916.findIndex(i => d917.includes(i)) > -1; }    function  h918(list) { return list ? '<==' : '<--'; };  function o919(list) { return list ? '==>' : '-->'; };   function g920(nodeId) { return c875 + ' ' + nodeId; } function h921(name)   { return q876 + ' ' + name;   } function z922(name)   { return h877 + ' ' + name;   }    function p923(str)  {      return str.toLowerCase() == 'true'         || str == '1'; }    function i924(n925, s926 = false) {     return d931(         n925.outputNodeId,         n925.outputId,         n925.outputOrder,         n925.inputNodeId,         n925.inputId,         n925.list,         s926); }    function t927(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return h921(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function o928(f243) {     return t927(         f243.outputNodeId,         f243.outputId,         f243.outputOrder,         f243.inputNodeId,         f243.inputId); }    function o929(f243) {     return t927(         f243.output.node.id,         f243.output.id,         f243.outputOrder,         f243.input.node.id,         f243.input.id); }    function z930(f243, s926 = false) {     return d931(         f243.output.node.id,         f243.output.id,         f243.outputOrder,         f243.input.node.id,         f243.input.id,         f243.list,         s926); }    function d931(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, s926 = false) {     const  sp   = s926 ? ' ' : '  ';      const jsp   = s926 ? ''  : ' ';       const arrow =            sp          + y935(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + o919(typeof list == 'string' ? p923(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function e932(pageId) {     return z922(pageId); }    function z933(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += i934(c);      return sup; }    function i934(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function y935(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += u936(c);      return sup; }    function u936(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function f937(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function b938(array, item) {     g939(array, array.indexOf(item)); }    function g939(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function e940(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function s941(array) {     return array[array.length-1]; }    function r942(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function v943(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function w944(o2795, array) {     for (const item of array)     {         const index = o2795.indexOf(item);                  if (index > -1)             o2795.splice(index, 1);     } }    function l945(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function h946(styleId) {     return styleId.split(',')[0] + ','; }    function n947(points) {     let q4031 = '';       if (points.length < 2)         return q4031;       q4031 += 'M';     q4031 += ' ' + x879(points[0].x);     q4031 += ' ' + x879(points[0].y);      for (let i = 1; i < points.length; i++)     {         q4031 +=                ' L'             + ' ' + x879(points[i].x)             + ' ' + x879(points[i].y);     }       return q4031; }    function point(x, y) { return {x: x, y: y}; }    function b948(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let l111 = {};              for (const key in val)                  l111[key] = clone(val[key]);              return l111;         }     }      throw 'unknown'; }    function q949(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => q949(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => q949(array, i));         else if (!array.includes(item))             array.push(item);     } }    function u950(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => u950(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function z951(array, item, except) {     if (Array.isArray(item))         item.forEach(i => z951(array, i, except));     else if (!array.find(except))         array.push(item); }    function g952(...args) {               if (enableAsserts)     {         console.assert(...args);              } }    function p953(...args) {               if (enableAsserts)         console.error(...args); }    function s954(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function h955(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function a956(i4091) {     const fills = [];       for (const fill of i4091)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const [p0, p1, p2] = fill[1];                  const d4206 =                      [[0,   1,   0],                      [0.5, 0.5, 1],                      [1,   1,   1]];                  let c4207 = [                     [p0.x, p1.x, p2.x],                     [p0.y, p1.y, p2.y],                     [1,    1,    1   ]];                  c4207 = y889(d4206, f891(c4207));                 c4207 = [c4207[0], c4207[1]];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: c4207,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function h957(type) {     return f1089.includes(type); }


function u958(type, active) {     return x959(type, active, o4006); }    function x959(type, active, o4006) {     if (y1166.includes(type))         return active              ? (o4006 ? n2428 : b2418)             : (o4006 ? f2429       : r2419      );      else if (d1167.includes(type))         return active              ? (o4006 ? f2434   : n2424)             : (o4006 ? z2435         : g2425      );      else if (c1296.includes(type)          || v1214.includes(type))         return active              ? (o4006 ? n2432  : b2422)             : (o4006 ? a2433        : a2423      );      else if (w1300.includes(type))         return active              ? (o4006 ? t2430  : l2420)             : (o4006 ? l2431        : a2421      );      else if (g1090.includes(type)           || type == z1087)         return active              ? (o4006 ? j2426   : k2416)             : (o4006 ? r2427         : k2417      );      else if (type == d1216)         return active              ? (o4006 ? j2426   : k2416)             : (o4006 ? r2427         : k2417      );       switch (type)     {         case l1168:               case y1178:         case i1181:         case y1184:         case m1187:          case g1169:                    case m1175:         case k1171:         case w1173:         case z1174:         case v1176:          case a1185:         case e1188:              return o4006                   ? r2427                           : k2417;                                             }                return o4006           ? r2427                   : k2417; }    function n960(color) {     return isNaN(color[1])         || isNaN(color[2])         || isNaN(color[3]); }


function r998(x, replace) {     return !isNaN(x) ? x : replace; }    function y999(c) {     return c >= 'a' && c <= 'z'         || c >= 'A' && c <= 'Z'; }   function e1000(i) {     let l = Math.floor(Math.log10(Math.abs(i)));      return l + 1; }    function i1001(dec) {     return Math.pow(10, -dec); }    function k1002(c) {     return c >= '0'          && c <= '9'; }    function z1003(c) {     return c.length == 1         && (   c >= 'A' && c <= 'F'             || c >= 'a' && c <= 'f'); }    function l1004(num)  {     if (typeof num !== 'number')         p953('Input must be a number');          const strNum = num.toFixed(10);     const iDec   = strNum.indexOf('.');          if (iDec === -1)         return 0;          let count        = strNum.length - iDec - 1;     let nonZeroFound = false;          for (let i = strNum.length-1; i > iDec; i--)     {         if (strNum[i] === '0')             count--;         else             break;     }          return count; }    function n1005(code) {     return code == 'ArrowLeft'         || code == 'ArrowRight'         || code == 'ArrowUp'         || code == 'ArrowDown'; }    function w1006(num, dec = 0, m4000 = false, f1007 = '.', f1008 = '') {     return m4000          ? r1010(num, dec, f1007, f1008)          : d1009(num, dec, f1007, f1008); }    function d1009(num, dec, f1007 = '.', f1008 = '') {     const v4093 = Math.abs(dec);     let    str = Number(num).toFixed(v4093).toString(10);                     let i = str.length-1;          while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return w1011(str, f1008, 3);           let whole = str.slice(0, i);     let frac  = str.slice(i+1);             i = frac.length-1;      if (dec < 0)     {         while (i >= 0 && frac[i] === '0')             frac = frac.substring(0, i--);     }           return w1011(whole, f1008, 3) + (frac != '' ? f1007 : '') + frac; }    function r1010(num, dec, f1007 = '.', f1008 = '') {     const o4092 = Number(num);     const v4093 = Math.abs(dec);      let   a4090 = Number(num).toFixed(v4093).toString(10);     let    str = Math.abs(o4092).toString(16);                 let i = str.length-1;      while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return w1011(str, f1008, 2);           let whole = str.slice(0, i);     let frac  = a4090.slice(i+1);                 i = frac.length-1;      let r4094 = parseFloat(frac);     frac = '';      while (r4094 != 0)     {         r4094 *= 16;          const o4095 = Math.floor(r4094);          frac += o4095.toString(16);         r4094 -= o4095;     }           if (whole.length % 2 > 0) whole = '0' + whole;     if (frac .length % 2 > 0) frac  = frac + '0';       const neg = num < 0 ? '-' : '';      return neg + w1011(whole, f1008, 2) + f1007 + p1012(frac, f1008, 2); }    function w1011(a4090, sep, x1013) {     let str = '';      for (let i = a4090.length-1, t = 0; i >= 0; i--, t++)     {         if (t == x1013)         {             str = sep + str;             t = 0;         }          str = a4090[i] + str;     }      return str; }    function p1012(a4090, sep, x1013) {     let str = '';      for (let i = 0, t = 0; i < a4090.length; i++, t++)     {         if (t == x1013)         {             str += sep;             t = 0;         }          str += a4090[i];     }      return str; }                                 function capitalize(str) {     let cap = "";      if (str.length > 0)         cap += str[0].toUpperCase();      if (str.length > 1)         cap += str.substring(1).toLowerCase();      return cap; }    function s1014(c4096) {     const query = window.location.search.substring(1);     const vars  = query.split('&');      for (let i = 0; i < vars.length; i++)      {         let pair = vars[i].split('=');          if (pair[0] == c4096)             return pair[1];     }      return false; }


const phi = (Math.sqrt(5) - 1) / 2;  const Phi = (Math.sqrt(5) + 1) / 2;     function i1015(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.floor((x + Number.EPSILON) * div) / div;     }    function c1016(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.round((x + Number.EPSILON) * div) / div;     }    function r1017(x, dec) {     const div = Math.ceil(Math.pow(10, dec));     return Math.ceil((x + Number.EPSILON) * div) / div;     }    function a1018(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      return Math.sqrt(dx*dx + dy*dy); }    function vector(angle, dist) {     return point(          dist * Math.cos(angle),          dist * Math.sin(angle)); }    function e1019(v1, v2) {     return v1.x == v2.x         && v1.y == v2.y; }    function b1020(v, salt = 0.0000000001) {     return h895(v, point(         -salt + Math.random() * salt*2,          -salt + Math.random() * salt*2)); }    function r1021(v) {     return point(-v.x, -v.y); }    function r1022(v) {           return point(v.y, -v.x); }    function trimAngle(angle, min = 0, max = Tau) {     while (angle <  min) angle += max - min;     while (angle >= max) angle -= max - min;      return angle; }    function m883(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function l884(p0, p1) {     const v = p900(p1, p0);          let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function c1023(x, y) {     let angle = Math.atan2(y, x);     if (angle < 0) angle += Tau;      return angle; }    function o4007(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         let r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         let r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function l4008(x1, y1, x2, y2, left, top, right, bottom) {     let t0 = 0;     let t1 = 1;      let dx = x2 - x1;     let dy = y2 - y1;      let cl = o4007(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     let cr = o4007( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     let ct = o4007(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     let cb = o4007( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function intersect(p1, p2, q1, q2, segment) {     if (   e1019(p1, p2)          || e1019(q1, q2))          return t984;       let v1 = p900(p2, p1);     let v2 = p900(q2, q1);      if (r894(v1, v2) == 0)          return t984;       let t1 = r894(p900(q1, p1), v2) / r894(v1, v2);     let t2 = r894(p900(q1, p1), v1) / r894(v1, v2);      if ((  0 <= t1 && t1 <= 1         && 0 <= t2 && t2 <= 1)         || !segment)         return h895(p1, n897(v1, t1));              return t984; }    function n4009(l0, l1, p, segment) {     if (e1019(p, l0))         return l0;              let d = n897(         w886(r1022(p900(l1, l0))),          distv(p, l0));                  return intersect(l0, l1, p, p900(p, d), segment); }    function y4010(p0, p1, p) {     let cp = n4009(p0, p1, p, false);      let c4207 = y889(         y4011(r1021(p0)),         l4012(-anglev2(p0, p1)));              p0 = transform(p0, c4207);     p1 = transform(p1, c4207);     cp = transform(cp, c4207);      return (cp.x - p0.x) / nozero(p1.x - p0.x); }    function transform(p, c4207) {     return y888(p, c4207); }    function y4011(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function l4012(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }                          const MaxDigits = 100000;   function d1024(x, res, resSize) {     let carry = 0n;               for (let i = 0; i < resSize; i++)      {         const prod = res[i] * x + carry;              res[i] = prod % 10n;          carry  = prod / 10n;      }                    while (carry)     {         res[resSize] = carry % 10n;         carry        = carry / 10n;         resSize++;     }      return resSize; }    function s1025(max = Number.MAX_SAFE_INTEGER/2) {     const num = Math.floor(Math.random() * max);     return x1026(num); }    function x1026(x)  {     while (!z1027(++x));     return x; }    function z1027(n, k = h1028)  {     if (n <= 1) return false;      if (n <= 3) return true;           if (n % 2 == 0)          return false;                let d = n - 1;          while (d % 2 == 0)          d /= 2;                       for (let i = 0; i < k; i++)             if (!z1029(d, n))             return false;                return true;  }        function z1029(d, n) {     return bigMillerTest(         BigInt(d),         BigInt(n)); }            function k1030(buffer, size) {     return s1031(buffer, 0, size); }    function s1031(buffer, start, size) {     let val = 0;     let mul = 1;      for (let i = start+size-1; i >= start; i--)      {         val += mul * buffer[i];         mul <<= 8;     }      return val; }    function m1032(val, buffer, u1033) {     s1034(val, buffer, 0, u1033); }    function s1034(val, buffer, start, u1033) {     let size = Math.ceil(bigBitCount(val) / 8);          size = Math.min(size, buffer.length - start);      start += u1033 - size;      for (let i = start+size-1; i >= start; i--)      {         buffer[i] = val & 0xFF;          val >>= 8;     } }    function lerpCos(a, b, t) {     return a < b          ? a + (b - a) * (-Math.cos(t*Tau/2)+1)/2          : a + (b - a) * (-Math.cos(t*Tau/2)+1)/2; }    function x1035(a, b, t) {     return a + (b - a) * t; }    function u1036(p0, p1, p2, t) {     const c0 = x1035(p0, p1, t);     const c1 = x1035(p1, p2, t);      return x1035(c0, c1, t); }    function tangent2(p0, p1, p2, t) {     return h895(n897(p0, -2*(1-t)), h895(n897(p1, 2*(1-2*t)), n897(p2, 2*t))); }    function tangent3(p0, p1, p2, p3, t) {     return h895(         n897(p900(p1, p0), 3 * Math.pow(1-t, 2)),         h895(            n897(p900(p2, p1), 6 * (1-t) * t),            n897(p900(p3, p2), 3 * Math.pow(t, 2)))); }    function s1037(p0, p1, p2, p3, t) {     const c0  = x1035(p0, p1, t);     const c1  = x1035(p1, p2, t);     const c2  = x1035(p2, p3, t);      const c01 = x1035(c0, c1, t);     const c12 = x1035(c1, c2, t);      return x1035(c01, c12, t); }    function m1038(angle) {     while (angle <  0  ) angle += Tau;     while (angle >= Tau) angle -= Tau;      return angle;  }    function g1039(m, v)  {     const result = [];      for (let i = 0; i < m.length; i++)      {         let sum = 0;          for (let j = 0; j < v.length; j++)              sum += m[i][j] * v[j];          result.push(sum);     }         return result; }    function smoothstep(x) {     if (   x < 0          || x > 1)          return x;      return 3*x*x - 2*x*x*x; }    function getMean(values) {     return values.length > 0          ? values.reduce((g807, cur) => g807 + cur, 0) / values.length          : Number.NaN; }    function getTrimmedMean(values, trimStart, trimEnd = trimStart) {     if (   trimStart <  0         || trimStart >= 0.5         || trimEnd   <  0         || trimEnd   >= 0.5)         throw new Error('trimStart = ' + trimStart + ', trimEnd = ' + trimEnd + ', trim must be between 0 and 0.5');           const sorted         = values.slice().sort((a, b) => a - b);      const trimCountStart = Math.floor(sorted.length * trimStart);     const trimCountEnd   = Math.floor(sorted.length * trimEnd  );      const trimmed   = sorted.slice(trimCountStart, sorted.length - trimCountEnd);     const sum       = trimmed.reduce((g807, val) => g807 + val, 0);      return trimmed.length > 0          ? sum / values.length          : Number.NaN; }    function getMedian(values) {     const sorted = [...values].sort((a, b) => a - b);     const middle = Math.floor(sorted.length / 2);      return sorted.length % 2 == 0          ? (sorted[middle-1] + sorted[middle]) / 2          : sorted[middle]; }


const t984 = point(Number.NaN, Number.NaN);    function z985(p) { return isNaN(p.x) || isNaN(p.y); }    function unit(v) {     return v.X != 0          || v.Y != 0         ? n897(v, 1 / s885(v))         : point(0, 0); }    function w986(p0, p1, t) {     return point(         x1035(p0.x, p1.x, t),         x1035(p0.y, p1.y, t)); }    function o987(p0, p1, p2, t) {     return point(         u1036(p0.x, p1.x, p2.x, t),         u1036(p0.y, p1.y, p2.y, t)); }    function h988(p0, p1, p2, p3, t) {     return point(         s1037(p0.x, p1.x, p2.x, p3.x, t),         s1037(p0.y, p1.y, p2.y, p3.y, t)); }    function o4007(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         const r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         const r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function l4008(x1, y1, x2, y2, left, top, right, bottom) {     let   t0 = 0;     let   t1 = 1;      const dx = x2 - x1;     const dy = y2 - y1;      const cl = o4007(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     const cr = o4007( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     const ct = o4007(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     const cb = o4007( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function a989(p1, p2, q1, q2, segment) {     if (   e1019(p1, p2)          || e1019(q1, q2))          return t984;       const v1 = p900(p2, p1);     const v2 = p900(q2, q1);      if (r894(v1, v2) == 0)          return t984;       const t1 = r894(p900(q1, p1), v2) / r894(v1, v2);     const t2 = r894(p900(q1, p1), v1) / r894(v1, v2);      if (   (   0 <= t1 && t1 <= 1             && 0 <= t2 && t2 <= 1)         || !segment)         return h895(p1, n897(v1, t1));              return t984; }    function n4009(l0, l1, p, segment, constrain = 0) {     if (e1019(p, l0))         return l0;      const v    = w886(r1022(p900(l1, l0)));           const dist = distv(p, w986(l0, l1, 1/2)) * 2;       const c    = w986(l0, l1, 1/2);     const dir  = distv(h895(p, v), c) < distv(p, c);       let d;               if (constrain == 2) d = point(dir ? -dist : dist, 0);     else if (constrain == 1) d = point(0, dir ? -dist : dist);     else                     d = n897(v, dir ? -dist : dist);       return a989(l0, l1, p, p900(p, d), segment); }    function y4010(p0, p1, p) {     let cp = n4009(p0, p1, p, false);      const c4207 = y889(         y4011(-p0),         l4012(-anglev2(p0, p1)));      p0 = transform(p0, c4207);     p1 = transform(p1, c4207);     cp = transform(cp, c4207);      return (cp.X - p0.X) / nozero(p1.X - p0.X); }    function y990(rect1, rect2) {     return rect1.l >= rect2.l         && rect1.r <= rect2.r         && rect1.t >= rect2.t         && rect1.b <= rect2.b;  }    function m991(rect1, rect2) {     return !(            rect1.l >= rect2.r         || rect1.r <= rect2.l         || rect1.t >= rect2.b         || rect1.b <= rect2.t);  }    function k992(rect, clip) {     if (!m991(rect, clip))         return m1047.NaN;      return new AbsRect(         Math.max(rect.l, clip.l),         Math.max(rect.t, clip.t),         Math.min(rect.r, clip.r),         Math.min(rect.b, clip.b)); }    function d993(rect) {     return new m1047(         rect.x + Math.min(rect.w, 0),         rect.y + Math.min(rect.h, 0),         Math.abs(rect.w),         Math.abs(rect.h)); }    function t994(x, y, w, h) {     return [         x + Math.min(w, 0),         y + Math.min(h, 0),         Math.abs(w),         Math.abs(h) ]; }    function transform(p, c4207) {     return y888(p, c4207); }    function y4011(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function l4012(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }    function offsetRect(elem) {     return new m1047(         elem.offsetLeft,         elem.offsetTop,         elem.offsetWidth,         elem.offsetHeight); }    function k995(elem) {     const bounds = elem.getBoundingClientRect();      return new m1047(         bounds.x,         bounds.y,         bounds.width,         bounds.height); }    function d996(p0, p1, p2) {     const v0  = p900(p1, p0);     const v1  = p900(p2, p1);          const pm0 = z899(h895(p0, p1), 2);     const pm1 = z899(h895(p1, p2), 2);          return a989(         pm0, h895(pm0, r1022(v0)),          pm1, p900(pm1, r1022(v1)),          false); }    function x997(p1, p2, p3) {           const pc = d996(p1, p2, p3);      let a = a887(         m883(p900(p1, pc)),         m883(p900(p2, pc)));                           return a; }    function makeWave(shape, x, y, width, amplitude, frequency, offset, alignX, alignY) {     const startX = x;     const w      = width / frequency;           x += offset;               while (x >  -w) x -= w;     while (x <= -w) x += w;       if (alignY == 1)         amplitude *= 2;               let height = amplitude;       const points = [];       if (Math.abs(w) > 0.0000001)     {         switch (shape)         {             case 0: makeSquareWave  (x, y, width, height, startX, w, points); break;             case 1: makeSawWave     (x, y, width, height, startX, w, points); break;             case 2: makeBackSawWave (x, y, width, height, startX, w, points); break;             case 3: makeTriangleWave(x, y, width, height, startX, w, points); break;             case 4: makeSineWave    (x, y, width, height, startX, w, points); break;         }                   points.forEach(p =>         {                  if (alignX == 1) p.x -= width/2;             else if (alignX == 2) p.x -= width;         });          points.forEach(p =>         {                  if (alignY == 1) p.y -= height/2;             else if (alignY == 2) p.y -= height;         });     }       return points; }    function makeSquareWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y);             p1 = point(x+w/2, y);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y+height);                          clipLineSegment(p0, p1, startX, width);                          points.push(p0, p1);         }          x += w/2;     } }    function makeSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y       );             p1 = point(x+w, y+height);              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeBackSawWave(x, y, width, height, startX, w, points) {     let p0, p1;           while (x < startX + width)     {         if (x + w > startX)         {             p0 = point(x,   y+height);             p1 = point(x+w, y       );              clipLineSegment(p0, p1, startX, width);              points.push(p0, p1);         }          x += w;     } }    function makeTriangleWave(x, y, width, height, startX, w, points) {     let p0, p1;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,     y+height);             p1 = point(x+w/2, y       );              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,     y       );             p1 = point(x+w/2, y+height);              clipLineSegment(p0, p1, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1);         }          x += w/2;     } }    function makeSineWave(x, y, width, height, startX, w, points) {     let p0, p1, p2, p3;      let i = 0;     while (x < startX + width)     {         if (x + w/2 > startX)         {             p0 = point(x,                              y+height);             p1 = point(x     + (x+w/2 - x)   * 0.3615, y+height);             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y       );             p3 = point(x+w/2,                          y       );              clipSinSegment(p0, p1, p2, p3, startX, width);              if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;           if (x < startX + width)         {             p0 = point(x,                              y       );             p1 = point(x     + (x+w/2 - x)   * 0.3615, y       );             p2 = point(x+w/2 + (x - (x+w/2)) * 0.3615, y+height);             p3 = point(x+w/2,                          y+height);                          clipSinSegment(p0, p1, p2, p3, startX, width);                          if (i++ == 0) points.push(p0);             points.push(p1, p2, p3);         }          x += w/2;     } }    function clipLineSegment(p0, p1, startX, width) {     if (   p0.x <  startX         && p1.x >= startX)     {         const t        = (startX - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     }          if (   p0.x <  startX + width         && p1.x >= startX + width)     {         const t        = (startX + width - p0.x) / nozero(p1.x - p0.x);         const segments = splitLineSeg(p0, p1, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;     } }    function clipSinSegment(p0, p1, p2, p3, startX, width) {     if (   p0.x <  startX         && p3.x >= startX)     {         const t        = findTforX3(p0, p1, p2, p3, startX);         const segments = u861(p0, p1, p2, p3, t);         const seg      = segments[1];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     }          if (   p0.x <  startX + width         && p3.x >= startX + width)     {         const t        = findTforX3(p0, p1, p2, p3, startX + width);         const segments = u861(p0, p1, p2, p3, t);         const seg      = segments[0];          p0.x = seg[0].x;  p0.y = seg[0].y;         p1.x = seg[1].x;  p1.y = seg[1].y;         p2.x = seg[2].x;  p2.y = seg[2].y;         p3.x = seg[3].x;  p3.y = seg[3].y;     } }


const quadrantKappa   = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
const kappaCorrection = 0.9993391093366649465402826439248;     function s856(x0, y0, x1, y1, x2, y2, x3, y3, t) {     const p0 = point(x0, y0);     const p1 = point(x1, y1);     const p2 = point(x2, y2);     const p3 = point(x3, y3);      return unit(h895(h895(         n897(p900(p1, p0), 3*sqr(1-t)),         n897(p900(p2, p1), 6*(1-t)*t)),         n897(p900(p3, p2), 3*sqr(t)))); }    function pointAlongLine(p0, p1, dist) {     return h895(p0, n897(w886(p900(p1, p0)), dist)); }    function w857(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = r860(p0, p1, p2, t);     let l      = halves[0];      let length = q862(l[0], l[1], l[2], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = r860(p0, p1, p2, t);         l      = halves[0];          length = q862(l[0], l[1], l[2], error);     }      if (g3857 == 0)         p953('endless loop in w857()');       return t; }    function i858(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = u861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = t863(l[0], l[1], l[2], l[3], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = u861(p0, p1, p2, p3, t);         l      = halves[0];          length = t863(l[0], l[1], l[2], l[3], error);     }      if (g3857 == 0)         p953('endless loop in i858()');       return t; }    function tangentAlongSegment2(p0, p1, p2, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = r860(p0, p1, p2, t);     let l      = halves[0];      let length = q862(l[0], l[1], l[2], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = r860(p0, p1, p2, t);         l      = halves[0];          length = q862(l[0], l[1], l[2], error);     }      if (g3857 == 0)         p953('endless loop in w857()');       return t; }    function tangentAlongSegment3(p0, p1, p2, p3, dist, error = 0.001) {     const hullLength =            distv(p0, p1)          + distv(p1, p2)         + distv(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = dist / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = u861(p0, p1, p2, p3, t);     let l      = halves[0];      let length = t863(l[0], l[1], l[2], l[3], error);       let g3857 = 1000;      while (Math.abs(dist - length) > error         && g3857-- > 0)     {         t += (dist - length) / hullLength;          halves = u861(p0, p1, p2, p3, t);         l      = halves[0];          length = t863(l[0], l[1], l[2], l[3], error);     }      if (g3857 == 0)         p953('endless loop in i858()');       return t; }    function splitLineSeg(p0, p1, t) {     const c = w986(p0, p1, t);      return [ [p0, c],              [c, p1] ]; }    function r860(p0, p1, p2, t) {     const c0  = w986(p0, p1, t);     const c1  = w986(p1, p2, t);      const c01 = w986(c0, c1, t);      return [ [p0, c0, c01],              [c01, c1, p2] ]; }    function u861(p0, p1, p2, p3, t) {     const c0   = w986(p0, p1, t);     const c1   = w986(p1, p2, t);     const c2   = w986(p2, p3, t);                      const c01  = w986(c0, c1, t);     const c12  = w986(c1, c2, t);      const c012 = w986(c01, c12, t);      return [ [p0, c0, c01, c012],              [c012, c12, c2, p3] ]; }    function q862(p0, p1, p2, error = 0.0000001) {     const z859 =           distv(p0, p1)         + distv(p1, p2);      const chord = distv(p0, p2);                if (z859 - chord > error)     {         const halves = r860(p0, p1, p2, 0.5);         const l      = halves[0];         const r      = halves[1];                      return q862(l[0], l[1], l[2], error)              + q862(r[0], r[1], r[2], error);     }      return z859; }    function t863(p0, p1, p2, p3, error = 0.0000001) {     const z859 =            distv(p0, p1)         + distv(p1, p2)         + distv(p2, p3);      const chord = distv(p0, p3);      if ((z859 - chord) > error)     {         const halves = u861(p0, p1, p2, p3, 0.5);         const l      = halves[0];         const r      = halves[1];                      return t863(l[0], l[1], l[2], l[3], error)              + t863(r[0], r[1], r[2], r[3], error);     }      return z859; }    function g864(p0, p1, p2) {     let rect = m1047.NaN;       rect = y3744(rect, p0);     rect = y3744(rect, p2);            if (   (   p0.x <= p1.x && p1.x <= p2.x             || p2.x <= p1.x && p1.x <= p0.x)         && (   p0.y <= p1.y && p1.y <= p2.y             || p2.y <= p1.y && p1.y <= p0.y))         return rect;       const ax = p0.x - 2*p1.x + p2.x;     const bx = 2 * (p1.x - p0.x);          const ay = p0.y - 2*p1.y + p2.y;     const by = 2 * (p1.y - p0.y);       const tx = -bx / nozero(2*ax);     const ty = -by / nozero(2*ay);       if (tx >= 0 && tx <= 1) rect = y3744(rect, o987(p0, p1, p2, tx));     if (ty >= 0 && ty <= 1) rect = y3744(rect, o987(p0, p1, p2, ty));           return rect; }    function d865(p0, p1, p2, p3) {     let rect = m1047.NaN;      rect = y3744(rect, p0);     rect = y3744(rect, p3);       const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;     const bx =  3*p0.x - 6*p1.x + 3*p2.x;     const cx = -3*p0.x + 3*p1.x;      const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;     const by =  3*p0.y - 6*p1.y + 3*p2.y;     const cy = -3*p0.y + 3*p1.y;       const roots = [];       i866(ax, bx, cx, roots);     i866(ay, by, cy, roots);       for (const root of roots)     {         const v = h988(p0, p1, p2, p3, root);                                                        rect = y3744(             rect,              v);     }            return rect; }    function i866(a, b, c, roots) {     a *= 3;     b *= 2;       let D = b*b - 4*a*c;     let r;      if (   Math.abs(a) < 1e-6         && Math.abs(b) > 1e-6)      {         r = -c/b;  if (r >= 0 && r <= 1) roots.push(r);         return;     }       if (D >= 0)      {         const sqrtD = Math.sqrt(D);          r = (-b + sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);         r = (-b - sqrtD) / (2*a);  if (r >= 0 && r <= 1) roots.push(r);     } }    function pointAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = q862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = t863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: g952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return pointAlongLine(points[i], points[i+1], distance - length);     case 2:  return o987        (points[i], points[i+1], points[i+2],              w857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return h988        (points[i], points[i+1], points[i+2], points[i+3], i858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: g952(false);      }           return t984; }    function tangentAlongCurve(degree, points, distance, error = 0.000001) {     let length    = 0;     let segLength = 0;       let i;     for (i = 0; i < points.length - degree - 1; i += degree)     {         switch (degree)         {         case 1:  segLength = distv     (points[i], points[i+1]);                                  break;         case 2:  segLength = q862(points[i], points[i+1], points[i+2],              error); break;         case 3:  segLength = t863(points[i], points[i+1], points[i+2], points[i+3], error); break;         default: g952(false);         }          if (length + segLength >= distance)             break;          length += segLength;     }       switch (degree)     {     case 1:  return p900    (points[i+1], points[i]);     case 2:  return tangent2(points[i], points[i+1], points[i+2],              w857(points[i], points[i+1], points[i+2],              distance - length));     case 3:  return tangent3(points[i], points[i+1], points[i+2], points[i+3], i858(points[i], points[i+1], points[i+2], points[i+3], distance - length));     default: g952(false);      }           return t984; }    function curveLength(degree, points) {     let length = 0;      for (let i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {             case 1:                 length += distv(                     points[i  ],                      points[i+1]);                 break;              case 2:                 length += q862(                     points[i  ],                      points[i+1],                     points[i+2]);                 break;              case 3:                 length += t863(                     points[i  ],                      points[i+1],                     points[i+2],                     points[i+3]);                 break;         }     }      return length; }    function linear2cubic(linear) {     if (linear.length == 0)         return [];       const cubic = [linear[0]];          for (let i = 0; i < linear.length-1; i++)     {         const p0 = linear[i  ];         const p1 = linear[i+1];          cubic.push(             w986(p0, p1, 1/3),             w986(p0, p1, 2/3),             p1);     }      return cubic; }    function quad2cubic(quad) {     if (quad.length == 0)         return [];       const cubic = [quad[0]];          for (let i = 0; i < quad.length-2; i += 2)     {         const p0 = quad[i  ];         const p1 = quad[i+1];         const p2 = quad[i+2];          cubic.push(             w986(p0, p1, 2/3),             w986(p2, p1, 2/3),             p2);     }      return cubic; }    function makeArc(p1, p2, p3) {     if (areClockwise(p1, p2, p3))     {         const pt = p1;         p1 = p3;         p3 = pt;     }      const pc = d996(p1, p2, p3);      const sa = m883(p900(p1, pc));     let   ea = m883(p900(p3, pc));      while (ea > sa) ea -= Tau;       return makeArc_(         pc,         s885(p900(p1, pc)),         sa,         ea); }    function makeArc_(center, radius, startAngle, endAngle) {     let diff  = endAngle - startAngle;     let angle = startAngle;       const points = [];       while (Math.abs(diff) > 0)     {         const da =              diff >= 0              ? Math.min(diff,  Tau/4)              : Math.max(diff, -Tau/4);          const handle = radius * arcKappa(da) * kappaCorrection;          const p1 = h895(center, vector(angle,      radius));         const p2 = h895(center, vector(angle + da, radius));              const v1 = p900(p1, center);         const v2 = p900(p2, center);           points.push(             p1,             p900(p1, n897(r1022(w886(v1)), handle)),             h895(p2, n897(r1022(w886(v2)), handle)));          angle += da;         diff  -= da;     }           points.push(h895(center, vector(endAngle, radius)));       return points; }    function arcKappa(angle)  {     return 4 * Math.tan(angle/4) / 3;  }     function areClockwise(p0, p1, p2) {     return r894(p900(p1, p0), p900(p2, p1)) >= 0; }    function createCompleteCurve(degree, o3745, closed) {     const segPoints = o3745.slice(0, Math.floor((o3745.length-1) / degree) * degree + 1);     let   points;               if (closed)     {         if (   o3745.length == segPoints.length             && e1019(o3745[0], o3745.at(-1)))             points = o3745;         else if (o3745.length - segPoints.length == degree-1)             points = [...o3745, o3745[0]];         else         {             switch (degree)             {             case 1: points = [...segPoints,                                                                                         segPoints[0]]; break;             case 2: points = [...segPoints, w986(segPoints.at(-1), segPoints[0], 1/2),                                             segPoints[0]]; break;             case 3: points = [...segPoints, w986(segPoints.at(-1), segPoints[0], 1/3), w986(segPoints.at(-1), segPoints[0], 2/3), segPoints[0]]; break;             }         }     }     else         points = segPoints;       return points; }    function findTforX3(p0, p1, p2, p3, x)  {            let precision     = 0.00001;     let t             = 0.5;      let maxIterations = 20;     let i             = 0;        while (i < maxIterations)      {         let xAtT =     (1 - t)**3        * p0.x                  + 3 * (1 - t)**2 * t    * p1.x                  + 3 * (1 - t)    * t**2 * p2.x                  +                  t**3 * p3.x;              let dAtT = -3 * (1 - t)**2 * p0.x                    + 3 * (1 - t)**2 * p1.x - 6 * t * (1 - t) * p1.x                    - 3 *      t **2 * p2.x + 6 * t * (1 - t) * p2.x                    + 3 *      t **2 * p3.x;              let tNext = t - (xAtT - x) / dAtT;               if (Math.abs(tNext - t) < precision)            return tNext;                     t = tNext;         i++;     }         return t; }            function i614(degree, points, p) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:  closestPoints.push(n4009(points[i], points[i+1], p, true));         case 2:  closestPoints.push(o987(points[i], points[i+1], points[i+2],              p615(points[i], points[i+1], points[i+2],              p, 0, 1)));         case 3:  closestPoints.push(h988(points[i], points[i+1], points[i+2], points[i+3], a616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1)));         default: g952(false);         }     }       let closest = t984;      for (const cp of closestPoints)     {         if (   z985(closest)             || distv(cp, p) < distv(closest, p))             closest = cp;     }       return closest; }    function closestTangentOnCurve(degree, points, p, constrain = 0) {     const closestPoints = [];      let i;     for (i = 0; i < points.length - degree; i += degree)     {         switch (degree)         {         case 1:               closestPoints.push([                 n4009(points[i], points[i+1], p, true, constrain),                 p900(points[i+1], points[i])]);              break;          case 2:           {             const t = p615(points[i], points[i+1], points[i+2], p, 0, 1, constrain);              closestPoints.push([                 o987  (points[i], points[i+1], points[i+2], t),                  tangent2(points[i], points[i+1], points[i+2], t)]);               break;         }         case 3:           {             const t = a616(points[i], points[i+1], points[i+2], points[i+3], p, 0, 1, constrain);              closestPoints.push([                 h988  (points[i], points[i+1], points[i+2], points[i+3], t),                 tangent3(points[i], points[i+1], points[i+2], points[i+3], t)]);               break;         }         default: g952(false);         }     }       let closest = t984;     let tangent = t984;      for (let i = 0; i < closestPoints.length; i++)     {         const cp = closestPoints[i][0];          if (   z985(closest)             || distv(cp, p) < distv(closest, p))         {             closest = cp;             tangent = closestPoints[i][1];         }     }       return [closest, tangent]; }    function p615(p0, p1, p2, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)          return (start + end) / 2;                const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = o987(p0, p1, p2, t);         const dp2 = sqrv(p900(hp, p));          currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return p615(         p0, p1, p2,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          constrain,         nSlices,         nIterations - 1); }    function a616(p0, p1, p2, p3, p, start, end, constrain = 0, nSlices = 1000, nIterations = 1000) {     if (nIterations <= 0)         return (start + end) / 2;           const tick = (end - start) / nSlices;      if (tick <= 0.000001)         return (start + end) / 2;       let best = 0;      let bestDistance = Number.MAX_SAFE_INTEGER;     let currentDistance;       let t = start;          while (t <= end)      {         const hp  = h988(p0, p1, p2, p3, t);         const dp2 = sqrv(p900(hp, p));                  currentDistance =                (constrain != 2 ? dp2.x : 0)              + (constrain != 1 ? dp2.y : 0);          if (currentDistance < bestDistance)          {             bestDistance = currentDistance;             best = t;         }                  t += tick;     }       return a616(         p0, p1, p2, p3,         p,          Math.max(best - tick, 0),          Math.min(best + tick, 1),          nSlices,         nIterations - 1); }


class Point {     x;     y;      constructor(x, y)     {         this.x = x;         this.y = y;     } }


class m1047 {     x;     y;     w;     h;       get l()            { return this.x;            }     get c()            { return this.x + this.w/2; }     get r()            { return this.x + this.w;   }                 get t()            { return this.y;            }     get m()            { return this.y + this.h/2  }     get b()            { return this.y + this.h;   }                get tl()           { return point(this.l, this.t); }     get tc()           { return point(this.c, this.t); }     get tr()           { return point(this.r, this.t); }     get ml()           { return point(this.l, this.m); }     get mc()           { return point(this.c, this.m); }     get cm()           { return point(this.c, this.m); }     get mr()           { return point(this.r, this.m); }     get bl()           { return point(this.l, this.b); }     get bc()           { return point(this.c, this.b); }     get br()           { return point(this.r, this.b); }                   get width()        { return this.w; }     get height()       { return this.h; }            get left()         { return this.l; }     get center()       { return this.c; }     get right()        { return this.r; }                get top()          { return this.t; }     get middle()       { return this.m; }     get bottom()       { return this.b; }      get topLeft()      { return this.tl; }     get topCenter()    { return this.tc; }     get topRight()     { return this.tr; }     get middleLeft()   { return this.ml; }     get middleCenter() { return this.mc; }     get centerMiddle() { return this.cm; }     get middleRight()  { return this.mr; }     get bottomLeft()   { return this.bl; }     get bottomCenter() { return this.bc; }     get bottomRight()  { return this.br; }        constructor(x, y, w, h)     {         this.x = x;         this.y = y;         this.w = w;         this.h = h;     }        static q3590(rect)     {         return new m1047(rect.x, rect.y, rect.width, rect.height);      }             static get NaN () { return new m1047(Number.NaN, Number.NaN, 0, 0) };     static get Zero() { return new m1047(0, 0, 0, 0); }        get isNaN()     {         return isNaN(this.x)             || isNaN(this.y)             || isNaN(this.w)             || isNaN(this.h);     }    	get isEmpty() 	{ 		return (this.w == 0 			 || this.h == 0); 	}        assign(rect)     {         this.x = rect.x;         this.y = rect.y;         this.w = rect.w;         this.h = rect.h;     } }    class   AbsRect extends m1047 {     constructor(l, t, r, b)     {         super(l, t, r-l, b-t);     } }    function q3743(rect1, rect2) {     if (rect1.isNaN) return m1047.q3590(rect2);     if (rect2.isNaN) return m1047.q3590(rect1);          return new AbsRect(         Math.min(rect2.l, rect1.l),         Math.min(rect2.t, rect1.t),         Math.max(rect2.r, rect1.r),         Math.max(rect2.b, rect1.b)); }    function y3744(rect, p) {     if (rect.isNaN)          return new m1047(p.x, p.y, 0, 0);      return new AbsRect(         Math.min(p.x, rect.l),         Math.min(p.y, rect.t),         Math.max(p.x, rect.r),         Math.max(p.y, rect.b)); } 


class Random {     seed;     index;       cache;        constructor(seed = 0)     {          this.seed  = seed;          this.index = 0;                  this.x1046(256);     }        copy()     {         return new Random(this.seed);     }        x1046(size)     {         this.cache = new Int32Array(size);                  let seed = this.seed;          for (let i = 0; i < size; i++)             this.cache[i] = seed = this.generate(seed);     }        next()     {         if (this.index >= this.cache.length)             this.x1046(i882(this.index));          return this.cache[this.index++] / -0x7fffffff;     }        get(index)     {         if (index >= this.cache.length)             this.x1046(i882(index+1));          return this.cache[index] / -0x7fffffff;     }        generate(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     } }


class m375 {     seed;     cache;      width;     height;        constructor(seed = 0)     {          this.seed  = seed;          this.x1046(256, 16);     }        copy()     {         return new Random(this.seed);     }        x1046(width, height)     {         if (   width  <= this.width             && height <= this.height)             return;          this.width  = width;         this.height = height;                  const seeds = new Array(this.width);         this.cache  = new Array(this.width);           let seed = this.seed;          for (let i = 0; i < this.width; i++)         {             seeds[i] = seed;             seed = this.generate1(seed);         }           for (let i = 0; i < this.width; i++)         {             this.cache[i] = new Array(this.height);             seed = seeds[i];              for (let j = 0; j < this.height; j++)             {                 this.cache[i][j] = seed;                 seed = this.generate2(seed);             }         }     }        get(x, y)     {           if (   x >= this.width                && y >= this.height) this.x1046(i882(x+1), i882(y+1));         else if (x >= this.width ) this.x1046(i882(x+1), this.height  );         else if (y >= this.height) this.x1046(this.width,    i882(y+1));          return this.cache[x][y] / -0x7fffffff;     }        generate1(seed)     {         seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     }        generate2(seed)     {         seed = (seed + 0x7f4a7c13) + (seed << 12);         seed = (seed ^ 0xe17a1465) ^ (seed >> 19);         seed = (seed + 0x59f89f1b) + (seed <<  5);         seed = (seed + 0xac564b05) ^ (seed <<  9);         seed = (seed + 0x65291958) + (seed <<  3);         seed = (seed ^ 0x4ab1db4f) ^ (seed >> 16);              return -seed;     } }


const t1456 = navigator.platform.toLowerCase().indexOf('mac') >= 0;    var w4013; var f4014;        const console_trace = console.trace;      console.trace = msg => {     console.groupCollapsed(msg || 'trace');     console_trace.apply(this);     console.groupEnd(); };    function y1457() {     w4013  = document.createElement('canvas');     f4014 = w4013.getContext('2d');      f4014.willReadFrequently = true; }    function avg(a, b) {     return (a + b) / 2; }    function swap(a, b) {     return [b, a]; }    function flipBit(value, index) {     const bit = ((value >> index) & 1) != 0;      return value         & ~(1 << index)         | (!bit ? 1 : 0) << index; }    function p1458(parent, child) {     return Array.prototype.indexOf.call(parent.children, child); }    function j4015(count, singular, plural = singular) {     if (singular == plural)     {         const x3868   = singular.at(-1);         const f3869 = x3868 == x3868.toUpperCase() ? 'S' : 's';          return singular + (count == 1 ? '' : f3869);     }     else     {         const x3868 = plural.at(-1);          if (x3868 == x3868.toUpperCase())             plural = plural.toUpperCase();          return count == 1             ? singular             : plural;     } }    function p1459(d1460) {     const o3870   = d1460.indexOf('.');     const d3871 = d1460.indexOf(',');      return o3870 >= 0          ? d1460.length-1 - o3870          : (d3871 >= 0             ? d1460.length-1 - d3871             : 0); }    function w1461() {     const num = 1.1;      return num         .toLocaleString(navigator.language)         .substring(1, 2); }    function u1462(l111) {     if (l111 == null)         return false;              return (            Object.keys(l111).length === 0          && l111.constructor === Object); }    function e1463(l111) {     return Object.assign(Object.create(Object.getPrototypeOf(l111)), l111); }    function e1464(l111) {     return JSON.parse(JSON.stringify(l111)); }    function z1465(array) {     return array.filter((value, index) =>          array.indexOf(value) === index); }    function o1466(element) {     const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';     return svg; }    function u4016(element) {      return element.style.visibility == 'visible';  }    function x1467(array, item) {     return array.indexOf(item) == array.length-1; }    function k1468(parent)  {     while (parent.firstChild)         parent.removeChild(parent.firstChild); }             function a1469(data) {     let str = '';      for (let i = 0; i < data.length; i++)         str += String.fromCharCode(data[si]);      return str; }           function log(...params) {     setTimeout(console.log.bind(console, ...params));  }    function b1470() {     setTimeout(console.trace.bind(console)); }    function k1471(num) {     return !isNaN(num) ? num : d964; }    function n1472(str) {     return str == d964          ? Number.NaN           : parseFloat(str); }    function v1473(strBool) {     return strBool == 'true'; }    function j1474(str)  {     if (typeof str != 'string')          return false;       if (str == 'NaN')          return true;      return !isNaN(str)          && !isNaN(parseFloat(str));  }    function r1475(elem) {     void(elem.offsetHeight); }   function readonly(target, name, descriptor) {     descriptor.writable = false;     return descriptor; }    function t1476     (plus = true) { return t1456 ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); } function l1477      (plus = true) { return t1456 ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); } function i1478    (plus = true) { return t1456 ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); } function l1479(plus = true) { return t1456 ? i1478(plus) + t1476(plus) : t1476(plus) + i1478(plus); }    function l1480(type, j4234, options) {     return  options.insert != undefined         &&  options.insert         && (    options.c3413 == undefined             || !options.c3413)         ? new d3(type, j4234, options)         : new i4      (type, j4234, options, options.c3413 != undefined && options.c3413); }    function b1481(x) {     return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32); }    function g1482(m1483, l1484, id = m1483, join = '', startNum = 2, addZero = false) {     if (addZero) id += '0';      if (!l1484(id))         return id;           let numLength = i1485(id);      if (numLength > 0)     {         const len = id.length - numLength;         let   num = parseInt(id.substring(len));          let w4238 = '';         while (w4238 == '' || l1484(w4238))             w4238 = id.substring(0, len + join.length) + join + (++num);          return w4238;     }      else if (numLength == 0)     {         let num   = startNum;         let w4238 = id + join + num;          while (l1484(w4238))             w4238 = id + join + (++num);          return w4238;     }      else         return id; }    function i1485(name) {     let numLength = 0;      for (let i = name.length - 1; i >= 0; i--)     {         if (k1002(name[i])) numLength++;         else break;     }      return numLength; }    function f1486(str)  {     return /^-?\d*\.?\d*(e-?\d+)?$/.test(str); }    function l1487(control, family, size, align = 'left') {     control.style.fontFamily = family;     control.style.fontSize   = size + 'px';     control.style.textAlign  = align; }    function u1488(month, year) {     if (month == 2)     {         return year % 4 != 0              ? 28              : 29;     }     else if (month == 4           || month == 7           || month == 9           || month == 11)         return 30;     else         return 31; }    function getFontStyles(fontName) {     let fonts = n4037.filter(f => f.fontName.family == fontName);       fonts.sort((a, b) =>     {         if (a.fontName.style != b.fontName.style)             return m1394.findIndex(w => w[0] == a.fontName.style.toLowerCase())                  - m1394.findIndex(w => w[0] == b.fontName.style.toLowerCase());          return 0;     });           return fonts.map(f => f.fontName.style); }    function f1489(str) {     return str.replaceAll(/\\(.)/g, (match, char) =>      {         const replacements =          {             'n':  '\n',             'r':  '\r',             't':  '\t',             '\\': '\\',             '\'': '\'',             '\"': '\"',             '\`': '\`'         };                return replacements[char] || match;     }); }    function unescapeRegexPattern(str) {     return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1'); }    function unescapeRegexReplacement(str) {     return str.replace(/\\([\\$&`'])/g, '$1'); }       //     // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html
                                                                                                                   function o1490(str1, str2)  {               const len1 = str1.length;     const len2 = str2.length;     const dist = [];                 for (let i = 0; i <= len1; i++) dist[i]    = [i];     for (let j = 1; j <= len2; j++) dist[0][j] =  j;                     for (let i = 1; i <= len1; i++)      {         for (let j = 1; j <= len2; j++)          {             const cost = str1[i-1] === str2[j-1] ? 0 : 1;              dist[i][j] = Math.min(                 dist[i-1][j  ] + 1,                      dist[i  ][j-1] + 1,                      dist[i-1][j-1] + cost);                              if (   i > 1                  && j > 1                  && str1[i-1] === str2[j-2]                  && str1[i-2] === str2[j-1])                 dist[i][j] = Math.min(dist[i][j], dist[i-2][j-2] + cost);          }     }           return dist[len1][len2]; }    function g1491(count) {     for (let i = 0; i < count; i++)          Math.random(); }    function n1492(str, sub, levenshteinDistance) {     if (sub.length > str.length)         return false;          if (str.includes(sub))         return true;          for (let i = 0; i <= str.length - sub.length; i++)      {         const s = str.substring(i, i + sub.length);                  if (o1490(sub, s) <= levenshteinDistance)             return true;     } }    function degamma(rgb, cs = u36) {     return [ cs.degamma(rgb[0]),              cs.degamma(rgb[1]),              cs.degamma(rgb[2]) ]; }    function regamma(rgb, cs = u36) {     return [ cs.regamma(rgb[0]),              cs.regamma(rgb[1]),              cs.regamma(rgb[2]) ]; }    String.prototype.replaceAt = function(index, replacement)  {     return this.substring(0, index)           + replacement           + this.substring(index+1); };    function x1493(array, condition) {     const items   = array.filter(condition);     const indices = [];          for (const item of items)         indices.push(items.indexOf(item));      return indices; }    function q1494(length) {     const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');      let str = '';      for (let i = 0; i < length; i++)         str += letters[Math.floor(Math.random() * letters.length)];      return str; }    function a1495(rect) {     return '{'               + rect.width         + ', '   + rect.height         + '}'; }    function l1496(str, _what, _with) {     var lastIndex = str.lastIndexOf(_what);      if (lastIndex === -1)          return str;      return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length); }    function o1497(x, y) {     const unders = document.elementsFromPoint(x, y)         .filter(el =>                 el.node             && el.className == 'nodeLabelWrapper');      unders.reverse();      return unders.length > 0           ? unders[0]          : null; }    function measureHtmlText(text, font, fontSize) {     divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';     divTextMeasure.innerHTML = text;              return k995(divTextMeasure); }    function strline(tab, string = '', firstLine = false) {     return (firstLine ? '' : '\n')          + '\t'.repeat(tab)           + string; } 


"use strict";   // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    function w850(c)  {     return    c > 64             && c < 91             ? c - 65             :    c > 96               && c < 123               ? c - 71              :    c > 47                 && c < 58                 ? c + 4                : c === 43                   ? 62                  : c === 47 ? 63 : 0; }    function i851(str, blocksSize)  {     const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");     const inLen  = base64.length;      const outLen =          blocksSize          ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize          : inLen * 3 + 1 >> 2;              const bytes = new Uint8Array(outLen);      for (let mod3,               mod4,               uint24 = 0,               out    = 0,          i = 0;          i < inLen;          i++)      {         mod4 = i & 3;         uint24 |= w850(base64.charCodeAt(i)) << 6 * (3 - mod4);          if (   mod4 === 3              || inLen - i === 1)          {             for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++)                  bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;              uint24 = 0;         }     }      return bytes; }      function j852(i)  {     return i < 26             ? i + 65            : i < 52               ? i + 71              : i < 62                 ? i - 4                : i === 62                   ? 43                  : i === 63 ? 47 : 65; }    function e853(bytes) {     let mod3   = 2,          base64 = "";      const length = bytes.length;      for (let i = 0, uint24 = 0; i < length; i++)      {         mod3 = i % 3;          if (i > 0 && (i * 4 / 3) % 76 === 0)              base64 += "\r\n";          uint24 |= bytes[i] << (16 >>> mod3 & 24);          if (   mod3 === 2              || bytes.length - i === 1)          {             base64 += String.fromCharCode(                 j852(uint24 >>> 18 & 0x3F),                  j852(uint24 >>> 12 & 0x3F),                  j852(uint24 >>>  6 & 0x3F),                  j852(uint24        & 0x3F));                              uint24 = 0;         }     }      return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '=='); }      function utf8ArrToStr(bytes)  {     let   str    = "";      const length = bytes.length;      for (let i = 0; i < length; i++)      {         const byte = bytes[i];          str += String.fromCharCode(                byte > 251              && byte < 254              && i + 5 < length              ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128             :    byte > 247                && byte < 252                && i + 4 < length                ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128               :    byte > 239                  && byte < 248                  && i + 3 < length                  ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                 :    byte > 223                    && byte < 240                    && i + 2 < length                    ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                   :    byte > 191                      && byte < 224                      && i + 1 < length                      ? (byte - 192 << 6) + bytes[++i] - 128                       : byte);     }      return str; }    function strToUtf8Arr(str)  {     let strLen = str.length,          arrLen = 0;             for (let i = 0; i < strLen; i++)      {         const chr = str.charCodeAt(i);         arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;     }      const bytes = new Uint8Array(arrLen);             for (let i = 0, iChr = 0; i < arrLen; iChr++)      {         const chr = str.charCodeAt(iChr);               if (chr < 0x80)          {             bytes[i++] = chr;         }          else if (chr < 0x800)          {             bytes[i++] = 192 + (chr >>> 6);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x10000)          {             bytes[i++] = 224 + (chr >>> 12);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }         else if (chr < 0x200000)          {             bytes[i++] = 240 + (chr >>> 18);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x4000000)          {             bytes[i++] = 248 + (chr >>> 24);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else          {             bytes[i++] = 252 + (chr >>> 30);             bytes[i++] = 128 + (chr >>> 24 & 0x3F);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }     }       return bytes; }


function position(e) {     return point(e.clientX, e.clientY); }    function f1499(l111, style) {     return window.getComputedStyle(l111).getPropertyValue(style); }    function b1500(e) {     return t1456 ? e.metaKey : e.ctrlKey;           }    function c1501(target, proto) {     target.dispatchEvent(new proto.constructor(proto.type, proto)); }    function w1502(className = '', id = '') {     const div = document.createElement('div');          if (className != '')         div.className = className;          if (id != '')         div.id = id;      return div; }    function i1503(div, to) {     if (!to.contains(div))         to.appendChild(div); }    function e1504(div, from) {     if (from.contains(div))         from.removeChild(div); }    function b1505(className = '') {     const textbox = document.createElement('INPUT');     textbox.setAttribute('type', 'text');       if (className.trim() != '')         textbox.className = className;          return textbox; }    function n1506(className = '') {     const textarea = document.createElement('textarea');      if (className.trim() != '')         textarea.className = className;          textarea.spellcheck = false;          return textarea; }    function createCanvas(className = '') {     const canvas = document.createElement('canvas');      if (className.trim() != '')         canvas.className = className;          return canvas; }    function c1507(elem, enable, bold = true) {     elem.style.fontStyle  = enable ? 'normal' : 'italic';       if (bold)         elem.style.fontWeight = enable ? 'normal' : 'bold'; }    function hasFocus(elem) {     return elem == document.activeElement; }    function h1508(id, properties) {     const elem = document.getElementById(id);      for (const property of properties)         elem.style[property] = properties[property]; }    function e1509(parent, child) {     return child.parentNode == parent; }    function f1510(event, element) {     const e = new event.constructor(event.type, event);     element.dispatchEvent(e); }    function offsetRect(element) {     return new m1047(         element.offsetLeft,         element.offsetTop,         element.offsetWidth,         element.offsetHeight); }    function clientRect(element) {     return new m1047(         element.clientLeft,         element.clientTop,         element.clientWidth,         element.clientHeight); }                  function h1511(elementId) {     if (document.selection)      {         var range = document.body.createTextRange();         range.moveToElementText(document.getElementById(elementId));         range.select();     }     else if (window.getSelection)      {         var range = document.createRange();         range.selectNode(document.getElementById(elementId));         window.getSelection().removeAllRanges();         window.getSelection().addRange(range);     } }    function p1512(e) {     return Math.abs(e.deltaX) < 100         && Math.abs(e.deltaY) < 100; }    function d1513(element, show = true)  {     const showStyle = 'block';     const hideStyle = 'none';      if (  !show         && element.style.display != hideStyle)         element.oldDisplay = element.style.display;      element.style.display =          show          ? (   element.style.oldDisplay             && element.style.oldDisplay != hideStyle            ? element.style.oldDsplay            : showStyle)         : hideStyle;  }   function e1514(element)               {      d1513(element, false);  }    function u4016(element) {     return element.offsetParent !== null; }    function c1515(element)  {      if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         return element.value.substring(             element.selectionStart,             element.selectionEnd);     } }    function p1516(element) {     if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         const str = element.value;          element.value =                str.slice(0, element.selectionStart)              + str.slice(element.selectionEnd)     } }    function scrollbarVisible(element)  {     return element.m3129 > element.clientHeight; }    function i1517(e) {     return point(e.clientX, e.clientY); }    function t1518(div) {     const selection = window.getSelection();      if (selection.rangeCount > 0)      {         const range = selection.getRangeAt(0);                  if (   range.commonAncestorContainer === div             || div.contains(range.commonAncestorContainer))         {             const selectedText = range.toString().trim();              if (selectedText.length > 0)                 return true;         }     }      return false;  }    function v1519(div) {     var range = document.createRange();     range.selectNode(div);      window.getSelection().removeAllRanges();     window.getSelection().addRange(range);     }    function u1520(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '.gen';          input.onchange = e =>      {          const file = e.target.files[0];           const reader = new FileReader();         reader.readAsText(file,'UTF-8');          reader.onload = e => callback(e.target.result);     };       input.click(); }    function d1521(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '*.*';          input.onchange = e =>      {          callback(e.target.files[0]);      };       input.click(); }    async function d1522(content, filename, contentType) {     const a    = document.createElement('a');     const file = new Blob([content], {type: contentType});      a.download = filename;     a.href     = URL.createObjectURL(file);      a.click();      await new Promise(resolve => setTimeout(resolve, 500));          URL.revokeObjectURL(a.href); }


const m1498 =  [     {name: 'AliceBlue',            color: 'f0f8ff'},     {name: 'AntiqueWhite',         color: 'faebd7'},     {name: 'Aqua',                 color: '00ffff'},     {name: 'Aquamarine',           color: '7fffd4'},     {name: 'Azure',                color: 'f0ffff'},     {name: 'Beige',                color: 'f5f5dc'},     {name: 'Bisque',               color: 'ffe4c4'},     {name: 'Black',                color: '000000'},     {name: 'BlanchedAlmond',       color: 'ffebcd'},     {name: 'Blue',                 color: '0000ff'},     {name: 'BlueViolet',           color: '8a2be2'},     {name: 'Brown',                color: 'a52a2a'},     {name: 'BurlyWood',            color: 'deb887'},     {name: 'CadetBlue',            color: '5f9ea0'},     {name: 'Chartreuse',           color: '7fff00'},     {name: 'Chocolate',            color: 'd2691e'},     {name: 'Coral',                color: 'ff7f50'},     {name: 'CornflowerBlue',       color: '6495ed'},     {name: 'Cornsilk',             color: 'fff8dc'},     {name: 'Crimson',              color: 'dc143c'},     {name: 'Cyan',                 color: '00ffff'},     {name: 'DarkBlue',             color: '00008b'},     {name: 'DarkCyan',             color: '008b8b'},     {name: 'DarkGoldenRod',        color: 'b8860b'},     {name: 'DarkGray',             color: 'a9a9a9'},     {name: 'DarkGrey',             color: 'a9a9a9'},     {name: 'DarkGreen',            color: '006400'},     {name: 'DarkKhaki',            color: 'bdb76b'},     {name: 'DarkMagenta',          color: '8b008b'},     {name: 'DarkOliveGreen',       color: '556b2f'},     {name: 'DarkOrange',           color: 'ff8c00'},     {name: 'DarkOrchid',           color: '9932cc'},     {name: 'DarkRed',              color: '8b0000'},     {name: 'DarkSalmon',           color: 'e9967a'},     {name: 'DarkSeaGreen',         color: '8fbc8f'},     {name: 'DarkSlateBlue',        color: '483d8b'},     {name: 'DarkSlateGray',        color: '2f4f4f'},     {name: 'DarkSlateGrey',        color: '2f4f4f'},     {name: 'DarkTurquoise',        color: '00ced1'},     {name: 'DarkViolet',           color: '9400d3'},     {name: 'DeepPink',             color: 'ff1493'},     {name: 'DeepSkyBlue',          color: '00bfff'},     {name: 'DimGray',              color: '696969'},     {name: 'DimGrey',              color: '696969'},     {name: 'DodgerBlue',           color: '1e90ff'},     {name: 'FireBrick',            color: 'b22222'},     {name: 'FloralWhite',          color: 'fffaf0'},     {name: 'ForestGreen',          color: '228b22'},     {name: 'Fuchsia',              color: 'ff00ff'},     {name: 'Gainsboro',            color: 'dcdcdc'},     {name: 'GhostWhite',           color: 'f8f8ff'},     {name: 'Gold',                 color: 'ffd700'},     {name: 'GoldenRod',            color: 'daa520'},     {name: 'Gray',                 color: '808080'},     {name: 'Grey',                 color: '808080'},     {name: 'Green',                color: '008000'},     {name: 'GreenYellow',          color: 'adff2f'},     {name: 'HoneyDew',             color: 'f0fff0'},     {name: 'HotPink',              color: 'ff69b4'},     {name: 'IndianRed',            color: 'cd5c5c'},     {name: 'Indigo',               color: '4b0082'},     {name: 'Ivory',                color: 'fffff0'},     {name: 'Khaki',                color: 'f0e68c'},     {name: 'Lavender',             color: 'e6e6fa'},     {name: 'LavenderBlush',        color: 'fff0f5'},     {name: 'LawnGreen',            color: '7cfc00'},     {name: 'LemonChiffon',         color: 'fffacd'},     {name: 'LightBlue',            color: 'add8e6'},     {name: 'LightCoral',           color: 'f08080'},     {name: 'LightCyan',            color: 'e0ffff'},     {name: 'LightGoldenRodYellow', color: 'fafad2'},     {name: 'LightGray',            color: 'd3d3d3'},     {name: 'LightGrey',            color: 'd3d3d3'},     {name: 'LightGreen',           color: '90ee90'},     {name: 'LightPink',            color: 'ffb6c1'},     {name: 'LightSalmon',          color: 'ffa07a'},     {name: 'LightSeaGreen',        color: '20b2aa'},     {name: 'LightSkyBlue',         color: '87cefa'},     {name: 'LightSlateGray',       color: '778899'},     {name: 'LightSlateGrey',       color: '778899'},     {name: 'LightSteelBlue',       color: 'b0c4de'},     {name: 'LightYellow',          color: 'ffffe0'},     {name: 'Lime',                 color: '00ff00'},     {name: 'LimeGreen',            color: '32cd32'},     {name: 'Linen',                color: 'faf0e6'},     {name: 'Magenta',              color: 'ff00ff'},     {name: 'Maroon',               color: '800000'},     {name: 'MediumAquaMarine',     color: '66cdaa'},     {name: 'MediumBlue',           color: '0000cd'},     {name: 'MediumOrchid',         color: 'ba55d3'},     {name: 'MediumPurple',         color: '9370db'},     {name: 'MediumSeaGreen',       color: '3cb371'},     {name: 'MediumSlateBlue',      color: '7b68ee'},     {name: 'MediumSpringGreen',    color: '00fa9a'},     {name: 'MediumTurquoise',      color: '48d1cc'},     {name: 'MediumVioletRed',      color: 'c71585'},     {name: 'MidnightBlue',         color: '191970'},     {name: 'MintCream',            color: 'f5fffa'},     {name: 'MistyRose',            color: 'ffe4e1'},     {name: 'Moccasin',             color: 'ffe4b5'},     {name: 'NavajoWhite',          color: 'ffdead'},     {name: 'Navy',                 color: '000080'},     {name: 'OldLace',              color: 'fdf5e6'},     {name: 'Olive',                color: '808000'},     {name: 'OliveDrab',            color: '6b8e23'},     {name: 'Orange',               color: 'ffa500'},     {name: 'OrangeRed',            color: 'ff4500'},     {name: 'Orchid',               color: 'da70d6'},     {name: 'PaleGoldenRod',        color: 'eee8aa'},     {name: 'PaleGreen',            color: '98fb98'},     {name: 'PaleTurquoise',        color: 'afeeee'},     {name: 'PaleVioletRed',        color: 'db7093'},     {name: 'PapayaWhip',           color: 'ffefd5'},     {name: 'PeachPuff',            color: 'ffdab9'},     {name: 'Peru',                 color: 'cd853f'},     {name: 'Pink',                 color: 'ffc0cb'},     {name: 'Plum',                 color: 'dda0dd'},     {name: 'PowderBlue',           color: 'b0e0e6'},     {name: 'Purple',               color: '800080'},     {name: 'RebeccaPurple',        color: '663399'},     {name: 'Red',                  color: 'ff0000'},     {name: 'RosyBrown',            color: 'bc8f8f'},     {name: 'RoyalBlue',            color: '4169e1'},     {name: 'SaddleBrown',          color: '8b4513'},     {name: 'Salmon',               color: 'fa8072'},     {name: 'SandyBrown',           color: 'f4a460'},     {name: 'SeaGreen',             color: '2e8b57'},     {name: 'SeaShell',             color: 'fff5ee'},     {name: 'Sienna',               color: 'a0522d'},     {name: 'Silver',               color: 'c0c0c0'},     {name: 'SkyBlue',              color: '87ceeb'},     {name: 'SlateBlue',            color: '6a5acd'},     {name: 'SlateGray',            color: '708090'},     {name: 'SlateGrey',            color: '708090'},     {name: 'Snow',                 color: 'fffafa'},     {name: 'SpringGreen',          color: '00ff7f'},     {name: 'SteelBlue',            color: '4682b4'},     {name: 'Tan',                  color: 'd2b48c'},     {name: 'Teal',                 color: '008080'},     {name: 'Thistle',              color: 'd8bfd8'},     {name: 'Tomato',               color: 'ff6347'},     {name: 'Turquoise',            color: '40e0d0'},     {name: 'Violet',               color: 'ee82ee'},     {name: 'Wheat',                color: 'f5deb3'},     {name: 'White',                color: 'ffffff'},     {name: 'WhiteSmoke',           color: 'f5f5f5'},     {name: 'Yellow',               color: 'ffff00'},     {name: 'YellowGreen',          color: '9acd32'} ];    const genColorNameLightness = [     {name: 'pale',   value: 0.87},     {name: 'light',  value: 0.76},     {name: 'bright', value: 0.65},     {name: 'deep',   value: 0.35},     {name: 'dim',    value: 0.22},     {name: 'dark',   value: 0.12} ];    const genColorNameSaturation = [     {name: 'calm',  value: 0.72},     {name: 'dull',  value: 0.46},     {name: 'dirty', value: 0.21} ];    const genColorNameHue = [     {name: 'violet',  value: 285},     {name: 'purple',  value: 269},     {name: 'indigo',  value: 252},     {name: 'blue',    value: 241},     {name: 'cobalt',  value: 222},     {name: 'sky',     value: 211},     {name: 'aqua',    value: 193},     {name: 'cyan',    value: 177},     {name: 'jade',    value: 154},     {name: 'green',   value: 112},     {name: 'lime',    value:  74},     {name: 'yellow',  value:  54},     {name: 'mango',   value:  42},     {name: 'orange',  value:  30},     {name: 'amber',   value:  17},     {name: 'salmon',  value:  11},     {name: 'red',     value:   0},     {name: 'rose',    value: 335},     {name: 'magenta', value: 310} ];    function parseColorNameLightness(name)  {     for (const item of genColorNameLightness)      {         if (   name.startsWith(item.name)              ||     o1490(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameSaturation(name)  {     for (const item of genColorNameSaturation)      {         if (   name.startsWith(item.name)              ||     o1490(name.slice(0, item.name.length), item.name) <= 1                && !genColorNameHue.find(h => h.name.startsWith(name)))          {             return { value:     item.value,                       remaining: name.slice(item.name.length) };         }     }      return { value:     null,               remaining: name }; }    function parseColorNameHue(name)  {     for (const item of genColorNameHue)      {         if (   name === item.name              || o1490(name.slice(0, item.name.length), item.name) <= 1)          {             return item.value;         }     }      return null; }    function parseColorName(_colorName)  {     let colorName = _colorName.replace(/\s+/g, '');       if (   colorName === 'black'          || o1490(colorName, 'black') <= 1)         return [0, 0, 0];      if (   colorName === 'white'          || o1490(colorName, 'white') <= 1)         return [0, 0, 1];               const grayVariants = ['gray', 'grey'];      let isGray = false;     let gl     = 0.5;      for (const grayVariant of grayVariants)      {         if (   colorName.endsWith(grayVariant)              || o1490(colorName.slice(-grayVariant.length), grayVariant) <= 1)          {             isGray = true;                      const grayPrefix = colorName.slice(0, -grayVariant.length);                          if (grayPrefix)              {                 const { value } = parseColorNameLightness(grayPrefix);                                  if (value !== null)                      gl = value;             }              break;         }     }       if (isGray)         return [0, 0, gl];       let h = null;     let s = null;     let l = null;                     let result  = parseColorNameLightness(colorName);         l       = result.value;     let remName = result.remaining;          result  = parseColorNameSaturation(remName);         s       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);                      if (   h === null          || s === null          || l === null)      {         h = null;         s = null;         l = null;          result  = parseColorNameSaturation(colorName);         s       = result.value;         remName = result.remaining;          result  = parseColorNameLightness(remName);         l       = result.value;         remName = result.remaining;          h       = parseColorNameHue(remName);     }       if (h === null) return null;      if (l === null) l = 0.5;     if (s === null) s = 1.0;           return [h / 360, s, l]; }    function createColorName(rgb) {     if (rgb.length > 3 && rgba[3] == 0)         return 'transparent';       const hsl = o48(rgb);      let   h = hsl[0] * 360;      while (h >= 360) h -= 360;     while (h <    0) h += 360;          const s = hsl[1];     const l = hsl[2];            if (l >= 0.94) return 'white';     else if (l <  0.06) return 'black';       let strH = '';     let strS = '';     let strL = '';            if (l >= 0.81 && l < 0.94) strL = 'pale ';     else if (l >= 0.69 && l < 0.81) strL = 'light ';     else if (l >= 0.56 && l < 0.69) strL = 'bright ';     else if (l >= 0.31 && l < 0.44) strL = 'deep ';     else if (l >= 0.19 && l < 0.31) strL = 'dim ';     else if (l >= 0.06 && l < 0.19) strL = 'dark ';           if (l > 0.25 && l < 0.75)      {              if (s >= 0.62 && s < 0.88) strS = 'calm ';         else if (s >= 0.31 && s < 0.62) strS = 'dull ';         else if (s >= 0.12 && s < 0.31) strS = 'dirty ';     }       if (s >= 0.12)     {              if (h < 293 && h >= 278) strH = 'violet';         else if (h < 278 && h >= 259) strH = 'purple';         else if (h < 259 && h >= 248) strH = 'indigo';         else if (h < 248 && h >= 233) strH = 'blue';         else if (h < 233 && h >= 221) strH = 'cobalt';         else if (h < 221 && h >= 201) strH = 'sky';         else if (h < 201 && h >= 185) strH = 'aqua';         else if (h < 185 && h >= 169) strH = 'cyan';         else if (h < 169 && h >= 139) strH = 'jade';         else if (h < 139 && h >=  86) strH = 'green';         else if (h <  86 && h >=  63) strH = 'lime';         else if (h <  63 && h >=  45) strH = 'yellow';         else if (h <  45 && h >=  40) strH = 'mango';         else if (h <  40 && h >=  21) strH = 'orange';         else if (h <  21 && h >=  13) strH = 'amber';         else if (h <  13 && h >=   8) strH = 'salmon';         else if (h <   8 || h >= 352) strH = 'red';         else if (h < 352 && h >= 328) strH = 'rose';         else if (h < 328 && h >= 293) strH = 'magenta';         else              console.error('error parsing hue name');     }     else          strH = 'gray';       return strL + strS + strH; } 


var _clipboard = '';    function x867(str)  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.writeText(str);          else          {             const prevActive = document.activeElement;             const textArea   = document.createElement('textarea');              textArea.value = str;              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus();             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('copy') ? res() : rej();                 textArea.remove();                  prevActive.focus();             });         }     }     else         _clipboard = str; }    function n868()  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.readText();          else          {             let textArea = document.createElement('textarea');              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus({preventScroll: true});             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('paste') ? res(textArea.value) : rej();                 textArea.remove();             });         }     }     else         return new Promise((res, rej) => res(_clipboard)); }


function l1048(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function k1049(key, tag) {     return key.substring(tag.length+1); }    function i1050(key) { return l1048(key, h877); } function l1051(key) { return l1048(key, c875); } function x1052(key) { return l1048(key, q876); }    function n1053(key) { return k1049(key, h877); } function w1054(key) { return k1049(key, c875); } function n1055(key) { return k1049(key, q876); }


const u963               = '\uFFFD'; const d964            = '?';      const y965           = '?'; const g966        = y965;  const NAME_SEPARATOR         = ' '; const y967       = ' > '; const   d968       = ' / '; const  b969       = ':';  const f970          = ' •'; const  h971          = ' ◇';       const  c972    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const a973    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    
 const  j974     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const o975     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';
 const  p976 = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const e977 = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';
 const  s978  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const x979  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
 const  f980     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const e981     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
   function s982(color = true) {     return o4006          ? (color ? j974  : s978 )          : (color ? c972 : p976); }    function x983(color = true) {     return o4006          ? (color ? o975  : x979 )          : (color ? a973 : e977); }


var showDebugInfo = false;  var debugFlag1    = false;    function u961(nodeIds) {     let str = '';      for (let i = 0; i < nodeIds.length; i++)     {         if (i > 0) str += ', ';         str += nodeIds[i];     }      return str; }    function p962(nodes) {     let str = '';      nodes.map(n => n ? n.id : 'undefined').join(', ');                                return str; }    function updateDebugInfo() {     if (showDebugInfo)     {         debugInfoText.style.display = 'inline-block';          debugInfoText.innerHTML =                         'pan = '  + graph.currentPage.pan.x.toFixed(2) + ', ' + graph.currentPage.pan.y.toFixed(2)             + '<br/>' + 'zoom = ' + graph.currentPage.zoom.toFixed(4);     }     else         debugInfoText.style.display = 'none'; }


const c1040   = 0,       q1041 = 1,       j1042 = 2,       d1043  = 3;    class i1044 {     initial;     current;            constructor()     {         this.reset();     }            set(seed)     {         this.initial = seed;         this.current = seed;     }                rotate()     {         this.current = (this.current + 0x7ed55d16) + (this.current << 12);         this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);         this.current = (this.current + 0x165667b1) + (this.current <<  5);         this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);         this.current = (this.current + 0xfd7046c5) + (this.current <<  3);         this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);     }                next()     {         const seed = this.current;         this.rotate();         return seed;     }        reset()     {         this.current = this.initial;     } };    class Noise { 	interpolation = d1043; 	clip = false;  	seed = new i1044();  	v0; 	v1; 	v2; 	v3;  	step = 0;       constructor(seed = 0)     {         this.seed.set(seed);         this.reset();     }       next(scale = 1)     {                  scale = Math.max(1, scale);          let next = this.v1;          if (this.step >= 1)         {                                   this.seed.rotate();              this.v0 = this.v1;                      this.v1 = this.v2;             this.v2 = this.v3;                      this.v3 = b1045(this.seed.current);              this.step -= 1;         }                    switch (this.interpolation)         {             case c1040:             {                 next = this.v1;                 break;             }             case q1041:             {                 next = this.v1 + this.step * (this.v2 - this.v1);                 break;             }             case j1042:             {                 const ft = this.step * Math.PI;                 const f  = (1 - Math.cos(ft)) * 0.5;                                  next = this.v1 + f * (this.v2 - this.v1);                 break;             }             case d1043:             {                 const p = (this.v3 - this.v2) - (this.v0 - this.v1);                 const q = (this.v0 - this.v1) - p;                 const r =  this.v2 - this.v0;                 const s =  this.v1;                  const val =                        p * cube(this.step)                      + q * sqr(this.step)                      + r * this.step                      + s;                  next = this.clip                      ? Math.max(0, Math.min(val, 1))                      : val;                  break;             }         }          this.step += 1 / scale;          return next;     }          reset()     {         this.seed.reset();          this.v0 = b1045(this.seed.current); this.seed.rotate();         this.v1 = b1045(this.seed.current); this.seed.rotate();         this.v2 = b1045(this.seed.current); this.seed.rotate();         this.v3 = b1045(this.seed.current); this.seed.rotate();          this.step = 0;     } }   function b1045(x) {     return x / -0x7fffffff; }


const settings = {     debugMode:                     false,              a2551:         false,     j2552:              0.35,     objectCenterSize:              18,     m4020:               500,     showPages:                     false,     showAllColorSpaces:            false,     showNodeIcons:                 true,     showBoolValues:                true,     separateThousands:             true,     invertSimpleMathParamOrder:    true,     activateDeactiatesOthers:      true,     preferHtmlColorNames:          false,     randomShiftR:                  true,     colorShiftR:                   true,      showSnapshots:                 false,     showRestartInfo:               true,     showColorLegendInMenus:        false,     showClearUndoWarning:          true,     shareUsageMetrics:             true,     showObjectCount:               true,     showDebugMenu:                 false,              showNodeId:                    false,      m2553:           false,     enableAsserts:                 false,      showTooltipLongText:           false,     showTooltipLists:              false,     showTooltipColorInterpolation: true,     showTooltipColorBlindness:     true,     showTooltipColorContrast:      true,     showTooltipColorNames:         true,     showTooltipAscii:              true,      enableBetaFeatures:            false,                  logThreadMessages:             false,     logDataMessages:               false,     logMessages:                   false,      logActions:                    false,                   logLoading:                    false,      logRequests:                   false,      logValueUpdates:               false,      logObjectUpdates:              false,     logStyleUpdates:               false,                  logRawLoadPages:               false,      logRawLoadNodes:               false,      logRawLoadConnections:         false,               logRawSavePages:               false,      logRawSaveNodes:               false,      logRawSaveConnections:         false,               logRawRequests:                false,      logRawValues:                  false,      sessionId:                     '' };    function c3592(v3660, value) {     switch (v3660)     {         case 'debugMode':                     settings.debugMode                     = value;  break;                          case 'enableZoomedOutParams':         settings.a2551         = value;  break;         case 'minZoomForParams':              settings.j2552              = value;  break;         case 'objectCenterSize':              settings.objectCenterSize              = value;  break;         case 'objectBatchSize':               settings.m4020               = value;  break;         case 'showPages':                     settings.showPages                     = value;  break;         case 'showAllColorSpaces':            settings.showAllColorSpaces            = value;  break;         case 'showNodeIcons':                 settings.showNodeIcons                 = value;  break;         case 'showBoolValues':                settings.showBoolValues                = value;  break;         case 'separateThousands':             settings.separateThousands             = value;  break;         case 'invertSimpleMathParamOrder':    settings.invertSimpleMathParamOrder    = value;  break;         case 'activateDeactiatesOthers':      settings.activateDeactiatesOthers      = value;  break;         case 'preferHtmlColorNames':          settings.preferHtmlColorNames          = value;  break;         case 'randomShiftR':                  settings.randomShiftR                  = value;  break;         case 'colorShiftR':                   settings.colorShiftR                   = value;  break;                  case 'showSnapshots':                 settings.showSnapshots                 = value;  break;         case 'showRestartInfo':               settings.showRestartInfo               = value;  break;         case 'showColorLegendInMenus':        settings.showColorLegendInMenus        = value;  break;         case 'showClearUndoWarning':          settings.showClearUndoWarning          = value;  break;         case 'shareUsageMetrics':             settings.shareUsageMetrics             = value;  break;         case 'showObjectCount':               settings.showObjectCount               = value;  break;         case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;                                  case 'showNodeId':                    settings.showNodeId                    = value;  break;         case 'showTransformPoints':           settings.m2553           = value;  break;         case 'enableAsserts':                 settings.enableAsserts                 = value;  break;          case 'showTooltipLists':              settings.showTooltipLists              = value;  break;         case 'showTooltipLongText':           settings.showTooltipLongText           = value;  break;         case 'showTooltipColorInterpolation': settings.showTooltipColorInterpolation = value;  break;         case 'showTooltipColorBlindness':     settings.showTooltipColorBlindness     = value;  break;         case 'showTooltipColorContrast':      settings.showTooltipColorContrast      = value;  break;         case 'showTooltipColorNames':         settings.showTooltipColorNames         = value;  break;         case 'showTooltipAscii':              settings.showTooltipAscii              = value;  break;          case 'enableBetaFeatures':            settings.enableBetaFeatures            = value;  break;                             case 'logThreadMessages':             settings.logThreadMessages             = value;  break;         case 'logDataMessages':               settings.logDataMessages               = value;  break;         case 'logMessages':                   settings.logMessages                   = value;  break;          case 'logActions':                    settings.logActions                    = value;  break;         case 'logLoading':                    settings.logLoading                    = value;  break;         case 'logRequests':                   settings.logRequests                   = value;  break;         case 'logValueUpdates':               settings.logValueUpdates               = value;  break;         case 'logObjectUpdates':              settings.logObjectUpdates              = value;  break;         case 'logStyleUpdates':               settings.logStyleUpdates               = value;  break;                             case 'logRawLoadPages':               settings.logRawLoadPages               = value;  break;         case 'logRawLoadNodes':               settings.logRawLoadNodes               = value;  break;         case 'logRawLoadConnections':         settings.logRawLoadConnections         = value;  break;                          case 'logRawSavePages':               settings.logRawSavePages               = value;  break;         case 'logRawSaveNodes':               settings.logRawSaveNodes               = value;  break;         case 'logRawSaveConnections':         settings.logRawSaveConnections         = value;  break;                          case 'logRawRequests':                settings.logRawRequests                = value;  break;         case 'logRawValues':                  settings.logRawValues                  = value;  break;          case 'sessionId':                     settings.sessionId                     = value;  break;     }        switch (v3660)     {         case 'objectCenterSize':             d2496(             {                 cmd:             'figUpdateObjectCenterSize',                 objectCenterSize: settings.objectCenterSize             });             break;     } }    function c3516(v3660, valid, value, save = true) {     switch (v3660)     {         case 'debugMode':                     p3659(valid, v3660, value, x722                    ); break;                        case 'enableZoomedOutParams':         p3659(valid, v3660, value, a648        ); break;         case 'showPages':                     p3659(valid, v3660, value, g652                    ); break;         case 'showAllColorSpaces':            p3659(valid, v3660, value, i654           ); break;         case 'showNodeIcons':                 p3659(valid, v3660, value, x655                ); break;         case 'showBoolValues':                p3659(valid, v3660, value, p657               ); break;         case 'separateThousands':             p3659(valid, v3660, value, p658            ); break;         case 'invertSimpleMathParamOrder':    p3659(valid, v3660, value, o659   ); break;         case 'activateDeactiatesOthers':      p3659(valid, v3660, value, menuItemActivateDeactiatesOthers     ); break;         case 'preferHtmlColorNames':          p3659(valid, v3660, value, menuItemPreferHtmlColorNames         ); break;         case 'randomShiftR':                  p3659(valid, v3660, value, menuItemRandomShiftR                 ); break;         case 'colorShiftR':                   p3659(valid, v3660, value, menuItemColorShiftR                  ); break;          case 'showSnapshots':                 p3659(valid, v3660, value, menuItemShowSnapshots                ); break;         case 'showRestartInfo':               p3659(valid, v3660, value, menuItemShowRestartInfo              ); break;         case 'showColorLegendInMenus':        p3659(valid, v3660, value, i656       ); break;         case 'showClearUndoWarning':          p3659(valid, v3660, value, p660         ); break;         case 'shareUsageMetrics':             p3659(valid, v3660, value, w661            ); break;         case 'showObjectCount':               p3659(valid, v3660, value, r663              ); break;         case 'showDebugMenu':                 p3659(valid, v3660, value, h664                ); break;                                case 'showNodeId':                    p3659(valid, v3660, value, p667                   ); break;         case 'showTransformPoints':           p3659(valid, v3660, value, u668          ); break;         case 'enableAsserts':                 p3659(valid, v3660, value, n669                ); enableAsserts = value; break;                  case 'showTooltipLists':              p3659(valid, v3660, value, p643             ); break;         case 'showTooltipLongText':           p3659(valid, v3660, value, a642          ); break;         case 'showTooltipColorInterpolation': p3659(valid, v3660, value, s644); break;         case 'showTooltipColorBlindness':     p3659(valid, v3660, value, e647    ); break;         case 'showTooltipColorContrast':      p3659(valid, v3660, value, v645     ); break;         case 'showTooltipColorNames':         p3659(valid, v3660, value, j646        ); break;         case 'showTooltipAscii':              p3659(valid, v3660, value, e647    ); break;          case 'enableBetaFeatures':            p3659(valid, v3660, value, menuItemEnableBetaFeatures           ); break;                                case 'logThreadMessages':             p3659(valid, v3660, value, d723            ); break;         case 'logDataMessages':               p3659(valid, v3660, value, b724              ); break;         case 'logMessages':                   p3659(valid, v3660, value, w725                  ); break;          case 'logActions':                    p3659(valid, v3660, value, m726                   ); break;         case 'logLoading':                    p3659(valid, v3660, value, t727                   ); break;         case 'logRequests':                   p3659(valid, v3660, value, m728                  ); break;         case 'logValueUpdates':               p3659(valid, v3660, value, g729              ); break;         case 'logObjectUpdates':              p3659(valid, v3660, value, q730             ); break;         case 'logStyleUpdates':               p3659(valid, v3660, value, w731              ); break;                                case 'logRawLoadPages':               p3659(valid, v3660, value, l732              ); break;         case 'logRawLoadNodes':               p3659(valid, v3660, value, g733              ); break;         case 'logRawLoadConnections':         p3659(valid, v3660, value, z734        ); break;                                case 'logRawSavePages':               p3659(valid, v3660, value, h735              ); break;         case 'logRawSaveNodes':               p3659(valid, v3660, value, f736              ); break;         case 'logRawSaveConnections':         p3659(valid, v3660, value, y737        ); break;                                case 'logRawRequests':                p3659(valid, v3660, value, u738               ); break;         case 'logRawValues':                  p3659(valid, v3660, value, w739                 ); break;     }        if (   save         && v3660 != 'showAllColorSpaces')         k2555(v3660, f937(value)); }    function p3659(valid, setting, value, menu) {     if (valid)          settings[setting] = value;         switch (setting)     {         case 'showNodeId':             d2496(             {                 cmd:    'figUpdateShowIds',                 f2799: settings.showNodeId             });             break;     }       if (menu)         menu.m2870(settings[setting]); }    function updateSettingsMenus() {     x722                    .r326(settings.debugMode                    );                      a648        .m2870(settings.a2551        );     g652                    .m2870(settings.showPages                    );     i654           .m2870(settings.showAllColorSpaces           );     x655                .m2870(settings.showNodeIcons                );     p657               .m2870(settings.showBoolValues               );     p658            .m2870(settings.separateThousands            );     o659   .m2870(settings.invertSimpleMathParamOrder   );     menuItemActivateDeactiatesOthers     .m2870(settings.activateDeactiatesOthers     );     menuItemPreferHtmlColorNames         .m2870(settings.preferHtmlColorNames         );     menuItemRandomShiftR                 .m2870(settings.randomShiftR                 );     menuItemColorShiftR                  .m2870(settings. colorShiftR                 );      menuItemShowSnapshots                .m2870(settings.showSnapshots                );     menuItemShowRestartInfo              .m2870(settings.showRestartInfo              );     i656       .m2870(settings.showColorLegendInMenus       );     p660         .m2870(settings.showClearUndoWarning         );     w661            .m2870(settings.shareUsageMetrics            );     r663              .m2870(settings.showObjectCount              );     h664                .m2870(settings.showDebugMenu                );                      p667                   .m2870(settings.showNodeId                   );     u668          .m2870(settings.m2553          );     n669                .m2870(settings.enableAsserts                );      p643             .m2870(settings.showTooltipLists             );     a642          .m2870(settings.showTooltipLongText          );     s644.m2870(settings.showTooltipColorInterpolation);     e647    .m2870(settings.showTooltipColorBlindness    );     v645     .m2870(settings.showTooltipColorContrast     );     j646        .m2870(settings.showTooltipColorNames        );     menuItemShowTooltipAscii             .m2870(settings.showTooltipAscii             );                            d723            .m2870(settings.logThreadMessages            );     b724              .m2870(settings.logDataMessages              );     w725                  .m2870(settings.logMessages                  );      m726                   .m2870(settings.logActions                   );                        t727                   .m2870(settings.logLoading                   );     m728                  .m2870(settings.logRequests                  );     g729              .m2870(settings.logValueUpdates              );     q730             .m2870(settings.logObjectUpdates             );     w731              .m2870(settings.logStyleUpdates              );                        g733              .m2870(settings.logRawLoadPages              );     g733              .m2870(settings.logRawLoadNodes              );     z734        .m2870(settings.logRawLoadConnections        );                          h735              .m2870(settings.logRawSaveNodes              );     f736              .m2870(settings.logRawSaveNodes              );     y737        .m2870(settings.logRawSaveConnections        );                      u738               .m2870(settings.logRawRequests               );     w739                 .m2870(settings.logRawValues                 ); }    function updateMenuItemShowPages() {     g2559('showPages', f937(settings.showPages));     graph.f2087();     b186.update(); }    function updateMenuItemShowSnapshots() {     g2559('showSnapshots', f937(settings.showSnapshots));      snapshotBar.style.display = settings.showSnapshots ? 'block' : 'none';      }    function updateMenuItemShowAllColorSpaces() {     g2559('showAllColorSpaces', f937(settings.showAllColorSpaces));      graph.nodes         .filter(n => m1177.includes(n.type))         .forEach(n => n.f3030()); }    function updateMenuItemShowNodeIcons() {     graph.nodes.forEach(n => n.f3030()); }    function updateMenuItemShowBoolValues() {     graph.nodes         .filter(n => n.params.find(p => p.type == n1091) != null)         .forEach(n => n.f3030()); }    function updateMenuItemSeparateThousands() {     graph.nodes         .filter(n => n.params.find(p => p.type == n1091) != null)         .forEach(n => n.f3030()); }    function updateMenuItemInvertSimpleMathParamOrder() {     graph.nodes         .filter(n => n.type == u1113)         .forEach(n => n.f3030()); }    function updateMenuItemShowColorLegendInMenus() {     for (const menu of l575)         menu.items.forEach(i => i.u3453()); }    function enableFeatures(sub) {     enableMenuItem(menuItemSetValueNames,      true, sub);     enableMenuItem(menuItemEnableBetaFeatures, true, sub);       enableMenuItem(menuItemShowRestartInfo,    true, sub);     enableMenuItem(menuItemValueName,          true, sub);     enableMenuItem(menuItemObjectName,         true, sub);        enableMenuItem(z692,              true, sub);           enableMenuItem(q694,            true, sub);     enableMenuItem(l671,         true, sub);     enableMenuItem(menuItemSaveSelected,       true, sub);     enableMenuItem(s695,              true, sub);       enableMenuItem(u701,           true, sub);     enableMenuItem(m703,              true, sub);     enableMenuItem(g3474,           true, sub);          enableMenuItem(j705,       true, sub);     enableMenuItem(b706,        true, sub);          enableMenuItem(c720,        true, sub);       enableMenuItem(menuItemVectorSep1,         true, sub, true);     enableMenuItem(menuItemVectorVertex,       true, sub, true);     enableMenuItem(menuItemVectorEdge,         true, sub, true);     enableMenuItem(menuItemVectorRegion,       true, sub, true);     enableMenuItem(menuItemVectorNetwork,      true, sub, true);     enableMenuItem(menuItemBooleanShape,       true, sub, true);     enableMenuItem(menuItemSaveTemplate,       true, sub);     enableMenuItem(o721,    true, sub);       updatePanelButton();       graph.nodes.forEach(n => n.o3494(sub)); }    function updatePanelButton() {     if (z567     ) z567     .div.style.display = !(settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none';     if (btnDecoration) btnDecoration.div.style.display =  (settings.enableBetaFeatures && subscribed()) ? 'inline-block' : 'none'; }    function enableMenuItem(menuItem, enable, sub, beta = false) {     if (!menuItem) return;      menuItem.enabled = enable;     menuItem.sub     = sub;      menuItem.r326(           !beta         || beta && settings.enableBetaFeatures);      menuItem.update(); }    function updateMenuItemShowDebugMenu() {     updateElementDisplay(p672.div, settings.showDebugMenu);      w576.update(         k995(w576.div).x + 6,         k995(w576.div).y - 4,         true); }     function updateElementDisplay(menuItem, enable) {     menuItem.style.display = enable ? 'block' : 'none'; }    function loadLocalSettings() {     n2554('debugMode'                    );              n2554('enableZoomedOutParams'        );     n2554('minZoomForParams'             );     n2554('objectCenterSize'             );     n2554('objectBatchSize'              );     n2554('showNodeIcons'                );     n2554('showBoolValues'               );     n2554('separateThousands'            );     n2554('invertSimpleMathParamOrder'   );     n2554('activateDeactiatesOthers'     );     n2554('preferHtmlColorNames'         );     n2554('randomShiftR'                 );     n2554('colorShiftR'                  );      n2554('showSnapshots'                );     n2554('showRestartInfo'              );     n2554('showColorLegendInMenus'       );     n2554('showPages'                    );     n2554('showClearUndoWarning'         );     n2554('shareUsageMetrics'            );     n2554('showObjectCount'              );     n2554('showDebugMenu'                );              n2554('showNodeId'                   );     n2554('showTransformPoints'          );     n2554('enableAsserts'                );      n2554('showTooltipLists'             );     n2554('showTooltipLongText'          );     n2554('showTooltipColorInterpolation');     n2554('showTooltipColorBlindness'    );     n2554('showTooltipColorContrast'     );     n2554('showTooltipColorNames'        );     n2554('showTooltipAscii'             );      n2554('enableBetaFeatures'           );                  n2554('logThreadMessages'            );     n2554('logDataMessages'              );     n2554('logMessages'                  );      n2554('logActions'                   );                  n2554('logLoading'                   );     n2554('logRequests'                  );     n2554('logValueUpdates'              );     n2554('logObjectUpdates'             );     n2554('logStyleUpdates'              );                  n2554('logRawLoadPages'              );     n2554('logRawLoadNodes'              );     n2554('logRawLoadConnections'        );              n2554('logRawSavePages'              );     n2554('logRawSaveNodes'              );     n2554('logRawSaveConnections'        );              n2554('logRawRequests'               );     n2554('logRawValues'                 ); }


const q1056           = 'LIST#';  const h1057    = 'NLIST#'; const   v1058    = 'TLIST#'; const  s1059    = 'SLIST#';   const p1060            = 'NULL'; const x1061             = 'VAR'; const y1062       = 'VARGRP'; const g1063             = 'FEEDBK'; const s1064               = 'REPT'; const z1065                = 'CACHE'; const j1066               = 'FRZ'; const v1067                = 'TIMER'; const f1068           = 'VNAME'; const r1352 = 'GVNAMES'; const d1353     = 'VNAMES'; const x1354          = 'ONAME';  const u1069              = 'CMB'; const n1070         = 'LSASIT'; const j1071              = 'EXTR'; const f1072            = 'SETP'; const t1073            = 'GETP'; const b1074              = 'SUBLST'; const k1075               = 'UNIQ'; const b1349         = 'RORD'; const o1350           = 'SHFTLST'; const i1076         = 'REVLST'; const t1351          = 'BUKLST'; const o1077                 = 'SORT'; const t1078               = 'CLMN'; const b1079                 = 'CELL'; const u1080                 = 'LIST'; const k1081           = 'COUNT'; const OBJECT_COUNT         = 'OBJCOUNT'; const o1082             = 'LCONT'; const w1083               = 'SELECT'; const w1360     = 'LSTSEL'; const r1084              = 'IF'; const z1085               = 'LSTFLT';   const z1087            = 'ANY#';   const x1088 = [     q1056,     h1057,     v1058,     s1059,     u1069,     j1071,     f1072,     t1073,     b1074,     u1080,     k1081,     o1082,     s1064 ];   const f1089 = [            q1056,     h1057,       v1058,      s1059 ];   const v1086                 = 'ITER';   const l1108             = 'PROB';   const HOLD                    = 'HOLD';   const n1091            = 'NUM#';   const x1092                  = 'NUM';    const v1355        = 'NPREC';    const t1093             = 'NSIGN';    const q1094         = 'ABS';    const p1356         = 'NEG';    const f1095            = 'ROUND';    const z1357         = 'QUANT';    const s1096    = 'SMINMAX';    const c1097           = 'MINMAX';    const k1098           = 'LIM';    const j1099            = 'NCURVE';    const e1358              = 'NMAP';    const k1359             = 'NBIAS';    const s1100              = 'NANISNUM'; const c1101         = 'CONST';   const h1102         = 'DATE';   const q1103         = 'SEQ';   const w1104            = 'RANGE';   const y1105             = 'WAVE';   const f1106           = 'RAND';   const d1107            = 'NOISE';   const l1109       = 'ACCUM';   const e1110      = 'LERP';  const c1111            = 'SOLVE'; const n1112          = 'NANIM';  const u1113      = 'SMATH';   const x1114             = 'MATH';   const f1115              = 'ADD';    const i1116         = 'SUB';    const b1117         = 'MUL';    const p1118           = 'DIV';    const t1119           = 'MOD';    const d1120         = 'EXP';  const j1121          = 'NBOOL';   const x1122              = 'NOT'; const z1123              = 'AND'; const o1124               = 'OR'; const a1125              = 'XOR';  const l1126        = 'COND'; const m1127            = 'EQ'; const c1128        = 'NE'; const v1129             = 'LT'; const r1130    = 'LE'; const f1131          = 'GT'; const d1132 = 'GE';  const k1133             = 'TRIG';   const j1134              = 'SIN';    const r1135              = 'COS';    const c1136              = 'TAN'; const x1137            = 'ATAN2';  const z1138           = 'CNVANG';   const g1090 = [     p1060,     x1061,     y1062,     ...x1088,     n1070,     j1071,     f1072,     t1073,     b1074,     k1075,     b1349,     o1350,     i1076,     t1351,     t1078,     o1077,     b1079,     u1080,     w1083,     w1360,     r1084,     z1085,     g1063,     s1064,          v1086,     l1108,     HOLD,     z1065,     j1066,     v1067,     f1068,     r1352,     d1353,     x1354 ];   const s1139 = [     x1114,     u1113,     f1115,     i1116,     b1117,     p1118,     t1119,     d1120 ];   const t1140 = [     j1121,     x1122,     z1123,     o1124,     a1125 ];   const r1141 = [     l1126,     m1127,     c1128,     v1129,     r1130,     f1131,     d1132 ];   const n1142 = [     k1133,     j1134,     r1135,     c1136,     x1137 ];   const l1143     = 'TEXT#'; const a1144           = 'TEXT'; const d1145    = 'TLEN'; const z1146      = 'TTRIM'; const d1147 = 'TSUB'; const v1148  = 'TCONT'; const l1149      = 'TCASE'; const w1150   = 'TREPL'; const r1151      = 'TJOIN'; const n1152       = 'TPAD'; const q1153   = 'TCMP'; const f1154      = 'TCHAR'; const j1155   = 'TUNI'; const f1156  = 'INDEX'; const i1157 = 'N2T'; const b1158  = 'C2T'; const w1159 = 'T2N'; const m1160  = 'T2C'; const t1161     = 'TSPLT'; const t3504      = 'TJSON'; const q1163       = 'TCSV'; const t1164     = 'FETCH'; const y1165      = 'TFILE';   const y1166 = [     n1091,     h1057,     x1092,     v1355,     t1093,     q1094,     p1356,     f1095,     z1357,     s1096,     c1097,     k1098,     j1099,     e1358,     k1359,     s1100,     c1101,     h1102,     q1103,     w1104,     y1105,     f1106,     d1107,     l1109,     e1110,     c1111,     n1112,     i1157,     f1154,      ...s1139,     ...t1140,     ...r1141,     ...n1142,      z1138,     t1351 ];   const d1167 = [     l1143,     v1058,     a1144,     d1145,     z1146,     d1147,     v1148,     l1149,     r1151,     n1152,     w1150,     q1153,     j1155,     f1156,     w1159,     m1160,     t1161,     t3504,     q1163,     t1164,     y1165 ];   const l1168        = 'COL#';   const g1169              = 'COL';    const c1170        = 'CVAL';   const k1171      = 'CCOR';   const b1172   = 'COLP3'; const w1173     = 'CCNT';   const z1174         = 'BLND';   const m1175  = 'CLERP';  const v1176        = 'CBLND';   const m1177 = [     l1168,     g1169,     k1171,     b1172,     z1174,     m1175,     v1176,     b1158 ];   const y1178          = 'FILL#'; const l1179                = 'FILL'; const a1180          = [y1178, l1179];    const i1181        = 'STRK#'; const q1182              = 'STRK'; const q1183        = [i1181, q1182];    const m1190  = 'STRKSD#'; const u1191        = 'STRKSD'; const w1192  = [m1190, u1191];  const y1184    = 'CSTOP#'; const a1185          = 'CSTOP'; const s1186    = [y1184, a1185];    const m1187      = 'GRAD#'; const e1188            = 'GRAD'; const z1189      = [m1187, e1188];    const d1193 = 'RCRN#'; const f1194       = 'RCRN'; const z1195 = [d1193, f1194];  const q1196   = 'DRSH#'; const x1197         = 'DRSH'; const r1198   = [q1196, x1197];   const b1199  = 'INSH#'; const e1200        = 'INSH'; const w1201  = [b1199, e1200];   const s1202    = 'LBLR#'; const p1203          = 'LBLR'; const j1204    = [s1202, p1203];   const m1205     = 'BBLR#'; const q1206           = 'BBLR'; const q1207     = [m1205, q1206];   const q1208    = 'MASK#'; const t1209          = 'MASK'; const n1210    = [q1208, t1209];   const s1211   = 'BLEND#'; const j1212         = 'BLEND'; const q1213   = [s1211, j1212];   const v1214 = [     ...w1192,     ...z1195,     ...r1198,     ...w1201,     ...j1204,     ...q1207,     ...q1213,     ...n1210 ];   const e1215 = [            l1168,              y1178,          m1187,            i1181,     m1190,      q1196,     b1199,       s1202,        m1205,      s1211,       q1208 ];   const d1216           = 'CSTL';     const j1217           = 'SHP#';    const r1218       = 'RECT#'; const t1219             = 'RECT';   const g1220       = [r1218, t1219];   const m1221            = 'LINE#'; const y1222                  = 'LINE';  const l1223            = [m1221, y1222];     const t1224         = 'ELPS#'; const h1225               = 'ELPS';  const o1226         = [t1224, h1225];   const x1227         = 'TRPZ#'; const r1228               = 'TRPZ'; const a1229         = [x1227, r1228];   const q1236         = 'POLY#'; const b1237               = 'POLY';  const h1238         = [q1236, b1237];     const m1239            = 'STAR#'; const j1240                  = 'STAR';  const b1241            = [m1239, j1240];     const v1242      = 'TXTS#'; const l1243            = 'TXTS';  const m1244      = [v1242, l1243];    const u1245           = 'PT#'; const l1246                 = 'PT'; const f1247           = [u1245, l1246];  const h1248          = 'PCORN';  const b1249     = 'VPATH#'; const w1250           = 'VPATH';  const g1251     = [b1249, w1250];   const g1252   = 'VPT#'; const x1253         = 'VPT';  const v1254   = [g1252, x1253];  const s1255     = 'VEDGE#'; const x1256           = 'VEDGE';  const g1257     = [s1255, x1256];  const w1258   = 'VREG#'; const b1259         = 'VREG';  const x1260   = [w1258, b1259];  const s1261  = 'VNET#'; const z1262        = 'VNET';  const q1263  = [s1261, z1262];  const y1264     = 'SGRP#'; const p1265           = 'SGRP'; const y1266     = [y1264, p1265];  const m1267           = 'FRM#'; const k1268                 = 'FRM'; const r1269           = [m1267, k1268];   const x1231        = 'ARC#'; const v1230              = 'ARC'; const u1232        = [x1231, v1230];  const g1234       = 'WAVEP#'; const x1233             = 'WAVEP'; const e1235       = [g1234, x1233];  const n1270                  = 'MOVE'; const c1271                = 'ROT'; const c1272                 = 'SCALE'; const e1273                  = 'SKEW';  const SHOW_CENTER           = 'SHOWCNTR'; const j1274            = 'SCENTR'; const e1275           = 'RSTX';  const q1276                 = 'PLACE'; const n1277           = 'APPLY';    const PATH_LENGTH           = 'PTHLEN'; const JOIN_PATHS            = 'JOINPTH'; const REORIENT_PATHS        = 'REORPTH'; const d1284      = 'PTALPATH'; const o1285 = 'CPTONPATH'; const y1278        = 'MESPT'; const y1279           = 'PTANGLE'; const v1280                = 'VECLEN'; const j1281         = 'CIRCEN'; const ARC_FROM_POINTS       = 'ARCPT'; const p1282       = 'INTLIN'; const p1283     = 'PTLERP'; const REVERSE_PATH          = 'REVPTH'; const BLEND_PATH            = 'BLENDPTH';   const PATH_TYPES = [     w1250,      r1228,     v1230,     x1233 ];  const PATH_VALUES = [     b1249,      x1227,     x1231,     g1234 ];   const q1286         = 'SBOOL'; const w1287   = 'SBOOL#';  const b1288            = 'SBOOLU'; const n1289         = 'SBOOLS'; const g1290        = 'SBOOLI'; const j1291          = 'SBOOLE';   const e1292 = [     q1286,     w1287,     b1288,     n1289,     g1290,     j1291 ];   const g1293               = 'RENDER'; const EXPORT               = 'EXPORT';   const p1294 = [     j1217,     s1059,     r1218,     m1221,     t1224,     x1227,     q1236,     m1239,     v1242,     u1245,     b1249,     g1252,     s1255,     w1258,     s1261,     x1231,     g1234,     y1264,     m1267,     w1287,     q1196,     b1199,     s1202,     m1205,     s1211,     q1208 ];   const q1295 = [     c1271,     c1272,     e1273 ];   const c1296 = [     ...p1294,      ...g1220,     ...l1223,     ...o1226,     ...a1229,     ...h1238,     ...b1241,     ...m1244,     ...f1247,        h1248,     ...g1251,     ...v1254,     ...g1257,     ...x1260,     ...q1263,     ...u1232,     ...e1235,     ...y1266,     ...r1269,     ...e1292,          n1270,     ...q1295,     SHOW_CENTER,     j1274,     e1275,              q1276,     n1277,          PATH_LENGTH,     JOIN_PATHS,     REORIENT_PATHS,     d1284,     o1285,              y1278,     y1279,     v1280,     j1281,     v1230,     x1233,     ARC_FROM_POINTS,     p1282,     p1283,     REVERSE_PATH,     BLEND_PATH,      g1293,     EXPORT ];   const f1297 = [             q1056,      h1057,        v1058,       s1059,                 n1091,             l1143,            l1168,               y1178,       y1184,         m1187,           i1181,         y1184,         m1187,              j1217,        r1218,             m1221,          t1224,          x1227,          q1236,             m1239,       v1242,            u1245,      b1249,    g1252,      s1255,    w1258,   s1261,      y1264,            m1267,     d1193,      q1196,     b1199,       s1202,        m1205,       s1211,       q1208 ];   const m1298    = 'GROUP'; const w1299   = 'GPARAM';   const w1300 = [     m1298,     w1299 ];   const z1301       = 'CMNT'; const v1302 = 'CMNTARR'; const q1303         = 'PANEL';   const o1304        = 'ACT'; const u1305 = 'BFACT'; const e1306   = 'BFLST'; const c1307      = 'DIS'; const n1308       = 'NOC';   const PARAM         = 'PARAM';     const q1309           = 'LOG';   const c1310         = 'GRAPH';   const k1311 =  [        [t1119,   '%' ],     [p1118,   '/' ],      [i1116, '−' ],     [f1115,      '+' ],     [b1117, '×' ],     [d1120, 'e<sup>x']  ];   const i1312 =  [        [p1118,   '/' ],      [i1116, '−' ],     [f1115,      '+'],     [b1117, '×'] ];    const x1313 = 0; const f1314 = 1; const o1315  = 2; const c1316 = 3;   const j1317 =  [        [x1313, 'not'],     [f1314, 'xor'],      [o1315,  'or' ],     [c1316, 'and'] ];    const n1318             = 0; const j1319    = 1; const y1320        = 2; const b1321            = 3; const k1322 = 4; const w1323          = 5;   const l1324 =  [        [n1318,             '<'],     [j1319,    '≤'],     [y1320,        '≠'],     [b1321,            '='],     [k1322, '≥'],     [w1323,          '>'] ];    const d1325  = 0; const x1326  = 1; const v1327  = 2; const o1328 = 3; const t1329 = 4; const c1330 = 5;   const l1331 =  [        [d1325,  'sin' ],     [x1326,  'cos' ],     [v1327,  'tan' ],     [o1328, 'asin'],     [t1329, 'acos'],     [c1330, 'atan'] ];    const a1332               = 'EMPTY'; const c1333             = 'CONNECT'; const c1334              = 'CREATE'; const w1335       = 'CREATE_INSERT'; const n1336              = 'DELETE'; const z1337          = 'DISCONNECT'; const b1338          = 'LINK_STYLE'; const i1339       = 'LINK_VARIABLE'; const j1340 = 'LINK_VARIABLE_GROUP'; const o1341         = 'MAKE_ACTIVE'; const MAKE_NOT_CONDITION_ACTION  = 'MAKE_NOT_CONDITION'; const j1342        = 'MAKE_PASSIVE'; const l1343               = 'PASTE'; const l1344           = 'RECONNECT'; const v1345              = 'REMOVE'; const b1346              = 'RENAME'; const g1347      = 'REORDER_INPUTS'; const a1348 = 'REORDER_CONNECTIONS'; const i1361              = 'SELECT'; const n1362         = 'SELECT_MOVE'; const u1363          = 'MOVE_NODES'; const o1364     = 'SET_PARAM_VALUE'; const SET_MULTIPLE_VALUES_ACTION = 'SET_MULTIPLE_VALUES'; const r1365   = 'SET_PARAM_SETTING'; const k1366       = 'SET_NODE_RECT'; const g1367      = 'TOGGLE_DISABLE'; const v1368 = 'TOGGLE_PARAM_HEADER'; const j1369   = 'SET_CURRENT_GRAPH'; const a1370         = 'CREATE_PAGE'; const c1371         = 'DELETE_PAGE'; const h1372         = 'GROUP_NODES'; const e1373       = 'UNGROUP_NODES'; const z1374     = 'HIGHLIGHT_NODES'; const SCROLL_LIST_NODE_ACTION    = 'SCROLL_LIST_NODE'; const SET_LIST_DIVIDER_ACTION    = 'SET_LIST_DIVIDER'; const SET_NODE_PARAM_ACTION      = 'SET_NODE_PARAM';   const k1375               = 'BNORM'; const r1376               = 'BDARK'; const y1377             = 'BMULT'; const k1378          = 'BPDRK'; const p1379           = 'BBURN'; const c1380              = 'BLITE'; const q1381               = 'BSCRN'; const u1382         = 'BPLGT'; const n1383          = 'BDODG'; const e1384              = 'BOVER'; const i1385           = 'BSOFT'; const t1386           = 'BHARD'; const x1387           = 'BDIFF'; const e1388            = 'BEXCL'; const h1389                  = 'BHUE'; const g1390           = 'BSAT'; const o1391                = 'BCOL'; const v1392           = 'BLUM';   const r1393 = [     [k1375,       'normal',       'NORMAL'      ],     [r1376,       'darken',       'DARKEN'      ],     [y1377,     'multiply',     'MULTIPLY'    ],     [k1378,  'plus darker',  'LINEAR_BURN' ],     [p1379,   'color burn',   'COLOR_BURN'  ],     [c1380,      'lighten',      'LIGHTEN'     ],     [q1381,       'screen',       'SCREEN'      ],     [u1382, 'plus lighter', 'LINEAR_DODGE'],     [n1383,  'color dodge',  'COLOR_DODGE' ],     [e1384,      'overlay',      'OVERLAY'     ],     [i1385,   'soft light',   'SOFT_LIGHT'  ],     [t1386,   'hard light',   'HARD_LIGHT'  ],     [x1387,   'difference',   'DIFFERENCE'  ],     [e1388,    'exclusion',    'EXCLUSION'   ],     [h1389,          'hue',          'HUE'         ],     [g1390,   'saturation',   'SATURATION'  ],     [o1391,        'color',        'COLOR'       ],     [v1392,   'luminosity',   'LUMINOSITY'  ] ];    const m1394 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const b1395           =  0; const a1396        =  1;  const o1397      =  2;   const w1398     = 2; const u1399    =  3;   const l1400   = 3;  const v1401       =  4;   const l1402 = 4; const r1403         =  5;   const a1404            =  6; const l1405            =  7; const m1406            =  8;  const n1407          =  9;  const d1408          = 10; const n1409        = 11;   const d1410  = 12; const q1411   = 13; const o1412    = 14;                                     const o1413   = 15; const h1414     = 16; const g1415  = 17;  const o1416        = 18;  const z1417           = 19; const p1418      = 20;     const f1419        = 21; const x1420          = 22; const m1421           = 23;  const c1422              = 24;                                                                         const q1453    = 24;                                                                                              const n1423 = 24; const c1424              = 25;                                                                         const w1454   = 25; const l1425          = 26;    const h1426         = 27;                                      const p1427     = 28;   const s1428   = 28;   const y1429 = 28;   const j1430    = 28;   const d1431   = 28;   const c1432  = 28;   const q1433      = 28;   const e1434    = 28;                                 const h1435   = 29;                                        const e1436 = 29;   const d1437 = 29;   const m1438 = 29;   const t1439     = 29;   const y1455     = 29;                                 const g1441   = 30;                                        const t1442   = 30;                                 const q1443 = 30;   const e1444           = 30;   const w1440 = 30;                                                                                                                                                                   const q1445   = 31;                                                                                                                                        const a1446           = 31;                                                                                                                                                                                                       const g1447      = 32;                                                                                                                                                                                                       const j1448     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const f1449        = 34;                                                                                                                                                                                                       const m1450        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const b1451    = 36;                                                                                                                                                                                                       const y1452 = 37;


class i1842 {     type;          nodeId     = '';       objectId   = NULL;     objectName = NULL;      m3819  = -1;       retain     = 0;     feedback   = false;       showCenter = false;          c4207;      xp0   = null;      xp1   = null;      xp2   = null;       sp0   = null;      sp1   = null;      sp2   = null;       c3739;     scaleStyle;        constructor(type, nodeId, objectId, objectName)     {         this.type         = type;         this.nodeId       = nodeId;         this.objectId     = objectId;         this.objectName   = objectName;          this.c4207        = clone(identity);          this.c3739 = 1;         this.scaleStyle   = 1;     }        z3358(base)     {         this.m3819    = base.m3819;                  this.feedback     = base.feedback;         this.retain       = base.retain;          this.showCenter   = base.showCenter;          this.c4207        = clone(base.c4207);          this.xp0          = clone(base.xp0);         this.xp1          = clone(base.xp1);         this.xp2          = clone(base.xp2);          this.sp0          = clone(base.sp0);         this.sp1          = clone(base.sp1);         this.sp2          = clone(base.sp2);          this.c3739 = base.c3739;         this.scaleStyle   = base.scaleStyle;     }        copy()     {         p953('invalid use of abstract method i1842.copy()');         return null;     }        getCount()     {         return 1;     }        v3741(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         let _cx;          let _cy;           if (units == 0)         {             _cx = bounds.x + cx * bounds.width;             _cy = bounds.y + cy * bounds.height;                     }         else if (units == 1)         {             _cx = bounds.x + cx;             _cy = bounds.y + cy;         }         else          {             _cx = cx;             _cy = cy;                     }           const ds1 = p900(this.sp1, this.sp0);         const ds2 = p900(this.sp2, this.sp0);          this.sp0  = point(_cx, _cy);          this.sp1  = h895(this.sp0, ds1);         this.sp2  = h895(this.sp0, ds2);           if (PATH_TYPES.includes(this.type))             this.v3742();     }        h4097(x, y, a = 0)     {         this.c4207 =             [[Math.cos(a), -Math.sin(a), x],              [Math.sin(a),  Math.cos(a), y],              [0,            0,           1]];     }        b3729(x, y, w, h)     {         this.xp0 = point(x,     y    );         this.xp1 = point(x + w, y    );         this.xp2 = point(x,     y + h);     }        k3731()     {         let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);         let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);                   let sx = vr.x;         let sy = vb.y;              let kx = vr.y;         let ky = vb.x;                  let dx = this.sp0.x;         let dy = this.sp0.y;                   let c4207 = y889(             b893(dx, dy),             [[sx, ky, 0],              [kx, sy, 0],              [0,  0,  1]]);               return c4207;     }                getBounds()     {         let bounds = m1047.NaN;          const dp = p900(this.xp1, this.xp0);          bounds = y3744(bounds, this.xp0);         bounds = y3744(bounds, this.xp1);         bounds = y3744(bounds, this.xp2);         bounds = y3744(bounds, h895(this.xp2, dp));          return bounds;     }        r4098(c4207, affectSpace)     {         const space = this.k3731();           if (this.type == l1246)         {             if (affectSpace > 0)             {                 const p = j3730(point(this.x, this.y), c4207, space);                  this.x = p.x;                 this.y = p.y;             }              if (affectSpace != 1)                 this.applySpaceTransform(c4207, space);         }         else if (PATH_TYPES.includes(this.type))         {             if (affectSpace > 0)             {                 this.applyObjectTransform(c4207, space);                  this.updatePoints(c4207, space);                 this.v3742();                              }              if (affectSpace != 1)                 this.applySpaceTransform(c4207, space);         }         else if (this.type == p1265)         {             for (const l111 of this.children)             {                 if (affectSpace > 0)                 {                     l111.applyObjectTransform(c4207, space);                      if (l111.type == w1250)                         l111.updatePoints(c4207, space);                 }                  if (affectSpace != 1)                     l111.applySpaceTransform(c4207, space);             }                         }         else         {             if (affectSpace > 0)                 this.applyObjectTransform(c4207, space);              if (affectSpace != 1)                 this.applySpaceTransform(c4207, space);         }     }        applyObjectTransform(c4207, space)     {         if (   this.xp0.x == this.xp1.x             && this.xp0.y == this.xp1.y)             this.xp1.x += 0.0001;          if (   this.xp0.x == this.xp2.x             && this.xp0.y == this.xp2.y)             this.xp2.y += 0.0001;          this.xp0 = j3730(this.xp0, c4207, space);         this.xp1 = j3730(this.xp1, c4207, space);         this.xp2 = j3730(this.xp2, c4207, space);     }        applySpaceTransform(c4207, space)     {         this.sp0 = j3730(this.sp0, c4207, space);         this.sp1 = j3730(this.sp1, c4207, space);         this.sp2 = j3730(this.sp2, c4207, space);     }        checkFlipped(flipX, flipY)     {         if (flipX)         {             const d1 = p900(this.xp1, this.xp0);              this.xp0 = h895(this.xp0, d1);             this.xp2 = h895(this.xp2, d1);             this.xp1 = p900(this.xp1, d1);         }                   if (flipY)         {             const d2 = p900(this.xp2, this.xp0);              this.xp0 = h895(this.xp0, d2);             this.xp1 = h895(this.xp1, d2);             this.xp2 = p900(this.xp2, d2);         }     }        b3755()     {         return {             type:       this.type,             nodeId:     this.nodeId,              objectId:   this.objectId,             objectName: this.objectName,                          feedback:   this.feedback,              xp0:        this.xp0 ? this.xp0 : null,             xp1:        this.xp1 ? this.xp1 : null,             xp2:        this.xp2 ? this.xp2 : null         };     }        o3740()     {         return [          this.type,          this.nodeId,           this.objectId,          this.objectName,                       this.feedback,          this.retain,                   this.xp0 ? this.xp0 : null,          this.xp1 ? this.xp1 : null,          this.xp2 ? this.xp2 : null,           0          ];     }        t3632()     {         return new c4216();     } }    function j3730(p, c4207, space) {     p = y888(p, f891(space));     p = y888(p, c4207);     p = y888(p, space);      return p; }    function j3737(l111) {     switch (l111.type)     {         case t1219:     return j1845 .prototype.copy.call(l111);         case y1222:          return x1841      .prototype.copy.call(l111);         case h1225:       return s1839   .prototype.copy.call(l111);         case r1228:       return g1850   .prototype.copy.call(l111);         case b1237:       return v1844   .prototype.copy.call(l111);         case j1240:          return f1848      .prototype.copy.call(l111);         case l1243:    return p1849      .prototype.copy.call(l111);         case l1246:         return b1843     .prototype.copy.call(l111);         case w1250:   return n1852.prototype.copy.call(l111);         case v1230:      return FigmaArcPath   .prototype.copy.call(l111);         case x1233:     return FigmaWavePath  .prototype.copy.call(l111);         case q1286: return p1837   .prototype.copy.call(l111);         case p1265:   return o1847.prototype.copy.call(l111);         case k1268:         return x1840     .prototype.copy.call(l111);     }      p953('invalid Figma object type \'' + l111.type + '\'');     return null; }    function getPointBounds(points) {     let minX = Number.MAX_SAFE_INTEGER;     let minY = Number.MAX_SAFE_INTEGER;     let maxX = Number.MIN_SAFE_INTEGER;     let maxY = Number.MIN_SAFE_INTEGER;      for (const p of points)     {         minX = Math.min(minX, p.x.value);         minY = Math.min(minY, p.y.value);         maxX = Math.max(maxX, p.x.value);         maxY = Math.max(maxY, p.y.value);     }      return new AbsRect(minX, minY, maxX, maxY); }    function getObjBounds(objects) {     let bounds = m1047.NaN;      for (const l111 of objects)         bounds = q3743(bounds, l111.getBounds());      return bounds; }    function v2585(node, l111) {     const sp0 = point(         l111.sp0.x ,          l111.sp0.y );      const sp1 = h895(sp0, n897(      p900(l111.sp1, l111.sp0),      settings.objectCenterSize));     const sp2 = h895(sp0, n897(n897(p900(l111.sp2, l111.sp0), -1), settings.objectCenterSize));          const center = createDecoPoly(         node.nodeId,         l111.objectId,         l111.objectName,          sp0,          [sp2, sp0, sp1],         false,         '',         [242, 72, 34],          f970,         true);      return center; }    function createDecoPoly(nodeId, objectId, objectName, center, points, closed, dashes, color, suffix, isCenter) {     const path = new n1852(         nodeId,         objectId   + suffix,         objectName + suffix,         points.map(p => b2022.fromPoint(objectId, p)),         closed ? 1 : 0,          0,          0,          0);       path.strokes.push([         'SOLID',          color[0],          color[1],          color[2],          100,          'NORMAL']);      path.strokeWeight =  1;     path.strokeAlign  = 'CENTER';     path.strokeJoin   = 'MITER';     path.strokeCap    = 'NONE';     path.strokeDashes =  dashes;     path.e3738       =  true;     path.isCenter     =  isCenter;       path.h4097(center.x, center.y);            return path; }    function d3627(value) {     return value         && value.objects         ? value.objects               .filter(o =>                       o.e3738  === false                   || o.isXform === true)               .map(o => o.copy())          : []; }


function w1822(l111, prop) {          if (prop.type ==         l1168)  v1823       (l111, prop);     else if (prop.type ==          y1178)  t1824        (l111, prop);     else if (prop.type ==      m1187)  b1825    (l111, prop);     else if (prop.type ==        i1181)  e1829      (l111, prop);     else if (prop.type ==  m1190)  addStrokeSidesProp (l111, prop);     else if (prop.type == d1193)  r1830(l111, prop);     else if (prop.type ==   q1196)  h1831  (l111, prop);     else if (prop.type ==  b1199)  j1832 (l111, prop);     else if (prop.type ==    s1202)  m1833   (l111, prop);     else if (prop.type ==     m1205)  c1834    (l111, prop);     else if (prop.type ==   s1211)  o1835  (l111, prop);     else if (prop.type ==    q1208)  e1836        (l111, prop); }    function v1823(l111, prop) {     const rgb = w4141(prop.v3241());      if (l111.type == p1265)     {         for (const _obj of l111.children)             w1822(_obj, prop);     }     else     {         l111.fills.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              255 ]);     } }    function t1824(l111, prop, target = l111.fills) {     if (prop.color.type != l1168)         return;       const rgb = w4141(prop.color.v3241());      if (l111.type == p1265)     {         for (const _obj of l111.children)             w1822(_obj, prop);     }     else     {         target.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              prop.opacity.t3632().value,             r1393[Math.min(Math.max(0, Math.round(prop.blend.value)), r1393.length-1)][2]]);     } }    function b1825(l111, prop, target = l111.fills)                 {     const gradient =      [         '',          [],          [],          '',          0                     ];       switch(prop.u3686.value)     {         case 0: gradient[0] = 'GRADIENT_LINEAR';  break;         case 1: gradient[0] = 'GRADIENT_RADIAL';  break;         case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;         case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;     }           let   x        =        prop.x     .value / 100;     let   y        =        prop.y     .value / 100;     let   s        = nozero(prop.size  .value / 100);     let   a        =        prop.angle .value / 360*Tau;     let   asp      = nozero(prop.aspect.value / 100);     const diag     =        prop.diagAspect;     let   sk       =        prop.skew  .value / 100;           const pos      = prop.position.value;     const isLinear = prop.u3686.value == 0;          const bounds   = l111.getBounds();       if (pos > 0)     {         if (   pos == 1             || pos == 2)          {             x = x / 100 * bounds.width;             y = y / 100 * bounds.height;         }                   x = x * 100 / nozero(bounds.width );         y = y * 100 / nozero(bounds.height);           if (pos == 4)         {             x = x - bounds.x / nozero(bounds.width );             y = y - bounds.y / nozero(bounds.height);                          s *= 100 / nozero(bounds.width);         }     }       let   p0 = point(x, y);     let   p1 = h895(p0, vector(a, diag === true ? s : s * nozero(asp)));     let   p2 = h895(p0, vector(a + Tau/4, s));      const a1 = anglev2(p0, p1);     const a2 = anglev2(p0, p2);           if (diag === true)     {         p1 = h895(p1, vector(a1 - Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p1))/2)));         p2 = h895(p2, vector(a2 + Tau/8, (asp-1) * Math.sqrt(sqr(distv(p0, p2))/2)));          p1 = h895(p1, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));         p2 = h895(p2, vector(a2 + Tau/8, s * sk * Math.sqrt(2)/2));     }     else     {         p2 = p900(p2, vector(a1, s * sk));     }       if (pos > 0)     {         if (   pos == 1             || pos == 3             || pos == 4)         {             const aspect = bounds.width / nozero(bounds.height);                          p1.y = p0.y + (p1.y - p0.y) * aspect;             p2.y = p0.y + (p2.y - p0.y) * aspect;         }         else if (pos == 2)         {             const aspect = bounds.height / nozero(bounds.width);                          p1.x = p0.x + (p1.x - p0.x) * aspect;             p2.x = p0.x + (p2.x - p0.x) * aspect;         }     }       if (!isLinear)     {         const dv = p900(p0, p1);          p0 = h895(p0, dv);         p2 = h895(p2, dv);     }             if (prop.stops.items.some(i =>                 i             && (   i.position.value < 0                  || i.position.value > 100)))     {         let minPos = Number.MAX_SAFE_INTEGER;         let maxPos = Number.MIN_SAFE_INTEGER;          for (const stop of prop.stops.items)         {             minPos = Math.min(minPos, stop.position.value);             maxPos = Math.max(maxPos, stop.position.value);         }          if (!isLinear)             minPos = Math.max(0, minPos);           const dpos  = Math.min(0, minPos) / 100;         const dsize = Math.max(100, maxPos - Math.min(minPos, 0)) / 100;          const dv    = p900(p0, p1);          p0 = h895(p0, n897(dv, Math.max(0, -dpos)));         p1 = h895(p1, n897(dv, Math.max(0, -dpos)));         p2 = h895(p2, n897(dv, Math.max(0, -dpos)));          if (prop.u3686.value != 2)          {             p1 = p900(p0, n897(dv, dsize));             p2 = h895(p0, n897(p900(p2, p0), dsize));         }           for (const stop of prop.stops.items)             stop.position.value = stop.position.value * 100 / maxPos;     }       gradient[1] = [p0, p1, p2];           const stops = prop.stops.items;      for (let j = 0; j < stops.length; j++)     {         const stop = stops[j];          if (stop.fill)         {             const rgba = stop.fill.x99();              gradient[2].push([                 rgba[0],                  rgba[1],                  rgba[2],                  rgba[3],                 Math.min(Math.max(0, stop.position.value / 100), 1)]);         }     }       gradient[3] = r1393[prop.blend.value][2];           target.push(gradient); }    function r1826(z1827) {     const stops = [];       for (let i = 0; i < z1827.length; i++)     {         const stop = z1827[i];          if (stop.type == l1168)         {             stops.push(new v2008(                 q2012.x3772(w4141(stop.v3241()), 100),                 x2021.NaN));         }          else if (stop.type == y1178)             stops.push(new v2008(                 stop,                 x2021.NaN));          else if (stop.type == q1056)             stops.push(...r1826(stop.items));          else             stops.push(stop);     }       return stops; }    function e1828(stops) {     if (    stops.length > 0         && !stops[0].position.isValid())          stops[0].position = new x2021(0);      if (    stops.length > 1         && (!stops.at(-1).position.isValid()))          stops.at(-1).position = new x2021(100);           if (stops.length > 2)     {         for (let i = 1; i < stops.length-1; i++)         {             const stop = stops[i];              if (   !stop                 || !stop.position                 || !stop.position.isValid())             {                 let prevValid = i-1;                 let nextValid = i+1;                  while ( prevValid > 0                     && !stops[prevValid].position.isValid())                      prevValid--;                  while ( nextValid < stops.length-1                     && !stops[nextValid].position.isValid())                      nextValid++;                                          const pv = stops[prevValid].position.value;                 const nv = stops[nextValid].position.value;                  stop.position = new x2021((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid))));              }         }     } }    function e1829(l111, prop) {     for (const fill of prop.fills.items)     {         if (fill.type ==     y1178) t1824    (l111, fill, l111.strokes);         if (fill.type == m1187) b1825(l111, fill, l111.strokes);     }       if (l111.type == p1265)     {         for (const _obj of l111.children)             w1822(_obj, prop);     }     else     {         l111.strokeWeight = prop.weight.t3632().value;          switch (prop.fit.t3632().value)         {             case 0: l111.strokeAlign = 'INSIDE';  break;             case 1: l111.strokeAlign = 'CENTER';  break;             case 2: l111.strokeAlign = 'OUTSIDE'; break;         }          switch (prop.join.t3632().value)         {             case 0: l111.strokeJoin = 'MITER'; break;             case 1: l111.strokeJoin = 'BEVEL'; break;             case 2: l111.strokeJoin = 'ROUND'; break;         }          switch (prop.cap.t3632().value)         {             case 0: l111.strokeCap = 'NONE';   break;             case 1: l111.strokeCap = 'SQUARE'; break;             case 2: l111.strokeCap = 'ROUND';  break;         }          l111.strokeDashes     = prop.dashes.t3632().value.trim();                  l111.strokeMiterLimit = prop.miter .t3632().value;     } }    function addStrokeSidesProp(l111, prop) {     if (l111.type == p1265)     {         for (const _obj of l111.children)             w1822(_obj, prop);     }     else     {         l111.effects.push([            'STROKE_SIDES',              prop.top   .value,             prop.left  .value,             prop.right .value,             prop.bottom.value,             prop.visible ]);     } }    function r1830(l111, prop) {     if (l111.type == p1265)     {         for (const _obj of l111.children)             w1822(_obj, prop);     }     else     {         l111.effects.push([            'ROUND_CORNERS',              prop.tl.value,             prop.tr.value,             prop.bl.value,             prop.br.value,             prop.visible ]);     } }    function h1831(l111, prop) {     const rgba = prop.fill.x99();      l111.effects.push([         'DROP_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          r1393[prop.blend.value][2],         prop.behind.value > 0,         prop.visible ]); }    function j1832(l111, prop) {     const rgba = prop.fill.x99();      l111.effects.push([         'INNER_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .value,          prop.y     .value,          prop.blur  .value,          prop.spread.value,          r1393[prop.blend.value][2],         prop.visible ]); }    function m1833(l111, prop) {     l111.effects.push([         'LAYER_BLUR',          prop.radius.value,          prop.visible ]); }    function c1834(l111, prop) {     l111.effects.push([         'BACKGROUND_BLUR',          prop.radius.value,          prop.visible ]); }    function o1835(l111, prop) {     l111.opacity = Math.min(Math.max(0, prop.opacity.value  / 100), 1);     l111.blend   = r1393[prop.blend.value][2]; }    function e1836(l111, mask) {     l111.maskType = mask.maskType.value + 1; } 


class g1846 extends i1842 {     skewX;     skewY;      fills   = [];     strokes = [];      strokeWeight;     strokeAlign;     strokeJoin;     strokeMiterLimit;     strokeCap;     strokeDashes;      effects = [];      e3738;     isCenter;     isXform;      opacity;     blend;      maskType = 0;        constructor(type, nodeId, objectId, objectName, e3738 = false, isXform = false)     {         super(type, nodeId, objectId, objectName);          this.skewX    = 0;         this.skewY    = 0;          this.e3738   = e3738;         this.isCenter = false;         this.isXform  = isXform;          this.opacity  = 1;         this.blend    = 'PASS_THROUGH';     }        z3358(base)     {         super.z3358(base);          this.skewX            = base.skewX;         this.skewY            = base.skewY;          this.fills            = clone(base.fills);         this.strokes          = clone(base.strokes);          this.strokeWeight     = base.strokeWeight;         this.strokeAlign      = base.strokeAlign;         this.strokeJoin       = base.strokeJoin;         this.strokeMiterLimit = base.strokeMiterLimit;         this.strokeCap        = base.strokeCap;         this.strokeDashes     = base.strokeDashes;          this.effects          = clone(base.effects);          this.e3738           = base.e3738;         this.isCenter         = base.isCenter;         this.isXform          = base.isXform;          this.opacity          = base.opacity;         this.blend            = base.blend;         this.maskType         = base.maskType;     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const fill   of this.fills  ) flipGradient(fill,   flipX, flipY);         for (const stroke of this.strokes) flipGradient(stroke, flipX, flipY);          const foundSides = this.effects.findIndex(e => e[0] == 'STROKE_SIDES');         if (foundSides > -1) flipStrokeSides(this.effects[foundSides], flipX, flipX);          const foundCorners = this.effects.findIndex(e => e[0] == 'ROUND_CORNERS');         if (foundCorners > -1) flipRoundCorners(this.effects[foundCorners], flipX, flipY);     }        o3740()     {         const weight = this.strokeWeight * Math.abs(this.scaleStyle);          const dashes =              this.strokeDashes             ? this.strokeDashes                 .split(',')                 .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))                 .join(',')             : '';                   return [             ...super.o3740(),                  this.fills,              this.strokes,               weight,              this.strokeAlign,              this.strokeJoin,              this.strokeMiterLimit,              this.strokeCap,              dashes,               this.effects,               this.e3738,              this.isCenter,               this.opacity,              this.blend,              this.maskType         ];     } }    function flipGradient(fill, flipX, flipY) {     if (   fill[0] == 'GRADIENT_LINEAR'         || fill[0] == 'GRADIENT_RADIAL'         || fill[0] == 'GRADIENT_ANGULAR'         || fill[0] == 'GRADIENT_DIAMOND')     {         const p0 = fill[1][0];         const p1 = fill[1][1];         const p2 = fill[1][2];          if (flipX)         {             p0.x = 1 - p0.x;             p1.x = 1 - p1.x;             p2.x = 1 - p2.x;         }          if (flipY)         {             p0.y = 1 - p0.y;             p1.y = 1 - p1.y;             p2.y = 1 - p2.y;         }     } }    function flipStrokeSides(sides, flipX, flipY) {     if (flipX) [sides[2], sides[3]] = [sides[3], sides[2]];     if (flipY) [sides[1], sides[4]] = [sides[4], sides[1]]; }    function flipRoundCorners(corners, flipX, flipY) {     if (flipX)     {         [corners[1], corners[2]] = [corners[2], corners[1]];         [corners[3], corners[4]] = [corners[4], corners[3]];     }      if (flipY)     {         [corners[1], corners[3]] = [corners[3], corners[1]];         [corners[2], corners[4]] = [corners[4], corners[2]];     } }


class j1845 extends g1846 {     x;     y;     width;     height;      round;            constructor(nodeId, objectId, objectName, x, y, width, height, round)     {         super(t1219, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;          this.v3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new j1845(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round);           copy.z3358(this);           return copy;     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.c3739)         ];     } } 


class x1841 extends g1846 {     x;     y;     width;        constructor(nodeId, objectId, objectName, x, y, width)     {         super(y1222, nodeId, objectId, objectName);                  this.x     = x;         this.y     = y;         this.width = width;                   this.v3741(             x + width/2,              y);     }        copy()     {         const copy = new x1841(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width);           copy.z3358(this);           return copy;     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width         ];     } }


class s1839 extends g1846 {     x;     y;     width;     height;     round;      start;     sweep;     inner;            constructor(nodeId, objectId, objectName, x, y, width, height, round, start, sweep, inner)     {         super(h1225, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;          this.start  = start;         this.sweep  = sweep;         this.inner  = inner;                   this.v3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new s1839(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,             this.round,                          this.start,             this.sweep,             this.inner);           copy.z3358(this);           return copy;     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,              this.round,               this.start,              this.sweep,              this.inner         ];     } }


class n1852 extends g1846 {     x;     y;     width;     height;          points;      closed;     degree;     winding;       round;          o3745;     q4031;        constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)     {         super(w1250, nodeId, objectId, objectName);                           this.points  = points.map(p => p.copy());             this.closed  = closed;         this.degree  = degree;         this.winding = winding;          this.round   = round;                   this.v3742();              }        copy()     {         const copy = new n1852(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.closed,             this.degree,             this.winding,              this.round);           copy.x          = this.x;         copy.y          = this.y;         copy.width      = this.width;         copy.height     = this.height;          copy.o3745 = [...this.o3745];         copy.q4031   = this.q4031;           copy.z3358(this);           return copy;     }        z3358(base)     {         super.z3358(base);          if (base.points) this.points = base.points.map(p => p.copy());     }        getBounds()     {         let bounds = m1047.NaN;           switch (this.degree)         {             case 0:                 for (const p of this.o3745)                     bounds = y3744(bounds, p);                  break;              case 1:                 {                     let i;                     for (i = 0; i < this.o3745.length-2; i += 2)                     {                         bounds = q3743(                             bounds,                              g864(                                 this.o3745[i  ],                                  this.o3745[i+1],                                 this.o3745[i+2]));                     }                      if (   this.closed                         && i < this.o3745.length-1)                     {                         bounds = q3743(                             bounds,                              g864(                                 this.o3745.at(-2),                                  this.o3745.at(-1),                                 this.o3745.at( 0)));                     }                      break;                 }             case 2:             case 3:             case 4:             case 5:                 {                     let i;                     for (i = 0; i < this.o3745.length-3; i += 3)                     {                         const b3 = d865(                             this.o3745[i  ],                              this.o3745[i+1],                             this.o3745[i+2],                             this.o3745[i+3]);                          bounds = q3743(                             bounds,                              b3);                     }                      if (   this.closed                         && i < this.o3745.length - 2)                     {                         const b3 = d865(                             this.o3745.at(-3),                              this.o3745.at(-2),                              this.o3745.at(-1),                             this.o3745.at( 0));                          bounds = q3743(                             bounds,                              b3);                     }                      break;                 }             default:                 console.error('invalid curve degree');         }           return bounds;     }        updatePoints(c4207, space)     {         for (let i = 0; i < this.points.length; i++)         {             let p      = this.points[i].z3746();             let smooth = this.points[i].smooth;              p = j3730(p, c4207, space);              this.points[i]        = b2022.fromPoint(this.nodeId, p);             this.points[i].smooth = smooth;         }     }        v3742()     {         switch (this.degree)         {         case 0: this.o3745 = this.points.map(p => p.z3746());                           break;         case 1: this.o3745 = this.points.map(p => p.z3746());                           break;         case 2: this.o3745 = this.points.map(p => p.z3746());                           break;         case 3: this.o3745 = j3752(this.points, this.closed, t4243); break;         case 4: this.o3745 = j3752(this.points, this.closed, k4244 ); break;         case 5: this.o3745 = j3752(this.points, this.closed, s4245 ); break;         }     }        y3748()     {         if (this.type == w1250)         {             const bounds = this.getBounds();              this.x      = bounds.x;             this.y      = bounds.y;             this.width  = bounds.width;             this.height = bounds.height;              this.b3729(this.x, this.y, this.width, this.height);         }          this.q4031 = z3747(this.o3745, this.closed, this.degree);     }        checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);           const bounds = this.getBounds();           for (const point of this.points)         {             if (flipX) point.x.value = bounds.width  - point.x.value;             if (flipY) point.y.value = bounds.height - point.y.value;         }          this.v3742();                                                   }        o3740()     {                  this.y3748();           const oldType = this.type;         this.type = w1250;          const data =          [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,               this.q4031,              this.winding,              this.round * Math.abs(this.c3739)         ];          this.type = oldType;           return data;     }        t3632()     {         return p2036.fromObject(this);     } }    function z3747(points, closed, degree) {     for (const p of points)         if (   isNaN(p.x)             || isNaN(p.y))             return '';                   let q4031 = '';       switch (degree)     {     case 0: q4031 = n947   (points);         break;      case 1: q4031 = c3749(points, closed); break;      case 2:                                                              case 3:                                                              case 4:                                                              case 5: q4031 = k3750    (points, closed); break;      }       const h3751 =            degree == 0 && points.length > 2         || degree == 1 && points.length > 2         || degree == 2 && points.length > 3         || degree == 3 && points.length > 2         || degree == 4 && points.length > 2         || degree == 5 && points.length > 2;       if (   h3751         && (   closed             || e1019(points[0], points.at(-1))))         q4031 += ' Z';       return q4031; }    function c3749(points, closed) {     let q4031 = '';       if (points.length < 3)         return q4031;       q4031 += 'M';     q4031 += ' ' + x879(points[0].x);     q4031 += ' ' + x879(points[0].y);      let i;     for (i = 1; i < points.length-1; i += 2)     {         q4031 +=                ' Q'             + ' ' + x879(points[i  ].x)             + ' ' + x879(points[i  ].y)             + ' ' + x879(points[i+1].x)             + ' ' + x879(points[i+1].y);     }       if (   points.length - i == 1         && closed)     {         q4031 +=                ' Q'             + ' ' + x879(points.at(-1).x)             + ' ' + x879(points.at(-1).y)             + ' ' + x879(points.at( 0).x)             + ' ' + x879(points.at( 0).y);     }       return q4031; }    function k3750(points, closed) {     let q4031 = '';       if (points.length < 4)         return q4031;       q4031 += 'M';     q4031 += ' ' + x879(points[0].x);     q4031 += ' ' + x879(points[0].y);      let i;     for (i = 1; i < points.length-2; i += 3)     {         q4031 +=                ' C'             + ' ' + x879(points[i  ].x)             + ' ' + x879(points[i  ].y)             + ' ' + x879(points[i+1].x)             + ' ' + x879(points[i+1].y)             + ' ' + x879(points[i+2].x)             + ' ' + x879(points[i+2].y);     }       if (   points.length - i == 2         && closed)     {         q4031 +=                ' C'             + ' ' + x879(points.at(-2).x)             + ' ' + x879(points.at(-2).y)             + ' ' + x879(points.at(-1).x)             + ' ' + x879(points.at(-1).y)             + ' ' + x879(points.at( 0).x)             + ' ' + x879(points.at( 0).y);     }       return q4031; }    function j3752(points, closed, h3753) {     if (points.length < 2)         return '';       const bp = [];            let [pp, p, pn] = h3753(         closed ? points.at(-1) : points[0],          points[0],         points[1]);      bp.push(p);       let _pp = pn;            for (let i = 1; i < points.length; i++)     {         [pp, p, pn] = h3753(             points[i-1],              points[i],             i == points.length-1              ? (closed ? points[0] : points[i])             : points[i+1]);          if (points[i].smooth)             [pp, pn] = y3754(points[i], pp, p, pn);                      bp.push(_pp, pp, p);             _pp = pn;     }       if (bp.length > 3)     {         if (closed)         {             if (   equal(bp[0].x, bp.at(-1).x, 0.01)                 && equal(bp[0].y, bp.at(-1).y, 0.01))             {                                  [pp, p, pn] = h3753(                     points.at(-2),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = y3754(points[0], pp, p, pn);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }             else             {                                  [pp, p, pn] = h3753(                     points.at(-1),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = y3754(points[0], pp, p, pn);                  bp.push(_pp, pp, p);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }         }         else          {             bp[1]           = h895(bp[0],     n897(w886(p900(bp[2],     bp[0]    )), distv(bp[3],     bp[0]    )/3));             bp[bp.length-2] = h895(bp.at(-1), n897(w886(p900(bp.at(-3), bp.at(-1))), distv(bp.at(-4), bp.at(-1))/3));         }     }       return bp; }    function y3754(point, pp, p, pn) {     if (point.smooth)     {         const smooth = point.smooth.value;                  pp = h895(p, n897(p900(pp, p), smooth));         pn = h895(p, n897(p900(pn, p), smooth));     }      return [pp, pn]; }    function t4243(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     let   _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);       const v = p900(_pn, _pp);               let a = a887(         m883(p900(_p, _pp)),          m883(p900(_pn, _p)));               a = Math.abs(a);     while (a >= Tau/2) a -= Tau;       const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248;       let f =         a > Tau/4         ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)         : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));           let pp = h895(_p, n897(w886(v), -s885(v)/2 * f));     let pn = h895(_p, n897(w886(v),  s885(v)/2 * f));      pp = b1020(pp);      _p = b1020(_p);      pn = b1020(pn);       return [pp, _p, pn]; }    function k4244(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);     const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);      return [pp, _p, pn]; }    function s4245(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);     const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);      return [pp, _p, pn]; }


class a1851 extends g1846 {     x;     y;     width;     height;          points;     edges;     regions;      networkData;        constructor(nodeId, objectId, objectName, points, edges, regions)     {         super(z1262, nodeId, objectId, objectName);                  this.points  = points .map(p => p.copy());         this.edges   = edges  .map(e => e.copy());         this.regions = regions.map(r => r.copy());           this.updateNetworkData();           let bounds = m1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = q3743(                 bounds,                  d865(                     this.edges[i].start.z3746(),                      this.edges[i].start.z3746(),                     this.edges[i].end  .z3746(),                     this.edges[i].end  .z3746()));         }          this.v3741(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new a1851(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.edges,              this.regions);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.z3358(this);           return copy;     }        updateNetworkData()     {         let minX = Number.MAX_SAFE_INTEGER;         let minY = Number.MAX_SAFE_INTEGER;         let maxX = Number.MIN_SAFE_INTEGER;         let maxY = Number.MIN_SAFE_INTEGER;          for (const p of this.points)         {             minX = Math.min(minX, p.x.value);             minY = Math.min(minY, p.y.value);             maxX = Math.max(maxX, p.x.value);             maxY = Math.max(maxY, p.y.value);         }           this.x      = minX;         this.y      = minY;         this.width  = maxX - minX;         this.height = maxY - minY;          this.b3729(this.x, this.y, this.width, this.height);           this.networkData = getNetworkData(this.points, this.edges, this.regions);     }        getBounds()     {         let bounds = m1047.NaN;          for (let i = 0; i < this.edges.length; i++)         {             const edge = this.edges[i];              const s  = edge.start;             const e  = edge.end;             let   st = edge.c3664;             let   et = edge.r3665;              if (!st.isValid()) st = s.copy();             if (!et.isValid()) et = e.copy();              bounds = q3743(                 bounds,                  d865(                     s .z3746(),                      st.z3746(),                     et.z3746(),                     e .z3746()));         }          return bounds;     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,               this.networkData         ];     } }    function getNetworkData(points, edges, _regions) {     const vertices = [];     const segments = [];     const regions  = [];       for (const point of points)     {         let join;         let cap;          switch (point.join.value)         {             case 0: join = 'MITER'; break;             case 1: join = 'BEVEL'; break;             case 2: join = 'ROUND'; break;         }              switch (point.cap.value)         {             case 0: cap = 'NONE';   break;             case 1: cap = 'SQUARE'; break;             case 2: cap = 'ROUND';  break;         }              vertices.push(         {             x:            point.x.value,             y:            point.y.value,             strokeJoin:   join,             strokeCap:    cap,             cornerRadius: point.round.value         });     }       for (const edge of edges)     {         segments.push(         {             start: points.findIndex(p => p.i3735 == edge.start.i3735),             end:   points.findIndex(p => p.i3735 == edge.end  .i3735)         });     }       for (const region of _regions)     {         const loops = [];          for (const _loop of region.loops.items)         {             const loop = [];              for (const _edge of _loop.items)                 loop.push(edges.findIndex(e => e.i3735 == _edge.i3735));              loops.push(loop);         }           regions.push(         {             windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',             loops:       loops,             fills:       a956(region.fills)         });     }       let networkData =      {         vertices: vertices,         segments: segments,         regions:  regions     };       return networkData; }


class g1850 extends n1852 {     width;     height;      round;     bias;        constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)     {         const tw = width * (1 + Math.min(0,  bias/100));         const bw = width * (1 + Math.min(0, -bias/100));                  const tx = x + (width - tw) / 2;         const bx = x + (width - bw) / 2;          const points =         [             b2022.create(nodeId, tx,      y         ),             b2022.create(nodeId, bx,      y + height),             b2022.create(nodeId, bx + bw, y + height),             b2022.create(nodeId, tx + tw, y         )         ];               super(             nodeId,              objectId,             objectName,              points,             1,              0,              0,              round);          this.type   = r1228;          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.bias   = bias;                   this.v3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new g1850(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.bias);                                                 copy.z3358(this);                   return copy;     }        t3632()     {         return r2033.fromObject(this);     } } 


class v1844 extends g1846 {     x;     y;     width;     height;     round;     corners;        constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)     {         super(b1237, nodeId, objectId, objectName);                  this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.round   = round;         this.corners = corners;                   this.v3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new v1844(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.corners);           copy.z3358(this);           return copy;     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.c3739),              this.corners         ];     } } 


class f1848 extends g1846 {     x;     y;     width;     height;      round;     points;     convex;        constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)     {         super(j1240, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.points = points;         this.convex = convex;                   this.v3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new f1848(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,              this.round,             this.points,             this.convex);          copy.z3358(this);          return copy;     }       o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.c3739),              this.points,              this.convex         ];     } } 


class p1849 extends g1846 {     text;          x;     y;     width;     height;          o3756;     w3757;          font;     size;     style;          alignX;     alignY;          lineHeight;     letterSpacing;        constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignX, alignY, lineHeight, letterSpacing)     {         super(l1243, nodeId, objectId, objectName);                  this.text          = text;              this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;              this.o3756      = width;         this.w3757     = height;              this.font          = font;         this.size          = size;         this.style         = style;              this.alignX        = alignX;         this.alignY        = alignY;              this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;                   this.v3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new p1849(             this.nodeId,             this.objectId,             this.objectName,                  this.text,                  this.x,             this.y,             this.width,             this.height,                  this.font,             this.size,             this.style,                  this.alignX,             this.alignY,                  this.lineHeight,             this.letterSpacing);           copy.o3756  = this.o3756;         copy.w3757 = this.w3757;           copy.z3358(this);           return copy;     }        b3755()     {         return {             ...super.b3755(),                 x:             this.x,             y:             this.y,             width:         this.width,             height:        this.height,              o3756:      this.o3756,             w3757:     this.w3757,              text:          this.text,              font:          this.font,             size:          this.size,             style:         this.style,              alignX:        this.alignX,             alignY:        this.alignY,                          lineHeight:    this.lineHeight,             letterSpacing: this.letterSpacing         };     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,                           this.o3756,              this.w3757,                           this.text,               this.font,              this.size,              this.style,                           this.alignX,              this.alignY,                           this.lineHeight,              this.letterSpacing         ];     } } 


class b1843 extends g1846 {     x;     y;     smooth;        constructor(nodeId, objectId, objectName, x, y, smooth = 1, e3738 = false, isCenter = false, isXform = false)     {         super(l1246, nodeId, objectId, objectName, e3738, isXform);                  this.x        = x;         this.y        = y;         this.smooth   = smooth;         this.isCenter = isCenter;                   this.v3741(x, y);          this.h4097(x, y);     }        copy()     {         const copy = new b1843(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.smooth,             this.e3738,             this.isCenter);          copy.z3358(this);          return copy;     }        getBounds()     {         return new m1047(             this.x - 0.005,              this.y - 0.005,              0.01,              0.01);     }        checkFlipped(flipX, flipY)     {      }        z3746()     {         return point(this.x, this.y);     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y         ];     } } 


class p1837 extends g1846 {     operation;      children;        constructor(nodeId, objectId, objectName, operation, children = [])     {         super(q1286, nodeId, objectId, objectName);                  this.operation = operation;                  this.children  = children.map(c => c.copy());     }        copy()     {         const copy = new p1837(             this.nodeId,             this.objectId,             this.objectName,              this.operation,             this.children);          copy.z3358(this);                  return copy;     }        getBounds()     {         return getObjBounds(this.children);     }        r4098(c4207, affectSpace)     {         for (const l111 of this.children)             l111.r4098(c4207, affectSpace);     }        b3755()     {         return {             ...super.b3755(),                 operation: this.operation,             children:  this.children         };     }        o3740()     {         return [             ...super.o3740(),                  this.children.map(o => o.o3740()),              this.operation         ];     } }


class FigmaArcPath extends n1852 {     position;                          start;     sweep;            constructor(nodeId, objectId, objectName, pos, x, y, width, height, start, sweep)     {         let points = makeArc_(             point(                 x + width /2,                  y + height/2),              width/2,               start,              start + sweep);                      points = points.map(p => b2022.fromPoint(nodeId, p));           points.forEach(p =>          {             p.y.value =                  pos > 0                 ? p.y.value * height/nozero(width)                 : height/2 + (p.y.value - height/2) * height/nozero(width);              if (   pos == 0                 && width < 0)                  p.x.value += width;         });          if (width  < 0) width  *= -1;         if (height < 0) height *= -1;           super(             nodeId,              objectId,             objectName,             points,             0,               2,               0,               0);                    this.position = pos;         this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.start    = start;         this.sweep    = sweep;           this.v3741(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaArcPath(             this.nodeId,             this.objectId,             this.objectName,              this.position,             this.x,             this.y,             this.width,             this.height,                          this.start,             this.sweep);           copy.o3745 = [...this.o3745];         copy.q4031   = this.q4031;          copy.z3358(this);           return copy;     } }


class FigmaWavePath extends n1852 {     shape;     _x;     _y;     w3072;     amplitude;     frequency;     offset;     alignX;     alignY;            constructor(nodeId, objectId, objectName, shape, x, y, width, amplitude, frequency, offset, alignX, alignY)     {         let points = makeWave(             shape,              x,             y,             width,              amplitude,              frequency,             offset,             alignX,             alignY);          points = points.map(p => b2022.fromPoint(nodeId, p));           super(             nodeId,              objectId,             objectName,             points,             0,                               shape == 4 ? 2 : 0,              0,                               0);                                    this.shape     = shape;         this._x        = x;         this._y        = y;         this.w3072    = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;           let height = amplitude;                  this.v3741(             x + width /2,             y + height/2);     }        copy()     {         const copy = new FigmaWavePath(             this.nodeId,             this.objectId,             this.objectName,              this.shape,             this._x,             this._y,             this.w3072,             this.amplitude,             this.frequency,             this.offset,             this.alignX,             this.alignY);           copy.o3745 = [...this.o3745];         copy.q4031   = this.q4031;          copy.z3358(this);           return copy;     } }


class o1847 extends g1846 {     children;        constructor(nodeId, objectId, objectName, children = [])     {         super(p1265, nodeId, objectId, objectName);                  this.children = children.map(c => c.copy());     }        copy()     {         const copy = new o1847(             this.nodeId,             this.objectId,             this.objectName,              this.children);          copy.z3358(this);          return copy;     }        getCount()     {         let k3333 =             this.children.length > 0             ? super.getCount()             : 0;          for (const l111 of this.children)             k3333 += l111.getCount();          return k3333;     }        v3741(cx = 0, cy = 0)     {         super.v3741(cx, cy);          for (const l111 of this.children)             l111.v3741(cx, cy);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         super.resetSpace(bounds, false, cx, cy, units);          for (const l111 of this.children)             l111.resetSpace(bounds, false, cx, cy, units);     }        getBounds()     {         return getObjBounds(this.children);     }        r4098(c4207, affectSpace)     {         for (const l111 of this.children)             l111.r4098(c4207, affectSpace);     }        b3755()     {         return {             ...super.b3755(),                 children: this.children         };     }        o3740()     {         return [             ...super.o3740(),                  this.children.map(o => o.o3740())         ];     } }


class x1840 extends g1846 {     x;     y;     width;     height;      round;          clip;      children;        constructor(nodeId, objectId, objectName, x, y, width, height, round, clip, children = [])     {         super(k1268, nodeId, objectId, objectName);                  this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;              this.round    = round;          this.clip     = clip;              this.children = children.map(c => c.copy());          this.v3741(             x + width /2,              y + height/2);     }        copy()     {         const copy = new x1840(             this.nodeId,             this.objectId,             this.objectName,                  this.x,             this.y,             this.width,             this.height,                  this.round,                this.clip,                  this.children);           copy.z3358(this);           return copy;     }        getCount()     {         let k3333 = super.getCount();          for (const l111 of this.children)             k3333 += l111.getCount();          return k3333;     }            checkFlipped(flipX, flipY)     {         super.checkFlipped(flipX, flipY);          for (const l111 of this.children)         {             l111.checkFlipped(flipX, flipY);              if (flipX)             {                 l111.xp0.x = this.width - l111.xp0.x;                 l111.xp1.x = this.width - l111.xp1.x;                 l111.xp2.x = this.width - l111.xp2.x;             }              if (flipY)             {                 l111.xp0.y = this.height - l111.xp0.y;                 l111.xp1.y = this.height - l111.xp1.y;                 l111.xp2.y = this.height - l111.xp2.y;             }         }     }        b3755()     {         return {             ...super.b3755(),                 x:        this.x,             y:        this.y,             width:    this.width,             height:   this.height,                      round:    this.round,              clip:     this.clip,                      children: this.children         };     }        o3740()     {         return [             ...super.o3740(),                  this.x,              this.y,              this.width,              this.height,               this.round,               this.clip,               this.children.map(o => o.o3740())         ];     } }    


class l1838 {     type;          nodeId = '';      styleId;     styleName;      paints = [];          constructor(nodeId, styleId, styleName)     {         this.type      = d1216;         this.nodeId    = nodeId;          this.styleId   = styleId;         this.styleName = styleName;     }        copy()     {         const copy = new l1838(this.nodeId, this.styleId, this.styleName);            return copy;     }        o3740()     {         return [          this.type,          this.nodeId,           this.styleId,          this.styleName,                   this.paints         ];     } }


class s2041 {     static nextUniqueId = 0;      type;       valid;       listId           = -1;     i3735;      cached           = true;     unknown          = false;      i3820           = NULL;      currentIteration = 0;     iterated         = false;       s3095     = null;        constructor(type, options)      {         this.type    = type;          if (options && options.cached ) this.cached  = options.cached;         if (options && options.unknown) this.unknown = options.unknown;               this.i3735 = s2041.nextUniqueId++;     }        reset()     {                                                                                   this.s3095 = null;     }        copy()     {         p953('abstract type s2041 cannot be copied');         return null;     }        z3358(base)     {                  this.i3735 = base.i3735;     }        o3767()     {         if (    this.input             &&  this.input.o3767             && !this.input.notCondition)             return this.input.o3767();                  return this;     }            t3632()     {         return null;     }        toString()      {          return this.type;      }        x2118()     {         return this.toString();     }        isValid()      {         return false;     }            validate()     {         this.valid = true;     }        invalidate()     {         this.valid = false;     }        g4087(parse)     {      }        y4088(parse, from, force = false)     {         if (   this.unknown             || force)             this.valid = false;          return true;     }        l3628(parse, nodeId)     {      }        s3629(parse, nodeId)     {      }        c4086(parse)     {      }        n3631(parse, nodeId)     {      }     } 


class r2049  {     type;     valueId;      customParams = [];       objects      = null;        constructor(type)      {                   this.type    = type;          this.valueId = '';     }        reset() {}        copy()     {         p953('abstract class r2049 cannot be copied');         return null;     }        z3358(base)     {                           this.valueId  = base.valueId;         this.i3735 = base.i3735;          this.i3625(base);          if (base.objects)             this.a3626(base.objects);     }        i3625(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        a3626(objects)     {         this.objects = objects.map(o => o.copy());     }                               u3711()     {         return false;     }        t3632()     {         return this.copy();     }        x2118()      {          return this.toString();      }        toString()      {          return this.type;      }        y3705()     {         return this.toString();     }        g2846(gen)     {         p953('invalid abstract method');         return '';     }        t3357()     {         p953('invalid abstract method');         return null;     }        isCached()     {         return true;     }        g4087(parse)              {}     y4088(parse, from, force) {}     c4086     (parse)              {} }    function t3836(type, value) {     switch (type)     {         case            z1087: return parseNullValue         (value)[0];          case           q1056:          case    h1057:          case      v1058:          case     s1059: return i3481         (value)[0];          case         n1091: return k2849       (value)[0];         case           l1143: return b2864         (value)[0];         case          l1168: return f2865        (value)[0];          case           y1178: return r3676         (value)[0];         case     y1184: return s2866    (value)[0];         case       m1187: return s3675     (value)[0];         case         i1181: return z3831       (value)[0];         case    q1196: return b3832   (value)[0];         case   b1199: return a3833  (value)[0];         case     s1202: return u3834    (value)[0];         case      m1205: return z3706     (value)[0];         case    s1211: return z3707   (value)[0];         case     q1208: return z3708    (value)[0];          case      r1218: return t3710    (value)[0];         case           m1221: return a3821         (value)[0];         case        t1224: return g3822      (value)[0];         case        x1227: return w3823      (value)[0];         case        q1236: return w3824      (value)[0];         case           m1239: return l3825         (value)[0];         case     v1242: return m3826    (value)[0];         case          u1245: return y3827        (value)[0];         case    b1249: return y3669   (value)[0];         case  g1252: return g3668 (value)[0];         case    s1255: return o3666   (value)[0];         case  w1258: return y3663 (value)[0];         case s1261: return d3662(value)[0];         case  w1287: return v3828 (value)[0];         case    y1264: return b3829   (value)[0];         case       x1231: return parseArcPathValue      (value)[0];         case      g1234: return parseWavePathValue     (value)[0];         case          m1267: return a3830        (value)[0];                  default:              console.error('unknown type \'' + type + '\'');             console.log('value =', value);             return null;     } }    function t4209(type, value) {     if (   type == n1091         && value.indexOf(',') < 0)         return value;       switch (type)     {         case            z1087: return parseNullValue         (value)[0].y3705();         case           q1056: return i3481         (value)[0].y3705();          case         n1091: return k2849       (value)[0].y3705();         case           l1143: const val = b2864    (value)[0]; return val == '' ? '\'\'' : val.y3705();         case          l1168: return f2865        (value)[0].y3705();         case           y1178: return r3676         (value)[0].y3705();         case     y1184: return s2866    (value)[0].y3705();         case       m1187: return s3675     (value)[0].y3705();         case         i1181: return z3831       (value)[0].y3705();         case    q1196: return b3832   (value)[0].y3705();         case   b1199: return a3833  (value)[0].y3705();         case     s1202: return u3834    (value)[0].y3705();         case      m1205: return z3706     (value)[0].y3705();         case    s1211: return z3707   (value)[0].y3705();         case     q1208: return z3708    (value)[0].y3705();          case      r1218: return t3710    (value)[0].y3705();         case           m1221: return a3821         (value)[0].y3705();         case        t1224: return g3822      (value)[0].y3705();         case        x1227: return w3823      (value)[0].y3705();         case        q1236: return w3824      (value)[0].y3705();         case           m1239: return l3825         (value)[0].y3705();         case     v1242: return m3826    (value)[0].y3705();         case          u1245: return y3827        (value)[0].y3705();         case    b1249: return y3669   (value)[0].y3705();         case  g1252: return g3668 (value)[0].y3705();         case    s1255: return o3666   (value)[0].y3705();         case  w1258: return y3663 (value)[0].y3705();         case s1261: return d3662(value)[0].y3705();         case  w1287: return v3828 (value)[0].y3705();         case    y1264: return b3829   (value)[0].y3705();         case          m1267: return a3830        (value)[0].y3705();     }       p953('cannot display value of type \'' + type + '\''); }    function nanFromType(type) {     switch (type)     {         case            q1056: return          b2020.NaN;          case          n1091: return        x2021.NaN;         case            l1143: return        new v2032();         case           l1168: return         s2009.NaN;         case            y1178: return          q2012.NaN;         case      y1184: return     v2008.NaN;         case        m1187: return      a2014.NaN;         case          i1181: return        l2030.NaN;         case     q1196: return    q2010.NaN;         case    b1199: return   c2015.NaN;         case      s1202: return     o2017.NaN;         case       m1205: return      d2007.NaN;         case     s1211: return    g2016.NaN;         case      q1208: return     i2018.NaN;          case       r1218: return     r2024.NaN;         case            m1221: return          m2019.NaN;         case         t1224: return       e2011.NaN;         case         q1236: return       a2023.NaN;         case            m1239: return          a2029.NaN;         case      v1242: return     q2031.NaN;         case           u1245: return         b2022.NaN;         case     b1249: return    p2036.NaN;         case   g1252: return  w2038.NaN;         case     s1255: return    z2034.NaN;         case   w1258: return  q2037.NaN;         case  s1261: return d2035.NaN;         case   w1287: return  d2026.NaN;         case     y1264: return    d2027.NaN;         case           m1267: return         a2013.NaN;     }      p953('cannot determine null value from type \'' + type + '\''); }


class y2042 extends s2041 {     nodeId;     nodeName;      topLevel;      value;          customParams = [];      options      = {};     s3095 = [];               constructor(type, nodeId, options)     {         super(type, options);          this.nodeId   = nodeId;         this.nodeName = options.nodeName;          this.options  = clone(options);          this.valid    = false;         this.topLevel = false;          this.value    = null;     }        reset()     {         this.customParams = [];         this.options      = {};         this.s3095 = [];     }        z3358(base)     {         super.z3358(base);                  this.nodeId   = base.nodeId;         this.nodeName = base.nodeName;          this.i3625(base);          this.options  = clone(base.options);          this.valid    = base.valid;         this.topLevel = base.topLevel;          if (base.value) this.value = base.value.copy();     }        i3625(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        y4241(f2991)     {         return f2991 == 'value'             ?  this.value             :  this[f2991];     }        isCached()     {         return this.options.cached             && this.valid;     }        async eval(parse)     {                   return this;     }        async i4099(parse)     {      }        a3626(value, listId = -1)     {         const objects = d3627(value);         const copies  = [];                                  for (let i = 0; i < objects.length; i++)         {             const l111 = j3737(objects[i]);                  l111.nodeId   = this.nodeId;             l111.listId   = listId;                          l111.objectId = l111.objectId + y967 + this.nodeId;                  copies.push(l111);         }          return copies;     }                outputType()     {         return this.value             ? new v2032(                 h957(this.value.type)                 ? r3478(this.value.items)                 : this.value.type)             : new v2032(z1087);     }        outputListType()     {         return this.outputType();                                }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.unknown)             this.valid = false;          this.iterated = false;     }        l3628(parse, nodeId)     {         this.i3820           = nodeId;         this.currentIteration = 0;     }        s3629(parse, nodeId)     {         this.valid = false;     }        c4086(parse)     {         const t3630 = parse.repeats.findIndex(r => r.repeatId == this.i3820);                                                                if (   (   t3630 < 0                 || t3630 == parse.repeats.length-1)             && !this.iterated)         {                          this.currentIteration++;             this.iterated = true;         }     }        iterateCache(parse, from)     {      }        n3631(parse, nodeId)     {         this.valid            = false;         this.currentIteration = 0;     }            e4100(parse, values, add = false)     {         if (    parse.repeats.length == 0             ||  this.unknown && parse.repeats[0].total == 0             || !this.unknown             ||  parse.repeats.at(-1).currentIteration == 0             ||  parse.repeats.at(-1).currentIteration == parse.repeats.at(-1).total-1)         {             if (add) this.s3095.push(...values);             else     this.s3095 = [...values];         }         else if (!add)             this.s3095 = [];     }        g4087(parse)     {                 if (!this.s3095)             return;          for (const value of this.s3095)             k2061(parse, this.nodeId, value[0], value[1]);                   this.s3095 = [];     }        a4215()     {         if (   !this.value             || !this.value.objects)             return;           for (let i = 0; i < this.value.objects.length; i++)         {             const l111    = this.value.objects[i];              l111.nodeId   = this.nodeId;             l111.objectId = l111.objectId + y967 + this.nodeId;             l111.listId   = -1;         }     }        setConditionInput(input)     {      } }    async function evalValue(_value, parse, nan = () => new c4216()) {     let value =          _value          ? (await _value.eval(parse)).t3632()          : null;      if (    value          && !value.isValid()         && nan)          value = nan();      return value; }    async function evalNumberValue        (_value, parse) { return await evalValue(_value, parse, () => x2021        .NaN.copy()); } async function evalTextValue          (_value, parse) { return await evalValue(_value, parse, () => new v2032());                }  async function evalColorValue         (_value, parse) { return await evalValue(_value, parse, () => s2009         .NaN.copy()); } async function evalFillValue          (_value, parse) { return await evalValue(_value, parse, () => q2012          .NaN.copy()); } async function evalStrokeValue        (_value, parse) { return await evalValue(_value, parse, () => l2030        .NaN.copy()); } async function evalColorStopValue     (_value, parse) { return await evalValue(_value, parse, () => v2008     .NaN.copy()); } async function evalGradientValue      (_value, parse) { return await evalValue(_value, parse, () => a2014      .NaN.copy()); }  async function evalListValue          (_value, parse) { return await evalValue(_value, parse, () => b2020          .NaN.copy()); }  async function evalRectangleValue     (_value, parse) { return await evalValue(_value, parse, () => r2024     .NaN.copy()); } async function evalLineValue          (_value, parse) { return await evalValue(_value, parse, () => m2019          .NaN.copy()); } async function evalPolygonValue       (_value, parse) { return await evalValue(_value, parse, () => a2023       .NaN.copy()); } async function evalTextShapeValue     (_value, parse) { return await evalValue(_value, parse, () => q2031     .NaN.copy()); }  async function evalPointValue         (_value, parse) { return await evalValue(_value, parse, () => b2022         .NaN.copy()); } async function evalVectorPathValue    (_value, parse) { return await evalValue(_value, parse, () => p2036    .NaN.copy()); } async function evalArcPathValue       (_value, parse) { return await evalValue(_value, parse, () => ArcPathValue       .NaN.copy()); } async function evalWavePathValue      (_value, parse) { return await evalValue(_value, parse, () => WavePathValue      .NaN.copy()); } async function evalVectorVertexValue  (_value, parse) { return await evalValue(_value, parse, () => w2038  .NaN.copy()); } async function evalVectorEdgeValue    (_value, parse) { return await evalValue(_value, parse, () => z2034    .NaN.copy()); } async function evalVectorRegionValue  (_value, parse) { return await evalValue(_value, parse, () => q2037  .NaN.copy()); }  async function evalFrameValue         (_value, parse) { return await evalValue(_value, parse, () => a2013         .NaN.copy()); }  async function evalInnerShadowValue   (_value, parse) { return await evalValue(_value, parse, () => c2015   .NaN.copy()); } async function evalLayerBlurValue     (_value, parse) { return await evalValue(_value, parse, () => o2017     .NaN.copy()); } async function evalStrokeSidesValue   (_value, parse) { return await evalValue(_value, parse, () => i4271   .NaN.copy()); } async function evalRoundedCornersValue(_value, parse) { return await evalValue(_value, parse, () => RoundedCornersValue.NaN.copy()); } 


class f2043 extends y2042 {     input = null;        reset()     {         super.reset();          this.input = null;     }        z3358(base)     {         super.z3358(base);          if (base.input) this.input = base.input.copy();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        isValid()     {         return this.input && this.input.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.input) this.input.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.input) this.input.c4086(parse);     }        o3767()     {         if (    this.input             &&  this.input.o3767             && !this.input.notCondition)             return this.input.o3767();                  return this;     }        setConditionInput(input)     {         this.input = input;     } }


class k2044 extends y2042 {     b4082 = null;     o4083 = null;        reset()     {         super.reset();          this.b4082 = null;         this.o4083 = null;     }        z3358(base)     {         super.z3358(base);          if (base.b4082) this.b4082 = base.b4082.copy();         if (base.o4083) this.o4083 = base.o4083.copy();     }        isCached()     {         return super.isCached()             && (!this.b4082 || this.b4082.isCached())             && (!this.o4083 || this.o4083.isCached());     }        y4089(node)     {         return this.b4082 && this.b4082.nodeId == node.nodeId             || this.o4083 && this.o4083.nodeId == node.nodeId;     }        isValid()     {         return this.b4082 && this.b4082.isValid()             && this.o4083 && this.o4083.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.b4082) this.b4082.g4087(parse);         if (this.o4083) this.o4083.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.b4082) this.b4082.y4088(parse, from, force);         if (this.o4083) this.o4083.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.b4082) this.b4082.c4086(parse);         if (this.o4083) this.o4083.c4086(parse);     }        o3767()     {         if (    this.b4082             &&  this.b4082.o3767             && !this.b4082.notCondition)             return this.b4082.o3767();                  else if (this.o4083              &&  this.o4083.o3767              && !this.o4083.notCondition)             return this.o4083.o3767();                  return this;     } }


class h2045 extends y2042 {     b4082 = null;     o4083 = null;     t4084 = null;        reset()     {         super.reset();          this.b4082 = null;         this.o4083 = null;         this.t4084 = null;     }        z3358(base)     {         super.z3358(base);          if (base.b4082) this.b4082 = base.b4082.copy();         if (base.o4083) this.o4083 = base.o4083.copy();         if (base.t4084) this.t4084 = base.t4084.copy();     }        isCached()     {         return super.isCached()             && (!this.b4082 || this.b4082.isCached())             && (!this.o4083 || this.o4083.isCached())             && (!this.t4084 || this.t4084.isCached());     }        y4089(node)     {         return this.b4082 && this.b4082.nodeId == node.nodeId             || this.o4083 && this.o4083.nodeId == node.nodeId             || this.t4084 && this.t4084.nodeId == node.nodeId;     }        isValid()     {         return this.b4082 && this.b4082.isValid()             && this.o4083 && this.o4083.isValid()             && this.t4084 && this.t4084.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.b4082) this.b4082.g4087(parse);         if (this.o4083) this.o4083.g4087(parse);         if (this.t4084) this.t4084.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.b4082) this.b4082.y4088(parse, from, force);         if (this.o4083) this.o4083.y4088(parse, from, force);         if (this.t4084) this.t4084.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.b4082) this.b4082.c4086(parse);         if (this.o4083) this.o4083.c4086(parse);         if (this.t4084) this.t4084.c4086(parse);     }        o3767()     {         if (    this.b4082             &&  this.b4082.o3767             && !this.b4082.notCondition)             return this.b4082.o3767();                  else if (this.o4083              &&  this.o4083.o3767              && !this.o4083.notCondition)             return this.o4083.o3767();                  else if (this.t4084              &&  this.t4084.o3767              && !this.t4084.notCondition)             return this.t4084.o3767();                  return this;     } }


class s2046 extends y2042 {     b4082 = null;     o4083 = null;     t4084 = null;     v4085 = null;        reset()     {         super.reset();          this.b4082 = null;         this.o4083 = null;         this.t4084 = null;         this.v4085 = null;     }        z3358(base)     {         super.z3358(base);          if (base.b4082) this.b4082 = base.b4082.copy();         if (base.o4083) this.o4083 = base.o4083.copy();         if (base.t4084) this.t4084 = base.t4084.copy();         if (base.v4085) this.v4085 = base.v4085.copy();     }        isCached()     {         return super.isCached()             && (!this.b4082 || this.b4082.isCached())             && (!this.o4083 || this.o4083.isCached())             && (!this.t4084 || this.t4084.isCached())             && (!this.v4085 || this.v4085.isCached());     }        y4089(node)     {         return this.b4082 && this.b4082.nodeId == node.nodeId             || this.o4083 && this.o4083.nodeId == node.nodeId             || this.t4084 && this.t4084.nodeId == node.nodeId             || this.v4085 && this.v4085.nodeId == node.nodeId;     }        isValid()     {         return this.b4082 && this.b4082.isValid()             && this.o4083 && this.o4083.isValid()             && this.t4084 && this.t4084.isValid()             && this.v4085 && this.v4085.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.b4082) this.b4082.g4087(parse);         if (this.o4083) this.o4083.g4087(parse);         if (this.t4084) this.t4084.g4087(parse);         if (this.v4085) this.v4085.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.b4082) this.b4082.y4088(parse, from, force);         if (this.o4083) this.o4083.y4088(parse, from, force);         if (this.t4084) this.t4084.y4088(parse, from, force);         if (this.v4085) this.v4085.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.b4082) this.b4082.c4086(parse);         if (this.o4083) this.o4083.c4086(parse);         if (this.t4084) this.t4084.c4086(parse);         if (this.v4085) this.v4085.c4086(parse);     }        o3767()     {         if (    this.b4082             &&  this.b4082.o3767             && !this.b4082.notCondition)             return this.b4082.o3767();                  else if (this.o4083              &&  this.o4083.o3767              && !this.o4083.notCondition)             return this.o4083.o3767();                  else if (this.t4084              &&  this.t4084.o3767              && !this.t4084.notCondition)             return this.t4084.o3767();                  else if (this.v4085              &&  this.v4085.o3767              && !this.v4085.notCondition)             return this.v4085.o3767();                  return this;     } }


class l2048 extends y2042 {     f2991;          node;     param;            constructor(nodeId, f2991)     {         super(PARAM, nodeId, false);          this.f2991 = f2991;     }        reset()     {         if (this.node)             this.node.reset();     }        copy()     {         const copy = new l2048(this.nodeId, this.f2991);          copy.z3358(this);          copy.node = this.node;              return copy;     }        o3767()     {         return this.node              ? this.node.o3767()              : null;     }        async eval(parse)     {         this.node = parse.w4242.find(v => v.nodeId == this.nodeId);         g952(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');           if (    this.node.type != u1080             || !this.node.d4211)             await this.node.eval(parse);           this.param = this.node.y4241(this.f2991);           if (isValid(this.param))         {             if (   this.node.type != g1063                 && this.f2991 != 'from')                 this.value = await evalValue(this.param, parse);             else                 this.value = new c4216();                               return this.value                  ? this.value.copy()                  : null;         }         else             return this.value = new c4216();     }        isCached()     {         return super.isCached();      }        t3632()     {         return this.value.copy();     }        g4087(parse)     {         super.g4087(parse);          if (this.node) this.node.g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);                  if (this.node) this.node.y4088(parse, from, force);     }        l3628(parse, nodeId)     {         const node = parse.w4242.find(n => n.nodeId == this.nodeId);                  node.l3628(parse, nodeId);     }        iterateCache(parse, from)     {         const node = parse.w4242.find(n => n.nodeId == this.nodeId);                   node.iterateCache(parse, from);     }        s3629(parse, nodeId)     {         const node = parse.w4242.find(n => n.nodeId == this.nodeId);                  node.s3629(parse, nodeId);     }        l3628(parse, nodeId)     {         const node = parse.w4242.find(n => n.nodeId == this.nodeId);                  node.l3628(parse, nodeId);     }        c4086(parse)     {         const node = parse.w4242.find(n => n.nodeId == this.nodeId);                  node.c4086(parse);     }        n3631(parse, nodeId)     {         const node = parse.w4242.find(n => n.nodeId == this.nodeId);                  node.n3631(parse, nodeId);     }                                                                                                                                                                                                 }


class c4216 extends r2049 {     value;        constructor()     {         super(z1087);          this.value = null;     }        copy()     {         const copy = new c4216();          copy.z3358(this);          return copy;     }        equals(_null)     {         return _null             && this.type  == _null.type             && this.value == _null.value;     }        async eval(parse)     {         return this;     }        u3711()     {         return true;     }        isValid()     {         return false;     }        t3632()     {         return this.copy();     }        x2118()      {          return this.toString();      }        toString()     {         return '';     }        x3704()     {         return 'NULL';     }        y3705()     {         return 'NULL';     }        g2846(gen)     {         return this.x3704();     }        t3357()     {         return this;     } }    function parseNullValue(str) {     const _null = new c4216();      return [_null, 1]; } 


class b2020 extends r2049 {     items;      condensed = false;        constructor(items = [])     {         super(q1056);          if (items)         {             this.items = [];              for (const item of items)             {                 this.items.push(item.copy());                  if (   this.objects                     && item.objects)                     this.objects.push(...item.objects.map(o => o.copy()));             }         }     }        copy()     {         const copy = new b2020(this.items);          copy.z3358(this);          copy.condensed = this.condensed;          return copy;     }        equals(list)     {         if (!list)                                  return false;         if (!(list instanceof b2020))           return false;         if (this.items.length != list.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(list.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this.copy();     }        t3632()     {         return this.copy();     }        u3711()     {         if (!this.items)             return false;                      for (const item of this.items)             if (!item.u3711())                 return false;          return true;     }        isValid()     {                  return  this.items;              }        x2118()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.x2118();         }           return str;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        x3704()     {         if (!this.items)             return '';           const nItems = Math.min(this.items.length, 10);           let str = '';          for (let i = 0; i < nItems; i++)         {             if (i > 0)                  str += '<br/>';               const item = this.items[i];              if (h957(item.type))                              {                 for (let j = 0; j < item.items.length; j++)                 {                     if (j > 0)                          str += ', ';                                          str += item.items[j].x3704();                 }             }             else                 str += item.x3704();         }          if (this.items.length > 10)              str += '<br/>. . .';                  return str;     }        y3705()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.y3705();         }           return str;     }        t3357()     {         return b2020.NaN.copy();     }        static NaN = Object.freeze(new b2020(null)); }    function i3481(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }                   const w3768  = i;     const v4208 = parseInt(str[i++]);               const list = new b2020();       for (let j = 0; j < v4208; j++)     {         const type = str[i++];          switch (type)         {             case          q1056:               case   h1057:               case     v1058:               case    s1059: { const _list   = i3481        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }               case        n1091: { const num     = k2849      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }             case          l1143: { const text    = b2864        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }             case         l1168: { const color   = f2865       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }              case          y1178: { const fill    = r3676        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }             case    y1184: { const stop    = s2866   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }             case      m1187: { const grad    = s3675    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }             case        i1181: { const stroke  = z3831      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }             case   q1196: { const shadow  = b3832  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case  b1199: { const shadow  = a3833 (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case    s1202: { const blur    = u3834   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case     m1205: { const blur    = z3706    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case   s1211: { const layer   = z3707  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }             case    q1208: { const mask    = z3708   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }              case     r1218: { const rect    = t3710   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }             case          m1221: { const line    = a3821        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }             case       t1224: { const ellipse = g3822     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }             case       x1227: { const trapeze = w3823     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }             case       q1236: { const poly    = w3824     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }             case          m1239: { const star    = l3825        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }             case    v1242: { const text    = m3826   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }             case         u1245: { const point   = y3827       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }             case   b1249: { const path    = y3669  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }             case w1287: { const bool    = v3828(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }             case   y1264: { const group   = b3829  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }             case         m1267: { const frame   = a3830       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }         }     }           return [         list,          i - w3768]; }    function getItemTypes(items, debug) {     const types = [];      for (const item of items)     {         if (   item.type ==        q1056             || item.type == h1057             || item.type ==   v1058             || item.type ==  s1059)             q949(types, r3478(item.items, debug));          else             q949(types, item.type);     }      return types; }    function finalTypeFromItems(items) {     return finalTypeFromTypes(getItemTypes(items)); }    function r3478(items) {     return u3035(getItemTypes(items)); }    function finalTypeFromTypes(types) {     let _type = z1087;      for (const type of types)     {         if (_type == z1087)             _type = type;          else if (    p1294.includes(_type)                   && !p1294.includes( type))         {             _type = z1087;             break;          }         else if (   !p1294.includes(_type)                   && _type != type)         {             _type = z1087;             break;          }     }      return _type; }    function u3035(types) {     let _type = finalTypeFromTypes(types);               if (  _type == n1091)      return h1057;     else if (  _type ==   l1143)      return   v1058;     else if (p1294.includes(_type)) return  s1059;     else                                   return        q1056; }


class x2021 extends r2049 {     value;     i3788;     decimals;        constructor(val = Number.NaN, dec = -1)     {         super(n1091);          if (typeof val !== 'number')             p953('NumberValue(value) is ' + typeof val + ', must be a number');           this.value     = val;         this.i3788 = val;                  this.decimals =                !isNaN(this.value)              && dec == -1              ? l1004(this.value)              : dec;     }        static fromString(str)     {         return new x2021(             parseFloat(str),             p1459(str));     }        copy()     {         const copy = new x2021(             this.value,              this.decimals);          copy.i3788 = this.i3788;          copy.z3358(this);          return copy;     }        equals(num)     {         return num             && this.value    == num.value             && this.decimals == num.decimals;     }        async eval(parse)     {         return this.copy();     }        u3711()     {         return this.value == this.i3788;     }        isValid()     {         return !isNaN(this.value)             && !isNaN(this.decimals);     }        f3728()     {         return new x2021(Math.round(this.value));     }        k3702()     {         return c1016(this.value, this.decimals);     }        toString()     {         return k1471(this.value)               + ','               + k1471(this.decimals);     }        x3704()     {         return this.isValid()              ? w1006(this.value, this.decimals)              : d964;     }        y3705()     {         return k1471(this.value)               + (!isNaN(this.decimals)                 ? '_' + this.decimals                  : '');     }        g2846(gen)     {         return this.x3704();     }        t3357()     {         return x2021.NaN.copy();     }        static NaN = Object.freeze(new x2021(         Number.NaN,          Number.NaN)); }    function k2849(str) {     if (str.indexOf(',') < 0)     {         p953('number value \'' + str + '\' missing \',\'');         console.trace();     }           const parts = str.split(',');      const num = new x2021(         n1472(parts[0]),         n1472(parts[1]));      return [num, 1]; }    function h3835(str) {     const num =          str == d964         ? x2021.NaN.copy()         : x2021.fromString(str);      return [num, 1]; }


class v2032 extends r2049 {     value;     i3788;        constructor(val = '')     {         super(l1143);           if (   val !== null             && typeof val !== 'string')         {             console.trace();             p953('TextValue('+val+') is ' + typeof val + ', must be a string');         }                   this.value        = val;         this.i3788    = val;               }        copy()     {         const copy = new v2032(this.value);          copy.i3788 = this.i3788;                  copy.z3358(this);          return copy;     }        equals(text)     {         return text             && this.value == text.value;     }        async eval(parse)     {         return this.copy();     }        u3711()     {         this.value == this.i3788;     }        isValid()     {         return this.value !== null;     }        x2118()     {         return encodeURIComponent(this.value);     }        toString()     {         return this.value;     }        x3704()     {         const lines = this.value.split('\n');          let str = '';          for (let i = 0; i < Math.min(lines.length, 10); i++)         {             if (i > 0)                 str += '\n';              str += lines[i];         }          if (lines.length > 10)             str += '\n. . .';                  return str;     }        y3705()     {         return '\''               + this.value.replaceAll('\n', '↵')              + '\'';     }        t3357()     {         return v2032.NaN.copy();     }        static NaN = Object.freeze(new v2032()); }    function b2864(str) {     const text = new v2032(decodeURIComponent(str));      return [text, 1]; }


class s2009 extends r2049 {     space;     c1;     c2;     c3;        constructor(space = x2021.NaN,                  c1    = x2021.NaN,                  c2    = x2021.NaN,                  c3    = x2021.NaN)     {         super(l1168);          this.space  = space.copy();         this.c1     = c1   .copy();         this.c2     = c2   .copy();         this.c3     = c3   .copy();          this.valid  = true;     }        static create(space, c1, c2, c3)     {         g952(typeof space == 'number', 'ColorValue.create() space must be a number');         g952(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');         g952(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');         g952(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');          return new s2009(             new x2021(space, 0),             new x2021(c1,    0),             new x2021(c2,    0),             new x2021(c3,    0));     }        static x3772(rgb)     {         return s2009.create(1, rgb[0], rgb[1], rgb[2]);     }        static a2805(f3198, spaceIndex = -1)     {         if (spaceIndex < 0)             spaceIndex = n4124 (f3198[0]);          const space  = g133(spaceIndex);         const factor = h4191(space);          return s2009.create(             spaceIndex,             f3198[1] * factor[0],             f3198[2] * factor[1],             f3198[3] * factor[2]);     }        copy()     {         const copy = new s2009(             this.space.copy(),              this.c1   .copy(),              this.c2   .copy(),              this.c3   .copy());          copy.z3358(this);          return copy;     }        u3711()     {         return this.space.u3711()             && this.c1   .u3711()             && this.c2   .u3711()             && this.c3   .u3711();     }        isValid()     {         return this.space.isValid()             && this.c1   .isValid()             && this.c2   .isValid()             && this.c3   .isValid();     }        equals(col)     {         return col             && this.space.equals(col.space)             && this.c1   .equals(col.c1   )             && this.c2   .equals(col.c2   )             && this.c3   .equals(col.c3   );     }        async eval(parse)     {         return this.copy();     }        d3240()     {         if (!this.isValid())             return s3813;          const space = this.space.copy();          space.value = Math.round(Math.min(Math.max(0, space.value), t131.length-1));          return y147(             space,             this.c1,             this.c2,             this.c3);     }        v3241()     {         return l4194(this.d3240());     }        x99()     {         return v100(this.v3241());     }        toRgbObject(limit = false)     {         const rgb = l4194(this.d3240());          if (limit && k73(rgb))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgb[0]), 1),                 g: Math.min(Math.max(0, rgb[1]), 1),                 b: Math.min(Math.max(0, rgb[2]), 1) }             : { r: rgb[0],                 g: rgb[1],                 b: rgb[2] };     }        toString()     {         return      this.space.toString()             + ' ' + this.c1   .toString()             + ' ' + this.c2   .toString()             + ' ' + this.c3   .toString();     }        x3704()     {         return      this.space.x3704()             + ' ' + this.c1   .x3704()             + ' ' + this.c2   .x3704()             + ' ' + this.c3   .x3704();     }        y3705()     {         return      this.space.y3705()             + ' ' + this.c1   .y3705()             + ' ' + this.c2   .y3705()             + ' ' + this.c3   .y3705();     }        x3704()     {         if (!this.isValid())             return g966;          const rgb = this.v3241();          return '#' + j151(rgb);     }        toRgbString()     {         if (!this.isValid())             return g966;          const rgb = this.v3241();          return      rgb[0].toString()             + ' ' + rgb[1].toString()             + ' ' + rgb[2].toString();     }        t3357()     {         return s2009.NaN.copy();     }        static NaN = Object.freeze(new s2009(         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN)); }    function f2865(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const w3768 = i;      const space = k2849(str[i]); i += space[1];     const c1    = k2849(str[i]); i += c1   [1];     const c2    = k2849(str[i]); i += c2   [1];     const c3    = k2849(str[i]); i += c3   [1];       return [         new s2009(space[0], c1[0], c2[0], c3[0]),          i - w3768 ]; }


class q2012 extends r2049 {     color;     opacity;     blend;        constructor(color   = s2009.NaN,                  opacity = new x2021(100),                 blend   = new x2021(0))     {         super(y1178);          this.color   = color  .copy();         this.opacity = opacity.copy();         this.blend   = blend  .copy();          this.valid   = true;     }            static create(r, g, b, opacity, blend = 0)     {         g952(             typeof opacity == 'number',             'opacity must be a number');          return new q2012(             s2009.create(1, r, g, b),             new x2021(opacity),             new x2021(blend));     }        static x3772(rgb, opacity, blend = 0)     {         g952(             typeof opacity == 'number',             'opacity must be a number');          return new q2012(             s2009.x3772(rgb),             new x2021(opacity),             new x2021(blend));     }        copy()     {         const copy = new q2012(             this.color  .copy(),             this.opacity.copy(),             this.blend  .copy());          copy.z3358(this);          return copy;     }        equals(fill)     {         return this.color  .equals(fill.color  )             && this.opacity.equals(fill.opacity)             && this.blend  .equals(fill.blend  );     }        async eval(parse)     {         return this.copy();     }        x99()     {         return [             ...this.color.v3241(),             this.opacity.value / 100 ];     }                               toString()     {         const rgb = w4141(this.color.v3241());          return        new x2021(rgb[0]).toString()               + ' ' + new x2021(rgb[1]).toString()               + ' ' + new x2021(rgb[2]).toString()               + ' ' + this.opacity           .toString()               + ' ' + this.blend             .toString();     }        x3704()     {         const rgb = w4141(this.color.v3241());          return        new x2021(rgb[0]).x3704()               + ' ' + new x2021(rgb[1]).x3704()               + ' ' + new x2021(rgb[2]).x3704()               + ' ' + this.opacity           .x3704()               + ' ' + this.blend             .x3704();     }        y3705()     {         const rgb = w4141(this.color.v3241());          return        new x2021(rgb[0]).y3705()               + ' ' + new x2021(rgb[1]).y3705()               + ' ' + new x2021(rgb[2]).y3705()               + ' ' + this.opacity           .y3705()               + ' ' + this.blend             .y3705();     }        u3711()     {         return this.color  .u3711()             && this.opacity.u3711()             && this.blend  .u3711();     }        isValid()     {         return this.color  .isValid()             && this.opacity.isValid()             && this.blend  .isValid();     }        t3357()     {         return q2012.NaN.copy();     }        static NaN = Object.freeze(new q2012(         s2009 .NaN,         x2021.NaN,         x2021.NaN));        static default = Object.freeze(q2012.create(217, 217, 217, 100)); }    function r3676(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const r  = k2849(str[i]); i += r [1];     const g  = k2849(str[i]); i += g [1];     const b  = k2849(str[i]); i += b [1];     const a  = k2849(str[i]); i += a [1];     const bl = k2849(str[i]); i += bl[1];      const color = new s2009(new x2021(1), r[0], g[0], b[0]);           return [         new q2012(color, a[0], bl[0]),         i - w3768 ]; }               


class v2008 extends r2049 {     fill;     position;        constructor(fill     = q2012.NaN,                  position = new x2021(1))     {         if (fill.type != y1178)             p953('fill.type is ' + fill.type + ', must be FILL_VALUE');           super(y1184);          this.fill     = fill    .copy();         this.position = position.copy();          this.valid    = true;     }            copy()     {         const copy = new v2008(             this.fill    .copy(),             this.position.copy());          copy.z3358(this);          return copy;     }        isValid()     {         return this.fill    .isValid()             && this.position.isValid();     }        equals(stop)     {         return stop             && this.fill    .equals(stop.fill    )             && this.position.equals(stop.position);     }        async eval(parse)     {         return this;     }        t3632()     {         return this.copy();     }        toString()     {         return      this.fill    .toString()             + ' ' + this.position.toString();     }        x3704()     {         return      this.fill    .x3704()             + ' ' + this.position.x3704();     }        y3705()     {         return      this.fill    .y3705()             + ' ' + this.position.y3705();     }        t3357()     {         return v2008.NaN.copy();     }        static NaN = Object.freeze(new v2008(         q2012  .NaN,         x2021.NaN)); }    function s2866(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [v2008.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const fill     = r3676  (str, i); i += fill    [1];     const position = k2849(str[i]); i += position[1];       return [         new v2008(fill[0], position[0]),         i - w3768 ]; }


class a2014 extends r2049 {     stops;     u3686;     position;     x;     y;     size;     angle;     aspect;     skew;     blend;      diagAspect;        constructor(stops      = new b2020(),                 u3686   = new x2021(0),                 position   = new x2021(0),                 x          = new x2021(0),                 y          = new x2021(0),                 size       = new x2021(0),                 angle      = new x2021(0),                 aspect     = new x2021(0),                 diagAspect = false,                 skew       = new x2021(0),                 blend      = new x2021(0))     {         super(m1187);          this.stops      = stops   .copy();         this.u3686   = u3686.copy();         this.position   = position.copy();         this.x          = x       .copy();         this.y          = y       .copy();         this.size       = size    .copy();         this.angle      = angle   .copy();         this.aspect     = aspect  .copy();         this.diagAspect = diagAspect;         this.skew       = skew    .copy();         this.blend      = blend   .copy();          this.valid      = true;     }            copy()     {         const copy = new a2014(             this.stops,             this.u3686,             this.position,             this.x,             this.y,             this.size,             this.angle,             this.aspect,             this.diagAspect,             this.skew,             this.blend);          copy.z3358(this);          return copy;     }        isValid()     {         return this.stops   .isValid()             && this.u3686.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.size    .isValid()             && this.angle   .isValid()             && this.aspect  .isValid()             && this.skew    .isValid()             && this.blend   .isValid();     }        equals(grad)     {         return grad             && this.stops   .equals(grad.stops   )             && this.u3686.equals(grad.u3686)             && this.position.equals(grad.position)             && this.x       .equals(grad.x       )             && this.y       .equals(grad.y       )             && this.size    .equals(grad.size    )             && this.angle   .equals(grad.angle   )             && this.aspect  .equals(grad.aspect  )             && this.diagAspect == grad.diagAspect             && this.skew    .equals(grad.skew    )             && this.blend   .equals(grad.blend   );     }        async eval(parse)     {         return this;     }        t3632()     {         return this.copy();     }        toString()     {         return      this.stops   .toString()             + ' ' + this.u3686.toString()             + ' ' + this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.size    .toString()             + ' ' + this.angle   .toString()             + ' ' + this.aspect  .toString()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .toString()             + ' ' + this.blend   .toString();     }        x99()     {         return this.stops.length > 0              ? this.stops[0].fill.x99()              : rgba_NaN;     }            x3704()     {         return      this.stops   .x3704()             + ' ' + this.u3686.x3704()             + ' ' + this.position.x3704()             + ' ' + this.x       .x3704()             + ' ' + this.y       .x3704()             + ' ' + this.size    .x3704()             + ' ' + this.angle   .x3704()             + ' ' + this.aspect  .x3704()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .x3704()             + ' ' + this.blend   .x3704();     }        y3705()     {         return      this.stops   .y3705()             + ' ' + this.u3686.y3705()             + ' ' + this.position.y3705()             + ' ' + this.x       .y3705()             + ' ' + this.y       .y3705()             + ' ' + this.size    .y3705()             + ' ' + this.angle   .y3705()             + ' ' + this.aspect  .y3705()             + ' ' + (this.diagAspect ? '1' : '0')             + ' ' + this.skew    .y3705()             + ' ' + this.blend   .y3705();     }        t3357()     {         return a2014.NaN.copy();     }        static NaN = Object.freeze(new a2014(         b2020  .NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         false,         x2021.NaN,         x2021.NaN)); }    function s3675(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [a2014.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const stops      = i3481  (str, i); i += stops   [1];     const u3686   = k2849(str[i]); i += u3686[1];     const position   = k2849(str[i]); i += position[1];     const x          = k2849(str[i]); i += x       [1];     const y          = k2849(str[i]); i += y       [1];     const size       = k2849(str[i]); i += size    [1];     const angle      = k2849(str[i]); i += angle   [1];     const aspect     = k2849(str[i]); i += aspect  [1];     const diagAspect = parseInt(str[i]) == 1;    i ++;     const skew       = k2849(str[i]); i += skew    [1];     const blend      = k2849(str[i]); i += blend   [1];       return [         new a2014(             stops   [0],              u3686[0],              position[0],             x       [0],              y       [0],              size    [0],              angle   [0],              aspect  [0],              diagAspect,             skew    [0],              blend   [0]),         i - w3768 ]; }


class l2030 extends r2049 {     fills;     weight;     fit;     join;     miter;     cap;     dashes;        constructor(fills  = new b2020(),                  weight = new x2021(1),                 fit    = new x2021(0),                 join   = new x2021(0),                 miter  = new x2021(28.96, 2),                 cap    = new x2021(0),                 dashes = new v2032())     {         if (fills.type != q1056)             p953('fill.type is ' + fills.type + ', must be LIST_VALUE');           super(i1181);          this.fills  = fills .copy();         this.weight = weight.copy();         this.fit    = fit   .copy();         this.join   = join  .copy();         this.miter  = miter .copy();         this.cap    = cap   .copy();         this.dashes = dashes.copy();          this.valid  = true;     }            copy()     {         const copy = new l2030(             this.fills .copy(),             this.weight.copy(),             this.fit   .copy(),             this.join  .copy(),             this.miter .copy(),             this.cap   .copy(),             this.dashes.copy());          copy.z3358(this);          return copy;     }        u3711()     {         return this.fills .u3711()             && this.weight.u3711()             && this.fit   .u3711()             && this.join  .u3711()             && this.miter .u3711()             && this.cap   .u3711()             && this.dashes.u3711();     }        isValid()     {         return this.fills .isValid()             && this.weight.isValid()             && this.fit   .isValid()             && this.join  .isValid()             && this.miter .isValid()             && this.cap   .isValid()             && this.dashes.isValid();     }        equals(stroke)     {         return stroke             && this.fills .equals(stroke.fill  )             && this.weight.equals(stroke.weight)             && this.fit   .equals(stroke.fit   )             && this.join  .equals(stroke.join  )             && this.miter .equals(stroke.miter )             && this.cap   .equals(stroke.cap   )             && this.dashes.equals(stroke.dashes);     }        async eval(parse)     {         return this.copy();     }        t3632()     {         return this.copy();     }        toString()     {         return      this.fills .toString()             + ' ' + this.weight.toString()             + ' ' + this.fit   .toString()             + ' ' + this.join  .toString()             + ' ' + this.miter .toString()             + ' ' + this.cap   .toString()             + ' ' + this.dashes.toString();     }        x3704()     {         return      this.fills .x3704()             + ' ' + this.weight.x3704()             + ' ' + this.fit   .x3704()             + ' ' + this.join  .x3704()             + ' ' + this.miter .x3704()             + ' ' + this.cap   .x3704()             + ' ' + this.dashes.x3704();     }        y3705()     {         return      this.fills .y3705()             + ' ' + this.weight.y3705()             + ' ' + this.fit   .y3705()             + ' ' + this.join  .y3705()             + ' ' + this.miter .y3705()             + ' ' + this.cap   .y3705()             + ' ' + this.dashes.y3705();     }        t3357()     {         return l2030.NaN.copy();     }        static NaN = Object.freeze(new l2030(         new b2020(),         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         new v2032()));        static default = Object.freeze(new l2030(         new b2020(),         new x2021(1),         new x2021(0),         new x2021(0),         new x2021(28.96),         new x2021(0),         new v2032())); }    function z3831(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [l2030.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const fills  = i3481  (str, i); i += fills [1];     const weight = k2849(str[i]); i += weight[1];     const fit    = k2849(str[i]); i += fit   [1];     const join   = k2849(str[i]); i += join  [1];     const miter  = k2849(str[i]); i += miter [1];     const cap    = k2849(str[i]); i += cap   [1];     const dashes = b2864  (str[i]); i += dashes[1];      return [          new l2030(             fills [0],              weight[0],              fit   [0],              join  [0],              miter [0],              cap   [0],              dashes[0]),                  i - w3768 ]; } 


class i4271 extends r2049 {     top;     left;     right;     bottom;     visible;        constructor(top     = new x2021(0),                  left    = new x2021(0),                  right   = new x2021(0),                  bottom  = new x2021(0),                  visible = true)     {         super(m1190);          this.top     = top;         this.left    = left;         this.right   = right;         this.bottom  = bottom;         this.visible = visible;     }            copy()     {         const copy = new i4271(             this.top   .copy(),             this.left  .copy(),             this.right .copy(),             this.bottom.copy(),             this.visible);          copy.z3358(this);          return copy;     }        equals(sides)     {         return this.top   .equals(sides.tl)             && this.left  .equals(sides.tr)             && this.right .equals(sides.bl)             && this.bottom.equals(sides.br)             && this.visible === sides.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.top   .toString()             + ' ' + this.left  .toString()             + ' ' + this.right .toString()             + ' ' + this.bottom.toString();     }        x3704()     {         return      this.top   .x3704()             + ' ' + this.left  .x3704()             + ' ' + this.right .x3704()             + ' ' + this.bottom.x3704();     }        y3705()     {         return      this.top   .y3705()             + ' ' + this.left  .y3705()             + ' ' + this.right .y3705()             + ' ' + this.bottom.y3705();     }        isValid()     {         return this.top   .isValid()             && this.left  .isValid()             && this.right .isValid()             && this.bottom.isValid();     }        t3357()     {         return i4271.NaN.copy();     }        static NaN = Object.freeze(new i4271(         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         false)); }    function parseStrokeSidesValue(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [i4271.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const top    = k2849(str[i]); i += top   [1];     const left   = k2849(str[i]); i += left  [1];     const right  = k2849(str[i]); i += right [1];     const bottom = k2849(str[i]); i += bottom[1];       const sides = new i4271(         top   [0],         left  [0],         right [0],         bottom[0]);       return [sides, i - w3768]; } 


class y2025 extends r2049 {     tl;     tr;     bl;     br;     visible;        constructor(tl = new x2021(0),                  tr = new x2021(0),                  bl = new x2021(0),                  br = new x2021(0),                  visible = true)     {         super(d1193);          this.tl      = tl;         this.tr      = tr;         this.bl      = bl;         this.br      = br;         this.visible = visible;     }            copy()     {         const copy = new y2025(             this.tl.copy(),             this.tr.copy(),             this.bl.copy(),             this.br.copy(),             this.visible);          copy.z3358(this);          return copy;     }        equals(corners)     {         return this.tl.equals(corners.tl)             && this.tr.equals(corners.tr)             && this.bl.equals(corners.bl)             && this.br.equals(corners.br)             && this.visible === corners.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.tl.toString()             + ' ' + this.tr.toString()             + ' ' + this.bl.toString()             + ' ' + this.br.toString();     }        x3704()     {         return      this.tl.x3704()             + ' ' + this.tr.x3704()             + ' ' + this.bl.x3704()             + ' ' + this.br.x3704();     }        y3705()     {         return      this.tl.y3705()             + ' ' + this.tr.y3705()             + ' ' + this.bl.y3705()             + ' ' + this.br.y3705();     }        isValid()     {         return this.tl.isValid()             && this.tr.isValid()             && this.bl.isValid()             && this.br.isValid();     }        t3357()     {         return y2025.NaN.copy();     }        static NaN = Object.freeze(new y2025(         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         false)); }    function b3837(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [y2025.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const tl = k2849(str[i]); i += tl[1];     const tr = k2849(str[i]); i += tr[1];     const bl = k2849(str[i]); i += bl[1];     const br = k2849(str[i]); i += br[1];       const corners = new y2025(         tl[0],         tr[0],         bl[0],         br[0]);       return [corners, i - w3768]; } 


class q2010 extends r2049 {     x;     y;     blur;     spread;     fill;     blend;     behind;     visible;        constructor(x       = new x2021(0),                  y       = new x2021(0),                  blur    = new x2021(0),                  spread  = new x2021(0),                  fill    = q2012.NaN,                 blend   = new x2021(0),                 behind  = new x2021(0),                 visible = true)     {         super(q1196);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.behind  = behind;         this.visible = visible;                  g952(fill.type == y1178, 'fill.type must be FILL_VALUE');     }                                             copy()     {         const copy = new q2010(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.behind.copy(),             this.visible);          copy.z3358(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.behind.equals(shadow.behind)             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString()             + ' ' + this.behind.toString();     }        x3704()     {         return      this.x     .x3704()             + ' ' + this.y     .x3704()             + ' ' + this.blur  .x3704()             + ' ' + this.spread.x3704()             + ' ' + this.fill  .x3704()             + ' ' + this.blend .x3704()             + ' ' + this.behind.x3704();     }        y3705()     {         return      this.x     .y3705()             + ' ' + this.y     .y3705()             + ' ' + this.blur  .y3705()             + ' ' + this.spread.y3705()             + ' ' + this.fill  .y3705()             + ' ' + this.blend .y3705()             + ' ' + this.behind.y3705();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid()             && this.behind.isValid();     }        t3357()     {         return q2010.NaN.copy();     }        static NaN = Object.freeze(new q2010(         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         q2012 .NaN,         x2021.NaN,         x2021.NaN,         false));        }    function b3832(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [q2010.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const x      = k2849(str[i]); i += x     [1];     const y      = k2849(str[i]); i += y     [1];     const blur   = k2849(str[i]); i += blur  [1];     const spread = k2849(str[i]); i += spread[1];     const fill   = r3676  (str, i); i += fill  [1];     const blend  = k2849(str[i]); i += blend [1];     const behind = k2849(str[i]); i += behind[1];       const shadow = new q2010(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0],         behind[0]);       return [shadow, i - w3768]; } 


class c2015 extends r2049 {     x;     y;     blur;     spread;     fill;     blend;     visible;        constructor(x       = new x2021(0),                  y       = new x2021(0),                  blur    = new x2021(0),                  spread  = new x2021(0),                  fill    = q2012.NaN,                 blend   = new x2021(0),                 visible = true)     {         super(b1199);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.visible = visible;     }                                             copy()     {         const copy = new c2015(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.visible);          copy.z3358(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString();     }        x3704()     {         return      this.x     .x3704()             + ' ' + this.y     .x3704()             + ' ' + this.blur  .x3704()             + ' ' + this.spread.x3704()             + ' ' + this.fill  .x3704()             + ' ' + this.blend .x3704();     }        y3705()     {         return      this.x     .y3705()             + ' ' + this.y     .y3705()             + ' ' + this.blur  .y3705()             + ' ' + this.spread.y3705()             + ' ' + this.fill  .y3705()             + ' ' + this.blend .y3705();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid();     }        t3357()     {         return c2015.NaN.copy();     }        static NaN = Object.freeze(new c2015(         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         q2012 .NaN,         x2021.NaN,         false));         }    function a3833(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [c2015.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const x      = k2849(str[i]); i += x     [1];     const y      = k2849(str[i]); i += y     [1];     const blur   = k2849(str[i]); i += blur  [1];     const spread = k2849(str[i]); i += spread[1];     const fill   = r3676  (str, i); i += fill  [1];     const blend  = k2849(str[i]); i += blend [1];       const shadow = new c2015(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0]);       return [shadow, i - w3768]; } 


class o2017 extends r2049 {     radius;     visible;        constructor(radius  = new x2021(0),                  visible = true)     {         super(s1202);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new o2017(             this.radius.copy(),             this.visible);          copy.z3358(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        x3704()     {         return this.radius.x3704();     }        y3705()     {         return this.radius.y3705();     }        isValid()     {         return this.radius.isValid();     }        t3357()     {         return o2017.NaN.copy();     }        static NaN = Object.freeze(new o2017(         x2021.NaN,         false));         }    function u3834(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [o2017.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const radius = k2849(str[i]); i += radius[1];       const shadow = new o2017(         radius[0]);       return [shadow, i - w3768]; } 


class d2007 extends r2049 {     radius;     visible;        constructor(radius  = new x2021(0),                 visible = true)     {         super(m1205);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new d2007(             this.radius.copy(),             this.visible);          copy.z3358(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        x3704()     {         return this.radius.x3704();     }        y3705()     {         return this.radius.y3705();     }        isValid()     {         return this.radius.isValid();     }        t3357()     {         return d2007.NaN.copy();     }        static NaN = Object.freeze(new d2007(         x2021.NaN,         false));         }    function z3706(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [d2007.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const radius = k2849(str[i]); i += radius[1];       const shadow = new d2007(         radius[0]);       return [shadow, i - w3768]; } 


class g2016 extends r2049 {     opacity;     blend;        constructor(opacity, blend)     {         super(s1211);          this.opacity = opacity.copy();         this.blend   = blend  .copy();     }            copy()     {         const copy = new g2016(this.opacity, this.blend);          copy.z3358(this);          return copy;     }        equals(layer)     {         return this.opacity.equals(layer.opacity)             && this.blend  .equals(layer.blend  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.opacity.toString()             + ' ' + this.blend  .toString();     }        x3704()     {         return      this.opacity.x3704()             + ' ' + this.blend  .x3704();     }        y3705()     {         return      this.opacity.y3705()             + ' ' + this.blend  .y3705();     }        u3711()     {         return this.opacity.u3711()             && this.blend  .u3711();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        t3357()     {         return g2016.NaN.copy();     }        static NaN = Object.freeze(new g2016(x2021.NaN, x2021.NaN)); }    function z3707(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [g2016.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const opacity = k2849(str[i]); i += opacity[1];     const blend   = k2849(str[i]); i += blend  [1];       const layer = new g2016(         opacity[0],         blend  [0]);               return [layer, i - w3768]; } 


class i2018 extends r2049 {     visible;     maskType;        constructor(maskType, visible = true)     {         super(q1208);          this.visible  = visible;         this.maskType = maskType.copy();     }            copy()     {         const copy = new i2018(this.maskType, this.visible);          copy.z3358(this);          return copy;     }        equals(mask)     {         return this.visible === mask.visible             && this.maskType.equals(mask.maskType);     }        async eval(parse)     {         return this;     }        toString()     {         return 'mask';     }        x3704()     {         return 'mask';     }        y3705()     {         return 'mask';     }        isValid()     {         return this.maskType.isValid();     }        t3357()     {         return i2018.NaN.copy();     }        static NaN = Object.freeze(new i2018(x2021.NaN, false)); }    function z3708(str) {     const mask =          str == d964         ? i2018.NaN         : new i2018(new x2021(parseInt(str)), true);      return [mask, 1]; } 


   class y2028 extends r2049 {     nodeId;      props = null;        constructor(type, nodeId)     {         super(type);          this.nodeId = nodeId;           this.objects = [];     }        z3358(base)     {         super.z3358(base);                  this.nodeId = base.nodeId;          if (base.objects) this.objects = base.objects.map(o => o.copy());          if (base.props  ) this.props   = base.props.copy();     }        u3711()     {         return !this.props             ||  this.props.u3711();     }        isValid()     {         return !this.props             ||  this.props.isValid();     } }    function x3709(str, i, l111) {     const props = i3481(str, i); i += props[1];      l111.props = props[0];      return i; }


class r2024 extends y2028 {     x;     y;     width;     height;     round;        constructor(nodeId,                 x      = new x2021(0),                  y      = new x2021(0),                  width  = new x2021(0),                  height = new x2021(0),                  round  = new x2021(0))     {         super(r1218, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;     }        copy()     {         const copy = new r2024(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy());          copy.z3358(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + super.toString();     }        x3704()     {         return 'rectangle';                                                                      }        y3705()     {         return      this.x     .y3705()             + ' ' + this.y     .y3705()             + ' ' + this.width .y3705()             + ' ' + this.height.y3705()             + ' ' + this.round .y3705();     }        t3632()     {         return this.copy();     }        u3711()     {         return super.u3711()             && this.x     .u3711()             && this.y     .u3711()             && this.width .u3711()             && this.height.u3711()             && this.round .u3711();     }        isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid();     }            static NaN = new r2024(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function t3710(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [r2024.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const x      = k2849(str[i]); i += x     [1];     const y      = k2849(str[i]); i += y     [1];     const width  = k2849(str[i]); i += width [1];     const height = k2849(str[i]); i += height[1];     const round  = k2849(str[i]); i += round [1];       const rect = new r2024(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0]);       i = x3709(str, i, rect);           return [rect, i - w3768]; } 


class m2019 extends y2028 {     x;     y;     width;        constructor(nodeId,                 x      = new x2021(0),                  y      = new x2021(0),                  width  = new x2021(0))     {         super(m1221, nodeId);          this.x     = x;         this.y     = y;         this.width = width;     }        copy()     {         const copy = new m2019(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.width.copy());          copy.z3358(this);          return copy;     }        equals(line)     {         return line             && this.x    .equals(line.x    )             && this.y    .equals(line.y    )             && this.width.equals(line.width);     }        async eval(parse)     {         return this.copy();     }        u3711()     {         return super.u3711()             && this.x     .u3711()             && this.y     .u3711()             && this.width .u3711();     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.width.isValid();     }        t3632()     {         return this.copy();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.width.toString()             + ' ' + super.toString();     }        x3704()     {         return      this.x    .x3704()             + ' ' + this.y    .x3704()             + ' ' + this.width.x3704();     }        y3705()     {         return      this.x    .y3705()             + ' ' + this.y    .y3705()             + ' ' + this.width.y3705();     }        static NaN = new m2019(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function a3821(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [m2019.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const x     = k2849(str[i]); i += x    [1];     const y     = k2849(str[i]); i += y    [1];     const width = k2849(str[i]); i += width[1];       const line = new m2019(         '',          x    [0],         y    [0],         width[0]);       i = x3709(str, i, line);           return [line, i - w3768]; } 


class e2011 extends y2028 {     position;     x;     y;     width;     height;     round;     start;     sweep;     inner;        constructor(nodeId,                 position = new x2021(0),                 x        = new x2021(0),                  y        = new x2021(0),                  width    = new x2021(0),                  height   = new x2021(0),                  round    = new x2021(0),                  start    = new x2021(0),                 sweep    = new x2021(0),                 inner    = new x2021(0))     {         super(t1224, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.start    = start;         this.sweep    = sweep;         this.inner    = inner;     }        copy()     {         const copy = new e2011(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.start   .copy(),             this.sweep   .copy(),             this.inner   .copy());          copy.z3358(this);          return copy;     }        equals(ellipse)     {         return ellipse             && this.position.equals(ellipse.position)             && this.x       .equals(ellipse.x       )             && this.y       .equals(ellipse.y       )             && this.width   .equals(ellipse.width   )             && this.height  .equals(ellipse.height  )             && this.round   .equals(ellipse.round   )             && this.start   .equals(ellipse.start   )             && this.sweep   .equals(ellipse.sweep   )             && this.inner   .equals(ellipse.inner   );     }        async eval(parse)     {         return this.copy();     }                    u3711()     {         return super.u3711()             && this.position.u3711()             && this.x       .u3711()             && this.y       .u3711()             && this.width   .u3711()             && this.height  .u3711()             && this.round   .u3711()             && this.start   .u3711()             && this.sweep   .u3711()             && this.inner   .u3711();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.start   .isValid()             && this.sweep   .isValid()             && this.inner   .isValid();     }        t3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + this.inner   .toString()             + ' ' + super.toString();     }        x3704()     {         return 'ellipse';                                                                                                                          }        y3705()     {         return      this.position.y3705()             + ' ' + this.x       .y3705()             + ' ' + this.y       .y3705()             + ' ' + this.width   .y3705()             + ' ' + this.height  .y3705()             + ' ' + this.round   .y3705()             + ' ' + this.start   .y3705()             + ' ' + this.sweep   .y3705()             + ' ' + this.inner   .y3705();     }        static NaN = new e2011(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function g3822(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [e2011.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const pos    = k2849(str[i]); i += pos   [1];     const x      = k2849(str[i]); i += x     [1];     const y      = k2849(str[i]); i += y     [1];     const width  = k2849(str[i]); i += width [1];     const height = k2849(str[i]); i += height[1];     const round  = k2849(str[i]); i += round [1];     const start  = k2849(str[i]); i += start [1];     const sweep  = k2849(str[i]); i += sweep [1];     const inner  = k2849(str[i]); i += inner [1];       const ellipse = new e2011(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         start [0],         sweep [0],         inner [0]);       i = x3709(str, i, ellipse);           return [ellipse, i - w3768]; } 


class r2033 extends y2028 {     x;     y;     width;     height;     round;     bias;        constructor(nodeId,                 x      = new x2021(0),                  y      = new x2021(0),                  width  = new x2021(0),                  height = new x2021(0),                  round  = new x2021(0),                 bias   = new x2021(0))     {         super(x1227, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;         this.bias   = bias;     }        static fromObject(l111)     {         return new r2033(             l111.nodeId,             new x2021(l111.x     ),              new x2021(l111.y     ),              new x2021(l111.width ),              new x2021(l111.height),              new x2021(l111.round ),             new x2021(l111.bias  ));     }        copy()     {         const copy = new r2033(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy(),             this.bias  .copy());          copy.z3358(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round )             && this.bias  .equals(rect.bias  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + this.bias  .toString()             + ' ' + super.toString();     }        x3704()     {         return 'trapeze';                                                                                   }        y3705()     {         return      this.x     .y3705()             + ' ' + this.y     .y3705()             + ' ' + this.width .y3705()             + ' ' + this.height.y3705()             + ' ' + this.round .y3705()             + ' ' + this.bias  .y3705();     }        t3632()     {         return this.copy();     }        u3711()     {         return super.u3711()             && this.x     .u3711()             && this.y     .u3711()             && this.width .u3711()             && this.height.u3711()             && this.round .u3711()             && this.bias  .u3711();     }            isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid()             && this.bias  .isValid();     }            static NaN = new r2033(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function w3823(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [r2033.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const x      = k2849(str[i]); i += x     [1];     const y      = k2849(str[i]); i += y     [1];     const width  = k2849(str[i]); i += width [1];     const height = k2849(str[i]); i += height[1];     const round  = k2849(str[i]); i += round [1];     const bias   = k2849(str[i]); i += bias  [1];       const rect = new r2033(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0],         bias  [0]);       i = x3709(str, i, rect);           return [rect, i - w3768]; } 


class a2023 extends y2028 {     position;     x;     y;     width;     height;     round;     corners;        constructor(nodeId,                 position = new x2021(0),                 x        = new x2021(0),                  y        = new x2021(0),                  width    = new x2021(0),                  height   = new x2021(0),                  round    = new x2021(0),                  corners  = new x2021(0))     {         super(q1236, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.corners  = corners;     }        copy()     {         const copy = new a2023(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.corners .copy());              copy.z3358(this);          return copy;     }        equals(poly)     {         return poly             && this.position.equals(poly.position)             && this.x       .equals(poly.x       )             && this.y       .equals(poly.y       )             && this.width   .equals(poly.width   )             && this.height  .equals(poly.height  )             && this.round   .equals(poly.round   )             && this.corners .equals(poly.corners );     }        async eval(parse)     {         return this.copy();     }        u3711()     {         return super.u3711()             && this.position.u3711()             && this.x       .u3711()             && this.y       .u3711()             && this.width   .u3711()             && this.height  .u3711()             && this.round   .u3711()             && this.corners .u3711();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.corners .isValid();     }        t3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.corners .toString()             + ' ' + super.toString();     }        x3704()     {         return      this.position.x3704()             + ' ' + this.x       .x3704()             + ' ' + this.y       .x3704()             + ' ' + this.width   .x3704()             + ' ' + this.height  .x3704()             + ' ' + this.round   .x3704()             + ' ' + this.corners .x3704();     }        y3705()     {         return      this.position.y3705()             + ' ' + this.x       .y3705()             + ' ' + this.y       .y3705()             + ' ' + this.width   .y3705()             + ' ' + this.height  .y3705()             + ' ' + this.round   .y3705()             + ' ' + this.corners .y3705();     }        static NaN = new a2023(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function w3824(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [a2023.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const pos     = k2849(str[i]); i += pos    [1];     const x       = k2849(str[i]); i += x      [1];     const y       = k2849(str[i]); i += y      [1];     const width   = k2849(str[i]); i += width  [1];     const height  = k2849(str[i]); i += height [1];     const round   = k2849(str[i]); i += round  [1];     const corners = k2849(str[i]); i += corners[1];       const poly = new a2023(         '',          pos    [0],         x      [0],         y      [0],         width  [0],         height [0],         round  [0],         corners[0]);       i = x3709(str, i, poly);           return [poly, i - w3768]; } 


class a2029 extends y2028 {     position;     x;     y;     width;     height;     round;     points;     convex;        constructor(nodeId,                 position = new x2021(0),                  x        = new x2021(0),                  y        = new x2021(0),                  width    = new x2021(0),                  height   = new x2021(0),                  round    = new x2021(0),                  points   = new x2021(0),                 convex   = new x2021(0))     {         super(m1239, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.points   = points;         this.convex   = convex;     }        copy()     {         const copy = new a2029(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.points  .copy(),             this.convex  .copy());          copy.z3358(this);          return copy;     }        equals(star)     {         return star             && this.position.equals(star.position)             && this.x       .equals(star.x       )             && this.y       .equals(star.y       )             && this.width   .equals(star.width   )             && this.height  .equals(star.height  )             && this.round   .equals(star.round   )             && this.points  .equals(star.points  )             && this.convex  .equals(star.convex  );     }        async eval(parse)     {         return this.copy();     }        u3711()     {         return super.u3711()             && this.position.u3711()             && this.x       .u3711()             && this.y       .u3711()             && this.width   .u3711()             && this.height  .u3711()             && this.round   .u3711()             && this.points  .u3711()             && this.convex  .u3711();     }            isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.points  .isValid()             && this.convex  .isValid();     }            t3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.points  .toString()             + ' ' + this.convex  .toString()             + ' ' + super.toString();     }        x3704()     {         return      this.position.x3704()             + ' ' + this.x       .x3704()             + ' ' + this.y       .x3704()             + ' ' + this.width   .x3704()             + ' ' + this.height  .x3704()             + ' ' + this.round   .x3704()             + ' ' + this.points  .x3704()             + ' ' + this.convex  .x3704();     }        y3705()     {         return      this.position.y3705()             + ' ' + this.x       .y3705()             + ' ' + this.y       .y3705()             + ' ' + this.width   .y3705()             + ' ' + this.height  .y3705()             + ' ' + this.round   .y3705()             + ' ' + this.points  .y3705()             + ' ' + this.convex  .y3705();     }        static NaN = new a2029(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function l3825(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [a2029.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const pos    = k2849(str[i]); i += pos   [1];     const x      = k2849(str[i]); i += x     [1];     const y      = k2849(str[i]); i += y     [1];     const width  = k2849(str[i]); i += width [1];     const height = k2849(str[i]); i += height[1];     const round  = k2849(str[i]); i += round [1];     const points = k2849(str[i]); i += points[1];     const convex = k2849(str[i]); i += convex[1];       const star = new a2029(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         points[0],         convex[0]);       i = x3709(str, i, star);           return [star, i - w3768]; } 


class q2031 extends y2028 {     text;     x;     y;     width;     height;     font;     style;     size;     alignX;     alignY;     lineHeight;     letterSpacing;            constructor(nodeId,                 text          = new v2032(),                 x             = new x2021(0),                  y             = new x2021(0),                  width         = new x2021(0),                  height        = new x2021(0),                  font          = new x2021(0),                 style         = new x2021(0),                 size          = new x2021(0),                 alignX        = new x2021(0),                 alignY        = new x2021(0),                 lineHeight    = new x2021(0),                 letterSpacing = new x2021(0))     {         super(v1242, nodeId);          this.text          = text;         this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;         this.font          = font;         this.style         = style;         this.size          = size;         this.alignX        = alignX;         this.alignY        = alignY;         this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;          this.objects       = [];     }        copy()     {         const copy = new q2031(             this.nodeId,             this.text         .copy(),             this.x            .copy(),              this.y            .copy(),              this.width        .copy(),              this.height       .copy(),              this.font         .copy(),             this.style        .copy(),             this.size         .copy(),             this.alignX       .copy(),             this.alignY       .copy(),             this.lineHeight   .copy(),             this.letterSpacing.copy());           copy.z3358(this);          return copy;     }        equals(text)     {         return text             && this.text         .equals(text.text         )             && this.x            .equals(text.x            )             && this.y            .equals(text.y            )             && this.width        .equals(text.width        )             && this.height       .equals(text.height       )             && this.font         .equals(text.font         )             && this.style        .equals(text.style        )             && this.size         .equals(text.size         )             && this.alignX       .equals(text.alignX       )             && this.alignY       .equals(text.alignY       )             && this.lineHeight   .equals(text.lineHeight   )             && this.letterSpacing.equals(text.letterSpacing);     }        async eval(parse)     {         return this.copy();     }        u3711()     {         return super.u3711()             && this.text         .u3711()             && this.x            .u3711()             && this.y            .u3711()             && this.width        .u3711()             && this.height       .u3711()             && this.font         .u3711()             && this.style        .u3711()             && this.size         .u3711()             && this.alignX       .u3711()             && this.alignY       .u3711()             && this.lineHeight   .u3711()             && this.letterSpacing.u3711();     }            isValid()     {         return super.isValid()             && this.text         .isValid()             && this.x            .isValid()             && this.y            .isValid()             && this.width        .isValid()             && this.height       .isValid()             && this.font         .isValid()             && this.style        .isValid()             && this.size         .isValid()             && this.alignX       .isValid()             && this.alignY       .isValid()             && this.lineHeight   .isValid()             && this.letterSpacing.isValid();     }            t3632()     {         return this.copy();     }        toString()     {         return      this.text         .x2118()              + ' ' + this.x            .toString()             + ' ' + this.y            .toString()             + ' ' + this.width        .toString()             + ' ' + this.height       .toString()             + ' ' + this.font         .toString()             + ' ' + this.style        .toString()             + ' ' + this.size         .toString()             + ' ' + this.alignX       .toString()             + ' ' + this.alignY       .toString()             + ' ' + this.lineHeight   .toString()             + ' ' + this.letterSpacing.toString()             + ' ' + super.toString();         }        x3704()     {         return 'textShape';                                                                                                                                                                       }        y3705()     {         return      this.text         .y3705()             + ' ' + this.x            .y3705()             + ' ' + this.y            .y3705()             + ' ' + this.width        .y3705()             + ' ' + this.height       .y3705()             + ' ' + this.font         .y3705()             + ' ' + this.style        .y3705()             + ' ' + this.size         .y3705()             + ' ' + this.alignX       .y3705()             + ' ' + this.alignY       .y3705()             + ' ' + this.lineHeight   .y3705()             + ' ' + this.letterSpacing.y3705();     }        x2118()     {         return      this.text         .x2118()             + ' ' + this.x            .x2118()             + ' ' + this.y            .x2118()             + ' ' + this.width        .x2118()             + ' ' + this.height       .x2118()             + ' ' + this.font         .x2118()             + ' ' + this.style        .x2118()             + ' ' + this.size         .x2118()             + ' ' + this.alignX       .x2118()             + ' ' + this.alignY       .x2118()             + ' ' + this.lineHeight   .x2118()             + ' ' + this.letterSpacing.x2118();     }        static NaN = new q2031(         '',         v2032.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function m3826(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [q2031.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const text          = b2864  (str[i]); i += text         [1];     const x             = k2849(str[i]); i += x            [1];     const y             = k2849(str[i]); i += y            [1];     const width         = k2849(str[i]); i += width        [1];     const height        = k2849(str[i]); i += height       [1];     const font          = k2849(str[i]); i += font         [1];     const style         = k2849(str[i]); i += style        [1];     const size          = k2849(str[i]); i += size         [1];     const alignX        = k2849(str[i]); i += alignX       [1];     const alignY        = k2849(str[i]); i += alignY       [1];     const lineHeight    = k2849(str[i]); i += lineHeight   [1];     const letterSpacing = k2849(str[i]); i += letterSpacing[1];       const txts = new q2031(         '',          text         [0],         x            [0],         y            [0],         width        [0],         height       [0],         font         [0],         style        [0],         size         [0],         alignX       [0],         alignY       [0],         lineHeight   [0],         letterSpacing[0]);       i = x3709(str, i, txts);           return [txts, i - w3768]; } 


class b2022 extends r2049 {     nodeId;      x;     y;     smooth;       sp0 = null;      sp1 = null;      sp2 = null;         constructor(nodeId,                 x = new x2021(0),                  y = new x2021(0),                 smooth = null)     {         super(u1245);          this.nodeId  = nodeId;          this.x       = x;         this.y       = y;         this.smooth  = smooth;           this.v3741();     }        copy()     {         const copy = new b2022(             this.nodeId,             this.x.copy(),              this.y.copy());          if (this.smooth) copy.smooth = this.smooth.copy();          copy.z3358(this);          copy.sp0 = clone(this.sp0);         copy.sp1 = clone(this.sp1);         copy.sp2 = clone(this.sp2);          return copy;     }        equals(p)     {         return p             && this.x.equals(p.x)             && this.y.equals(p.y);     }        v3741(cx = 0, cy = 0) {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        applySpaceTransform(c4207, space)     {         this.sp0 = j3730(this.sp0, c4207, space);         this.sp1 = j3730(this.sp1, c4207, space);         this.sp2 = j3730(this.sp2, c4207, space);     }        static create(nodeId, x, y)     {         return new b2022(             nodeId,             new x2021(x),             new x2021(y));     }        static fromPoint(nodeId, p)     {         return new b2022(             nodeId,             new x2021(p.x),             new x2021(p.y));     }        async eval(parse)     {         return this.copy();     }        u3711()     {         return this.x.u3711()             && this.y.u3711()             && (  !this.smooth                 || this.smooth.u3711());     }        isValid()     {         return this.x.isValid()             && this.y.isValid()             && (  !this.smooth                 || this.smooth.isValid());     }        toString()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.toString()               + ' ' + this.y.toString()             : d964;     }        x3704()     {         return this.x.isValid()             && this.y.isValid()             ?   '(' + this.x.x3704()               + ', ' + this.y.x3704()               + ')'             : d964;     }        y3705()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.y3705()               + ' ' + this.y.y3705()             : d964;     }        t3632()     {         return this.copy();     }        z3746()     {         return point(             this.x.value,             this.y.value);     }        g2846(gen)     {         return '';     }        t3357()     {         return b2022.NaN.copy();     }        static NaN = Object.freeze(new b2022(         '',         x2021.NaN,          x2021.NaN)); }    function y3827(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [b2022.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const x = k2849(str[i]); i += x[1];     const y = k2849(str[i]); i += y[1];       const point = new b2022(         '',          x[0],         y[0]);       return [point, i - w3768]; } 


class p2036 extends y2028 {     points;     closed;     degree;     winding;     round;        constructor(nodeId,                 points  = new b2020(),                  closed  = new x2021(0),                  degree  = new x2021(0),                  winding = new x2021(0),                  round   = new x2021(0))     {         super(b1249, nodeId);          this.points  = points ?? new b2020();         this.closed  = closed;         this.degree  = degree;         this.winding = winding;         this.round   = round;     }        static fromObject(l111)     {         return new p2036(             l111.nodeId,             new b2020(l111.points.map(p => b2022.fromPoint(l111.nodeId, p))),              new x2021(l111.closed ),              new x2021(l111.degree ),              new x2021(l111.winding),              new x2021(l111.round  ));     }        copy()     {         const copy = new p2036(             this.nodeId,             this.points .copy(),              this.closed .copy(),              this.degree .copy(),              this.winding.copy(),              this.round  .copy());          copy.z3358(this);          return copy;     }        equals(rect)     {         return rect             && this.points .equals(rect.points )             && this.closed .equals(rect.closed )             && this.degree .equals(rect.degree )             && this.winding.equals(rect.winding)             && this.round  .equals(rect.round  );     }        async eval(parse)     {         return this.copy();     }        toString()     {         return      this.points .toString()             + ' ' + this.closed .toString()             + ' ' + this.degree .toString()             + ' ' + this.winding.toString()             + ' ' + this.round  .toString()             + ' ' + super.toString();     }        x3704()     {         return      this.points .x3704()             + ' ' + this.closed .x3704()             + ' ' + this.degree .x3704()             + ' ' + this.winding.x3704()             + ' ' + this.round  .x3704();     }        y3705()     {         return      this.points .y3705()             + ' ' + this.closed .y3705()             + ' ' + this.degree .y3705()             + ' ' + this.winding.y3705()             + ' ' + this.round  .y3705();     }        t3632()     {         return this.copy();     }        u3711()     {         return super.u3711()             && this.points .u3711()             && this.closed .u3711()             && this.degree .u3711()             && this.winding.u3711()             && this.round  .u3711();     }            isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }            static NaN = new p2036(         '',         b2020  .NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function y3669(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [p2036.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const points  = i3481  (str, i); i += points [1];     const closed  = k2849(str[i]); i += closed [1];     const degree  = k2849(str[i]); i += degree [1];     const winding = k2849(str[i]); i += winding[1];     const round   = k2849(str[i]); i += round  [1];      const path = new p2036(         '',          points [0],         closed [0],         degree [0],         winding[0],         round  [0]);       i = x3709(str, i, path);           return [path, i - w3768]; } 


class w2038 extends r2049 {     nodeId;      x;     y;     join;     cap;     round;        constructor(nodeId,                 x     = new x2021(0),                  y     = new x2021(0),                 join  = new x2021(0),                 cap   = new x2021(0),                 round = new x2021(0))     {         super(g1252);          this.nodeId = nodeId;          this.x      = x    .copy();         this.y      = y    .copy();         this.join   = join .copy();         this.cap    = cap  .copy();         this.round  = round.copy();     }        copy()     {         const copy = new w2038(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.join .copy(),              this.cap  .copy(),              this.round.copy());          copy.z3358(this);          return copy;     }        equals(p)     {         return p             && this.x    .equals(p.x    )             && this.y    .equals(p.y    )             && this.join .equals(p.join )             && this.cap  .equals(p.cap  )             && this.round.equals(p.round);     }        static create(nodeId, x, y)     {         return new w2038(             nodeId,             new x2021(x    ),             new x2021(y    ),             new x2021(join ),             new x2021(cap  ),             new x2021(round));     }        static fromPoint(nodeId, p)     {         return new w2038(             nodeId,             new x2021(p.x),             new x2021(p.y),             new x2021(0),             new x2021(0),             new x2021(0));     }        async eval(parse)     {         return this;     }        u3711()     {         return this.x    .u3711()             && this.y    .u3711()             && this.join .u3711()             && this.cap  .u3711()             && this.round.u3711();     }        isValid()     {         return this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.join .toString()             + ' ' + this.cap  .toString()             + ' ' + this.round.toString();     }        x3704()     {         return      this.x    .x3704()             + ' ' + this.y    .x3704()             + ' ' + this.join .x3704()             + ' ' + this.cap  .x3704()             + ' ' + this.round.x3704();     }        y3705()     {         return      this.x    .y3705()             + ' ' + this.y    .y3705()             + ' ' + this.join .y3705()             + ' ' + this.cap  .y3705()             + ' ' + this.round.y3705();     }        t3632()     {         return this.copy();     }        z3746()     {         return point(             this.x.value,             this.y.value);     }        g2846(gen)     {         return '';     }        t3357()     {         return w2038.NaN.copy();     }        static NaN = Object.freeze(new w2038(         '',         x2021.NaN,          x2021.NaN,          x2021.NaN,          x2021.NaN,          x2021.NaN)); }    function g3668(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [w2038.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const x     = k2849(str[i]); i += x    [1];     const y     = k2849(str[i]); i += y    [1];     const join  = k2849(str[i]); i += join [1];     const cap   = k2849(str[i]); i += cap  [1];     const round = k2849(str[i]); i += round[1];       const point = new w2038(         '',          x    [0],         y    [0],         join [0],         cap  [0],         round[0]);       return [point, i - w3768]; } 


class z2034 extends r2049 {     nodeId;      start;     end;     c3664;     r3665;        constructor(nodeId,                 start,                  end,                 c3664 = b2022.create(nodeId, 0, 0),                 r3665   = b2022.create(nodeId, 0, 0))     {         super(s1255);          this.nodeId = nodeId;          this.start        = start       .copy();                this.end          = end         .copy();                  this.c3664 = c3664.copy();         this.r3665   = r3665  .copy();       }        copy()     {         const copy = new z2034(             this.nodeId,             this.start       .copy(),              this.end         .copy(),              this.c3664.copy(),              this.r3665  .copy());          copy.z3358(this);          return copy;     }        equals(edge)     {         return edge             && this.start       .equals(edge.start       )             && this.end         .equals(edge.end         )             && this.c3664.equals(edge.c3664)             && this.  r3665.equals(edge.  r3665);     }        static create(nodeId, start, end, c3664, r3665)     {         return new z2034(             nodeId,             start,             end,             b2022.create(nodeId, c3664.x, c3664.y),             b2022.create(nodeId,   r3665.x,   r3665.y));     }        async eval(parse)     {         return this;     }        u3711()     {         return this.start       .u3711()             && this.end         .u3711()             && this.c3664.u3711()             && this.r3665  .u3711();     }        isValid()     {         return this.start       .isValid()             && this.end         .isValid()             && this.c3664.isValid()             && this.r3665  .isValid();     }        toString()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.c3664.toString()             + ' ' + this.r3665  .toString();     }        x3704()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.c3664.toString()             + ' ' + this.r3665  .toString();     }        y3705()     {         return      this.start       .y3705()             + ' ' + this.end         .y3705()             + ' ' + this.c3664.y3705()             + ' ' + this.r3665  .y3705();     }        t3632()     {         return this.copy();     }        g2846(gen)     {         return '';     }        t3357()     {         return z2034.NaN.copy();     }        static NaN = Object.freeze(new z2034(         '',         w2038.NaN,          w2038.NaN,          b2022.NaN,          b2022.NaN)); }    function o3666(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [z2034.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const start        = g3668(str, i); i += start       [1];     const end          = g3668(str, i); i += end         [1];     const c3664 = y3827       (str, i); i += c3664[1];     const r3665   = y3827       (str, i); i +=   r3665[1];       const edge = new z2034(         '',          start       [0],         end         [0],         c3664[0],           r3665[0]);       return [edge, i - w3768]; } 


class q2037 extends y2028 {     loops;       winding;      fills = [];        constructor(nodeId,                 loops   = new b2020(),                  winding = new x2021(0))     {         super(w1258, nodeId);          this.loops   = loops;           this.winding = winding;     }        copy()     {         const copy = new q2037(             this.nodeId,             this.loops  .copy(),              this.winding.copy());          copy.fills = clone(this.fills);                  copy.z3358(this);          return copy;     }        equals(region)     {         return region             && this.loops  .equals(region.loops  )             && this.winding.equals(region.winding);     }                                              async eval(parse)     {         return this;     }        u3711()     {         return this.loops  .u3711()             && this.winding.u3711();     }        isValid()     {         return this.loops  .isValid()             && this.winding.isValid();     }        toString()     {         return      this.loops  .toString()             + ' ' + this.winding.toString();     }        x3704()     {         return      this.loops  .x3704()             + ' ' + this.winding.x3704();     }        y3705()     {         return      this.loops  .y3705()             + ' ' + this.winding.y3705();     }        t3632()     {         return this.copy();     }        g2846(gen)     {         return '';     }        t3357()     {         return z2034.NaN.copy();     }        static NaN = Object.freeze(new q2037(         '',         b2020  .NaN,          x2021.NaN)); }    function y3663(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [q2037.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const loops   = i3481  (str, i); i += loops  [1];     const winding = k2849(str[i]); i += winding[1];       const region = new q2037(         '',          loops  [0],         winding[0]);       i = x3709(str, i, region);       return [region, i - w3768]; } 


class d2035 extends r2049 {     nodeId;      regions;        constructor(nodeId,                 regions = new b2020())     {         super(s1261);          this.nodeId  = nodeId;          this.regions = regions;      }        copy()     {         const copy = new d2035(             this.nodeId,             this.regions.copy());          copy.z3358(this);          return copy;     }        equals(other)     {         return other             && this.regions.equals(other.regions);     }        static create(nodeId, regions)     {         return new d2035(             nodeId,             regions);     }        async eval(parse)     {         return this;     }        u3711()     {         return this.regions.u3711();     }        isValid()     {         return this.regions.isValid();     }        toString()     {         return this.regions.toString();     }        x3704()     {         return this.regions.x3704();     }        y3705()     {         return this.regions.y3705();     }        t3632()     {         return this.copy();     }        g2846(gen)     {         return '';     }        t3357()     {         return d2035.NaN.copy();     }        static NaN = Object.freeze(new d2035(         '',         b2020.NaN)); }    function d3662(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [d2035.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const regions = i3481(str, i); i += regions[1];       const net = new d2035(         '',          regions[0]);       return [net, i - w3768]; } 


class d2026 extends y2028 {     operation;     children;        constructor(nodeId, children, operation)     {         super(w1287, nodeId);          this.children  = children;         this.operation = operation;          this.objects =              children.objects             ? children.objects.map(o => o.copy())             : null;     }        copy()     {         const copy = new d2026(             this.nodeId,             this.children .copy(),             this.operation.copy());          copy.z3358(this);          return copy;     }        equals(bool)     {         return bool             && this.children .equals(bool.children )             && this.operation.equals(bool.operation);     }        async eval(parse)     {         return this;     }        toString()     {         return      this.children .toString()             + ' ' + this.operation.toString();     }        x3704()     {         return      this.children .x3704()             + ' ' + this.operation.x3704();     }        y3705()     {         return      this.children .y3705()             + ' ' + this.operation.y3705();     }        t3632()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children .isValid()             && this.operation.isValid();     }            static NaN = new d2026(         '',         b2020  .NaN,         x2021.NaN); }    function v3828(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [d2026.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const children  = i3481  (str, i); i += children [1];     const operation = k2849(str[i]); i += operation[1];      const bool = new d2026(         '',          children [0],         operation[0]);       i = x3709(str, i, bool);           return [bool, i - w3768]; } 


class WavePathValue extends y2028 {     shape;     x;     y;     width;     amplitude;     frequency;     offset;     alignX;       alignY;        degree;        constructor(nodeId,                 shape     = new x2021(0),                 x         = new x2021(0),                  y         = new x2021(0),                  width     = new x2021(0),                  amplitude = new x2021(0),                 frequency = new x2021(0),                 offset    = new x2021(0),                 alignX    = new x2021(0),                 alignY    = new x2021(0))     {         super(g1234, nodeId);          this.shape     = shape;         this.x         = x;         this.y         = y;         this.width     = width;         this.amplitude = amplitude;         this.frequency = frequency;         this.offset    = offset;         this.alignX    = alignX;         this.alignY    = alignY;          this.degree   = new x2021(2);     }        copy()     {         const copy = new WavePathValue(             this.nodeId,             this.shape    .copy(),             this.x        .copy(),              this.y        .copy(),              this.width    .copy(),              this.amplitude.copy(),             this.frequency.copy(),             this.offset   .copy(),             this.alignX   .copy(),             this.alignY   .copy());          copy.z3358(this);          return copy;     }        equals(wave)     {         return wave             && this.shape    .equals(wave.shape    )             && this.x        .equals(wave.x        )             && this.y        .equals(wave.y        )             && this.width    .equals(wave.width    )             && this.amplitude.equals(wave.amplitude)             && this.frequency.equals(wave.frequency)             && this.offset   .equals(wave.offset   )             && this.alignX   .equals(wave.alignX   )             && this.alignY   .equals(wave.alignY   );     }        async eval(parse)     {         return this.copy();     }                    u3711()     {         return super.u3711()             && this.shape    .u3711()             && this.x        .u3711()             && this.y        .u3711()             && this.width    .u3711()             && this.amplitude.u3711()             && this.frequency.u3711()             && this.offset   .u3711()             && this.alignX   .u3711()             && this.alignY   .u3711();     }        isValid()     {         return super.isValid()             && this.shape    .isValid()             && this.x        .isValid()             && this.y        .isValid()             && this.width    .isValid()             && this.amplitude.isValid()             && this.frequency.isValid()             && this.offset   .isValid()             && this.alignX   .isValid()             && this.alignY   .isValid();     }        t3632()     {         return this.copy();     }        toString()     {         return      this.shape    .toString()             + ' ' + this.x        .toString()             + ' ' + this.y        .toString()             + ' ' + this.width    .toString()             + ' ' + this.amplitude.toString()             + ' ' + this.frequency.toString()             + ' ' + this.offset   .toString()             + ' ' + this.alignX   .toString()             + ' ' + this.alignY   .toString()             + ' ' + super.toString();     }        x3704()     {         return 'wave';                                                                                                                          }        y3705()     {         return      this.shape    .y3705()             + ' ' + this.x        .y3705()             + ' ' + this.y        .y3705()             + ' ' + this.width    .y3705()             + ' ' + this.amplitude.y3705()             + ' ' + this.frequency.y3705()             + ' ' + this.offset   .y3705()             + ' ' + this.alignX   .y3705()             + ' ' + this.alignY   .y3705();     }        static NaN = new WavePathValue(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function parseWavePathValue(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [WavePathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const shape     = k2849(str[i]); i += shape    [1];     const x         = k2849(str[i]); i += x        [1];     const y         = k2849(str[i]); i += y        [1];     const width     = k2849(str[i]); i += width    [1];     const amplitude = k2849(str[i]); i += amplitude[1];     const frequency = k2849(str[i]); i += frequency[1];     const offset    = k2849(str[i]); i += offset   [1];     const alignX    = k2849(str[i]); i += alignX   [1];     const alignY    = k2849(str[i]); i += alignY   [1];       const wave = new WavePathValue(         '',          shape    [0],         x        [0],         y        [0],         width    [0],         amplitude[0],         frequency[0],         offset   [0],         alignX   [0],         alignY   [0]);       i = x3709(str, i, wave);           return [wave, i - w3768]; } 


class ArcPathValue extends y2028 {     position;     x;     y;     width;     height;     start;     sweep;      degree;         constructor(nodeId,                 position = new x2021(0),                 x        = new x2021(0),                  y        = new x2021(0),                  width    = new x2021(0),                  height   = new x2021(0),                  start    = new x2021(0),                 sweep    = new x2021(0))     {         super(x1231, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.start    = start;         this.sweep    = sweep;          this.degree   = new x2021(2);     }        copy()     {         const copy = new ArcPathValue(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.start   .copy(),             this.sweep   .copy());          copy.z3358(this);          return copy;     }        equals(arc)     {         return arc             && this.position.equals(arc.position)             && this.x       .equals(arc.x       )             && this.y       .equals(arc.y       )             && this.width   .equals(arc.width   )             && this.height  .equals(arc.height  )             && this.start   .equals(arc.start   )             && this.sweep   .equals(arc.sweep   );     }        async eval(parse)     {         return this.copy();     }                    u3711()     {         return super.u3711()             && this.position.u3711()             && this.x       .u3711()             && this.y       .u3711()             && this.width   .u3711()             && this.height  .u3711()             && this.start   .u3711()             && this.sweep   .u3711();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.start   .isValid()             && this.sweep   .isValid();     }        t3632()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.start   .toString()             + ' ' + this.sweep   .toString()             + ' ' + super.toString();     }        x3704()     {         return 'arc';                                                                                                }        y3705()     {         return      this.position.y3705()             + ' ' + this.x       .y3705()             + ' ' + this.y       .y3705()             + ' ' + this.width   .y3705()             + ' ' + this.height  .y3705()             + ' ' + this.start   .y3705()             + ' ' + this.sweep   .y3705();     }        static NaN = Object.freeze(new ArcPathValue(         '',         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN)); }    function parseArcPathValue(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [ArcPathValue.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const pos    = k2849(str[i]); i += pos   [1];     const x      = k2849(str[i]); i += x     [1];     const y      = k2849(str[i]); i += y     [1];     const width  = k2849(str[i]); i += width [1];     const height = k2849(str[i]); i += height[1];     const start  = k2849(str[i]); i += start [1];     const sweep  = k2849(str[i]); i += sweep [1];       const arc = new ArcPathValue(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         start [0],         sweep [0]);       i = x3709(str, i, arc);           return [arc, i - w3768]; } 


class d2027 extends r2049 {     items = [];        constructor(nodeId, items = [])     {         super(y1264, nodeId);          this.items = items;               }        copy()     {         const copy = new d2027(             this.nodeId,             this.items.map(i => i.copy()));          copy.z3358(this);          return copy;     }        equals(group)     {         if (!group)                                  return false;         if (!(group instanceof d2027))     return false;         if (this.items.length != group.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(group.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        x3704()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.x3704();         }           return str;     }        y3705()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.y3705();         }           return str;     }        t3632()     {         return this.copy();     }        isValid()     {         return  this.items             && !this.items.find(i => !i.isValid());     }            static NaN = new d2027(         '',         b2020.NaN); }    function b3829(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const w3768 = i;      const group = new d2027();           const v4208 = parseInt(str[i++]);       for (let j = 0; j < v4208; j++)     {         const type = str[i++];                  switch (type)         {             case          q1056:               case    s1059: { const _list   = i3481        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }               case     r1218: { const rect    = t3710   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }             case          m1221: { const line    = a3821        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }             case       t1224: { const ellipse = g3822     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       x1227: { const ellipse = w3823     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case       q1236: { const poly    = w3824     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }             case          m1239: { const star    = l3825        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }             case    v1242: { const text    = m3826   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }             case         u1245: { const point   = y3827       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }             case   b1249: { const path    = y3669  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case w1287: { const path    = v3828(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case   y1264: { const _group  = b3829  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }             case         m1267: { const frame   = a3830       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }         }     }           return [         group,          i - w3768]; } 


class a2013 extends y2028 {     children;     position;     x;     y;     width;     height;     round;     clip;        constructor(nodeId, children, position, x, y, width, height, round, clip)     {         super(m1267, nodeId);          this.children = children;         this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.clip     = clip;          this.objects =                 children             && children.objects              ? children.objects.map(o => o.copy())              : [];     }        copy()     {         const copy = new a2013(             this.nodeId,             this.children.copy(),             this.position.copy(),             this.x       .copy(),             this.y       .copy(),             this.width   .copy(),             this.height  .copy(),             this.round   .copy(),             this.clip    .copy());          copy.z3358(this);          return copy;     }        equals(frame)     {         return frame             && this.children.equals(frame.children)             && this.position.equals(frame.position)             && this.x       .equals(frame.x       )             && this.y       .equals(frame.y       )             && this.width   .equals(frame.width   )             && this.height  .equals(frame.height  )             && this.round   .equals(frame.round   )             && this.clip    .equals(frame.clip    );     }        async eval(parse)     {         return this;     }        toString()     {         return       this.children.toString()              + ' ' + this.position.toString()              + ' ' + this.x       .toString()              + ' ' + this.y       .toString()              + ' ' + this.width   .toString()              + ' ' + this.height  .toString()              + ' ' + this.round   .toString()              + ' ' + this.clip    .toString()              + ' ' + super.toString();     }        x3704()     {         return 'frame';                                                                                                             }        y3705()     {         return       this.children.y3705()              + ' ' + this.position.y3705()              + ' ' + this.x       .y3705()              + ' ' + this.y       .y3705()              + ' ' + this.width   .y3705()              + ' ' + this.height  .y3705()              + ' ' + this.clip    .y3705()              + ' ' + this.round   .y3705();     }        t3632()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.children.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.clip    .isValid();     }            static NaN = new a2013(         '',         b2020  .NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN,         x2021.NaN); }    function a3830(str, i = -1) {     if (   i <  0 && str    == d964         || i >= 0 && str[i] == d964)         return [a2013.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const w3768 = i;      const children = i3481  (str, i); i += children[1];     const position = k2849(str[i]); i += position[1];     const x        = k2849(str[i]); i += x       [1];     const y        = k2849(str[i]); i += y       [1];     const width    = k2849(str[i]); i += width   [1];     const height   = k2849(str[i]); i += height  [1];     const round    = k2849(str[i]); i += round   [1];     const clip     = k2849(str[i]); i += clip    [1];      const frame = new a2013(         '',          children[0],         position[0],         x       [0],         y       [0],         width   [0],         height  [0],         round   [0],         clip    [0]);       i = x3709(str, i, frame);           return [frame, i - w3768]; } 


class z1866 extends f2043 {     count            = null;     iteration        = null;    v3679            = null;     loop             = null;      g3818 = [];      isTerminal       = false;      activeAfter      = false;      listAfter        = false;         constructor(nodeId, options)     {         super(s1064, nodeId, options);     }            reset()     {         super.reset();          this. count      = null;         this. iteration  = null;         this.v3679      = null;         this. loop       = null;          this.isTerminal  = false;         this.activeAfter = false;         this.listAfter   = false;          this.g3818 = [];     }        copy()     {         const copy = new z1866(this.nodeId, this.options);          copy.z3358(this);          if (this. value    ) copy. value     = this. value    .copy();         if (this. iteration) copy. iteration = this. iteration.copy();         if (this. count    ) copy. count     = this. count    .copy();         if (this.v3679    ) copy.v3679     = this.v3679    .copy();         if (this. loop     ) copy. loop      = this. loop     .copy();          copy.isTerminal  = this.isTerminal;         copy.activeAfter = this.activeAfter;         copy.listAfter   = this.listAfter;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let   count     = await evalNumberValue(this.count,     parse);         let   iteration = await evalNumberValue(this.iteration, parse);         let  v3679     = new x2021(1);           let iterations = [];          if (iteration.isValid())         {             if (iteration.type != l1143)                 iteration = new v2032(iteration.value.toString());              const _iterations = iteration.value.split(',');                          if (_iterations.length > 1)             {                 for (const iter of _iterations)                 {                     if (iter.includes('-'))                     {                         const iterParts = iter.split('-');                          if (iterParts.length == 2)                         {                             let start = iterParts[0];                             let end   = iterParts[1];                              if (   !isNaN(Number(start))                                 && !isNaN(Number(end  )))                             {                                 for (let i = start; i <= end; i++)                                     iterations.push(parseInt(i));                             }                         }                     }                     else                         iterations.push(parseInt(iter));                 }             }             else                 iterations.push(parseInt(iteration.value));         }           count =              count             ? new x2021(Math.floor(count.value))             : new x2021(0);           if (   this.loop              && this.loop.type != n1091)              g3356(this.loop, this);           this.value = new b2020();         this.value.objects = [];           if (   count             && count.value > 0)                                                             {             if (this.input)             {                 const z3179    = Date.now();                 let   p3817 = false;                   const nRepeats =                      this.options.enabled                      ? count.value                      : 0;                                   let repeat =                 {                     repeatId:         this.nodeId,                     currentIteration: 0,                     total:            nRepeats                 };                                       parse.repeats.push(repeat);                  if (parse.repeats.length == 1)                     parse.j3639 += nRepeats;                   if (   this.loop                     && this.loop.l3628)                     this.loop.l3628(parse, this.nodeId);                   if (this.loop)                 {                     parse.evalAccumulate = false;                     await this.loop.eval(parse);                      parse.evalAccumulate = true;                 }                   for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)                 {                     if (  !p3817                         && Date.now() - z3179 > 50)                     {                         y2076(this.nodeId);                         p3817 = true;                     }                       repeat.currentIteration = i;                       this.input.y4088(parse, this, false);                                           const input = await evalValue      (this.input, parse);                          v3679 = await evalNumberValue(this.v3679, parse);                       if (   input                         && nRepeats > 0                         && (  !v3679                              || v3679.value > 0))                     {                                                                           if (h957(input.type))                         {                             if (input.condensed === true)                                 this.value.items.push(input);                             else                             {                                 for (const item of input.items)                                     this.value.items.push(item);                             }                         }                         else                             this.value.items.push(input);                                   if (   this.options.active                             || this.options.a2997                             || this.options.beforeList)                         {                             this.g3818 = [];                                                       if (input.objects)                             {                                 for (let j = 0; j < input.objects.length; j++, o++)                                 {                                     const l111 = j3737(input.objects[j]);                                       this.g3818.push(l111.copy());                                       if (  !iteration.isValid()                                         || iterations.includes(i))                                     {                                         l111.nodeId      = this.nodeId;                                         l111.listId      = i;                                          l111.objectId   += y967 + this.nodeId + ':' + (o+1).toString();                                         l111.objectName += ' ' + (o+1).toString();                                          l111.m3819   = repeat.currentIteration;                                          if (this.value.objects)                                             this.value.objects.push(l111);                                     }                                 }                             }                         }                     }                       this.input.c4086(parse);                       if (   this.loop                         && this.loop.iterateCache)                         this.loop.iterateCache(parse, this);                                           if (parse.repeats.length == 1)                     {                         parse.m3638++;                          if (await l3861(parse.i2066))                         {                             q2078(this.nodeId);                             return this;                         }                     }                                           if (p3817)                         v2077(parse, this.nodeId, i / nRepeats);                 }                   if (   this.loop                     && this.loop.n3631)                     this.loop.n3631(parse, this.nodeId);                   if (this.startTimer > -1)                 {                     clearTimeout(this.startTimer);                     this.startTimer = -1;                 }                   q2078(this.nodeId);                   g952(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');                 parse.repeats.pop();             }             else if (this.input)                 await evalValue(this.input, parse);         }         else if (this.input)             await evalValue(this.input, parse);                   const type = this.outputListType();          this.e4100(parse,         [             ['type',      type     ],             ['count',     count    ],             ['iteration', iteration]         ]);           this.validate();          return this;     }        t3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this. count     && this. count    .isValid()             && this. iteration && this. iteration.isValid()             && (!this.v3679   || this.v3679    .isValid());     }        g4087(parse)     {         super.g4087(parse);          if (this. count    ) this. count    .g4087(parse);         if (this. iteration) this. iteration.g4087(parse);         if (this.v3679    ) this.v3679    .g4087(parse);         if (this. loop     ) this. loop     .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this. count    ) this. count    .y4088(parse, from, force);         if (this. iteration) this. iteration.y4088(parse, from, force);         if (this.v3679    ) this.v3679    .y4088(parse, from, force);         if (this. loop     ) this. loop     .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this. count    ) this. count    .c4086(parse);         if (this. iteration) this. iteration.c4086(parse);         if (this.v3679    ) this.v3679    .c4086(parse);         if (this. loop     ) this. loop     .c4086(parse);     } }    function g3356(loop, node) {     g952(            loop.type == v1086         || loop.type == j1066         || loop.type == w1104         || loop.type == y1105         || loop.type == q1103         || loop.type == f1106         || loop.type == d1107         || loop.type == l1108         || loop.type == u1069         || loop.type == PARAM,          'only volatile types can be repeated'); }


class x1875 extends f2043 {     from   = null;      i3820 = NULL;            constructor(nodeId, options)     {         super(g1063, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new x1875(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (     !parse.evalFeedback)             return this;                    const input = await evalValue(this.input, parse);                     this.e4100(parse,          [             ['type', this.outputListType()]         ]);           await this.i4099(parse, {input});                   this.validate();          return this;     }        async i4099(parse, options = {})     {         const repeat = parse.repeats.find(r => r.repeatId == this.i3820);           const feedback =                 repeat             && repeat.currentIteration > 0             && this.from;                   this.value = new b2020();          if (feedback)         {             for (const l111 of this.from.g3818)                 this.value.items.push(l111.t3632());              if (this.from.g3818)                 this.value.objects = this.from.g3818.map(o => o.copy());         }         else if (options.input               && options.input.isValid())         {             this.value.items.push(options.input);              if (options.input.objects)                 this.value.objects = options.input.objects.map(o => o.copy());         }           const iter =             repeat              ? NAME_SEPARATOR + repeat.currentIteration              : '';          for (const item of this.value.items)             item.nodeId = this.nodeId;          if (this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const l111 = this.value.objects[i];                  l111.nodeId   = this.nodeId;                 l111.objectId = this.nodeId + y967 + i + iter;             }         }           await super.i4099(parse);     }        t3632()     {         return this.value.copy();     }                                l3628(parse, nodeId)     {         super.l3628(parse, nodeId);          this.from = parse.w4242.find(n => n.nodeId == nodeId);     }        n3631(parse, nodeId)     {         super.n3631(parse, nodeId);          this.from = null;     } } 


class l1865 extends f2043 {     constructor(nodeId, options)     {         super(p1060, nodeId, options);     }            copy()     {         const copy = new l1865(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();         if (this.input) copy.input = this.input.copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).t3632()              : new c4216();           this.a4215();           this.e4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     } } 


class v1880 extends y2042 {     varValue = null;        constructor(nodeId, options, styleId)     {         super(x1061, nodeId, options);     }        reset()     {         super.reset();          this.varValue = null;     }        copy()     {         const copy = new t1886(this.nodeId, this.options);          if (this.varValue) copy.varValue = this.varValue.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value =              this.varValue             ? (await this.varValue.eval(parse)).t3632()             : new c4216();           this.e4100(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalVariable(options = {})     {         if (!this.options.enabled)             return;     }        isValid()     {         return this.varValue && this.varValue.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.varValue) this.varValue.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.varValue) this.varValue.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.varValue) this.varValue.c4086(parse);     } }


class d1881 extends y2042 {     input = null;        constructor(nodeId, options)     {         super(y1062, nodeId, options);     }        copy()     {         const copy = new e1863(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof r2049)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await evalListValue(this.input, parse);           this.s3095 = [];                                                                                                                                                                                                                                                  this.e4100(parse, [['', new c4216()]], true);                                        this.validate();          return this;     }                y4241(f2991)     {         return this.value             && this.value.items             && f2991 != 'value'             ? this.value.items.find(i => i.valueId == f2991)              : null;     }        t3632()     {         return this.value.copy();     }        isValid()     {         return this.input && this.input.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.input) this.input.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.input) this.input.c4086(parse);     } }


class u1853 extends f2043 {     d4211 = null;        constructor(nodeId, options)     {         super(z1065, nodeId, options);     }            reset()     {         super.reset();          this.d4211 = null;     }        copy()     {         const copy = new u1853(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();                   return copy;     }        async eval(parse)     {         if (!this.options.enabled)             this.d4211 = null;                      if (   this.isCached()             && this.d4211)             return this;           if (this.d4211)             this.value = this.d4211.copy();          else         {             this.value = await evalValue(this.input, parse);              if (   this.options.enabled                 && this.value)                 this.d4211 = this.value.copy();         }           this.a4215();           this.e4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        iterateCache(parse, from)     {         this.d4211 = null;          super.iterateCache(parse, from);     } } 


class u1861 extends f2043 {     frozen = false;      i3820 = NULL;        constructor(nodeId, options)     {         super(j1066, nodeId, options);     }            reset()     {         super.reset();          this.frozen = false;     }        copy()     {         const copy = new u1861(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const repeat = parse.repeats.find(r => r.repeatId == this.i3820);           if (      repeat                && repeat.currentIteration == 0             || !this.options.enabled)             this.frozen = false;           if (!this.frozen)         {             this.value =                  this.input                  ? (await this.input.eval(parse)).t3632()                 : new c4216();              this.frozen = true;              this.a4215();         }           this.e4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     } } 


class u1877 extends f2043 {     interval = null;    v3679    = null;     loop     = null;        constructor(nodeId, options)     {         super(v1067, nodeId, options);     }            reset()     {         super.reset();          this. interval = null;         this.v3679    = null;         this. loop     = null;     }        copy()     {         const copy = new u1877(this.nodeId, this.options);          copy.z3358(this);          if (this. interval) copy. interval = this. interval.copy();         if (this.v3679   ) copy.v3679    = this.v3679   .copy();         if (this. loop    ) copy. loop     = this. loop    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const  interval = await evalNumberValue(this. interval, parse);         const v3679    = await evalNumberValue(this.v3679,    parse);         const  loop     = await evalNumberValue(this. loop,     parse);                       if (this.loop.type != n1091) g3356(this.loop, this);          if (v3679.value == 0)             return this;           if (this.input)         {             this.input.y4088(parse, this, true);              const input = await evalValue(this.input, parse);              this.value = input ? input : new c4216();              if (this.loop.type != n1091)                 this.loop.c4086(parse);         }         else             this.value = new c4216();                       this.e4100(parse,         [             ['value',    this.value],             ['interval', interval  ]         ]);                   this.a4215();           this.validate();          return this;     }        t3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.interval && this.interval.isValid()             && this.v3679   && this.v3679  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this. interval) this. interval.g4087(parse);         if (this.v3679   ) this.v3679   .g4087(parse);         if (this. loop    ) this. loop    .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this. interval) this. interval.y4088(parse, from, force);         if (this.v3679   ) this.v3679   .y4088(parse, from, force);         if (this. loop    ) this. loop    .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this. interval) this. interval.c4086(parse);         if (this.v3679   ) this.v3679   .c4086(parse);         if (this. loop    ) this. loop    .c4086(parse);     } } 


class k1879 extends f2043 {     name = null;        constructor(nodeId, options)     {         super(f1068, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new k1879(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value =              this.input              ? (await this.input.eval(parse)).t3632()              : new c4216();                   const name = await evalTextValue(this.name, parse);           if (   this.options.enabled             && this.value.isValid())         {             this.value.valueId = name.value;         }           this.a4215();           this.e4100(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.name) this.name.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.name) this.name.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.name) this.name.c4086(parse);     }        n3631(parse, nodeId)     {         super.n3631(parse, nodeId);          if (this.name) this.name.n3631(parse, nodeId);     } } 


class GGetListValueNames extends f2043 {             constructor(nodeId, options)     {         super(r1352, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new GGetListValueNames(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);           this.counts = new b2020();                                                    if (   input                 && input.items)             {                 if (this.options.enabled)                 {                     this.value = new b2020();                     this.value.objects = [];                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(new v2032(input.items[i].valueId));                      if (input.objects)                     {                         for (let i = 0; i < input.objects.length; i++)                             this.value.objects.push(input.objects[i]);                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = b2020.NaN.copy();                                       this.a4215();           this.e4100(parse,          [             ['type',   this.outputListType()                   ],             ['length', new x2021(this.value.items.length)]         ]);                           if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GListValueNames extends k2044 {     constructor(nodeId, options)     {         super(d1353, nodeId, options);     }            copy()     {         const copy = new GListValueNames(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082 = await evalListValue(this.b4082, parse);         const o4083 = await evalListValue(this.o4083, parse);                   if (   this.options.enabled             && b4082             && o4083             && b4082.items             && o4083.items)         {             for (let i = 0; i < b4082.items.length && i < o4083.items.length; i++)                 b4082.items[i].valueId = o4083.items[i].value;              this.value = b4082;         }         else if (b4082)             this.value = b4082;            this.a4215();           this.e4100(parse,         [             ['type', this.outputListType()]         ]);           this.validate();          return this;     } } 


class GObjectName extends f2043 {     name    = null;           constructor(nodeId, options)     {         super(x1354, nodeId, options);     }            reset()     {         super.reset();          this.name    = null;            }        copy()     {         const copy = new GObjectName(this.nodeId, this.options);          copy.z3358(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.name   ) copy.name    = this.name   .copy();                 return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).t3632()              : new c4216();                   const name    = await evalTextValue  (this.name, parse);                          if (   this.options.enabled             && this.value.isValid()             && this.value.objects)         {             for (const l111 of this.value.objects)             {                 l111.nodeId     = this.nodeId;                 l111.objectName = name.value;                           }         }           this.a4215();           this.e4100(parse,         [             ['type',    this.outputType()],             ['name',    name             ]                    ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name    && this.name   .isValid()               }        g4087(parse)     {         super.g4087(parse);          if (this.name   ) this.name   .g4087(parse);           }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.name   ) this.name   .y4088(parse, from, force);           }        c4086(parse)     {         super.c4086(parse);          if (this.name   ) this.name   .c4086(parse);           }        n3631(parse, nodeId)     {         super.n3631(parse, nodeId);          if (this.name   ) this.name   .n3631(parse, nodeId);           } } 


class m1856 extends y2042 {     inputs = [];      value;        constructor(nodeId, options)     {         super(u1069, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new m1856(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new b2020();          this.value.objects = [];           for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);               if (   input                 && input.isValid()                 && this.options.enabled)             {                 if (h957(input.type))                 {                     if (input.condensed === true)                         this.value.items.push(input);                     else                     {                         for (const item of input.items)                             this.value.items.push(item);                     }                 }                 else                     this.value.items.push(input);             }               const inputObjects = this.a3626(input, i);                          for (const l111 of inputObjects)             {                 l111.objectId += y967 + i;                 l111.m3819 = i;             }              this.value.objects.push(...inputObjects);         }                     const bounds = getObjBounds(this.value.objects);          const singlePoint =                this.value.objects.length  == 1              && this.value.objects[0].type == l1246;          for (const l111 of this.value.objects)         {             const angle1 = l884(l111.sp0, l111.sp1);             const angle2 = l884(l111.sp0, l111.sp2);              l111.v3741(l111.sp0.x, l111.sp0.y);                          l111.sp1 = h895(l111.sp0, vector(angle1, 1));             l111.sp2 = h895(l111.sp0, vector(angle2, 1));              l111.resetSpace(bounds, singlePoint);         }                   const length = new x2021(this.value.items.length);         const type   = new v2032(r3478(this.value.items));           this.e4100(parse,         [             ['length', length],             ['type',   type  ]         ]);           if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        t3632()     {         return this.value.copy();     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));     }        l3628(parse, i3820)     {         this.inputs.forEach(i => i.l3628(parse, i3820));     }        s3629(parse, nodeId)     {         this.inputs.forEach(i => i.s3629(parse, nodeId));     }        c4086(parse)     {         this.inputs.forEach(i => i.c4086(parse));     }        iterateCache(parse, from)     {         for (const input of this.inputs)         {             if (   input.type == u1080                 || input.type == u1069                 || input.type == z1065)                 input.iterateCache(parse, from);         }     }        n3631(parse, nodeId)     {         this.inputs.forEach(i => i.n3631(parse, nodeId));     } }


class q1857 extends f2043 {             constructor(nodeId, options)     {         super(n1070, nodeId, options);     }            reset()     {         super.reset();               }        copy()     {         const copy = new q1857(this.nodeId, this.options);          copy.z3358(this);                    return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           this.value = new b2020();         this.value.condensed = true;          let length = 0;           const input = await evalListValue(this.input, parse);                                                    if (input)             {                 length = input.items.length;                                                       if (   h957(input.type)                     && this.options.enabled)                 {                     for (const item of input.items)                     {                         const copy = item.copy();                          this.value.items.push(copy);                                              }                 }                 else                 {                     const copy = input.copy();                      this.value.items.push(copy);                     this.value.objects.push(...copy.objects);                 }             }             else                 this.value = new b2020();                                       this.a4215();               this.e4100(parse,         [             ['length', new x2021(length)                              ],             ['type', new v2032(r3478(this.value.items))]         ]);                   this.validate();          return this;     } } 


class p1859 extends f2043 {     indices     = null;                  constructor(nodeId, options)     {         super(j1071, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;                   }        copy()     {         const copy = new p1859(this.nodeId, this.options);          copy.z3358(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value = new b2020();          let length = 0;                                                            if (   input                 && indices                 && input.items)             {                 length = input.items.length;                   if (this.options.enabled)                 {                     for (let i = 0; i < indices.items.length; i++)                     {                         const item = input.items[Math.round(indices.items[i].value)];                                                  this.value.items.push(item ? item.copy() : new c4216());                                                  if (   item                             && item.objects                             && this.value.objects)                              this.value.objects.push(...item.objects);                     }                 }             }             else                 this.value = b2020.NaN.copy();                               this.a4215();           this.e4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new x2021(this.value.items.length)],              ['indices', indices                                 ]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.indices) this.indices.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.indices) this.indices.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.indices) this.indices.c4086(parse);     } } 


class n1872 extends k2044 {     name = null;            constructor(nodeId, options)     {         super(f1072, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new n1872(this.nodeId, this.options);          copy.z3358(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082 = await evalValue    (this.b4082, parse);         const o4083 = await evalValue    (this.o4083, parse);         const name   = await evalTextValue(this.name,   parse);           if (   b4082             && name)         {             let nameValue = name.value.trim();               if (h957(b4082.type))             {                 this.value = new b2020();                  if (this.options.enabled)                 {                     for (let i = 0; i < b4082.items.length; i++)                     {                         const item = b4082.items[i];                          if (   o4083                             && name.value.trim() != '')                             item.customParams.push([nameValue, o4083]);                                                   if (   item                             && item[nameValue]                             && item[nameValue].objects                              && this.value.objects)                             this.value.objects.push(...item[nameValue].objects);                     }                 }                 else                     this.value = b4082;             }             else             {                 this.value = b4082;                  if (   o4083                     && nameValue != ''                     && this.options.enabled)                     this.value.customParams.push([nameValue, o4083]);             }         }         else         {             this.value = new c4216();         }           this.a4215();           this.e4100(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.name) this.name.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.name) this.name.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.name) this.name.c4086(parse);     } } 


class o1873 extends f2043 {     name = null;            constructor(nodeId, options)     {         super(t1073, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new o1873(this.nodeId, this.options);          copy.z3358(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue    (this.input, parse);         const name  = await evalTextValue(this.name,  parse);           if (   input             && name             && name.value.trim() != '')         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getGetParamValue(input.items[i], name));                 }                 else                     this.value = getGetParamValue(input, name);             }             else                 this.value = input.copy();         }         else         {             this.value = new c4216();         }           this.a4215();           const type = this.outputType();                  this.e4100(parse,         [             ['value', this.value],             ['type',  type      ],             ['name',  name      ]         ]);                   if (type.value == l1143 && parse.settings.n3732)         {             this.e4100(parse,             [                 ['preview', this.value]             ],             true);         }         else if (h957(type.value)   && parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.name) this.name.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.name) this.name.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.name) this.name.c4086(parse);     } }    function getGetParamValue(input, name) {     let nameValue = name.value.trim();       if (    input         && !input[nameValue])     {              if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();         else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();     }       let value = null;      if (   input         && input[nameValue])     {         value = input[nameValue];     }     else     {         const customIndex = input.customParams.findIndex(p => p[0] == nameValue);          value =             customIndex > -1             ? input.customParams[customIndex][1]             : new c4216();     }       if (   input         && input[nameValue]         && input[nameValue].objects          && this.value.objects)         value.objects.push(...input[nameValue].objects);       return value; }


class x1876 extends f2043 {     start       = null;     end         = null;                  constructor(nodeId, options)     {         super(b1074, nodeId, options);     }            reset()     {         super.reset();          this.start       = null;         this.end         = null;               }        copy()     {         const copy = new x1876(this.nodeId, this.options);          copy.z3358(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;                                                                this.value = new b2020();             this.value.objects = [];               if (   input                 && start                 && end)             {                 if (input.items)                 {                     length = input.items.length;                       const _end =                         end.isValid()                         ? end                         : new x2021(input.items.length);                       if (this.options.enabled)                     {                         const endValue =                              _end.value < 0                             ? length + _end.value                             : _end.value;                          if (start.value < endValue)                         {                             for (let i = start.value, j = 0; i < endValue; i++, j++)                             {                                 const item = input.items[i];                                                                  this.value.items.push(item ? item.copy() : new c4216());                                                                  if (   item                                     && this.value.objects                                     && item.objects)                                 {                                     item.objects.forEach(o => o.m3819 = j);                                     this.value.objects.push(...item.objects);                                 }                             }                         }                         else                             this.value = b2020.NaN.copy();                     }                     else                         this.value = input.copy();                 }                 else                     this.value = b2020.NaN.copy();             }                                   this.a4215();           this.e4100(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new x2021(this.value.items.length)       ],              ['fullLength', new x2021(input ? input.items.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.start) this.start.y4088(parse, from, force);         if (this.end  ) this.end  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.start) this.start.c4086(parse);         if (this.end  ) this.end  .c4086(parse);     } } 


class a1878 extends f2043 {     counts      = null;     indices     = null;                  constructor(nodeId, options)     {         super(k1075, nodeId, options);     }            reset()     {         super.reset();          this.counts  = null;         this.indices = null;                       }        copy()     {         const copy = new a1878(this.nodeId, this.options);          copy.z3358(this);          if (this.counts ) copy.counts  = this.counts .copy();         if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue(this.input, parse);                                                    this.counts  = new b2020();             this.indices = new b2020();                           if (input)             {                 if (this.options.enabled)                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item       = input.items[i];                         const foundIndex = this.value.items.findIndex(i => i.equals(item));                          if (foundIndex < 0)                         {                             this.value.items.push(item.copy());                              if (   this.value.objects                                 && item.objects)                                 this.value.objects.push(...item.objects);                              this.counts .items.push(new x2021(1));                             this.indices.items.push(new b2020([new x2021(i)]));                         }                         else                         {                             this.counts .items[foundIndex].value++;                             this.indices.items[foundIndex].items.push(new x2021(i));                         }                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = new b2020();                               this.a4215();           this.e4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new x2021(this.value.items.length)],             ['counts',  this.counts                             ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }                                                                                                                                        } 


class z1867 extends f2043 {     indices = null;            constructor(nodeId, options)     {         super(b1349, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;     }        copy()     {         const copy = new z1867(this.nodeId, this.options);          copy.z3358(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue(this.input,   parse);         const indices = await evalListValue(this.indices, parse);           this.value         = new b2020();         this.value.objects = [];           if (   input             && input.items)         {             if (   this.options.enabled                 && indices                 && input.items                 && indices.items                 && input.items.length == indices.items.length)             {                 this.value.items = new Array(input.items.length);                  for (let i = 0; i < input.items.length; i++)                     this.value.items[i] = input.items[indices.items[i].value];                                   for (let i = 0; i < this.value.items.length; i++)                 {                     const item = this.value.items[i];                      if (   item.objects                         && this.value.objects)                     {                         const objects = ordered.objects.filter(o => o.m3819 == m3819).map(o => o.copy());                         objects.forEach(o => o.m3819 = i);                          this.value.objects.push(...objects);                     }                 }             }             else                 this.value = input.copy();         }         else             this.value = new b2020();           this.a4215();           this.e4100(parse,         [             ['type',    this.outputListType()],             ['indices', indices              ]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.indices) this.indices.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.indices) this.indices.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.indices) this.indices.c4086(parse);     } }


class y1868 extends f2043 {     offset = null;            constructor(nodeId, options)     {         super(o1350, nodeId, options);     }            reset()     {         super.reset();          this.offset = null;     }        copy()     {         const copy = new y1868(this.nodeId, this.options);          copy.z3358(this);          if (this.offset) copy.offset = this.offset.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input  = await evalListValue  (this.input,  parse);         const offset = await evalNumberValue(this.offset, parse);           let length = 0;                       this.value = new b2020();         this.value.objects = [];           if (   input             && offset)         {             if (input.items)             {                 length = input.items.length;                  if (this.options.enabled)                 {                     let _offset = offset.value % input.items.length;                     while (_offset < 0) _offset += input.items.length;                      let j = 0;                     for (let i = _offset; i < input.items.length; i++, j++)                         this.addItem(input, i, j);                      for (let i = 0; i < _offset; i++, j++)                         this.addItem(input, i, j);                 }                 else                     this.value = input.copy();             }             else                 this.value = b2020.NaN.copy();         }           this.a4215();           this.e4100(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new x2021(this.value.items.length)       ],              ['offset',     offset                                         ]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        addItem(input, i, j)     {         const item = input.items[i];          this.value.items.push(item ? item.copy() : new c4216());                  if (   item             && this.value.objects             && input.objects)         {                          item.objects.forEach(o => o.m3819 = j);              this.value.objects.push(...item.objects);         }     }        isValid()     {         return super.isValid()             && this.offset && this.offset.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.offset) this.offset.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.offset) this.offset.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.offset) this.offset.c4086(parse);     } } 


class g1869 extends f2043 {     constructor(nodeId, options)     {         super(i1076, nodeId, options);     }            reset()     {         super.reset();     }        copy()     {         const copy = new g1869(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             if (this.options.enabled)             {                 this.value = new b2020();                 this.value.objects = [];                  for (let i = input.items.length-1; i >= 0; i--)                     this.value.items.push(input.items[i]);                  if (input.objects)                 {                     for (let i = input.objects.length-1; i >= 0; i--)                         this.value.objects.push(input.objects[i]);                 }             }             else                 this.value = input.copy();         }         else             this.value = b2020.NaN.copy();               this.a4215();           this.e4100(parse,          [             ['type',   this.outputListType()                   ],             ['length', new x2021(this.value.items.length)]         ]);                           if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class GBuckleList extends f2043 {     amount;        constructor(nodeId, options)     {         super(t1351, nodeId, options);     }            reset()     {         super.reset();          this.buckle = null;     }        copy()     {         const copy = new GBuckleList(this.nodeId, this.options);          copy.z3358(this);          if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const amount = await evalNumberValue(this.amount, parse);          amount.value = Math.round(amount.value);                           if (   input             && input.isValid())         {             const _amount = Math.min(amount.value + 1, Math.floor(input.items.length/2));              if (this.options.enabled)             {                 const temp1 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value),                     ...input.items.slice(0, _amount)                  .map(i => i.value).map(i => i - input.items[0].value + input.items.at(-1).value)                 ];                  const temp2 =                  [                     ...input.items.slice(input.items.length - _amount).map(i => i.value).map(i => i - input.items.at(-1).value + input.items[0].value),                     ...input.items.slice(0, _amount)                  .map(i => i.value)                 ];                  g952(                     temp1.length == temp2.length,                     'error building list edge blend');                                   const temp = [];                  for (let i = 0; i < _amount*2; i++)                     temp.push(new x2021(x1035(temp1[i], temp2[i], i/(_amount*2-1))));                   this.value = new b2020();                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[_amount + i]);                  for (let i = _amount; i < input.items.length - _amount; i++)                     this.value.items.push(input.items[i]);                  for (let i = 0; i < _amount; i++)                     this.value.items.push(temp[i]);             }             else                 this.value = input;         }         else             this.value = b2020.NaN.copy();               this.e4100(parse,          [             ['length', new x2021(this.value.items.length)],             ['amount', amount                                  ]         ]);                           if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class g1874 extends f2043 {     condition     = null;     reverse       = null;     indices       = null;      i4212 = null;                   constructor(nodeId, options)     {         super(o1077, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.reverse   = null;         this.indices   = null;     }        copy()     {         const copy = new g1874(this.nodeId, this.options);          copy.z3358(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.reverse  ) copy.reverse   = this.reverse  .copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalListValue  (this.input,   parse);         const reverse = await evalNumberValue(this.reverse, parse);           this.value         = new b2020();         this.value.objects = [];           let maxColumns = 0;          this.indices = new b2020();           if (   input             && reverse)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.o3767)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.o3767(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const d4213 = reverse.value > 0 ? -1 : 1;                         const t4214          = [...input.items];                           [ input       .items,                            this.indices.items ] = await asyncSort(                             parse,                              t4214,                              this.condition                              ? conditionNode                              : null,                                      this,                             this.condition,                              d4213);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, h957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const m3819 = t4214.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.m3819 == m3819).map(o => o.copy());                                 objects.forEach(o => o.m3819 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                 {                     this.value   = input;                     this.indices = new b2020(Array.from(Array(input.items.length).keys()).map(i => new x2021(i)));                 }             }             else             {                 this.value   = input;                 this.indices = new b2020(Array.from(Array(input.items.length).keys()).map(i => new x2021(i)));             }         }         else         {             this.value   = new b2020();             this.indices = new b2020();         }           this.a4215();           this.e4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new x2021(this.value.items.length)],             ['reverse', reverse                                 ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid())             && this.reverse && this.reverse.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.condition) this.condition.g4087(parse);         if (this.reverse  ) this.reverse  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.condition) this.condition.y4088(parse, from, force);         if (this.reverse  ) this.reverse  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.condition) this.condition.c4086(parse);         if (this.reverse  ) this.reverse  .c4086(parse);     } }    async function asyncSort(parse, t4214, conditionNode, node, condition, d4213) {     const j3568 = conditionNode ? conditionNode.input : null;       const sorted  = [];       for (let i = 0; i < t4214.length; i++)     {         const item = t4214[i];          const cond = await getSortCondition(parse, conditionNode, node, condition, item);         if (!cond) return [t4214, [...t4214.keys()]];                  const condValue = cond.t3632();                   if (   condValue.type != n1091             && condValue.type != l1143)              return [t4214, [...t4214.keys()]];          sorted.push({item, condition: condValue.value, index: i});     }       sorted.sort((a, b) =>     {         if (   typeof(a.condition) == 'number'             && typeof(b.condition) == 'number')         {             if (a.condition < b.condition) return -1*d4213;             if (a.condition > b.condition) return  1*d4213;         }         else if (typeof(a.condition) == 'string'               && typeof(b.condition) == 'string')         {             if (a.condition.localeCompare(b.condition) < 0) return -1*d4213;             if (a.condition.localeCompare(b.condition) > 0) return  1*d4213;         }          return 0;     });       if (conditionNode)         conditionNode.input = j3568;       return [ sorted.map(item => item.item),               sorted.map(item => new x2021(item.index)) ]; }    async function getSortCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      conditionNode.input = item.copy();     condition.y4088(parse, node, true);       return await condition.eval(parse); }


class x1860 extends f2043 {     condition = null;     indices   = null;                  constructor(nodeId, options)     {         super(z1085, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;         this.indices   = null;     }        copy()     {         const copy = new x1860(this.nodeId, this.options);          copy.z3358(this);          if (this.condition) copy.condition = this.condition.copy();         if (this.indices  ) copy.indices   = this.indices  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue(this.input, parse);           this.value         = new b2020();         this.value.objects = [];          let maxColumns = 0;                   this.indices = new b2020();           if (input)         {             if (this.options.enabled)             {                 if (  !this.condition                     || this.condition.o3767)                 {                     if (this.condition)                         await this.condition.eval(parse);                      const conditionNode =                          this.condition                         ? this.condition.o3767(parse)                         : null;                       if (  !this.condition                         || conditionNode)                     {                         const unfiltered = [...input.items];                           [input.items, this.indices.items] = await asyncFilter(                             parse,                              unfiltered,                              conditionNode,                             this,                             this.condition);                           input.items.forEach(i => maxColumns = Math.max(maxColumns, h957(i.type) ? i.items.length : 1));                                                   for (let i = 0; i < input.items.length; i++)                         {                             const row       = input   .items[i];                             const m3819 = unfiltered.indexOf(row);                              this.value.items.push(row.copy());                              if (   row.objects                                 && this.value.objects)                             {                                 const objects = input.objects.filter(o => o.m3819 == m3819).map(o => o.copy());                                 objects.forEach(o => o.m3819 = i);                                  this.value.objects.push(...objects);                             }                         }                     }                 }                 else                     this.value = await evalListValue(this.input, parse);             }             else                 this.value = input.copy();         }         else             this.value = new b2020();           this.a4215();           this.e4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new x2021(this.value.items.length)],             ['indices', this.indices                            ]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && (!this.condition || this.condition.isValid());     }        g4087(parse)     {         super.g4087(parse);          if (this.condition) this.condition.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.condition) this.condition.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.condition) this.condition.c4086(parse);     } }    async function asyncFilter(parse, array, conditionNode, node, condition) {     const j3568 = conditionNode ? conditionNode.input : null;      const filtered = [];     const indices  = [];      for (let i = 0; i < array.length; i++)     {         const item = array[i];          const cond = await getFilterCondition(parse, conditionNode, node, condition, item);         if (!cond) return array;                  const condValue = cond.t3632();                   if (   condValue.type == n1091             && condValue.value > 0)         {             filtered.push(item);             indices .push(new x2021(i));         }     }      if (conditionNode)         conditionNode.input = j3568;      return [filtered, indices]; }    async function getFilterCondition(parse, conditionNode, node, condition, item) {     if (!conditionNode)         return item;          conditionNode.reset();      const value = conditionNode.t3632();     if (!value) return item;      if (   value.type == item.type         || value.type == z1087)     {         conditionNode.input = item.copy();         condition.y4088(parse, node, true);      }      return await condition.eval(parse); }


class p1855 extends f2043 {     index       = null;                  constructor(nodeId, options)     {         super(t1078, nodeId, options);     }            reset()     {         super.reset();          this.index       = null;               }        copy()     {         const copy = new p1855(this.nodeId, this.options);          copy.z3358(this);          if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached())                          return this;           const input = await evalListValue  (this.input, parse);         const index = await evalNumberValue(this.index, parse);                   this.value = new b2020();          let maxColumns = 0;                                                    if (   input                 && index)             {                 if (isTable(input))                 {                     input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));                      if (index.value < maxColumns)                     {                         const valueIds = [];                          for (let i = 0; i < input.items.length; i++)                         {                             const row = input.items[i];                              if (index.value < row.items.length)                             {                                 const item = row.items[index.value].copy();                                  item.valueId = g1482(                                     item.valueId,                                      id => valueIds.includes(id),                                     item.valueId,                                     '',                                     1,                                     true);                                                                 this.value.items.push(item);                                  q949(valueIds, item.valueId);                                  if (   this.value.objects                                      && row.items[index.value].objects)                                     this.value.objects.push(...row.items[index.value].objects);                             }                         }                     }                 }                 else if (h957(input.type))                 {                     this.value = input.copy();                     maxColumns = 1;                 }             }                               this.a4215();          this.e4100(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new x2021(this.value.items.length)],             ['columns', new x2021(maxColumns, 0)          ],             ['index',   index                                   ]         ]);               if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.index) this.index.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.index) this.index.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.index) this.index.c4086(parse);     } }    function isTable(value) {     if (!h957(value.type))         return false;      for (const item of value.items)     {         if (!h957(item.type))             return false;     }      return true; }


class p1854 extends f2043 {     column;     row;            constructor(nodeId, options)     {         super(b1079, nodeId, options);     }            reset()     {         super.reset();          this.column = null;         this.row    = null;     }        copy()     {         const copy = new p1854(this.nodeId, this.options);          copy.z3358(this);          if (this.column) copy.column = this.column.copy();         if (this.row   ) copy.row    = this.row   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalListValue  (this.input,  parse);         const column = await evalNumberValue(this.column, parse);         const row    = await evalNumberValue(this.row,    parse);           let columns = 0;         let rows    = 0;          if (   input             && column             && row)         {             if (isTable(input))             {                 rows = input.items.length;                  input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));                  if (row.value < rows)                 {                     const _row = input.items[row.value];                      if (column.value < columns)                         this.value = _row.items[column.value].copy();                     else                         this.value = new c4216();                 }                 else                     this.value = new c4216();             }             else                 this.value = new c4216();         }         else             this.value = new c4216();           this.e4100(parse,         [                          ['type',    this.outputType()          ],             ['columns', new x2021(columns, 0)],             ['rows',    new x2021(rows   , 0)]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.column && this.column.isValid()             && this.row    && this.row   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.column) this.column.g4087(parse);         if (this.row   ) this.row   .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.column) this.column.y4088(parse, from, force);         if (this.row   ) this.row   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.column) this.column.c4086(parse);         if (this.row   ) this.row   .c4086(parse);     } }


class e1863 extends f2043 {     d4211 = null;        constructor(nodeId, options)     {         super(u1080, nodeId, options);     }        reset()     {         super.reset();          this.d4211 = null;     }        copy()     {         const copy = new e1863(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof r2049)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        y4241(f2991)     {         let param =                this.value             && this.value.items             && f2991 != 'value'             ? this.value.items.find(i => i.valueId == f2991)             : null;          if (!param)             param = this[f2991];          return param;     }        async eval(parse)     {         if (   this.isCached()             && this.d4211)             return this;           const input = await evalListValue(this.input, parse);            if (this.d4211)            this.value = this.d4211.copy();          else         {             this.value = input ?? new c4216();             this.d4211 = this.value.copy();         }           this.s3095 = [];           if (    this.value.isValid()             &&  this.value.items             && !isEmpty(this.value.items))         {             for (let i = 0; i < this.value.items.length; i++)             {                 const item = this.value.items[i];                                  let valueId =                      item.valueId.trim() != ''                     ? item.valueId                     : i.toString();                  valueId = g1482(                     valueId,                     id => this.value.items.find(i =>                            i != item                          && i.valueId == id));                  Object.assign(this, {[valueId]: item});                 this.e4100(parse, [[valueId, item]], true);                  item.sortId = i;             }              this.s3095.sort((a, b) => a.sortId - b.sortId);               this.e4100(parse, [['-type-', this.outputType()]], true);         }         else             this.e4100(parse, [['-type-', new v2032(q1056)]], true);           this.a4215();           this.validate();          return this;     }                t3632()     {         return this.value.copy();     }        iterateCache(parse, from)     {         this.d4211 = null;     } }


class n1870 extends y2042 {     inputs = [];      index = null;            constructor(nodeId, options)     {         super(w1083, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.index = null;     }           copy()     {         const copy = new n1870(this.nodeId, this.options);          copy.z3358(this);                  copy.inputs = this.inputs.map(i => i.copy());          if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;          let index  = await evalNumberValue(this.index, parse);         let length = 0;           const inputs = [];          for (let i = 0; i < this.inputs.length; i++)             inputs.push(await evalValue(this.inputs[i], parse));           if (inputs.length > 0)         {             length = inputs.length;               index =                     index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length                 ? new x2021(Math.round(index.value))                 : new x2021(0);                           if (   index.isValid()                 && index.value >= -inputs.length                 && index.value <   inputs.length)             {                 this.value = inputs.at(index.value);                                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const l111 = this.value.objects[i];                          l111.nodeId = this.nodeId;                         l111.listId = -1;                          l111.objectId = this.nodeId;                                                  if (l111.objectId != NULL)                              l111.objectId += '/';                          l111.objectId += index.value.toString();                          if (this.value.objects.length > 1)                         {                             l111.objectId += '/';                             l111.objectId += i.toString();                         }                     }                 }             }             else             {                 this.value = new c4216();             }         }         else         {             this.value = new c4216();         }                   const type = this.outputType();          this.e4100(parse,         [             ['value',      type == l1168                          || type == y1178                          ? this.value                          : new c4216()      ],             ['type',    type                   ],             ['length',  new x2021(length)],             ['index',   index                  ]         ]);           if (type.value == l1143 && parse.settings.n3732)         {             this.e4100(parse,             [                 ['preview', this.value]             ],             true);         }         else if (h957(type.value) && parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             &&  this.index && this.index.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.index) this.index.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.index) this.index.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.index) this.index.c4086(parse);     } }


class v1871 extends f2043 {     index = null;        constructor(nodeId, options)     {         super(w1360, nodeId, options);     }        reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new v1871(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();         if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const input = await evalListValue  (this.input, parse);         let   index = await evalNumberValue(this.index, parse);                  let  length = 0;                                    if (   input             && input.isValid()             && h957(input.type)             && input.items             && input.items.length > 0)         {             length = input.items.length;               index =                     index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length                 ? new x2021(Math.round(index.value))                 : new x2021(0);                           if (   index.isValid()                 && index.value >= -input.items.length                 && index.value <   input.items.length)             {                 this.value = input.items.at(index.value);                                  if (   input.objects                     && input.objects.at(index.value))                     this.value.objects = [input.objects.at(index.value)];                   if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const l111 = this.value.objects[i];                          l111.nodeId = this.nodeId;                         l111.listId = -1;                          l111.objectId = this.nodeId;                                                  if (l111.objectId != NULL)                             l111.objectId += '/';                          l111.objectId += index.value.toString();                     }                 }             }             else             {                 this.value = new c4216();             }         }         else          {             this.value = new c4216();         }                     const type = this.outputType();          this.e4100(parse,         [             ['value',      type == l1168                          || type == y1178                          ? this.value                          : new c4216()],             ['type',    type                   ],             ['length',  new x2021(length)],             ['index',   index                  ]         ]);           if (type.value == l1143 && parse.settings.n3732)         {             this.e4100(parse,             [                 ['preview', this.value]             ],             true);         }         else if (h957(type.value) && parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.index) this.index.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.index) this.index.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.index) this.index.c4086(parse);     } }


class g1864 extends f2043 {     start = null;        constructor(nodeId, options)     {         super(k1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new g1864(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalListValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count = input.items.length;             this.value = new x2021(count - (start.value == 0 ? 1 : 0));         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.start) this.start.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.start) this.start.c4086(parse);     }     }


class GObjectCount extends f2043 {     start = null;        constructor(nodeId, options)     {         super(k1081, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new g1864(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const start = await evalNumberValue(this.start, parse);                   if (input)         {             const count =                  input.objects                 ? input.objects.length                 : 0;              this.value = new x2021(count - (start.value == 0 ? 1 : 0));         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.start) this.start.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.start) this.start.c4086(parse);     }     }


class l1858 extends k2044 {     first;     last;     all;        constructor(nodeId, options)     {         super(o1082, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new l1858(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082 = await evalListValue(this.b4082, parse);         const o4083 = await evalValue    (this.o4083, parse);               if (   b4082 && b4082.isValid()              && o4083 && o4083.isValid())         {             const indices = [];                           if (   o4083                 && o4083.isValid())             {                 for (let i = 0; i < b4082.items.length; i++)                 {                     if (b4082.items[i].equals(o4083))                         indices.push(i);                 }                     this.value = new x2021(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new x2021(indices.at( 0)) : x2021.NaN.copy();                 this.last  = indices.length > 0 ? new x2021(indices.at(-1)) : x2021.NaN.copy();                  this.all   = new b2020();                  for (const index of indices)                     this.all.items.push(new x2021(index));             }             else             {                 this.value = new x2021(1);                  this.first = x2021.NaN.copy();                 this.last  = x2021.NaN.copy();                 this.all   =   b2020.NaN.copy();             }         }         else                           {             this.value = x2021.NaN.copy();             this.first = x2021.NaN.copy();             this.last  = x2021.NaN.copy();             this.all   =   b2020.NaN.copy();         }               this.e4100(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class r1862 extends y2042 {     b4082    = null;     o4083    = null;      condition = null;        constructor(nodeId, options)     {         super(r1084, nodeId, options);     }            reset()     {         super.reset();          this.b4082    = null;         this.o4083    = null;          this.condition = null;     }        copy()     {         const copy = new r1862(this.nodeId, this.options);          copy.z3358(this);          if (this.b4082   ) copy.b4082    = this.b4082   .copy();         if (this.o4083   ) copy.o4083    = this.o4083   .copy();          if (this.condition) copy.condition = this.condition.copy();          if (this.value    ) copy.value     = this.value    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.b4082 || this.b4082.isCached())             && (!this.o4083 || this.o4083.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const b4082 = await evalValue(this.b4082, parse);         const o4083 = await evalValue(this.o4083, parse);                  const cond   = await evalNumberValue(this.condition, parse);             if (   b4082                && o4083) this.value = cond.value != 0 ? b4082 : o4083;         else if (b4082) this.value = cond.value != 0 ? b4082 : new c4216();         else if (o4083) this.value = cond.value == 0 ? o4083 : new c4216();         else             this.value = new c4216();           this.a4215();           this.e4100(parse,         [             ['type',      this.outputType()],             ['condition', cond             ]         ]);                           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()               : null;     }        isValid()     {         return this.b4082    && this.b4082   .isValid()             && this.o4083    && this.o4083   .isValid()             && this.condition && this.condition.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.b4082   ) this.b4082   .g4087(parse);         if (this.o4083   ) this.o4083   .g4087(parse);         if (this.condition) this.condition.g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.b4082   ) this.b4082   .y4088(parse, from, force);         if (this.o4083   ) this.o4083   .y4088(parse, from, force);         if (this.condition) this.condition.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.b4082   ) this.b4082   .c4086(parse);         if (this.o4083   ) this.o4083   .c4086(parse);         if (this.condition) this.condition.c4086(parse);     }     } 


class u1898 extends y2042 {     inputs = [];        reset()     {         super.reset();          this.inputs = [];     }        o3767()     {         const conditionNodes = [];          for (const input of this.inputs)         {             const conditionNode = input.o3767();             if (conditionNode) conditionNodes.push(conditionNode);                     }          console.assert(conditionNodes.length < 2, 'Error: sort order requires not more than one order node');          return conditionNodes.length == 1              ? conditionNodes[0]              : null;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        isValid()     {         return  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid());     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));     } } 


class p1935 extends f2043 {     constructor(nodeId, options)     {         super(x1092, nodeId, options);     }        copy()     {         const copy = new p1935(this.nodeId, this.options);                  copy.z3358(this);          copy.value = this.value;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)             this.value = input;         else if (this.value)             await this.value.eval(parse);         else             this.value = x2021.NaN.copy();           this.e4100(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input               || this.input.isValid();     } }


class GSetPrecision extends f2043 {     decimals;        constructor(nodeId, options)     {         super(v1355, nodeId, options);     }            reset()     {         super.reset();          this.decimals = null;     }        copy()     {         const copy = new GSetPrecision(this.nodeId, this.options);          copy.z3358(this);          if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021(0);                   const input    = await evalNumberValue(this.input,    parse);         const decimals = await evalNumberValue(this.decimals, parse);           if (input)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == n1091                             ? getSetPrecisionValue(item, decimals)                             : x2021.NaN.copy());                        }                 }                 else                     this.value = getSetPrecisionValue(input, decimals);             }             else                 this.value = input;         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type',     this.outputType()],             ['value',    this.value       ],             ['decimals', decimals         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.decimals && this.decimals.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.decimals) this.decimals.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.decimals) this.decimals.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.decimals) this.decimals.c4086(parse);     } }    function getSetPrecisionValue(input, decimals) {     g952(          input == n1091,          'input must be NUMBER_VALUE');      return new x2021(input.value, decimals.value); }


class b1942 extends f2043 {     constructor(nodeId, options)     {         super(t1093, nodeId, options);     }            copy()     {         const copy = new b1942(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getSignValue(item)                         : x2021.NaN.copy());                    }             }             else                 this.value = getSignValue(input); }         else             this.value = x2021.NaN.copy();           this.e4100(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getSignValue(input) {     g952(          input.type == n1091,          'input.type must be NUMBER_VALUE');      return new x2021(Math.sign(input.value)); }


class k1923 extends f2043 {     constructor(nodeId, options)     {         super(q1094, nodeId, options);     }            copy()     {         const copy = new k1923(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getAbsoluteValue(item, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getAbsoluteValue(input, this.options.enabled);         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getAbsoluteValue(input, enabled) {     g952(          input.type == n1091,          'input.type must be NUMBER_VALUE');      return enabled         ? new x2021(Math.abs(input.value), input.decimals)         : input; }


class GNegative extends f2043 {     constructor(nodeId, options)     {         super(p1356, nodeId, options);     }            copy()     {         const copy = new GNegative(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);                       if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getNegativeValue(item, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getNegativeValue(input, this.options.enabled);         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,          [             ['type', this.outputType()]         ]);           this.validate();          return this;     } }    function getNegativeValue(input, enabled) {     g952(          input == n1091,          'input must be NUMBER_VALUE');      return new x2021(         (enabled ? -1 : 1) * input.value,         input.decimals); }


class e1940 extends f2043 {     type;     decimals;        constructor(nodeId, options)     {         super(f1095, nodeId, options);     }            reset()     {         super.reset();          this.type     = null;         this.decimals = null;     }        copy()     {         const copy = new e1940(this.nodeId, this.options);          copy.z3358(this);          if (this.type    ) copy.type     = this.type    .copy();         if (this.decimals) copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021(0);                   const input = await evalNumberValue(this.input,    parse);         const type  = await evalNumberValue(this.type,     parse);         const dec   = await evalNumberValue(this.decimals, parse);           if (   input             && type             && dec)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getRoundValue(item, type, dec, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getRoundValue(input, type, dec, this.options.enabled); }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['_type',    this.outputType()],             ['type',     type             ],             ['decimals', dec              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type     && this.type    .isValid()             && this.decimals && this.decimals.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.type    ) this.type    .g4087(parse);         if (this.decimals) this.decimals.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.type    ) this.type    .y4088(parse, from, force);         if (this.decimals) this.decimals.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.type    ) this.type    .c4086(parse);         if (this.decimals) this.decimals.c4086(parse);     } }    function getRoundValue(input, type, dec, enabled) {     g952(         input.type == n1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;      switch (type.value)     {         case 0: return new x2021(i1015(input.value, dec.value), dec.value);         case 1: return new x2021(c1016(input.value, dec.value), dec.value);         case 2: return new x2021( r1017(input.value, dec.value), dec.value);     } }


class GQuantize extends f2043 {     type;     base;     step;     amount;        constructor(nodeId, options)     {         super(z1357, nodeId, options);     }            reset()     {         super.reset();          this.type   = null;         this.base   = null;         this.step   = null;         this.amount = null;     }        copy()     {         const copy = new GQuantize(this.nodeId, this.options);          copy.z3358(this);          if (this.type  ) copy.type   = this.type  .copy();         if (this.base  ) copy.base   = this.base  .copy();         if (this.step  ) copy.step   = this.step  .copy();         if (this.amount) copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021(0);                   const input  = await evalNumberValue(this.input,  parse);         const type   = await evalNumberValue(this.type,   parse);         const base   = await evalNumberValue(this.base,   parse);         const step   = await evalNumberValue(this.step,   parse);         const amount = await evalNumberValue(this.amount, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getQuantizeValue(item, type, base, step, amount, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getQuantizeValue(input, type, base, step, amount, this.options.enabled); }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['_type',  this.outputType()],             ['type',   type             ],             ['base',   base             ],             ['step',   step             ],             ['amount', amount           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type   && this.type  .isValid()             && this.base   && this.base  .isValid()             && this.step   && this.step  .isValid()             && this.amount && this.amount.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.type  ) this.type  .g4087(parse);         if (this.base  ) this.base  .g4087(parse);         if (this.step  ) this.step  .g4087(parse);         if (this.amount) this.amount.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.type  ) this.type  .y4088(parse, from, force);         if (this.base  ) this.base  .y4088(parse, from, force);         if (this.step  ) this.step  .y4088(parse, from, force);         if (this.amount) this.amount.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.type  ) this.type  .c4086(parse);         if (this.base  ) this.base  .c4086(parse);         if (this.step  ) this.step  .c4086(parse);         if (this.amount) this.amount.c4086(parse);     } }    function getQuantizeValue(input, type, base, step, amount, enabled) {     g952(          input.type == n1091,          'input.type must be NUMBER_VALUE');           if (!enabled)         return input;       let qval;      switch (type.value)     {         case 0: qval = base.value + step.value * Math.floor((input.value - base.value) / step.value); break;         case 1: qval = base.value + step.value * Math.round((input.value - base.value) / step.value); break;         case 2: qval = base.value + step.value * Math. ceil((input.value - base.value) / step.value); break;     }      return new x2021(         input.value + (qval - input.value) * amount.value/100,         Math.max(base.decimals, step.decimals)); }


class e1943 extends f2043 {     operand;     operation;        constructor(nodeId, options)     {         super(s1096, nodeId, options);     }            reset()     {         super.reset();          this.operand   = null;         this.operation = null;     }        copy()     {         const copy = new e1940(this.nodeId, this.options);          copy.z3358(this);          if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021(0);                   const input   = await evalNumberValue(this.input,     parse);         const operand = await evalNumberValue(this.operand,   parse);         const op      = await evalNumberValue(this.operation, parse);           if (input)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == n1091                             ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)                             : x2021.NaN.copy());                        }                 }                 else                 {                     this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [                          ['type',      this.outputType()],             ['operand',   operand          ],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operand   && this.operation.isValid()             && this.operation && this.operand  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operand  ) this.operand  .g4087(parse);         if (this.operation) this.operation.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.operand  ) this.operand  .y4088(parse, from, force);         if (this.operation) this.operation.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.operand  ) this.operand  .c4086(parse);         if (this.operation) this.operation.c4086(parse);     } }    function getSimpleMinMaxValue(input, operand, op, enabled) {     g952(         input.type == n1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);          return new x2021(op.value == 0             ? Math.min(input.value, operand.k3702())             : Math.max(input.value, operand.k3702()));     }     else         return input; }


class a1932 extends u1898 {     operation;        constructor(nodeId, options)     {         super(c1097, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new a1932(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.f3728();           if (this.options.enabled)             op.value = Math.min(Math.max(0, op.value), k1311.length-1);                   this.value = await evalMinMaxInputs(this.inputs, op.value, parse);                   this.e4100(parse,         [             ['operation', op        ]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.operation) this.operation.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.operation) this.operation.c4086(parse);     } }    async function evalMinMaxInputs(inputs, op, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       let value = new x2021(0);       const s3689 = await evalNumberValue(inputs[0], parse);       if (   inputs.length == 1         && s3689.type == n1091)     {         value = new x2021(-s3689.value);     }     else if (h957(s3689.type)             && !isEmpty(s3689.items))     {         value = s3689.items[0].copy();                  for (let i = 1; i < s3689.items.length; i++)         {             const item = s3689.items[i];              if (item.type == n1091)             {                 value = new x2021(                      op == 0                     ? Math.min(value.value, item.value)                     : Math.max(value.value, item.value));             }                             }     }     else     {         if (s3689.type != n1091)             return x2021.NaN.copy();          value = s3689;     }       for (let i = 1; i < inputs.length; i++)     {         const val = await evalNumberValue(inputs[i], parse);           if (h957(val.type))         {             for (const item of val.items)             {                 if (item.type == n1091)                 {                     value = new x2021(                         op == 0                         ? Math.min(value.value, item.value)                         : Math.max(value.value, item.value));                                       }                                 }         }         else         {             g952(                 val.type == n1091,                  'val.type must be NUMBER_VALUE');                              value = new x2021(                 op == 0                 ? Math.min(value.value, val.value)                 : Math.max(value.value, val.value));                       }     }       return value; }


class t1931 extends f2043 {     min = null;     max = null;            constructor(nodeId, options)     {         super(k1098, nodeId, options);     }            reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new t1931(this.nodeId, this.options);          copy.z3358(this);          if (this.min) copy.min = this.min.copy();         if (this.max) copy.max = this.max.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getLimitsValue(item, min, max, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getLimitsValue(input, min, max, this.options.enabled);         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type', this.outputType()],             ['min',   min             ],             ['max',   max             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min && this.min.isValid()             && this.max && this.max.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);         if (this.min  ) this.min  .g4087(parse);         if (this.max  ) this.max  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.input) this.input.y4088(parse, from, force);         if (this.min  ) this.min  .y4088(parse, from, force);         if (this.max  ) this.max  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.input) this.input.c4086(parse);         if (this.min  ) this.min  .c4086(parse);         if (this.max  ) this.max  .c4086(parse);     } }    function getLimitsValue(input, min, max, enabled) {     g952(          input.type == n1091,          'input.type must be NUMBER_VALUE');      if (!enabled)         return input;      return new x2021(         Math.min(Math.max(             min.value,             input.value),             max.value),         input.decimals); }


class n1936 extends f2043 {     min   = null;     max   = null;     power = null;            constructor(nodeId, options)     {         super(j1099, nodeId, options);     }            reset()     {         super.reset();          this.min   = null;         this.max   = null;         this.power = null;     }        copy()     {         const copy = new n1936(this.nodeId, this.options);          copy.z3358(this);          if (this.min  ) copy.min   = this.min  .copy();         if (this.max  ) copy.max   = this.max  .copy();         if (this.power) copy.power = this.power.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min   || this.min  .isCached())             && (!this.max   || this.max  .isCached())             && (!this.power || this.power.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalNumberValue(this.input, parse);         const min   = await evalNumberValue(this.min,   parse);         const max   = await evalNumberValue(this.max,   parse);         const power = await evalNumberValue(this.power, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getNumberCurveValue(item, min, max, power, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getNumberCurveValue(input, min, max, power, this.options.enabled);         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type',  this.outputType()],             ['min',   min              ],             ['max',   max              ],             ['power', power            ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min   && this.min  .isValid()             && this.max   && this.max  .isValid()             && this.power && this.power.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.min  ) this.min  .g4087(parse);         if (this.max  ) this.max  .g4087(parse);         if (this.power) this.power.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.min  ) this.min  .y4088(parse, from, force);         if (this.max  ) this.max  .y4088(parse, from, force);         if (this.power) this.power.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.min  ) this.min  .c4086(parse);         if (this.max  ) this.max  .c4086(parse);         if (this.power) this.power.c4086(parse);     } }    function getNumberCurveValue(input, min, max, power, enabled) {     g952(         input.type == n1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = Math.pow(f, power.value);     f = min.value + f * (max.value - min.value);          return new x2021(f); }


class GNumberMap extends f2043 {     from = null;     to   = null;            constructor(nodeId, options)     {         super(e1358, nodeId, options);     }            reset()     {         super.reset();          this.from = null;         this.to   = null;     }        copy()     {         const copy = new GNumberMap(this.nodeId, this.options);          copy.z3358(this);          if (from) copy.from = this.from.copy();         if (to  ) copy.to   = this.to  .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.from  || this.from.isCached())             && (!this.to    || this.to  .isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue    (this.input, parse);         const from  = await evalListValue(this.from,  parse);         const to    = await evalListValue(this.to,    parse);           if (   input              && input.isValid())         {             if (this.options.enabled)             {                 if (   from && from.isValid() && from.items.length > 0                     && to   && to  .isValid() && to  .items.length > 0)                 {                     if (h957(input.type))                     {                         this.value = new b2020();                                  for (let i = 0; i < input.items.length; i++)                         {                             const item = input.items[i];                                      this.value.items.push(                                 item.type == n1091                                 ? getNumberMapValue(item, from, to)                                 : x2021.NaN.copy());                            }                     }                     else                         this.value = getNumberMapValue(input, from, to);                 }                 else                     this.value = x2021.NaN.copy();             }             else                 this.value = input;         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type', this.outputType()],             ['from', from             ],             ['to',   to               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid()             && this.to   && this.to  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from) this.from.g4087(parse);         if (this.to  ) this.to  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.from) this.from.y4088(parse, from, force);         if (this.to  ) this.to  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.from) this.from.c4086(parse);         if (this.to  ) this.to  .c4086(parse);     } }    function getNumberMapValue(input, from, to) {     g952(         input.type == n1091,         'input.type must be NUMBER_VALUE');       const maxDec = Math.max(         from.items.reduce((max, val) => Math.max(max, val.decimals), 0),         to  .items.reduce((max, val) => Math.max(max, val.decimals), 0));       if (from.items.length == 1)         return input;             const nFromSegments = Math.floor(from.items.length-1);     let   fromIndex     = 0;      while (fromIndex < nFromSegments-1)     {         if (   input.value >= from.items[fromIndex  ]             && input.value <  from.items[fromIndex+1])             break;          fromIndex++;     }               const fromLocal =              (input.value - from.items[fromIndex].value)          / (from.items[fromIndex+1].value - from.items[fromIndex].value);      const f = fromIndex/nFromSegments + fromLocal * ((fromIndex+1)/nFromSegments - fromIndex/nFromSegments);                 const nToSegments = Math.floor(to.items.length-1);     const toIndex     = Math.min(Math.max(0, Math.floor((to.items.length-1) * f)), nToSegments-1);       if (to.items.length == 1)         return to.items[0];      else if (to.items.length > 0             && toIndex < to.items.length-1)     {         const toLocal =              nToSegments > 1             ? (f - toIndex/nToSegments) * nToSegments             : f;           const s3689 = to.items[toIndex  ];         const val1 = to.items[toIndex+1];          return new x2021(             x1035(s3689.value, val1.value, toLocal),             maxDec);     } }


class GNumberBias extends f2043 {     min    = null;     max    = null;     bias   = null;     spread = null;            constructor(nodeId, options)     {         super(k1359, nodeId, options);     }            reset()     {         super.reset();          this.min    = null;         this.max    = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new GNumberBias(this.nodeId, this.options);          copy.z3358(this);          if (this.min   ) copy.min    = this.min   .copy();         if (this.max   ) copy.max    = this.max   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min    || this.min   .isCached())             && (!this.max    || this.max   .isCached())             && (!this.bias   || this.bias  .isCached())             && (!this.spread || this.spread.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const input  = await evalNumberValue(this.input,  parse);         const min    = await evalNumberValue(this.min,    parse);         const max    = await evalNumberValue(this.max,    parse);         const bias   = await evalNumberValue(this.bias,   parse);         const spread = await evalNumberValue(this.spread, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getNumberBiasValue(item, min, max, bias, spread, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getNumberBiasValue(input, min, max, bias, spread, this.options.enabled);         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type',   this.outputType()],             ['min',    min              ],             ['max',    max              ],             ['bias',   bias             ],             ['spread', spread           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.min   ) this.min   .g4087(parse);         if (this.max   ) this.max   .g4087(parse);         if (this.bias  ) this.bias  .g4087(parse);         if (this.spread) this.spread.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.min   ) this.min   .y4088(parse, from, force);         if (this.max   ) this.max   .y4088(parse, from, force);         if (this.bias  ) this.bias  .y4088(parse, from, force);         if (this.spread) this.spread.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.min   ) this.min   .c4086(parse);         if (this.max   ) this.max   .c4086(parse);         if (this.bias  ) this.bias  .c4086(parse);         if (this.spread) this.spread.c4086(parse);     } }    function b3734(f, bias, spread) {     const b = bias   / 50;     const s = spread / 50;       f =          b >= 0         ? 1 - Math.pow(1-f, 1+b)         :     Math.pow(  f, 1-b);            if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;     else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;     else if (s < 0)              f = s1037(0, (1-s)/3, (2+s)/3, 1, f);       return f; }    function getNumberBiasValue(input, min, max, bias, spread, enabled) {     g952(         input.type == n1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       let f = (input.value - min.value) / (max.value - min.value);      f = b3734(f, bias.value, spread.value);     f = min.value + f * (max.value - min.value);      return new x2021(f); }


class q1933 extends f2043 {     _value = null;        constructor(nodeId, options)     {         super(s1100, nodeId, options);     }            reset()     {         super.reset();          this._value = null;     }        copy()     {         const copy = new q1933(this.nodeId, this.options);          copy.z3358(this);          if (this._value) copy._value = this._value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalNumberValue(this. input, parse);         const _value = await evalNumberValue(this._value, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getNaNisNumberValue(item, _value, this.options.enabled)                         : v2032.NaN.copy());                    }             }             else             {                 this.value = getNaNisNumberValue(input, _value, this.options.enabled);             }         }          else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type',   this.outputType()]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.value && this.value.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.value) this.value.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.value) this.value.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.value) this.value.c4086(parse);     } }    function getNaNisNumberValue(input, value, enabled) {     if (    enabled         && !input.isValid())         return value;     else         return input; }


class r1926 extends y2042 {     constant;        constructor(nodeId, options)     {         super(c1101, nodeId, options);     }            reset()     {         super.reset();          this.constant = null;     }        copy()     {         const copy = new r1926(this.nodeId, this.options);          copy.z3358(this);          if (this.constant) copy.constant = this.constant.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                                  const constant = await evalNumberValue(this.constant, parse);                   let value;          switch (Math.min(Math.max(0, constant.k3702()), 5))         {             case 0: value = 1.4142135623; break;              case 1: value = 2.7182818284; break;              case 2: value = 0.6180339887; break;              case 3: value = 1.6180339887; break;              case 4: value = 3.1415926536; break;              case 5: value = 6.2831853072; break;          }           this.value = new x2021(value);                   this.e4100(parse,         [             ['value',   this.value],             ['constant', constant ]         ]);           this.validate();          return this;     }        isValid()     {         return this.constant && this.constant.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.constant) this.constant.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.constant) this.constant.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.constant) this.constant.c4086(parse);     } } 


class t1928 extends y2042 {     seconds   = null;     minutes   = null;     hours     = null;     dayOfWeek = null;     date      = null;     month     = null;     year      = null;                    constructor(nodeId, options)     {         super(k1098, nodeId, options);     }            reset()     {         super.reset();                  this.seconds   = null;         this.minutes   = null;         this.hours     = null;         this.dayOfWeek = null;         this.date      = null;         this.month     = null;         this.year      = null;     }        copy()     {         const copy = new t1931(this.nodeId, this.options);                  copy.z3358(this);                  if (this.seconds  ) copy.seconds   = this.seconds  .copy();         if (this.minutes  ) copy.minutes   = this.minutes  .copy();         if (this.hours    ) copy.hours     = this.hours    .copy();         if (this.dayOfWeek) copy.dayOfWeek = this.dayOfWeek.copy();         if (this.date     ) copy.date      = this.date     .copy();         if (this.month    ) copy.month     = this.month    .copy();         if (this.year     ) copy.year      = this.year     .copy();          return copy;     }                        isCached()     {         return super.isCached()             && (!this.year      || this.year     .isCached())             && (!this.month     || this.month    .isCached())             && (!this.date      || this.date     .isCached())             && (!this.dayOfWeek || this.dayOfWeek.isCached())             && (!this.hours     || this.hours    .isCached())             && (!this.minutes   || this.minutes  .isCached())             && (!this.seconds   || this.seconds  .isCached())     }        async eval(parse)     {         if (this.isCached())             return this;           this.s3095 = [];                   if (this.options.enabled)         {             const dateTime = new Date();              const seconds   = new x2021(dateTime.getSeconds() );             const minutes   = new x2021(dateTime.getMinutes() );             const hours     = new x2021(dateTime.getHours()   );             const dayOfWeek = new x2021(dateTime.getDay()     );             const date      = new x2021(dateTime.getDate()    );             const month     = new x2021(dateTime.getMonth()   );             const year      = new x2021(dateTime.getFullYear());               this.e4100(parse,             [                 ['seconds',   seconds  ],                 ['minutes',   minutes  ],                 ['hours',     hours    ],                 ['dayOfWeek', dayOfWeek],                 ['date',      date     ],                 ['month',     month    ],                 ['year',      year     ]             ]);             }                       this.validate();          return this;     }            isValid()     {         return this.year      && this.year     .isValid()             && this.month     && this.month    .isValid()             && this.date      && this.date     .isValid()             && this.dayOfWeek && this.dayOfWeek.isValid()             && this.hours     && this.hours    .isValid()             && this.minutes   && this.minutes  .isValid()             && this.seconds   && this.seconds  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.year     ) this.year     .g4087(parse);         if (this.month    ) this.month    .g4087(parse);         if (this.date     ) this.date     .g4087(parse);         if (this.dayOfWeek) this.dayOfWeek.g4087(parse);         if (this.hours    ) this.hours    .g4087(parse);         if (this.minutes  ) this.minutes  .g4087(parse);         if (this.seconds  ) this.seconds  .g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.year     ) this.year     .y4088(parse, from, force);         if (this.month    ) this.month    .y4088(parse, from, force);         if (this.date     ) this.date     .y4088(parse, from, force);         if (this.dayOfWeek) this.dayOfWeek.y4088(parse, from, force);         if (this.hours    ) this.hours    .y4088(parse, from, force);         if (this.minutes  ) this.minutes  .y4088(parse, from, force);         if (this.seconds  ) this.seconds  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.year     ) this.year     .c4086(parse);         if (this.month    ) this.month    .c4086(parse);         if (this.date     ) this.date     .c4086(parse);         if (this.dayOfWeek) this.dayOfWeek.c4086(parse);         if (this.hours    ) this.hours    .c4086(parse);         if (this.minutes  ) this.minutes  .c4086(parse);         if (this.seconds  ) this.seconds  .c4086(parse);     }     } 


class d1929 extends y2042 {     inputs = [];        constructor(nodeId, options)     {         super(v1086, nodeId, options);     }            reset()     {         super.reset();          this.input = [];     }        copy()     {         const copy = new d1929(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _values = [];          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalValue(this.inputs[i], parse);              if (   input                 && this.options.enabled)                         {                 if (h957(input.type))                 {                     for (const item of input.items)                         _values.push(item.copy());                    }                 else                     _values.push(input.copy());             }         }                       this.value =              _values.length > 0             ? _values[this.currentIteration % _values.length]             : new c4216();           if (   this.value              && this.value.objects)         {             for (let i = 0; i < this.value.objects.length; i++)             {                 const l111 = this.value.objects[i];                      l111.nodeId = this.nodeId;                 l111.listId = -1;                      l111.objectId = this.nodeId;                                  if (l111.objectId != NULL)                      l111.objectId += '/';                      l111.objectId += i.toString();             }         }           this.i4099(parse);                   this.e4100(parse,         [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));     } } 


class t1941 extends y2042 {     start    = null;     multiply = null;     add      = null;     end      = null;      current  = null;                    constructor(nodeId, options)     {         super(q1103, nodeId, options);     }        reset()     {         super.reset();                  this.start    = null;         this.multiply = null;         this.add      = null;         this.end      = null;              this.current  = null;     }           copy()     {         const copy = new t1941(this.nodeId, this.options);          copy.z3358(this);          if (this.start   ) copy.start    = this.start   .copy();         if (this.multiply) copy.multiply = this.multiply.copy();         if (this.add     ) copy.add      = this.add     .copy();         if (this.end     ) copy.end      = this.end     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const start = await evalNumberValue(this.start,    parse);         const mult  = await evalNumberValue(this.multiply, parse);         const add   = await evalNumberValue(this.add,      parse);         const end   = await evalNumberValue(this.end,      parse);               if (   start             && mult             && add             && end)         {             const value = start.value + (this.options.enabled ? add.value * this.currentIteration : 0);              if (!end.isValid())                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else if (   end.isValid()                         && (   add.value == 0                          || add.value >  0 && start.value < end.value                                            &&       value < end.value                          || add.value <  0 && start.value > end.value                                            &&       value > end.value))                 this.value = getSequenceValue(start, mult, add, this.currentIteration, this.options.enabled);              else                 this.value = x2021.NaN.copy();         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['start',    start],             ['multiply', mult ],             ['add',      add  ],             ['end',      end  ]         ]);                   this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.start    && this.start   .isValid()             && this.multiply && this.multiply.isValid()             && this.add      && this.add     .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start   ) this.start   .g4087(parse);         if (this.multiply) this.multiply.g4087(parse);         if (this.add     ) this.add     .g4087(parse);         if (this.end     ) this.end     .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.start   ) this.start   .y4088(parse, from, force);         if (this.multiply) this.multiply.y4088(parse, from, force);         if (this.add     ) this.add     .y4088(parse, from, force);         if (this.end     ) this.end     .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.start   ) this.start   .c4086(parse);         if (this.multiply) this.multiply.c4086(parse);         if (this.add     ) this.add     .c4086(parse);         if (this.end     ) this.end     .c4086(parse);     } }    function getSequenceValue(start, mult, add, iteration, enabled) {     let value = start.value;      if (enabled)     {         for (let i = 0; i < iteration; i++)         {             value *= mult.value;             value += add .value;         }     }      return new x2021(value); }


class n1939 extends y2042 {     from  = null;     start = null;     end   = null;                constructor(nodeId, options)     {         super(w1104, nodeId, options);     }            reset()     {         super.reset();          this.from  = null;         this.start = null;         this.end   = null;     }        copy()     {         const copy = new n1939(this.nodeId, this.options);          copy.z3358(this);          if (this.from   ) copy.from    = this.from   .copy();         if (this.start  ) copy.start   = this.start  .copy();         if (this.end    ) copy.end     = this.end    .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const from  = await evalNumberValue(this.from,  parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.i3820);         const iteration = repeat ? repeat.currentIteration : 0;           if (   from             && start             && end)         {             let delta = end.value - start.value;              let step =                  repeat                 && this.options.enabled                 ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))                 : 0;                               let startOffset;                   if (from  .value == 2) startOffset = step;             else if (from  .value == 1                 && repeat                 && repeat.total == 1) startOffset = delta/2;             else                        startOffset = 0;               let f;                          if (repeat)             {                      if (from.value == 2) f = iteration/repeat.total;                 else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);                 else if (from.value == 0) f = iteration/repeat.total;             }             else                 f = 0;               this.value = new x2021(                 start.value + startOffset + f * delta,                 Math.max(start.decimals, end.decimals));         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['from',  from ],             ['start', start],             ['end',   end  ]         ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.from  && this.from .isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from ) this.from .g4087(parse);         if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.from ) this.from .y4088(parse, from, force);         if (this.start) this.start.y4088(parse, from, force);         if (this.end  ) this.end  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.from ) this.from .c4086(parse);         if (this.start) this.start.c4086(parse);         if (this.end  ) this.end  .c4086(parse);     } } 


class k1945 extends y2042 {     shape     = null;     base      = null;     amplitude = null;     frequency = null;     offset    = null;     bias      = null;          useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(y1105, nodeId, options);     }            reset()     {         super.reset();          this.shape     = null;         this.base      = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.bias      = null;     }        copy()     {         const copy = new k1945(this.nodeId, this.options);          copy.z3358(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.base     ) copy.base      = this.base     .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const shape  = await evalNumberValue(this.shape,     parse);         const base   = await evalNumberValue(this.base,      parse);         const amp    = await evalNumberValue(this.amplitude, parse);         let   freq   = await evalNumberValue(this.frequency, parse);         const offset = await evalNumberValue(this.offset,    parse);         const bias   = await evalNumberValue(this.bias,      parse);               const repeat    = parse.repeats.find(r => r.repeatId == this.i3820);         const iteration = repeat ? repeat.currentIteration : 0;            if (this.options.enabled)         {             let t;                                       if (   repeat                 && shape                 && freq                 && offset)             {                 const _freq =                     this.useWavelength                     ? repeat.total / nozero(freq.value)                     : freq.value;                  let _offset =                     this.offsetAbsolute                     ? offset.value/repeat.total                     : (offset.value/100)/_freq;                  if (shape.value == 3)                     _offset -= 0.25;                  t = (iteration/repeat.total - _offset) * _freq;                  while (t < 0) t++;                 while (t > 1) t--;                  switch (shape.value)                 {                     case 0: t = (t%1) < 0.5 ? 1 : -1;      break;                      case 1: t = (1 - (t%1)*2);             break;                      case 2: t = ((t%1)*2 - 1);             break;                      case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break;                      case 4: t = Math.sin(t * Tau);         break;                  }             }             else                  t = 0;                           if (bias)             {                 const b = bias.value / 100;                  if (b >= 0) t = t / (1+b) + b/2;                 else        t = t / (1-b) + b/2;             }               if (amp ) t = t * amp .value;             if (base) t = t + base.value;               this.value = new x2021(t);         }         else             this.value = base;                   this.e4100(parse,         [             ['shape',     shape ],             ['base',      base  ],             ['amplitude', amp   ],             ['frequency', freq  ],             ['offset',    offset],             ['bias',      bias  ]         ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.shape     && this.shape    .isValid()             && this.base      && this.base     .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.bias      && this.bias     .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.shape    ) this.shape    .g4087(parse);         if (this.base     ) this.base     .g4087(parse);         if (this.amplitude) this.amplitude.g4087(parse);         if (this.frequency) this.frequency.g4087(parse);         if (this.offset   ) this.offset   .g4087(parse);         if (this.bias     ) this.bias     .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.shape    ) this.shape    .y4088(parse, from, force);         if (this.base     ) this.base     .y4088(parse, from, force);         if (this.amplitude) this.amplitude.y4088(parse, from, force);         if (this.frequency) this.frequency.y4088(parse, from, force);         if (this.offset   ) this.offset   .y4088(parse, from, force);         if (this.bias     ) this.bias     .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.shape    ) this.shape    .c4086(parse);         if (this.base     ) this.base     .c4086(parse);         if (this.amplitude) this.amplitude.c4086(parse);         if (this.frequency) this.frequency.c4086(parse);         if (this.offset   ) this.offset   .c4086(parse);         if (this.bias     ) this.bias     .c4086(parse);     } } 


class n1938 extends y2042 {     seed         = null;     iteration    = null;     min          = null;     max          = null;     bias         = null;     spread       = null;     unique       = null;      random       = null;     randomUnique = null;      lastValue1   = -1;     lastValue2   = -1;     uniqueOffset =  0;        constructor(nodeId, options)     {         super(f1106, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.min       = null;         this.max       = null;         this.bias      = null;         this.spread    = null;         this.unique    = null;     }        copy()     {         const copy = new n1938(this.nodeId, this.options);          copy.z3358(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.min      ) copy.min       = this.min      .copy();         if (this.max      ) copy.max       = this.max      .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();         if (this.spread   ) copy.spread    = this.spread   .copy();         if (this.unique   ) copy.unique    = this.unique   .copy();          if (this.random   ) copy.random    = this.random   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const min       = await evalNumberValue(this.min,       parse);         const max       = await evalNumberValue(this.max,       parse);         const bias      = await evalNumberValue(this.bias,      parse);         const spread    = await evalNumberValue(this.spread,    parse);         const unique    = await evalNumberValue(this.unique,    parse);               if (   this.options.enabled             && iteration             && seed             && min             && max             && bias             && spread             && unique)         {             if (  !this.random                 || this.random.seed != seed.value)             {                 this.random       = new Random(seed.value);                 this.randomUnique = new Random(seed.value+1);             }               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 let f  = this.random.get(this.currentIteration + this.uniqueOffset);                  f = b3734(f, bias.value, spread.value);                 f = min.value + f * (max.value - min.value);                                  this.value = new x2021(f, Math.max(min.decimals, max.decimals));                                       const _unique = unique.value/100;                                   if (max.value - min.value >= 1)                 {                     while (this.value.k3702() == this.lastValue1                         && this.randomUnique.get(this.currentIteration) < _unique)                         this.value = new x2021(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                  if (max.value - min.value >= 2)                 {                     while ((   this.value.k3702() == this.lastValue1                             || this.value.k3702() == this.lastValue2)                         && this.randomUnique.get(this.currentIteration) < Math.max(_unique - 1))                         this.value = new x2021(                             min.value + this.random.get(this.currentIteration + ++this.uniqueOffset) * (max.value - min.value),                             Math.max(min.decimals, max.decimals));                 }                     }             else                 this.value = new x2021((min.value + max.value) / 2);         }         else             this.value = x2021.NaN.copy();           if (this.value.isValid())             this.value.value = this.value.k3702();          this.lastValue2 = this.lastValue1;         this.lastValue1 = this.value.value;           this.e4100(parse,         [             ['iteration', iteration],             ['seed',      seed     ],             ['min',       min      ],             ['max',       max      ],             ['bias',      bias     ],             ['spread',    spread   ],             ['unique',    unique   ]         ]);                   this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.min       && this.min      .isValid()             && this.max       && this.max      .isValid()             && this.bias      && this.bias     .isValid()             && this.spread    && this.spread   .isValid()             && this.unique    && this.unique   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.seed     ) this.seed     .g4087(parse);         if (this.iteration) this.iteration.g4087(parse);         if (this.min      ) this.min      .g4087(parse);         if (this.max      ) this.max      .g4087(parse);         if (this.bias     ) this.bias     .g4087(parse);         if (this.spread   ) this.spread   .g4087(parse);         if (this.unique   ) this.unique   .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.seed     ) this.seed     .y4088(parse, from, force);         if (this.iteration) this.iteration.y4088(parse, from, force);         if (this.min      ) this.min      .y4088(parse, from, force);         if (this.max      ) this.max      .y4088(parse, from, force);         if (this.bias     ) this.bias     .y4088(parse, from, force);         if (this.spread   ) this.spread   .y4088(parse, from, force);         if (this.unique   ) this.unique   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.seed     ) this.seed     .c4086(parse);         if (this.iteration) this.iteration.c4086(parse);         if (this.min      ) this.min      .c4086(parse);         if (this.max      ) this.max      .c4086(parse);         if (this.bias     ) this.bias     .c4086(parse);         if (this.spread   ) this.spread   .c4086(parse);         if (this.unique   ) this.unique   .c4086(parse);     }        l3628(parse, nodeId)     {         super.l3628(parse, nodeId);          this.uniqueOffset = 0;     }        n3631(parse, nodeId)     {         super.n3631(parse, nodeId);          this.uniqueOffset = 0;     } } 


class a1934 extends y2042 {     seed        = null;     iteration   = null;     min         = null;     max         = null;     scale       = null;     interpolate = null;     offset      = null;     evolve      = null;     detail      = null;          randoms     = [];     offsets     = [];                    constructor(nodeId, options)     {         super(d1107, nodeId, options);     }                    reset()     {         super.reset();                  this.seed          = null;         this.iteration     = null;         this.min           = null;         this.max           = null;         this.scale         = null;         this.interpolate   = null;         this.offset        = null;         this.evolve        = null;         this.detail        = null;     }        copy()     {         const copy = new a1934(this.nodeId, this.options);          copy.z3358(this);          if (this.seed       ) copy.seed        = this.seed       .copy();         if (this.iteration  ) copy.iteration   = this.iteration  .copy();         if (this.min        ) copy.min         = this.min        .copy();         if (this.max        ) copy.max         = this.max        .copy();         if (this.scale      ) copy.scale       = this.scale      .copy();         if (this.offset     ) copy.offset      = this.offset     .copy();         if (this.evolve     ) copy.evolve      = this.evolve     .copy();         if (this.interpolate) copy.interpolate = this.interpolate.copy();         if (this.detail     ) copy.detail      = this.detail     .copy();          if (this.randoms    ) copy.randoms     = this.randoms.map(r => r.copy());         if (this.offsets    ) copy.offsets     = this.offsets.slice();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed        = await evalNumberValue(this.seed,        parse);         const iteration   = await evalNumberValue(this.iteration,   parse);         const min         = await evalNumberValue(this.min,         parse);         const max         = await evalNumberValue(this.max,         parse);         const scale       = await evalNumberValue(this.scale,       parse);         const offset      = await evalNumberValue(this.offset,      parse);         const evolve      = await evalNumberValue(this.evolve,      parse);         const interpolate = await evalNumberValue(this.interpolate, parse);         const detail      = await evalNumberValue(this.detail,      parse);               if (   this.options.enabled             && seed             && iteration             && min             && max             && scale             && offset             && evolve             && interpolate             && detail)         {             const _detail = Math.max(1, Math.ceil(detail.value));               if (  !this.randoms                 || this.randoms.length < _detail)             {                 const randoms = new Array(_detail);                  for (let c = 0; c < this.randoms.length; c++)                     randoms[c] = this.randoms[c];                                   let _seed = seed.value;                  for (let c = this.randoms.length; c < _detail; c++)                 {                     randoms[c] = new m375(_seed);                     _seed = seed.value;                 }                   this.randoms = randoms;                   this.updateOffsets(this.randoms[0].width * _detail);             }               let   size  = 1;             let   power = 1;                          const avg   = (min.value + max.value) / 2;             let   r;                           if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);                               if (   this.options.enabled                 && scale  && scale .isValid()                 && offset && offset.isValid()                 && evolve && evolve.isValid())             {                 r = avg;                                  if (this.currentIteration >= 0)                 {                     for (let c = 0; c < _detail; c++)                     {                         const i  = Math.max(0, this.currentIteration / (Math.max(0.000001, scale.value) * size) + offset.value);                         const i0 = Math.floor(i);                         const i1 = Math.ceil (i);                                                   this.updateOffsets((i1 + 1) * _detail);                          const o0 = this.offsets[i0];                         const o1 = this.offsets[i1];                         let   _o;                          switch (interpolate.value)                         {                             case 0: _o = o0;                                                 break;                             case 1: _o = x1035(o0, o1, i-i0);                                 break;                             case 2: _o = (o0 + (o1 - o0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;                         }                                                   const j   = evolve.value + _o;                         const j0  = Math.floor(j);                         const j1  = Math.ceil (j);                           const r00 = this.randoms[c].get(i0, j0);                         const r10 = this.randoms[c].get(i1, j0);                         const r01 = this.randoms[c].get(i0, j1);                         const r11 = this.randoms[c].get(i1, j1);                                       let _r, _r0, _r1;                                                  switch (interpolate.value)                         {                             case 0:                                  _r = r00;                                 break;                              case 1:                                  _r0 = x1035(r00, r10, i-i0);                                 _r1 = x1035(r01, r11, i-i0);                                 _r  = x1035(_r0, _r1, j-j0);                                 break;                              case 2:                                  _r0 = (r00 + (r10 - r00) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r1 = (r01 + (r11 - r01) * (-Math.cos((i-i0)*Tau/2) + 1)/2);                                  _r  = (_r0 + (_r1 - _r0) * (-Math.cos((j-j0)*Tau/2) + 1)/2);                                  break;                         }                           const clamp =                              detail.value - c < 1                              ? detail.value - c                              : 1;                          r +=                              - power *      (avg       - min.value) * clamp                             + power * _r * (max.value - min.value) * clamp;                                                   size  /= 2;                         power /= 2;                                                   this.updateOffsets(this.randoms[0].width * _detail);                     }                 }             }             else             {                 r = min.value;             }               this.value = new x2021(r, Math.max(min.decimals, max.decimals));         }         else         {             this.value = x2021.NaN.copy();         }           this.e4100(parse,         [             ['seed',        seed       ],             ['iteration',   iteration  ],             ['min',         min        ],             ['max',         max        ],             ['scale',       scale      ],             ['offset',      offset     ],             ['evolve',      evolve     ],             ['interpolate', interpolate],             ['detail',      detail     ]         ]);                   this.validate();          return this;     }        updateOffsets(newSize)     {         if (newSize < this.offsets.length)              return;          this.offsets = new Array(newSize);         const offsetRandom = new Random(0);          for (let o = 0; o < newSize; o++)             this.offsets[o] = offsetRandom.get(o);     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed        && this.seed       .isValid()             && this.iteration   && this.iteration  .isValid()             && this.min         && this.min        .isValid()             && this.max         && this.max        .isValid()             && this.scale       && this.scale      .isValid()             && this.offset      && this.offset     .isValid()             && this.evolve      && this.evolve     .isValid()             && this.interpolate && this.interpolate.isValid()             && this.detail      && this.detail     .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.seed       ) this.seed       .g4087(parse);         if (this.iteration  ) this.iteration  .g4087(parse);         if (this.min        ) this.min        .g4087(parse);         if (this.max        ) this.max        .g4087(parse);         if (this.scale      ) this.scale      .g4087(parse);         if (this.offset     ) this.offset     .g4087(parse);         if (this.evolve     ) this.evolve     .g4087(parse);         if (this.interpolate) this.interpolate.g4087(parse);         if (this.detail     ) this.detail     .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.seed       ) this.seed       .y4088(parse, from, force);         if (this.iteration  ) this.iteration  .y4088(parse, from, force);         if (this.min        ) this.min        .y4088(parse, from, force);         if (this.max        ) this.max        .y4088(parse, from, force);         if (this.scale      ) this.scale      .y4088(parse, from, force);         if (this.offset     ) this.offset     .y4088(parse, from, force);         if (this.evolve     ) this.evolve     .y4088(parse, from, force);         if (this.interpolate) this.interpolate.y4088(parse, from, force);         if (this.detail     ) this.detail     .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.seed       ) this.seed       .c4086(parse);         if (this.iteration  ) this.iteration  .c4086(parse);         if (this.min        ) this.min        .c4086(parse);         if (this.max        ) this.max        .c4086(parse);         if (this.scale      ) this.scale      .c4086(parse);         if (this.offset     ) this.offset     .c4086(parse);         if (this.evolve     ) this.evolve     .c4086(parse);         if (this.interpolate) this.interpolate.c4086(parse);         if (this.detail     ) this.detail     .c4086(parse);     } } 


class v1937 extends k2044 {     seed      = null;     iteration = null;     chance    = null;     alternate = null;      random    = null;        constructor(nodeId, options)     {         super(l1108, nodeId, options);     }            reset()     {         super.reset();          this.seed      = null;         this.iteration = null;         this.chance    = null;         this.alternate = null;     }        copy()     {         const copy = new n1938(this.nodeId, this.options);          copy.z3358(this);          if (this.seed     ) copy.seed      = this.seed     .copy();         if (this.iteration) copy.iteration = this.iteration.copy();         if (this.chance   ) copy.chance    = this.chance   .copy();         if (this.alternate) copy.alternate = this.alternate.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082    = await evalValue      (this.b4082,    parse);         const o4083    = await evalValue      (this.o4083,    parse);         const seed      = await evalNumberValue(this.seed,      parse);         const iteration = await evalNumberValue(this.iteration, parse);         const chance    = await evalNumberValue(this.chance,    parse);         const alternate = await evalNumberValue(this.alternate, parse);               if (   seed             && iteration             && chance             && alternate)         {             if (  !this.random                 || this.random.seed != seed.value)                 this.random = new Random(seed.value);               if (iteration.isValid())                 this.currentIteration = Math.round(iteration.value);               if (this.currentIteration >= 0)             {                 const calt  = this.currentIteration % 2 == 0 ? 0 : 1;                  let   cval  = chance.value/100;                       cval += alternate.value/100 * (calt - cval);                  const ch    = this.random.get(this.currentIteration) > cval ? 0 : 1;                                   if (   b4082                      && o4083)                 {                     if (   b4082.isValid()                         && o4083.isValid())                         this.value = ch < 0.5 ? b4082 : o4083;                     else                         this.value = new c4216();                 }                  else if (b4082)                     this.value = b4082;                                  else if (o4083)                     this.value = o4083;                                  else                     this.value = new x2021(ch < 0.5 ? 0 : 1);             }             else                 this.value = new c4216();         }         else             this.value = new c4216();           this.e4100(parse,         [             ['type',      this.outputType()],             ['seed',      seed             ],             ['iteration', iteration        ],             ['chance',    chance           ],             ['alternate', alternate        ]         ]);                   this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed      && this.seed     .isValid()             && this.iteration && this.iteration.isValid()             && this.chance    && this.chance   .isValid()             && this.alternate && this.alternate.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.seed     ) this.seed     .g4087(parse);         if (this.iteration) this.iteration.g4087(parse);         if (this.chance   ) this.chance   .g4087(parse);         if (this.alternate) this.alternate.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.seed     ) this.seed     .y4088(parse, from, force);         if (this.iteration) this.iteration.y4088(parse, from, force);         if (this.chance   ) this.chance   .y4088(parse, from, force);         if (this.alternate) this.alternate.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.seed     ) this.seed     .c4086(parse);         if (this.iteration) this.iteration.c4086(parse);         if (this.chance   ) this.chance   .c4086(parse);         if (this.alternate) this.alternate.c4086(parse);     } } 


class e1924 extends f2043 {     current;     when;        constructor(nodeId, options)     {         super(l1109, nodeId, options);          this.current = new x2021(0);     }            reset()     {         super.reset();          this.current = null;         this.when    = null;     }        copy()     {         const copy = new e1924(this.nodeId, this.options);          copy.z3358(this);          if (this.when   ) copy.when    = this.when   .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalNumberValue(this.input, parse);         const when  = await evalNumberValue(this.when,  parse);                       if (   input             && when)         {             if (this.options.enabled)             {                 if (when.value > 0)                     this.value = this.current.copy();                  if (input)                 {                     this.current.value   += input.value;                     this.current.decimals = Math.max(this.current.decimals, input.decimals);                 }                  if (when.value == 0)                     this.value = this.current.copy();             }             else                 this.value = input.copy();         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,          [             ['when', when]         ]);                   this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.when && this.when.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.when) this.when.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.when) this.when.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.when) this.when.c4086(parse);     }        n3631(parse, nodeId)     {         super.n3631(parse, nodeId);          this.current = new x2021(0);     } } 


class GHold extends f2043 {     current;     first;        constructor(nodeId, options)     {         super(HOLD, nodeId, options);          this.current = null;     }            reset()     {         super.reset();          this.current = null;         this.first   = null;     }        copy()     {         const copy = new GHold(this.nodeId, this.options);          copy.z3358(this);          if (this.first  ) copy.first   = this.first  .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (    this.isCached()             || !parse.evalAccumulate)             return this;           const input = await evalValue(this.input, parse);         const first = await evalValue(this.first, parse);                       if (   input             && first)         {             if (this.options.enabled)             {                 this.value   = this.current ? this.current : first;                 this.current = input;             }             else                 this.value = input;         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,          [             ['type', this.outputType()]         ]);                   this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.first) this.first.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.first) this.first.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.first) this.first.c4086(parse);     }        n3631(parse, nodeId)     {         super.n3631(parse, nodeId);          this.current = null;     } } 


class r1930 extends k2044 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(e1110, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new r1930(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const values = [];                  for (const l3811 of this.inputs)         {             const input = await evalNumberValue(l3811, parse);              if (h957(input.type))             {                 for (const item of input.items)                 {                                                                    const value = await evalNumberValue(item, parse);                     values.push(value);                 }             }             else             {                 const value = await evalNumberValue(input, parse);                 values.push(value);             }         }                           const maxDec = values.reduce((max, v) => Math.max(max, v.decimals), 0);           const deg =             degree.value < 3             ? Math.min(degree.value, 2) + 1             : 1;          const nSegments = Math.floor((values.length-1)/deg);         const index     = Math.min(Math.floor((values.length-1)/deg * amount.value/100), nSegments-1);           if (values.length == 1)             this.value = values[0];          else if (values.length > 0               && index < values.length - deg)         {             const localAmount =                  nSegments > 1                 ? (amount.value/100 - index/nSegments) * nSegments                 : amount.value/100;               if (degree.value == 0)              {                 const s3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new x2021(                     x1035(s3689.value, val1.value, localAmount),                     maxDec);             }             else if (degree.value == 1)              {                 const s3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                  this.value = new x2021(                     u1036(s3689.value, val1.value, val2.value, localAmount),                     maxDec);             }             else if (degree.value == 2)              {                 const s3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                 const val2 = values[index*deg+2];                 const val3 = values[index*deg+3];                  this.value = new x2021(                     s1037(s3689.value, val1.value, val2.value, val3.value, localAmount),                     maxDec);             }             else if (degree.value == 3)              {                 const s3689 = values[index*deg  ];                 const val1 = values[index*deg+1];                  this.value = new x2021(                     lerpCos(s3689.value, val1.value, localAmount),                     maxDec);             }             else                 this.value = x2021.NaN.copy();         }          else                               this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['value',  this.value],             ['amount', amount    ],             ['degree', degree    ]         ]);                   this.validate();          return this;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.amount) this.amount.g4087(parse);         if (this.degree) this.degree.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.amount) this.amount.y4088(parse, from, force);         if (this.degree) this.degree.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.amount) this.amount.c4086(parse);         if (this.degree) this.degree.c4086(parse);     } } 


class v1944 extends f2043 {     current = null;     target  = null;      temp    = null;            constructor(nodeId, options)     {         super(k1098, nodeId, options);     }            reset()     {         super.reset();          this.current = null;         this.target  = null;         this.temp    = null;     }        copy()     {         const copy = new v1944(this.nodeId, this.options);          copy.z3358(this);          if (this.current) copy.current = this.current.copy();         if (this.target ) copy.target  = this.target .copy();          return copy;     }        isCached()     {         return super.isCached()             && this.current.isCached()             && this.target .isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           let   input   = await evalNumberValue(this.input,   parse);         let   current = await evalNumberValue(this.current, parse);         const target  = await evalNumberValue(this.target,  parse);           if (   input             && current.isValid()             && target .isValid())         {             g952(                 input.type == n1091,                  'input.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 let   diff      = target.value - current.value;                 let   prevDiff  = 0;                   let   temp      = 0;                 let   step      = Number.MAX_SAFE_INTEGER/65536;                   let   iter      = 0;                 const maxIter   = 1000;                                   y2076(this.nodeId);                   parse.j3639 += maxIter;                   while (iter++ < maxIter)                 {                     temp += step;                       if (this.input.type == PARAM)                     {                         this.input.node[this.input.f2991].value    = temp;                         this.input.node[this.input.f2991].decimals = l1004(temp);                     }                                               this.current.y4088(parse, this);                     current = await evalNumberValue(this.current, parse);                                                                                      if (current.isValid())                     {                         diff = target.value - current.value;                                                   if (Math.abs(diff) < 0.0000001)                             break;                                                       if (   Math.abs (diff) >  Math.abs (prevDiff)                             || Math.sign(diff) != Math.sign(prevDiff))                             step /= -2;                                                                             prevDiff = diff;                     }                                               parse.m3638++;                     v2077(parse, this.nodeId, iter / maxIter);                 }                   if (iter < maxIter)                 {                     parse.m3638 += maxIter - iter;                      input = await evalNumberValue(this.input, parse);                     this.value = input.copy();                 }                 else                 {                     this.value = x2021.NaN.copy();                     console.warn('max solve iterations');                 }             }             else                 this.value = input.copy();         }         else         {             if (this.input)                  await this.input.eval(parse);              this.value = x2021.NaN.copy();         }                             this.e4100(parse,         [                          ['current', current   ],             ['target',  target    ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.current && this.current.isValid()             && this.target  && this.target .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.current) this.current.g4087(parse);         if (this.target ) this.target .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.current) this.current.y4088(parse, from, force);         if (this.target ) this.target .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.current) this.current.c4086(parse);         if (this.target ) this.target .c4086(parse);     } } 


class z1925 extends y2042 {     from   = null;     to     = null;     curve  = null;     repeat = null;     length = null;     time   = null;                    constructor(nodeId, options)     {         super(n1112, nodeId, options);     }                    reset()     {         super.reset();                  this.from   = null;         this.to     = null;         this.curve  = null;         this.repeat = null;         this.length = null;         this.time   = null;     }        copy()     {         const copy = new z1925(this.nodeId, this.options);          copy.z3358(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.to    ) copy.to     = this.to    .copy();         if (this.curve ) copy.curve  = this.curve .copy();         if (this.repeat) copy.repeat = this.repeat.copy();         if (this.length) copy.length = this.length.copy();         if (this.time  ) copy.time   = this.time  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from   = await evalNumberValue(this.from,   parse);         const to     = await evalNumberValue(this.to,     parse);         const curve  = await evalNumberValue(this.curve,  parse);         const repeat = await evalNumberValue(this.repeat, parse);         const length = await evalNumberValue(this.length, parse);         const time   = await evalNumberValue(this.time,   parse);               const maxDec = Math.max(from.decimals, to.decimals);          switch (curve.value)         {             case 0:              {                 this.value = new x2021(                     time.value < length.value ? from.value : to.value,                      maxDec);                      break;             }             case 1:              {                 this.value = new x2021(                     from.value + (to.value - from.value) * time.value / length.value,                     maxDec);                  break;             }             case 2:              {                 let f = time.value / length.value;                  f = 1 - sqr(1 - f);                  this.value = new x2021(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 3:              {                 let f = time.value / length.value;                  f = sqr(f);                  this.value = new x2021(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 4:              {                 let f = time.value / length.value;                  f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);                  this.value = new x2021(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }         }                   this.e4100(parse,         [             ['from',   from  ],             ['to',     to    ],             ['curve',  curve ],             ['repeat', repeat],             ['length', length],             ['time',   time  ]         ]);                   this.validate();          return this;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.to     && this.to    .isValid()             && this.curve  && this.curve .isValid()             && this.repeat && this.repeat.isValid()             && this.length && this.length.isValid()             && this.time   && this.time  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from  ) this.from  .g4087(parse);         if (this.to    ) this.to    .g4087(parse);         if (this.curve ) this.curve .g4087(parse);         if (this.repeat) this.repeat.g4087(parse);         if (this.length) this.length.g4087(parse);         if (this.time  ) this.time  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.from  ) this.from  .y4088(parse, from, force);         if (this.to    ) this.to    .y4088(parse, from, force);         if (this.curve ) this.curve .y4088(parse, from, force);         if (this.repeat) this.repeat.y4088(parse, from, force);         if (this.length) this.length.y4088(parse, from, force);         if (this.time  ) this.time  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.from  ) this.from  .c4086(parse);         if (this.to    ) this.to    .c4086(parse);         if (this.curve ) this.curve .c4086(parse);         if (this.repeat) this.repeat.c4086(parse);         if (this.length) this.length.c4086(parse);         if (this.time  ) this.time  .c4086(parse);     } } 


class g1901 extends u1898 {     operation;        constructor(nodeId, options)     {         super(x1114, nodeId, options);     }       reset()     {         super.reset();          this.operation = null;     }            copy()     {         const copy = new g1901(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.f3728();                   if (op.isValid())         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), k1311.length-1);             op.decimals = 0;         }           if (this.options.enabled)         {             switch (op.value)             {                 case 0: this.value = await u3700  (this, this.inputs, parse); break;                 case 1: this.value = await w3699  (this, this.inputs, parse); break;                 case 2: this.value = await h3697(this, this.inputs, parse); break;                 case 3: this.value = await j3696     (this, this.inputs, parse); break;                 case 4: this.value = await v3698(this, this.inputs, parse); break;                 case 5: this.value = await i3701(this, this.inputs, parse); break;             }         }          else if (this.inputs.length > 0)             this.value =                     this.inputs.length > 0                  && this.inputs[0]                  ? (await this.inputs[0].eval(parse)).t3632()                  : null;          else             this.value = x2021.NaN.copy();           this.e4100(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.operation) this.operation.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.operation) this.operation.c4086(parse);     } }    async function j3696(node, inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       const value = new x2021(0);       for (let i = 0; i < inputs.length; i++)     {         const val = await evalValue(inputs[i], parse);                   if (   !val             || !val.isValid())         {             for (let j = i+1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return x2021.NaN.copy();         }           if (h957(val.type))         {             if (   isEmpty(val.items)                 || val.items[0].type != n1091)                 return x2021.NaN.copy();              for (const item of val.items)             {                 if (item.type == n1091)                 {                     value.value   += item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }         }         else         {             g952(                  val.type == n1091,                  'val.type must be NUMBER_VALUE');              value.value   += val.value;             value.decimals = Math.max(value.decimals, val.decimals);         }     }       return value; }    async function h3697(node, inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       let value = new x2021(0);       if (!isEmpty(inputs))     {         const s3689 = await evalValue(inputs[0], parse);          if (   !s3689             || !s3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return x2021.NaN.copy();         }                                                                 if (     h957(s3689.type)              && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              if (   !o3688                 || !o3688.isValid())                 return x2021.NaN.copy();               value.value    = o3688.value;             value.decimals = o3688.decimals;              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                  if (   !item                     || !item.isValid())                     return x2021.NaN.copy();                  if (item.type == n1091)                 {                     value.value   -= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              value.value    = s3689.value;             value.decimals = s3689.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return x2021.NaN.copy();             }               if (h957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == n1091)                     {                         value.value   -= item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 g952(                      val.type == n1091,                      'val.type must be NUMBER_VALUE');                                      value.value   -= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function v3698(node, inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       const value = new x2021(0);       if (!isEmpty(inputs))     {         value.value = 1;          for (let i = 0; i < inputs.length; i++)         {             const val = await evalValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return x2021.NaN.copy();             }               if (h957(val.type))             {                 if (   isEmpty(val.items)                     || val.items[0].type != n1091)                     return x2021.NaN.copy();                  for (const item of val.items)                 {                     value.value   *= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }             else             {                 g952(                      val.type == n1091,                      'val.type must be NUMBER_VALUE');                  value.value   *= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function w3699(node, inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();               let value = new x2021(0);               if (!isEmpty(inputs))     {         const s3689 = await evalValue(inputs[0], parse);          if (   !s3689             || !s3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return x2021.NaN.copy();         }           if (    h957(s3689.type)             && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              if (   !o3688                 || !o3688.isValid())                 return x2021.NaN.copy();               value.value    = o3688.value;             value.decimals = o3688.decimals;              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                  if (   !item                     || !item.isValid())                     return x2021.NaN.copy();                                       if (item.type == n1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.value    = value.value / item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              value.value    = s3689.value;             value.decimals = s3689.decimals;         }                   for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return x2021.NaN.copy();             }               if (h957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return x2021.NaN.copy();                       if (item.type == n1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                                                   value.value    = value.value / item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 g952(                      val.type == n1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                                                        value.value    = value.value / val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }    async function u3700(node, inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();               const value = new x2021(0);               if (!isEmpty(inputs))     {         const s3689 = await evalValue(inputs[0], parse);          if (   !s3689             || !s3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return x2021.NaN.copy();         }           if (    h957(s3689.type)             && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              if (   !o3688                 || !o3688.isValid())                 return x2021.NaN.copy();               value.value    = o3688.value;             value.decimals = o3688.decimals;              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                                  if (   !item                     || !item.isValid())                     return x2021.NaN.copy();                   if (item.type == n1091)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.decimals = Math.max(value.decimals, item.decimals);                     value.value    = value.value % item.value;                 }                                 }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              value.value    = s3689.value;             value.decimals = s3689.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return x2021.NaN.copy();             }               if (h957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return x2021.NaN.copy();                       if (item.type == n1091)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                          value.decimals = Math.max(value.decimals, item.decimals);                         value.value    = i1015(value.value % item.value, value.decimals);                     }                                     }             }             else             {                 g952(                      val.type == n1091,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                  value.decimals = Math.max(value.decimals, val.decimals);                 value.value    = i1015(value.value % val.value, value.decimals);             }         }     }       return value; }    async function i3701(node, inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       const value = new x2021(0);       if (!isEmpty(inputs))     {         const s3689 = await evalValue(inputs[0], parse);          if (   !s3689             || !s3689.isValid())         {             for (let j = 1; j < inputs.length; j++)                 await evalValue(inputs[j], parse);                          return x2021.NaN.copy();         }           if (    h957(s3689.type)             && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              if (   !o3688                 || !o3688.isValid())                 return x2021.NaN.copy();               value.value    = o3688.value;             value.decimals = o3688.decimals;              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                                  if (   !item                     || !item.isValid())                     return x2021.NaN.copy();                   if (item.type == n1091)                 {                     value.value    = Math.pow(value.value,    item.value);                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              value.value    = s3689.value;             value.decimals = s3689.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);              if (   !val                 || !val.isValid())             {                 for (let j = i+1; j < inputs.length; j++)                     await evalValue(inputs[j], parse);                                  return x2021.NaN.copy();             }               if (h957(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return x2021.NaN.copy();                      if (item.type == n1091)                     {                         value.value    = Math.pow(value.value,    item.value);                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 g952(                     val.type == n1091,                      'val.type must be NUMBER_VALUE');                  value.value    = Math.pow(value.value,    val.value);                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class b1904 extends f2043 {     operation;     operand;     invert;        constructor(nodeId, options)     {         super(u1113, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;         this.invert    = null;     }        copy()     {         const copy = new e1940(this.nodeId, this.options);          copy.z3358(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();         if (this.invert   ) copy.invert    = this.invert   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021(0);           const input   = await evalNumberValue(this.input,     parse);         const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);         const invert  = await evalNumberValue(this.invert,    parse);           if (op)         {             op.value    = Math.min(Math.max(0, Math.round(op.value)), k1311.length-1);             op.decimals = 0;         }           if (   input             && op)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == n1091                             ? x3695(item, operand, op, invert, this.options.enabled)                             : x2021.NaN.copy());                        }                 }                 else                 {                     this.value = x3695(input, operand, op, invert, this.options.enabled);                 }             }             else                 this.value = input.copy();         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [                          ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ],             ['invert',    invert           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid()             && this.invert    && this.invert   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);         if (this.operand  ) this.operand  .g4087(parse);         if (this.invert   ) this.invert   .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.operation) this.operation.y4088(parse, from, force);         if (this.operand  ) this.operand  .y4088(parse, from, force);         if (this.invert   ) this.invert   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.operation) this.operation.c4086(parse);         if (this.operand  ) this.operand  .c4086(parse);         if (this.invert   ) this.invert   .c4086(parse);     } }    function x3695(input, operand, op, invert, enabled) {     g952(         input.type == n1091,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), k1311.length-1);          const o3694 = Math.max(input.decimals, operand.decimals);          switch (op.value)         {             case 0:                  return invert.value == 0                     ? new x2021(input.value % operand.value, o3694)                     : new x2021(operand.value % input.value, o3694);              case 1:                  if (      operand.value == 0                        && invert .value == 0                     ||    input  .value == 0                        && invert .value == 1)                     return x2021.NaN.copy();                 else                     return invert.value == 0                         ? new x2021(input.value / operand.value, o3694)                         : new x2021(operand.value / input.value, o3694);              case 2:                  return invert.value == 0                     ? new x2021(input.value - operand.value, o3694)                     : new x2021(operand.value - input.value, o3694);              case 3:                  return invert.value == 0                     ? new x2021(input.value + operand.value, o3694)                     : new x2021(operand.value + input.value, o3694);              case 4:                  return invert.value == 0                     ? new x2021(input.value * operand.value, o3694)                     : new x2021(operand.value * input.value, o3694);              case 5:                  return invert.value == 0                     ? new x2021(Math.pow(input.value, operand.value), o3694)                     : new x2021(Math.pow(operand.value, input.value), o3694);         }           p953('invalid math operation');         return input;     }     else         return input; }


class z1907 extends u1898 {     operation;        constructor(nodeId, options)     {         super(j1121, nodeId, options);     }        reset()     {         super.reset();          this.operation = null;     }           copy()     {         const copy = new z1907(this.nodeId, this.options);          copy.z3358(this);          copy.inputs    = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let op = await evalNumberValue(this.operation, parse);          if (op) op = op.f3728();           op.value     =          op.i3788 = Math.min(Math.max(0, op.value), j1317.length-1);                   switch (op.value)         {             case x1313: this.value = await x3693(this.inputs, parse); break;             case f1314: this.value = await i3690 (this.inputs, parse); break;             case o1315:  this.value = await u3691  (this.inputs, parse); break;             case c1316: this.value = await x3692 (this.inputs, parse); break;         }                   this.e4100(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.operation) this.operation.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.operation) this.operation.c4086(parse);     } }


class n1908 extends u1898 {     constructor(nodeId, options)     {         super(x1122, nodeId, options);     }            copy()     {         const copy = new n1908(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await x3693(this.inputs, parse);                   this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }    async function x3693(inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       const value = new x2021();       if (!isEmpty(inputs))     {         const s3689 = await evalNumberValue(inputs[0], parse);         if (!s3689.isValid()) return x2021.NaN.copy();          if (    h957(s3689.type)             && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              value.value = o3688.k3702() != 0 ? 0 : 1;              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                                  if (   item.type == n1091                     && item.k3702() == 0)                     value.value = 1;             }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              value.value = s3689.k3702() != 0 ? 0 : 1;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return x2021.NaN.copy();              if (h957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == n1091                         && item.k3702() == 0)                         value.value = 1;                 }             }             else             {                 g952(                     val.type == n1091,                      'val.type must be NUMBER_VALUE');                  if (val.k3702() == 0)                     value.value = 1;             }         }     }       return value; } 


class m1906 extends u1898 {     constructor(nodeId, options)     {         super(z1123, nodeId, options);     }            copy()     {         const copy = new m1906(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await x3692(this.inputs, parse);                   this.e4100(parse,          [             ['', new c4216()]                      ]);                   this.validate();          return this;     } }    async function x3692(inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       const value = new x2021();       if (!isEmpty(inputs))     {         const s3689 = await evalNumberValue(inputs[0], parse);         if (!s3689.isValid()) return x2021.NaN.copy();           if (    h957(s3689.type)             && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              value.value = o3688.k3702();              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                                  if (item.type == n1091)                     value.value = Math.min(value.value, item.k3702());             }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              value.value = s3689.k3702();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return x2021.NaN.copy();               if (h957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == n1091)                         value.value = Math.min(value.value, item.k3702());                 }             }             else             {                 g952(                     val.type == n1091,                      'val.type must be NUMBER_VALUE');                  value.value = Math.min(value.value, val.k3702());             }         }                   if (value.value != 0)             value.value = 1;     }       return value; }


class s1909 extends u1898 {     constructor(nodeId, options)     {         super(o1124, nodeId, options);     }            copy()     {         const copy = new s1909(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await u3691(this.inputs, parse);                   this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }    async function u3691(inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       const value = new x2021();       if (!isEmpty(inputs))     {         const s3689 = await evalNumberValue(inputs[0], parse);         if (!s3689.isValid()) return x2021.NaN.copy();          if (    h957(s3689.type)             && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              value.value = o3688.k3702();              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                                  if (item.type == n1091)                     value.value = Math.max(value.value, item.k3702());             }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              value.value = s3689.k3702();         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return x2021.NaN.copy();              if (h957(val.type))             {                 for (const item of val.items)                 {                     if (item.type == n1091)                         value.value = Math.max(value.value, item.k3702());                 }             }             else             {                 g952(                     val.type == n1091,                      'val.type must be NUMBER_VALUE');                                      value.value = Math.max(value.value, val.k3702());             }         }           if (value.value != 0)             value.value = 1;     }       return value; }


class r1910 extends u1898 {     constructor(nodeId, options)     {         super(a1125, nodeId, options);     }            copy()     {         const copy = new r1910(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3690(this.inputs, parse);                   this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }    async function i3690(inputs, parse) {     if (isEmpty(inputs))         return x2021.NaN.copy();       const value = new x2021(0);       let flipped;      if (!isEmpty(inputs))     {         const s3689 = await evalNumberValue(inputs[0], parse);         if (!s3689.isValid()) return x2021.NaN.copy();          if (    h957(s3689.type)             && !isEmpty(s3689.items))         {             const o3688 = s3689.items[0];              flipped = o3688.k3702() != 0;              for (let i = 1; i < s3689.items.length; i++)             {                 const item = s3689.items[i];                                  if (   item.type == n1091                     && item.k3702() != 0)                     flipped++;             }         }         else         {             if (s3689.type != n1091)                 return x2021.NaN.copy();              flipped = s3689.k3702() != 0;         }           for (let i = 1; i < inputs.length; i++)         {             const val = await evalNumberValue(inputs[i], parse);             if (!val.isValid()) return x2021.NaN.copy();              if (h957(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == n1091                         && item.k3702() != 0)                         flipped++;                     }             }             else             {                 g952(                     val.type == n1091,                      'val.type must be NUMBER_VALUE');                                      if (val.k3702() != 0)                     flipped++;             }         }           value.value = flipped == 1 ? 1 : 0;     }       return value; }


class r1911 extends f2043 {     operation;     operand;        constructor(nodeId, options)     {         super(l1126, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new r1911(this.nodeId, this.options);          copy.z3358(this);          if (this.operation) copy.operation = this.operation.copy();         if (this.operand  ) copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op      = await evalNumberValue(this.operation, parse);         const operand = await evalNumberValue(this.operand,   parse);          op.value = Math.min(Math.max(0, op.value), l1324.length-1);                   switch (op.value)         {             case n1318:              this.value = await v3687(this.input, operand, ((a, b) => a <  b), parse);  break;             case j1319:     this.value = await v3687(this.input, operand, ((a, b) => a <= b), parse);  break;             case y1320:         this.value = await v3687(this.input, operand, ((a, b) => a != b), parse);  break;             case b1321:             this.value = await v3687(this.input, operand, ((a, b) => a == b), parse);  break;             case k1322:  this.value = await v3687(this.input, operand, ((a, b) => a >= b), parse);  break;             case w1323:           this.value = await v3687(this.input, operand, ((a, b) => a >  b), parse);  break;         }           this.e4100(parse,         [                          ['operation', op        ],             ['operand',   operand   ]         ]);           this.validate();      return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);         if (this.operand  ) this.operand  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.operation) this.operation.y4088(parse, from, force);         if (this.operand  ) this.operand  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.operation) this.operation.c4086(parse);         if (this.operand  ) this.operand  .c4086(parse);     } }    async function v3687(b4082, o4083, op, parse)  {     const s3689 = await evalNumberValue(b4082, parse);     const val1 = await evalNumberValue(o4083, parse);      if (   s3689 && s3689.isValid()          && val1 && val1.isValid())         return new x2021(op(s3689.k3702(), val1.k3702()) ? 1 : 0);     else                           return x2021.NaN.copy(); }


class p1912 extends k2044 {     constructor(nodeId, options)     {         super(m1127, nodeId, options);     }            copy()     {         const copy = new p1912(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await v3687(             this.b4082,              this.o4083,              (a, b) => a == b,              parse);                       this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } } 


class c1917 extends k2044 {     constructor(nodeId, options)     {         super(c1128, nodeId, options);     }            copy()     {         const copy = new c1917(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await v3687(             this.b4082,              this.o4083,              (a, b) => a != b,              parse);                   this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }


class t1915 extends k2044 {     constructor(nodeId, options)     {         super(v1129, nodeId, options);     }            copy()     {         const copy = new t1915(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await v3687(             this.b4082,              this.o4083,              (a, b) => a < b,              parse);                       this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }


class a1916 extends k2044 {     constructor(nodeId, options)     {         super(r1130, nodeId, options);     }            copy()     {         const copy = new a1916(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await v3687(             this.b4082,              this.o4083,              (a, b) => a <= b,              parse);                       this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } } 


class b1913 extends k2044 {     constructor(nodeId, options)     {         super(f1131, nodeId, options);     }            copy()     {         const copy = new b1913(this.nodeId, this.options);         copy.z3358(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await v3687(             this.b4082,              this.o4083,              (a, b) => a > b,              parse);                   this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }


class t1914 extends k2044 {     constructor(nodeId, options)     {         super(d1132, nodeId, options);     }            copy()     {         const copy = new t1914(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await v3687(             this.b4082,              this.o4083,              (a, b) => a >= b,              parse);                       this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } } 


class d1922 extends f2043 {     function;        constructor(nodeId, options)     {         super(k1133, nodeId, options);     }            reset()     {         super.reset();          this.function = null;     }        copy()     {         const copy = new d1922(this.nodeId, this.options);          copy.z3358(this);          if (this.function) copy.function = this.function.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input,    parse);         const func  = await evalNumberValue(this.function, parse);          func.value = Math.min(Math.max(0, func.value), l1331.length-1);                   if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? await getTrigValue(item, func, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = await getTrigValue(input, func, this.options.enabled); }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type',     this.outputType()],             ['function', func             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.function && this.function.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.function) this.function.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.function) this.function.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.function) this.function.c4086(parse);     } }    async function getTrigValue(input, func, enabled) {     g952(         input.type == n1091,         'input.type must be NUMBER_VALUE');       if (!enabled)         return input;       switch (func.value)     {         case d1325:  return await g4235   (input, false);         case x1326:  return await j4236 (input, false);         case v1327:  return await u4237(input, false);         case o1328: return await g4235   (input, true );         case t1329: return await j4236 (input, true );         case c1330: return await u4237(input, true );     } }


class s1920 extends f2043 {     constructor(nodeId, options)     {         super(j1134, nodeId, options);     }            copy()     {         const copy = new s1920(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await g4235(this.input, parse);           this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     }        t3632()     {         return this.value.copy();     } }    async function g4235(input, arc) {     if (!input)         return x2021.NaN.copy();      const val =          !arc          ? Math.sin (input.value)          : Math.asin(input.value);      return new x2021(val, l1004(val)); }


class p1919 extends f2043 {     constructor(nodeId, options)     {         super(r1135, nodeId, options);     }            copy()     {         const copy = new p1919(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await j4236(this.input, parse);           this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }    async function j4236(input, arc) {     if (!input)         return x2021.NaN.copy();      const val =          !arc          ? Math.cos (input.value)          : Math.acos(input.value);     return new x2021(val, l1004(val)); }


class k1921 extends f2043 {     constructor(nodeId, options)     {         super(c1136, nodeId, options);     }            copy()     {         const copy = new k1921(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await u4237(this.input, parse);           this.e4100(parse,          [             ['', new c4216()]                      ]);           this.validate();          return this;     } }    async function u4237(input, arc) {     if (!input)         return x2021.NaN.copy();      const val =          !arc          ? Math.tan (input.value)          : Math.atan(input.value);          return new x2021(val, l1004(val)); }


class g1918 extends y2042 {     x;     y;            constructor(nodeId, options)     {         super(x1137, nodeId, options);     }            reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new g1918(this.nodeId, this.options);          copy.z3358(this);          if (this.x) copy.x = this.x.copy();         if (this.y) copy.y = this.y.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x = await evalNumberValue(this.x, parse);         const y = await evalNumberValue(this.y, parse);           this.value = new x2021(Math.atan2(y.value, x.value));           this.e4100(parse,         [                          ['x',     x         ],             ['y',     y         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x) this.x.g4087(parse);         if (this.y) this.y.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.x) this.x.y4088(parse, from, force);         if (this.y) this.y.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.x) this.x.c4086(parse);         if (this.y) this.y.c4086(parse);     } } 


class r1927 extends f2043 {     from;        constructor(nodeId, options)     {         super(z1138, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new r1927(this.nodeId, this.options);          copy.z3358(this);          if (this.from) copy.from = this.from.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new x2021(0);                   const input = await evalNumberValue(this.input, parse);         const from  = await evalNumberValue(this.from,  parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getConvertAngleValue(item, from, this.options.enabled)                         : x2021.NaN.copy());                    }             }             else                 this.value = getConvertAngleValue(input, from, this.options.enabled);         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type',  this.outputType()],                          ['from',  from             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from) this.from.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.from) this.from.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.from) this.from.c4086(parse);     } }    function getConvertAngleValue(input, from, enabled) {     g952(          input == n1091,          'input must be NUMBER_VALUE');               const value = input;          if (enabled)     {         switch (from.value)         {             case 0: value.value = value.value/360 * Tau; break;             case 1: value.value = value.value/Tau * 360; break;         }          value.decimals = l1004(value.value);     }       return value; }


class i1991 extends f2043 {     constructor(nodeId, options)     {         super(a1144, nodeId, options);     }        copy()     {         const copy = new i1991(this.nodeId, this.options);                  copy.z3358(this);          copy.value = this.value;                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)             this.value = await evalTextValue(this.input, parse);         else if (this.value)             await this.value.eval(parse);         else             this.value = new v2032();           this.e4100(parse,         [             ['value', this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return   !this.input                && this.value != u963              || this.input.isValid();     } }


class x1999 extends f2043 {     length;        constructor(nodeId, options)     {         super(d1145, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new x1999(this.nodeId, this.options);          copy.z3358(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);          if (   input             && input.value)         {             g952(input.type == l1143, 'input must be TEXT_VALUE');              this.length = new x2021(input.value.length);         }         else             this.length = x2021.NaN.copy();               this.e4100(parse,         [             ['length', this.length]         ]);           this.validate();          return this;     } } 


class n2006 extends f2043 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(z1146, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new n2006(this.nodeId, this.options);          copy.z3358(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == l1143                         ? p3429(item, start, end, this.options.enabled)                         : new v2032());                    }             }             else             {                 this.value = p3429(input, start, end, this.options.enabled);             }         }         else             this.value = new v2032();           this.e4100(parse,         [                          ['type',  this.outputType()],             ['start', start            ],             ['end',   end              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.start) this.start.y4088(parse, from, force);         if (this.end  ) this.end  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.start) this.start.c4086(parse);         if (this.end  ) this.end  .c4086(parse);     } }    function p3429(input, start, end, enabled) {     g952(input.type == l1143, 'input.type must be TEXT_VALUE');                     const value = input.copy();      if (enabled)     {         if (start.value.length > 0) value.value = s954(value.value, f1489(start.value));         if (end  .value.length > 0) value.value = h955  (value.value, f1489(end  .value));     }      return value; }


class y2003 extends f2043 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(d1147, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new y2003(this.nodeId, this.options);          copy.z3358(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const start = await evalNumberValue(this.start, parse);         const end   = await evalNumberValue(this.end,   parse);           let length = 0;           if (   input             && start             && end)         {             length = input.value.length;                          this.value = input.copy();                          g952(this.value.type == l1143, 'this.value.type must be TEXT_VALUE');                                               const _end =                 end.isValid()                 ? end                 : new x2021(input.value.length);               if (this.options.enabled)             {                 const endValue =                      _end.value < 0                     ? length + _end.value                     : _end.value;                  if (start.value <= endValue)                     this.value.value = this.value.value.substring(start.value, endValue);                 else                     this.value = new v2032();             }             else                 this.value = input.copy();         }         else             this.value = new v2032();           this.e4100(parse,         [             ['length', new x2021(length)],              ['start',  start                  ],             ['end',    end                    ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        g4087(parse)     {         super.g4087(parse);          if (this.start) this.start.g4087(parse);         if (this.end  ) this.end  .g4087(parse);     }        c4086(parse, from)     {         super.c4086(parse, from);          if (this.start) this.start.c4086(parse, from);         if (this.end  ) this.end  .c4086(parse, from);     } } 


class u1994 extends k2044 {     first;     last;     all;        constructor(nodeId, options)     {         super(v1148, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new u1994(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082 = await evalTextValue(this.b4082, parse);         const o4083 = await evalTextValue(this.o4083, parse);               if (   b4082 && b4082.isValid()              && o4083 && o4083.isValid())         {             const indices = [];             let   index   = 0;              if (o4083.value != '')             {                 while (index != -1)                  {                     index = b4082.value.indexOf(o4083.value, index);                      if (index != -1)                      {                         indices.push(index);                         index += 1;                     }                 }                                   this.value = new x2021(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new x2021(indices.at( 0)) : x2021.NaN.copy();                 this.last  = indices.length > 0 ? new x2021(indices.at(-1)) : x2021.NaN.copy();                  this.all   = new b2020();                  for (const index of indices)                     this.all.items.push(new x2021(index));             }             else             {                 this.value = new x2021(1);                  this.first = x2021.NaN.copy();                 this.last  = x2021.NaN.copy();                 this.all   =   b2020.NaN.copy();             }         }         else                           {             this.value = x2021.NaN.copy();             this.first = x2021.NaN.copy();             this.last  = x2021.NaN.copy();             this.all   =   b2020.NaN.copy();         }               this.e4100(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class b1992 extends f2043 {     case;            constructor(nodeId, options)     {         super(l1149, nodeId, options);     }            reset()     {         super.reset();          this.case = null;     }        copy()     {         const copy = new b1992(this.nodeId, this.options);          copy.z3358(this);          if (this.case) copy.case = this.case.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue  (this.input, parse);         const t3658 = await evalNumberValue(this.case,  parse);           if (input)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == l1143                             ? getTextCaseValue(item, t3658)                             : new v2032());                        }                 }                 else                 {                     this.value = getTextCaseValue(input, t3658);                 }             }             else                 this.value = input.copy();         }         else             this.value = new v2032();           this.e4100(parse,         [                          ['type',   this.outputType()],             ['case',  t3658             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.case && this.case.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.case) this.case.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.case) this.case.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.case) this.case.c4086(parse);     } }    function getTextCaseValue(input, t3658) {     g952(input.type == l1143, 'input.type must be TEXT_VALUE');      const val   = input.value;     const value = new v2032();           if (t3658.value == 0)           value.value = val.toLowerCase();      else if (t3658.value == 1)     {         if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();         if (val.length > 1) value.value += val.substring(1)   .toLowerCase();     }      else if (t3658.value == 2)     {         let i = 0;         while (i < val.length)         {             while (i < val.length                 && /\s/.test(val.charAt(i)))                 value.value += val.charAt(i++);              if (i < val.length)                 value.value += val.charAt(i++).toUpperCase();              while (i < val.length                 && !/\s/.test(val.charAt(i)))                 value.value += val.charAt(i++).toLowerCase();         }     }      else if (t3658.value == 3)          value.value = val.toUpperCase();       return value; }


class m1990 extends f2043 {     base;     decimals;     thousands;            constructor(nodeId, options)     {         super(i1157, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new m1990(this.nodeId, this.options);          copy.z3358(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalNumberValue(this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalNumberValue(this.thousands, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? m3430(item, base, decimals, thousands)                         : v2032.NaN.copy());                    }             }             else             {                 this.value = m3430(input, base, decimals, thousands);             }         }         else             this.value = v2032.NaN.copy();           this.e4100(parse,         [                          ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.base     ) this.base     .g4087(parse);         if (this.decimals ) this.decimals .g4087(parse);         if (this.thousands) this.thousands.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.base     ) this.base     .y4088(parse, from, force);         if (this.decimals ) this.decimals .y4088(parse, from, force);         if (this.thousands) this.thousands.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.base     ) this.base     .c4086(parse);         if (this.decimals ) this.decimals .c4086(parse);         if (this.thousands) this.thousands.c4086(parse);     } }    function m3430(input, base, decimals, thousands) {     return input.isValid()          ? new v2032(w1006(                input.value,                -input.decimals,                 base.value == 1,                 decimals.value,                 thousands.value))          : new v2032('?'); }


class y1988 extends f2043 {     format;            constructor(nodeId, options)     {         super(b1158, nodeId, options);     }       reset()     {         super.reset();          this.format = null;     }            copy()     {         const copy = new y1988(this.nodeId, this.options);          copy.z3358(this);          if (this.format) copy.format = this.format.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalColorValue (this.input,  parse);         const format = await evalNumberValue(this.format, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getColorToTextValue(item, format)                         : v2032.NaN.copy());                    }             }             else             {                 this.value = getColorToTextValue(input, format);             }         }          else             this.value = v2032.NaN.copy();           this.e4100(parse,         [             ['type',   this.outputType()],             ['format', format           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.format) this.format.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.format) this.format.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.format) this.format.c4086(parse);     } }    function getColorToTextValue(input, format) {     let str = u963;      const rgb = input.v3241();      switch (format.value)     {         case 0:              str = j151(rgb);             break;          case 1:              str =                    w1006(rgb[0], -3) + ', '                 + w1006(rgb[1], -3) + ', '                 + w1006(rgb[2], -3);             break;          case 2:              str =                    Math.round(rgb[0] * 255) + ', '                 + Math.round(rgb[1] * 255) + ', '                 + Math.round(rgb[2] * 255);             break;          case 3:              str = createColorName(rgb);             break;     }      return new v2032(str); }


class y2005 extends f2043 {     base      = null;     decimals  = null;     thousands = null;            constructor(nodeId, options)     {         super(w1159, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new y2005(this.nodeId, this.options);          copy.z3358(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalTextValue  (this.input,     parse);         const base      = await evalNumberValue(this.base,      parse);         const decimals  = await evalNumberValue(this.decimals,  parse);         const thousands = await evalTextValue  (this.thousands, parse);           if (   input             && input.isValid())         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == l1143                         ? getTextToNumberValue(item, base, decimals, thousands)                         : x2021.NaN.copy());                    }             }             else                 this.value = getTextToNumberValue(input, base, decimals, thousands);         }          else             this.value = x2021.NaN.copy();           this.e4100(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.base     ) this.base     .g4087(parse);         if (this.decimals ) this.decimals .g4087(parse);         if (this.thousands) this.thousands.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.base     ) this.base     .y4088(parse, from, force);         if (this.decimals ) this.decimals .y4088(parse, from, force);         if (this.thousands) this.thousands.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.base     ) this.base     .c4086(parse);         if (this.decimals ) this.decimals .c4086(parse);         if (this.thousands) this.thousands.c4086(parse);     } }    function getTextToNumberValue(input, base, decimals, thousands) {     let num   = Number.NaN;     let value = input.value;      if (thousands)         value = value.replaceAll(thousands.value, '');           if (base)     {         switch (base.value)         {             case 0:              {                 if (value.lastIndexOf(decimals.value) < 0)                     num = parseInt(value.replace(/\D/g, ''), 10);                 else                 {                     value = l1496(value, decimals.value, '.');                     num   = parseFloat(value);                 }                          break;             }             case 1:              {                 const decIndex = value.lastIndexOf(decimals.value);                  if (decIndex < -1)                     num = parseInt(value, 16);                 else                 {                     const whole = value.slice(0, decIndex);                     const frac  = value.slice(decIndex + decimals.value.length);                      num =                          parseInt(whole, 16)                         + frac.split('')                             .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);                 }                  break;             }         }     }       return new x2021(num, l1004(num)); }


class v2004 extends f2043 {     constructor(nodeId, options)     {         super(m1160, nodeId, options);     }            copy()     {         const copy = new v2004(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             const input = await evalTextValue(this.input, parse);              if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == l1143                         ? getTextToColorValue(item)                         : x2021.NaN.copy());                    }             }             else             {                 this.value = getTextToColorValue(input);             }         }         else             this.value = s2009.NaN.copy();           this.e4100(parse,         [             ['value', this.value       ],             ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getTextToColorValue(input) {     const str = input.value.trim();       let rgb;        if (settings.preferHtmlColorNames)     {                    let webColor = m1498.find(wc => wc.name.toLowerCase() == str);         if (!webColor) webColor = m1498.find(wc => o1490(wc.name.toLowerCase(), str) <= 1);                  if (webColor)              rgb = g153(webColor.color);     }     else     {         const hsl = parseColorName(str);          rgb =              hsl              ? p50(hsl)              : g153(str);     }           return s2009.x3772(w4141(rgb)); }


class u1987 extends f2043 {     constructor(nodeId, options)     {         super(f1154, nodeId, options);     }            copy()     {         const copy = new u1987(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalNumberValue(this.input, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == n1091                         ? getCodeToCharacterValue(item)                         : v2032.NaN.copy());                    }             }             else             {                 this.value = getCodeToCharacterValue(input);             }         }         else             this.value = v2032.NaN.copy();           this.e4100(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCodeToCharacterValue(input) {     return new v2032(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff))); }


class w1986 extends f2043 {     constructor(nodeId, options)     {         super(j1155, nodeId, options);     }            copy()     {         const copy = new w1986(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalTextValue(this.input, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == l1143                         ? getCharacterToCodeValue(item)                         : x2021.NaN.copy());                    }             }             else             {                 this.value = getCharacterToCodeValue(input);             }         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCharacterToCodeValue(input) {     return input.value.length > 0          ? new x2021(input.value.charCodeAt(0))          : x2021.NaN.copy(); }


class a1989 extends y2042 {     name;     index;            constructor(nodeId, options)     {         super(f1156, nodeId, options);     }            reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new a1989(this.nodeId, this.options);          copy.z3358(this);          if (this.name ) copy.name  = this.name .copy();         if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const name  = await evalTextValue  (this.name,  parse);         const index = await evalNumberValue(this.index, parse);           switch (name.value)         {             case 0: this.value = new v2032(                 [                     'monday',                      'tuesday',                      'wednesday',                      'thursday',                      'friday',                      'saturday',                      'sunday'                 ]                  [index.value-1]);                  break;              case 1: this.value = new v2032(                 [                     'january',                      'february',                      'march',                      'april',                      'may',                      'june',                      'july',                     'august',                     'september',                     'october',                     'november',                     'december'                 ]                  [index.value-1]);                  break;              case 2:                 this.value = new v2032(c4038[index.value]);                 break;          }           this.e4100(parse,         [                          ['name',  name      ],             ['index', index     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid()             && this.name  && this.name .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.index) this.index.g4087(parse);         if (this.name ) this.name .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.index) this.index.y4088(parse, from, force);         if (this.name ) this.name .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.index) this.index.c4086(parse);         if (this.name ) this.name .c4086(parse);     } } 


class y2001 extends f2043 {     what  = null;     with  = null;     regex = null;        constructor(nodeId, options)     {         super(w1150, nodeId, options);     }            reset()     {         super.reset();          this.what  = null;         this.with  = null;         this.regex = null;     }        copy()     {         const copy = new y2001(this.nodeId, this.options);          copy.z3358(this);          if (this.what ) copy.what  = this.what .copy();         if (this.with ) copy.with  = this.with .copy();         if (this.regex) copy.regex = this.regex.copy();          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = await evalTextValue  (this.input, parse);         const _what  = await evalTextValue  (this.what,  parse);         const _with  = await evalTextValue  (this.with,  parse);         const _regex = await evalNumberValue(this.regex, parse);           if (input)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == l1143                             ? getReplaceValue(item, _what, _with, _regex)                             : new v2032());                        }                 }                 else                 {                     this.value = getReplaceValue(input, _what, _with, _regex);                 }             }             else                 this.value = input.copy();         }         else             this.value = new v2032();           this.e4100(parse,         [                          ['type',   this.outputType()],             ['what',  _what             ],             ['with',  _with             ],             ['regex', _regex            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what  && this.what .isValid()             && this.with  && this.with .isValid()             && this.regex && this.regex.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.what ) this.what .g4087(parse);         if (this.with ) this.with .g4087(parse);         if (this.regex) this.regex.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.what ) this.what .y4088(parse, from, force);         if (this.with ) this.with .y4088(parse, from, force);         if (this.regex) this.regex.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.what ) this.what .c4086(parse);         if (this.with ) this.with .c4086(parse);         if (this.regex) this.regex.c4086(parse);     } }    function getReplaceValue(input, _what, _with, _regex) {     g952(input.type == l1143, 'input.type must be TEXT_VALUE');      const value = new v2032();           if (_regex.value > 0)     {         try         {             value.value = input.value.replace(                 new RegExp(unescapeRegexPattern(_what.value), 'gu'),                 unescapeRegexReplacement(_with.value));         }         catch (e)         {             x4041(e.message, {error: true});         }     }     else if (input.value)     {         value.value = input.value.replaceAll(             f1489(_what.value),             f1489(_with.value));     }       return value; }


class d1998 extends y2042 {     inputs = [];      with = null;            constructor(nodeId, options)     {         super(r1151, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.with = null;     }           copy()     {         const copy = new d1998(this.nodeId, this.options);         copy.z3358(this);                  copy.inputs = this.inputs.map(i => i.copy());         copy.with   = this.with;          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           const _with = await evalTextValue(this.with, parse);          this.value = await evalJoinInputs(this.inputs, _with, parse);                   this.e4100(parse,         [                          ['with',  _with     ]         ]);           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.with && this.with.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.with) this.with.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.with) this.with.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.with) this.with.c4086(parse);     } }    async function evalJoinInputs(inputs, _with, parse) {     if (isEmpty(inputs))         return new v2032();       const value = new v2032();     const w     = f1489(_with.value);      for (let i = 0; i < inputs.length; i++)     {         const val = await evalTextValue(inputs[i], parse);         if (!val) continue;           if (i > 0)             value.value += w;           if (h957(val.type))         {             for (let j = 0; j < val.items.length; j++)             {                 if (j > 0)                     value.value += w;                   const item = val.items[j];                  if (item.type == l1143)                     value.value += item.value;             }         }         else         {             g952(val.type == l1143, 'val.type must be TEXT_VALUE');              value.value += val.value;         }     }       return value; }


class t2000 extends f2043 {     q3654   = null;     l3655 = null;     d3656     = null;     y3657   = null;                    constructor(nodeId, options)     {         super(n1152, nodeId, options);     }            reset()     {         super.reset();                  this.q3654   = null;         this.l3655 = null;         this.d3656     = null;         this.y3657   = null;     }        copy()     {         const copy = new t2000(this.nodeId, this.options);          copy.z3358(this);          if (this.q3654  ) copy.q3654   = this.q3654  .copy();         if (this.l3655) copy.l3655 = this.l3655.copy();         if (this.d3656    ) copy.d3656     = this.d3656    .copy();         if (this.y3657  ) copy.y3657   = this.y3657  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const q3654   = await evalTextValue  (this.q3654,   parse);         const l3655 = await evalNumberValue(this.l3655, parse);         const d3656     = await evalTextValue  (this.d3656,     parse);         const y3657   = await evalNumberValue(this.y3657,   parse);           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == l1143                         ? getPadValue(                             item,                              q3654,                              l3655,                              d3656,                              y3657,                              this.options.enabled)                         : new v2032());                    }             }             else             {                 this.value = getPadValue(                     input,                      q3654,                      l3655,                      d3656,                      y3657,                      this.options.enabled);             }         }         else             this.value = new v2032();           this.e4100(parse,         [                          ['type',       this.outputType()],             ['startPad',   q3654         ],             ['startCount', l3655       ],             ['endPad',     d3656           ],             ['endCount',   y3657         ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.q3654   && this.q3654  .isValid()             && this.l3655 && this.l3655.isValid()             && this.d3656     && this.d3656    .isValid()             && this.y3657   && this.y3657  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.q3654  ) this.q3654  .g4087(parse);         if (this.l3655) this.l3655.g4087(parse);         if (this.d3656    ) this.d3656    .g4087(parse);         if (this.y3657  ) this.y3657  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.q3654  ) this.q3654  .y4088(parse, from, force);         if (this.l3655) this.l3655.y4088(parse, from, force);         if (this.d3656    ) this.d3656    .y4088(parse, from, force);         if (this.y3657  ) this.y3657  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.q3654  ) this.q3654  .c4086(parse);         if (this.l3655) this.l3655.c4086(parse);         if (this.d3656    ) this.d3656    .c4086(parse);         if (this.y3657  ) this.y3657  .c4086(parse);     } }    function getPadValue(input, q3654, l3655, d3656, y3657, enabled) {     g952(input.type == l1143, 'input.type must be TEXT_VALUE');      const value = input.copy();          if (enabled)         value.value = input.value             .padStart(l3655.value, f1489(q3654.value))             .padEnd  (  y3657.value, d3656.value != '' ? f1489(d3656.value) : f1489(q3654.value));      return value; }


class a2002 extends f2043 {     separator;        constructor(nodeId, options)     {         super(t1161, nodeId, options);     }        reset()     {         super.reset();          this.separator = null;     }           copy()     {         const copy = new a2002(this.nodeId, this.options);          copy.z3358(this);          if (this.separator) copy.separator = this.separator.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const separator = await evalTextValue(this.separator, parse);           this.value = new b2020();           if (   this.input             && separator)         {             const input = await evalTextValue(this.input, parse);                          if (   input                 && input.value)             {                 g952(input.type == l1143, 'input must be TEXT_VALUE');                 const items = input.value.split(f1489(separator.value));                  for (const item of items)                     this.value.items.push(new v2032(item));             }         }               this.e4100(parse,         [             ['length',    new x2021(this.value.items.length)],             ['separator', separator                               ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.separator && this.separator.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.separator) this.separator.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.separator) this.separator.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.separator) this.separator.c4086(parse);     } } 


class l1993 extends k2044 {     operation;        constructor(nodeId, options)     {         super(q1153, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new l1993(this.nodeId, this.options);          copy.z3358(this);          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = x2021.NaN.copy();                           const op = await evalNumberValue(this.operation, parse);                   if (op)         {             op.value = Math.min(Math.max(0, op.value), l1324.length-1);              switch (op.value)             {                 case n1318:              this.value = await evalCompareInputs(this.b4082, this.o4083, ((a, b) => a <  b), parse);  break;                 case j1319:     this.value = await evalCompareInputs(this.b4082, this.o4083, ((a, b) => a <= b), parse);  break;                 case y1320:         this.value = await evalCompareInputs(this.b4082, this.o4083, ((a, b) => a != b), parse);  break;                 case b1321:             this.value = await evalCompareInputs(this.b4082, this.o4083, ((a, b) => a == b), parse);  break;                 case k1322:  this.value = await evalCompareInputs(this.b4082, this.o4083, ((a, b) => a >= b), parse);  break;                 case w1323:           this.value = await evalCompareInputs(this.b4082, this.o4083, ((a, b) => a >  b), parse);  break;             }         }           this.e4100(parse,         [             ['value',     this.value],             ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.operation) this.operation.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.operation) this.operation.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.operation) this.operation.c4086(parse);     } }    async function evalCompareInputs(b4082, o4083, op, parse)  {     const s3689 = await evalTextValue(b4082, parse);     const val1 = await evalTextValue(o4083, parse);      if (   s3689 && s3689.isValid()          && val1 && val1.isValid())         return new x2021(op(s3689.value, val1.value) ? 1 : 0);     else                           return new c4216(); }


class j1995 extends f2043 {     r3647;     i3648;        constructor(nodeId, options)     {         super(q1163, nodeId, options);     }            reset()     {         super.reset();          this.r3647    = null;         this.i3648 = null;     }        copy()     {         const copy = new j1995(this.nodeId, this.options);          copy.z3358(this);          if (this.r3647   ) copy.r3647    = this.r3647   .copy();         if (this.i3648) copy.i3648 = this.i3648.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const r3647    = await evalTextValue(this.r3647,    parse);         const i3648 = await evalTextValue(this.i3648, parse);           this.value = new b2020();           let maxColumns = 0;                   let nRows    = 0;         let nColumns = 0;           if (   this.input             && r3647             && i3648             && r3647.value != '')         {             const input = await evalTextValue(this.input, parse);                           const rows =                     input                 && input.value                             ? input.value.split(f1489(r3647.value))                 : [];               for (const _row of rows)             {                 const cells =                      _row                     ? _row.split(f1489(i3648.value))                     : [];                   const row = new b2020();                  for (const cell of cells)                     row.items.push(new v2032(cell));                  maxColumns = Math.max(maxColumns, row.items.length);                   this.value.items.push(row);             }               nRows    = this.value.items.length;             nColumns = maxColumns;         }               this.e4100(parse,         [             ['rowSeparator',    r3647             ],             ['columnSeparator', i3648          ],             ['rows',            new x2021(nRows   )],             ['columns',         new x2021(nColumns)]         ]);                   if (parse.settings.g3733)         {             this.e4100(parse,             [                 ['preview', new b2020(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.r3647    && this.r3647   .isValid()             && this.i3648 && this.i3648.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.r3647   ) this.r3647   .g4087(parse);         if (this.i3648) this.i3648.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.r3647   ) this.r3647   .y4088(parse, from, force);         if (this.i3648) this.i3648.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.r3647   ) this.r3647   .c4086(parse);         if (this.i3648) this.i3648.c4086(parse);     } } 


class GTextJson extends f2043 {     constructor(nodeId, options)     {         super(t3504, nodeId, options);     }            copy()     {         const copy = new GTextJson(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new b2020();           if (this.input)         {             const input = await evalTextValue(this.input, parse);                          try             {                 const json = JSON.parse(input.value);                 this.value = this.evalItems(json);             }             catch (e)             {                 this.value = new b2020();             }         }               this.e4100(parse,         [             ['length',  new x2021(this.value.items.length)]                      ]);                   if (parse.settings.n3732)         {             this.e4100(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        evalItems(json)     {         let list = new b2020();           for (const key in json)         {             if (   typeof json[key] === 'object'                 && json[key] !== null)             {                 const l111 = this.evalItems(json[key]);                 l111.valueId = key;                 list.items.push(l111);             }             else             {                 let value;                  if (   typeof json[key] === 'number'                     || f1486(json[key]))                     value = x2021.fromString(json[key].toString());                 else if (typeof json[key] === 'boolean')                     value = new x2021(p923(json[key].toString()) ? 1 : 0);                 else                     value = new v2032(json[key]);                                       value.valueId =                      key == 'value'                     ? '(value)'                      : key;                  list.items.push(value);             }         }                   return list;     } } 


class n1996 extends y2042 {     request;     d4211;        constructor(nodeId, options)     {         super(t1164, nodeId, options);     }            reset()     {         super.reset();          this.request     = null;         this.d4211 = null;     }        copy()     {         const copy = new n1996(this.nodeId, this.options);          copy.z3358(this);          if (this.request    ) copy.request     = this.request    .copy();         if (this.d4211) copy.d4211 = this.d4211.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const request     = await evalTextValue(this.request,     parse);         const d4211 = await evalTextValue(this.d4211, parse);                   y2076(this.nodeId);           if (d4211.value == '')         {             try              {                 const response = await fetch(request.value);                 const content  = await response.text();                                  this.value = new v2032(content);             }             catch (e)             {                                                   this.value =                      request.value.trim() == NULL                     ? new v2032()                     : new v2032('invalid request');             }         }         else         {             this.value = this.d4211.copy();         }           this.e4100(parse,         [             ['value',   this.value],             ['request', request   ]         ]);                           if (parse.settings.n3732)         {             this.e4100(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return this.request && this.request.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.request) this.request.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.request) this.request.y4088(parse, from, force);          this.d4211 = new v2032();     }        c4086(parse)     {         super.c4086(parse);          if (this.request) this.request.c4086(parse);     } }


class s1997 extends y2042 {               d4211 = null;        constructor(nodeId, options)     {         super(y1165, nodeId, options);     }            reset()     {         super.reset();          this.d4211 = null;     }        copy()     {         const copy = new s1997(this.nodeId, this.options);          copy.z3358(this);          if (this.d4211) copy.d4211 = this.d4211.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const d4211 = await evalTextValue(this.d4211, parse);                          y2076(this.nodeId);           this.value = d4211 ?? new v2032();           this.e4100(parse,         [             ['', new c4216()]                      ]);                           if (parse.settings.n3732)         {             this.e4100(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return false;     }        g4087(parse)     {         super.g4087(parse);          if (this.path) this.path.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.path) this.path.y4088(parse, from, force);               }        c4086(parse)     {         super.c4086(parse);          if (this.path) this.path.c4086(parse);     } }


class q1795 {     name;      max;     value;          constructor(name = '', max = 0, value = 0)     {         this.name  = name;         this.max   = max;         this.value = value;     } }    async function z1796(parse,                               nodeId,                               color,                               order, b3683, b3684, n3685,                               v3712, y3713, y3714, l3715)  {     const m3716 = k4193(f4199(color));           let p1805 = [...color],         t1806 = null,          v1807 = order ? order.value : -1,         j1808     = -1,         y1809     = -1,         s1810     = -1;       let progress = 0,         total    = 6 * Math.pow(2, Tau);               let d = 1;              parse.j3639 += 1024;       dLoop:     while (d > 1/1024)     {         if (parse.e3640)             break dLoop;          let _closestColor = [...p1805];           for (let u3682 = 0; u3682 < 6; u3682++)         {             if (parse.e3640)                 break dLoop;              p1805 = [..._closestColor];              const [min1, min2, min3] = l1802(color[0], u3682);             const [max1, max2, max3] = f1803(color[0], u3682);              let start1 = x1035(min1, j1808, 1-d),  j1811 = x1035(max1, j1808, 1-d),                 start2 = x1035(min2, y1809, 1-d),  m1812 = x1035(max2, y1809, 1-d),                 start3 = x1035(min3, s1810, 1-d),  b1813 = x1035(max3, s1810, 1-d);                                                                                                                                     if (y3713) { j1808 = b3683.k3702(); start1 = j1808; j1811 = j1808+Epsilon; }             if (y3714) { y1809 = b3684.k3702(); start2 = y1809; m1812 = y1809+Epsilon; }             if (l3715) { s1810 = n3685.k3702(); start3 = s1810; b1813 = s1810+Epsilon; }                                                   [ p1805,             t1806,             v1807,             j1808,             y1809,             s1810,             progress ] = await findCorrectionInOrder(                 parse,                 nodeId,                 m3716,                 u3682,                  v3712,                  y3713,  y3714,  l3715,                 j1808, y1809, s1810,                 start1,   start2,   start3,                  j1811,     m1812,     b1813,                 [...p1805],                 t1806,                  v1807,                 progress,                 total);         }           if (parse.e3640)             break;                   d /= 2;           parse.m3638++;           if (await l3861(parse.i2066))             break;     }       if (!parse.e3640)     {                   const c3717 = v1797(color, v1807, j1808, y1809, s1810)[2];          let c1 = j1808;         let c2 = y1809;         let c3 = s1810;          while (c1 >= 0 && r108(v1797(color, v1807, c1-1, y1809, s1810)[2], c3717)) c1--;         while (c2 >= 0 && r108(v1797(color, v1807, j1808, c2-1, s1810)[2], c3717)) c2--;         while (c3 >= 0 && r108(v1797(color, v1807, j1808, y1809, c3-1)[2], c3717)) c3--;          j1808 = Math.max(0, c1);         y1809 = Math.max(0, c2);         s1810 = Math.max(0, c3);     }           return [         v1807,         j1808,         y1809,         s1810 ]; }    async function findCorrectionInOrder(parse,                                      nodeId,                                      m3716,                                      order,                                       v3712,                                       y3713,  y3714,  l3715,                                      j1808, y1809, s1810,                                      start1,   start2,   start3,                                       j1811,     m1812,     b1813,                                      p1805,                                      t1806,                                      v1807,                                      progress,                                      total) {     const color = [...p1805];          let x3718 = y3713 ? 1 : 2;     let o3719 = y3714 ? 1 : 2;     let x3720 = l3715 ? 1 : 2;       cLoop:     for (let m1 = start1; m1 < j1811; m1 += (j1811-start1)/x3718)     {         if (parse.e3640)             break cLoop;          for (let m2 = start2; m2 < m1812; m2 += (m1812-start2)/o3719)         {             if (parse.e3640)                 break cLoop;              for (let m3 = start3; m3 < b1813; m3 += (b1813-start3)/x3720)             {                 if (parse.e3640)                     break cLoop;                  const [f3198, _oklab, s124] = v1797(color, order, m1, m2, m3);                  if (   e78(s124)                     && (  !t1806                         || j102(m3716, _oklab) < j102(m3716, t1806)))                 {                     p1805 = f3198;                     t1806 = _oklab;                                          if (!v3712)                         v1807 = order;                      j1808 = m1;                     y1809 = m2;                     s1810 = m3;                 }                  progress++;             }         }                   v2077(parse, nodeId, progress / total, false);     }           return [         p1805,         t1806,         v1807,         j1808,         y1809,         s1810,         progress ]; }    function v1797(color, order, m1, m2, m3) {     const f3198 = y1798(color, order, m1, m2, m3);     const oklab  = k4193(f4199(f3198));     const rgb    = g3984(oklab);      return [f3198, oklab, rgb]; }    function y1798(color, order, c1, c2, c3) {     if (order < 0)         return color;       const [i1, i2, i3] = i1801(order);                                 color = k1799(color, i1, c1);     if (!o150(color)) color = k1799(color, i2, c2);     if (!o150(color)) color = k1799(color, i3, c3);                 let rgb = l4194(color);      if (e78(rgb))         rgb = l80(rgb);                   color = r4195(         m146(rgb),         color[0]);           return color; }    function k1799(color, t3721, margin) {     const factor = h4191(color[0]);      margin /= factor[t3721];       const v3726 = [...color];     const j3063 = color[t3721+1];      const d = 0.001;       let q3724  = j3063,          r3725 = j3063;      let u3722  = o150(color);     let  o3723 = u3722;       let j3727 = 1/d*2;       while (   !u3722            && ! o3723            && j3727-- > 0)     {         q3724  -= d;  u3722  = v1800(q3724 , t3721, v3726);          r3725 += d;   o3723 = v1800( r3725, t3721, v3726);     }       j3727 = 1/d*2;     color = [...v3726];       if (u3722)      {          u3722 = o150(color);         q3724     = j3063;          while (   !u3722                && margin > 0                && j3727-- > 0)         {             q3724 -= d;              u3722 = v1800(q3724, t3721, v3726);             margin -= Math.sign(margin) * d;         }          color[t3721+1] = q3724;     }     else if (o3723)     {          o3723 = o150(color);         r3725     = j3063;          while (   !o3723                && margin > 0                && j3727-- > 0)         {             r3725 += d;              o3723 = v1800(r3725, t3721, v3726);             margin -= Math.sign(margin) * d;         }          color[t3721+1] = r3725;     }       return color; }    function v1800(c, t3721, v3726) {     let color = [...v3726];     color[t3721+1] = c;      return o150(color); }    function i1801(order) {     switch (order)     {         case 0: return [0, 1, 2];         case 1: return [1, 0, 2];         case 2: return [1, 2, 0];         case 3: return [0, 2, 1];         case 4: return [2, 0, 1];         case 5: return [2, 1, 0];     }           p953('invalid correction order ' + order);     return [0, 0, 0]; }    function l1802(space, order) {     const [c1, c2, c3] = i1801(order);      let min;      switch (space)     {         case 'hex':         case 'rgb':   min = [0, 0, 0]; break;          case 'hsv':          case 'hsl':   min = [0, 0, 0]; break;          case 'hclok':         case 'hclab':         case 'hcluv': min = [0, 0, 0]; break;          case 'oklab':         case 'lab':         case 'luv':   min = [0, -j4129[1]/2, -j4129[2]/2]; break;                  default:                          p953('invalid validation order ' + order);             return [0, 0, 0];     }      return [min[c1], min[c2], min[c3]]; }    function f1803(space, order) {     const [c1, c2, c3] = i1801(order);      let max;      switch (space)     {         case 'hex':         case 'rgb':   max = [...r4126]; break;          case 'hsv':          case 'hsl':   max = [r4127[0]/2, r4127[1], r4127[2]]; break;          case 'hclok':         case 'hclab':         case 'hcluv': max = [q4128[0]/2, q4128[1], q4128[2]]; break;          case 'oklab':         case 'lab':         case 'luv':   max = [...j4129]; break;                  default:                          p953('invalid validation order ' + order);             return [0, 0, 0];     }      return [max[c1], max[c2], max[c3]]; }    function reorderCorrection(v1807,                            j1808, y1809, s1810,                            y3713,  y3714,  l3715) {     let c1 = { closest: j1808, locked: y3713 };     let c2 = { closest: y1809, locked: y3714 };     let c3 = { closest: s1810, locked: l3715 };      if (   c1.closest <  Epsilon         && c2.closest <  Epsilon         && c3.closest >= Epsilon)     {         switch (v1807)         {             case 0: v1807 = 4; break;             case 1: v1807 = 5; break;             case 2: v1807 = 0; break;             case 3: v1807 = 1; break;             case 4: v1807 = 2; break;             case 5: v1807 = 3; break;         }          const tmp = c2;         c1 = c3;         c2 = c1;         c3 = tmp;     }     else if (c1.closest >= Epsilon           && c2.closest <  Epsilon)     {         switch (v1807)         {             case 0: v1807 = 3; break;             case 1: v1807 = 2; break;             case 2: v1807 = 1; break;             case 3: v1807 = 0; break;             case 4: v1807 = 5; break;             case 5: v1807 = 4; break;         }          const tmp = c2;         c2 = c3;         c3 = tmp;     }     else if (c1.closest < Epsilon)     {         switch (v1807)         {             case 0: v1807 = 2; break;             case 1: v1807 = 3; break;             case 2: v1807 = 4; break;             case 3: v1807 = 5; break;             case 4: v1807 = 0; break;             case 5: v1807 = 1; break;         }          const tmp = c1;         c1 = c2;         c2 = c3;         c3 = tmp;     }       return [         v1807,         c1.closest, c2.closest, c3.closest,         c1.locked,  c2.locked,  c3.locked ]; }    function q1804(g133) {     switch (g133)     {     case 'hex':     case 'rgb':         return [             new q1795('R', r4126[0]),             new q1795('G', r4126[1]),             new q1795('B', r4126[2]) ];      case 'hsv':         return [             new q1795('H', r4127[0]/2),             new q1795('S', r4127[1]),             new q1795('V', r4127[2]) ];      case 'hsl':         return [             new q1795('H', r4127[0]/2),             new q1795('S', r4127[1]),             new q1795('L', r4127[2]) ];      case 'hclok':     case 'hclab':     case 'hcluv':         return [             new q1795('H', q4128[0]/2),             new q1795('C', q4128[1]),             new q1795('L', q4128[2]) ];      case 'oklab':      case 'lab':         return [             new q1795('L', j4129[0]),             new q1795('a', j4129[1]),             new q1795('b', j4129[2]) ];      case 'luv':         return [             new q1795('L', j4129[0]),             new q1795('u', j4129[1]),             new q1795('v', j4129[2]) ];     }       p953('invalid color space ' + g133);     return [         new q1795(),         new q1795(),         new q1795() ]; }


class v1814 extends f2043 {     space   = null;         b3683      = null;    b3684      = null;    n3685      = null;          c1      = null;     c2      = null;     c3      = null;      convert = null;          r3264;        constructor(nodeId, options)     {         super(g1169, nodeId, options);     }                reset()     {         super.reset();                  this.space   = null;                  this.b3683     = null;         this.b3684     = null;         this.n3685     = null;                  this.c1      = null;         this.c2      = null;         this.c3      = null;              this.convert = null;     }        copy()     {         const copy = new v1814(this.nodeId, this.options);          copy.z3358(this);          copy.space = this.space.copy();          if (this.b3683) copy.b3683 = this.b3683.copy();         if (this.b3684) copy.b3684 = this.b3684.copy();         if (this.n3685) copy.n3685 = this.n3685.copy();          if (this. c1) copy. c1 = this. c1.copy();         if (this. c2) copy. c2 = this. c2.copy();         if (this. c3) copy. c3 = this. c3.copy();          if (this.convert)              copy.convert = this.convert.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   space = await evalNumberValue(this.space, parse);          let   c1    = await evalNumberValue(this.b3683,   parse);         let   c2    = await evalNumberValue(this.b3684,   parse);         let   c3    = await evalNumberValue(this.n3685,   parse);          if (space) space = space.f3728();                   if (input)         {             if (input.isValid())             {                 if (this.options.enabled)                 {                     this.value = input.copy();                                           const fromSpaceIndex = input.space.value;                      const toSpaceIndex = Math.min(Math.max(                         0,                         Math.round(space.value)),                          v4125(parse)-1);                       if (toSpaceIndex != fromSpaceIndex)                     {                         this.convertColor(                             this.value,                             g133(fromSpaceIndex),                              g133(  toSpaceIndex));                          this.value.space.value = toSpaceIndex;                     }                                           if (!c1) c1 = this.value.c1;                     if (!c2) c2 = this.value.c2;                     if (!c3) c3 = this.value.c3;                       if (c1) { this.value.c1 = c1; this.c1 = c1; }                     if (c2) { this.value.c2 = c2; this.c2 = c2; }                     if (c3) { this.value.c3 = c3; this.c3 = c3; }                 }                 else                     this.value = input.copy();             }             else                 this.value = s2009.NaN.copy();                               if (!this.convert)                 this.convert = x2021.NaN.copy();         }         else if (space               && c1               && c2               && c3)         {             this.value = new s2009(space, c1, c2, c3);               const toSpaceIndex = Math.min(Math.max(                 0,                 Math.round(this.value.space.value)),                  v4125(parse)-1);              this.value.space.value = toSpaceIndex;               if (    this.convert                 &&  this.convert.isValid()                 &&  this.convert.value > -1                 &&  this.value.isValid()                 && !this.r3264)             {                 await this.convert.eval(parse);                  this.convertColor(                     this.value,                     g133(this.convert.value),                      g133(toSpaceIndex));             }         }         else             this.value = s2009.NaN.copy();           if (!this.value.space.isValid())             this.value = new s2009(                 this.space ? this.space.t3632() : x2021.NaN,                 x2021.NaN,                 x2021.NaN,                 x2021.NaN);           this.e4100(parse,         [             ['convert', this.convert    ],             ['space',   this.value.space],             ['c1',      this.value.c1   ],             ['c2',      this.value.c2   ],             ['c3',      this.value.c3   ]         ]);                                        this.validate();          return this;     }        convertColor(color, fromSpace, n3205)     {         let col = [             fromSpace,              j4175(color.c1.value, fromSpace, 0),             j4175(color.c2.value, fromSpace, 1),             j4175(color.c3.value, fromSpace, 2) ];          col = b4186(r4195(col, n3205));          color.c1.value = col[1];         color.c2.value = col[2];         color.c3.value = col[3];     }        t3632()     {         return this.options.enabled              ? this.value.copy()              : s2009.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.space && this.space.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.space) this.space.g4087(parse);         if (this.b3683  ) this.b3683  .g4087(parse);         if (this.b3684  ) this.b3684  .g4087(parse);         if (this.n3685  ) this.n3685  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.space) this.space.y4088(parse, from, force);         if (this.b3683  ) this.b3683  .y4088(parse, from, force);         if (this.b3684  ) this.b3684  .y4088(parse, from, force);         if (this.n3685  ) this.n3685  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.space) this.space.c4086(parse);         if (this.b3683  ) this.b3683  .c4086(parse);         if (this.b3684  ) this.b3684  .c4086(parse);         if (this.n3685  ) this.n3685  .c4086(parse);     } }


class g1821 extends f2043 {     quality      = null;      corrections  = [];        constructor(nodeId, options)     {         super(c1170, nodeId, options);     }            reset()     {         super.reset();          this.quality     = null;         this.corrections = [];     }        copy()     {         const copy = new g1821(this.nodeId, this.options);          copy.z3358(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.quality) copy.quality = this.quality.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalColorValue (this.input,   parse);         const quality = await evalNumberValue(this.quality, parse);           if (input)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await x2804(parse, this, input.items[i], quality));                 }                 else                     this.value = await x2804(parse, this, input, quality);             }             else                 this.value = input.copy();         }         else             this.value = s2009.NaN.copy();                    this.e4100(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', quality          ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.quality && this.quality.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.quality) this.quality.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.quality) this.quality.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.quality) this.quality.c4086(parse);     } }    async function x2804(parse, node, input, quality) {     let rgb = input.v3241();      if (quality.value == 0)      {         rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);            rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);            rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff);                   return s2009.x3772(rgb);     }     else if (quality.value == 1)      {         rgb = z129(rgb);          rgb[0] = Math.round(rgb[0] * 0xff);         rgb[1] = Math.round(rgb[1] * 0xff);         rgb[2] = Math.round(rgb[2] * 0xff);          return s2009.x3772(rgb);     }     else      {         if (!e78(rgb))             y2076(node.nodeId);                   const inputColor = input.d3240();           const       [ v1807,         j1808,         y1809,         s1810 ] = await z1796(             parse,             node.nodeId,             inputColor,             quality, null,  null,  null,             false,   false, false, false);                       if (!parse.e3640)         {             if (   v1807 >= 0                 && v1807 <  6)             {                 node.f3198 = y1798(                     inputColor,                     v1807,                     j1808,                     y1809,                     s1810);                  return s2009.a2805(node.f3198);             }             else             {                 return s2009.NaN.copy();             }         }     }           return s2009.NaN.copy(); }


class u1820 extends f2043 {     u3682  = null;     b3683     = null;     b3684     = null;     n3685     = null;          order   = null;     c1      = null;     c2      = null;     c3      = null;      corrections = [];        constructor(nodeId, options)     {         super(k1171, nodeId, options);     }            reset()     {         super.reset();          this.u3682  = null;         this.b3683     = null;         this.b3684     = null;         this.n3685     = null;                  this.order   = null;         this.c1      = null;         this.c2      = null;         this.c3      = null;              this.corrections = [];     }        copy()     {         const copy = new u1820(this.nodeId, this.options);          copy.z3358(this);                  if (this.u3682) copy.u3682 = this.order .copy();         if (this.b3683   ) copy.b3683    = this.b3683   .copy();         if (this.b3684   ) copy.b3684    = this.b3684   .copy();         if (this.n3685   ) copy.n3685    = this.n3685   .copy();                  if (this. order) copy. order = this.order .copy();         if (this. c1   ) copy. c1    = this. c1   .copy();         if (this. c2   ) copy. c2    = this. c2   .copy();         if (this. c3   ) copy. c3    = this. c3   .copy();                  if (this.value ) copy. value = this. value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this. input, parse);         let   order = await evalNumberValue(this.u3682, parse);         const c1    = await evalNumberValue(this.b3683,    parse);         const c2    = await evalNumberValue(this.b3684,    parse);         const c3    = await evalNumberValue(this.n3685,    parse);          if (order)          {             order       = order.f3728();             order.value = Math.min(Math.max(0, order.value), 5);         }           if (input)         {             if (this.options.enabled)             {                 const rgb = input.v3241();                                  if (!e78(rgb))                     y2076(this.nodeId);                   const inputColor = input.d3240();                   const               [ v1807,                 j1808,                 y1809,                 s1810 ] = await z1796(                     parse,                     this.nodeId,                     inputColor,                      order, c1, c2, c3,                      this.order != null,                     this.c1    != null,                      this.c2    != null,                      this.c3    != null);                                        if (    !parse.e3640)                 {                     if (   v1807 >= 0                          && v1807 <  6)                     {                         this.f3198 = y1798(                             inputColor,                             v1807,                             j1808,                             y1809,                             s1810);                                                       this.order = new x2021(v1807);                         this.c1    = new x2021(j1808);                         this.c2    = new x2021(y1809);                         this.c3    = new x2021(s1810);                                                   this.value = s2009.a2805(this.f3198);                          this.value.c1.decimals = input.c1.decimals;                         this.value.c2.decimals = input.c2.decimals;                         this.value.c3.decimals = input.c3.decimals;                           this.e4100(parse,                         [                             ['order', new x2021(v1807, 0)],                             ['c1',    new x2021(j1808,     1)],                             ['c2',    new x2021(y1809,     1)],                             ['c3',    new x2021(s1810,     1)],                             ['value', this.value                      ]                         ]);                     }                     else                     {                         this.order = x2021.NaN.copy();                         this.c1    = x2021.NaN.copy();                         this.c2    = x2021.NaN.copy();                         this.c3    = x2021.NaN.copy();                         this.value = input.copy();                                  this.e4100(parse,                         [                             ['order', this.order],                             ['c1',    this.c1   ],                             ['c2',    this.c2   ],                             ['c3',    this.c3   ],                             ['value', this.value]                         ]);                     }                 }                 else                 {                     this.order = x2021.NaN.copy();                     this.c1    = x2021.NaN.copy();                     this.c2    = x2021.NaN.copy();                     this.c3    = x2021.NaN.copy();                     this.value = input.copy();                          this.e4100(parse,                     [                         ['order', this.order],                         ['c1',    this.c1   ],                         ['c2',    this.c2   ],                         ['c3',    this.c3   ],                         ['value', this.value]                     ]);                 }             }             else             {                 this.order = x2021.NaN.copy();                 this.c1    = x2021.NaN.copy();                 this.c2    = x2021.NaN.copy();                 this.c3    = x2021.NaN.copy();                 this.value = input.copy();                  this.e4100(parse,                 [                     ['order', this.order],                     ['c1',    this.c1   ],                     ['c2',    this.c2   ],                     ['c3',    this.c3   ],                     ['value', this.value]                 ]);             }         }         else         {             this.order = x2021.NaN.copy();             this.c1    = x2021.NaN.copy();             this.c2    = x2021.NaN.copy();             this.c3    = x2021.NaN.copy();             this.value = s2009 .NaN.copy();              this.e4100(parse,             [                 ['order', x2021.NaN],                 ['c1',    x2021.NaN],                 ['c2',    x2021.NaN],                 ['c3',    x2021.NaN],                 ['value', s2009 .NaN]             ]);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order && this.order.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.u3682) this.u3682.g4087(parse);         if (this.b3683   ) this.b3683   .g4087(parse);         if (this.b3684   ) this.b3684   .g4087(parse);         if (this.n3685   ) this.n3685   .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.u3682) this.u3682.y4088(parse, from, force);         if (this.b3683   ) this.b3683   .y4088(parse, from, force);         if (this.b3684   ) this.b3684   .y4088(parse, from, force);         if (this.n3685   ) this.n3685   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.u3682) this.u3682.c4086(parse);         if (this.b3683   ) this.b3683   .c4086(parse);         if (this.b3684   ) this.b3684   .c4086(parse);         if (this.n3685   ) this.n3685   .c4086(parse);     } } 


class y1817 extends k2044 {     standard = null;     contrast = null;       constructor(nodeId, options)     {         super(w1173, nodeId, options);     }        reset()     {         super.reset();          this.standard = null;         this.contrast = null;     }        copy()     {         const copy = new y1817(this.nodeId, this.options);          copy.z3358(this);          if (this.standard) copy.standard = this.standard.copy();         if (this.contrast) copy.contrast = this.contrast.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082   = await evalColorValue (this.b4082,   parse);         const o4083   = await evalColorValue (this.o4083,   parse);         const standard = await evalNumberValue(this.standard, parse);                   if (standard.isValid())             standard.value = Math.min(Math.max(0, standard.value), 1);           if (   b4082              && o4083)         {             if (   b4082.isValid()                 && o4083.isValid())             {                 if (   t149(b4082.d3240())                     && t149(o4083.d3240()))                 {                     if (standard.value == 0)                     {                         const value = k157(b4082.v3241(), o4083.v3241());                         this.contrast = new x2021(value, 2);                     }                     else                     {                         const value = h161(b4082.v3241(), o4083.v3241());                         this.contrast = new x2021(value, 1);                     }                 }                 else                     this.contrast = x2021.NaN.copy();             }             else                 this.contrast = x2021.NaN.copy();               this.value =                  b4082                  ? b4082                 : s2009.NaN.copy();               this.e4100(parse,             [                 ['text', b4082],                 ['back', o4083]             ]);         }          else if (b4082)          {             this.e4100(parse,             [                 ['text', b4082.isValid() ? b4082 : s2009.NaN],                 ['back', s2009.NaN                            ]             ]);                          this.value    = b4082;             this.contrast = x2021.NaN.copy();         }          else if (o4083)          {             this.e4100(parse,             [                 ['text', s2009.NaN                            ],                 ['back', o4083.isValid() ? o4083 : s2009.NaN]             ]);              this.value    = s2009 .NaN.copy();             this.contrast = x2021.NaN.copy();         }          else         {             this.value    = s2009 .NaN.copy();             this.contrast = x2021.NaN.copy();              this.e4100(parse,             [                 ['text', s2009.NaN],                 ['back', s2009.NaN]             ]);         }                    this.e4100(parse,         [             ['standard', standard     ],             ['contrast', this.contrast]         ],         true);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.standard && this.standard.isValid()             && (!this.contrast || this.contrast.isValid());     }        g4087(parse)     {         super.g4087(parse);          if (this.standard) this.standard.g4087(parse);         if (this.contrast) this.contrast.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.standard) this.standard.y4088(parse, from, force);         if (this.contrast) this.contrast.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.standard) this.standard.c4086(parse);         if (this.contrast) this.contrast.c4086(parse);     } } 


class e1819 extends f2043 {     from = null;        constructor(nodeId, options)     {         super(b1172, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new e1819(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();         if (this.from ) copy.from  = this.from .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         let   from  = await evalNumberValue(this.from,  parse);          if (from) from = from.f3728();                   if (input)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await getConvertP3Value(input.items[i], from));                 }                 else                     this.value = await getConvertP3Value(input, from);             }             else                 this.value = input.copy();         }         else             this.value = s2009.NaN.copy();                    this.e4100(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', from             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.from) this.from.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.from) this.from.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.from) this.from.c4086(parse);     } }    function getConvertP3Value(input, from) {     return s2009.x3772(         from.value == 0         ? w4141(i61(input.v3241()))         : w4141(k62(input.v3241()))); }


class k1816 extends f2043 {     l;     m;     s;       constructor(nodeId, options)     {         super(z1174, nodeId, options);     }            reset()     {         super.reset();          this.l = null;         this.m = null;         this.s = null;     }        copy()     {         const copy = new k1816(this.nodeId, this.options);          copy.z3358(this);          if (this.l) copy.l = this.l.copy();         if (this.m) copy.m = this.m.copy();         if (this.s) copy.s = this.s.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalColorValue (this.input, parse);         const l     = await evalNumberValue(this.l,     parse);          const m     = await evalNumberValue(this.m,     parse);         const s     = await evalNumberValue(this.s,     parse);           if (input)         {             if (this.options.enabled)             {                 if (h957(input.type))                 {                     this.value = new b2020();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getColorBlindValue(input.items[i], l, m, s));                 }                 else                     this.value = getColorBlindValue(input, l, m, s);             }             else                 this.value = input.copy();         }         else             this.value = s2009.NaN.copy();           this.e4100(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['l',      l                ],             ['m',      m                ],             ['s',      s                ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l && this.l.isValid()             && this.m && this.m.isValid()             && this.s && this.s.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.l) this.l.g4087(parse);         if (this.m) this.m.g4087(parse);         if (this.s) this.s.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.l) this.l.y4088(parse, from, force);         if (this.m) this.m.y4088(parse, from, force);         if (this.s) this.s.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.l) this.l.c4086(parse);         if (this.m) this.m.c4086(parse);         if (this.s) this.s.c4086(parse);     } }    function getColorBlindValue(input, l, m, s) {     const rgb   = input.v3241();      const rgbCb = h134(         rgb,         l.value / 2,         m.value / 2,         s.value / 2);      if (   !k73(rgb  )         && !k73(rgbCb))     {         const validRgbCb = rgbCb;              const validCol = r4195(             m146(validRgbCb),              g133(input.space.value));          return s2009.a2805(validCol);     }     else         return s2009.NaN.copy(); }


class h1818 extends k2044 {     space;     amount;     gamma;       constructor(nodeId, options)     {         super(m1175, nodeId, options);     }            reset()     {         super.reset();          this.space  = null;         this.amount = null;         this.gamma  = null;     }        copy()     {         const copy = new h1818(this.nodeId, this.options);          copy.z3358(this);          if (this.space ) copy.space  = this.space .copy();         if (this.amount) copy.amount = this.amount.copy();         if (this.gamma ) copy.gamma  = this.gamma .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082 = await evalColorValue (this.b4082, parse);         const o4083 = await evalColorValue (this.o4083, parse);         let   space  = await evalNumberValue(this.space,  parse);         const amount = await evalNumberValue(this.amount, parse);         const gamma  = await evalNumberValue(this.gamma,  parse);          if (space) space = space.f3728();                   if (   b4082              && o4083)         {             g952(                 amount.type == n1091,                  'this.result.type must be NUMBER_VALUE');              const f = amount.value / 100;               const spaceIndex = Math.min(Math.max(0, space.value), v4125()-1);             const gammaValue = Math.max(0.0001, gamma.value);              const _space = g133(spaceIndex);              const f3198 = this.interpolate(                 spaceIndex,                 r4195(b4082.d3240(), _space),                 r4195(o4083.d3240(), _space),                 f,                 gammaValue);                                          this.value = s2009.a2805(f3198, spaceIndex);         }          else if (b4082)              this.value = b4082;          else if (o4083)              this.value = o4083;                      else              this.value = s2009.NaN.copy();           this.e4100(parse,         [             ['space',  space     ],             ['amount', amount    ],             ['gamma',  gamma     ],             ['value',  this.value]         ]);                   this.validate();                  return this;     }        interpolate(space, col0, l103, f, gamma)     {         if (   space <= 1             || space >  6)          {             gamma = Math.max(0.01, gamma);              const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);               const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);               const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);                const r1 = Math.sign(l103[1]) * Math.pow(Math.abs(l103[1]), gamma);             const g1 = Math.sign(l103[2]) * Math.pow(Math.abs(l103[2]), gamma);             const b1 = Math.sign(l103[3]) * Math.pow(Math.abs(l103[3]), gamma);              const r = x1035(r0, r1, f);                     const g = x1035(g0, g1, f);                         const b = x1035(b0, b1, f);                      return [                 g133(space),                 Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),                 Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),                 Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];         }         else          {             const h0 = col0[1] * Tau;  const h1 = l103[1] * Tau;             const c0 = col0[2];        const c1 = l103[2];             const l0 = col0[3];        const l1 = l103[3];              return [                 g133(space),                 m1038(h0 + a887(h0, h1) * f) / Tau,                 x1035(c0, c1, f),                 x1035(l0, l1, f) ];         }     }        isValid()     {         return super.isValid()             && this.space  && this.space .isValid()             && this.amount && this.amount.isValid()             && this.gamma  && this.gamma .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.space ) this.space .g4087(parse);         if (this.amount) this.amount.g4087(parse);         if (this.gamma ) this.gamma .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.space ) this.space .y4088(parse, from, force);         if (this.amount) this.amount.y4088(parse, from, force);         if (this.gamma ) this.gamma .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.space ) this.space .c4086(parse);         if (this.amount) this.amount.c4086(parse);         if (this.gamma ) this.gamma .c4086(parse);     } } 


class s1815 extends k2044 {     mode    = null;     opacity = null;           constructor(nodeId, options)     {         super(v1176, nodeId, options);     }            reset()     {         super.reset();          this.mode    = null;         this.opacity = null;     }        copy()     {         const copy = new s1815(this.nodeId, this.options);          copy.z3358(this);          if (this.mode   ) copy.mode    = this.mode   .copy();         if (this.opacity) copy.opacity = this.opacity.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082  = await evalColorValue (this.b4082,  parse);         const o4083  = await evalColorValue (this.o4083,  parse);         let   mode    = await evalNumberValue(this.mode,    parse);         const opacity = await evalNumberValue(this.opacity, parse);                  if (mode) mode = mode.f3728();           if (   b4082              && o4083)         {             g952(                 opacity.type == n1091,                  'this.result.type must be NUMBER_VALUE');              const c3771 = opacity.value / 100;              const n3770 = Math.min(Math.max(0, mode.value), r1393.length-1);               const col = this.blend(                 n3770,                 b4082.v3241(),                 o4083.v3241(),                 c3771);              this.value = s2009.x3772(w4141(col));         }          else if (b4082)              this.value = b4082;          else if (this.o4083)              this.value = o4083;                      else              this.value = s2009.NaN.copy();           this.e4100(parse,         [             ['value',   this.value],             ['mode',    mode      ],             ['opacity', opacity   ]         ]);           this.validate();                  return this;     }        blend(mode, col0, l103, opacity)     {         switch (mode)         {             case  0: return e4247    (col0, l103, opacity);              case  1: return r4248    (col0, l103, opacity);             case  2: return k4249  (col0, l103, opacity);             case  3: return o4250 (col0, l103, opacity);              case  4: return h4251   (col0, l103, opacity);             case  5: return e4252    (col0, l103, opacity);             case  6: return y4254(col0, l103, opacity);              case  7: return l4256   (col0, l103, opacity);             case  8: return n4257 (col0, l103, opacity);             case  9: return r4259 (col0, l103, opacity);              case 10: return x4261(col0, l103, opacity);             case 11: return o4262 (col0, l103, opacity);              case 12: return s4264       (col0, l103, opacity);             case 13: return a4265(col0, l103, opacity);             case 14: return x4266     (col0, l103, opacity);             case 15: return w4267(col0, l103, opacity);         }     }        isValid()     {         return super.isValid()             && this.mode    && this.mode   .isValid()             && this.opacity && this.opacity.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.mode   ) this.mode   .g4087(parse);         if (this.opacity) this.opacity.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.mode   ) this.mode   .y4088(parse, from, force);         if (this.opacity) this.opacity.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.mode   ) this.mode   .c4086(parse);         if (this.opacity) this.opacity.c4086(parse);     } } 


function e4247(col, back, opacity) {     return [ col[0] * opacity + back[0] * (1 - opacity),              col[1] * opacity + back[1] * (1 - opacity),              col[2] * opacity + back[2] * (1 - opacity) ]; }    function r4248(col, back, opacity) {     return e4247(         [ Math.min(back[0], col[0]),           Math.min(back[1], col[1]),           Math.min(back[2], col[2]) ],         back,         opacity); }    function chanMultiply(c, b) {     return c * b; }    function k4249(col, back, opacity) {     return e4247(         [ chanMultiply(col[0], back[0]),           chanMultiply(col[1], back[1]),           chanMultiply(col[2], back[2]) ],         back,         opacity); }    function chanColorBurn(c, b) {          if (b == 1) return 1;     else if (c == 0) return 0;     else             return 1 - Math.min((1 - b) / c, 1); }    function o4250(col, back, opacity) {     return e4247(          [ chanColorBurn(col[0], back[0]),            chanColorBurn(col[1], back[1]),            chanColorBurn(col[2], back[2]) ],         back,         opacity); }    function h4251(col, back, opacity) {     return e4247(         [ Math.max(back[0], col[0]),           Math.max(back[1], col[1]),           Math.max(back[2], col[2]) ],         back,         opacity); }    function r4253(c, b) {     return b + c - b*c; }    function e4252(col, back, opacity) {     return e4247(         [ r4253(col[0], back[0]),           r4253(col[1], back[1]),           r4253(col[2], back[2]) ],         back,         opacity); }    function v4255(c, b) {          if (b == 0) return 0;     else if (c == 1) return 1;     else             return Math.min(b / (1 - c), 1); }    function y4254(col, back, opacity) {     return e4247(         [ v4255(col[0], back[0]),           v4255(col[1], back[1]),           v4255(col[2], back[2]) ],         back,         opacity); }    function l4256(col, back, opacity) {     return e4247(         [ l4260(back[0], col[0]),           l4260(back[1], col[1]),           l4260(back[2], col[2]) ],         back,         opacity); }    function v2806(b) {     return b <= 0.25          ? ((16 * b - 12) * b + 4) * b          : Math.sqrt(b); }    function z4258(c, b) {     return c <= 0.5          ? b - (1 - 2*c) * b * (1 - b)          : b + (2*c - 1) * (v2806(b) - b); }    function n4257(col, back, opacity) {     return e4247(         [ z4258(col[0], back[0]),           z4258(col[1], back[1]),           z4258(col[2], back[2]) ],         back,         opacity); }    function l4260(c, b) {     if (c <= 0.5) return chanMultiply(b, 2 * c);     else          return r4253(b, 2 * c - 1); }    function r4259(col, back, opacity) {     return e4247(         [ l4260(col[0], back[0]),           l4260(col[1], back[1]),           l4260(col[2], back[2]) ],         back,         opacity); }    function x4261(col, back, opacity) {     return [ Math.abs(back[0] - col[0]),              Math.abs(back[1] - col[1]),              Math.abs(back[2] - col[2]) ]; }    function a4263(c, b) {     return b + c - 2*b*c; }    function o4262(col, back, opacity) {     return e4247(         [ a4263(col[0], back[0]),           a4263(col[1], back[1]),           a4263(col[2], back[2]) ],         back,         opacity); }    function j2807(col) {     return col[0] * 0.30          + col[1] * 0.59          + col[2] * 0.11; }    function m2808(z127, l) {     const col = [...z127];      const d = l - j2807(col);      col[0] += d;     col[1] += d;     col[2] += d;      return q2816(col); }    function h2809(col) {     return Math.max(col[0], col[1], col[2])           - Math.min(col[0], col[1], col[2]); }    function e2810(col) {          if (col[0] <= col[1]            && col[0] <= col[2]) return 0;     else if (col[1] <= col[1]            && col[1] <= col[2]) return 1;     else                       return 2; }    function i2811(col) {          if (   col[0] >= col[1]               && col[0] <= col[2]           ||    col[0] <= col[1]               && col[0] >= col[2]) return 0;     else if (   col[1] >= col[0]               && col[1] <= col[2]           ||    col[1] <= col[0]               && col[1] >= col[2]) return 1;     else                          return 2; }    function u2812(col) {          if (col[0] >= col[1]            && col[0] >= col[2]) return 0;     else if (col[1] >= col[1]            && col[1] >= col[2]) return 1;     else                       return 2; }    function e2813(col)  {     if (   col[0] == col[1]          && col[0] == col[2])         return [0, 1, 2];      else          return [             e2810(col),              i2811(col),              u2812(col)]; }    function k2814(z127, s) {     const col       = [...z127];     const [n, d, x] = e2813(col);      if (col[x] > col[n])     {         col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));         col[x] = s;     }     else         col[d] = col[x] = 0;      col[n] = 0;      return col; }    function r2815(c, l, n, x) {          if (n < 0) return l + (((c - l) * l) / (l - n));     else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));     else            return c; }    function q2816(col) {     const l   = j2807(col);      const n = Math.min(col[0], col[1], col[2]);     const x = Math.max(col[0], col[1], col[2]);      return [ r2815(col[0], l, n, x),              r2815(col[1], l, n, x),              r2815(col[2], l, n, x) ]; }    function s4264(col, back, opacity) {     return e4247(         m2808(k2814(col, h2809(back)), j2807(back)),         back,         opacity); }    function a4265(col, back, opacity) {     return e4247(         m2808(k2814(back, h2809(col)), j2807(back)),         back,         opacity); }    function x4266(col, back, opacity) {     return e4247(         m2808(col, j2807(back)),         back,         opacity); }    function w4267(col, back, opacity) {     return e4247(         m2808(back, j2807(col)),         back,         opacity); }


class t1886 extends y2042 {     id;      colorStyle;     m2817;           linked;        constructor(nodeId, options, styleId)     {         super(d1216, nodeId, options);          this.id == styleId;     }        copy()     {         const copy = new t1886(this.nodeId, this.options);          copy.id = this.id;          if (this.colorStyle) copy.colorStyle = this.colorStyle.copy();         if (this.m2817  ) copy.m2817   = this.m2817  .copy();                         copy.linked   = this.linked;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value = await evalColorValue(this.m2817, parse);           if (   this.value.isValid()             && this.linked)                                   {             if (this.value.type == l1168)                 this.value = q2012.x3772(w4141(this.value.v3241()), 0xff);              const rgba       = this.value.x99();             const k3260 = v100(h120(rgba), rgba[3]);              this.evalStyle({rgba: k3260});         }         else             this.value = q2012.NaN.copy();           this.e4100(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalStyle(options = {})     {         if (!this.options.enabled)             return;                       const colorStyle = new l1838(this.nodeId, this.id, this.name);                     colorStyle.paints =          [             [ 'SOLID',                        Math.round(options.rgba[0] * 0xff)               + ' ' + Math.round(options.rgba[1] * 0xff)               + ' ' + Math.round(options.rgba[2] * 0xff)               + ' ' + Math.round(options.rgba[3] * 100 ) ]         ];           this.colorStyle = colorStyle;     }        isValid()     {         return this.m2817 && this.m2817.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.m2817) this.m2817.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.m2817) this.m2817.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.m2817) this.m2817.c4086(parse);     } }


class w1888 extends f2043 {     color   = null;     opacity = null;     blend   = null;        constructor(nodeId, options)     {         super(l1179, nodeId, options);     }        reset()     {         super.reset();          this.color   = null;         this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new w1888(this.nodeId, this.options);          copy.z3358(this);          if (this.color  ) copy.color   = this.color  .copy();         if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'color':   return this.input ? this.value.color   : this.color;             case 'opacity': return this.input ? this.value.opacity : this.opacity;             case 'blend':   return this.input ? this.value.blend   : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalFillValue  (this.input,   parse);         let   color   = await evalColorValue (this.color,   parse);         let   opacity = await evalNumberValue(this.opacity, parse);         let   blend   = await evalNumberValue(this.blend,   parse);           if (input)         {             this.value = new q2012(                 color   ?? input.color,                 opacity ?? input.opacity,                 blend   ?? input.blend);         }         else if ((!color   || color  .type == l1168 )               && (!opacity || opacity.type == n1091)               && (!blend   || blend  .type == n1091))         {             this.value = new q2012(                 color,                  opacity,                 blend);         }         else             this.value = q2012.NaN.copy();           this.e4100(parse,         [             ['value',   this.value],             ['color',   color     ],             ['opacity', opacity   ],             ['blend',   blend     ]         ]);                                                this.validate();          return this;     }        t3632()     {         return this.options.enabled             ? new q2012(                 this.color   ? this.color  .t3632() : this.input.value.color  .t3632(),                 this.opacity ? this.opacity.t3632() : this.input.value.opacity.t3632(),                 this.blend   ? this.blend  .t3632() : this.input.value.blend  .t3632())             : q2012.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.color   && this.color  .isValid()             && this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.color  ) this.color  .g4087(parse);         if (this.opacity) this.opacity.g4087(parse);         if (this.blend  ) this.blend  .g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.color  ) this.color  .y4088(parse, from, force);         if (this.opacity) this.opacity.y4088(parse, from, force);         if (this.blend  ) this.blend  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.color  ) this.color  .c4086(parse);         if (this.opacity) this.opacity.c4086(parse);         if (this.blend  ) this.blend  .c4086(parse);     } }


class r1885 extends f2043 {     fill     = null;     position = null;        constructor(nodeId, options)     {         super(a1185, nodeId, options);     }        reset()     {         super.reset();          this.fill     = null;         this.position = null;     }        copy()     {         const copy = new r1885(this.nodeId, this.options);          copy.z3358(this);          if (this.fill    ) copy.fill     = this.fill    .copy();         if (this.position) copy.position = this.position.copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'fill':      return this.input ? this.value.fill     : this.fill;             case 'position':  return this.input ? this.value.position : this.position;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                                     const input    = await evalColorStopValue(this.input,    parse);         let   fill     = await evalFillValue     (this.fill,     parse);         const position = await evalNumberValue   (this.position, parse);                  fill = this.validateFill(fill);           if (input)         {             this.value = new v2008(                    fill                  && fill.type != y1178                      ? fill                      : input.fill,                 position ?? input.position);         }         else         {             this.value = new v2008(                 fill,                  position);         }           this.e4100(parse,          [             ['value', this.value]         ]);                   if (!this.fill    ) this.fill     = this.value.fill    .copy();         if (!this.position) this.position = this.value.position.copy();           this.validate();          return this;     }        validateFill(fill)     {         if (!fill)             return null;           if (fill.type == l1168)             return q2012.x3772(w4141(fill.v3241()), 100);         else             return fill;     }        t3632()     {         return new v2008(             this.options.enabled             ? this.validateFill(this.fill ? this.fill.t3632() : this.input.fill.t3632())             : q2012.NaN,             this.position ? this.position.t3632() : this.input.position.t3632());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fill     && this.fill    .isValid()             && this.position && this.position.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.fill    ) this.fill    .g4087(parse);         if (this.position) this.position.g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.fill    ) this.fill    .y4088(parse, from, force);         if (this.position) this.position.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.fill    ) this.fill    .c4086(parse);         if (this.position) this.position.c4086(parse);     } }


class n1889 extends y2042 {     inputs = [];      u3686 = null;     position = null;     x        = null;     y        = null;     size     = null;     angle    = null;     aspect   = null;     skew     = null;     blend    = null;          diagAspect;                constructor(nodeId, options)     {         super(e1188, nodeId, options);     }                    reset()     {         super.reset();                  this.inputs = [];              this.u3686 = null;         this.position = null;         this.x        = null;         this.y        = null;         this.size     = null;         this.angle    = null;         this.aspect   = null;         this.skew     = null;         this.blend    = null;     }        copy()     {         const copy = new n1889(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.u3686) copy.u3686 = this.x       .copy();         if (this.position) copy.position = this.position.copy();         if (this.x       ) copy.x        = this.x       .copy();         if (this.y       ) copy.y        = this.y       .copy();         if (this.size    ) copy.size     = this.size    .copy();         if (this.angle   ) copy.angle    = this.angle   .copy();         if (this.aspect  ) copy.aspect   = this.aspect  .copy();         if (this.skew    ) copy.skew     = this.skew    .copy();         if (this.blend   ) copy.blend    = this.blend   .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'gradType':  return this.input ? this.value.u3686 : this.u3686;             case 'position':  return this.input ? this.value.position : this.position;             case 'x':         return this.input ? this.value.x        : this.x;             case 'y':         return this.input ? this.value.y        : this.y;             case 'size':      return this.input ? this.value.size     : this.size;             case 'angle':     return this.input ? this.value.angle    : this.angle;             case 'aspect':    return this.input ? this.value.aspect   : this.aspect;             case 'skew':      return this.input ? this.value.skew     : this.skew;             case 'blend':     return this.input ? this.value.blend    : this.blend;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                       let u3686 = await evalNumberValue(this.u3686, parse);         let position = await evalNumberValue(this.position, parse);         let x        = await evalNumberValue(this.x,        parse);         let y        = await evalNumberValue(this.y,        parse);         let size     = await evalNumberValue(this.size,     parse);         let angle    = await evalNumberValue(this.angle,    parse);         let aspect   = await evalNumberValue(this.aspect,   parse);         let skew     = await evalNumberValue(this.skew,     parse);         let blend    = await evalNumberValue(this.blend,    parse);           if (position) position.value = Math.min(Math.max(0, Math.floor(position.value)), 4);         if (blend   ) blend   .value = Math.min(Math.max(0, Math.floor(blend   .value)), r1393.length-1);           let stops = new b2020();           const inputs = [];                  for (const input of this.inputs)             inputs.push(await evalValue(input, parse));           if (   inputs.length == 1             && inputs[0].type == m1187)         {             this.value        = inputs[0].t3632();             this.value.nodeId = this.nodeId;             this.value.i3625(inputs[0]);              if (u3686)  this.value.u3686 = u3686;  else  u3686 = this.value.u3686;                   if (position)  this.value.position = position;  else  position = this.value.position;                   if (x       )  this.value.x        = x;         else  x        = this.value.x;                   if (y       )  this.value.y        = y;         else  y        = this.value.y;                   if (size    )  this.value.size     = size;      else  size     = this.value.size;                   if (angle   )  this.value.angle    = angle;     else  angle    = this.value.angle;                   if (aspect  )  this.value.aspect   = aspect;    else  aspect   = this.value.aspect;                   if (skew    )  this.value.skew     = skew;      else  skew     = this.value.skew;                   if (blend   )  this.value.blend    = blend;     else  blend    = this.value.blend;               }         else         {             for (let i = 0, o = 0; i < inputs.length; i++)             {                 const input = inputs[i];                  if (   input                     && this.options.enabled)                 {                     if (h957(input.type))                     {                         for (const item of input.items)                             if (item.isValid())                                 stops.items.push(item);                     }                     else if (input.type == m1187)                     {                         for (const item of input.stops.items)                             stops.items.push(item);                     }                     else                         if (input.isValid())                             stops.items.push(input);                 }             }               stops.items = r1826(stops.items);              e1828(stops.items);               this.value = new a2014(                 stops,                 u3686,                 position,                 x,                  y,                  size,                  angle,                  aspect,                 this.diagAspect,                 skew,                 blend);         }                   this.e4100(parse,         [             ['value',    this.value],             ['gradType', u3686  ],             ['position', position  ],             ['x',        x         ],             ['y',        y         ],             ['size',     size      ],             ['angle',    angle     ],             ['aspect',   aspect    ],             ['skew',     skew      ],             ['blend',    blend     ]         ]);                   if (   inputs.length == 1             && inputs[0].type == m1187)         {             if (!this.u3686) this.u3686 = this.value.u3686.copy();             if (!this.position) this.position = this.value.position.copy();             if (!this.x       ) this.x        = this.value.x       .copy();             if (!this.y       ) this.y        = this.value.y       .copy();             if (!this.size    ) this.size     = this.value.size    .copy();             if (!this.angle   ) this.angle    = this.value.angle   .copy();             if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();             if (!this.skew    ) this.skew     = this.value.skew    .copy();             if (!this.blend   ) this.blend    = this.value.blend   .copy();         }           this.validate();          return this;     }                t3632()     {         return this.value.copy();     }                         isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.u3686 && this.u3686.isValid()             && this.position && this.position.isValid()             && this.x        && this.x       .isValid()             && this.y        && this.y       .isValid()             && this.size     && this.size    .isValid()             && this.angle    && this.angle   .isValid()             && this.aspect   && this.aspect  .isValid()             && this.skew     && this.skew    .isValid()             && this.blend    && this.blend   .isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.u3686) this.u3686.g4087(parse);         if (this.position) this.position.g4087(parse);         if (this.x       ) this.x       .g4087(parse);         if (this.y       ) this.y       .g4087(parse);         if (this.size    ) this.size    .g4087(parse);         if (this.angle   ) this.angle   .g4087(parse);         if (this.aspect  ) this.aspect  .g4087(parse);         if (this.skew    ) this.skew    .g4087(parse);         if (this.blend   ) this.blend   .g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));                  if (this.u3686) this.u3686.y4088(parse, from, force);         if (this.position) this.position.y4088(parse, from, force);         if (this.x       ) this.x       .y4088(parse, from, force);         if (this.y       ) this.y       .y4088(parse, from, force);         if (this.size    ) this.size    .y4088(parse, from, force);         if (this.angle   ) this.angle   .y4088(parse, from, force);         if (this.aspect  ) this.aspect  .y4088(parse, from, force);         if (this.skew    ) this.skew    .y4088(parse, from, force);         if (this.blend   ) this.blend   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.u3686) this.u3686.c4086(parse);         if (this.position) this.position.c4086(parse);         if (this.x       ) this.x       .c4086(parse);         if (this.y       ) this.y       .c4086(parse);         if (this.size    ) this.size    .c4086(parse);         if (this.angle   ) this.angle   .c4086(parse);         if (this.aspect  ) this.aspect  .c4086(parse);         if (this.skew    ) this.skew    .c4086(parse);         if (this.blend   ) this.blend   .c4086(parse);     }     }


class d1895 extends f2043 {     fills  = null;    y3674  = null;      weight = null;     fit    = null;     join   = null;     miter  = null;     cap    = null;     dashes = null;                constructor(nodeId, options)     {         super(q1182, nodeId, options);     }                reset()     {         super.reset();                  this. fills  = null;         this.y3674  = null;          this. weight = null;         this. fit    = null;         this. join   = null;         this. miter  = null;         this. cap    = null;         this. dashes = null;     }        copy()     {         const copy = new d1895(this.nodeId, this.options);          copy.z3358(this);          if (this.fills ) copy. fills  = this.fills .copy();         if (this.y3674) copy.y3674  = this.y3674.copy();         if (this.weight) copy. weight = this.weight.copy();         if (this.fit   ) copy. fit    = this.fit   .copy();         if (this.join  ) copy. join   = this.join  .copy();         if (this.miter ) copy. miter  = this.miter .copy();         if (this.cap   ) copy. cap    = this.cap   .copy();         if (this.dashes) copy. dashes = this.dashes.copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'fills ':  return this.input ? this.value.fills  : this.fills;             case 'weight':  return this.input ? this.value.weight : this.weight;             case 'fit':     return this.input ? this.value.fit    : this.fit;             case 'join':    return this.input ? this.value.join   : this.join;             case 'miter':   return this.input ? this.value.miter  : this.miter;             case 'cap':     return this.input ? this.value.cap    : this.cap;             case 'dashes':  return this.input ? this.value.dashes : this.dashes;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;          const input = await evalStrokeValue(this. input, parse);         let   fills = await evalListValue  (this.y3674, parse);          fills = this.validateFills(fills);          if (!h957(this.y3674.type))             this.fills = fills;           const weight = await evalNumberValue(this.weight, parse);         const fit    = await evalNumberValue(this.fit,    parse);         const join   = await evalNumberValue(this.join,   parse);         const miter  = await evalNumberValue(this.miter,  parse);         const cap    = await evalNumberValue(this.cap,    parse);         const dashes = await evalTextValue  (this.dashes, parse);           if (input)         {             this.value = new l2030(                 fills  ?? input.fills,                 weight ?? input.weight,                 fit    ?? input.fit,                 join   ?? input.join,                 miter  ?? input.miter,                 cap    ?? input.cap,                 dashes ?? input.dashes);         }         else         {             this.value = new l2030(                 fills,                  weight,                  fit,                  join,                 miter,                 cap,                 dashes);         }           this.e4100(parse,         [             ['value',  this.value],             ['fills',  fills     ],             ['weight', weight    ],             ['fit',    fit       ],             ['join',   join      ],             ['miter',  miter     ],             ['cap',    cap       ],             ['dashes', dashes    ]         ]);           this.validate();          return this;     }        validateFills(fills)     {                     if (!fills)             return null;          if (fills.type == l1168)             return new b2020([q2012.x3772(w4141(fills.v3241()), 100)]);          else if (fills.type ==     y1178               || fills.type == m1187)             return new b2020([fills]);         else         {             g952(fills.type == q1056, 'stroke.fills must be a LIST_VALUE');             return fills;         }     }        t3632()     {         return new l2030(             this.options.enabled             ? this.validateFills(this.fills ? this.fills.t3632() : this.input.fills.t3632())             : new b2020(),             this.weight ? this.weight.t3632() : this.input.weight.t3632(),             this.fit    ? this.fit   .t3632() : this.input.fit   .t3632(),             this.join   ? this.join  .t3632() : this.input.join  .t3632(),             this.miter  ? this.miter .t3632() : this.input.miter .t3632(),             this.cap    ? this.cap   .t3632() : this.input.cap   .t3632(),             this.dashes ? this.dashes.t3632() : this.input.dashes.t3632());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fills  && this.fills .isValid()             && this.weight && this.weight.isValid()             && this.fit    && this.fit   .isValid()             && this.join   && this.join  .isValid()             && this.miter  && this.miter .isValid()             && this.cap    && this.cap   .isValid()             && this.dashes && this.dashes.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.y3674) this.y3674.g4087(parse);         if (this.weight) this.weight.g4087(parse);         if (this.fit   ) this.fit   .g4087(parse);         if (this.join  ) this.join  .g4087(parse);         if (this.miter ) this.miter .g4087(parse);         if (this.cap   ) this.cap   .g4087(parse);         if (this.dashes) this.dashes.g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.y3674) this.y3674.y4088(parse, from, force);         if (this.weight) this.weight.y4088(parse, from, force);         if (this.fit   ) this.fit   .y4088(parse, from, force);         if (this.join  ) this.join  .y4088(parse, from, force);         if (this.miter ) this.miter .y4088(parse, from, force);         if (this.cap   ) this.cap   .y4088(parse, from, force);         if (this.dashes) this.dashes.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.y3674) this.y3674.c4086(parse);         if (this.weight) this.weight.c4086(parse);         if (this.fit   ) this.fit   .c4086(parse);         if (this.join  ) this.join  .c4086(parse);         if (this.miter ) this.miter .c4086(parse);         if (this.cap   ) this.cap   .c4086(parse);         if (this.dashes) this.dashes.c4086(parse);     }     }


class GStrokeSides extends f2043 {     top    = null;     left   = null;     right  = null;     bottom = null;                constructor(nodeId, options)     {         super(u1191, nodeId, options);     }                reset()     {         super.reset();                  this.top    = null;         this.left   = null;         this.right  = null;         this.bottom = null;     }        copy()     {         const copy = new GStrokeSides(this.nodeId, this.options);          copy.z3358(this);          if (this.top   ) copy.top    = this.top   .copy();         if (this.left  ) copy.left   = this.left  .copy();         if (this.right ) copy.right  = this.right .copy();         if (this.bottom) copy.bottom = this.bottom.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalStrokeSidesValue(this.input,  parse);         const top    = await evalNumberValue     (this.top,    parse);         const left   = await evalNumberValue     (this.left,   parse);         const right  = await evalNumberValue     (this.right,  parse);         const bottom = await evalNumberValue     (this.bottom, parse);           if (input)         {             this.value = new i4271(                 top    ?? input.top,                 left   ?? input.left,                 right  ?? input.right,                 bottom ?? input.bottom,                 this.options.enabled);         }         else         {             this.value = new i4271(                 top,                  left,                  right,                  bottom,                 this.options.enabled);         }           this.e4100(parse,         [             ['top',    this.value.top   ],             ['left',   this.value.left  ],             ['right',  this.value.right ],             ['bottom', this.value.bottom]         ]);                   if (!this.top   ) this.top    = this.value.top   .copy();         if (!this.left  ) this.left   = this.value.left  .copy();         if (!this.right ) this.right  = this.value.right .copy();         if (!this.bottom) this.bottom = this.value.bottom.copy();           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.top    && this.top   .isValid()             && this.left   && this.left  .isValid()             && this.right  && this.right .isValid()             && this.bottom && this.bottom.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.top   ) this.top   .g4087(parse);         if (this.left  ) this.left  .g4087(parse);         if (this.right ) this.right .g4087(parse);         if (this.bottom) this.bottom.g4087(parse);     }                   y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.top   ) this.top   .y4088(parse, from, force);         if (this.left  ) this.left  .y4088(parse, from, force);         if (this.right ) this.right .y4088(parse, from, force);         if (this.bottom) this.bottom.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.top   ) this.top   .c4086(parse);         if (this.left  ) this.left  .c4086(parse);         if (this.right ) this.right .c4086(parse);         if (this.bottom) this.bottom.c4086(parse);     } }


class v1894 extends f2043 {     tl = null;     tr = null;     bl = null;     br = null;                constructor(nodeId, options)     {         super(f1194, nodeId, options);     }                reset()     {         super.reset();                  this.tl = null;         this.tr = null;         this.bl = null;         this.br = null;     }        copy()     {         const copy = new v1894(this.nodeId, this.options);          copy.z3358(this);          if (this.tl) copy.tl = this.tl.copy();         if (this.tr) copy.tr = this.tr.copy();         if (this.bl) copy.bl = this.bl.copy();         if (this.br) copy.br = this.br.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRoundedCornersValue(this.input, parse);         const tl    = await evalNumberValue        (this.tl,    parse);         const tr    = await evalNumberValue        (this.tr,    parse);         const bl    = await evalNumberValue        (this.bl,    parse);         const br    = await evalNumberValue        (this.br,    parse);           if (input)         {             this.value = new y2025(                 tl ?? input.tl,                 tr ?? input.tr,                 bl ?? input.bl,                 br ?? input.br,                 this.options.enabled);         }         else         {             this.value = new y2025(                 tl,                  tr,                  bl,                  br,                 this.options.enabled);         }           this.e4100(parse,         [             ['tl', this.value.tl],             ['tr', this.value.tr],             ['bl', this.value.bl],             ['br', this.value.br]         ]);                   if (!this.tl) this.tl = this.value.tl.copy();         if (!this.tr) this.tr = this.value.tr.copy();         if (!this.bl) this.bl = this.value.bl.copy();         if (!this.br) this.br = this.value.br.copy();           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.tl && this.tl.isValid()             && this.tr && this.tr.isValid()             && this.bl && this.bl.isValid()             && this.br && this.br.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.tl) this.tl.g4087(parse);         if (this.tr) this.tr.g4087(parse);         if (this.bl) this.bl.g4087(parse);         if (this.br) this.br.g4087(parse);     }                   y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.tl) this.tl.y4088(parse, from, force);         if (this.tr) this.tr.y4088(parse, from, force);         if (this.bl) this.bl.y4088(parse, from, force);         if (this.br) this.br.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.tl) this.tl.c4086(parse);         if (this.tr) this.tr.c4086(parse);         if (this.bl) this.bl.c4086(parse);         if (this.br) this.br.c4086(parse);     } }


class p1887 extends f2043 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;     behind = null;                constructor(nodeId, options)     {         super(x1197, nodeId, options);     }                reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;         this.behind = null;     }        copy()     {         const copy = new p1887(this.nodeId, this.options);          copy.z3358(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();         if (this.behind) copy.behind = this.behind.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const x      = await evalNumberValue(this.x,      parse);         const y      = await evalNumberValue(this.y,      parse);         const blur   = await evalNumberValue(this.blur,   parse);         const spread = await evalNumberValue(this.spread, parse);         let   fill   = await evalFillValue  (this.fill,   parse);         const blend  = await evalNumberValue(this.blend,  parse);         const behind = await evalNumberValue(this.behind, parse);           if (   fill             && fill.type == l1168)             fill = new q2012(fill);                   if (input)         {             this.value = new q2010(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 behind ?? input.behind,                 this.options.enabled);         }         else         {             this.value = new q2010(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                  behind,                 this.options.enabled);         }           this.e4100(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],             ['behind', this.value.behind]         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();         if (!this.behind) this.behind = this.value.behind.copy();           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid()             && this.behind && this.behind.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x     ) this.x     .g4087(parse);         if (this.y     ) this.y     .g4087(parse);         if (this.blur  ) this.blur  .g4087(parse);         if (this.spread) this.spread.g4087(parse);         if (this.fill  ) this.fill  .g4087(parse);         if (this.blend ) this.blend .g4087(parse);         if (this.behind) this.behind.g4087(parse);     }                   y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.x     ) this.x     .y4088(parse, from, force);         if (this.y     ) this.y     .y4088(parse, from, force);         if (this.blur  ) this.blur  .y4088(parse, from, force);         if (this.spread) this.spread.y4088(parse, from, force);         if (this.fill  ) this.fill  .y4088(parse, from, force);         if (this.blend ) this.blend .y4088(parse, from, force);         if (this.behind) this.behind.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.x     ) this.x     .c4086(parse);         if (this.y     ) this.y     .c4086(parse);         if (this.blur  ) this.blur  .c4086(parse);         if (this.spread) this.spread.c4086(parse);         if (this.fill  ) this.fill  .c4086(parse);         if (this.blend ) this.blend .c4086(parse);         if (this.behind) this.behind.c4086(parse);     } }


class c1890 extends f2043 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;                constructor(nodeId, options)     {         super(e1200, nodeId, options);     }        reset()     {         super.reset();          this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;     }        copy()     {         const copy = new c1890(this.nodeId, this.options);          copy.z3358(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalInnerShadowValue(this.input,  parse);         const x      = await evalNumberValue     (this.x,      parse);         const y      = await evalNumberValue     (this.y,      parse);         const blur   = await evalNumberValue     (this.blur,   parse);         const spread = await evalNumberValue     (this.spread, parse);         let   fill   = await evalFillValue       (this.fill,   parse);         const blend  = await evalNumberValue     (this.blend,  parse);                   if (   fill             && fill.type == l1168)             fill = new q2012(fill);           if (input)         {             this.value = new c2015(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 this.options.enabled);         }         else         {             this.value = new c2015(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                 this.options.enabled);         }           this.e4100(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x     ) this.x     .g4087(parse);         if (this.y     ) this.y     .g4087(parse);         if (this.blur  ) this.blur  .g4087(parse);         if (this.spread) this.spread.g4087(parse);         if (this.fill  ) this.fill  .g4087(parse);         if (this.blend ) this.blend .g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.x     ) this.x     .y4088(parse, from, force);         if (this.y     ) this.y     .y4088(parse, from, force);         if (this.blur  ) this.blur  .y4088(parse, from, force);         if (this.spread) this.spread.y4088(parse, from, force);         if (this.fill  ) this.fill  .y4088(parse, from, force);         if (this.blend ) this.blend .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.x     ) this.x     .c4086(parse);         if (this.y     ) this.y     .c4086(parse);         if (this.blur  ) this.blur  .c4086(parse);         if (this.spread) this.spread.c4086(parse);         if (this.fill  ) this.fill  .c4086(parse);         if (this.blend ) this.blend .c4086(parse);     } }


class d1892 extends f2043 {     radius = null;        constructor(nodeId, options)     {         super(p1203, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new d1892(this.nodeId, this.options);          copy.z3358(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalLayerBlurValue(this.input,  parse);         const radius = await evalNumberValue   (this.radius, parse);                   if (input)         {             this.value = new o2017(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new o2017(                 radius,                 this.options.enabled);         }           this.e4100(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        t3632()     {         return new o2017(             this.radius ? this.radius.t3632() : this.input.radius.t3632(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.radius) this.radius.g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.radius) this.radius.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.radius) this.radius.c4086(parse);     } }


class y1884 extends f2043 {     radius = null;        constructor(nodeId, options)     {         super(q1206, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new y1884(this.nodeId, this.options);          copy.z3358(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input  = await evalValue      (this.input,  parse);         const radius = await evalNumberValue(this.radius, parse);                   if (input)         {             this.value = new d2007(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new d2007(                 radius,                 this.options.enabled);         }           this.e4100(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        t3632()     {         return new d2007(             this.radius ? this.radius.t3632() : this.input.radius.t3632(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.radius) this.radius.g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.radius) this.radius.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.radius) this.radius.c4086(parse);     } }


class o1891 extends y2042 {     opacity;     blend;        constructor(nodeId, options)     {         super(j1212, nodeId, options);     }        reset()     {         super.reset();          this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new o1891(this.nodeId, this.options);          copy.z3358(this);          if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const opacity = await evalNumberValue(this.opacity, parse);         const blend   = await evalNumberValue(this.blend,   parse);           this.value =              this.options.enabled             ? new g2016(opacity, blend)             : new g2016(new x2021(100), new x2021(0));           this.e4100(parse,          [             ['opacity', opacity],             ['blend',   blend  ]         ]);           this.validate();          return this;     }        t3632()     {         return this.value.copy();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.opacity) this.opacity.g4087(parse);         if (this.blend  ) this.blend  .g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.opacity) this.opacity.y4088(parse, from, force);         if (this.blend  ) this.blend  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.opacity) this.opacity.c4086(parse);         if (this.blend  ) this.blend  .c4086(parse);     } }


class w1893 extends y2042 {     maskType;        constructor(nodeId, options)     {         super(t1209, nodeId, options);     }        reset()     {         super.reset();          this.maskType = null;     }        copy()     {         const copy = new w1893(this.nodeId, this.options);          copy.z3358(this);          if (this.maskType) copy.maskType = this.maskType.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const maskType = await evalNumberValue(this.maskType, parse);           this.value = new i2018(maskType, this.options.enabled);           this.e4100(parse,          [             ['maskType', maskType]         ]);           this.validate();          return this;     }        t3632()     {         return this.value.copy();     }        isValid()     {         return this.maskType && this.maskType.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.maskType) this.maskType.g4087(parse);     }                    y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.maskType) this.maskType.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.maskType) this.maskType.c4086(parse);     } }


class k1974 extends y2042 {     x      = null;     y      = null;     width  = null;     height = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.width  = null;         this.height = null;     }        z3358(base)     {         super.z3358(base);          if (base.x     ) this.x      = base.x     .copy();         if (base.y     ) this.y      = base.y     .copy();         if (base.width ) this.width  = base.width .copy();         if (base.height) this.height = base.height.copy();     }        async evalBaseParams(parse, evalHeight = true)     {         let x      =              await evalNumberValue(this.x,      parse);         let y      =              await evalNumberValue(this.y,      parse);         let width  =              await evalNumberValue(this.width,  parse);         let height = evalHeight ? await evalNumberValue(this.height, parse) : null;          return [x, y, width, height];     }        evalStyle(options = {})     {                       }        isValid()     {         return this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.width  && this.width .isValid()             && this.height && this.height.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x     ) this.x     .g4087(parse);         if (this.y     ) this.y     .g4087(parse);         if (this.width ) this.width .g4087(parse);         if (this.height) this.height.g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.x     ) this.x     .y4088(parse, from, force);         if (this.y     ) this.y     .y4088(parse, from, force);         if (this.width ) this.width .y4088(parse, from, force);         if (this.height) this.height.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.x     ) this.x     .c4086(parse);         if (this.y     ) this.y     .c4086(parse);         if (this.width ) this.width .c4086(parse);         if (this.height) this.height.c4086(parse);     } }    function validateObjectRect(x, y, w, h, a = 0, _a = 0) {     if (w < 0)     {         x += w * Math.cos(_a);         y += w * Math.sin(_a);     }      if (h < 0)     {         y += h * Math.cos(_a);         x -= h * Math.sin(_a);     }             w = Math.abs(w);     h = Math.abs(h);       return [x, y, w, h, a, _a]; }


class t1973 extends k1974 {     input = null;      props = null;           constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.input = null;         this.props = null;     }        z3358(base)     {         super.z3358(base);                  if (base.input) this.input = base.input.copy();         if (base.props) this.props = base.props.copy();     }        y4241(f2991)     {         switch (f2991)         {             case 'props':  return this.input ? this.value.props : this.props;         }          return null;     }        p2896()     {         return this.value             && this.value.props             && this.value.props.isValid();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async l2895(parse)     {         let props = await evalListValue(this.props, parse);          if (   props             && e1215.includes(props.type))             props = new b2020([props]);                   if (this.value)         {             if (this.input)             {                 this.value.props = props ?? this.input.t3632().props;                                  if (props)  this.value.props = props;  else  props = this.value.props;               }             else                 this.value.props = props;                                   if (   this.value                 && this.value.isValid()                 && this.value.props != undefined)              {                 this.e4100(parse,                  [                                      ],                  true);                                   if (!this.props) this.props = this.value.props.copy();             }         }     }        async i4099(parse)     {         if (!this.value)             return;           for (const l111 of this.value.objects)         {             g952(l111.fills,   'obj.fills   must not be null');             g952(l111.strokes, 'obj.strokes must not be null');             g952(l111.effects, 'obj.effects must not be null');               if (this.value.props)                 addProps(l111, this.value.props);         }     }        evalStyle(options = {})     {      }        isValid()     {         return super.isValid()             && (!this.input || this.input.isValid())             && this.props && this.props.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);         if (this.props) this.props.g4087(parse);     }            y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.input) this.input.y4088(parse, from, force);         if (this.props) this.props.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.input) this.input.c4086(parse);         if (this.props) this.props.c4086(parse);     } }    function addProps(l111, props) {     if (h957(props.type))     {                        for (let i = 0; i < props.items.length; i++)             w1822(l111, props.items[i]);     }     else         w1822(l111, props); }


class b1968 extends t1973 {     round = null;        constructor(nodeId, options)     {         super(t1219, nodeId, options);     }        reset()     {         super.reset();          this.round = null;     }        copy()     {         const copy = new b1968(this.nodeId, this.options);          copy.z3358(this);          if (this.round) copy.round = this.round.copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalRectangleValue(this.input, parse);         let   round = await evalNumberValue   (this.round, parse);          if (round && !round.isValid()) round = x2021.NaN.copy();                   let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.t3632();             this.value.nodeId = this.nodeId;             this.value.i3625(input);                          if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;           }         else         {             this.value = new r2024(                 this.nodeId,                  x,                  y,                  width,                  height,                  round);         }                  this.e4100(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.p2896()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const rect = new j1845(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r);                  rect.h4097(x, y);                 rect.b3729(x, y, w, h);                  this.value.objects.push(rect);             }         }                   await super.i4099(parse);     }                                                                                    isValid()     {         return super.isValid()             && this.round && this.round.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.round) this.round.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.round) this.round.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.round) this.round.c4086(parse);     } }


class b1959 extends t1973 {     constructor(nodeId, options)     {         super(y1222, nodeId, options);     }        copy()     {         const copy = new b1959(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'width': return this.input ? this.value.width : this.width;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let input = await evalLineValue(this.input, parse);          let [x, y, width, ] = await this.evalBaseParams(parse, false);                       if (input)         {             this.value        = input.t3632();             this.value.nodeId = this.nodeId;             this.value.i3625(input);              if (x    )  this.value.x     = x;      else  x     = this.value.x;                   if (y    )  this.value.y     = y;      else  y     = this.value.y;                   if (width)  this.value.width = width;  else  width = this.value.width;           }         else         {             this.value = new m2019(                 this.nodeId,                  x,                  y,                  width);         }           this.e4100(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.x    ) this.x     = this.value.x    .copy();         if (!this.y    ) this.y     = this.value.y    .copy();         if (!this.width) this.width = this.value.width.copy();           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                       this.value.objects = [];           if (   super.p2896()                && this.value.x    .isValid()             && this.value.y    .isValid()             && this.value.width.isValid())          {             let x = this.value.x    .value;             let y = this.value.y    .value;             let w = this.value.width.value;               [x, y, w, , , ] = validateObjectRect(x, y, w, 0);               if (w != 0)             {                 const line = new x1841(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w);                  line.h4097(x, y);                 line.b3729(x, y, w, 0.01);                                  this.value.objects.push(line);             }         }                   await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.x     && this.x    .isValid()             && this.y     && this.y    .isValid()             && this.width && this.width.isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.x    ) this.x    .g4087(parse);         if (this.y    ) this.y    .g4087(parse);         if (this.width) this.width.g4087(parse);     }                   y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.x    ) this.x    .y4088(parse, from, force);         if (this.y    ) this.y    .y4088(parse, from, force);         if (this.width) this.width.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);           if (this.x    ) this.x    .c4086(parse);         if (this.y    ) this.y    .c4086(parse);         if (this.width) this.width.c4086(parse);     } }


class z1955 extends t1973 {     position = null;     round    = null;     start    = null;     sweep    = null;     inner    = null;      innerAbsolute;     sweepInDegrees;        constructor(nodeId, options)     {         super(h1225, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.start    = null;         this.sweep    = null;         this.inner    = null;     }        copy()     {         const copy = new z1955(this.nodeId, this.options);          copy.z3358(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();         if (this.inner   ) copy.inner    = this.inner   .copy();                  return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;             case 'inner':    return this.input ? this.value.inner    : this.inner         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalValue      (this.input,    parse);         let pos   = await evalNumberValue(this.position, parse);         let round = await evalNumberValue(this.round,    parse);         let start = await evalNumberValue(this.start,    parse);         let sweep = await evalNumberValue(this.sweep,    parse);         let inner = await evalNumberValue(this.inner,    parse);          if (pos   && !pos  .isValid()) pos   = x2021.NaN.copy();         if (round && !round.isValid()) round = x2021.NaN.copy();         if (start && !start.isValid()) start = x2021.NaN.copy();         if (sweep && !sweep.isValid()) sweep = x2021.NaN.copy();         if (inner && !inner.isValid()) inner = x2021.NaN.copy();           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.i3625(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;             if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;           }         else         {             this.value = new e2011(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 start,                 sweep,                 inner);         }           this.e4100(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['start',    start ],             ['sweep',    sweep ],             ['inner',    inner ]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.p2896()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new x2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new x2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new x2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new x2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x  = _x.value;             let   y  = _y.value;             let   w  = _w.value;             let   h  = _h.value;             let   r  = this.value.round .value;             const st = this.value.start .value;             let   sw = this.value.sweep .value;             let   i  = this.value.inner .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 if (this.innerAbsolute ) i  /= Math.max(w, h) / 200;                 if (this.sweepInDegrees) sw /= 3.6;                  const ellipse = new s1839(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, st, sw, i);                  ellipse.h4097(x, y);                 ellipse.b3729(x, y, w, h);                  this.value.objects.push(ellipse);             }         }           await super.i4099(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid()             && this.inner    && this.inner   .isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);         if (this.start   ) this.start   .g4087(parse);         if (this.sweep   ) this.sweep   .g4087(parse);         if (this.inner   ) this.inner   .g4087(parse);     }                   y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.position) this.position.y4088(parse, from, force);         if (this.round   ) this.round   .y4088(parse, from, force);         if (this.start   ) this.start   .y4088(parse, from, force);         if (this.sweep   ) this.sweep   .y4088(parse, from, force);         if (this.inner   ) this.inner   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);           if (this.position) this.position.c4086(parse);         if (this.round   ) this.round   .c4086(parse);         if (this.start   ) this.start   .c4086(parse);         if (this.sweep   ) this.sweep   .c4086(parse);         if (this.inner   ) this.inner   .c4086(parse);     } }


class t1979 extends t1973 {     round = null;     bias  = null;        constructor(nodeId, options)     {         super(r1228, nodeId, options);     }        reset()     {         super.reset();          this.round = null;         this.bias  = null;     }        copy()     {         const copy = new t1979(this.nodeId, this.options);          copy.z3358(this);          if (this.round) copy.round = this.round.copy();         if (this.bias ) copy.bias  = this.bias .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'x':      return this.input ? this.value.x      : this.x;             case 'y':      return this.input ? this.value.y      : this.y;             case 'width':  return this.input ? this.value.width  : this.width;             case 'height': return this.input ? this.value.height : this.height;             case 'round':  return this.input ? this.value.round  : this.round;             case 'bias':   return this.input ? this.value.bias   : this.bias;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         let   round = await evalNumberValue(this.round, parse);         let   bias  = await evalNumberValue(this.bias,  parse);                  let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.t3632();             this.value.nodeId = this.nodeId;             this.value.i3625(input);              if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;               if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;           }         else         {             this.value = new r2033(                 this.nodeId,                  x,                  y,                  width,                  height,                  round,                 bias);         }                  this.e4100(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ],             ['bias',   bias  ]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();         if (!this.bias  ) this.bias   = this.value.bias  .copy();           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.p2896()                && this.value.x     .isValid()                 && this.value.y     .isValid()                 && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid()             && this.value.bias  .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);             let   b = this.value.bias  .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const trapeze = new g1850(                     this.nodeId,                      this.nodeId,                      this.nodeName,                      x, y, w, h, r, b);                  trapeze.h4097(x, y);                 trapeze.b3729(x, y, w, h);                  this.value.objects.push(trapeze);             }         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid()             && this.bias  && this.bias .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.round) this.round.g4087(parse);         if (this.bias ) this.bias .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.round) this.round.y4088(parse, from, force);         if (this.bias ) this.bias .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.round) this.round.c4086(parse);         if (this.bias ) this.bias .c4086(parse);     } }


class z1967 extends t1973 {     position = null;     round    = null;     corners  = null;        constructor(nodeId, options)     {         super(b1237, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.corners  = null;     }        copy()     {         const copy = new z1967(this.nodeId, this.options);          copy.z3358(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.corners ) copy.corners  = this.corners .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'corners':  return this.input ? this.value.corners  : this.corners;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input   = await evalPolygonValue(this.input,    parse);         let pos     = await evalNumberValue (this.position, parse);         let round   = await evalNumberValue (this.round,    parse);         let corners = await evalNumberValue (this.corners,  parse);           if (input)         {             this.value        = input.t3632();             this.value.nodeId = this.nodeId;             this.value.i3625(input);              if (pos    )  this.value.position = pos;      else  pos     = this.value.position;             if (x      )  this.value.x        = x;        else  x       = this.value.x;                   if (y      )  this.value.y        = y;        else  y       = this.value.y;                   if (width  )  this.value.width    = width;    else  width   = this.value.width;               if (height )  this.value.height   = height;   else  height  = this.value.height;              if (round  )  this.value.round    = round;    else  round   = this.value.round;               if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;           }         else         {             this.value = new a2023(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 corners);         }           this.e4100(parse,          [             ['position', pos    ],             ['x',        x      ],             ['y',        y      ],             ['width',    width  ],             ['height',   height ],             ['round',    round  ],             ['corners',  corners]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.corners ) this.corners  = this.value.corners .copy();           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   super.p2896()                && this.value.x      .isValid()             && this.value.y      .isValid()             && this.value.width  .isValid()             && this.value.height .isValid()             && this.value.round  .isValid()             && this.value.corners.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new x2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new x2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new x2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new x2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const c = Math.max(3, Math.floor(this.value.corners.value));               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const poly = new v1844(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, c);                  poly.h4097(x, y);                 poly.b3729(x, y, w, h);                  this.value.objects.push(poly);             }         }                   await super.i4099(parse);     }                                                                                              isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.corners  && this.corners .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);         if (this.corners ) this.corners .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.position) this.position.y4088(parse, from, force);         if (this.round   ) this.round   .y4088(parse, from, force);         if (this.corners ) this.corners .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.position) this.position.c4086(parse);         if (this.round   ) this.round   .c4086(parse);         if (this.corners ) this.corners .c4086(parse);     } }


 class y1977 extends t1973 {     position = null;     round    = null;     points   = null;     convex   = null;        constructor(nodeId, options)     {         super(j1240, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.points   = null;         this.convex   = null;     }        copy()     {         const copy = new y1977(this.nodeId, this.options);          copy.z3358(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.points  ) copy.points   = this.points  .copy();         if (this.convex  ) copy.convex   = this.convex  .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'points':   return this.input ? this.value.points   : this.points;             case 'convex':   return this.input ? this.value.convex   : this.convex;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input  = await evalValue      (this.input,    parse);         let pos    = await evalNumberValue(this.position, parse);         let round  = await evalNumberValue(this.round,    parse);         let points = await evalNumberValue(this.points,   parse);         let convex = await evalNumberValue(this.convex,   parse);           if (input)         {             this.value        = input.t3632();             this.value.nodeId = this.nodeId;             this.value.i3625(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (points)  this.value.points   = points;  else  points = this.value.points;               if (convex)  this.value.convex   = convex;  else  convex = this.value.convex;          }         else         {             this.value = new a2029(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 points,                 convex);         }           this.e4100(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['points',   points],             ['convex',   convex]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.points  ) this.points   = this.value.points  .copy();         if (!this.convex  ) this.convex   = this.value.convex  .copy();            this.validate();          return this;    }       async i4099(parse, options = {})    {         if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.p2896()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()              && this.value.round .isValid()             && this.value.points.isValid()             && this.value.convex.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new x2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new x2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new x2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new x2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const p = Math.max(3, Math.floor(this.value.points.value));             const c = this.value.convex.value;               if (   w != 0                 && h != 0)             {                 const star = new f1848(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, p, c);                  star.h4097(x, y);                 star.b3729(x, y, w, h);                  this.value.objects.push(star);             }         }                  await super.i4099(parse);     }                                                                                                    isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.points   && this.points  .isValid()             && this.convex   && this.convex  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);         if (this.points  ) this.points  .g4087(parse);         if (this.convex  ) this.convex  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.position) this.position.y4088(parse, from, force);         if (this.round   ) this.round   .y4088(parse, from, force);         if (this.points  ) this.points  .y4088(parse, from, force);         if (this.convex  ) this.convex  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.position) this.position.c4086(parse);         if (this.round   ) this.round   .c4086(parse);         if (this.points  ) this.points  .c4086(parse);         if (this.convex  ) this.convex  .c4086(parse);     } }


class o1978 extends t1973 {     text          = null;     x             = null;     y             = null;     width         = null;     height        = null;     font          = null;     size          = null;     style         = null;     alignX        = null;     alignY        = null;     lineHeight    = null;     letterSpacing = null;                constructor(nodeId, options)     {         super(l1243, nodeId, options);     }            reset()     {         super.reset();                  this.text          = null;         this.x             = null;         this.y             = null;         this.width         = null;         this.height        = null;         this.font          = null;         this.size          = null;         this.style         = null;         this.alignX        = null;         this.alignY        = null;         this.lineHeight    = null;         this.letterSpacing = null;     }        copy()     {         const copy = new o1978(this.nodeId, this.options);          copy.z3358(this);          if (this.text         ) copy.text          = this.text         .copy();         if (this.x            ) copy.x             = this.x            .copy();         if (this.y            ) copy.y             = this.y            .copy();         if (this.width        ) copy.width         = this.width        .copy();         if (this.height       ) copy.height        = this.height       .copy();         if (this.font         ) copy.font          = this.font         .copy();         if (this.style        ) copy.style         = this.style        .copy();         if (this.size         ) copy.size          = this.size         .copy();         if (this.alignX       ) copy.alignX        = this.alignX       .copy();         if (this.alignY       ) copy.alignY        = this.alignY       .copy();         if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();         if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'text':          return this.input ? this.value.text          : this.text;             case 'x':             return this.input ? this.value.x             : this.x;             case 'y':             return this.input ? this.value.y             : this.y;             case 'width':         return this.input ? this.value.width         : this.width;             case 'height':        return this.input ? this.value.height        : this.height;             case 'font':          return this.input ? this.value.font          : this.font;             case 'style':         return this.input ? this.value.style         : this.style;             case 'size':          return this.input ? this.value.size          : this.size;             case 'alignX':        return this.input ? this.value.alignX        : this.alignX;             case 'alignY':        return this.input ? this.value.alignY        : this.alignY;             case 'lineHeight':    return this.input ? this.value.lineHeight    : this.lineHeight;             case 'letterSpacing': return this.input ? this.value.letterSpacing : this.letterSpacing;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalTextShapeValue(this.input,         parse);         let   text          = await evalNumberValue   (this.text,          parse);         let   x             = await evalNumberValue   (this.x,             parse);         let   y             = await evalNumberValue   (this.y,             parse);         let   width         = await evalNumberValue   (this.width,         parse);         let   height        = await evalNumberValue   (this.height,        parse);         let   font          = await evalNumberValue   (this.font,          parse);         let   style         = await evalNumberValue   (this.style,         parse);         let   size          = await evalNumberValue   (this.size,          parse);         let   alignX        = await evalNumberValue   (this.alignX,        parse);         let   alignY        = await evalNumberValue   (this.alignY,        parse);         let   lineHeight    = await evalNumberValue   (this.lineHeight,    parse);         let   letterSpacing = await evalNumberValue   (this.letterSpacing, parse);           if (text          && !text         .isValid()) text          = new v2032();         if (x             && !x            .isValid()) x             = x2021.NaN.copy();         if (y             && !y            .isValid()) y             = x2021.NaN.copy();         if (width         && !width        .isValid()) width         = x2021.NaN.copy();         if (height        && !height       .isValid()) height        = x2021.NaN.copy();         if (font          && !font         .isValid()) font          = x2021.NaN.copy();         if (style         && !style        .isValid()) style         = x2021.NaN.copy();         if (size          && !size         .isValid()) size          = x2021.NaN.copy();         if (alignX        && !alignX       .isValid()) alignX        = x2021.NaN.copy();         if (alignY        && !alignY       .isValid()) alignY        = x2021.NaN.copy();         if (lineHeight    && !lineHeight   .isValid()) lineHeight    = x2021.NaN.copy();         if (letterSpacing && !letterSpacing.isValid()) letterSpacing = x2021.NaN.copy();                    if (text          && text         .type !=   l1143) text          = new v2032();         if (x             && x            .type != n1091) x             = x2021.NaN.copy();         if (y             && y            .type != n1091) y             = x2021.NaN.copy();         if (width         && width        .type != n1091) width         = x2021.NaN.copy();         if (height        && height       .type != n1091) height        = x2021.NaN.copy();         if (font          && font         .type != n1091) font          = x2021.NaN.copy();         if (style         && style        .type != n1091) style         = x2021.NaN.copy();         if (size          && size         .type != n1091) size          = x2021.NaN.copy();         if (alignX        && alignX       .type != n1091) alignX        = x2021.NaN.copy();         if (alignY        && alignY       .type != n1091) alignY        = x2021.NaN.copy();         if (lineHeight    && lineHeight   .type != n1091) lineHeight    = x2021.NaN.copy();         if (letterSpacing && letterSpacing.type != n1091) letterSpacing = x2021.NaN.copy();                   if (input)         {             this.value        = input.t3632();             this.value.nodeId = this.nodeId;             this.value.i3625(input);                          if (text         )  this.value.text          = text;           else  text          = this.value.text;             if (x            )  this.value.x             = x;              else  x             = this.value.x;             if (y            )  this.value.y             = y;              else  y             = this.value.y;             if (width        )  this.value.width         = width;          else  width         = this.value.width;             if (height       )  this.value.height        = height;         else  height        = this.value.height;             if (font         )  this.value.font          = font;           else  font          = this.value.font;             if (style        )  this.value.style         = style;          else  style         = this.value.style;             if (size         )  this.value.size          = size;           else  size          = this.value.size;             if (alignX       )  this.value.alignX        = alignX;         else  alignX        = this.value.alignX;             if (alignY       )  this.value.alignY        = alignY;         else  alignY        = this.value.alignY;             if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;             if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing;          }         else         {             this.value = new q2031(                 this.nodeId,                  text,                  x,                  y,                  width,                  height,                  font,                  style,                 size,                 alignX,                 alignY,                 lineHeight,                 letterSpacing);         }                  this.e4100(parse,          [             ['text',          text         ],             ['x',             x            ],             ['y',             y            ],             ['width',         width        ],             ['height',        height       ],             ['font',          font         ],             ['style',         style        ],             ['size',          size         ],             ['alignX',        alignX       ],             ['alignY',        alignY       ],             ['lineHeight',    lineHeight   ],             ['letterSpacing', letterSpacing]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.text         ) this.text          = this.value.text         .copy();         if (!this.x            ) this.x             = this.value.x            .copy();         if (!this.y            ) this.y             = this.value.y            .copy();         if (!this.width        ) this.width         = this.value.width        .copy();         if (!this.height       ) this.height        = this.value.height       .copy();         if (!this.font         ) this.font          = this.value.font         .copy();         if (!this.style        ) this.style         = this.value.style        .copy();         if (!this.size         ) this.size          = this.value.size         .copy();         if (!this.alignX       ) this.alignX        = this.value.alignX       .copy();         if (!this.alignY       ) this.alignY        = this.value.alignY       .copy();         if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();         if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();                   this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                   this.value.objects = [];           if (   super.p2896()                && this.value.text         .isValid()             && this.value.x            .isValid()             && this.value.y            .isValid()             && this.value.width        .isValid()             && this.value.height       .isValid()             && this.value.font         .isValid()             && this.value.style        .isValid()             && this.value.size         .isValid()             && this.value.alignX       .isValid()             && this.value.alignY       .isValid()             && this.value.lineHeight   .isValid()             && this.value.letterSpacing.isValid())         {             let x = this.value.x     .value;             let y = this.value.y     .value;             let w = this.value.width .value;             let h = this.value.height.value;              const fontName   = c4038[this.value.font.value];             const fontStyles = getFontStyles(fontName);              const text = new p1849(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.value.text.value,                 x, y, w, h,                 fontName,                 this.value.size         .value,                 fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],                 this.value.alignX       .value,                 this.value.alignY       .value,                 this.value.lineHeight   .value,                 this.value.letterSpacing.value);                               text.h4097(x, y);                                                                                                                                                                                                text.b3729(x, y, w, h);                  this.value.objects.push(text);                      }                   await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.text          && this.text         .isValid()             && this.x             && this.x            .isValid()             && this.y             && this.y            .isValid()             && this.width         && this.width        .isValid()             && this.height        && this.height       .isValid()             && this.font          && this.font         .isValid()             && this.style         && this.style        .isValid()             && this.size          && this.size         .isValid()             && this.alignX        && this.alignX       .isValid()             && this.alignY        && this.alignY       .isValid()             && this.lineHeight    && this.lineHeight   .isValid()             && this.letterSpacing && this.letterSpacing.isValid();     }        g4087(parse)     {         super.g4087(parse);                  if (this.text         ) this.text         .g4087(parse);         if (this.x            ) this.x            .g4087(parse);         if (this.y            ) this.y            .g4087(parse);         if (this.width        ) this.width        .g4087(parse);         if (this.height       ) this.height       .g4087(parse);         if (this.font         ) this.font         .g4087(parse);         if (this.style        ) this.style        .g4087(parse);         if (this.size         ) this.size         .g4087(parse);         if (this.alignX       ) this.alignX       .g4087(parse);         if (this.alignY       ) this.alignY       .g4087(parse);         if (this.lineHeight   ) this.lineHeight   .g4087(parse);         if (this.letterSpacing) this.letterSpacing.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);                  if (this.text         ) this.text         .y4088(parse, from, force);         if (this.x            ) this.x            .y4088(parse, from, force);         if (this.y            ) this.y            .y4088(parse, from, force);         if (this.width        ) this.width        .y4088(parse, from, force);         if (this.height       ) this.height       .y4088(parse, from, force);         if (this.font         ) this.font         .y4088(parse, from, force);         if (this.style        ) this.style        .y4088(parse, from, force);         if (this.size         ) this.size         .y4088(parse, from, force);         if (this.alignX       ) this.alignX       .y4088(parse, from, force);         if (this.alignY       ) this.alignY       .y4088(parse, from, force);         if (this.lineHeight   ) this.lineHeight   .y4088(parse, from, force);         if (this.letterSpacing) this.letterSpacing.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);                  if (this.text         ) this.text         .c4086(parse);         if (this.x            ) this.x            .c4086(parse);         if (this.y            ) this.y            .c4086(parse);         if (this.width        ) this.width        .c4086(parse);         if (this.height       ) this.height       .c4086(parse);         if (this.font         ) this.font         .c4086(parse);         if (this.style        ) this.style        .c4086(parse);         if (this.size         ) this.size         .c4086(parse);         if (this.alignX       ) this.alignX       .c4086(parse);         if (this.alignY       ) this.alignY       .c4086(parse);         if (this.lineHeight   ) this.lineHeight   .c4086(parse);         if (this.letterSpacing) this.letterSpacing.c4086(parse);     } }


class j1963 extends f2043 {     x = null;     y = null;        constructor(nodeId, options)     {         super(l1246, nodeId, options);     }        reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new j1963(this.nodeId, this.options);          copy.z3358(this);          if (this.value) copy.value = this.value.copy();         if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'x': return this.input ? this.value.x : this.x;             case 'y': return this.input ? this.value.y : this.y;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalPointValue (this.input, parse);         let x     = await evalNumberValue(this.x,     parse);         let y     = await evalNumberValue(this.y,     parse);           if (   input             && input.isValid())         {             const l3811 = input;              if (input.type == g1252)             {                 input = new b2022(input.nodeId, input.x, input.y);                 input.i3625(l3811);             }                          this.value        = input;             this.value.nodeId = this.nodeId;             this.value.i3625(input);               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new x2021(this.value.objects[0].x);                 this.value.y = new x2021(this.value.objects[0].y);             }                          if (x)  this.value.x = x;  else  x = this.value.x;             if (y)  this.value.y = y;  else  y = this.value.y;         }         else if (x                && y)         {             this.value = new b2022(                 this.nodeId,                  x,                  y);         }         else             this.value = b2022.NaN.copy();           this.value.i3735 = this.i3735;           await this.i4099(parse);           this.e4100(parse,          [             ['x', x],             ['y', y]         ]);               this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new b1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.h4097(x, y);              this.value.objects = [point];         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x) this.x.g4087(parse);         if (this.y) this.y.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.x) this.x.y4088(parse, from, force);         if (this.y) this.y.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.x) this.x.c4086(parse);         if (this.y) this.y.c4086(parse);     } }


class b1964 extends f2043 {     smooth = null;        constructor(nodeId, options)     {         super(h1248, nodeId, options);     }        reset()     {         super.reset();          this.smooth = null;     }        copy()     {         const copy = new b1964(this.nodeId, this.options);          copy.z3358(this);          if (this.value ) copy.value  = this.value .copy();         if (this.smooth) copy.smooth = this.smooth.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input  = await evalPointValue (this.input,  parse);         const smooth = await evalNumberValue(this.smooth, parse);                  if (input)         {             this.value        = input;             this.value.nodeId = this.nodeId;             this.value.i3625(input);              this.value.smooth = smooth;               if (   this.value.objects                 && this.value.objects.length > 0)             {                 this.value.x = new x2021(this.value.objects[0].x);                 this.value.y = new x2021(this.value.objects[0].y);             }         }         else             this.value = b2022.NaN.copy();           await this.i4099(parse);           this.e4100(parse,          [             ['smooth', smooth]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x      = this.value.x.value;             const y      = this.value.y.value;             const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;              const point = new b1843(                 this.nodeId,                  this.nodeId,                  this.nodeName,                  x,                  y,                  smooth);              point.h4097(x, y);              this.value.objects = [point];         }           await super.i4099(parse);     }        t3632()     {         return this.value.copy();                                                    }        isValid()     {         return super.isValid()             && this.smooth && this.smooth.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.smooth) this.smooth.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.smooth) this.smooth.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.smooth) this.smooth.c4086(parse);     } }


class r1983 extends t1973 {     points  = null;     closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(w1250, nodeId, options);     }        reset()     {         super.reset();          this.points  = null;         this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new r1983(this.nodeId, this.options);          copy.z3358(this);          if (this.points ) copy.points  = this.points .copy();         if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'points':  return this.input ? this.value.points  : this.points;             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = await evalVectorPathValue(this.input,   parse);         let   points  = await evalNumberValue    (this.points,  parse);         let   closed  = await evalNumberValue    (this.closed,  parse);         let   degree  = await evalNumberValue    (this.degree,  parse);         let   winding = await evalNumberValue    (this.winding, parse);         let   round   = await evalNumberValue    (this.round,   parse);           await this.evalBaseParams(parse);           if (input)         {                                                    if (   input.points                 && input.points.items                 && input.points.objects)             {                 g952(                      input.points.items.length == input.points.objects.length,                     'Vector path points input item count must match object count');                  for (let i = 0; i < input.points.items.length; i++)                 {                     const item = input.points.items  [i].copy();                     const l111  = input.points.objects[i].copy();                      if (item && l111)                     {                         item.x = new x2021(l111.x);                         item.y = new x2021(l111.y);                     }                 }             }               this.value = new p2036(                 this.nodeId,                    points                  && points.items.length > 0                  ? points                 : input.points,                 closed  ?? input.closed,                 degree  ?? input.degree,                 winding ?? input.winding,                 round   ?? input.round);              this.value.i3625(input);                           if (points )  this.value.points   = points;   else  points  = this.value.points;                 if (closed )  this.value.closed   = closed;   else  closed  = this.value.closed;                 if (degree )  this.value.degree   = degree;   else  degree  = this.value.degree;               if (winding)  this.value.windingt = winding;  else  winding = this.value.winding;              if (round  )  this.value.round    = round;    else  round   = this.value.round;           }         else         {             this.value = new p2036(                 this.nodeId,                  points,                  closed,                  degree,                  winding,                  round);         }                   this.e4100(parse,          [                        ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          if (this.value.points.objects)         {             const y4101 = this.value.points.objects.filter(o => o.type == l1246);              for (const pt of y4101)             {                 const p = b2022.create(this.nodeId, pt.x, pt.y);                                  if (pt.smooth != null)                     p.smooth = new x2021(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   super.p2896()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new n1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              path.v3741(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.h4097(x, y);             path.b3729(x, y, w, h);               this.value.objects.push(path);         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.points ) this.points .g4087(parse);         if (this.closed ) this.closed .g4087(parse);         if (this.degree ) this.degree .g4087(parse);         if (this.winding) this.winding.g4087(parse);         if (this.round  ) this.round  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.points ) this.points .y4088(parse, from, force);         if (this.closed ) this.closed .y4088(parse, from, force);         if (this.degree ) this.degree .y4088(parse, from, force);         if (this.winding) this.winding.y4088(parse, from, force);         if (this.round  ) this.round  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.points ) this.points .c4086(parse);         if (this.closed ) this.closed .c4086(parse);         if (this.degree ) this.degree .c4086(parse);         if (this.winding) this.winding.c4086(parse);         if (this.round  ) this.round  .c4086(parse);     } }


class o1985 extends f2043 {     x     = null;     y     = null;     join  = null;     cap   = null;     round = null;        constructor(nodeId, options)     {         super(x1253, nodeId, options);     }        reset()     {         super.reset();          this.x     = null;         this.y     = null;         this.join  = null;         this.cap   = null;         this.round = null;     }        copy()     {         const copy = new o1985(this.nodeId, this.options);          copy.z3358(this);          if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();         if (this.join ) copy.join  = this.join .copy();         if (this.cap  ) copy.cap   = this.cap  .copy();         if (this.round) copy.round = this.round.copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'x':     return this.input ? this.value.x     : this.x;             case 'y':     return this.input ? this.value.y     : this.y;             case 'join':  return this.input ? this.value.join  : this.join;             case 'cap':   return this.input ? this.value.cap   : this.cap;             case 'round': return this.input ? this.value.round : this.round;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = await evalVectorVertexValue(this.input, parse);         let x     = await evalNumberValue      (this.x,     parse);         let y     = await evalNumberValue      (this.y,     parse);         let join  = await evalNumberValue      (this.join,  parse);         let cap   = await evalNumberValue      (this.cap,   parse);         let round = await evalNumberValue      (this.round, parse);           if (input)         {             const l3811 = input;              if (input.type == u1245)             {                 input = new w2038(input.nodeId, input.x, input.y);                 input.i3625(l3811);             }                          this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.i3625(input);                                                                                                                          this.value.x     = new x2021(this.value.objects[0].x    );             this.value.y     = new x2021(this.value.objects[0].y    );             this.value.join  = new x2021(this.value.objects[0].join );             this.value.cap   = new x2021(this.value.objects[0].cap  );             this.value.round = new x2021(this.value.objects[0].round);              if (x    )  this.value.x     = x;      else  x     = this.value.x;             if (y    )  this.value.y     = y;      else  y     = this.value.y;             if (join )  this.value.join  = join;   else  join  = this.value.join;             if (cap  )  this.value.cap   = cap;    else  cap   = this.value.cap;             if (round)  this.value.round = round;  else  round = this.value.round;         }         else         {             this.value = new w2038(                 this.nodeId,                  x,                  y,                  join,                  cap,                  round);         }                  this.value.i3735 = this.i3735;           await this.i4099(parse);           this.e4100(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x                 && this.value.y                 && this.value.join              && this.value.cap               && this.value.round)         {             const x     = this.value.x    .value;             const y     = this.value.y    .value;                                                     const point = new b1843(this.nodeId, this.nodeId, this.nodeName, x, y);              point.h4097(x, y);              this.value.objects = [point];         }           await super.i4099(parse);     }        t3632()     {         const point = new w2038(             this.nodeId,             this.x    .t3632(),             this.y    .t3632(),             this.join .t3632(),             this.cap  .t3632(),             this.round.t3632());          point.i3625(this.value);          point.objects  = this.value.objects.map(o => o.copy());         point.i3735 = this.value.i3735;          return point;     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.x    ) this.x    .g4087(parse);         if (this.y    ) this.y    .g4087(parse);         if (this.join ) this.join .g4087(parse);         if (this.cap  ) this.cap  .g4087(parse);         if (this.round) this.round.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.x    ) this.x    .y4088(parse, from, force);         if (this.y    ) this.y    .y4088(parse, from, force);         if (this.join ) this.join .y4088(parse, from, force);         if (this.cap  ) this.cap  .y4088(parse, from, force);         if (this.round) this.round.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.x    ) this.x    .c4086(parse);         if (this.y    ) this.y    .c4086(parse);         if (this.join ) this.join .c4086(parse);         if (this.cap  ) this.cap  .c4086(parse);         if (this.round) this.round.c4086(parse);     } }


class b1980 extends k2044 {     c3664 = null;     r3665   = null;                    constructor(nodeId, options)     {         super(x1256, nodeId, options);     }        reset()     {         super.reset();                  this.c3664 = null;         this.r3665   = null;     }        copy()     {         const copy = new b1980(this.nodeId, this.options);          copy.z3358(this);          if (this.c3664) copy.c3664 = this.c3664.copy();         if (this.r3665  ) copy.r3665   = this.r3665  .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'startTangent': return this.input ? this.value.c3664 : this.c3664;             case 'endTangent':   return this.input ? this.value.r3665   : this.r3665;         }          return null;     }        async eval(parse)     {         if (this.isCached())             return this;                   let b4082       = await evalVectorVertexValue(this.b4082,       parse);         let o4083       = await evalVectorVertexValue(this.o4083,       parse);         let c3664 = await evalNumberValue      (this.c3664, parse);         let   r3665 = await evalNumberValue      (this.  r3665, parse);          if (   b4082             && o4083             && c3664             && r3665)         {             if (b4082.type == u1245) b4082 = new w2038(b4082.nodeId, b4082.x, b4082.y);             if (o4083.type == u1245) o4083 = new w2038(o4083.nodeId, o4083.x, o4083.y);              if (c3664.type == g1252) c3664 = new b2022(c3664.nodeId, c3664.x, c3664.y);             if (  r3665.type == g1252)   r3665 = new b2022(  r3665.nodeId,   r3665.x,   r3665.y);               this.value = new z2034(                 this.nodeId,                 b4082,                 o4083,                 c3664,                 r3665);               this.value.i3735 = this.i3735;         }         else             this.value = z2034.NaN.copy();                           await this.i4099(parse);           this.e4100(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   !this.options.enabled             || !this.value.start.isValid()             || !this.value.end  .isValid())             return;                                   this.value.objects = [];           if (   this.value.start.isValid()             && this.value.end  .isValid())         {             const path = new n1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 [ this.value.start,                   this.value.c3664.isValid() ? this.value.c3664 : this.value.start,                   this.value.r3665  .isValid() ? this.value.  r3665 : this.value.end,                   this.value.end ],                 0,                 2,                  0,                 0);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               path.h4097(x, y);             path.b3729(x, y, w, h);              this.value.objects.push(path);         }           await super.i4099(parse);     }                                                                               isValid()     {         return super.isValid()             && this.c3664.isValid()             && this.r3665  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.c3664) this.c3664.g4087(parse);         if (this.r3665  ) this.r3665  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.c3664) this.c3664.y4088(parse, from, force);         if (this.r3665  ) this.r3665  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.c3664) this.c3664.c4086(parse);         if (this.r3665  ) this.r3665  .c4086(parse);     } }


class b1984 extends t1973 {     inputs  = [];      loops   = null;     winding = null;        constructor(nodeId, options)     {         super(b1259, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.loops   = null;         this.winding = null;     }        copy()     {         const copy = new b1984(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.winding) copy.winding = this.winding.copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'loops':   return this.input ? this.value.loops   : this.loops;             case 'winding': return this.input ? this.value.winding : this.winding;         }          return super.y4241(f2991);     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached()             && this.winding.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const winding = await evalNumberValue(this.winding, parse);           this.loops = new b2020();           const loop = new b2020();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorEdgeValue(this.inputs[i], parse);              if (h957(input.type))             {                 const _loop = new b2020();                  for (let j = 0; j < input.items.length; j++)                 {                     const item = input.items[j];                      if (item.type == s1255)                     {                         const edge = item.copy();                          if (_loop.items.length > 0)                         {                             const prevEdge = _loop.items.at(-1);                              if (   edge.end.x.equals(prevEdge.end.x)                                 && edge.end.y.equals(prevEdge.end.y))                             {                                 [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                                 [edge.c3664, edge.r3665] = [edge.r3665, edge.c3664];                             }                         }                          _loop.items.push(edge);                     }                 }                  if (!isEmpty(_loop.items))                     loops.items.push(_loop);             }             else             {                 g952(                      input.type == s1255,                      'input.type must be VECTOR_EDGE_VALUE');                  const edge = input.copy();                  if (loop.items.length > 0)                 {                     const prevEdge = loop.items.at(-1);                      if (   edge.end.x.equals(prevEdge.end.x)                         && edge.end.y.equals(prevEdge.end.y))                     {                         [edge.start,        edge.end       ] = [edge.end,        edge.start       ];                         [edge.c3664, edge.r3665] = [edge.r3665, edge.c3664];                     }                 }                  loop.items.push(edge);             }         }           if (!isEmpty(loop.items))             this.loops.items.push(loop);           this.value = new q2037(             this.nodeId,             this.loops,              winding);           this.value.i3735 = this.i3735;           this.e4100(parse,         [             ['value',   this.value],             ['winding', winding   ]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];                   if (   this.loops  .isValid()             && this.winding.isValid())         {             const regions = [];               for (let i = 0; i < this.loops.items.length; i++)             {                 const loop = this.loops.items[i];                   const points = [];                      for (let j = 0; j < loop.items.length; j++)                 {                     const edge = loop.items[j];                     const next = loop.items[j == loop.items.length-1 ? 0 : j+1];                      points.push(                            edge.start.i3735 == next.start.i3735                         || edge.start.i3735 == next.end  .i3735                         ? edge.end                           : edge.start);                 }                   regions.push(new n1852(                     this.nodeId,                     this.nodeId + '/' + i,                     this.nodeName,                     points,                     1,                     0,                      this.winding.value,                     0));             }                           let bounds = getObjBounds(regions);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               for (const region of regions)             {                 region.h4097(x, y);                 region.b3729(x, y, w, h);                  this.value.objects.push(region);             }         }           await super.i4099(parse);     }                                                                          isValid()     {         if (!super.isValid())             return false;                      for (const input of this.inputs)             if (!input.isCached())                 return false;                  return this.winding.isValid()             && this.props  .isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.winding) this.winding.g4087(parse);         if (this.props  ) this.props  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.winding) this.winding.y4088(parse, from, force);         if (this.props  ) this.props  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.winding) this.winding.c4086(parse);         if (this.props  ) this.props  .c4086(parse);     } }


class o1982 extends t1973 {     inputs = [];        constructor(nodeId, options)     {         super(z1262, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new o1982(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const regions = new b2020();          for (let i = 0; i < this.inputs.length; i++)         {             const input = await evalVectorRegionValue(this.inputs[i], parse);              g952(                  input.type == w1258,                  'input.type must be VECTOR_REGION_VALUE');              regions.items.push(input);         }           this.value = new d2035(             this.nodeId,             regions);           this.e4100(parse,          [             ['value', this.value]         ]);           await this.l2895(parse);                   await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];           if (!isEmpty(this.value.regions.items))         {             let points  = [];             let edges   = [];             let regions = [];               for (const region of this.value.regions.items)             {                 if (!isEmpty(region.objects))                     region.fills = region.objects[0].fills;                   if (region.loops)                 {                     for (const loop of region.loops.items)                     {                         for (const edge of loop.items)                         {                             u950(points, edge.start, p => p.i3735 == edge.start.i3735);                             u950(points, edge.end,   p => p.i3735 == edge.end  .i3735);                              u950(edges, edge, e => e.i3735 == edge.i3735);                         }                     }                      u950(regions, region, r => r.i3735 == region.i3735);                 }             }                           const network = new a1851(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 edges,                 regions);                           const bounds = getObjBounds([network]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               network.h4097(x, y);             network.b3729(x, y, w, h);              this.value.objects.push(network);         }           await super.i4099(parse);     }                                                                isValid()     {         return super.isValid()             && this.regions.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.g4087(parse));     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));     } }


class GArcPath extends t1973 {     position = null;     start    = null;     sweep    = null;      sweepInDegrees;        constructor(nodeId, options)     {         super(v1230, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.start    = null;         this.sweep    = null;     }        copy()     {         const copy = new GArcPath(this.nodeId, this.options);          copy.z3358(this);          if (this.position) copy.position = this.position.copy();         if (this.start   ) copy.start    = this.start   .copy();         if (this.sweep   ) copy.sweep    = this.sweep   .copy();                  return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'start':    return this.input ? this.value.start    : this.start;             case 'sweep':    return this.input ? this.value.sweep    : this.sweep;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = await evalArcPathValue(this.input,    parse);         let pos   = await evalNumberValue (this.position, parse);         let start = await evalNumberValue (this.start,    parse);         let sweep = await evalNumberValue (this.sweep,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.i3625(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (start )  this.value.start    = start;   else  start  = this.value.start;             if (sweep )  this.value.sweep    = sweep;   else  sweep  = this.value.sweep;         }         else         {             this.value = new ArcPathValue(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 start,                 sweep);         }           this.e4100(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['start',    start ],             ['sweep',    sweep ]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.p2896()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x   = vpos.value <= 0 ? vx : new x2021(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y   = vpos.value <= 0 ? vy : new x2021(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w   = vpos.value <= 0 ? vw : new x2021(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h   = vpos.value <= 0 ? vh : new x2021(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x    = _x.value;             let   y    = _y.value;             let   w    = _w.value;             let   h    = _h.value;             const st   = this.value.start.value/360 * Tau;             let   sw   = this.value.sweep.value/100 * Tau;               [x, , w, , , ] = validateObjectRect(x, y, w, h);                                                          if (this.sweepInDegrees) sw /= 3.6;                  const arc = new FigmaArcPath(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     vpos.value,                     x, y, w, h, st, sw);                   const bounds = getObjBounds([arc]);                          arc.v3741(x + w/2, y + h/2);                 arc.h4097(bounds.x, bounds.y);                 arc.b3729(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(arc);                      }           await super.i4099(parse);     }                       isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.start    && this.start   .isValid()             && this.sweep    && this.sweep   .isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.position) this.position.g4087(parse);         if (this.start   ) this.start   .g4087(parse);         if (this.sweep   ) this.sweep   .g4087(parse);     }                   y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.position) this.position.y4088(parse, from, force);         if (this.start   ) this.start   .y4088(parse, from, force);         if (this.sweep   ) this.sweep   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);           if (this.position) this.position.c4086(parse);         if (this.start   ) this.start   .c4086(parse);         if (this.sweep   ) this.sweep   .c4086(parse);     } }


class GWavePath extends t1973 {     shape     = null;     amplitude = null;     frequency = null;     offset    = null;     alignX    = null;     alignY    = null;      useWavelength;     offsetAbsolute;        constructor(nodeId, options)     {         super(x1233, nodeId, options);     }        reset()     {         super.reset();          this.shape     = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.alignX    = null;         this.alignY    = null;     }        copy()     {         const copy = new GWavePath(this.nodeId, this.options);          copy.z3358(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.alignX   ) copy.alignX    = this.alignX   .copy();         if (this.alignY   ) copy.alignY    = this.alignY   .copy();                  return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'shape':     return this.input ? this.value.shape     : this.shape;             case 'x':         return this.input ? this.value.x         : this.x;             case 'y':         return this.input ? this.value.y         : this.y;             case 'width':     return this.input ? this.value.width     : this.width;             case 'amplitude': return this.input ? this.value.amplitude : this.amplitude;             case 'frequency': return this.input ? this.value.frequency : this.frequency;             case 'offset':    return this.input ? this.value.offset    : this.offset;             case 'alignX':    return this.input ? this.value.alignX    : this.alignX;             case 'alignY':    return this.input ? this.value.alignY    : this.alignY;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, ] = await this.evalBaseParams(parse);           let input     = await evalWavePathValue(this.input,     parse);         let shape     = await evalNumberValue  (this.shape,     parse);         let amplitude = await evalNumberValue  (this.amplitude, parse);         let frequency = await evalNumberValue  (this.frequency, parse);         let offset    = await evalNumberValue  (this.offset,    parse);         let alignX    = await evalNumberValue  (this.alignX,    parse);         let alignY    = await evalNumberValue  (this.alignY,    parse);           if (input)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;             this.value.i3625(input);              if (shape    )  this.value.shape     = shape;      else  shape      = this.value.shape;             if (x        )  this.value.x         = x;          else  x          = this.value.x;                   if (y        )  this.value.y         = y;          else  y          = this.value.y;                   if (width    )  this.value.width     = width;      else  width      = this.value.width;               if (amplitude)  this.value.amplitude = amplitude;  else  amplitude  = this.value.amplitude;             if (frequency)  this.value.frequency = frequency;  else  frequency  = this.value.frequency;             if (offset   )  this.value.offset    = offset;     else  offset     = this.value.offset;             if (alignX   )  this.value.alignX    = alignX;     else  alignX     = this.value.alignX;             if (alignY   )  this.value.alignY    = alignY;     else  alignY     = this.value.alignY;         }         else         {             this.value = new WavePathValue(                 this.nodeId,                 shape,                 x,                  y,                  width,                  amplitude,                 frequency,                 offset,                 alignX,                 alignY);         }           this.e4100(parse,          [             ['shape',     shape    ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['amplitude', amplitude],             ['frequency', frequency],             ['offset',    offset   ],             ['alignX',    alignX   ],             ['alignY',    alignY   ]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.p2896()             && this.value.shape    .isValid()             && this.value.x        .isValid()             && this.value.y        .isValid()             && this.value.width    .isValid()             && this.value.amplitude.isValid()             && this.value.frequency.isValid()             && this.value.offset   .isValid()             && this.value.alignX   .isValid()             && this.value.alignY   .isValid())         {             const sh     = this.value.shape    .value;             let   x      = this.value.x        .value;             let   y      = this.value.y        .value;             let   w      = this.value.width    .value;             const amp    = this.value.amplitude.value;             let   freq   = this.value.frequency.value;             const off    = this.value.offset   .value;             const alignX = this.value.alignX   .value;             const alignY = this.value.alignY   .value;               [x, y, w, , ] = validateObjectRect(x, y, w, 0);               const _freq = this.useWavelength ? w/nozero(freq) : freq;             const wl    = this.useWavelength ? freq : w/nozero(freq);              const so    = this.shape.value >= 3 ? 0.25 : 0;              const _off =                 this.offsetAbsolute                 ? off - so*wl                 : (off/100 - so) * wl;                                                          const wave = new FigmaWavePath(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     sh,                      x, y, w,                     amp,                     _freq,                     _off,                     alignX,                     alignY);                   const bounds = getObjBounds([wave]);                  wave.v3741(                     bounds.x + bounds.width /2,                                 bounds.y + bounds.height/2                             );                  wave.h4097(bounds.x, bounds.y);                 wave.b3729(bounds.x, bounds.y, bounds.w, bounds.h);                   this.value.objects.push(wave);                      }           await super.i4099(parse);     }                       isValid()     {         return super.isValid()             && this.shape     && this.shape    .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.alignX    && this.alignX   .isValid()             && this.alignY    && this.alignY   .isValid();     }        g4087(parse)     {         super.g4087(parse);           if (this.shape    ) this.shape    .g4087(parse);         if (this.amplitude) this.amplitude.g4087(parse);         if (this.frequency) this.frequency.g4087(parse);         if (this.offset   ) this.offset   .g4087(parse);         if (this.alignX   ) this.alignX   .g4087(parse);         if (this.alignY   ) this.alignY   .g4087(parse);     }                   y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.shape    ) this.shape    .y4088(parse, from, force);         if (this.amplitude) this.amplitude.y4088(parse, from, force);         if (this.frequency) this.frequency.y4088(parse, from, force);         if (this.offset   ) this.offset   .y4088(parse, from, force);         if (this.alignX   ) this.alignX   .y4088(parse, from, force);         if (this.alignY   ) this.alignY   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);           if (this.shape    ) this.shape    .c4086(parse);         if (this.amplitude) this.amplitude.c4086(parse);         if (this.frequency) this.frequency.c4086(parse);         if (this.offset   ) this.offset   .c4086(parse);         if (this.alignX   ) this.alignX   .c4086(parse);         if (this.alignY   ) this.alignY   .c4086(parse);     } }


class y1975 extends k1974 {     inputs = [];        constructor(nodeId, options)     {         super(p1265, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new y1975(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new d2027(this.nodeId);          this.value.objects = [];                  const inputs = [];                  if (this.options.enabled)         {             for (let i = 0; i < this.inputs.length; i++)             {                 const input = await evalValue(this.inputs[i], parse);                  if (input)                             {                     inputs.push(input);                      if (   input.type == s1059                         || input.type == q1056)                     {                         for (const item of input.items)                         {                             if (!p1294.includes(item.type))                                 continue;                              this.value.items.push(item);                                                      }                     }                     else                     {                         this.value.items.push(input);                                              }                 }             }         }           this.e4100(parse,          [             ['value', this.value]         ]);                      await this.i4099(parse, {inputs: inputs});           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                       if (this.value.items)         {             const group = new o1847(                 this.nodeId,                 this.nodeId,                 this.nodeName);               for (let i = 0; i < options.inputs.length; i++)             {                 const input = options.inputs[i];                  if (input.objects)                 {                     for (let j = 0; j < input.objects.length; j++)                         this.y3736(group.children, input.objects[j], i, j);                 }             }                                 const bounds = getObjBounds(group.children);              const singlePoint =                    group.children.length  == 1                  && group.children[0].type == l1246;              for (const l111 of group.children)             {                                                        l111.v3741(l111.sp0.x, l111.sp0.y);                                                                     l111.resetSpace(bounds, singlePoint);             }               group.x      = bounds.x;             group.y      = bounds.y;             group.width  = bounds.width;             group.height = bounds.height;                           group.v3741();             group.resetSpace(bounds);              group.h4097(bounds.x, bounds.y);             group.b3729(bounds.x, bounds.y, bounds.width, bounds.height);               this.value.objects = [group];         }         else         {             this.value.objects = [];         }           await super.i4099(parse);     }        y3736(objects, _obj, inputIndex, objIndex)     {         const l111 = j3737(_obj);          l111.nodeId    = this.nodeId;         l111.objectId += y967 + inputIndex;         l111.listId    = -1;          objects.push(l111);     }        t3632()     {         return this.value.copy();     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return true;     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));     } }


class d1956 extends t1973 {     children = null;     position = null;     round    = null;     clip     = null;        constructor(nodeId, options)     {         super(k1268, nodeId, options);     }        reset()     {         super.reset();          this.children = null;         this.position = null;         this.round    = null;         this.clip     = null;     }        copy()     {         const copy = new d1956(this.nodeId, this.options);          copy.z3358(this);          if (this.children) copy.children = this.children.copy();         if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.clip    ) copy.clip     = this.clip    .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'children': return this.input ? this.value.children : this.children;             case 'position': return this.input ? this.value.position : this.position;             case 'x':        return this.input ? this.value.x        : this.x;             case 'y':        return this.input ? this.value.y        : this.y;             case 'width':    return this.input ? this.value.width    : this.width;             case 'height':   return this.input ? this.value.height   : this.height;             case 'round':    return this.input ? this.value.round    : this.round;             case 'clip':     return this.input ? this.value.clip     : this.clip;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const [x, y, width, height] = await this.evalBaseParams(parse);          let children = await evalListValue  (this.children, parse);         let position = await evalNumberValue(this.position, parse);         let round    = await evalNumberValue(this.round,    parse);         let clip     = await evalNumberValue(this.clip,     parse);           if (   children             && p1294.includes(children.type)             && children.type != s1059)         {             const objects    = children.objects;             children         = new b2020([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalFrameValue(this.input, parse);              this.value = new a2013(                 this.nodeId,                 children ?? input.children,                 position ?? input.position,                 x        ?? input.x,                 y        ?? input.y,                 width    ?? input.width,                 height   ?? input.height,                 round    ?? input.round,                 clip     ?? input.clip);         }         else         {             this.value = new a2013(                 this.nodeId,                  children,                 position,                 x,                  y,                  width,                 height,                  round,                 clip);         }           const childType = new v2032(r3478(children.items));          this.e4100(parse,          [             ['childType', childType],             ['position',  position ],             ['x',         x        ],             ['y',         y        ],             ['width',     width    ],             ['height',    height   ],             ['round',     round    ],             ['clip',      clip     ]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.children) this.children = this.value.children.copy();         if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.clip    ) this.clip     = this.value.clip    .copy();           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.position             && this.value.x             && this.value.y             && this.value.width             && this.value.height             && this.value.round             && this.value.clip)         {             let   pos = this.value.position.value;             let   x   = this.value.x       .value;             let   y   = this.value.y       .value;             let   w   = this.value.width   .value;             let   h   = this.value.height  .value;             const r   = Math.max(0, this.value.round.value);             const c   = this.value.clip    .value;               const frame = new x1840(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x, y, w, h, r, c);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == l1246;                               const xoff = b893(-x, -y);              for (let i = 0; i < this.value.objects.length; i++)             {                 const l111 = this.value.objects[i];                                                     l111.v3741();                                                                     l111.resetSpace(bounds, singlePoint);                  if (pos > 0)                     l111.r4098(xoff, 2);                  this.y3736(frame.children, l111);             }               frame.h4097(x, y);             frame.b3729(x, y, w, h);                      this.value.objects = [frame];                           this.e4100(parse,              [                 ['nChildren', new x2021(frame.children.length)]             ],              true);         }           await super.i4099(parse);     }        y3736(objects, _obj)     {         const l111 = j3737(_obj);                              l111.nodeId   = this.nodeId;         l111.objectId = l111.objectId + y967 + this.nodeId;         l111.listId   = -1;                  objects.push(l111);     }        t3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children && this.children.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.children) this.children.g4087(parse);         if (this.position) this.position.g4087(parse);         if (this.round   ) this.round   .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.children) this.children.y4088(parse, from, force);         if (this.position) this.position.y4088(parse, from, force);         if (this.round   ) this.round   .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.children) this.children.c4086(parse);         if (this.position) this.position.c4086(parse);         if (this.round   ) this.round   .c4086(parse);     } }


class x1952 extends f2043 {     props   = null;     replace = null;        constructor(nodeId, options)     {         super(n1277, nodeId, options);     }        reset()     {         super.reset();          this.props   = null;         this.replace = null;     }        copy()     {         const copy = new x1952(this.nodeId, this.options);          copy.z3358(this);          if (this.props  ) copy.props   = this.props  .copy();         if (this.replace) copy.replace = this.replace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input   = await evalValue    (this.input,   parse);         const props   = await evalListValue(this.props,   parse);         const replace = await evalValue    (this.replace, parse);            if (input)         {             this.value         = input;             this.value.props   = props;             this.value.replace = replace;         }         else         {             this.value = new c4216();         }                  await this.i4099(parse);           this.e4100(parse,          [             ['type',    this.outputType()],                          ['props',   props            ],             ['replace', replace          ]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (this.value.isValid())         {             this.value.objects =                     this.input                  && this.input.value                 ? this.input.value.objects.map(o => o.copy())                  : [];         }           if (this.value.objects)         {             for (const l111 of this.value.objects)             {                 l111.nodeId   = this.nodeId;                 l111.objectId = l111.objectId + y967 + this.nodeId;             }              this.applyProps(this.value.objects, this.value.props, this.value.replace.value);         }                   await super.i4099(parse);     }        applyProps(objects, props, replace)     {         for (const l111 of objects)         {             if (this.options.enabled)             {                                                                                                                                          {                     if (replace == 1)                     {                         l111.fills    = [];                         l111.strokes  = [];                         l111.effects  = [];                         l111.maskType = 0;                     }                       if (h957(props.type))                     {                                        for (let i = props.items.length-1; i >= 0; i--)                             w1822(l111, props.items[i]);                     }                     else                         w1822(l111, props);                 }             }         }     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }            isValid()     {         return super.isValid()             && this.props   && this.props  .isValid()             && this.replace && this.replace.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.props  ) this.props  .g4087(parse);         if (this.replace) this.replace.g4087(parse);     }       y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.props  ) this.props  .y4088(parse, from, force);         if (this.replace) this.replace.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.props  ) this.props  .c4086(parse);         if (this.replace) this.replace.c4086(parse);     } }


class y1946 extends t1973 {     children  = null;     operation = null;        constructor(nodeId, options)     {         super(q1286, nodeId, options);     }        reset()     {         super.reset();          this.children  = null;         this.operation = null;     }        copy()     {         const copy = new y1946(this.nodeId, this.options);          copy.z3358(this);          if (this.children ) copy.children  = this.children .copy();         if (this.operation) copy.operation = this.operation.copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'children':  return this.input ? this.value.children  : this.children;             case 'operation': return this.input ? this.value.operation : this.operation;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           await this.evalBaseParams(parse);          let   children  = await evalListValue  (this.children,  parse);         const operation = await evalNumberValue(this.operation, parse);           if (   children             && p1294.includes(children.type)             && children.type != s1059)         {             const objects    = children.objects;             children         = new b2020([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = await evalValue(this.input, parse);              this.value = new d2026(                 this.nodeId,                 children  ?? input.children,                 operation ?? input.operation);         }         else         {             this.value = new d2026(                 this.nodeId,                  children,                 operation);         }           this.e4100(parse,         [             ['operation', operation]         ]);           await this.l2895(parse);           await this.i4099(parse);           if (!this.children ) this.children  = this.value.children .copy();         if (!this.operation) this.operation = this.value.operation.copy();           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.objects             && this.value.operation)         {             let typeSuffix = '';              switch (this.operation.value)             {                 case 0: typeSuffix = '+'; break;                 case 1: typeSuffix = '-'; break;                 case 2: typeSuffix = '*'; break;                 case 3: typeSuffix = '/'; break;             }               const bool = new p1837(                 this.nodeId,                 this.nodeId + y967 + typeSuffix,                 this.nodeName,                 this.operation.value);               const bounds = getObjBounds(this.value.objects);              for (let i = 0; i < this.value.objects.length; i++)             {                 const l111 = this.value.objects[i];                                                     l111.v3741();                                                                     l111.resetSpace(bounds, false);                  this.y3736(bool.children, l111);             }                            bool.x      = bounds.x;             bool.y      = bounds.y;             bool.width  = bounds.width;             bool.height = bounds.height;                           bool.v3741();             bool.resetSpace(bounds);              bool.h4097(bounds.x, bounds.y);             bool.b3729(bounds.x, bounds.y, bounds.width, bounds.height);                      this.value.objects = [bool];               const nChildren = new x2021(                 this.children.objects                  ? this.children.objects.length                 : 0);               this.e4100(parse,             [                 ['nChildren', nChildren]             ],             true);         }         else         {             this.value.objects = [];                          this.e4100(parse,             [                 ['nChildren', new x2021(0)]             ],             true);         }                   await super.i4099(parse);     }        y3736(objects, _obj)     {         const l111 = j3737(_obj);          l111.nodeId   = this.nodeId;         l111.objectId = l111.objectId + y967 + this.nodeId;         l111.listId   = -1;          objects.push(l111);     }       t3632()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children  && this.children .isValid()             && this.operation && this.operation.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.input    ) this.input    .g4087(parse);         if (this.children ) this.children .g4087(parse);         if (this.operation) this.operation.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.input    ) this.input    .y4088(parse, from, force);         if (this.children ) this.children .y4088(parse, from, force);         if (this.operation) this.operation.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.input    ) this.input    .c4086(parse);         if (this.children ) this.children .c4086(parse);         if (this.operation) this.operation.c4086(parse);     } }














class e1969 extends k1974 {     inputs = [];      retain = null;      finalize;        constructor(nodeId, options)     {         super(g1293, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];         this.retain = null;     }        copy()     {         const copy = new e1969(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          const retain   = await evalNumberValue(this.retain, parse);         const finalize = this.finalize.value > 0;           this.value = new b2020();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = d3627(this.inputs[i].value);                                   if (   this.options.enabled                 && (   finalize                     || retain.value == 1))             {                 for (let j = 0; j < objects.length; j++, o++)                 {                     let l111 = objects[j];                                            l111.nodeId   = this.nodeId;                     l111.objectId = l111.objectId + y967 + this.nodeId;                     l111.listId   = -1;                      if (  (   !isEmpty(l111.fills  )                            || !isEmpty(l111.strokes))                         && !l111.e3738)                             l111.retain = finalize ? 2 : 1;                                                  this.value.objects.push(l111);                 }             }         }           this.e4100(parse, [['', new c4216()]]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.retain && this.retain.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.retain) this.retain.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.retain) this.retain.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.retain) this.retain.c4086(parse);     } }


class GExport extends k1974 {     inputs = [];      scale;     format;         suffix;          constructor(nodeId, options)     {         super(EXPORT, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.scale    = null;         this.format   = null;                     this.suffix   = null;           }        copy()     {         const copy = new GExport(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.scale   ) copy.scale    = this.scale   .copy();         if (this.format  ) copy.format   = this.format  .copy();                     if (this.suffix  ) copy.suffix   = this.suffix  .copy();                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const scale      = await evalNumberValue(this.scale,    parse);         const format     = await evalNumberValue(this.format,   parse);                     const suffix     = await evalTextValue  (this.suffix,   parse);                 this.value = new b2020();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = d3627(this.inputs[i].value);                                   for (let j = 0; j < objects.length; j++, o++)             {                 let l111 = objects[j];                                    l111.nodeId   = this.nodeId;                 l111.objectId = l111.objectId + y967 + this.nodeId;                 l111.listId   = -1;                  this.value.objects.push(l111);             }         }           this.e4100(parse,          [             ['objectIds', new b2020(this.value.objects.map(o => new v2032(o.objectId)))]         ]);           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.scale    && this.scale   .isValid()             && this.format   && this.format  .isValid()                                 && this.suffix   && this.suffix  .isValid();               }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.scale   ) this.scale   .g4087(parse);         if (this.format  ) this.format  .g4087(parse);                     if (this.suffix  ) this.suffix  .g4087(parse);           }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.scale   ) this.scale   .y4088(parse, from, force);         if (this.format  ) this.format  .y4088(parse, from, force);                     if (this.suffix  ) this.suffix  .y4088(parse, from, force);           }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.scale   ) this.scale   .c4086(parse);         if (this.format  ) this.format  .c4086(parse);                     if (this.suffix  ) this.suffix  .c4086(parse);           } }


class v1961 extends f2043 {     g3661    = null;     x           = null;     y           = null;     affectSpace = null;          _a          = 0;        constructor(nodeId, options)     {         super(n1270, nodeId, options);     }        reset()     {         super.reset();          this.g3661    = null;         this.x           = null;         this.y           = null;         this.affectSpace = null;          this._a          = 0;     }        copy()     {         const copy = new v1961(this.nodeId, this.options);          copy.z3358(this);          if (this.g3661   ) copy.g3661    = this.g3661   .copy();         if (this.x          ) copy.x           = this.x          .copy();         if (this.y          ) copy.y           = this.y          .copy();         if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input       = await evalValue      (this.input,       parse);         const g3661    = await evalNumberValue(this.g3661,    parse);         const x           = await evalNumberValue(this.x,           parse);         const y           = await evalNumberValue(this.y,           parse);         const affectSpace = await evalNumberValue(this.affectSpace, parse);           if (input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new c4216();         }           await this.i4099(             parse,              {                 g3661:    g3661,                 x:           x,                  y:           y,                 affectSpace: affectSpace             });           this.e4100(parse,         [             ['type',        this.outputType()],             ['moveType',    g3661         ],             ['x',           x                ],             ['y',           y                ],             ['affectSpace', affectSpace      ]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   this.value             && this.value.isValid()             && options.g3661             && options.x             && options.y             && options.affectSpace)         {             this.value.objects = d3627(this.input.value);               if (h957(this.value.type))             {                 for (let i = 0; i < this.value.items.length; i++)                     this.value.items[i].objects = this.value.objects.filter(o => o.m3819 == i);             }                              const g3661    = options.g3661   .value;             const x           = options.x          .value;             const y           = options.y          .value;             const affectSpace = options.affectSpace.value;               let _a = y/360*Tau;              while (_a <  0  ) _a += Tau;             while (_a >= Tau) _a -= Tau;                   const _v = vector(_a, x);                          const _x = g3661 == 0 ? x : _v.x;             const _y = g3661 == 0 ? y : _v.y;               const c4207 =                  g3661 == 0                 ? b893(_x, _y)                 : y889(                     b893(_x, _y),                     y892(-_a));                                    for (const l111 of this.value.objects)             {                 l111.nodeId    = this.nodeId;                 l111.objectId += y967 + this.nodeId;                  if (this.options.enabled)                     l111.r4098(c4207, affectSpace);             }               if (   this.value.type == b1249                 && this.value.objects                 && this.value.objects.length > 0                 && this.value.points.objects)             {                 for (let i = 0; i < this.value.objects[0].points.length; i++)                 {                     const p = this.value.objects[0].points[i].z3746();                          this.value.points.objects[i].x = p.x;                     this.value.points.objects[i].y = p.y;                 }             }         }                           await super.i4099(parse);     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.g3661    && this.g3661   .isValid()             && this.x           && this.x          .isValid()             && this.y           && this.y          .isValid()             && this.affectSpace && this.affectSpace.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.g3661   ) this.g3661   .g4087(parse);         if (this.x          ) this.x          .g4087(parse);         if (this.y          ) this.y          .g4087(parse);         if (this.affectSpace) this.affectSpace.g4087(parse);     }       y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.g3661   ) this.g3661   .y4088(parse, from, force);         if (this.x          ) this.x          .y4088(parse, from, force);         if (this.y          ) this.y          .y4088(parse, from, force);         if (this.affectSpace) this.affectSpace.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.g3661   ) this.g3661   .c4086(parse);         if (this.x          ) this.x          .c4086(parse);         if (this.y          ) this.y          .c4086(parse);         if (this.affectSpace) this.affectSpace.c4086(parse);     } }


class d1951 extends f2043 {     affectSpace = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.affectSpace = null;     }        z3358(base)     {         super.z3358(base);          if (base.affectSpace) this.affectSpace = base.affectSpace.copy();     }        async evalBaseParams(parse)     {         const affectSpace = await evalNumberValue(this.affectSpace, parse);          return [affectSpace];     }        async evalAffineObjects(parse, options, c3739, scaleStyle, getXform)     {         if (   !this.value             || !this.value.isValid()             || !this.input)             return m1047.NaN;           this.value.objects = d3627(this.input.value);                  if (h957(this.value.type))         {             for (let i = 0; i < this.value.items.length; i++)                 this.value.items[i].objects = this.value.objects.filter(o => o.m3819 == i);         }           const bounds = getObjBounds(this.value.objects);         const c4207  = getXform();           for (const l111 of this.value.objects)         {             l111.nodeId   = this.nodeId;             l111.objectId = l111.objectId + y967 + this.nodeId;               if (this.options.enabled)             {                 l111.r4098(                     c4207,                      options.affectSpace ? options.affectSpace.value : 2);                  l111.checkFlipped(                     options.flipX === true && c4207[0][0] < 0,                      options.flipY === true && c4207[1][1] < 0);                                      l111.c3739 *= Math.abs(c3739);                 l111.scaleStyle   *= Math.abs(scaleStyle  );                                  if (l111.type == l1243)                 {                     const sx = Math.sqrt(sqr(c4207[0][0]) + sqr(c4207[0][1]));                     const sy = Math.sqrt(sqr(c4207[1][0]) + sqr(c4207[1][1]));                      l111.size *= Math.min(sx, sy);                 }             }         }           if (   this.value.type == b1249             && this.value.objects             && this.value.objects.length > 0             && this.value.points.objects)         {             for (let i = 0; i < this.value.objects[0].points.length; i++)             {                 const p = this.value.objects[0].points[i].z3746();                  this.value.points.objects[i].x = p.x;                 this.value.points.objects[i].y = p.y;             }         }           return bounds;     }        isValid()     {         return super.isValid()             && this.affectSpace && this.affectSpace.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.affectSpace) this.affectSpace.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.affectSpace) this.affectSpace.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.affectSpace) this.affectSpace.c4086(parse);     } }


class e1971 extends d1951 {     angle = null;        constructor(nodeId, options)     {         super(c1271, nodeId, options);     }        reset()     {         super.reset();          this.angle = null;     }        copy()     {         const copy = new e1971(this.nodeId, this.options);          copy.z3358(this);          if (this.angle) copy.angle = this.angle.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const angle = await evalNumberValue(this.angle, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new c4216();         }                  const _bounds = await this.i4099(             parse,              {                 angle:       angle,                  affectSpace: affectSpace             });                   const bounds = new r2024(             this.nodeId,             new x2021(_bounds.x     ),              new x2021(_bounds.y     ),              new x2021(_bounds.width ),             new x2021(_bounds.height),             new x2021(0));           this.e4100(parse,         [             ['type',        this.outputType()],             ['angle',       angle            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async i4099(parse, options)     {         const a     = options.angle ? options.angle.value/360*Tau : 0;         const c4207 = y892(a);          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1,              1,             () => c4207);     }        t3632()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.angle && this.angle.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.angle) this.angle.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.angle) this.angle.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.angle) this.angle.c4086(parse);     } }


class p1972 extends d1951 {     scaleX        = null;     scaleY        = null;     affectCorners = null;     affectStyle   = null;            constructor(nodeId, options)     {         super(c1272, nodeId, options);     }        reset()     {         super.reset();          this.scaleX        = null;         this.scaleY        = null;         this.affectCorners = null;         this.affectStyle   = null;     }        copy()     {         const copy = new p1972(this.nodeId, this.options);          copy.z3358(this);          if (this.scaleX       ) copy.scaleX        = this.scaleX       .copy();         if (this.scaleY       ) copy.scaleY        = this.scaleY       .copy();         if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();         if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = await evalValue      (this.input,         parse);         let   scaleX        = await evalNumberValue(this.scaleX,        parse);         let   scaleY        = await evalNumberValue(this.scaleY,        parse);         let   affectCorners = await evalNumberValue(this.affectCorners, parse);         let   affectStyle   = await evalNumberValue(this.affectStyle,   parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input.copy();                          if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new c4216();         }                  const _bounds = await this.i4099(             parse,              {                 scaleX:        scaleX,                  scaleY:        scaleY,                  affectSpace:   affectSpace,                 affectCorners: affectCorners,                 affectStyle:   affectStyle             });           const bounds = new r2024(             this.nodeId,             new x2021(_bounds.x     ),              new x2021(_bounds.y     ),              new x2021(_bounds.width ),             new x2021(_bounds.height),             new x2021(0));           this.e4100(parse,         [             ['type',          this.outputType()],             ['scaleX',        scaleX           ],             ['scaleY',        scaleY           ],             ['affectSpace',   affectSpace      ],             ['affectCorners', affectCorners    ],             ['affectStyle',   affectStyle      ],             ['bounds',        bounds           ]         ]);                   this.validate();          return this;     }        async i4099(parse, options)     {         let sx = x879(options.scaleX.value / 100);         let sy = x879(options.scaleY.value / 100);          options.flipX = sx < 0;         options.flipY = sy < 0;                  const scale = Math.min(sx, sy);          return await this.evalAffineObjects(             parse,             options,              this.affectCorners.value > 0 ? scale : 1,             this.affectStyle  .value > 0 ? scale : 1,             () => [[sx, 0,  0],                    [0,  sy, 0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.scaleX        && this.scaleX       .isValid()             && this.scaleY        && this.scaleY       .isValid()             && this.affectCorners && this.affectCorners.isValid()             && this.affectStyle   && this.affectStyle  .isValid();     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        g4087(parse)     {         super.g4087(parse);          if (this.scaleX       ) this.scaleX       .g4087(parse);         if (this.scaleY       ) this.scaleY       .g4087(parse);         if (this.affectCorners) this.affectCorners.g4087(parse);         if (this.affectStyle  ) this.affectStyle  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.scaleX       ) this.scaleX       .y4088(parse, from, force);         if (this.scaleY       ) this.scaleY       .y4088(parse, from, force);         if (this.affectCorners) this.affectCorners.y4088(parse, from, force);         if (this.affectStyle  ) this.affectStyle  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.scaleX       ) this.scaleX       .c4086(parse);         if (this.scaleY       ) this.scaleY       .c4086(parse);         if (this.affectCorners) this.affectCorners.c4086(parse);         if (this.affectStyle  ) this.affectStyle  .c4086(parse);     } }


class i1976 extends d1951 {     skewX = null;     skewY = null;        constructor(nodeId, options)     {         super(e1273, nodeId, options);     }        reset()     {         super.reset();          this.skewX = null;         this.skewY = null;     }        copy()     {         const copy = new i1976(this.nodeId, this.options);          copy.z3358(this);          if (this.skewX) copy.skewX = this.skewX.copy();         if (this.skewY) copy.skewY = this.skewY.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalValue      (this.input, parse);         let   skewX = await evalNumberValue(this.skewX, parse);         let   skewY = await evalNumberValue(this.skewY, parse);           const [affectSpace] = await this.evalBaseParams(parse);           if (input)         {             this.value = input;              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new c4216();         }                   const _bounds = await this.i4099(             parse,              {                 skewX:       skewX,                  skewY:       skewY,                  affectSpace: affectSpace             });           const bounds = new r2024(             this.nodeId,             new x2021(_bounds.x     ),              new x2021(_bounds.y     ),              new x2021(_bounds.width ),             new x2021(_bounds.height),             new x2021(0));           this.e4100(parse,         [             ['type',        this.outputType()],             ['skewX',       skewX            ],             ['skewY',       skewY            ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async i4099(parse, options)     {         const sx = -options.skewX.value / 100;         const sy = -options.skewY.value / 100;          options.flipX = false;         options.flipY = false;          return await this.evalAffineObjects(             parse,             options,              1, 1,             () => [[1,  sx, 0],                    [sy, 1,  0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.skewX && this.skewX.isValid()             && this.skewY && this.skewY.isValid();     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        g4087(parse)     {         super.g4087(parse);          if (this.skewX) this.skewX.g4087(parse);         if (this.skewY) this.skewY.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.skewX) this.skewX.y4088(parse, from, force);         if (this.skewY) this.skewY.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.skewX) this.skewX.c4086(parse);         if (this.skewY) this.skewY.c4086(parse);     } }


class GShowCenter extends f2043 {     show = null;        constructor(nodeId, options)     {         super(SHOW_CENTER, nodeId, options);     }        copy()     {         const copy = new GShowCenter(this.nodeId, this.options);          copy.z3358(this);          if (this.show) copy.show = this.show.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue      (this.input, parse);         const show  = await evalNumberValue(this.show,  parse);           if (   input             && show)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new c4216();                   await this.i4099(parse, {show: show && show.value > 0});           const type = this.outputType();          this.e4100(parse,         [             ['type', type],             ['show', show]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = d3627(this.input.value);               for (const l111 of this.value.objects)             {                 l111.nodeId   = this.nodeId;                 l111.objectId = l111.objectId + y967 + this.nodeId;                                  if (   this.options.enabled                     && options.show)                     l111.showCenter = options.show;             }         }                           await super.i4099(parse);     }        t3632()     {         return this.value         ? this.value.copy()         : null;     }        isValid()     {         return super.isValid()             && this.show && this.show.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.show) this.show.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.show) this.show.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.show) this.show.c4086(parse);     } }


class f1953 extends f2043 {     centerX = null;     centerY = null;     units   = null;        constructor(nodeId, options)     {         super(j1274, nodeId, options);     }        reset()     {         super.reset();          this.centerX = null;         this.centerY = null;         this.units   = null;     }        copy()     {         const copy = new f1953(this.nodeId, this.options);          copy.z3358(this);          if (this.centerX) copy.centerX = this.centerX.copy();         if (this.centerY) copy.centerY = this.centerY.copy();         if (this.units  ) copy.units   = this.units  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input   = await evalValue      (this.input,   parse);         const centerX = await evalNumberValue(this.centerX, parse);         const centerY = await evalNumberValue(this.centerY, parse);         const units   = await evalNumberValue(this.units,   parse);           if (this.input)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new c4216();         }                   await this.i4099(             parse,              {                 centerX:    centerX,                  centerY:    centerY,                 units:      units             });           const type = this.outputType();          this.e4100(parse,         [             ['type',    type   ],             ['centerX', centerX],             ['centerY', centerY],             ['units',   units  ]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = d3627(this.input.value);                           const centerX = options.centerX    ? options.centerX   .value : 0;             const centerY = options.centerY    ? options.centerY   .value : 0;             const units   = options.units      ? options.units     .value : 0;                   const cx      = units == 0 ? centerX/100 : centerX;             const cy      = units == 0 ? centerY/100 : centerY;               const bounds  = getObjBounds(this.value.objects);               const singlePoint =                      this.value.objects.length  == 1                  && this.value.objects[0].type == l1246;               for (const l111 of this.value.objects)             {                 l111.nodeId   = this.nodeId;                 l111.objectId = l111.objectId + y967 + this.nodeId;                  if (this.options.enabled)                     l111.resetSpace(bounds, singlePoint, cx, cy, units);             }         }                           await super.i4099(parse);     }        t3632()     {         return this.value             ? this.value.copy()             : null;     }                    isValid()     {         return super.isValid()             && this.centerX && this.centerX.isValid()             && this.centerY && this.centerY.isValid()             && this.units   && this.units  .isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.centerX) this.centerX.g4087(parse);         if (this.centerY) this.centerY.g4087(parse);         if (this.units  ) this.units  .g4087(parse);     }       y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.centerX) this.centerX.y4088(parse, from, force);         if (this.centerY) this.centerY.y4088(parse, from, force);         if (this.units  ) this.units  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.centerX) this.centerX.c4086(parse);         if (this.centerY) this.centerY.c4086(parse);         if (this.units  ) this.units  .c4086(parse);     } }


class g1970 extends f2043 {     constructor(nodeId, options)     {         super(e1275, nodeId, options);     }        copy()     {         const copy = new g1970(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalValue(this.input, parse);           if (input)         {             this.value = input;              this.value.nodeId = this.nodeId;         }         else             this.value = new c4216();                   await this.i4099(parse);           const type = this.outputType();          this.e4100(parse,         [             ['type', type]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = d3627(this.input.value);               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == l1246;               for (const l111 of this.value.objects)             {                 l111.nodeId    = this.nodeId;                 l111.objectId += y967 + this.nodeId;                  if (this.options.enabled)                 {                     l111.v3741();                     l111.resetSpace(bounds, singlePoint);                 }             }         }                           await super.i4099(parse);     }        t3632()     {         return this.value         ? this.value.copy()         : null;     } }


class GJoinPaths extends t1973 {     inputs  = [];      closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new GJoinPaths(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        y4241(f2991)     {         switch (f2991)         {             case 'closed':  return this.input ? this.value.closed  : this.closed;             case 'degree':  return this.input ? this.value.degree  : this.degree;             case 'winding': return this.input ? this.value.winding : this.winding;             case 'round':   return this.input ? this.value.round   : this.round;         }          return super.y4241(f2991);     }        async eval(parse)     {         if (this.isCached())             return this;           const closed  = await evalNumberValue(this.closed,  parse);         const degree  = await evalNumberValue(this.degree,  parse);         const winding = await evalNumberValue(this.winding, parse);         const round   = await evalNumberValue(this.round,   parse);           if (this.inputs.length > 0)         {             const paths  = [];             const points = new b2020();              for (const l3811 of this.inputs)             {                 const input = await evalVectorPathValue(l3811, parse);                  if (h957(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }                                          for (let i = 0; i < paths.length; i++)             {                 const path = paths[i];                                  if (   !path                     || !path.objects                     ||  path.objects.length == 0)                     continue;                   let _degree;                       if (path.type == b1249) _degree = path.degree.value;                 else if (path.type == x1231   ) _degree = 2;                 else if (path.type == g1234  ) _degree = path.shape.value == 4 ? 2 : 0;                   const o3745 = path.objects[0].o3745;                 const pathDegree = Math.min(_degree, 2) + 1;                                   if (o3745.length == 0) continue;                   const segment = this.makeCubic(o3745, pathDegree);                  if (   i > 0                     && points.items.length > 1                     && segment.length > 1)                     this.joinSegment(points, segment, degree);                  points.items.push(...segment.map(p => b2022.fromPoint(this.nodeId, p)));             }               if (   closed.value > 0                 && points.items.length > 1)             {                 const segment = [ points.items[0].z3746(),                                   points.items[1].z3746() ];                  this.joinSegment(points, segment, degree);                  points.items.push(points.items[0].copy());             }               this.value = new p2036(                 this.nodeId,                  points,                  closed,                  new x2021(2),                 winding,                  round);               this.value.points.objects = this.value.points.items.map(p =>             {                 return new b1843(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     p.x.value,                     p.y.value,                     p.smooth ? p.smooth.value/100 : 1);             });         }         else         {             this.value = new p2036(                 this.nodeId,                  new b2020(),                  closed,                  new x2021(2),                 winding,                  round);         }           this.e4100(parse,          [             ['closed',  closed ],             ['degree',  degree ],             ['winding', winding],             ['round',   round  ]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        joinSegment(points, segment, degree)     {         const p_2 = points.items.at(-2).z3746();         const p_1 = points.items.at(-1).z3746();          const p0  = segment[0];         const p1  = segment[1];          if (!e1019(p_1, p0))             points.items.push(...this.getJoinPoints(p_2, p_1, p0, p1, degree).map(p => b2022.fromPoint(this.nodeId, p)));         else             points.items.pop();     }        getJoinPoints(p_2, p_1, p0, p1, degree)     {         const points = [];           switch (degree.value)         {              case 0:                  points.push(w986(p_1, p0, 1/3));                 points.push(w986(p_1, p0, 2/3));                 break;              case 1:              {                 const c = a989(p_2, p_1, p1, p0, false);                 points.push(h895(p_1, n897(w886(p900(c, p_1)), Math.min(distv(p_2, p_1), distv(p_1, c) * 2/3))));                 points.push(h895(p0,  n897(w886(p900(c, p0 )), Math.min(distv(p1,  p0),  distv(p0,  c) * 2/3))));                 break;             }             case 2:                  points.push(h895(p_2, n897(p900(p_1, p_2), 2)));                 points.push(h895(p1,  n897(p900(p0,  p1),  2)));                 break;              case 3:                  points.push(point(x1035(p_1.x, p0.x, 0.3615), p_1.y));                 points.push(point(x1035(p0.x, p_1.x, 0.3615), p0 .y));                 break;              case 4:                  points.push(point(p_1.x, x1035(p_1.y, p0.y, 0.3615)));                 points.push(point(p0 .x, x1035(p0.y, p_1.y, 0.3615)));                 break;         }                   return points;     }        makeCubic(o3745, pathDegree)     {         const points = [o3745[0]];           for (let i = 0; i < o3745.length-pathDegree; i += pathDegree)         {             let segPoints;              switch (pathDegree)             {                 case 1: segPoints = linear2cubic(o3745.slice(i, i+2)); break;                 case 2: segPoints =   quad2cubic(o3745.slice(i, i+3)); break;                 case 3: segPoints =              o3745.slice(i, i+4);  break;             }              points.push(...segPoints.slice(1));          }                  return points;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          for (const pt of this.value.points.items)         {             const p = b2022.create(this.nodeId, pt.x.value, pt.y.value);                          if (pt.smooth != null)                 p.smooth = new x2021(pt.smooth);              points.push(p);         }           this.value.objects = [];           if (   super.p2896()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new n1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                               const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.v3741(x + w/2, y + h/2);             path.h4097(x, y);             path.b3729(x, y, w, h);              this.value.objects.push(path);         }           await super.i4099(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.closed ) this.closed .g4087(parse);         if (this.degree ) this.degree .g4087(parse);         if (this.winding) this.winding.g4087(parse);         if (this.round  ) this.round  .g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.closed ) this.closed .y4088(parse, from, force);         if (this.degree ) this.degree .y4088(parse, from, force);         if (this.winding) this.winding.y4088(parse, from, force);         if (this.round  ) this.round  .y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.closed ) this.closed .c4086(parse);         if (this.degree ) this.degree .c4086(parse);         if (this.winding) this.winding.c4086(parse);         if (this.round  ) this.round  .c4086(parse);     } }


class GReorientPaths extends t1973 {     inputs  = [];      reverse = null;        constructor(nodeId, options)     {         super(JOIN_PATHS, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.reverse = null;     }        copy()     {         const copy = new GReorientPaths(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.reverse) copy.reverse = this.reverse.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const reverse = await evalNumberValue(this.reverse, parse);           if (this.inputs.length > 0)         {             const paths = [];              for (const l3811 of this.inputs)             {                 const input = await evalVectorPathValue(l3811, parse);                  if (h957(input.type)) paths.push(...input.items);                 else                             paths.push(input);             }               this.value = new b2020();               const reorientedPaths =                  this.options.enabled                 ? reorientPaths(paths, reverse.value > 0)                 : paths                       .filter(path => path.objects && path.objects.length > 0)                       .map   (path => path.objects[0].o3745);         ;              g952(paths.length == reorientedPaths.length, 'original path count must match reoriented path count');                                       for (let i = 0; i < reorientedPaths.length; i++)             {                 const points =                      reorientedPaths[i]                     ? reorientedPaths[i].map(p => b2022.fromPoint(this.nodeId, p))                     :    paths[i]                     && paths[i].points                     ? paths[i].points.items                     : [];                  if (points.length == 0)                     continue;                                  const path = new p2036(                     this.nodeId,                     new b2020(points),                     paths[i].closed,                     paths[i].degree,                     paths[i].winding,                     paths[i].round);                                      path.z3358(paths[i]);                                  this.value.items.push(path);             }         }         else         {             this.value = new b2020();         }           this.e4100(parse,          [             ['reverse', reverse]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {         this.value.objects = [];           for (let i = 0; i < this.value.items.length; i++)         {             const _path = this.value.items[i];             if (!_path) continue;               if (   _path.points.items.length >= 2                 && _path.closed .isValid()                 && _path.degree .isValid()                 && _path.winding.isValid()                 && _path.round  .isValid())             {                 const path = new n1852(                      this.nodeId,                      this.nodeId + y967 + i,                      this.nodeName,                     _path.points.items,                     _path.closed .value,                     _path.degree .value,                     _path.winding.value,                     _path.round  .value);                   if (_path.props)                     addProps(path, _path.props);                                       _path.objects = [path];                  this.value.objects.push(path);             }         }           const bounds = getObjBounds(this.value.objects);          for (const path of this.value.objects)         {             path.v3741(                 bounds.x + bounds.width /2,                             bounds.y + bounds.height/2                         );               let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                          path.h4097(x, y);             path.b3729(x, y, w, h);         }           await super.i4099(parse);     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return this.reverse && this.reverse.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.reverse) this.reverse.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));              if (this.reverse) this.reverse.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.reverse) this.reverse.c4086(parse);     } }    function reorientPaths(paths, reverse)  {     const orderedPaths = [];      let remainingPaths = paths         .filter(path => path.objects && path.objects.length > 0)         .map   (path => path.objects[0].o3745);       orderedPaths.push(remainingPaths.shift());       while (remainingPaths.length > 0)      {         const currentPath = orderedPaths.at(-1);                  const { closestPathIndex, shouldReverse } = findNextPath(currentPath, remainingPaths);          if (closestPathIndex == -1)              break;           let nextPath = remainingPaths.splice(closestPathIndex, 1)[0];                  if (shouldReverse)             nextPath.reverse();          orderedPaths.push(nextPath);     }       return reverse          ? orderedPaths.reverse().map(path => path.slice().reverse())          : orderedPaths; }    function findNextPath(currentPath, remainingPaths) {     let minDistance      = Infinity;     let closestPathIndex = -1;     let shouldReverse    = false;       const currentEndPoint = currentPath.at(-1);      remainingPaths.forEach((path, index) =>      {         const distanceToStart = distv(currentEndPoint, path.at( 0));         const distanceToEnd   = distv(currentEndPoint, path.at(-1));          if (distanceToStart < minDistance)          {             minDistance      = distanceToStart;             closestPathIndex = index;             shouldReverse    = false;         }          if (distanceToEnd < minDistance)          {             minDistance      = distanceToEnd;             closestPathIndex = index;             shouldReverse    = true;         }     });       return { closestPathIndex, shouldReverse }; }


class s1960 extends f2043 {     length = null;     angle  = null;            constructor(nodeId, options)     {         super(y1278, nodeId, options);     }            reset()     {         super.reset();          this.length = null;         this.angle  = null;     }        copy()     {         const copy = new s1960(this.nodeId, this.options);          copy.z3358(this);          if (this.length) copy.length = this.length.copy();         if (this.angle ) copy.angle  = this.angle .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             const v   = input.z3746();              const len = s885(v);             let   ang = m883 (v);              if (ang > Tau/2) ang -= Tau;              this.length = new x2021(len, -2);              this.angle =                  len > 0                  ? new x2021(ang/Tau * 360, -2)                  : x2021.NaN.copy();         }         else         {             this.length = x2021.NaN.copy();             this.angle  = x2021.NaN.copy();         }           this.e4100(parse,         [             ['length', this.length],             ['angle',  this.angle ]         ]);                   this.validate();          return this;     } }


class GPointAngle extends f2043 {     constructor(nodeId, options)     {         super(y1279, nodeId, options);     }            copy()     {         const copy = new GPointAngle(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalPointValue(this.input, parse);           if (input)         {             if (h957(input.type))             {                 this.value = new b2020();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                     const l111  = input.objects[i];                      this.value.items.push(                         item.type == u1245                         ? new x2021(anglev2(l111.sp0, l111.sp1) / Tau * 360)                         : x2021.NaN.copy());                    }             }             else             {                 if (input.objects)                 {                     const l111 = input.objects[0];                     this.value = new x2021(anglev2(l111.sp0, l111.sp1) / Tau * 360);                 }             }         }         else             this.value = x2021.NaN.copy();           this.e4100(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }         


class q1981 extends k2044 {     transform = null;        constructor(nodeId, options)     {         super(v1280, nodeId, options);     }            reset()     {         super.reset();                  this.transform = null;     }        copy()     {         const copy = new q1981(this.nodeId, this.options);          copy.z3358(this);          if (this.transform) copy.transform = this.transform .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082    = await evalPointValue (this.b4082,    parse);         const o4083    = await evalPointValue (this.o4083,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   b4082 && b4082.objects && b4082.objects.length > 0 && b4082.objects[0]             && o4083 && o4083.objects && o4083.objects.length > 0 && o4083.objects[0])         {             this.value = b2022.fromPoint(                 this.nodeId,                 p900(o4083.objects[0].z3746(), b4082.objects[0].z3746()));              await this.i4099(                 parse,                  {                     transform: transform,                 });         }         else         {             this.value = b2022.NaN.copy();         }           this.e4100(parse,         [             ['transform', transform]         ]);                   this.validate();          return this;     }        async i4099(parse, options = {})     {                                                     if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new b1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);               point.h4097(x, y);                           if (options.transform.value > 0)             {                 point.r4098(                     getTransformFromAngle(m883(point.z3746())),                     2);             }                       this.value.objects = [point];         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid(); }        g4087(parse)     {         super.g4087(parse);          if (this.transform) this.transform.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.transform) this.transform.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.transform) this.transform.c4086(parse);     } }    function getTransformFromAngle(a)  {     const cosa = Math.cos(a);     const sina = Math.sin(a);      return [[ cosa, -sina, 0 ],              [ sina,  cosa, 0 ],              [ 0,     0,    1 ]]; }


class r1954 extends h2045 {     constructor(nodeId, options)     {         super(j1281, nodeId, options);     }                                   copy()     {         const copy = new r1954(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082 = await evalPointValue(this.b4082, parse);         const o4083 = await evalPointValue(this.o4083, parse);         const t4084 = await evalPointValue(this.t4084, parse);           if (   b4082 && b4082.isValid()             && o4083 && o4083.isValid()             && t4084 && t4084.isValid())         {             const pc = d996(                 b4082.z3746(),                 o4083.z3746(),                 t4084.z3746());              this.value = b2022.fromPoint(this.nodeId, pc);         }         else         {             this.value = b2022.NaN.copy();         }           await this.i4099(parse);           this.e4100(parse,          [             ['', new c4216()]                      ]);                   this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new b1843(this.nodeId, this.nodeId, this.nodeName, x, y);              point.h4097(x, y);              this.value.objects = [point];         }           await super.i4099(parse);     } }


class GArcFromPoints extends t1973 {     b4082  = null;     o4083  = null;     t4084  = null;            constructor(nodeId, options)     {         super(ARC_FROM_POINTS, nodeId, options);     }            reset()     {         super.reset();          this.b4082  = null;         this.o4083  = null;         this.t4084  = null;     }        copy()     {         const copy = new GArcFromPoints(this.nodeId, this.options);          copy.z3358(this);          if (base.b4082 ) this.b4082  = base.b4082 .copy();         if (base.o4083 ) this.o4083  = base.o4083 .copy();         if (base.t4084 ) this.t4084  = base.t4084 .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082 = await evalPointValue(this.b4082, parse);         const o4083 = await evalPointValue(this.o4083, parse);         const t4084 = await evalPointValue(this.t4084, parse);           if (   b4082 && b4082.isValid()             && o4083 && o4083.isValid()             && t4084 && t4084.isValid())         {                           const p0 = b4082.objects[0].z3746();             const p1 = o4083.objects[0].z3746();             const p2 = t4084.objects[0].z3746();              const points = makeArc(p0, p1, p2);              this.value = new p2036(                 this.nodeId,                 new b2020(points.map(p => b2022.fromPoint(this.nodeId, p))),                 new x2021(0),                 new x2021(2),                 new x2021(0),                 new x2021(0));         }         else         {             this.value = p2036.NaN.copy();         }           this.e4100(parse,          [             ['', new c4216()]         ]);           await this.l2895(parse);           await this.i4099(parse);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   const points = [];          if (this.value.points)         {             for (const pt of this.value.points.items)             {                 const p = b2022.create(this.nodeId, pt.x.value, pt.y.value);                                  if (pt.smooth != null)                     p.smooth = new x2021(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   points.length >= 2             && this.value             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new n1852(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.v3741(x + w/2, y + h/2);             path.h4097(x, y);             path.b3729(x, y, w, h);              this.value.objects.push(path);         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.b4082 && this.b4082.isValid()             && this.o4083 && this.o4083.isValid()             && this.t4084 && this.t4084.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.b4082) this.b4082.g4087(parse);         if (this.o4083) this.o4083.g4087(parse);         if (this.t4084) this.t4084.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.b4082) this.b4082.y4088(parse, from, force);         if (this.o4083) this.o4083.y4088(parse, from, force);         if (this.t4084) this.t4084.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.b4082) this.b4082.c4086(parse);         if (this.o4083) this.o4083.c4086(parse);         if (this.t4084) this.t4084.c4086(parse);     } }


class GPathLength extends f2043 {     length;        constructor(nodeId, options)     {         super(PATH_LENGTH, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new GPathLength(this.nodeId, this.options);          copy.z3358(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0)         {             g952(input.type == b1249, 'input must be VECTOR_PATH_VALUE');              const degree = Math.min(input.degree.value, 2) + 1;              const points = createCcompleteCurve(                 degree,                  input.objects[0].o3745,                  input.closed.value > 0);               let length = curveLength(degree, points);               if (input.closed.value > 0)             {                 const endPoints = points.slice(points.length - degree);                 length += curveLength(degree, [...endPoints, points[0]]);             }              this.length = new x2021(length, -2);         }         else             this.length = x2021.NaN.copy();               this.e4100(parse,         [             ['length', this.length]         ]);           this.validate();          return this;     } } 


class y1965 extends f2043 {     position  = null;     distance  = null;     offset    = null;     transform = null;                    constructor(nodeId, options)     {         super(d1284, nodeId, options);     }            reset()     {         super.reset();          this.position  = null;         this.distance  = null;         this.offset    = null;         this.transform = null;     }        copy()     {         const copy = new y1965(this.nodeId, this.options);          copy.z3358(this);          if (this.position ) copy.position  = this.position .copy();         if (this.distance ) copy.distance  = this.distance .copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = await evalVectorPathValue(this.input,     parse);         const position  = await evalNumberValue    (this.position,  parse);         const distance  = await evalNumberValue    (this.distance,  parse);         const offset    = await evalNumberValue    (this.offset,    parse);         const transform = await evalNumberValue    (this.transform, parse);           let pt;         let tangent = t984;           if (   input             && input.objects.length > 0)         {             const degree = Math.min(input.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  input.objects[0].o3745,                  input.closed.value > 0);               let length = curveLength(degree, points);                           const dist =                  position.value > 0                  ? distance.value                                                          : Math.min(Math.max(0, distance.value/100), 1) * length;                if (   dist >= 0                  && dist <= length                 && points.length >= degree-1)             {                 pt      =   pointAlongCurve(degree, points, dist);                 tangent = tangentAlongCurve(degree, points, dist);                  this.value = b2022.fromPoint(this.nodeId, pt);             }             else                 this.value = b2022.NaN.copy();         }         else             this.value = b2022.NaN.copy();           this.e4100(parse,         [             ['position',  position ],             ['distance',  distance ],             ['offset',    offset   ],             ['transform', transform]         ]);                   await this.i4099(parse,         {             transform:  transform,             tangent:    tangent,             offset:     offset.value         });           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new b1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.h4097(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -m883(options.tangent);                 let   c4207 = b893();                  c4207 = y889(c4207, y892(a));                  if (options.offset)                     c4207 = y889(c4207, b893(0, options.offset));                  point.r4098(c4207, options.transform.value > 0 ? 2 : 0);             }               this.value.objects = [point];         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.distance  && this.distance .isValid()             && this.offset    && this.offset   .isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position ) this.position .g4087(parse);         if (this.distance ) this.distance .g4087(parse);         if (this.offset   ) this.offset   .g4087(parse);         if (this.transform) this.transform.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.position ) this.position .y4088(parse, from, force);         if (this.distance ) this.distance .y4088(parse, from, force);         if (this.offset   ) this.offset   .y4088(parse, from, force);         if (this.transform) this.transform.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.position ) this.position .c4086(parse);         if (this.distance ) this.distance .c4086(parse);         if (this.offset   ) this.offset   .c4086(parse);         if (this.transform) this.transform.c4086(parse);     } }


class r1966 extends k2044 {     constrain = null;     transform = null;                    constructor(nodeId, options)     {         super(o1285, nodeId, options);     }            reset()     {         super.reset();          this.constrain = null;         this.transform = null;     }        copy()     {         const copy = new r1966(this.nodeId, this.options);          copy.z3358(this);          if (this.constrain) copy.constrain  = this.constrain.copy();         if (this.transform) copy.transform  = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082    = await evalVectorPathValue(this.b4082,     parse);         const o4083    = await evalPointValue     (this.o4083,     parse);          const constrain = await evalNumberValue    (this.constrain,  parse);         const transform = await evalNumberValue    (this.transform,  parse);           let tangent = t984;           if (   b4082             && o4083             && b4082.objects.length > 0             && o4083.objects.length > 0)         {             const degree = Math.min(b4082.degree.value, 2) + 1;              const points = createCompleteCurve(                 degree,                  b4082.objects[0].o3745,                  b4082.closed.value > 0);              let closest;             [closest, tangent] = closestTangentOnCurve(                 degree,                  points,                  o4083.objects[0].z3746(),                 constrain.value);                              this.value = b2022.fromPoint(this.nodeId, closest);         }         else             this.value = b2022.NaN.copy();           this.e4100(parse,         [             ['constrain',  constrain ],             ['transform',  transform ]         ]);                   await this.i4099(parse,         {             transform: transform,             tangent:   tangent         });           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   if (!this.value.objects)             this.value.objects = [];           if (   this.value.x             && this.value.y                && this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new b1843(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x,                 y,                 this.smooth ? this.smooth.value/100 : 1);              point.h4097(x, y);               if (   options.transform.value > 0                 && options.tangent)             {                 const a     = -m883(options.tangent);                 const c4207 =  y892(a);                  point.r4098(c4207, options.transform.value > 0 ? 2 : 0);             }                                       this.value.objects = [point];         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.transform) this.transform.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.transform) this.transform.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.transform) this.transform.c4086(parse);     } }


class u1958 extends s2046 {     segment = null;        constructor(nodeId, options)     {         super(p1282, nodeId, options);     }            reset()     {         super.reset();          if (this.segment) this.segment.reset();     }        copy()     {         const copy = new u1958(this.nodeId, this.options);          copy.z3358(this);          if (this.segment) copy.segment = this.segment.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082  = await evalPointValue (this.b4082,  parse);         const o4083  = await evalPointValue (this.o4083,  parse);         const t4084  = await evalPointValue (this.t4084,  parse);         const v4085  = await evalPointValue (this.v4085,  parse);         const segment = await evalNumberValue(this.segment, parse);           if (   b4082             && o4083             && t4084             && v4085)         {             const p = a989(                 b4082.z3746(),                 o4083.z3746(),                 t4084.z3746(),                 v4085.z3746(),                 segment.value > 0);              this.value = b2022.fromPoint(this.nodeId, p);         }         else         {             this.value = b2022.NaN.copy();         }           await this.i4099(parse);           this.e4100(parse,          [             ['value',   this.value],             ['segment', segment   ]         ]);                   this.validate();          return this;     }        async i4099(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new b1843(this.nodeId, this.nodeId, this.nodeName, x, y);              point.h4097(x, y);              this.value.objects = [point];         }           await super.i4099(parse);     }        isValid()     {         return super.isValid()             && this.segment && this.segment.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.segment) this.segment.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.segment) this.segment.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.segment) this.segment.c4086(parse);     } }


class f1957 extends k2044 {     amount    = null;     transform = null;            constructor(nodeId, options)     {         super(p1283, nodeId, options);     }            reset()     {         super.reset();          this.amount    = null;         this.transform = null;     }        copy()     {         const copy = new f1957(this.nodeId, this.options);          copy.z3358(this);          if (this.amount   ) copy.amount    = this.amount   .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const b4082    = await evalPointValue (this.b4082,    parse);         const o4083    = await evalPointValue (this.o4083,    parse);         const amount    = await evalNumberValue(this.amount,    parse);         const transform = await evalNumberValue(this.transform, parse);           if (   b4082 && b4082.isValid() && b4082.objects  && b4082.objects.length > 0             && o4083 && o4083.isValid() && o4083.objects  && o4083.objects.length > 0)         {             const p0  = point(b4082.objects[0].x, b4082.objects[0].y);             const p1  = point(o4083.objects[0].x, o4083.objects[0].y);             const amt = amount.value / 100;              const p   = w986(p0, p1, amt);                               let sp0 = w986(b4082.objects[0].sp0, o4083.objects[0].sp0, amt);             let sp1 = w986(b4082.objects[0].sp1, o4083.objects[0].sp1, amt);             let sp2 = w986(b4082.objects[0].sp2, o4083.objects[0].sp2, amt);              if (transform.value > 0)             {                 const l1 = distv(sp0, sp1);                 const l2 = distv(sp0, sp2);                  sp0 = clone(p);                 sp1 = h895(sp0, n897(w886(p900(p1, p0)), l1));                 sp2 = h895(sp0, r1022(n897(w886(p900(p1, p0)), l2)));             }               this.value = new b2022(this.nodeId, new x2021(p.x), new x2021(p.y));              const pt = new b1843(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);             pt.h4097(p.x, p.y);             this.value.objects = [pt];              this.value.objects[0].sp0 = sp0;             this.value.objects[0].sp1 = sp1;             this.value.objects[0].sp2 = sp2;         }         else             this.value = b2022.NaN.copy();           this.e4100(parse,         [             ['amount',    amount   ],             ['transform', transform]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.amount    && this.amount   .isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.amount   ) this.amount   .g4087(parse);         if (this.transform) this.transform.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.amount   ) this.amount   .y4088(parse, from, force);         if (this.transform) this.transform.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.amount   ) this.amount   .c4086(parse);         if (this.transform) this.transform.c4086(parse);     } }


class GReversePath extends f2043 {     constructor(nodeId, options)     {         super(REVERSE_PATH, nodeId, options);     }        copy()     {         const copy = new GReversePath(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input = await evalVectorPathValue(this.input, parse);           if (   input             && input.objects.length > 0             && input.objects[0].o3745)         {             this.value        = input.copy();             this.value.nodeId = this.nodeId;         }         else         {             this.value = new c4216();         }           await this.i4099(parse);           this.e4100(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = d3627(this.input.value);               for (const l111 of this.value.objects)             {                 l111.nodeId   = this.nodeId;                 l111.objectId = l111.objectId + y967 + this.nodeId;                  if (   this.options.enabled                     && PATH_TYPES.includes(l111.type))                     l111.o3745.reverse();             }         }                           await super.i4099(parse);     }        t3632()     {         return this.value              ? this.value.copy()              : null;     } }


class GBlendPath extends t1973 {     inputs = [];      amount;     degree;        constructor(nodeId, options)     {         super(BLEND_PATH, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];          this.amount = null;         this.degree = null;     }        copy()     {         const copy = new GBlendPath(this.nodeId, this.options);          copy.z3358(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.amount) copy.amount = this.amount.copy();         if (this.degree) copy.degree = this.degree.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const amount = await evalNumberValue(this.amount, parse);         const degree = await evalNumberValue(this.degree, parse);           const paths = [];                  for (const l3811 of this.inputs)         {             const input = await evalVectorPathValue(l3811, parse);              if (h957(input.type))             {                 for (const item of input.items)                 {                     const path = await evalVectorPathValue(item, parse);                     paths.push(path);                 }             }             else             {                 const path = await evalVectorPathValue(input, parse);                 paths.push(path);             }         }                           if (paths.length == 1)             this.value = paths[0];          else if (paths.length > 0)         {                                                                                                                                                                                                                                                                                                                                                              this.value = p2036.NaN.copy();         }          else                               this.value = p2036.NaN.copy();           await this.i4099(parse);           this.e4100(parse,         [             ['type',   this.outputType()],             ['amount', amount           ],             ['degree', degree           ]         ]);           this.validate();          return this;     }        async i4099(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = d3627(this.input.value);               for (const l111 of this.value.objects)             {                 l111.nodeId   = this.nodeId;                 l111.objectId = l111.objectId + y967 + this.nodeId;                                                }         }                           await super.i4099(parse);     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return  super.isValid()             &&  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid())             &&  this.amount && this.amount.isValid()             &&  this.degree && this.degree.isValid();     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));          if (this.amount) this.amount.g4087(parse);         if (this.degree) this.degree.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));          if (this.amount) this.amount.y4088(parse, from, force);         if (this.degree) this.degree.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));          if (this.amount) this.amount.c4086(parse);         if (this.degree) this.degree.c4086(parse);     } }


class g1962 extends f2043 {     position  = null;     transform = null;                constructor(nodeId, options)     {         super(q1276, nodeId, options);     }        reset()     {         super.reset();                  this.position  = null;         this.transform = null;     }        copy()     {         const copy = new g1962(this.nodeId, this.options);          copy.z3358(this);          if (this.position ) copy.position  = this.position .copy();         if (this.transform) copy.transform = this.transform.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const input     = await evalValue      (this.input,     parse);         const position  = await evalPointValue (this.position,  parse);         const transform = await evalNumberValue(this.transform, parse);          if (   input             && position)         {             this.value = input.copy();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else             this.value = new c4216();           if (   position             && position.isValid()             && position.objects             && position.objects.length > 0)         {             const p0 = point(                 position.objects[0].x,                  position.objects[0].y);              const p1 = h895(p0, p900(position.objects[0].sp1, position.objects[0].sp0));             const p2 = h895(p0, p900(position.objects[0].sp2, position.objects[0].sp0));              await this.i4099(                 parse,                  {                     transform:  transform,                     sp0:        p0,                     sp1:        p1,                     sp2:        p2                 });         }                   this.e4100(parse,         [             ['position',  position ],             ['transform', transform]         ]);           this.validate();          return this;     }        async i4099(parse, options)     {         if (   this.value             && this.value.isValid())         {             this.value.objects = d3627(this.input.value);               const place = b893(                 options.sp0 ? options.sp0.x : 0,                 options.sp0 ? options.sp0.y : 0);               for (const l111 of this.value.objects)             {                 l111.nodeId   = this.nodeId;                 l111.objectId = l111.objectId + y967 + this.nodeId;                   if (this.options.enabled)                 {                     let c4207 = y889(                         b893(                             -l111.sp0.x,                              -l111.sp0.y),                         place);                       if (   options.transform.value > 0                         && options.sp0                         && options.sp1                         && options.sp2)                     {                         const sp = getTransformFromPoints(                             options.sp0,                              options.sp1,                              options.sp2);                          c4207 = y889(c4207, sp);                          l111.sp1 = h895(l111.sp0, point(1, 0));                         l111.sp2 = h895(l111.sp0, point(0, 1));                     }                       l111.r4098(c4207, true);                 }             }         }                           await super.i4099(parse);     }        t3632()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.position  && this.position .isValid()             && this.transform && this.transform.isValid();     }        g4087(parse)     {         super.g4087(parse);          if (this.position ) this.position .g4087(parse);         if (this.transform) this.transform.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.position ) this.position .y4088(parse, from, force);         if (this.transform) this.transform.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.position ) this.position .c4086(parse);         if (this.transform) this.transform.c4086(parse);     } }    function getTransformFromPoints(p0, p1, p2)  {     const dx   = p1.x - p0.x;     const dy   = p1.y - p0.y;      const a    = Math.atan2(dy, dx);        const cosa = Math.cos(a);     const sina = Math.sin(a);                        return [[ cosa,         -sina , 0 ],              [ sina , cosa,          0 ],              [ 0,             0,             1 ]]; }


class u1882 extends y2042 {     h3091 = [];     params   = [];        constructor(nodeId, options)     {         super(m1298, nodeId, options);     }            copy()     {         const copy = new u1882(this.nodeId, this.options);          copy.z3358(this);          copy.params = this.params.map(p => p.copy());          return copy;     }        y4241(f2991)     {         return this.params[this.h3091.findIndex(id => id == f2991)];     }        async eval(parse)     {         if (this.isCached())             return this;           this.s3095 = [];           if (!isEmpty(this.params))         {             for (let i = 0; i < this.params.length; i++)             {                 const param = await this.params[i].eval(parse);                 this.e4100(parse, [[this.h3091[i], param.t3632()]], true);             }         }         else             this.e4100(parse, [['', new c4216()]], true);                                   this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()               : null;     }        g4087(parse)     {         super.g4087(parse);          this.inputs.forEach(i => i.g4087(parse));         this.params.forEach(p => p.g4087(parse));     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          this.inputs.forEach(i => i.y4088(parse, from, force));         this.params.forEach(p => p.y4088(parse, from, force));     }        c4086(parse)     {         super.c4086(parse);          this.inputs.forEach(i => i.c4086(parse));         this.params.forEach(p => p.c4086(parse));     } } 


class o1883 extends y2042 {     input    = null;          dataType = NULL;        constructor(nodeId, options)     {         super(w1299, nodeId, options);     }        reset()     {         super.reset();          this.input    = null;         this.dataType = null;     }        copy()     {         const copy = new o1883(this.nodeId, this.options);                  copy.z3358(this);          if (this.input) copy.input = this.input.copy();                  copy.dataType = this.dataType;                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             if (!this.input.value)                 await this.input.eval(parse);              this.value = this.input.t3632();         }          else if (this.dataType != NULL)             this.value = nanFromType(this.dataType);                  else             this.value = new c4216();           this.e4100(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        t3632()     {         return this.value.copy();     }        g4087(parse)     {         super.g4087(parse);          if (this.input) this.input.g4087(parse);     }        y4088(parse, from, force)     {         super.y4088(parse, from, force);          if (this.input) this.input.y4088(parse, from, force);     }        c4086(parse)     {         super.c4086(parse);          if (this.input) this.input.c4086(parse);     } }


class d2039 extends y2042 {     constructor(nodeId, options)     {         super(z1301, nodeId, options);     }            copy()     {         const copy = new d2039(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new c4216();           this.e4100(parse, [['', new c4216()]]);                           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()               : null;     } } 


class a2040 extends y2042 {     constructor(nodeId, options)     {         super(v1302, nodeId, options);     }            copy()     {         const copy = new a2040(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new c4216();           this.e4100(parse, [['', new c4216()]]);                           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()               : null;     } } 


class a2047 extends y2042 {     constructor(nodeId, options)     {         super(q1303, nodeId, options);     }            copy()     {         const copy = new a2047(this.nodeId, this.options);          copy.z3358(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new c4216();           this.e4100(parse, [['', new c4216()]]);                           this.validate();          return this;     }        t3632()     {         return this.value              ? this.value.copy()               : null;     } } 


var f3863 = false;  var u3864          = [];   var n4037            = []; var c4038  = [];       var lastMessage = null;   onmessage = function(e) {     const msg = JSON.parse(e.data);       if (msg.cmd == 'returnUiGetValueForGenerator')          return;           if (msg.cmd == 'genRequest')     {         if (   lastMessage             && lastMessage.cmd == 'genRequest')             return;           p4017(msg.request, msg.save);              }     else     {         switch (msg.cmd)         {             case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;                      case 'genEndUiMessage':  q2053 (msg.msgCmd);              break;             case 'genEndFigMessage': w2054();                        break;         }          lastMessage = null;     }       d2050(     {         cmd:   'uiEndGenMessage',         msgCmd: msg.cmd     }); };         function d2050(msg) {     if (msg == undefined)     {         p953('undefined message');         console.trace();     }      postMessage(JSON.stringify(msg)); }    function y2051(msg) {     u3864.push(msg);     j2052(); }    function j2052(msg) {     if (!isEmpty(u3864))          {                  let msg = u3864.shift();                                                                                                                                                                               d2050(msg);     } }    function q2053(msgCmd) {          j2052(); }    function w2054() {     f3863 = false;          if (   !isEmpty(h2058 )         || !isEmpty(x2059)         || !isEmpty(u2060 ))     {         u3860(             w2055,             false,             -1,              Number.MAX_SAFE_INTEGER,              w2056,              z2057,              [],              [],             [],             false);     }      j2052(); }  


var w2055     = -1; var w2056  =  NULL; var z2057 =  NULL; var h2058  =  []; var x2059 =  []; var u2060  =  [];    function initFonts(fonts, uniqueFontNames) {     n4037           = fonts;     c4038 = uniqueFontNames; }    function p4017(request, save) {     const i2066       = parseInt(request[0]);     const actionId        = parseInt(request[1]);     const set             = parseInt(request[2]);     const m4020 = parseInt(request[3]);       const settings =     {         showAllColorSpaces:  ((set >> 0) & 1) != 0,         logRequests:         ((set >> 1) & 1) != 0,         m2553: ((set >> 2) & 1) != 0,         g189:        ((set >> 3) & 1) != 0,         n3732:    ((set >> 4) & 1) != 0,         g3733:    ((set >> 5) & 1) != 0     };       const z4018  = request[4];     const j4019 = request[5];      const viewportZoom  = request[6];       const parse = new r1785(         request,          7,         i2066,         z4018,          j4019,          viewportZoom,         settings,         save);       const j3727 = 100;      while (   parse.pos < parse.request.length            && parse.so  < j3727)         r1787(parse);       if (settings.logRequests)         e2122(parse);       const b4230 = parse.n3641         .map(id => parse.w4242.find(n => n.nodeId == id));                const s3862 = parse.w4242         .filter(n =>                  n.topLevel              && !b4230.find(h3496 => h3496.nodeId == n.nodeId));      const otherNodes = parse.w4242.filter(n =>                !b4230   .find(h3496 => h3496.nodeId == n.nodeId)             && !s3862.find(h3496 => h3496.nodeId == n.nodeId));       (async () =>     {         let stop = false;           for (const nodes of [b4230, s3862])         {             for (const node of nodes)             {                 if (await l3861(parse.i2066)) { stop = true; break; }                 await node.eval(parse);             }         }           if (    stop             && !settings.g189)             return;           y2051({cmd: 'uiEndGlobalProgress'});                  for (const nodes of [s3862, otherNodes])             for (const node of nodes)                  node.g4087(parse);                           for (const node of parse.w4242)         {             if (node.options.active === true)             {                 if (   node.value                     && node.value.objects)                     node.value.objects.forEach(o => e2062(parse, o));                  if (node.colorStyle)                      v2063(parse, node.colorStyle);             }         }           for (const node of parse.w4242)         {             if (   node.options.active === true                 && node.value                 && node.value.objects)             {                 for (const l111 of node.value.objects)                 {                     if (l111.showCenter)                     {                         e2062(                             parse,                              v2585(node, l111));                     }                       if (    parse.settings.m2553                         && !l111.e3738                         &&  l111.xp0                         &&  l111.xp1                         &&  l111.xp2)                     {                         const xp0 = clone(l111.xp0);                         const xp1 = clone(l111.xp1);                         const xp2 = clone(l111.xp2);                         const xp3 = h895(xp2, p900(xp1, xp0));                          e2062(                             parse,                              createDecoPoly(                                 node.nodeId,                                 l111.objectId,                                 l111.objectName,                                 l111.sp0,                                 [xp0, xp2, xp3, xp1],                                 true,                                 '1, 2',                                 [12, 140, 233],                                 h971,                                 false));                     }                 }             }         }                    await u3860(             parse.i2066,             settings.g189,             actionId,             m4020,             parse.z4018,             parse.j4019,             parse.s3095,             parse.g3642,             parse.y3643,             save);     })(); }    async function l3861(i2066) {     const uiCurRequestId = await genGetValueFromUi('curRequestId');      if (uiCurRequestId.value > i2066)      {          y2051({cmd: 'uiEndGlobalProgress'});         return true;      }      return false }    function k2061(parse, nodeId, f2991, value) {     if (!value)         return;           l945(parse.s3095, v =>            v.nodeId     == nodeId         && v.f2991    == f2991         && v.value.type == value.type);               parse.s3095.push(     {         nodeId:  nodeId,         f2991: f2991,         type:    value.type,          value:   value.x2118()     }); }    function e2062(parse, object) {     z951(         parse.g3642,         object,         o =>    o.nodeId   == object.nodeId              && o.objectId == object.objectId); }    function v2063(parse, style) {     z951(         parse.y3643,         style,         o => o.nodeId == style.nodeId); }    function h2064() {     w2056  =  NULL;     z2057 =  NULL;      h2058  =  [];     x2059 =  [];     u2060  =  []; }    async function u3860(i2066, g189, actionId, m4020, z4018, j4019, s3095, g3642, y3643, save) {     if (   isEmpty(s3095 )         && isEmpty(g3642)         && isEmpty(y3643 ))     {         z4018  = w2056;         j4019 = z2057;                  s3095  = h2058;         g3642 = x2059;         y3643  = u2060;          h2064();     }     else if (f3863)     {         w2055     = i2066;         w2056  = z4018;         z2057 = j4019;          h2058  = s3095;         x2059 = g3642;         u2060  = y3643;          return;     }       const nodeIds = z1465(s3095.map(v => v.nodeId));     const counts  = nodeIds.map(id => s3095.filter(v => v.nodeId == id).length);             const approxNodeChunkSize = 1000000;     const objChunkSize        = 1000000;     const styleChunkSize      = 1000000;           let n  = 0;      let o  = 0;      let s  = 0;       let nc = 0;      let oc = 0;      let sc = 0;        let x2069   = [],         n2070       = [],         q2071     = [];      let b2068 = 0;      let m2074   = true;               y2051(     {         cmd:      'uiInitGlobalProgress',         i2066: i2066     });       let z2067 = 0;     g3642.forEach(o => z2067 += o.getCount());           while (   n < nodeIds      .length            || o < g3642.length            || s < y3643 .length)     {         if (n < nodeIds.length)         {             x2069.push(nodeIds[n], counts[n]);              const values = s3095.filter(v => v.nodeId == nodeIds[n]);                           for (const v of values)                 x2069.push(v.f2991, v.type, v.value);              n++, nc++;         }           if (o < g3642.length)         {             n2070.push(g3642[o].o3740());             o++, oc++;         }           if (s < y3643.length)         {             q2071.push(y3643[s].o3740());             s++, sc++;         }           const chunkNotEmpty =                nc >= approxNodeChunkSize             || oc == objChunkSize             || sc == styleChunkSize;           if (chunkNotEmpty)         {             const i2075 =                        n >= nodeIds      .length                 && o >= g3642.length                 && s >= y3643 .length                 && (   !isEmpty(x2069)                     || !isEmpty(n2070    )                     || !isEmpty(q2071  ));              z2065(                 i2066,                 actionId,                 z4018,                 j4019,                 m4020,                 z2067,                 b2068++,                 x2069,                 n2070,                 q2071,                 n,                 nodeIds.length,                 m2074,                 i2075,                 save);              x2069 = [];  nc = 0;             n2070     = [];  oc = 0;             q2071   = [];  sc = 0;              m2074 = false;         }           if (await l3861(i2066))              break;     }       const lastChunkNotEmpty =            !isEmpty(x2069)         || !isEmpty(n2070    )         || !isEmpty(q2071  );       if (   lastChunkNotEmpty         || g189         ||    isEmpty(s3095)             && isEmpty(g3642)            && isEmpty(y3643))     {         z2065(             i2066,             actionId,             z4018,             j4019,             m4020,             z2067,             b2068++,             x2069,             n2070,             q2071,             nodeIds.length,             nodeIds.length,             false,             true,             save);     }       y2051({         cmd: 'uiForwardToFigma',         msg: {cmd: 'figCommitUndo'}     }) }    function z2065(i2066, actionId, z4018, j4019, m4020, z2067, b2068, x2069, n2070, q2071, s2072, f2073, m2074, i2075, save) {     y2051({         cmd:            'uiUpdateValuesAndObjects',         i2066:       i2066,         actionId:        actionId,         z4018:    z4018,         j4019:   j4019,         m4020: m4020,         z2067:    z2067,         chunkId:         b2068,         values:          [...x2069].map(v => v.toString()),         objects:         [...n2070    ],         styles:          [...q2071  ],         s2072:    s2072,         f2073:      f2073,         m2074:    m2074,         i2075:     i2075,         save:            save     });       if (   !isEmpty(n2070  )         || !isEmpty(q2071))         f3863 = true; }    function y2076(nodeId) {     y2051(     {         cmd:   'uiInitNodeProgress',         nodeId: nodeId     }); }    function v2077(parse, nodeId, progress, updateGlobal = true) {     y2051(     {         cmd:           'uiUpdateNodeProgress',         nodeId:         nodeId,         progress:       progress,         globalProgress: parse.m3638 / parse.j3639,         updateGlobal:   updateGlobal     }); }    function q2078(nodeId, endGlobal) {     y2051(     {         cmd:      'uiEndNodeProgress',         nodeId:    nodeId,         endGlobal: endGlobal     }); }    async function genGetObjectSizeFromFigma(l111)  {     return new Promise((resolve, reject) =>      {         const timeout = 1000;          d2050(         {             cmd: 'uiForwardToFigma',             msg:               {                 cmd:   'figGetObjectSize',                 object: l111             }         });          const l2741 = setTimeout(() =>              reject(new Error('Timeout: Result not received within the specified time')),             timeout);          function h4030(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnFigGetObjectSize')              {                 clearTimeout(l2741);                                  const { objectId, width, height } = msg;                 resolve({ objectId, width, height });                  self.removeEventListener('message', h4030);             }         }          self.addEventListener('message', h4030);     }); }    async function genGetValueFromUi(key)  {     return new Promise((resolve, reject) =>      {         const timeout = 60000;          d2050(         {             cmd: 'uiGetValueForGenerator',             key:  key          });          const l2741 = setTimeout(() =>              reject(new Error('Timeout: Result not received by Generator within the specified time')),             timeout);          function h4030(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnUiGetValueForGenerator')              {                 clearTimeout(l2741);                  resolve(                 {                      key:   msg.key,                      value: msg.value                  });                  self.removeEventListener('message', h4030);             }         }          self.addEventListener('message', h4030);     }); }


function s1622(parse) {     parse.pos++;       const col = parse.move();      if (parse.settings.logRequests)          u2130(l1168, col, parse);      return f2865(col)[0]; }    function i1623(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const col = new v1814(nodeId, options);      col.r3264 = options.r3264;             let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(col, parse, ignore, v4208);       if (ignore)      {         t1790(parse, col);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           let h3091;      if (v4208 == 1)     {         col.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['space', 'convert', 'c1', 'c2', 'c3'];       parse.z1788 = false;          for (const id of h3091)     {         switch (id)         {         case 'space':   col.space        = r1787(parse);  break;         case 'convert': col.convert      = r1787(parse);  break;         case 'c1':      col.b3683 = col.c1 = r1787(parse);  break;         case 'c2':      col.b3684 = col.c2 = r1787(parse);  break;         case 'c3':      col.n3685 = col.c3 = r1787(parse);  break;         }     }           parse.r3646--;       t1790(parse, col);     return col; }    function n1624(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const valid = new g1821(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(valid, parse, ignore, v4208);       if (ignore)      {         t1790(parse, valid);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         valid.input = r1787(parse);       valid.quality = r1787(parse);     valid.value   = r1787(parse);       parse.r3646--;       t1790(parse, valid);     return valid; }    function j1625(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const corr = new u1820(nodeId, options);      corr.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(corr, parse, ignore, v4208);       if (ignore)      {         t1790(parse, corr);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)         corr.input = r1787(parse);       h3091 = parse.move().split(',');      parse.z1788 = false;          for (const id of h3091)     {         switch (id)         {         case 'order':  corr.u3682 = corr.order = r1787(parse);  break;         case 'c1':     corr.b3683    = corr.c1    = r1787(parse);  break;         case 'c2':     corr.b3684    = corr.c2    = r1787(parse);  break;         case 'c3':     corr.n3685    = corr.c3    = r1787(parse);  break;         case 'value':  corr.value               = r1787(parse);  break;         }     }                       parse.r3646--;       t1790(parse, corr);     return corr; }    function r1626(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cnt = new y1817(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }       const j3681 =          v4208 == 1         ? parseInt(parse.move())         : -1;           if (parse.settings.logRequests)          w2129(cnt, v4208, j3681, parse, ignore);       if (ignore)      {         t1790(parse, cnt);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         cnt.b4082   = r1787(parse);         cnt.o4083   = r1787(parse);     }     else if (v4208 == 1)     {              if (j3681 == 0) cnt.b4082 = r1787(parse);          else if (j3681 == 1) cnt.o4083 = r1787(parse);      }         cnt.standard = r1787(parse);       parse.r3646--;       t1790(parse, cnt);     return cnt; }    function a1627(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const convert = new e1819(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(convert, parse, ignore, v4208);       if (ignore)      {         t1790(parse, convert);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         convert.input = r1787(parse);       convert.from = r1787(parse);       parse.r3646--;       t1790(parse, convert);     return convert; }    function d1628(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cb = new k1816(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(cb, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cb);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         cb.input = r1787(parse);      cb.l = r1787(parse);     cb.m = r1787(parse);     cb.s = r1787(parse);           parse.r3646--;       t1790(parse, cb);     return cb; }    function e1629(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const x1035 = new h1818(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(x1035, parse, ignore, v4208);       if (ignore)      {         t1790(parse, x1035);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         x1035.b4082 = r1787(parse);         x1035.o4083 = r1787(parse);     }      else if (v4208 == 1)         x1035.b4082 = r1787(parse);       else if (v4208 != 0)         p953('nInputs must be [0, 2]');       x1035.space  = r1787(parse);     x1035.amount = r1787(parse);     x1035.gamma  = r1787(parse);       parse.r3646--;       t1790(parse, x1035);     return x1035; }    function n1630(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const blend = new s1815(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(blend, parse, ignore, v4208);       if (ignore)      {         t1790(parse, blend);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         blend.b4082 = r1787(parse);         blend.o4083 = r1787(parse);     }      else if (v4208 == 1)         blend.b4082 = r1787(parse);       else if (v4208 != 0)         p953('nInputs must be [0, 2]');       blend.mode    = r1787(parse);     blend.opacity = r1787(parse);       parse.r3646--;       t1790(parse, blend);     return blend; }    function h1668(parse) {     parse.pos++;       const grad = parse.move();      if (parse.settings.logRequests)          u2130(m1187, grad, parse);      return s3675(grad)[0]; }    function e1669(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const grad = new n1889(nodeId, options);      grad.r3264 = options.r3264;       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(grad, parse, ignore, v4208);       if (ignore)     {         t1790(parse, grad);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         grad.inputs.push(r1787(parse));       const i3667 = q1792(parse);       for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'gradType': grad.u3686 = r1787(parse); break;         case 'position': grad.position = r1787(parse); break;         case 'x':        grad.x        = r1787(parse); break;         case 'y':        grad.y        = r1787(parse); break;         case 'size':     grad.size     = r1787(parse); break;         case 'angle':    grad.angle    = r1787(parse); break;         case 'aspect':   grad.aspect   = r1787(parse); break;         case 'skew':     grad.skew     = r1787(parse); break;         case 'blend':    grad.blend    = r1787(parse); break;         }     }                                                         grad.diagAspect = parseInt(parse.move()) > 0;       parse.z1788 = false;     parse.r3646--;       t1790(parse, grad);     return grad; }                function s1670(parse) {     parse.pos++;       const stop = parse.move();      if (parse.settings.logRequests)          u2130(y1184, stop, parse);      return s2866(stop)[0]; }    function b1671(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const stop = new r1885(nodeId, options);      stop.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(stop, parse, ignore, v4208);       if (ignore)     {         t1790(parse, stop);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         stop.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['fill', 'position'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'fill':     stop.fill     = r1787(parse); break;         case 'position': stop.position = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, stop);     return stop; }


function t1631(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const _null = new l1865(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(_null, parse, ignore, v4208);       if (ignore)      {         t1790(parse, _null);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         _null.input = r1787(parse);       parse.r3646--;       t1790(parse, _null);     return _null; }    function w1632(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const variable = new v1880(nodeId, options);      variable.existing = options.existing;       if (parse.settings.logRequests)          x2123(variable, parse, ignore);       if (ignore)      {         t1790(parse, variable);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;     parse.z1788 = false;       const c3678 = parseInt(parse.move());      if (c3678 == 1)         variable.varValue = r1787(parse);           parse.r3646--;           variable.linked = variable.id != NULL;       t1790(parse, variable);     return variable; }    function g1633(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const group = new d1881(nodeId, options);           let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(group, parse, ignore, v4208);       if (ignore)      {         t1790(parse, group);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         group.input = r1787(parse);       parse.r3646--;       t1790(parse, group);     return group; }    function i1634(parse) {     parse.pos++;       const list = parse.move();      if (parse.settings.logRequests)          u2130(q1056, list, parse);      return i3481(list)[0]; }    function z1635(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cmb = new m1856(nodeId, options);           let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(cmb, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cmb);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           for (let i = 0; i < v4208; i++)         cmb.inputs.push(r1787(parse));       parse.r3646--;               t1790(parse, cmb);     return cmb; }    function x1636(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const listAsItem = new q1857(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(listAsItem, parse, ignore, v4208);       if (ignore)      {         t1790(parse, listAsItem);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         listAsItem.input = r1787(parse);           parse.r3646--;       t1790(parse, listAsItem);     return listAsItem; }    function z1637(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const extr = new p1859(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(extr, parse, ignore, v4208);       if (ignore)      {         t1790(parse, extr);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         extr.input = r1787(parse);      extr.indices = r1787(parse);           parse.r3646--;       t1790(parse, extr);     return extr; }    function a1638(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const set = new n1872(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(set, parse, ignore, v4208);       if (ignore)      {         t1790(parse, set);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         set.b4082 = r1787(parse);         set.o4083 = r1787(parse);         set.name   = r1787(parse);     }     else if (v4208 == 1)     {         set.b4082 = r1787(parse);          set.name   = r1787(parse);     }     else if (v4208 == 0)     {         set.name   = r1787(parse);     }           parse.r3646--;       t1790(parse, set);     return set; }    function g1639(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const extr = new o1873(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(extr, parse, ignore, v4208);       if (ignore)      {         t1790(parse, extr);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         extr.input = r1787(parse);      extr.name = r1787(parse);           parse.r3646--;       t1790(parse, extr);     return extr; }    function x1640(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const sub = new x1876(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(sub, parse, ignore, v4208);       if (ignore)      {         t1790(parse, sub);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         sub.input = r1787(parse);      sub.start = r1787(parse);     sub.end   = r1787(parse);           parse.r3646--;       t1790(parse, sub);     return sub; }    function v1641(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const unique = new a1878(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(unique, parse, ignore, v4208);       if (ignore)      {         t1790(parse, unique);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         unique.input = r1787(parse);             parse.r3646--;       t1790(parse, unique);     return unique; }    function a1643(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const shift = new y1868(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(shift, parse, ignore, v4208);       if (ignore)      {         t1790(parse, shift);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         shift.input = r1787(parse);      shift.offset = r1787(parse);           parse.r3646--;       t1790(parse, shift);     return shift; }    function m1644(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const reverse = new g1869(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(reverse, parse, ignore, v4208);       if (ignore)      {         t1790(parse, reverse);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         reverse.input = r1787(parse);             parse.r3646--;       t1790(parse, reverse);     return reverse; }    function genParseBuckleList(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const buckle = new GBuckleList(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(buckle, parse, ignore, v4208);       if (ignore)      {         t1790(parse, buckle);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         buckle.input = r1787(parse);         buckle.amount = r1787(parse);           parse.r3646--;       t1790(parse, buckle);     return buckle; }    function s1642(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const reorder = new z1867(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(reorder, parse, ignore, v4208);       if (ignore)      {         t1790(parse, reorder);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         reorder.input = r1787(parse);       reorder.indices = r1787(parse);           parse.r3646--;       t1790(parse, reorder);     return reorder; }    function w1645(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const sort = new g1874(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(sort, parse, ignore, v4208);       if (ignore)      {         t1790(parse, sort);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         sort.input = r1787(parse);       const nConditions = parseInt(parse.move());      if (nConditions == 1)         sort.condition = r1787(parse);               sort.reverse   = r1787(parse);           parse.r3646--;       t1790(parse, sort);     return sort; }    function b1646(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const filter = new x1860(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(filter, parse, ignore, v4208);       if (ignore)      {         t1790(parse, filter);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         filter.input = r1787(parse);      filter.condition = r1787(parse);           parse.r3646--;       t1790(parse, filter);     return filter; }    function l1647(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const column = new p1855(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(column, parse, ignore, v4208);       if (ignore)      {         t1790(parse, column);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         column.input = r1787(parse);      column.index = r1787(parse);           parse.r3646--;       t1790(parse, column);     return column; }    function u1648(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cell = new p1854(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(cell, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cell);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         cell.input = r1787(parse);      cell.column = r1787(parse);     cell.row    = r1787(parse);           parse.r3646--;       t1790(parse, cell);     return cell; }    function o1649(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const list = new e1863(nodeId, options);           let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(list, parse, ignore, v4208);       if (ignore)      {         t1790(parse, list);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         list.input = r1787(parse);       parse.r3646--;       t1790(parse, list);     return list; }    function v1650(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const sel = new n1870(nodeId, options);           let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(sel, parse, ignore, v4208);       if (ignore)      {         t1790(parse, sel);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           for (let i = 0; i < v4208; i++)         sel.inputs.push(r1787(parse));      sel.index = r1787(parse);       parse.r3646--;               t1790(parse, sel);     return sel; }    function genParseSelectFromList(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const sel = new v1871(nodeId, options);           let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(sel, parse, ignore, v4208);       if (ignore)      {         t1790(parse, sel);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         sel.input = r1787(parse);      sel.index = r1787(parse);           parse.r3646--;       t1790(parse, sel);     return sel; }    function y1651(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const count = new g1864(nodeId, options);           let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(count, parse, ignore, v4208);       if (ignore)      {         t1790(parse, count);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         count.input = r1787(parse);      count.start = r1787(parse);       parse.r3646--;       t1790(parse, count);     return count; }    function genParseObjectCount(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const count = new GObjectCount(nodeId, options);           let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(count, parse, ignore, v4208);       if (ignore)      {         t1790(parse, count);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         count.input = r1787(parse);      count.start = r1787(parse);       parse.r3646--;       t1790(parse, count);     return count; }    function g1652(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cont = new l1858(nodeId, options);          let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(cont, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cont);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         cont.b4082 = r1787(parse);         cont.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         cont.b4082 = r1787(parse);      }             parse.r3646--;       t1790(parse, cont);     return cont; }    function t1653(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const r3680 = new r1862(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }       const j3681 =          v4208 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          x2123(r3680, parse, ignore, v4208);       if (ignore)      {         t1790(parse, r3680);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      if (v4208 == 2)     {         r3680.b4082    = r1787(parse);         r3680.o4083    = r1787(parse);         r3680.condition = r1787(parse);     }     else if (v4208 == 1)     {              if (j3681 == 0) r3680.b4082 = r1787(parse);          else if (j3681 == 1) r3680.o4083 = r1787(parse);           r3680.condition = r1787(parse);     }     else if (v4208 == 0)     {         r3680.condition = r1787(parse);     }      parse.r3646--;       t1790(parse, r3680);     return r3680; }    function e1654(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const feedback = new x1875(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(feedback, parse, ignore, v4208);       if (ignore)      {         t1790(parse, feedback);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         feedback.input = r1787(parse);       parse.r3646--;       t1790(parse, feedback);     return feedback; }    function w1655(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const repeat = new z1866(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(repeat, parse, ignore, v4208);       if (ignore)      {         t1790(parse, repeat);         return parse.w4242.find(n => n.nodeId == nodeId);     }       repeat.isTerminal  = parseInt(parse.move()) > 0;     repeat.activeAfter = parseInt(parse.move()) > 0;     repeat.listAfter   = parseInt(parse.move()) > 0;       parse.r3646++;       if (v4208 == 1)         repeat.input = r1787(parse);      repeat. count     = r1787(parse);     repeat .iteration = r1787(parse);     repeat.v3679     = r1787(parse);        repeat. loop      = r1787(parse);         parse.r3646--;       t1790(parse, repeat);     return repeat; }    function m1656(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cache = new u1853(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(cache, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cache);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         cache.input = r1787(parse);       parse.r3646--;       t1790(parse, cache);     return cache; }    function h1657(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const freeze = new u1861(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(freeze, parse, ignore, v4208);       if (ignore)      {         t1790(parse, freeze);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         freeze.input = r1787(parse);       parse.r3646--;       t1790(parse, freeze);     return freeze; }    function k1658(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const timer = new u1877(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(timer, parse, ignore, v4208);       if (ignore)      {         t1790(parse, timer);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         timer.input = r1787(parse);       timer.interval = r1787(parse);     timer.v3679   = r1787(parse);     timer. loop    = r1787(parse);         parse.r3646--;       t1790(parse, timer);     return timer; }    function h1659(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const name = new k1879(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(name, parse, ignore, v4208);       if (ignore)      {         t1790(parse, name);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         name.input = r1787(parse);      name.name = r1787(parse);       parse.r3646--;       t1790(parse, name);     return name; }    function genParseGetListValueNames(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const names = new GGetListValueNames(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(names, parse, ignore, v4208);       if (ignore)      {         t1790(parse, names);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         names.input = r1787(parse);             parse.r3646--;       t1790(parse, names);     return names; }    function genParseListValueNames(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const names = new GListValueNames(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }       const j3681 =          v4208 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          x2123(names, parse, ignore, v4208);       if (ignore)     {         t1790(parse, names);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      if (v4208 == 2)     {         names.b4082 = r1787(parse);         names.o4083 = r1787(parse);     }     else if (v4208 == 1)     {              if (j3681 == 0) names.b4082 = r1787(parse);          else if (j3681 == 1) names.o4083 = r1787(parse);      }      parse.r3646--;       t1790(parse, names);     return names; }    function genParseObjectName(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const name = new GObjectName(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(name, parse, ignore, v4208);       if (ignore)      {         t1790(parse, name);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         name.input = r1787(parse);      name.name    = r1787(parse);         parse.r3646--;       t1790(parse, name);     return name; }    function a1660(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cmnt = new d2039(nodeId, options);           if (parse.settings.logRequests)          x2123(cmnt, parse, ignore);       if (ignore)      {         t1790(parse, cmnt);         return parse.w4242.find(n => n.nodeId == nodeId);     }       t1790(parse, cmnt);     return cmnt; }    function d1661(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cmnt = new a2040(nodeId, options);           if (parse.settings.logRequests)          x2123(cmnt, parse, ignore);       if (ignore)      {         t1790(parse, cmnt);         return parse.w4242.find(n => n.nodeId == nodeId);     }       t1790(parse, cmnt);     return cmnt; }    function i1662(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const panel = new a2047(nodeId, options);           if (parse.settings.logRequests)          x2123(panel, parse, ignore);       if (ignore)      {         t1790(parse, panel);         return parse.w4242.find(n => n.nodeId == nodeId);     }       t1790(parse, panel);     return panel; }


function k1663(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const group = new u1882(nodeId, options);       let c3678 = -1;          if (!ignore)     {         c3678 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(group, parse, ignore);       if (ignore)     {         t1790(parse, group);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;             for (let i = 0; i < c3678; i++)     {         group.h3091.push(parse.move());         group.params  .push(r1787(parse));     }       parse.r3646--;       t1790(parse, group);     return group; }    function f1664(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const param = new o1883(nodeId, options);       let v4208  = -1;     let j3677 = -1;          if (!ignore)     {         v4208  = parseInt(parse.move());         j3677 = parseInt(parse.move());          g952(v4208  == 0 || v4208  == 1,  'nInputs must be [0, 1]');         g952(j3677 == 0 || j3677 == 1, 'nOutputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(param, parse, ignore);       if (ignore)      {         t1790(parse, param);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)     {         param.input    = r1787(parse);         param.dataType = parse.move();     }     else if (j3677 == 1)         param.dataType = parse.move();       parse.r3646--;       t1790(parse, param);     return param; } 


function f1665(parse) {     parse.pos++;       const fill = parse.move();      if (parse.settings.logRequests)          u2130(y1178, fill, parse);      return r3676(fill)[0]; }    function p1666(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const fill = new w1888(nodeId, options);      fill.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(fill, parse, ignore, v4208);       if (ignore)     {         t1790(parse, fill);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         fill.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['color', 'opacity', 'blend'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'color':   fill.color   = r1787(parse); break;         case 'opacity': fill.opacity = r1787(parse); break;         case 'blend':   fill.blend   = r1787(parse); break;         }     }           parse.r3646--;       t1790(parse, fill);     return fill; }    function f1667(parse) {     const fill = r1787(parse);       if (m1177.includes(fill.type))         fill.options.opacity = r1787(parse);      return fill; }    function g1672(parse) {     parse.pos++;       const stroke = parse.move();      if (parse.settings.logRequests)          u2130(i1181, stroke, parse);      return z3831(stroke)[0]; }    function s1673(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const stroke = new d1895(nodeId, options);      stroke.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(stroke, parse, ignore, v4208);       if (ignore)     {         t1790(parse, stroke);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         stroke.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'fill':   stroke.y3674 = r1787(parse); stroke.fills = stroke.y3674; break;         case 'weight': stroke.weight = r1787(parse); break;         case 'fit':    stroke.fit    = r1787(parse); break;         case 'join':   stroke.join   = r1787(parse); break;         case 'miter':  stroke.miter  = r1787(parse); break;         case 'cap':    stroke.cap    = r1787(parse); break;         case 'dashes': stroke.dashes = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, stroke);     return stroke; }    function z1674(parse) {     const stroke = r1787(parse);       if (    a1180.includes(stroke.type)         || m1177.includes(stroke.type))         stroke.data.weight = r1787(parse);      return stroke; }    function genParseStrokeSidesValue(parse) {     parse.pos++;       const sides = parse.move();      if (parse.settings.logRequests)          u2130(m1190, sides, parse);      return parseStrokeSidesValue(sides)[0]; }    function genParseStrokeSides(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const sides = new GStrokeSides(nodeId, options);      sides.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(sides, parse, ignore, v4208);       if (ignore)     {         t1790(parse, sides);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         sides.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['top', 'left', 'right', 'bottom'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'top':    sides.top    = r1787(parse); break;         case 'left':   sides.left   = r1787(parse); break;         case 'right':  sides.right  = r1787(parse); break;         case 'bottom': sides.bottom = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, sides);     return sides; }    function x1675(parse) {     parse.pos++;       const corners = parse.move();      if (parse.settings.logRequests)          u2130(d1193, corners, parse);      return b3837(corners)[0]; }    function i1676(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const corners = new v1894(nodeId, options);      corners.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(corners, parse, ignore, v4208);       if (ignore)     {         t1790(parse, corners);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         corners.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['tl', 'tr', 'bl', 'br'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'tl': corners.tl = r1787(parse); break;         case 'tr': corners.tr = r1787(parse); break;         case 'bl': corners.bl = r1787(parse); break;         case 'br': corners.br = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, corners);     return corners; }    function r1677(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          u2130(q1196, shadow, parse);      return b3832(shadow)[0]; }    function w1678(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const shadow = new p1887(nodeId, options);      shadow.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(shadow, parse, ignore, v4208);       if (ignore)     {         t1790(parse, shadow);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         shadow.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'x':      shadow.x      = r1787(parse); break;         case 'y':      shadow.y      = r1787(parse); break;         case 'blur':   shadow.blur   = r1787(parse); break;         case 'spread': shadow.spread = r1787(parse); break;         case 'fill':   shadow.fill   = r1787(parse); break;         case 'blend':  shadow.blend  = r1787(parse); break;         case 'behind': shadow.behind = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, shadow);     return shadow; }    function q1679(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.logRequests)          u2130(b1199, shadow, parse);      return a3833(shadow)[0]; }    function i1680(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const shadow = new c1890(nodeId, options);      shadow.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(shadow, parse, ignore, v4208);       if (ignore)     {         t1790(parse, shadow);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         shadow.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'x':      shadow.x      = r1787(parse); break;         case 'y':      shadow.y      = r1787(parse); break;         case 'blur':   shadow.blur   = r1787(parse); break;         case 'spread': shadow.spread = r1787(parse); break;         case 'fill':   shadow.fill   = r1787(parse); break;         case 'blend':  shadow.blend  = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, shadow);     return shadow; }    function f1681(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          u2130(s1202, blur, parse);      return u3834(blur)[0]; }    function f1682(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const blur = new d1892(nodeId, options);      blur.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(blur, parse, ignore, v4208);       if (ignore)     {         t1790(parse, blur);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         blur.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['radius'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'radius': blur.radius = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, blur);     return blur; }    function p1683(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.logRequests)          u2130(m1205, blur, parse);      return z3706(blur)[0]; }    function j1684(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const blur = new y1884(nodeId, options);      blur.r3264 = options.r3264;       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(blur, parse, ignore, v4208);       if (ignore)     {         t1790(parse, blur);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       let h3091;      if (v4208 == 1)     {         blur.input = r1787(parse);         h3091 = parse.move().split(',');     }     else         h3091 = ['radius'];       parse.z1788 = false;      for (const id of h3091)     {         switch (id)         {         case 'radius': blur.radius = r1787(parse); break;         }     }               parse.r3646--;       t1790(parse, blur);     return blur; }    function o1685(parse) {     parse.pos++;       const layer = parse.move();      if (parse.settings.logRequests)          u2130(s1211, layer, parse);      return z3707(layer)[0]; }    function n1686(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const layer = new o1891(nodeId, options);       if (parse.settings.logRequests)          x2123(layer, parse, ignore);       if (ignore)     {         t1790(parse, layer);         return parse.w4242.find(n => n.nodeId == nodeId);     }       layer.opacity = r1787(parse);     layer.blend   = r1787(parse);               t1790(parse, layer);     return layer; }    function d1687(parse) {     parse.pos++;       const mask = parse.move();      if (parse.settings.logRequests)          u2130(q1208, mask, parse);      return z3708(mask)[0]; }    function b1688(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const mask = new w1893(nodeId, options);       if (parse.settings.logRequests)          x2123(mask, parse, ignore);       if (ignore)     {         t1790(parse, mask);         return parse.w4242.find(n => n.nodeId == nodeId);     }       mask.maskType = r1787(parse);               t1790(parse, mask);     return mask; }


function n1690(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          u2130(n1091, val, parse);      return val.indexOf(',') >= 0          ? k2849      (val)[0]          : h3835(val)[0]; }    function q1691(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const num = new p1935(nodeId, options);           if (parse.settings.logRequests)          x2123(num, parse, ignore);       if (ignore)      {         t1790(parse, num);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;     parse.z1788 = false;       if (parse.next == n1091) num.value = r1787(parse);     else                            num.input = r1787(parse);       parse.r3646--;       t1790(parse, num);     return num; }    function genParseSetPrecision(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const prec = new GSetPrecision(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(prec, parse, ignore, v4208);       if (ignore)      {         t1790(parse, prec);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         prec.input = r1787(parse);      prec.decimals = r1787(parse);           parse.r3646--;       t1790(parse, prec);     return prec; }    function p1692(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const u3673 = new r1926(nodeId, options);       if (parse.settings.logRequests)          x2123(u3673, parse, ignore);       if (ignore)      {         t1790(parse, u3673);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       u3673.constant = r1787(parse);       parse.r3646--;       t1790(parse, u3673);     return u3673; }    function s1693(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const dateTime = new t1928(nodeId, options);       if (parse.settings.logRequests)          x2123(dateTime, parse, ignore);       if (ignore)      {         t1790(parse, dateTime);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       dateTime.seconds   = r1787(parse);     dateTime.minutes   = r1787(parse);     dateTime.hours     = r1787(parse);     dateTime.dayOfWeek = r1787(parse);     dateTime.date      = r1787(parse);     dateTime.month     = r1787(parse);     dateTime.year      = r1787(parse);       parse.r3646--;       t1790(parse, dateTime);     return dateTime; }    function f1694(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const sign = new b1942(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(sign, parse, ignore);       if (ignore)      {         t1790(parse, sign);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         sign.input = r1787(parse);           parse.r3646--;       t1790(parse, sign);     return sign; }    function u1695(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const abs = new k1923(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(abs, parse, ignore);       if (ignore)      {         t1790(parse, abs);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         abs.input = r1787(parse);           parse.r3646--;       t1790(parse, abs);     return abs; }    function genParseNegative(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const neg = new GNegative(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(neg, parse, ignore);       if (ignore)      {         t1790(parse, neg);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         neg.input = r1787(parse);           parse.r3646--;       t1790(parse, neg);     return neg; }    function m1696(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const round = new e1940(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(round, parse, ignore, v4208);       if (ignore)      {         t1790(parse, round);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         round.input = r1787(parse);      round.type     = r1787(parse);     round.decimals = r1787(parse);           parse.r3646--;       t1790(parse, round);     return round; }    function genParseQuantize(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const quant = new GQuantize(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(quant, parse, ignore, v4208);       if (ignore)      {         t1790(parse, quant);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         quant.input = r1787(parse);      quant.type   = r1787(parse);     quant.base   = r1787(parse);     quant.step   = r1787(parse);     quant.amount = r1787(parse);           parse.r3646--;       t1790(parse, quant);     return quant; }    function i1697(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const g3672 = new e1943(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(g3672, parse, ignore, v4208);       if (ignore)      {         t1790(parse, g3672);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         g3672.input = r1787(parse);      g3672.operand   = r1787(parse);     g3672.operation = r1787(parse);           parse.r3646--;       t1790(parse, g3672);     return g3672; }    function v1698(parse) {     const [type, nodeId, options, ignore] = o1789(parse);       const t3671 = new a1932(nodeId, options);           let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(t3671, parse, ignore, v4208);       if (ignore)      {         t1790(parse, t3671);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      for (let i = 0; i < v4208; i++)         t3671.inputs.push(r1787(parse));       t3671.operation = r1787(parse);       parse.r3646--;               t1790(parse, t3671);     return t3671; }    function g1699(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const limits = new t1931(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(limits, parse, ignore, v4208);       if (ignore)      {         t1790(parse, limits);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         limits.input = r1787(parse);      limits.min = r1787(parse);     limits.max = r1787(parse);           parse.r3646--;       t1790(parse, limits);     return limits; }    function h1700(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const curve = new n1936(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(curve, parse, ignore, v4208);       if (ignore)      {         t1790(parse, curve);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         curve.input = r1787(parse);      curve.min    = r1787(parse);     curve.max    = r1787(parse);     curve.power  = r1787(parse);           parse.r3646--;       t1790(parse, curve);     return curve; }    function genParseNumberMap(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const map = new GNumberMap(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(map, parse, ignore, v4208);       if (ignore)      {         t1790(parse, map);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         map.input = r1787(parse);      map.from = r1787(parse);     map.to   = r1787(parse);           parse.r3646--;       t1790(parse, map);     return map; }    function genParseNumberBias(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const bias = new GNumberBias(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(bias, parse, ignore, v4208);       if (ignore)      {         t1790(parse, bias);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         bias.input = r1787(parse);      bias.min    = r1787(parse);     bias.max    = r1787(parse);     bias.bias   = r1787(parse);     bias.spread = r1787(parse);           parse.r3646--;       t1790(parse, bias);     return bias; }    function v1701(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const m3670 = new q1933(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(m3670, parse, ignore, v4208);       if (ignore)      {         t1790(parse, m3670);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         m3670.input = r1787(parse);      m3670._value = r1787(parse);      parse.r3646--;       t1790(parse, m3670);     return m3670; }    function e1702(parse, m1689) {     const [type, nodeId, options, ignore] = o1789(parse);       const math = m1689(nodeId, options);           let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(math, parse, ignore, v4208);       if (ignore)      {         t1790(parse, math);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      for (let i = 0; i < v4208; i++)         math.inputs.push(r1787(parse));       math.operation = r1787(parse);       parse.r3646--;               t1790(parse, math);     return math; }    function q1703(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const smath = new b1904(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(smath, parse, ignore, v4208);       if (ignore)      {         t1790(parse, smath);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         smath.input = r1787(parse);      smath.operation = r1787(parse);     smath.operand   = r1787(parse);     smath.invert    = r1787(parse);           parse.r3646--;       t1790(parse, smath);     return smath; }    function v1704(parse, m1689) {     const [type, nodeId, options, ignore] = o1789(parse);       const arith = m1689(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(arith, parse, ignore, v4208);       if (ignore)      {         t1790(parse, arith);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      for (let i = 0; i < v4208; i++)         arith.inputs.push(r1787(parse));      parse.r3646--;               t1790(parse, arith);     return arith; }    function u1705(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const convert = new r1927(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(convert, parse, ignore, v4208);       if (ignore)      {         t1790(parse, convert);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         convert.input = r1787(parse);      convert.from = r1787(parse);           parse.r3646--;       t1790(parse, convert);     return convert; }    function genParseIterate(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const define = new d1929(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(define, parse, ignore, v4208);       if (ignore)      {         t1790(parse, define);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           for (let i = 0; i < v4208; i++)         define.inputs.push(r1787(parse));       parse.r3646--;       t1790(parse, define);     return define; }    function n1707(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const dist = new n1939(nodeId, options);       if (parse.settings.logRequests)          x2123(dist, parse, ignore);       if (ignore)      {         t1790(parse, dist);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       dist.from   = r1787(parse);     dist.start  = r1787(parse);     dist.end    = r1787(parse);       parse.r3646--;       t1790(parse, dist);     return dist; }    function t1708(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const wave = new k1945(nodeId, options);       if (parse.settings.logRequests)          x2123(wave, parse, ignore);       if (ignore)      {         t1790(parse, wave);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       wave.shape     = r1787(parse);     wave.base      = r1787(parse);     wave.amplitude = r1787(parse);     wave.frequency = r1787(parse);     wave.offset    = r1787(parse);     wave.bias      = r1787(parse);       wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.r3646--;       t1790(parse, wave);     return wave; }    function g1709(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const seq = new t1941(nodeId, options);       if (parse.settings.logRequests)          x2123(seq, parse, ignore);       if (ignore)      {         t1790(parse, seq);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       seq.start    = r1787(parse);     seq.multiply = r1787(parse);     seq.add      = r1787(parse);     seq.end      = r1787(parse);       parse.r3646--;       t1790(parse, seq);     return seq; }    function o1710(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const rnd = new n1938(nodeId, options);       if (parse.settings.logRequests)          x2123(rnd, parse, ignore);       if (ignore)      {         t1790(parse, rnd);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       rnd.seed      = r1787(parse);     rnd.iteration = r1787(parse);     rnd.min       = r1787(parse);     rnd.max       = r1787(parse);     rnd.bias      = r1787(parse);     rnd.spread    = r1787(parse);     rnd.unique    = r1787(parse);       parse.r3646--;       t1790(parse, rnd);     return rnd; }    function u1711(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const noise = new a1934(nodeId, options);       if (parse.settings.logRequests)          x2123(noise, parse, ignore);       if (ignore)      {         t1790(parse, noise);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       noise.seed        = r1787(parse);     noise.iteration   = r1787(parse);     noise.min         = r1787(parse);     noise.max         = r1787(parse);     noise.scale       = r1787(parse);     noise.offset      = r1787(parse);     noise.evolve      = r1787(parse);     noise.interpolate = r1787(parse);     noise.detail      = r1787(parse);       parse.r3646--;       t1790(parse, noise);     return noise; }    function l1712(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const prob = new v1937(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }       const j3681 =          v4208 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.logRequests)          x2123(prob, parse, ignore, v4208);       if (ignore)      {         t1790(parse, prob);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         prob.b4082   = r1787(parse);         prob.o4083   = r1787(parse);     }     else if (v4208 == 1)     {              if (j3681 == 0) prob.b4082 = r1787(parse);          else if (j3681 == 1) prob.o4083 = r1787(parse);      }       prob.seed      = r1787(parse);     prob.iteration = r1787(parse);     prob.chance    = r1787(parse);     prob.alternate = r1787(parse);       parse.r3646--;       t1790(parse, prob);     return prob; }    function t1713(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const accum = new e1924(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(accum, parse, ignore, v4208);       if (ignore)      {         t1790(parse, accum);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         accum.input = r1787(parse);      accum.when = r1787(parse);               parse.r3646--;       t1790(parse, accum);     return accum; }    function genParseHold(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const hold = new GHold(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(hold, parse, ignore, v4208);       if (ignore)      {         t1790(parse, hold);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         hold.input = r1787(parse);      hold.first = r1787(parse);               parse.r3646--;       t1790(parse, hold);     return hold; }    function z1714(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const x1035 = new r1930(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(x1035, parse, ignore, v4208);       if (ignore)      {         t1790(parse, x1035);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      for (let i = 0; i < v4208; i++)         x1035.inputs.push(r1787(parse));       x1035.amount = r1787(parse);     x1035.degree = r1787(parse);       parse.r3646--;       t1790(parse, x1035);     return x1035; }    function v1715(parse) {     const [type, nodeId, options, ignore] = o1789(parse);       const bool = new z1907(nodeId, options);           let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(bool, parse, ignore, v4208);       if (ignore)      {         t1790(parse, bool);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      for (let i = 0; i < v4208; i++)         bool.inputs.push(r1787(parse));       bool.operation = r1787(parse);       parse.r3646--;               t1790(parse, bool);     return bool; }    function x1716(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cond = new r1911(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(cond, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cond);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         cond.input = r1787(parse);             cond.operation = r1787(parse);     cond.operand   = r1787(parse);       parse.r3646--;       t1790(parse, cond);     return cond; }    function t1717(parse, m1689) {     const [type, nodeId, options, ignore] = o1789(parse);       const cond = m1689(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)         x2123(cond, parse, ignore, v4208);        if (ignore)      {         t1790(parse, cond);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;      if (v4208 == 2)     {         cond.b4082 = r1787(parse);         cond.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         cond.b4082 = r1787(parse);      }      parse.r3646--;       t1790(parse, cond);     return cond; }    function a1718(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const trig = new d1922(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(trig, parse, ignore, v4208);       if (ignore)      {         t1790(parse, trig);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         trig.input = r1787(parse);      trig.function = r1787(parse);      parse.r3646--;       t1790(parse, trig);     return trig; }    function q1719(parse, m1689) {     const [type, nodeId, options, ignore] = o1789(parse);       const trig = m1689(nodeId, options);       let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)         x2123(trig, parse, ignore, v4208);        if (ignore)      {         t1790(parse, trig);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         trig.input = r1787(parse);       parse.r3646--;       t1790(parse, trig);     return trig; }    function r1720(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const atan2 = new g1918(nodeId, options);              if (parse.settings.logRequests)          x2123(atan2, parse, ignore);       if (ignore)      {         t1790(parse, atan2);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       atan2.x = r1787(parse);     atan2.y = r1787(parse);           parse.r3646--;       t1790(parse, atan2);     return atan2; }    function m1721(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const solve = new v1944(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(solve, parse, ignore, v4208);       if (ignore)      {         t1790(parse, solve);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         solve.input = r1787(parse);      solve.current = r1787(parse);     solve.target  = r1787(parse);           parse.r3646--;       t1790(parse, solve);     return solve; }    function d1722(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const anim = new z1925(nodeId, options);       if (parse.settings.logRequests)          x2123(anim, parse);       if (ignore)      {         t1790(parse, anim);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       anim.from   = r1787(parse);     anim.to     = r1787(parse);     anim.curve  = r1787(parse);     anim.repeat = r1787(parse);     anim.length = r1787(parse);     anim.time   = r1787(parse);       parse.r3646--;       t1790(parse, anim);     return anim; } 


function v1723(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const rect = new b1968(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(rect, parse, ignore);       if (ignore)      {         t1790(parse, rect);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         rect.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'x':      rect.x      = r1787(parse); break;         case 'y':      rect.y      = r1787(parse); break;         case 'width':  rect.width  = r1787(parse); break;         case 'height': rect.height = r1787(parse); break;         case 'round':  rect.round  = r1787(parse); break;         case 'props':  rect.props  = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, rect);     return rect; }                                                                     function q1724(parse) {     const [, nodeId, options, ignore] = o1789(parse);         const line = new b1959(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(line, parse, ignore);       if (ignore)      {         t1790(parse, line);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         line.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'x':     line.x     = r1787(parse); break;         case 'y':     line.y     = r1787(parse); break;         case 'width': line.width = r1787(parse); break;         case 'props': line.props = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, line);     return line; }    function c1725(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const ellipse = new z1955(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(ellipse, parse, ignore);       if (ignore)      {         t1790(parse, ellipse);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         ellipse.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'position': ellipse.position = r1787(parse); break;         case 'x':        ellipse.x        = r1787(parse); break;         case 'y':        ellipse.y        = r1787(parse); break;         case 'width':    ellipse.width    = r1787(parse); break;         case 'height':   ellipse.height   = r1787(parse); break;         case 'round':    ellipse.round    = r1787(parse); break;         case 'start':    ellipse.start    = r1787(parse); break;         case 'sweep':    ellipse.sweep    = r1787(parse); break;         case 'inner':    ellipse.inner    = r1787(parse); break;         case 'props':    ellipse.props    = r1787(parse); break;         }     }               ellipse.innerAbsolute  = parseInt(parse.move()) > 0;     ellipse.sweepInDegrees = parseInt(parse.move()) > 0;       parse.z1788 = false;     parse.r3646--;       t1790(parse, ellipse);     return ellipse; }    function l1726(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const trapeze = new t1979(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(trapeze, parse, ignore);       if (ignore)      {         t1790(parse, trapeze);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         trapeze.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'x':      trapeze.x      = r1787(parse); break;         case 'y':      trapeze.y      = r1787(parse); break;         case 'width':  trapeze.width  = r1787(parse); break;         case 'height': trapeze.height = r1787(parse); break;         case 'round':  trapeze.round  = r1787(parse); break;         case 'bias':   trapeze.bias   = r1787(parse); break;         case 'props':  trapeze.props  = r1787(parse); break;         }     }               parse.z1788 = false;     parse.r3646--;       t1790(parse, trapeze);     return trapeze; }    function n1727(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const poly = new z1967(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(poly, parse, ignore);       if (ignore)      {         t1790(parse, poly);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         poly.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'position': poly.position = r1787(parse); break;         case 'x':        poly.x        = r1787(parse); break;         case 'y':        poly.y        = r1787(parse); break;         case 'width':    poly.width    = r1787(parse); break;         case 'height':   poly.height   = r1787(parse); break;         case 'round':    poly.round    = r1787(parse); break;         case 'corners':  poly.corners  = r1787(parse); break;         case 'props':    poly.props    = r1787(parse); break;         }     }               parse.z1788 = false;     parse.r3646--;       t1790(parse, poly);     return poly; }    function m1728(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const star = new y1977(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(star, parse, ignore);       if (ignore)      {         t1790(parse, star);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         star.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'position': star.position = r1787(parse); break;         case 'x':        star.x        = r1787(parse); break;         case 'y':        star.y        = r1787(parse); break;         case 'width':    star.width    = r1787(parse); break;         case 'height':   star.height   = r1787(parse); break;         case 'round':    star.round    = r1787(parse); break;         case 'points':   star.points   = r1787(parse); break;         case 'convex':   star.convex   = r1787(parse); break;         case 'props':    star.props    = r1787(parse); break;         }     }               parse.z1788 = false;     parse.r3646--;       t1790(parse, star);     return star; }    function e1729(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const text = new o1978(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(text, parse, ignore);       if (ignore)      {         t1790(parse, text);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         text.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {                case 'text':          text.text          = r1787(parse); break;         case 'x':             text.x             = r1787(parse); break;         case 'y':             text.y             = r1787(parse); break;         case 'width':         text.width         = r1787(parse); break;         case 'height':        text.height        = r1787(parse); break;         case 'font':          text.font          = r1787(parse); break;         case 'size':          text.size          = r1787(parse); break;         case 'style':         text.style         = r1787(parse); break;         case 'props':         text.props         = r1787(parse); break;         case 'alignX':        text.alignX        = r1787(parse); break;         case 'alignY':        text.alignY        = r1787(parse); break;         case 'lineHeight':    text.lineHeight    = r1787(parse); break;         case 'letterSpacing': text.letterSpacing = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, text);     return text; }    function l1730(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          u2130(u1245, point, parse);      return y3827(point)[0]; }    function a1731(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const point = new j1963(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(point, parse, ignore);       if (ignore)      {         t1790(parse, point);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         point.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'x': point.x = r1787(parse); break;         case 'y': point.y = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, point);     return point; }    function w1732(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const corner = new b1964(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(corner, parse, ignore);       if (ignore)      {         t1790(parse, corner);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         corner.input = r1787(parse);      corner.smooth = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, corner);     return corner; }    function p1733(parse) {     parse.pos++;       const path = parse.move();      if (parse.settings.logRequests)          u2130(b1249, path, parse);      return y3669(path)[0]; }    function j1734(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const path = new r1983(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(path, parse, ignore);       if (ignore)      {         t1790(parse, path);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         path.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {                case 'points':  path.points  = r1787(parse); break;         case 'closed':  path.closed  = r1787(parse); break;         case 'degree':  path.degree  = r1787(parse); break;         case 'winding': path.winding = r1787(parse); break;         case 'round':   path.round   = r1787(parse); break;         case 'props':   path.props   = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, path);     return path; }    function genParsePathLength(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const len = new GPathLength(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(len, parse, ignore, v4208);       if (ignore)      {         t1790(parse, len);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         len.input = r1787(parse);           parse.r3646--;       t1790(parse, len);     return len; }    function genParseJoinPaths(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const join = new GJoinPaths(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(join, parse, ignore, v4208);       if (ignore)      {         t1790(parse, join);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         join.inputs.push(r1787(parse));       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {                case 'closed':  join.closed  = r1787(parse); break;         case 'degree':  join.degree  = r1787(parse); break;         case 'winding': join.winding = r1787(parse); break;         case 'round':   join.round   = r1787(parse); break;         case 'props':   join.props   = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, join);     return join; }    function genParseReorientPaths(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const reorient = new GReorientPaths(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(reorient, parse, ignore, v4208);       if (ignore)      {         t1790(parse, reorient);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         reorient.inputs.push(r1787(parse));       reorient.reverse = r1787(parse);                   parse.z1788 = false;     parse.r3646--;       t1790(parse, reorient);     return reorient; }    function m1735(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.logRequests)          u2130(g1252, point, parse);      return g3668(point)[0]; }    function b1736(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const point = new o1985(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(point, parse, ignore);       if (ignore)      {         t1790(parse, point);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         point.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'x':     point.x     = r1787(parse); break;         case 'y':     point.y     = r1787(parse); break;         case 'join':  point.join  = r1787(parse); break;         case 'cap':   point.cap   = r1787(parse); break;         case 'round': point.round = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, point);     return point; }    function p1737(parse) {     parse.pos++;       const edge = parse.move();      if (parse.settings.logRequests)          u2130(s1255, edge, parse);      return o3666(edge)[0]; }    function t1738(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const edge = new b1980(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(edge, parse, ignore, v4208);       if (ignore)      {         t1790(parse, edge);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         edge.b4082 = r1787(parse);         edge.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         edge.b4082 = r1787(parse);      }       edge.c3664 = r1787(parse);     edge.  r3665 = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, edge);     return edge; }    function p1739(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          u2130(w1258, region, parse);      return y3663(region)[0]; }    function v1740(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const region = new b1984(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(region, parse, ignore, v4208);       if (ignore)      {         t1790(parse, region);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         region.inputs.push(r1787(parse));       region.winding = r1787(parse);     region.props   = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, region);     return region; }    function a1741(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.logRequests)          u2130(s1261, region, parse);      return d3662(region)[0]; }    function j1742(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const network = new o1982(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(network, parse, ignore, v4208);       if (ignore)      {         t1790(parse, network);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         network.inputs.push(r1787(parse));      network.props = r1787(parse);       parse.r3646--;        t1790(parse, network);     return network; }    function u1743(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const bool = new y1946(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(bool, parse, ignore);       if (ignore)      {         t1790(parse, bool);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         bool.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'children':  bool.children  = r1787(parse); break;         case 'operation': bool.operation = r1787(parse); break;         case 'props':     bool.props     = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, bool);     return bool; }    function genParseArcPath(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const arc = new GArcPath(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(arc, parse, ignore);       if (ignore)      {         t1790(parse, arc);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         arc.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'position': arc.position = r1787(parse); break;         case 'x':        arc.x        = r1787(parse); break;         case 'y':        arc.y        = r1787(parse); break;         case 'width':    arc.width    = r1787(parse); break;         case 'height':   arc.height   = r1787(parse); break;         case 'start':    arc.start    = r1787(parse); break;         case 'sweep':    arc.sweep    = r1787(parse); break;         case 'props':    arc.props    = r1787(parse); break;         }     }               arc.sweepInDegrees = parseInt(parse.move()) > 0;       parse.z1788 = false;     parse.r3646--;       t1790(parse, arc);     return arc; }    function genParseWavePath(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const wave = new GWavePath(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(wave, parse, ignore);       if (ignore)      {         t1790(parse, wave);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         wave.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'shape':     wave.shape     = r1787(parse); break;         case 'x':         wave.x         = r1787(parse); break;         case 'y':         wave.y         = r1787(parse); break;         case 'width':     wave.width     = r1787(parse); break;         case 'amplitude': wave.amplitude = r1787(parse); break;         case 'frequency': wave.frequency = r1787(parse); break;         case 'offset':    wave.offset    = r1787(parse); break;         case 'alignX':    wave.alignX    = r1787(parse); break;         case 'alignY':    wave.alignY    = r1787(parse); break;         case 'props':     wave.props     = r1787(parse); break;         }     }               wave.useWavelength  = parseInt(parse.move()) > 0;     wave.offsetAbsolute = parseInt(parse.move()) > 0;       parse.z1788 = false;     parse.r3646--;       t1790(parse, wave);     return wave; }    function y1744(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const group = new y1975(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(group, parse, ignore, v4208);       if (ignore)      {         t1790(parse, group);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         group.inputs.push(r1787(parse));       parse.r3646--;       t1790(parse, group);     return group; }    function t1745(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const frame = new d1956(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(frame, parse, ignore);       if (ignore)      {         t1790(parse, frame);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         frame.input = r1787(parse);       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {         case 'children': frame.children = r1787(parse); break;         case 'position': frame.position = r1787(parse); break;         case 'x':        frame.x        = r1787(parse); break;         case 'y':        frame.y        = r1787(parse); break;         case 'width':    frame.width    = r1787(parse); break;         case 'height':   frame.height   = r1787(parse); break;         case 'round':    frame.round    = r1787(parse); break;         case 'clip':     frame.clip     = r1787(parse); break;         case 'props':    frame.props    = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, frame);     return frame; }    function e1746(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const move = new v1961(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(move, parse, ignore);       if (ignore)      {         t1790(parse, move);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         move.input = r1787(parse);      move.g3661    = r1787(parse);     move.x           = r1787(parse);     move.y           = r1787(parse);     move.affectSpace = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, move);     return move; }    function v1747(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const rotate = new e1971(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(rotate, parse, ignore);       if (ignore)      {         t1790(parse, rotate);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         rotate.input = r1787(parse);      rotate.angle       = r1787(parse);     rotate.affectSpace = r1787(parse);           parse.z1788 = false;     parse.r3646--;       t1790(parse, rotate);     return rotate; }    function t1748(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const scale = new p1972(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(scale, parse, ignore);       if (ignore)      {         t1790(parse, scale);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         scale.input = r1787(parse);      scale.scaleX        = r1787(parse);     scale.scaleY        = r1787(parse);     scale.affectCorners = r1787(parse);     scale.affectStyle   = r1787(parse);     scale.affectSpace   = r1787(parse);           parse.z1788 = false;     parse.r3646--;       t1790(parse, scale);     return scale; }    function k1749(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const skew = new i1976(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(skew, parse, ignore);       if (ignore)      {         t1790(parse, skew);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         skew.input = r1787(parse);      skew.skewX       = r1787(parse);     skew.skewY       = r1787(parse);     skew.affectSpace = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, skew);     return skew; }    function genParseShowCenter(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const showCenter = new GShowCenter(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(showCenter, parse, ignore);       if (ignore)      {         t1790(parse, showCenter);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         showCenter.input = r1787(parse);      showCenter.show = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, showCenter);     return showCenter; }    function x1750(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const center = new f1953(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(center, parse, ignore);       if (ignore)      {         t1790(parse, center);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         center.input = r1787(parse);      center.centerX    = r1787(parse);     center.centerY    = r1787(parse);     center.units      = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, center);     return center; }    function t1751(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const reset = new g1970(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(reset, parse, ignore);       if (ignore)      {         t1790(parse, reset);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         reset.input = r1787(parse);       parse.r3646--;       t1790(parse, reset);     return reset; }    function h1752(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const measure = new s1960(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(measure, parse, ignore, v4208);       if (ignore)      {         t1790(parse, measure);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           if (v4208 == 1)         measure.input = r1787(parse);                 parse.r3646--;       t1790(parse, measure);     return measure; }    function e1753(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const angle = new GPointAngle(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(angle, parse, ignore, v4208);       if (ignore)      {         t1790(parse, angle);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         angle.input = r1787(parse);           parse.r3646--;       t1790(parse, angle);     return angle; }    function p1754(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const vector = new q1981(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(vector, parse, ignore, v4208);       if (ignore)      {         t1790(parse, vector);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           if (v4208 == 2)     {         vector.b4082 = r1787(parse);         vector.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         vector.b4082 = r1787(parse);      }       vector.transform  = r1787(parse);       parse.r3646--;       t1790(parse, vector);     return vector; }    function v1755(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const center = new r1954(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          x2123(center, parse, ignore, v4208);       if (ignore)      {         t1790(parse, center);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           if (v4208 == 3)     {         center.b4082 = r1787(parse);         center.o4083 = r1787(parse);         center.t4084 = r1787(parse);     }     else if (v4208 == 2)     {         center.b4082 = r1787(parse);         center.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         center.b4082 = r1787(parse);     }       parse.r3646--;       t1790(parse, center);     return center; }    function genParseArcFromPoints(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const arc = new GArcFromPoints(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.logRequests)          x2123(arc, parse, ignore, v4208);       if (ignore)      {         t1790(parse, arc);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           if (v4208 == 3)     {         arc.b4082 = r1787(parse);         arc.o4083 = r1787(parse);         arc.t4084 = r1787(parse);     }     else if (v4208 == 2)     {         arc.b4082 = r1787(parse);         arc.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         arc.b4082 = r1787(parse);     }       const i3667 = q1792(parse);      for (let i = 0; i < i3667; i++)     {         const f2991 = h1794(parse);          parse.z1788 = true;          switch (f2991)         {                case 'props':   arc.props   = r1787(parse); break;         }     }       parse.z1788 = false;     parse.r3646--;       t1790(parse, arc);     return arc; }    function s1756(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const inter = new u1958(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 4, 'nInputs must be [0, 4]');     }           if (parse.settings.logRequests)          x2123(inter, parse, ignore, v4208);       if (ignore)      {         t1790(parse, inter);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           if (v4208 == 4)     {         inter.b4082 = r1787(parse);         inter.o4083 = r1787(parse);         inter.t4084 = r1787(parse);         inter.v4085 = r1787(parse);     }     else if (v4208 == 3)     {         inter.b4082 = r1787(parse);         inter.o4083 = r1787(parse);         inter.t4084 = r1787(parse);     }     else if (v4208 == 2)     {         inter.b4082 = r1787(parse);         inter.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         inter.b4082 = r1787(parse);     }       inter.segment = r1787(parse);       parse.r3646--;       t1790(parse, inter);     return inter; }    function j1757(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const x1035 = new f1957(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(x1035, parse, ignore, v4208);       if (ignore)      {         t1790(parse, x1035);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         x1035.b4082 = r1787(parse);         x1035.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         x1035.b4082 = r1787(parse);      }       x1035.amount     = r1787(parse);     x1035.transform  = r1787(parse);       parse.r3646--;       t1790(parse, x1035);     return x1035; }    function genParsePointAlongPath(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const pap = new y1965(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(pap, parse, ignore, v4208);       if (ignore)      {         t1790(parse, pap);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         pap.input = r1787(parse);        pap.position   = r1787(parse);     pap.distance   = r1787(parse);     pap.offset     = r1787(parse);     pap.transform  = r1787(parse);       parse.r3646--;       t1790(parse, pap);     return pap; }    function genParseClosestPointOnPath(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cpop = new r1966(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(cpop, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cpop);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         cpop.b4082 = r1787(parse);         cpop.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         cpop.b4082 = r1787(parse);      }       cpop.constrain  = r1787(parse);     cpop.transform  = r1787(parse);       parse.r3646--;       t1790(parse, cpop);     return cpop; }    function genParseReversePath(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const reverse = new GReversePath(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(reverse, parse, ignore, v4208);       if (ignore)      {         t1790(parse, reverse);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         reverse.input = r1787(parse);             parse.r3646--;       t1790(parse, reverse);     return reverse; }    function genParseBlendPath(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const blend = new GBlendPath(nodeId, options);          let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(blend, parse, ignore, v4208);       if (ignore)      {         t1790(parse, blend);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;           for (let i = 0; i < v4208; i++)         blend.inputs.push(r1787(parse));       blend.amount = r1787(parse);     blend.degree = r1787(parse);             parse.r3646--;       t1790(parse, blend);     return blend; }    function t1759(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const place = new g1962(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(place, parse, ignore);       if (ignore)      {         t1790(parse, place);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         place.input = r1787(parse);      place.position   = r1787(parse);     place.transform  = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, place);     return place; }    function i1760(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const apply = new x1952(nodeId, options);       let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(apply, parse, ignore);       if (ignore)      {         t1790(parse, apply);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         apply.input = r1787(parse);      apply.props   = r1787(parse);     apply.replace = r1787(parse);       parse.z1788 = false;     parse.r3646--;       t1790(parse, apply);     return apply; }    function f1761(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const render = new e1969(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(render, parse, ignore, v4208);       if (ignore)      {         t1790(parse, render);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         render.inputs.push(r1787(parse));      render.retain   = r1787(parse);     render.finalize = r1787(parse);       parse.r3646--;       t1790(parse, render);     return render; }    function genParseExport(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const _export = new GExport(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(_export, parse, ignore, v4208);       if (ignore)      {         t1790(parse, _export);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         _export.inputs.push(r1787(parse));      _export.scale    = r1787(parse);     _export.format   = r1787(parse);         _export.suffix   = r1787(parse);     _export.profile  = r1787(parse);       parse.r3646--;       t1790(parse, _export);     return _export; }


              function a1762(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const style = new t1886(nodeId, options);      style.existing = options.existing;       if (parse.settings.logRequests)          x2123(style, parse, ignore);       if (ignore)      {         t1790(parse, style);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;     parse.z1788 = false;       style.id       = parse.move();     style.name     = options.nodeName;          style.m2817 = r1787(parse);           parse.r3646--;           style.linked = style.id != NULL;       t1790(parse, style);     return style; }                             


 function o1763(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.logRequests)          u2130(l1143, val, parse);      return b2864(val)[0]; }    function v1764(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const text = new i1991(nodeId, options);           if (parse.settings.logRequests)          x2123(text, parse, ignore);       if (ignore)      {         t1790(parse, text);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;     parse.z1788 = false;       if (parse.next == l1143) text.value = r1787(parse);     else                          text.input = r1787(parse);       parse.r3646--;       t1790(parse, text);     return text; }    function n1765(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const len = new x1999(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(len, parse, ignore, v4208);       if (ignore)      {         t1790(parse, len);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         len.input = r1787(parse);           parse.r3646--;       t1790(parse, len);     return len; }    function x1766(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const trim = new n2006(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(trim, parse, ignore, v4208);       if (ignore)      {         t1790(parse, trim);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         trim.input = r1787(parse);      trim.start = r1787(parse);     trim.end   = r1787(parse);           parse.r3646--;       t1790(parse, trim);     return trim; }    function w1767(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const sub = new y2003(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(sub, parse, ignore, v4208);       if (ignore)      {         t1790(parse, sub);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         sub.input = r1787(parse);      sub.start = r1787(parse);     sub.end   = r1787(parse);           parse.r3646--;       t1790(parse, sub);     return sub; }    function k1768(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cont = new u1994(nodeId, options);          let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(cont, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cont);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         cont.b4082 = r1787(parse);         cont.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         cont.b4082 = r1787(parse);      }             parse.r3646--;       t1790(parse, cont);     return cont; }    function n1769(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const t3658 = new b1992(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(t3658, parse, ignore, v4208);       if (ignore)      {         t1790(parse, t3658);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         t3658.input = r1787(parse);      t3658.case = r1787(parse);           parse.r3646--;       t1790(parse, t3658);     return t3658; }    function t1770(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const replace = new y2001(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(replace, parse, ignore, v4208);       if (ignore)      {         t1790(parse, replace);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         replace.input = r1787(parse);      replace.what  = r1787(parse);     replace.with  = r1787(parse);     replace.regex = r1787(parse);           parse.r3646--;       t1790(parse, replace);     return replace; }                                                                     function i1771(parse, m1689) {     const [type, nodeId, options, ignore] = o1789(parse);       const join = new d1998(nodeId, options);       let v4208 = 0;          if (!ignore)         v4208 = parseInt(parse.move());       if (parse.settings.logRequests)          x2123(join, parse, ignore, v4208);       if (ignore)      {         t1790(parse, join);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       for (let i = 0; i < v4208; i++)         join.inputs.push(r1787(parse));       join.with = r1787(parse);           parse.r3646--;               t1790(parse, join);     return join; }    function z1772(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const pad = new t2000(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(pad, parse, ignore, v4208);       if (ignore)      {         t1790(parse, pad);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         pad.input = r1787(parse);      pad.q3654   = r1787(parse);     pad.l3655 = r1787(parse);     pad.d3656     = r1787(parse);     pad.y3657   = r1787(parse);           parse.r3646--;       t1790(parse, pad);     return pad; }    function l1773(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const cmp = new l1993(nodeId, options);          let v4208 = -1;      if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 => 0 && v4208 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.logRequests)          x2123(cmp, parse, ignore, v4208);       if (ignore)      {         t1790(parse, cmp);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 2)     {         cmp.b4082 = r1787(parse);         cmp.o4083 = r1787(parse);     }     else if (v4208 == 1)     {         cmp.b4082 = r1787(parse);      }             cmp.operation = r1787(parse);           parse.r3646--;       t1790(parse, cmp);     return cmp; }    function v1774(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const x3653 = new u1987(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(x3653, parse, ignore, v4208);       if (ignore)      {         t1790(parse, x3653);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         x3653.input = r1787(parse);           parse.r3646--;       t1790(parse, x3653);     return x3653; }    function r1775(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const t3652 = new w1986(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(t3652, parse, ignore, v4208);       if (ignore)      {         t1790(parse, t3652);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         t3652.input = r1787(parse);           parse.r3646--;       t1790(parse, t3652);     return t3652; }    function c1776(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const index = new a1989(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(index, parse, ignore, v4208);       if (ignore)      {         t1790(parse, index);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       index.name  = r1787(parse);     index.index = r1787(parse);           parse.r3646--;       t1790(parse, index);     return index; }    function i1777(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const f3651 = new m1990(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(f3651, parse, ignore, v4208);       if (ignore)      {         t1790(parse, f3651);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         f3651.input = r1787(parse);      f3651.base      = r1787(parse);     f3651.decimals  = r1787(parse);     f3651.thousands = r1787(parse);           parse.r3646--;       t1790(parse, f3651);     return f3651; }    function w1778(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const r3650 = new y1988(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(r3650, parse, ignore, v4208);       if (ignore)      {         t1790(parse, r3650);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         r3650.input = r1787(parse);      r3650.format = r1787(parse);           parse.r3646--;       t1790(parse, r3650);     return r3650; }    function x1779(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const j3649 = new y2005(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(j3649, parse, ignore);       if (ignore)      {         t1790(parse, j3649);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         j3649.input = r1787(parse);      j3649.base      = r1787(parse);     j3649.decimals  = r1787(parse);     j3649.thousands = r1787(parse);           parse.r3646--;       t1790(parse, j3649);     return j3649; }    function x1780(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const text2col = new v2004(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.logRequests)          x2123(text2col, parse, ignore);       if (ignore)      {         t1790(parse, text2col);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         text2col.input = r1787(parse);           parse.r3646--;       t1790(parse, text2col);     return text2col; }    function p1781(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const split = new a2002(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(split, parse, ignore, v4208);       if (ignore)      {         t1790(parse, split);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         split.input = r1787(parse);      split.separator = r1787(parse);           parse.r3646--;       t1790(parse, split);     return split; }    function u1782(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const csv = new j1995(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(csv, parse, ignore, v4208);       if (ignore)      {         t1790(parse, csv);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         csv.input = r1787(parse);      csv.r3647    = r1787(parse);     csv.i3648 = r1787(parse);           parse.r3646--;       t1790(parse, csv);     return csv; }    function k3703(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const json = new GTextJson(nodeId, options);          let v4208 = -1;          if (!ignore)     {         v4208 = parseInt(parse.move());         g952(v4208 == 0 || v4208 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.logRequests)          x2123(json, parse, ignore, v4208);       if (ignore)      {         t1790(parse, json);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       if (v4208 == 1)         json.input = r1787(parse);           parse.r3646--;       t1790(parse, json);     return json; }    function b1783(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const fetch = new n1996(nodeId, options);          if (parse.settings.logRequests)          x2123(fetch, parse, ignore);       if (ignore)      {         t1790(parse, fetch);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       fetch.request     = r1787(parse);     fetch.d4211 = r1787(parse);           parse.r3646--;       t1790(parse, fetch);     return fetch; }    function h1784(parse) {     const [, nodeId, options, ignore] = o1789(parse);       const file = new s1997(nodeId, options);          if (parse.settings.logRequests)          x2123(file, parse, ignore);       if (ignore)      {         t1790(parse, file);         return parse.w4242.find(n => n.nodeId == nodeId);     }       parse.r3646++;       file.d4211 = r1787(parse);                parse.r3646--;       t1790(parse, file);     return file; }


class r1785 {     request;     i2066;          pos;      so;      settings = {};      save;       log  = '';          r3646 = 0;      get tab() { return this.z1788 ? ' ' : (u872 + t870.repeat(Math.max(0, this.r3646))); }           z1788 = false;       evalAccumulate = true;     evalFeedback   = true;           z4018;     j4019;      viewportZoom;      m3638 = 0;     j3639   = 0;      scope           = [];      w4242     = [];            repeats         = [];        e3640    = false;           n3641    = [];        d2875    = [];     s3095    = [];     g3642   = [];     y3643    = [];            get next() { return this.request[this.pos]; }      get i3645()      {          return this.pos+1 < this.request.length               ? this.request[this.pos+1]              : null;     }        constructor(request, n3644, i2066, z4018, j4019, viewportZoom, settings, save)     {         this.request       = request;         this.i2066     = i2066;                    this.pos           = n3644;          this.so            = 0;                  this.z4018  = z4018;          this.j4019 = j4019;             this.viewportZoom  = viewportZoom;          this.settings      = settings;          this.save          = save;     }        move()     {                   const token = this.request[this.pos++];                  return token;     }        t1786()      {         return isEmpty(this.repeats)             ||    this.repeats.length == 1                && this.repeats[0].currentIteration == this.repeats[0].total-1;     }  }    function r1787(parse, z1788 = true) {           if (!z1788)         parse.z1788 = false;       let result = null;            if (parse.next == PARAM                  ) result = a1793             (parse);              else if (parse.next ==        q1056                        || parse.next == h1057                        || parse.next ==   v1058                        || parse.next ==  s1059      ) result = i1634         (parse);       else if (parse.next == p1060              ) result = t1631              (parse);     else if (parse.next == x1061               ) result = w1632          (parse);     else if (parse.next == y1062         ) result = g1633     (parse);     else if (parse.next == r1084                ) result = t1653            (parse);     else if (parse.next == g1063               ) result = e1654          (parse);     else if (parse.next == s1064                 ) result = w1655            (parse);     else if (parse.next == z1065                  ) result = m1656             (parse);     else if (parse.next == v1086                ) result = genParseIterate           (parse);     else if (parse.next == j1066                 ) result = h1657            (parse);     else if (parse.next == v1067                  ) result = k1658             (parse);     else if (parse.next == f1068             ) result = h1659         (parse);     else if (parse.next == r1352   ) result = genParseGetListValueNames (parse);     else if (parse.next == d1353       ) result = genParseListValueNames    (parse);     else if (parse.next == x1354            ) result = genParseObjectName        (parse);      else if (parse.next == u1069                ) result = z1635           (parse);     else if (parse.next == n1070           ) result = x1636        (parse);     else if (parse.next == j1071                ) result = z1637           (parse);     else if (parse.next == f1072              ) result = a1638          (parse);     else if (parse.next == t1073              ) result = g1639          (parse);     else if (parse.next == b1074                ) result = x1640           (parse);     else if (parse.next == k1075                 ) result = v1641            (parse);     else if (parse.next == b1349           ) result = s1642       (parse);     else if (parse.next == o1350             ) result = a1643         (parse);     else if (parse.next == i1076           ) result = m1644       (parse);     else if (parse.next == t1351            ) result = genParseBuckleList        (parse);     else if (parse.next == o1077                   ) result = w1645              (parse);     else if (parse.next == z1085                 ) result = b1646            (parse);     else if (parse.next == t1078                 ) result = l1647            (parse);     else if (parse.next == b1079                   ) result = u1648              (parse);     else if (parse.next == u1080                   ) result = o1649              (parse);     else if (parse.next == w1083                 ) result = v1650            (parse);     else if (parse.next == w1360       ) result = genParseSelectFromList    (parse);     else if (parse.next == k1081             ) result = y1651         (parse);     else if (parse.next == OBJECT_COUNT           ) result = genParseObjectCount       (parse);     else if (parse.next == o1082               ) result = g1652      (parse);           else if (parse.next == n1091           ) result = n1690          (parse);     else if (parse.next == x1092                 ) result = q1691            (parse);     else if (parse.next == v1355       ) result = genParseSetPrecision      (parse);     else if (parse.next == t1093            ) result = f1694              (parse);     else if (parse.next == q1094        ) result = u1695          (parse);     else if (parse.next == p1356        ) result = genParseNegative          (parse);     else if (parse.next == f1095           ) result = m1696             (parse);     else if (parse.next == z1357        ) result = genParseQuantize          (parse);     else if (parse.next == c1097          ) result = v1698            (parse);     else if (parse.next == s1096   ) result = i1697      (parse);     else if (parse.next == k1098          ) result = g1699            (parse);     else if (parse.next == j1099           ) result = h1700       (parse);     else if (parse.next == e1358             ) result = genParseNumberMap         (parse);     else if (parse.next == k1359            ) result = genParseNumberBias        (parse);     else if (parse.next == s1100             ) result = v1701       (parse);     else if (parse.next == c1101        ) result = p1692          (parse);     else if (parse.next == h1102        ) result = s1693          (parse);     else if (parse.next == q1103        ) result = g1709          (parse);     else if (parse.next == w1104           ) result = n1707             (parse);     else if (parse.next == y1105            ) result = t1708              (parse);     else if (parse.next == f1106          ) result = o1710            (parse);     else if (parse.next == d1107           ) result = u1711             (parse);     else if (parse.next == l1108            ) result = l1712       (parse);     else if (parse.next == l1109      ) result = t1713        (parse);     else if (parse.next == HOLD                   ) result = genParseHold              (parse);     else if (parse.next == e1110     ) result = z1714       (parse);     else if (parse.next == c1111           ) result = m1721             (parse);     else if (parse.next == n1112         ) result = d1722           (parse);          else if (parse.next == x1114            ) result = e1702              (parse, (nodeId, options) => new g1901          (nodeId, options));     else if (parse.next == u1113     ) result = q1703        (parse, (nodeId, options) => new g1901          (nodeId, options));     else if (parse.next == f1115             ) result = v1704        (parse, (nodeId, options) => new d1897           (nodeId, options));     else if (parse.next == i1116        ) result = v1704        (parse, (nodeId, options) => new k1905      (nodeId, options));     else if (parse.next == b1117        ) result = v1704        (parse, (nodeId, options) => new y1903      (nodeId, options));     else if (parse.next == p1118          ) result = v1704        (parse, (nodeId, options) => new j1899        (nodeId, options));     else if (parse.next == t1119          ) result = v1704        (parse, (nodeId, options) => new p1902        (nodeId, options));     else if (parse.next == d1120        ) result = v1704        (parse, (nodeId, options) => new j1900      (nodeId, options));           else if (parse.next == j1121         ) result = v1715           (parse);     else if (parse.next == x1122             ) result = v1704        (parse, (nodeId, options) => new n1908           (nodeId, options));     else if (parse.next == z1123             ) result = v1704        (parse, (nodeId, options) => new m1906           (nodeId, options));     else if (parse.next == o1124              ) result = v1704        (parse, (nodeId, options) => new s1909            (nodeId, options));     else if (parse.next == a1125             ) result = v1704        (parse, (nodeId, options) => new r1910           (nodeId, options));           else if (parse.next == l1126       ) result = x1716         (parse);     else if (parse.next == m1127           ) result = t1717     (parse, (nodeId, options) => new p1912         (nodeId, options));     else if (parse.next == c1128       ) result = t1717     (parse, (nodeId, options) => new c1917      (nodeId, options));     else if (parse.next == v1129            ) result = t1717     (parse, (nodeId, options) => new t1915          (nodeId, options));     else if (parse.next == r1130   ) result = t1717     (parse, (nodeId, options) => new a1916   (nodeId, options));     else if (parse.next == f1131         ) result = t1717     (parse, (nodeId, options) => new b1913       (nodeId, options));     else if (parse.next == d1132) result = t1717     (parse, (nodeId, options) => new t1914(nodeId, options));       else if (parse.next == k1133            ) result = a1718     (parse);     else if (parse.next == j1134             ) result = q1719          (parse, (nodeId, options) => new s1920          (nodeId, options));     else if (parse.next == r1135             ) result = q1719          (parse, (nodeId, options) => new p1919        (nodeId, options));     else if (parse.next == c1136             ) result = q1719          (parse, (nodeId, options) => new k1921       (nodeId, options));     else if (parse.next == x1137           ) result = r1720             (parse, (nodeId, options) => new k1921       (nodeId, options));      else if (parse.next == z1138          ) result = u1705      (parse);       else if (parse.next == l1143             ) result = o1763         (parse);     else if (parse.next == a1144                   ) result = v1764              (parse);     else if (parse.next == d1145            ) result = n1765        (parse);     else if (parse.next == z1146              ) result = x1766          (parse);     else if (parse.next == d1147         ) result = w1767     (parse);     else if (parse.next == v1148          ) result = k1768      (parse);     else if (parse.next == l1149              ) result = n1769          (parse);     else if (parse.next == f1154              ) result = v1774   (parse);     else if (parse.next == j1155           ) result = r1775   (parse);     else if (parse.next == f1156          ) result = c1776       (parse);     else if (parse.next == i1157         ) result = i1777      (parse);     else if (parse.next == b1158          ) result = w1778       (parse);     else if (parse.next == w1159         ) result = x1779      (parse);     else if (parse.next == m1160          ) result = x1780       (parse);     else if (parse.next == w1150           ) result = t1770       (parse);     else if (parse.next == r1151              ) result = i1771          (parse);     else if (parse.next == n1152               ) result = z1772           (parse);     else if (parse.next == q1153           ) result = l1773       (parse);     else if (parse.next == t1161             ) result = p1781         (parse);     else if (parse.next == q1163               ) result = u1782           (parse);     else if (parse.next == t3504              ) result = k3703          (parse);     else if (parse.next == t1164             ) result = b1783         (parse);     else if (parse.next == y1165              ) result = h1784          (parse);       else if (parse.next == l1168            ) result = s1622        (parse);     else if (parse.next == g1169                  ) result = i1623             (parse);     else if (parse.next == c1170            ) result = n1624        (parse);     else if (parse.next == k1171          ) result = j1625      (parse);     else if (parse.next == w1173         ) result = r1626     (parse);     else if (parse.next == b1172       ) result = a1627    (parse);     else if (parse.next == z1174             ) result = d1628        (parse);     else if (parse.next == m1175      ) result = e1629  (parse);     else if (parse.next == v1176            ) result = n1630        (parse);            else if (parse.next == y1178             ) result = f1665         (parse);     else if (parse.next == l1179                   ) result = p1666              (parse);            else if (parse.next == y1184       ) result = s1670    (parse);     else if (parse.next == a1185             ) result = b1671         (parse);            else if (parse.next == m1187         ) result = h1668     (parse);     else if (parse.next == e1188               ) result = e1669          (parse);            else if (parse.next == i1181           ) result = g1672       (parse);     else if (parse.next == q1182                 ) result = s1673            (parse);            else if (parse.next == m1190     ) result = genParseStrokeSidesValue  (parse);     else if (parse.next == u1191           ) result = genParseStrokeSides       (parse);            else if (parse.next == d1193    ) result = x1675 (parse);     else if (parse.next == f1194          ) result = i1676      (parse);            else if (parse.next == q1196      ) result = r1677   (parse);     else if (parse.next == x1197            ) result = w1678        (parse);            else if (parse.next == b1199     ) result = q1679  (parse);     else if (parse.next == e1200           ) result = i1680       (parse);            else if (parse.next == s1202       ) result = f1681    (parse);     else if (parse.next == p1203             ) result = f1682         (parse);            else if (parse.next == m1205        ) result = p1683     (parse);     else if (parse.next == q1206              ) result = j1684          (parse);      else if (parse.next == s1211      ) result = o1685   (parse);     else if (parse.next == j1212            ) result = n1686        (parse);            else if (parse.next == q1208       ) result = d1687    (parse);     else if (parse.next == t1209             ) result = b1688         (parse);            else if (parse.next == d1216            ) result = a1762        (parse);            else if (parse.next == t1219              ) result = v1723         (parse);          else if (parse.next == y1222                   ) result = q1724              (parse);     else if (parse.next == h1225                ) result = c1725           (parse);     else if (parse.next == r1228                ) result = l1726           (parse);     else if (parse.next == b1237                ) result = n1727           (parse);     else if (parse.next == j1240                   ) result = m1728              (parse);     else if (parse.next == l1243             ) result = e1729         (parse);       else if (parse.next == u1245            ) result = l1730        (parse);     else if (parse.next == l1246                  ) result = a1731             (parse);     else if (parse.next == h1248           ) result = w1732       (parse);     else if (parse.next == b1249      ) result = p1733   (parse);     else if (parse.next == w1250            ) result = j1734        (parse);          else if (parse.next == g1252    ) result = m1735 (parse);     else if (parse.next == x1253          ) result = b1736      (parse);     else if (parse.next == s1255      ) result = p1737   (parse);     else if (parse.next == x1256            ) result = t1738        (parse);     else if (parse.next == w1258    ) result = p1739 (parse);     else if (parse.next == b1259          ) result = v1740      (parse);     else if (parse.next == s1261   ) result = a1741(parse);     else if (parse.next == z1262         ) result = j1742     (parse);      else if (parse.next == w1287    ) result = n3838 (parse);     else if (parse.next == q1286          ) result = u1743      (parse);      else if (parse.next == x1231         ) result = genParseArcPathValue      (parse);     else if (parse.next == v1230               ) result = genParseArcPath           (parse);      else if (parse.next == g1234        ) result = genParseWavePathValue     (parse);     else if (parse.next == x1233              ) result = genParseWavePath          (parse);      else if (parse.next == y1264      ) result = j3839   (parse);     else if (parse.next == p1265            ) result = y1744        (parse);       else if (parse.next == m1267            ) result = s3840        (parse);     else if (parse.next == k1268                  ) result = t1745             (parse);       else if (parse.next == n1270                   ) result = e1746              (parse);     else if (parse.next == c1271                 ) result = v1747            (parse);     else if (parse.next == c1272                  ) result = t1748             (parse);     else if (parse.next == e1273                   ) result = k1749              (parse);      else if (parse.next == SHOW_CENTER            ) result = genParseShowCenter        (parse);     else if (parse.next == j1274             ) result = x1750            (parse);     else if (parse.next == e1275            ) result = t1751    (parse);      else if (parse.next == PATH_LENGTH            ) result = genParsePathLength        (parse);     else if (parse.next == JOIN_PATHS             ) result = genParseJoinPaths         (parse);     else if (parse.next == REORIENT_PATHS         ) result = genParseReorientPaths     (parse);     else if (parse.next == y1278         ) result = h1752     (parse);     else if (parse.next == y1279            ) result = e1753        (parse);     else if (parse.next == v1280                 ) result = p1754            (parse);     else if (parse.next == j1281          ) result = v1755      (parse);     else if (parse.next == ARC_FROM_POINTS        ) result = genParseArcFromPoints     (parse);     else if (parse.next == p1282        ) result = s1756    (parse);     else if (parse.next == p1283      ) result = j1757  (parse);     else if (parse.next == d1284       ) result = genParsePointAlongPath    (parse);     else if (parse.next == o1285  ) result = genParseClosestPointOnPath(parse);     else if (parse.next == REVERSE_PATH           ) result = genParseReversePath       (parse);     else if (parse.next == BLEND_PATH             ) result = genParseBlendPath         (parse);      else if (parse.next == q1276                  ) result = t1759             (parse);     else if (parse.next == n1277            ) result = i1760        (parse);          else if (parse.next == g1293                 ) result = f1761            (parse);     else if (parse.next == EXPORT                 ) result = genParseExport            (parse);       else if (parse.next == m1298             ) result = k1663         (parse);     else if (parse.next == w1299            ) result = f1664        (parse);       else if (parse.next == z1301                ) result = a1660           (parse);     else if (parse.next == v1302          ) result = d1661      (parse);     else if (parse.next == q1303                  ) result = i1662             (parse);      else p953('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);       parse.z1788 = false;       if (result)         return result;     else     {         parse.so++;         return null;     } }    function o1789(parse) {     const type     = parse.move();     const nodeId   = parse.move();     const nodeName = parse.move();           parse.scope.push(nodeId);       if (parse.w4242.find(n => n.nodeId == nodeId))         return [type, nodeId, {nodeName: nodeName}, true];       const options = s1791(parse);      options.nodeName = nodeName;       return [type, nodeId, options, false]; }    function t1790(parse, node = null) {     parse.scope.pop();      if (node)     {         if (isEmpty(parse.scope))             node.topLevel = true;          q949(parse.w4242, node);     } }    function s1791(parse) {     const opt = parseInt(parse.move());      const options =      {         active:       ((opt >>  0) & 1) != 0,         a2997: ((opt >>  1) & 1) != 0,         beforeList:   ((opt >>  2) & 1) != 0,         enabled:      ((opt >>  3) & 1) != 0,         cached:       ((opt >>  4) & 1) != 0,         unknown:      ((opt >>  5) & 1) != 0,         notCondition: ((opt >>  6) & 1) != 0,         r3264:    ((opt >> 20) & 1) != 0,         existing:     ((opt >> 21) & 1) != 0     };      return options; }    function q1792(parse) {     const i3667 = parseInt(parse.move());      if (parse.settings.logRequests)          parse.log += parse.tab + i3667;      return i3667; }    function a1793(parse) {     if (parse.next != PARAM)          return null;              parse.move();      const type = parse.move();            const nodeId  = parse.move();     const f2991 = parse.move();          const param   = new l2048(nodeId, f2991);        q949(parse.n3641, nodeId);       if (parse.settings.logRequests)          t2127(param, type, parse);       return param; }    function h1794(parse) {     const f2991 = parse.move();      if (parse.settings.logRequests)         parse.log += parse.tab + f2991;      return f2991; }


class v2131 {     request;     pos;      so            = 0;     r3646          = 0;        skipNewLine   = false;      loggedNodeIds = [];            constructor(request, pos)     {         this.request = request;         this.pos     = pos;     }       get tab()      {          if (this.skipNewLine)         {             this.skipNewLine = false;             return '';         }         else              return u872 + t870.repeat(Math.max(0, this.r3646));      } }    function log(str) {     p3881.innerHTML = str; }    function y2132(g2133, l111 = null) {     let str = g2133;      if (l111)         str = l111.id + '.' + str;      console.log(         '%c ' + str + ' ',          'background: #fc0; color: #632;'); }    function k2134(str, color = 'white', background = 'red') {     console.log(         '%c ' + str + ' ',          'background: ' + background + '; color: ' + color + ';'); }    function logValueUpdates(z4018, j4019, values) {           let log     = '';     let newLine = true;      if (   z4018  != ''          || j4019 != '')         log = '↓ ' + x2125(z4018) + '.' + x2125(j4019);     else         newLine = false;                 let i    = 0;     let r3646 = 0;      while (i < values.length)     {         const nodeId  = values[i++];         const v4208 = parseInt(values[i++]);          log +=                (newLine ? u872 : '') + t870.repeat(Math.max(0, r3646))             + nodeId;          newLine = true;          r3646++;          for (let j = 0; j < v4208; j++)         {             const index = values[i++];             const type  = values[i++];             const value = values[i++];              log +=                    u872 + t870.repeat(Math.max(0, r3646))                 + index + ' ' + t4209(type, value);         }          r3646--;     }       console.log(         '%c%s',          'background: #e70; color: white;',          log); }    function logObjectUpdates(objects) {     console.log(         '%cobjects',          'background: #07e; color: white;',          objects); }    function logStyleUpdates(styles) {     console.log(         '%cstyles',          'background: #b4d; color: white;',          styles); }    function m2135(pageJson) {     console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;'); }    function d2136(nodeJson) {     console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;'); }    function d2137(c2138) {     let log = 'SAVING ' + c2138.length + ' ' + j4015(c2138.length, 'CONNECTION');      for (const f243 of c2138)         log += '\n' + f243.x2118();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function k2139(c2138) {     let log = 'UPDATING ' + c2138.length + ' ' + j4015(c2138.length, 'SAVED CONNECTION');      for (const f243 of c2138)         log += '\n' + f243.x2118();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function g2140() {     let log =          'UNDO STACK:\n'         + l2885.actions.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #ffd; color: #b80;', log); }    function d2141() {     let log =           'REDO STACK:\n'         + l2885.p2887.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #fff4e8; color: #c64;', log); }


function e2122(parse) {     let log = '';      if (   parse.z4018  != ''          || parse.j4019 != '')         log = '↓ ' + x2125(parse.z4018) + '.' + x2125(parse.j4019);      log += parse.log;      console.log(         '%c%s',          'background: #60aa60; color: #fff',           log); }    function x2123(node, parse, ignore, v4208 = -1) {     parse.log += parse.tab + node.type;     parse.log += r2124(node, ignore);      if (    v4208 > -1         && !ignore)         parse.log += ' ' + v4208; }    function r2124(node, ignore = false) {     return ' '           + x2125(node.nodeId)           + ' ' + x2125(node.nodeName)          + (!ignore             ? h2126(node)             : ''); }    function x2125(nodeId) {     return nodeId == '' ? '\'\'' : nodeId; }    function h2126(node) {     let log = '';      if ( node.options.active      ) log += ' ' + o1304;     if ( node.options.a2997) log += ' ' + u1305;     if ( node.options.beforeList  ) log += ' ' + e1306;     if (!node.options.enabled     ) log += ' ' + c1307;      if (!node.cached              ) log += ' ' + n1308;      return log; }    function t2127(param, type, parse) {     parse.log +=                  parse.tab + PARAM         + ' ' + type          + ' ' + x2125(param.nodeId)          + '.' + x2125(param.f2991); }    function x2128(node, parse) {     parse.log += parse.tab + node.type;     parse.log += r2124(node); }    function w2129(x1035, v4208, j3681, parse, ignore) {     parse.log += parse.tab + w1173;     parse.log += r2124(x1035, ignore);      if (!ignore)     {         parse.log += ' ' + v4208;          if (v4208 == 1)             parse.log += ' ' + j3681;     } }    function u2130(type, val, parse) {     parse.log += parse.tab + type + ' ' + t4209(type, val); }                                           


async function logSavedNode(nodeKey, o4006) {     const log  = v2119(await y1563(nodeKey, false));      if (o4006)     {         console.log(             '%c%s\n%c%s',              'background: #fa24; color: white;',              w1054(nodeKey),              'background: #fa44; color: #edc;',             log);     }     else     {         console.log(             '%c%s\n%c%s',              'background: #fdb; color: black;',              w1054(nodeKey),              'background: #fed; color: black;',             log);     } }    function v2119(json) {     let a4032 = json         .replace('{\n', '')         .replace('\n}', '')          .replace('[\n' + t870, '')         .replace('\n' + t870 + ']', '')          .split(t870 + '"params":\n').join('')           .split('": "').join(': ')         .split('", "').join(': ')          .split(t870 + '"').join(t870)         .split(t870 + t870 + '["').join(t870 + t870)                  .split('",\n').join('\n')         .split('"\n').join('\n')                  .split('"],\n').join('\n');       if (a4032[a4032.length-1] == '"')         a4032 = a4032.substring(0, a4032.length - 1);      if (a4032.substring(a4032.length-2) == '"]')             a4032 = a4032.substring(0, a4032.length - 2);      return a4032; }    function s2120(json) {     let a4032 = json         .replace('{\n', '')         .replace('\n}', '')         .replace('[\n' + t870, '')         .replace('\n' + t870 + ']', '');      return a4032; }    function d2121(f243, o4006) {     const g4210 = i924(f243, true);      if (o4006)     {         console.log(             '%c%s',              'background: #4f44; color: #ded',              g4210);      }     else     {         console.log(             '%c%s',              'background: #cfc; color: black;',              g4210);      } }


  const D65 = [0.95047, 1, 1.08883];    function x31(R, G, B, Y, W, gamma, degamma, regamma, luminance) {     return {             R:         R,         G:         G,         B:         B,          Y:         Y,          W:         W,          a3974:   l32(R, G, B, W),         xyz2lin:   f891(l32(R, G, B, W)),          gamma:     gamma,                  degamma:   degamma,         regamma:   regamma,                  luminance: luminance     }; }   function l32(R, G, B, W) {     const C0 = e33(R);     const C1 = e33(G);     const C2 = e33(B);      const M = [ [ C0[0], C1[0], C2[0] ],                  [ C0[1], C1[1], C2[1] ],                  [ C0[2], C1[2], C2[2] ] ];      const S = b948(W, f891(M));      return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],              [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],              [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ]; }   function e33(c) {     const x = c[0],           y = c[1];      return [x/y, 1, (1-x-y)/y]; } 


const u36 = x31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.212656,      0.715158,      0.072186],       D65,              2.4,                function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },            function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },                function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } ); 


function r66(rgb, amount) {     const hsv = p52(rgb);     hsv[2] *= amount;     return c54(hsv); }    function k67(rgb, amount) {     const hsv = p52(rgb);     hsv[1] *= amount;     return c54(hsv); }    function s68(rgb, amount) {     const hsl = o48(rgb);     hsl[1] *= amount;     return p50(hsl); }


function z51(r, g, b) {     let h, s, v;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      v = max;     s = max == 0 ? 0 : delta / max; 	     if      (max == r) h = 1/6 * (g - b) / delta + 1;        else if (max == g) h = 1/6 * (b - r) / delta + 1/3;      else if (max == b) h = 1/6 * (r - g) / delta + 2/3;   	if (h > 1) h -= 1; 	      return [h, s, v]; }    function p52(rgb) {     return z51(rgb[0], rgb[1], rgb[2]); }    function o53(h, s, v) {     while (h < 0) h++;     h %= 1;      if (s == 0)         return [v, v, v];       h *= 6 - 0.0000001;      let i = Math.floor(h);     let f = h - i; 	     let p = v * (1 - s);     let q = v * (1 - s * f);     let t = v * (1 - s * (1 - f));      switch (i)     {         case 0:  return [v, t, p];         case 1:  return [q, v, p];         case 2:  return [p, v, t];         case 3:  return [p, q, v];         case 4:  return [t, p, v];         default: return [v, p, q];     } }    function c54(hsv) { 	return o53(hsv[0], hsv[1], hsv[2]); }


function c47(r, g, b) {     let h, s, l;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      l = (max + min) / 2;           if (max == min) h = 0;     else if (max == r  ) h = 1/6 * (g - b) / delta + 1;     else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;     else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;           if (max == min) s = 0;     else if (l <= 0.5)   s = delta / (2 * l);     else if (l >  0.5)   s = delta / (2 - 2 * l);      return [h, s, l]; }    function o48(rgb) {     return c47(rgb[0], rgb[1], rgb[2]); }    function s49(h, s, l) {     while (h < 0) h++;     h %= 1;      let q =         l < 0.5         ? l * (1 + s)         : l + s - l * s;      let p = 2 * l - q;      let tr = h + 1/3;     let tg = h;     let tb = h - 1/3;      if (tr < 0) tr += 1; if (tr > 1) tr -= 1;     if (tg < 0) tg += 1; if (tg > 1) tg -= 1;     if (tb < 0) tb += 1; if (tb > 1) tb -= 1;      let r, g, b;      let qp6 = (q - p) * 6;            if (tr <  1/6)				r = p + qp6 * tr;     else if (tr >= 1/6 && tr < 0.5)	r = q;     else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);     else							r = p; 	          if (tg <  1/6)				g = p + qp6 * tg;     else if (tg >= 1/6 && tg < 0.5)	g = q;     else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);     else							g = p;           if (tb <  1/6)				b = p + qp6 * tb;     else if (tb >= 1/6 && tb < 0.5) b = q;     else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);     else							b = p;      return [r, g, b]; }    function p50(hsl) {     return s49(hsl[0], hsl[1], hsl[2]); }


function g59(xyz) {     return b948(xyz, CAT); }    function m60(lms) {     return b948(lms, invCAT); } 


function c69(rgb, cs = u36) {      return z70(degamma(rgb, cs), cs); }        function z70(rgb, cs = u36) {     return b948(rgb, cs.a3974); }            function w71(xyz, cs = u36) {     return regamma(s72(xyz, cs), cs); }    function s72(xyz, cs = u36) {     return b948(xyz, cs.xyz2lin); }


function d3976(rgb, cs = u36) {     return d3978(c69(rgb, cs), cs.W); }    function c3977(luv, cs = u36) {     return w71(h3979(luv, cs.W), cs); }    function d3978(xyz, W = u36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = cube(6/29);     const k = cube(29/3);      const yw = y / W[1];      let l =          yw > e         ? 116 * Math.cbrt(yw) - 16         : k * yw;      const u_ = 4*x / (x + 15*y + 3*z);     const v_ = 9*y / (x + 15*y + 3*z);          const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const u = 13*l * (u_ - uw);     const v = 13*l * (v_ - vw);      return [         l / 100,          u / 100,          v / 100]; }    function h3979(luv, W = u36.W) {     let l = luv[0] * 100,          u = luv[1] * 100,          v = luv[2] * 100;      const e = cube(6/29);         const k = cube(29/3);      const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const y =          l > e*k         ? cube((l + 16) / 116)         : l / k;          const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;     const b = -5 * y;     const c = -1/3;     const d =  y * (39*l / nozero(v + 13*l*vw) - 5);      const x = (d - b) / nozero(a - c);      const z = x*a + b;      return [x, y, z]; }


function r55(rgb, cs = u36) {     return t57(c69(rgb, cs), cs.W); }    function s56(lab, cs = u36) {     return w71(o58(lab, cs.W), cs); }    function t57(xyz, W = u36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = 0.008856;      const k = 903.3;          let xw = x / W[0];     let yw = y / W[1];     let zw = z / W[2];      xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;     yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;     zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;       const l = (1.16 * yw) - 0.16;     const a = 5 * (xw - yw);     const b = 2 * (yw - zw);      return [l, a, b]; }    function o58(lab, W = u36.W) {     const l = lab[0],            a = lab[1],            b = lab[2];      const e = 0.008856 / 100;      const k = 903.3    / 100;       const yw = (l + 0.16)/1.16;     const xw = a/5 + yw;     const zw = yw - b/2;      let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;     let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;     let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;      x *= W[0];     y *= W[1];     z *= W[2];       return [x, y, z]; }


function w3980(rgb, cs = u36) {     return t3981(rgb[0], rgb[1], rgb[2], cs); }    function t3981(r, g, b, cs = u36)  {     return x3983(x3982(r, g, b, cs)); }    function x3982(r, g, b, cs = u36)  {     r = cs.degamma(r);     g = cs.degamma(g);     b = cs.degamma(b);      return [         0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b, 	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b, 	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ]; }            function x3983(lms)  {     const l = Math.cbrt(lms[0]);     const m = Math.cbrt(lms[1]);     const s = Math.cbrt(lms[2]);      const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;     const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;     const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;      return [         l_,         a_,          b_ ]; }            function g3984(lab, cs = u36) {     return l3988(m3986(lab), cs); }    function y3985(l, a, b, cs = u36)  {     return g3984([l, a, b], cs); }    function m3986(lab) {     return q3987(lab[0], lab[1], lab[2]); }    function q3987(l, a, b)  {     return [         l + 0.3963377774 * a + 0.2158037573 * b,         l - 0.1055613458 * a - 0.0638541728 * b,         l - 0.0894841775 * a - 1.2914855480 * b ]; }    function l3988(lms, cs = u36)  {     const l = cube(lms[0]);     const m = cube(lms[1]);     const s = cube(lms[2]);  	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s; 	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s; 	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;      return [         cs.regamma(r),         cs.regamma(g),         cs.regamma(b) ]; }


const q65 = 0.89;   function n63(opp)  {                const l = opp[0],            a = opp[1],            b = opp[2];      const h = Math.atan2(b, a);     const c = Math.sqrt(a*a + b*b);      return [h, c, l]; }    function o64(pol)  {                const h = pol[0],            c = pol[1],            l = pol[2];      const a = c * Math.cos(h);     const b = c * Math.sin(h);      return [l, a, b]; }


function k34(hcl, cs = u36) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];       return g3984(o64(hcl), cs); }        function d35(h, c, l, cs = u36) {     return d35([h, c, l], cs); }                    function y37(rgb, cs = u36) {     const hcl = n63(w3980(rgb, cs));      hcl[0] /= Tau;     hcl[1] /= nozero(hcl[2]);      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function z38(r, g, b, cs = u36) {     return y37([r, g, b], cs); }    function n39(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return o64(hcl); }    function f40(hcl, cs = u36) {     return s56(n39(hcl), cs); }    function e41(lab) {     let hcl = n63(lab);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function g42(rgb, cs = u36) {     return e41(r55(rgb, cs)); }    function z43(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return o64(hcl); }    function o44(hcl, cs = u36) {     return c3977(z43(hcl), cs); }    function n45(luv) {     let hcl = n63(luv);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function r46(rgb, cs = u36) {     return n45(d3976(rgb, cs)); }


function i61(rgb) {     const p3 =          [ [ 0.8225, 0.1774, 0      ],           [ 0.0332, 0.9669, 0      ],           [ 0.0171, 0.0724, 0.9108 ] ];      rgb = degamma(rgb);      return regamma(g1039(p3, rgb)); }    function k62(rgb)  {     const invp3 =          [ [ 1.2249, -0.2247, 0      ],           [-0.0420,  1.0419, 0      ],           [-0.0197, -0.0786, 1.0979 ] ];        rgb = g1039(invp3, degamma(rgb));        return regamma(rgb); }


const t131 =  [     ['hex',   'Hex'   ],     ['rgb',   'RGB'   ],      ['hsv',   'HSV'   ],      ['hsl',   'HSL'   ],      ['hclok', 'HCL/ok'],     ['hclab', 'HCL/ab'],     ['hcluv', 'HCL/uv'],     ['oklab', 'okLab' ],     ['lab',   'Lab'   ],     ['luv',   'Luv'   ] ];    class v132 {     hex   = Object.freeze(0);     rgb   = Object.freeze(1);     hsv   = Object.freeze(2);     hsl   = Object.freeze(3);     hclok = Object.freeze(4);     hclab = Object.freeze(5);     hcluv = Object.freeze(6);     oklab = Object.freeze(7);     lab   = Object.freeze(8);     luv   = Object.freeze(9); }    class Color extends Float32Array {     get r() { return this[0]; }     get g() { return this[1]; }     get b() { return this[2]; }     get a() { return this[3]; }     get s() { return this[4]; }      set r(r) { this[0] = r; }     set g(g) { this[1] = g; }     set b(b) { this[2] = b; }     set a(a) { this[3] = a; }     set s(s) { this[4] = s; }        constructor(c = null)     {         super(5);           if (c)         {             this.r = c.r;             this.g = c.g;             this.b = c.b;             this.a = c.a;             this.s = c.s;         }         else         {             this.r = 0;             this.g = 0;             this.b = 0;             this.a = 0;             this.s = v132.rgb;         }     } }


const m76 = 0.001;    function m146(rgb) {     const _space = 'rgb';      return [         _space,          j4175(rgb[0], _space, 0),          j4175(rgb[1], _space, 1),          j4175(rgb[2], _space, 2) ];  }    function y147(space, c1, c2, c3) {     const _space = g133(space.value);      return [         _space,          j4175(c1.value, _space, 0),          j4175(c2.value, _space, 1),          j4175(c3.value, _space, 2) ];  }    function y148(c) {     return isNaN(c[1])         || isNaN(c[2])         || isNaN(c[3]); }    function t149(col, lim = m76) {     return x75(l4194(col), lim); }    function o150(col, lim = m76) {     return e78(l4194(col), lim); }


const rgb_NaN = [     Number.NaN,     Number.NaN,     Number.NaN ];  const rgba_NaN = [     Number.NaN,     Number.NaN,     Number.NaN,     Number.NaN ];   const rgbInvalid  = [0xff, 0, 0xff]; const rgbaInvalid = [0xff, 0, 0xff, 0xff];   const s3813 = Object.freeze([     'rgb',     Number.NaN,     Number.NaN,     Number.NaN ]);            const CAT = [[ 0.7328, 0.4296, -0.1624],              [-0.7036, 1.6975,  0.0061],              [ 0.0030, 0.0136,  0.9834]];  const invCAT = f891(CAT);   const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],             [ 0.0329845436, 0.9293118715,  0.0361456387 ],             [ 0.0482003018, 0.2643662691,  0.6338517070 ]];  const invM1 = f891(M1);    function k73(rgb)  {     return isNaN(rgb[0])         || isNaN(rgb[1])         || isNaN(rgb[2]); }    function w74(rgba)  {     return isNaN(rgba[0])         || isNaN(rgba[1])         || isNaN(rgba[2])         || isNaN(rgba[3]); }    function x75(rgb, lim = m76) {     return rgb[0] > -lim && rgb[0] < 1 + lim          && rgb[1] > -lim && rgb[1] < 1 + lim          && rgb[2] > -lim && rgb[2] < 1 + lim; }    function g77(rgba, lim = m76) {     return rgba[0] > -lim && rgba[0] < 1 + lim          && rgba[1] > -lim && rgba[1] < 1 + lim          && rgba[2] > -lim && rgba[2] < 1 + lim         && rgba[3] > -lim && rgba[3] < 1 + lim; }    function e78(rgb, lim = m76) {     return !k73  (rgb)         &&  x75(rgb, lim); }    function c79(rgba, lim = m76) {     return !w74  (rgba)         &&  g77(rgba, lim); }    function l80(rgb) {     return [         Math.min(Math.max(0, rgb[0]), 1),         Math.min(Math.max(0, rgb[1]), 1),         Math.min(Math.max(0, rgb[2]), 1) ]; }    function f81(z82, z83, t) {     return [ x1035(z82[0], z83[0], t),              x1035(z82[1], z83[1], t),              x1035(z82[2], z83[2], t) ]; }    function m84(k3801, rgba2, t) {     return [ x1035(k3801[0], rgba2[0], t),              x1035(k3801[1], rgba2[1], t),              x1035(k3801[2], rgba2[2], t),              x1035(k3801[3], rgba2[3], t) ]; }    function j85(z82, z83) {     return [ z82[0] + z83[0],              z82[1] + z83[1],              z82[2] + z83[2] ]; }    function rgbaAdd(k3801, rgba2) {     return [ k3801[0] + rgba2[0],              k3801[1] + rgba2[1],              k3801[2] + rgba2[2],              k3801[3] + rgba2[3] ]; }    function i86(z82, z83) {     return [ z82[0] - z83[0],              z82[1] - z83[1],              z82[2] - z83[2] ]; }    function w87(rgb, s) {     return [ rgb[0] * s,              rgb[1] * s,              rgb[2] * s ]; }    function rgbaMuls(rgba, s) {     return [ rgba[0] * s,              rgba[1] * s,              rgba[2] * s,              rgba[3] * s ]; }    function c88(z82, z83) {     return [ (z82[0] + z83[0]) / 2,              (z82[1] + z83[1]) / 2,              (z82[2] + z83[2]) / 2 ]; }    function t89(z82, z83) {     return [ Math.max(z82[0], z83[0]),              Math.max(z82[1], z83[1]),              Math.max(z82[2], z83[2]) ]; }    function k90(col, p) {     return [         Math.pow(col[0], p),          Math.pow(col[1], p),          Math.pow(col[2], p) ] }    function b91(cones) {     return cones.l == 1          && cones.m == 1          && cones.s == 1; }    function k92(rgb) {     return '{' + Math.round(rgb[0] * 255) + ', '                + Math.round(rgb[1] * 255) + ', '                + Math.round(rgb[2] * 255) + '}'; }    function t93(r, g, b, a) {     if (a !== undefined)     {         return 'rgba('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ', '             + a + ')';     }     else     {         return 'rgb('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ')';     } }    function b94(r, g, b) {     return t93(r, g, b, 1); }    function x95(rgb) {     return t93(rgb[0], rgb[1], rgb[2], 1); }    function u96(r, g, b, a) {     return t93(r, g, b, a); }    function t97(rgba) {     return t93(rgba[0], rgba[1], rgba[2], rgba[3]); }    function l98(rgb, a = 1) {     return t93(rgb[0], rgb[1], rgb[2], a); }    function x99(rgb_) {     return rgb_.length == 3          ? [...rgb_, 1]          : rgb_; }    function v100(rgb, a = 1) {     return [rgb[0], rgb[1], rgb[2], a]; }    function g101(rgb, threshold = 0.71) {     return y37(rgb)[2] < threshold; }    function j102(l103, s104) {     const d0 = s104[0] - l103[0];     const d1 = s104[1] - l103[1];     const d2 = s104[2] - l103[2];      return Math.sqrt(d0*d0 + d1*d1 + d2*d2); }    function t105(rgba, v) {     return [         rgba[0] * v,         rgba[1] * v,         rgba[2] * v,         rgba[3] * v ]; }    function g106(rgba, v) {     return [         rgba[0] / v,         rgba[1] / v,         rgba[2] / v,         rgba[3] / v ]; }    function e107(l103, s104) {     return Math.max(Math.max(Math.max(         Math.abs(s104[0] - l103[0]),         Math.abs(s104[1] - l103[1])),         Math.abs(s104[2] - l103[2]))); }    function r108(z82, z83) {     return Math.abs(z82[0] - z83[0]) < m76         && Math.abs(z82[1] - z83[1]) < m76         && Math.abs(z82[2] - z83[2]) < m76;         }    function e109(style)  {     f4014.fillStyle = style;     f4014.fillRect(0, 0, 1, 1);      return g106(f4014.getImageData(0, 0, 1, 1).data, 0xFF); }    function e110(l111, style)  {     f4014.fillStyle = f1499(l111, style);     f4014.fillRect(0, 0, 1, 1);      return g106(f4014.getImageData(0, 0, 1, 1).data, 0xFF); }    function o112(rgb, opacity = 1) {     return !k73(rgb)            ? (opacity >= 0.5                ? (g101(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])                : (o4006 ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))            : (o4006 ? k2441 : a2440); }    function l113(rgb) {     return !k73(rgb)          ? (g101(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])            : (o4006 ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);   }    function v114(h115) {     let l3848,          s3849;                   const t3850 = l113(h115);            if (!k73(h115))     {         const l3851 = y37(h115);          const r3852 = [...l3851];         const o3853 = [...l3851];          r3852[0] += 1/12;  if (r3852[0] > 1) r3852[0] -= 1;         o3853[0] -= 1/12;  if (o3853[0] < 0) o3853[0] += 1;           const g3854 = v100(z123(k34(r3852)), 0.35);         const h3855 = v100(z123(k34(o3853)), 0.35);          const factor   = e119(h115);          const colWarn1 = m84(t3850, g3854, factor);         const colWarn2 = m84(t3850, h3855, factor);                  l3848     = t97(colWarn1);         s3849     = t97(colWarn2);     }     else     {         l3848 = t97(t3850);         s3849 = t97(t3850);     }       return [l3848,              s3849]; }    function i116(i, l117, b118) {     return 'repeating-linear-gradient('             + '-45deg, '             + 'transparent 0 ' + i   + 'px,'              +  l117 + ' '    + i   + 'px ' + i*2 +'px,'             + 'transparent '   + i*2 + 'px ' + i*3 +'px,'             +  b118 + ' '    + i*3 + 'px ' + i*4 +'px)'; }    function e119(h115) {     let dr, dg, db;      if (h115[0] < 0) dr = -h115[0]; else if (h115[0] > 1) dr = h115[0] - 1; else dr = 0;     if (h115[1] < 0) dg = -h115[1]; else if (h115[1] > 1) dg = h115[1] - 1; else dg = 0;     if (h115[2] < 0) db = -h115[2]; else if (h115[2] > 1) db = h115[2] - 1; else db = 0;          const d   = [dr, dg, db].sort()[1];     const avg = (dr + dg + db) / 3;      const factor = Math.min((d + avg) / 2, 1);                                                              return factor; }    function h120(u121) {     let d3856 = [...u121];              const factor = e119(u121);      if (factor > 0)     {         const hcl = y37(z123(u121));         hcl[1] /= 2;                   d3856 = f81(u121, z129(k34(hcl)), factor);     }      return d3856; }    function i122(rgba) {     return !w74(rgba)          ? (g101(rgba)  ? '#ffffff29' : '#00000022')          : (o4006 ? '#ffffff08' : '#00000006');  }    function z123(s124) {     const rgb = [...s124];      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function y125(val) {     return Math.min(Math.max(0, val), 1); }    function l126(z127, j128, val) {     const col = [...z127];     col[j128] = val;     return col; }    function z129(rgb) {     let hcl = y37(rgb);      let g3857 = 10000;      while (!x75(k34(hcl))          && hcl[1] > 0.001          && g3857-- > 0)         hcl[1] -= 0.001;      rgb = k34(hcl);      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function d130(rgba) {     if (!w74(rgba))         return 'transparent';     else     {         return o4006             ? 'rgba(56, 56, 56, 0.95)'             : 'rgba(255, 255, 255, 0.95)';     } }


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/
  const e135 = g59(z70([1, 1, 1])); const v136 = g59(z70([0, 0, 1])); const o137 = g59(z70([1, 0, 0]));  const h138 = (e135[2]*v136[0] - v136[2]*e135[0]) / (e135[2]*v136[1] - v136[2]*e135[1]); const t139 = (e135[1]*v136[0] - v136[1]*e135[0]) / (e135[1]*v136[2] - v136[1]*e135[2]);  const c140 = (e135[2]*v136[1] - v136[2]*e135[1]) / (e135[2]*v136[0] - v136[2]*e135[0]); const d141 = (e135[0]*v136[1] - v136[0]*e135[1]) / (e135[0]*v136[2] - v136[0]*e135[2]);  const f142 = (e135[1]*o137[2] - o137[1]*e135[2]) / (e135[1]*o137[0] - o137[1]*e135[0]); const x143 = (e135[0]*o137[2] - o137[0]*e135[2]) / (e135[0]*o137[1] - o137[0]*e135[1]);  const o144 = e135[0] / e135[2]; const y145 = e135[1] / e135[2];   // this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
    const l3858 = 0.88;   function h134(rgb, l, m, s, cs = u36) {     if (   l == 0         && m == 0         && s == 0)     {                   const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          rgb = [a, a, a];     }     else     {         const xyz = c69(rgb, cs);         const lms = g59(xyz);          const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          const lm = Math.min(l + m, 1);           const lms_ = [             lms[0] + x1035(l3858 * (o144*lms[2] - lms[0]), (1 - l) * ((h138*lms[1] + t139*lms[2]) - lms[0]), lm),             lms[1] + x1035(l3858 * (y145*lms[2] - lms[1]), (1 - m) * ((c140*lms[0] + d141*lms[2]) - lms[1]), lm),             lms[2] + x1035(0,                     x1035(s, 1 - s, lm) * ((f142*lms[0] + x143*lms[1]) - lms[2]), lm) ];          const xyz_ = m60(lms_);               rgb  = w71(xyz_, cs);           let bm_ = r55(rgb, cs);         bm_[0] = x1035(a, bm_[0], lm);         rgb = s56(bm_, cs);                   rgb = f81(             [a, a, a],              rgb,              Math.min(s + lm, 1));     }           return rgb; }


function j151(rgb) {     let hex =           Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function r152(rgba) {     let hex =           Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function g153(hex)  {     return hex.indexOf(d964) > -1             ? rgb_NaN             : a155(hex); }    function p154(hex)  {     return hex.indexOf(d964) > -1             ? rgba_NaN             : x156(hex); }    function a155(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgb = [];      if (hex.length >= 6)     {         rgb[0] = parseInt(hex.slice(0, 2), 16);          rgb[1] = parseInt(hex.slice(2, 4), 16);          rgb[2] = parseInt(hex.slice(4, 6), 16);      }     else if (hex.length >= 3)     {         rgb[0] = parseInt(hex[0], 16) * 0x11;          rgb[1] = parseInt(hex[1], 16) * 0x11;          rgb[2] = parseInt(hex[2], 16) * 0x11;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgb[0] = v;          rgb[1] = v;          rgb[2] = v;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgb[0] = v * 0x11;          rgb[1] = v * 0x11;          rgb[2] = v * 0x11;      }     else if (hex.length == 0)     {         rgb[0] = 0;          rgb[1] = 0;          rgb[2] = 0;              }       rgb[0] /= 0xff;     rgb[1] /= 0xff;     rgb[2] /= 0xff;           return rgb; }    function x156(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgba = [];      if (hex.length >= 8)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = parseInt(hex.slice(6, 8), 16);      }     else if (hex.length >= 6)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = 0xff;      }     else if (hex.length >= 4)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = parseInt(hex[3], 16) * 0x11;      }     else if (hex.length == 3)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgba[0] = v;          rgba[1] = v;          rgba[2] = v;          rgba[3] = 0xff;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgba[0] = v * 0x11;          rgba[1] = v * 0x11;          rgba[2] = v * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 0)     {         rgba[0] = 0;          rgba[1] = 0;          rgba[2] = 0;                  rgba[3] = 0;      }       rgba[0] /= 0xff;     rgba[1] /= 0xff;     rgba[2] /= 0xff;     rgba[3] /= 0xff;       return rgba; }


function k157(t158, t159) {     if (    k73  (t158)         || !x75(t158))         return Number.NaN;      const b164 = u36.luminance(t158);     const  l165 = u36.luminance(t159);      return (         l165 > b164         ? ( l165 + 0.05) / (b164 + 0.05)         : (b164 + 0.05) / ( l165 + 0.05)); }    function h160(ratio) {          if (ratio >= 7  ) return 'AAA';     else if (ratio >= 4.5) return 'AA';     else if (ratio >= 3  ) return 'AA<sub>L</sub>';     else                   return ''; }    function h161(t158, t159) {     if (!e78(t158))         return Number.NaN;      return r163(         v162(t158),         v162(t159)); }    // I copied the code below from https://github.com/Myndex/s4122-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
  const d4102     = 2.4;          const d4103        = 0.2126729,        z4104        = 0.7151522,        m4105        = 0.0721750;      const y4106      = 0.56,        f4107     = 0.57,       u4108      = 0.62,       h4109       = 0.65;      const l4110     = 0.022,       z4111     = 1.414,        x4112    = 1.14,       q4113    = 1.14,       h4114 = 0.035991,       p4115 = 0.035991,       t4116 = 27.7847239587675,       g4117 = 27.7847239587675,       f4118 = 0.027,       k4119 = 0.027,       f4120      = 0.001,       r4121   = 0.0005;    function v162(rgb)  {                     return d4103 * Math.pow(rgb[0], d4102)           + z4104 * Math.pow(rgb[1], d4102)          + m4105 * Math.pow(rgb[2], d4102); }    function r163(b164, l165) {     let s4122           = 0;      let d4123 = 0;       b164 =          b164 > l4110          ? b164          : b164 + Math.pow(l4110 - b164, z4111);              l165 =          l165 > l4110          ? l165          : l165 + Math.pow(l4110 - l165, z4111);      if (Math.abs(l165 - b164) < r4121)           return 0;        if (l165 > b164)      {           s4122 = (Math.pow(l165, y4106) - Math.pow(b164, f4107)) * x4112;          d4123 =              s4122 < f4120              ? 0              : s4122 < h4114               ? s4122 - s4122 * t4116 * f4118                : s4122 - f4118;     }      else      {           s4122 = (Math.pow(l165, h4109) - Math.pow(b164, u4108)) * q4113;          d4123 =              s4122 > -f4120              ? 0              : s4122 > -p4115                ? s4122 - s4122 * g4117 * k4119                : s4122 + k4119;     }       return d4123 * 100; }


function g133     (index) { return t131[index][0]; } function n4124(space) { return t131.findIndex(s => s[0] == space); }  function v4125(parse = null) {      const set = parse ? parse.settings : settings;      return set.showAllColorSpaces             ? t131.length         : t131.length - 5;  }    const r4126  = [255, 255, 255]; const r4127  = [360, 100, 100]; const q4128  = [360, 100, 100]; const j4129  = [100, 100, 100];      const m4130   = [255, 255, 255];    const d4131   = [360, 100, 100];   const z4132 = [360, 50,  100]; const q4133 = [360, 400, 100]; const d4134 = [360, 330, 100];     const b4135 = [100,  30,  30]; const g4136   = [100, 100, 100]; const y4137   = [100, 150, 150];     function o4138(space) {     switch (space)     {         case 'hex':         case 'rgb':   return r4126;          case 'hsv':         case 'hsl':   return r4127;          case 'hclok':         case 'hclab':         case 'hcluv': return q4128;          case 'oklab':           case 'lab':               case 'luv':   return j4129;                     default:      p953('invalid color factor from space \''+space+'\''); break;     } }    function g4139(col, space) {     let scale;      switch (space)     {         case 'hex':             case 'rgb':   scale = m4130;   break;          case 'hsv':             case 'hsl':   scale = d4131;   break;          case 'hclok': scale = z4132; break;         case 'hclab': scale = q4133; break;         case 'hcluv': scale = d4134; break;          case 'oklab': scale = b4135; break;         case 'lab':   scale = g4136;   break;         case 'luv':   scale = y4137;   break;     }      return [         col[0] * scale[0],         col[1] * scale[1],         col[2] * scale[2] ]; }    function x4140(rgb) {     return [ rgb[0] / 255,              rgb[1] / 255,              rgb[2] / 255 ]; }    function w4141(rgb) {     return [ Math.round(rgb[0] * 255),              Math.round(rgb[1] * 255),              Math.round(rgb[2] * 255) ]; }    function l4142(node, space) {     switch (space)     {         case 'hex':   m4144   (node); break;         case 'rgb':   b4145   (node); break;          case 'hsv':   k4146   (node); break;         case 'hsl':   x4147   (node); break;          case 'hclok': o4148 (node); break;         case 'hclab': b4149 (node); break;         case 'hcluv': v4150 (node); break;          case 'oklab': v4151 (node); break;         case 'lab':   c4152   (node); break;         case 'luv':   h4153   (node); break;     }      node.q4143(); }    function m4144  (node) { d4154   (node); u4164(node); } function b4145  (node) { d4154   (node);                        }  function k4146  (node) { m4155   (node, 'V');                   } function x4147  (node) { m4155   (node, 'L');                   }               function o4148(node) { f4156(node);                        } function b4149(node) { z4157(node);                        } function v4150(node) { p4158(node);                        }               function v4151(node) { e4159 (node, 'a', 'b');              } function c4152  (node) { v4160   (node, 'a', 'b');              } function h4153  (node) { g4161   (node, 'u', 'v');              }       function d4154(node) {     l4163(node,          'R', 0, m4130[0], '', false,          'G', 0, m4130[1],          'B', 0, m4130[2]);        node.n4168.m4269[0].min =      node.f4169.m4269[0].min =      node.i4170.m4269[0].min = Number.MIN_SAFE_INTEGER;       node.n4168.m4269[0].max =      node.f4169.m4269[0].max =      node.i4170.m4269[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);     }    function m4155(node, v_or_l)  {      l4163(node,          'H',    0, d4131[0], '°', true,           'S',    0, d4131[1],          v_or_l, 0, d4131[2]);        node.n4168.m4269[0].n811 = -4;      node.f4169.m4269[0].min =      node.i4170.m4269[0].min = Number.MIN_SAFE_INTEGER;       node.f4169.m4269[0].max =      node.i4170.m4269[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function switchToHclControls(node, scale)  {      l4163(node,          'H', 0, scale[0], '°', true,           'C', 0, scale[1],          'L', 0, scale[2]);        node.n4168.m4269[0].n811 = -4;      node.f4169.m4269[0].min =      node.i4170.m4269[0].min = Number.MIN_SAFE_INTEGER;       node.f4169.m4269[0].max =      node.i4170.m4269[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function f4156(node) { switchToHclControls(node, z4132); } function z4157(node) { switchToHclControls(node, q4133); } function p4158(node) { switchToHclControls(node, d4134); }    function o4162(node, c2, c3, scale) {      l4163(node,          'L', 0,        scale[0], '', false,           c2, -scale[1], scale[1],          c3, -scale[2], scale[2]);        showRgbControlHex(node, false);  }    function e4159(node) { o4162(node, 'a', 'b', b4135); } function v4160  (node) { o4162(node, 'a', 'b', g4136  ); } function g4161  (node) { o4162(node, 'u', 'v', y4137  ); }    function showRgbControlHex(node, show) {     node.n4168.m4269[0].m4000 = show;     node.f4169.m4269[0].m4000 = show;     node.i4170.m4269[0].m4000 = show; }    function l4163(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max) {     h4165(node);      node.n4168.s2954(c1, false);      node.f4169.s2954(c2, false);      node.i4170.s2954(c3, false);      node.n4168.m4269[0].i809 = c1wrap;     node.n4168.m4269[0].setSuffix(c1suffix, c1suffix != '');      node.n4168.m4269[0].l3121(c1min);      node.f4169.m4269[0].l3121(c2min);     node.i4170.m4269[0].l3121(c3min);          node.n4168.m4269[0].h3122(c1max);      node.f4169.m4269[0].h3122(c2max);      node.i4170.m4269[0].h3122(c3max);           node.n4168.c2833();     node.f4169.c2833();     node.i4170.c2833();      node.n4168.m4269[0].n811 = 0; }    function u4164(node) {     g4167(node);      e1504(node.n4168.div, node.v4171);     e1504(node.f4169.div, node.v4171);     e1504(node.i4170.div, node.v4171);              i1503(node.r4172.div, node.v4171); }    function z4166(node) {     g4167(node);      e1504(node.n4168.div,     node.v4171);     e1504(node.f4169.div,     node.v4171);     e1504(node.i4170.div,     node.v4171);          e1504(node.r4172.div, node.v4171); }    function g4167(node) {     for (let i = node.inputs.length-1; i >= 2; i--)         if (node.inputs[i].connected)             a2599(node.inputs[i]);      for (let i = node.outputs.length-1; i >= 2; i--)         for (const input of node.outputs[i].z4173)             a2599(input); }    function h4165(node) {     e1504(node.r4172.div, node.v4171);      i1503(node.n4168.div, node.v4171);     i1503(node.f4169.div, node.v4171);     i1503(node.i4170.div, node.v4171); }    function m146(rgb) {     return [        'rgb',         rgb[0],         rgb[1],         rgb[2] ]; }    function j4175(value, space, j128) {     switch (space)     {         case 'hex':         case 'rgb':   return g4176(value, j128);          case 'hsv':            case 'hsl':   return b4177 (value, j128);          case 'hclok':          case 'hclab':          case 'hcluv': return l4179 (value, j128);          case 'oklab':           case 'lab':             case 'luv':   return r4178 (value, j128);     } }    function g4176(value, j128) {     switch (j128)     {         case 0: return value / r4126[0];         case 1: return value / r4126[1];          case 2: return value / r4126[2];     } }    function b4177(value, j128) {     switch (j128)     {         case 0: return value / r4127[0];         case 1: return value / r4127[1];          case 2: return value / r4127[2];     } }    function r4178(value, j128) {     switch (j128)     {         case 0: return value / j4129[0];         case 1: return value / j4129[1];          case 2: return value / j4129[2];     } }    function l4179(value, j128) {     switch (j128)     {         case 0: return value / q4128[0];         case 1: return value / q4128[1];          case 2: return value / q4128[2];     } }    function k4180(color) {     return u4181(         color[0],          color[1],          color[2],          color[3]) }    function u4181(space, c1, c2, c3) {     switch (space)     {         case 'hex':         case 'rgb':   return d4182(c1, c2, c3);          case 'hsv':            case 'hsl':   return p4183(c1, c2, c3);          case 'hclok':          case 'hclab':          case 'hcluv': return o4184(c1, c2, c3);          case 'oklab':          case 'lab':          case 'luv':   return q4185(c1, c2, c3);     } }    function d4182(c1, c2, c3) {     return [         c1 / r4126[0],          c2 / r4126[1],          c3 / r4126[2]]; }    function p4183(c1, c2, c3) {     return [         c1 / r4127[0],          c2 / r4127[1],          c3 / r4127[2]]; }    function o4184(c1, c2, c3) {     return [         c1 / q4128[0],          c2 / q4128[1],          c3 / q4128[2]]; }    function q4185(c1, c2, c3) {     return [         c1 / j4129[0],          c2 / j4129[1],          c3 / j4129[2]]; }    function b4186(color) {     switch (color[0])     {         case 'hex':         case 'rgb':   return s4187(         color[1], color[2], color[3]);          case 'hsv':   return n4188('hsv',   color[1], color[2], color[3]);         case 'hsl':   return n4188('hsl',   color[1], color[2], color[3]);          case 'hclok': return q4189('hclok', color[1], color[2], color[3]);         case 'hclab': return q4189('hclab', color[1], color[2], color[3]);         case 'hcluv': return q4189('hcluv', color[1], color[2], color[3]);          case 'oklab': return v4190('oklab', color[1], color[2], color[3]);         case 'lab':   return v4190('lab',   color[1], color[2], color[3]);         case 'luv':   return v4190('luv',   color[1], color[2], color[3]);     } }    function s4187(c1, c2, c3) {     return [        'rgb',         c1 * r4126[0],          c2 * r4126[1],          c3 * r4126[2] ]; }    function n4188(space, c1, c2, c3) {     return [         space,         c1 * r4127[0],          c2 * r4127[1],          c3 * r4127[2] ]; }    function q4189(space, c1, c2, c3) {     return [         space,         c1 * q4128[0],          c2 * q4128[1],          c3 * q4128[2] ]; }    function v4190(space, c1, c2, c3) {     return [         space,         c1 * j4129[0],          c2 * j4129[1],          c3 * j4129[2] ]; }    function f3204(node, color) {     const n3205 = g133(node.k3200.value);     node.f3198   = r4195(color, n3205);      node.y3484(node.f3198); }    function h4191(space) {     switch (space)     {         case 'hex':         case 'rgb':   return r4126;          case 'hsv':            case 'hsl':   return r4127;          case 'hclok':          case 'hclab':          case 'hcluv': return q4128;          case 'oklab':          case 'lab':          case 'luv':   return j4129;     }     }    function i4192(space) {     switch (space)     {         case 'hex':         case 'rgb':   return m4130;          case 'hsv':            case 'hsl':   return d4131;          case 'hclok': return z4132;         case 'hclab': return q4133;         case 'hcluv': return d4134;          case 'oklab': return b4135;         case 'lab':   return g4136;         case 'luv':   return y4137;     }     }


function k4193(color) {     return [         color[1],          color[2],          color[3]]; }    function l4194(color) {     const col = k4193(color);      switch (color[0])     {         case 'hex':         case 'rgb':   return           col;          case 'hsv':   return c54  (col);         case 'hsl':   return p50  (col);          case 'hclok': return k34(col);         case 'hclab': return f40(col);         case 'hcluv': return o44(col);          case 'oklab': return g3984(col);         case 'lab':   return s56  (col);         case 'luv':   return c3977  (col);     } }    function r4195(color, n3205) {     switch (n3205)     {         case 'hex':             case 'rgb':   return h4196    (color);          case 'hsv':   return a4197    (color);         case 'hsl':   return v4198    (color);          case 'hclok': return k4202  (color);         case 'hclab': return i4203  (color);         case 'hcluv': return s4204  (color);          case 'oklab': return f4199(color);         case 'lab':   return c4200    (color);         case 'luv':   return e4201    (color);     } }    function h4196(z4205) {     const col = k4193(z4205);      let rgb;      switch (z4205[0])     {         case 'hex':         case 'rgb':   rgb =           col;  break;          case 'hsv':   rgb = c54  (col); break;         case 'hsl':   rgb = p50  (col); break;          case 'hclok': rgb = k34(col); break;         case 'hclab': rgb = f40(col); break;         case 'hcluv': rgb = o44(col); break;          case 'oklab': rgb = g3984(col); break;         case 'lab':   rgb = s56  (col); break;         case 'luv':   rgb = c3977  (col); break;     }      return m146(rgb); }    function a4197(z4205) {     const col = k4193(z4205);          let hsv;          switch (z4205[0])     {         case 'hex':         case 'rgb':   hsv = p52(          col ); break;          case 'hsv':   hsv =                   col;   break;         case 'hsl':   hsv = p52(p50  (col)); break;          case 'hclok': hsv = p52(k34(col)); break;         case 'hclab': hsv = p52(f40(col)); break;         case 'hcluv': hsv = p52(o44(col)); break;          case 'oklab': hsv = p52(g3984(col)); break;         case 'lab':   hsv = p52(s56  (col)); break;         case 'luv':   hsv = p52(c3977  (col)); break;     }          if (isNaN(hsv[0]))         hsv[0] = 5/6;          return [        'hsv',         hsv[0],         hsv[1],         hsv[2] ]; }    function v4198(z4205) {     const col = k4193(z4205);      let hsl;      switch (z4205[0])     {         case 'hex':         case 'rgb':   hsl = o48(          col ); break;          case 'hsv':   hsl = o48(c54  (col)); break;         case 'hsl':   hsl =                   col;   break;          case 'hclok': hsl = o48(k34(col)); break;         case 'hclab': hsl = o48(f40(col)); break;         case 'hcluv': hsl = o48(o44(col)); break;          case 'oklab': hsl = o48(g3984(col)); break;         case 'lab':   hsl = o48(s56  (col)); break;         case 'luv':   hsl = o48(c3977  (col)); break;     }      return [        'hsl',         hsl[0],         hsl[1],         hsl[2] ]; }    function f4199(z4205) {     const col = k4193(z4205);      let lab;      switch (z4205[0])     {         case 'hex':         case 'rgb':   lab = w3980(          col ); break;          case 'hsv':   lab = w3980(c54  (col)); break;         case 'hsl':   lab = w3980(p50  (col)); break;          case 'hclok': lab = w3980(k34(col)); break;         case 'hclab': lab = w3980(f40(col)); break;         case 'hcluv': lab = w3980(o44(col)); break;          case 'oklab': lab =                     col;   break;         case 'lab':   lab = w3980(s56  (col)); break;         case 'luv':   lab = w3980(c3977  (col)); break;     }      return [        'oklab',         lab[0],         lab[1],         lab[2] ]; }    function c4200(z4205) {     const col = k4193(z4205);      let lab;      switch (z4205[0])     {         case 'hex':         case 'rgb':   lab = r55(          col ); break;          case 'hsv':   lab = r55(c54  (col)); break;         case 'hsl':   lab = r55(p50  (col)); break;          case 'hclok': lab = r55(k34(col)); break;         case 'hclab': lab =         n39(col);  break;         case 'hcluv': lab = r55(o44(col)); break;          case 'oklab': lab = r55(g3984(col)); break;         case 'lab':   lab =                   col;   break;         case 'luv':   lab = r55(c3977  (col)); break;     }      return [        'lab',         lab[0],         lab[1],         lab[2] ]; }    function e4201(z4205) {     const col = k4193(z4205);      let luv;      switch (z4205[0])     {         case 'hex':         case 'rgb':   luv = d3976(          col ); break;          case 'hsv':   luv = d3976(c54  (col)); break;         case 'hsl':   luv = d3976(p50  (col)); break;          case 'hclok': luv = d3976(k34(col)); break;         case 'hclab': luv = d3976(f40(col)); break;         case 'hcluv': luv =         z43(col);  break;          case 'oklab': luv = d3976(g3984(col)); break;         case 'lab':   luv = d3976(s56  (col)); break;         case 'luv':   luv =                   col;   break;     }      return [        'luv',         luv[0],         luv[1],         luv[2] ]; }    function k4202(z4205) {     const col = k4193(z4205);      let hcl;      switch (z4205[0])     {         case 'hex':         case 'rgb':   hcl = y37(          col);  break;          case 'hsv':   hcl = y37(c54  (col)); break;         case 'hsl':   hcl = y37(p50  (col)); break;          case 'hclok': hcl =                     col;   break;         case 'hclab': hcl = y37(f40(col)); break;         case 'hcluv': hcl = y37(o44(col)); break;          case 'oklab': hcl = y37(g3984(col)); break;         case 'lab':   hcl = y37(s56  (col)); break;         case 'luv':   hcl = y37(c3977  (col)); break;     }      return [        'hclok',         hcl[0],         hcl[1],         hcl[2] ]; }    function i4203(z4205) {     const col = k4193(z4205);      let lab;      switch (z4205[0])     {         case 'hex':         case 'rgb':   lab = g42(          col) ; break;                  case 'hsv':   lab = g42(c54  (col)); break;         case 'hsl':   lab = g42(p50  (col)); break;                  case 'hclok': lab = g42(k34(col)); break;         case 'hclab': lab =                     col;   break;         case 'hcluv': lab = g42(o44(col)); break;                  case 'oklab': lab = g42(g3984(col)); break;         case 'lab':   lab = e41(          col ); break;         case 'luv':   lab = g42(c3977  (col)); break;     }      return [        'hclab',         lab[0],         lab[1],         lab[2] ]; }    function s4204(z4205) {     const col = k4193(z4205);      let hcl;      switch (z4205[0])     {         case 'hex':         case 'rgb':   hcl = r46(          col ); break;          case 'hsv':   hcl = r46(c54  (col)); break;         case 'hsl':   hcl = r46(p50  (col)); break;          case 'hclab': hcl = r46(f40(col)); break;         case 'hcluv': hcl =                     col;   break;         case 'hclok': hcl = r46(k34(col)); break;          case 'oklab': hcl = r46(g3984(col)); break;         case 'lab':   hcl = r46(s56  (col)); break;         case 'luv':   hcl = n45(          col ); break;     }      return [        'hcluv',         hcl[0],         hcl[1],         hcl[2] ]; }


</script>