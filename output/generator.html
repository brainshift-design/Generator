<script id="generatorScript" type="javascript/worker"> 'use strict';  


const k858 = 327;   const u859        = 2147483647;    const NULL             = '';    const g860             = '  ';  const g861              = '    '; const z862               = '\n';    const a863   = '◦ G •'; const e864    = a863 + ' ';  const f865          = 'G_NODE'; const y866          = 'G_CONN'; const c867          = 'G_PAGE'; const s868          = 'G_TEMP';    const identity = Object.freeze(     [[1, 0, 0],      [0, 1, 0],      [0, 0, 1]]);    const Epsilon = 0.0000001; const Tau     = Math.PI * 2;    var z2516 = false;    function t869(x, eps = 0.000000001)  {      return Math.abs(x) < eps ? 0 : x; }    function nozero(x, eps = 0.000000001)  {      return x != 0           ? x           : (x < 0 ? -eps : eps); }    function l870(v, eps = 0.000000001)  {      return point(         nozero(v.x, eps),          nozero(v.y, eps));  }    function equal(a, b, eps = 0.000000001) {     return Math.abs(b - a) < eps; }    function sqr (x) { return x*x;   }; function cube(x) { return x*x*x; };    function w871(f) { return Math.floor(f) | 0; }    function t872(x) {     x = w871(x);      x--;      x |= x >>  1;     x |= x >>  2;     x |= x >>  4;     x |= x >>  8;     x |= x >> 16;     x |= x >> 32;      return ++x; }    function gcd(a, b) {     let temp;     while (1)     {         temp = a % b;          if (temp == 0)           return b;          a = b;         b = temp;     } }    function distance(p1, p2) {     const dx = p2.x - p1.x;     const dy = p2.y - p1.y;      return Math.sqrt(dx*dx + dy*dy); }    function angle(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function l873(v1, v2) {     return p874(v1.x, v1.y, v2.x, v2.y); }    function p874(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      let angle = Math.atan2(dy, dx);     if (angle < 0) angle += Tau;      return angle; }    function z875(v) {     return Math.sqrt(v.x*v.x + v.y*v.y); }    function z876(v) {     return point(         v.x == 0 ? 0 : v.x / z875(v),         v.y == 0 ? 0 : v.y / z875(v)); }    function dot(v1, v2) {     return v1.x * v2.x + v1.y * v2.y; }    function t877(a1, a2) {     let diff = a2 - a1;      while (diff <= -Tau/2) diff += Tau;     while (diff >   Tau/2) diff -= Tau;      return diff;  }    function f878(v, m) {     let v3 = [v.x, v.y, 1];     let r  = v942(v3, m);      return point(r[0], r[1]); }    function f879(...mm) {     s946(mm.length > 0, 'mulm3m3() must take at least one argument');      let result = clone(mm[0]);      for (let a = 1; a < mm.length; a++)     {         const m1 = result;         const m2 = mm[a];          const m = [[0, 0, 0],                    [0, 0, 0],                    [0, 0, 0]];          for (let i = 0; i < 3; i++)         {             for (let j = 0; j < 3; j++)             {                                  for (let k = 0; k < 3; k++)                     m[i][j] += m1[i][k] * m2[k][j];             }         }          result = m;     }      return result; }    function a880(m, s) {     for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             m[i][j] /= s;      return m; }    function adjugate(m) {     return cofactor(transpose(m)); }    function transpose(m) {     return [[m[0][0], m[1][0], m[2][0]],             [m[0][1], m[1][1], m[2][1]],             [m[0][2], m[1][2], m[2][2]]]; }    function cofactor(m) {     return [[  m[1][1] * m[2][2] - m[2][1] * m[1][2], -(m[1][0] * m[2][2] - m[2][0] * m[1][2]),  m[1][0] * m[2][1] - m[2][0] * m[1][1] ],             [-(m[0][1] * m[2][2] - m[2][1] * m[0][2]),  m[0][0] * m[2][2] - m[2][0] * m[0][2], -(m[0][0] * m[2][1] - m[2][0] * m[0][1])],             [  m[0][1] * m[1][2] - m[1][1] * m[0][2], -(m[0][0] * m[1][2] - m[1][0] * m[0][2]),  m[0][0] * m[1][1] - m[1][0] * m[0][1] ]];  }    function determinant(m) {     return   m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])            - m[0][1] * (m[1][0] * m[2][2] - m[2][0] * m[1][2])            + m[0][2] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]); }    function m881(m) {     return a880(adjugate(m), determinant(m)); }    function q882(angle) {     const cosA = t869(Math.cos(angle));     const sinA = t869(Math.sin(angle));      return [[ cosA, sinA, 0],             [-sinA, cosA, 0],             [ 0,    0,    1]]; }    function f883(x = 0, y = 0, q884 = 1, z885 = 1, angle = 0, m886 = 0, a887 = 0) {     const cosA = Math.cos(angle);     const sinA = Math.sin(angle);      return [[q884*cosA -  a887*sinA, -m886*cosA + z885*sinA, x],             [ a887*cosA + q884*sinA, z885*cosA +  m886*sinA, y],             [0,                         0,                         1]]; }    function a888(v1, v2) {                               return v1.x * v2.y - v1.y * v2.x; }	    function y889(v1, v2) {     return point(         v1.x + v2.x,         v1.y + v2.y); }	    function d890(v1, v2) {     return point(         v1.x * v2.x,         v1.y * v2.y); }	    function r891(v, s) {     return point(         v.x * s,         v.y * s); }	    function z892(v1, v2) {     return point(         v1.x / v2.x,         v1.y / v2.y); }	    function j893(v, s) {     return point(         v.x / s,         v.y / s); }	    function u894(v1, v2) {     return point(         v1.x - v2.x,         v1.y - v2.y); }	    function q895(str)  {     return decodeURI(encodeURIComponent(str)); }    function q896(str)  {     return decodeURIComponent(encodeURI(str)); }    function s897(bytes)  {     let str = '';      for (let i = 0; i < bytes.length; i++)         str += String.fromCharCode(bytes[i]);      return str; }    function x898(str) {     return Array.from(q896(str), c => c.charCodeAt(0)); }    function n899(array, size)  {     const newArray = new Uint8Array(size);     g900(array, newArray);     return newArray; }    function g900(src, dst) {     h901(         src, 0, src.length,         dst, 0, dst.length); }    function h901(src, u902, t903, dst, e904, t905) {     const size = Math.min(t903, t905);      for (let i = 0; i < size; i++)         dst[e904 + i] = src[u902 + i]; }    function g906(b907, e908) {     if (b907.length != e908.length)         return false;      for (let i = 0; i < b907.length; i++)     {         if (b907[i] != e908[i])             return false;     }      return true; }    function v909(w910, t911) {     return w910.findIndex(i => t911.includes(i)) > -1; }    function  z912(list) { return list ? '<==' : '<--'; };  function f913(list) { return list ? '==>' : '-->'; };   function u914(nodeId) { return f865 + ' ' + nodeId; } function t915(name)   { return y866 + ' ' + name;   } function p916(name)   { return c867 + ' ' + name;   }    function u917(str)  {      return str.toLowerCase() == 'true'         || str == '1'; }    function j918(e919, s920 = false) {     return t925(         e919.outputNodeId,         e919.outputId,         e919.outputOrder,         e919.inputNodeId,         e919.inputId,         e919.list,         s920); }    function y921(outputNodeId, outputId, outputOrder, inputNodeId, inputId) {     return t915(           outputNodeId + ' '         + outputId     + ' '         + outputOrder  + ' '         + inputNodeId  + ' '         + inputId); }    function c922(k243) {     return y921(         k243.outputNodeId,         k243.outputId,         k243.outputOrder,         k243.inputNodeId,         k243.inputId); }    function t923(k243) {     return y921(         k243.output.node.id,         k243.output.id,         k243.outputOrder,         k243.input.node.id,         k243.input.id); }    function p924(k243, s920 = false) {     return t925(         k243.output.node.id,         k243.output.id,         k243.outputOrder,         k243.input.node.id,         k243.input.id,         k243.list,         s920); }    function t925(outputNodeId, outputId, outputOrder, inputNodeId, inputId, list, s920 = false) {     const  sp   = s920 ? ' ' : '  ';      const jsp   = s920 ? ''  : ' ';       const arrow =            sp          + y929(typeof outputOrder == 'string' ? parseInt(outputOrder) : outputOrder)          + f913(typeof list == 'string' ? u917(list) : list)          + sp;      const join  = jsp + '.' + jsp;      return  outputNodeId + join + outputId          + arrow          + inputNodeId  + join + inputId;           }    function x926(pageId) {     return p916(pageId); }    function j927(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += q928(c);      return sup; }    function q928(c) {     switch (c)     {         case '0': return '⁰';         case '1': return '¹';         case '2': return '²';         case '3': return '³';         case '4': return '⁴';         case '5': return '⁵';         case '6': return '⁶';         case '7': return '⁷';         case '8': return '⁸';         case '9': return '⁹';         case '.': return '·';     } }    function y929(num) {     const str = num.toString();      let sup = '';      for (const c of str)         sup += i930(c);      return sup; }    function i930(c) {     switch (c)     {         case '0': return '₀';         case '1': return '₁';         case '2': return '₂';         case '3': return '₃';         case '4': return '₄';         case '5': return '₅';         case '6': return '₆';         case '7': return '₇';         case '8': return '₈';         case '9': return '₉';         case '.': return ' ';     } }    function g931(bool) {     return bool ? 'true' : 'false'; }    function isValid(val) {     return val != undefined         && val != null; }    function isEmpty(array) {     return array.length == 0; }    function w932(array, item) {     s933(array, array.indexOf(item)); }    function s933(array, index) {     if (   index > -1          && index < array.length)         array.splice(index, 1); }    function z934(array) {     if (isEmpty(array))         return null;      let last = array.at(-1);     array.splice(array.length-1, 1);      return last; }    function t935(array) {     return array[array.length-1]; }    function s936(array, from, to)  {     const item = array[from];     array.splice(from, 1);     array.splice(to, 0, item); }    function x937(array, item) {     const index = array.indexOf(item);          if (index > -1)         array.splice(index, 1); }    function a938(k2768, array) {     for (const item of array)     {         const index = k2768.indexOf(item);                  if (index > -1)             k2768.splice(index, 1);     } }    function x939(array, where) {     const index = array.findIndex(where);          if (index > -1)         array.splice(index, 1); }    function t940(styleId) {     return styleId.split(',')[0] + ','; }    function l941(points) {     let b4009 = '';       if (points.length < 2)         return b4009;       b4009 += 'M';     b4009 += ' ' + t869(points[0].x);     b4009 += ' ' + t869(points[0].y);      for (let i = 1; i < points.length; i++)     {         b4009 +=                ' L'             + ' ' + t869(points[i].x)             + ' ' + t869(points[i].y);     }       return b4009; }    function point(x, y) { return {x: x, y: y}; }    function v942(v, m) {     let r = [0, 0, 0];      for (let i = 0; i < 3; i++)         for (let j = 0; j < 3; j++)             r[i] += v[j] * m[i][j];      return r; }    function clone(val)  {     const type = typeof val;          if (val === null)        return null;      else if (type === 'undefined'            || type === 'number'            || type === 'string'            || type === 'boolean')          return val;      else if (type === 'object')      {         if (val instanceof Array)              return val.map(x => clone(x));          else if (val instanceof Uint8Array)              return new Uint8Array(val);          else          {             let c111 = {};              for (const key in val)                  c111[key] = clone(val[key]);              return c111;         }     }      throw 'unknown'; }    function e943(array, item, equal = null) {     if (equal)     {         if (Array.isArray(item))             item.forEach(i => e943(array, i, equal));         else if (!array.find(i => equal(i, item)))             array.push(item);     }     else     {         if (Array.isArray(item))             item.forEach(i => e943(array, i));         else if (!array.includes(item))             array.push(item);     } }    function b944(array, item, equal) {     if (Array.isArray(item))         item.forEach(i => b944(array, i, equal));     else if (!array.find(equal))         array.push(item); }    function k945(array, item, except) {     if (Array.isArray(item))         item.forEach(i => k945(array, i, except));     else if (!array.find(except))         array.push(item); }    function s946(...args) {               if (z2516)     {         console.assert(...args);              } }    function u947(...args) {               if (z2516)         console.error(...args); }    function p948(str, trim)  {     while (str.length >= trim.length         && str.substring(0, trim.length) == trim)          str = str.substring(trim.length);      return str; }    function b949(str, trim)  {     while (str.length >= trim.length         && str.substring(str.length - trim.length) == trim)          str = str.substring(0, str.length - trim.length);      return str; }    function b950(e4069) {     const fills = [];       for (const fill of e4069)     {         switch (fill[0])         {             case 'SOLID':             {                 const color = {                     r: Math.min(Math.max(0, fill[1] / 0xff), 1),                      g: Math.min(Math.max(0, fill[2] / 0xff), 1),                      b: Math.min(Math.max(0, fill[3] / 0xff), 1) };                  const opacity = Math.min(Math.max(0, fill[4] / 100), 1);                   if (   !isNaN(color.r)                     && !isNaN(color.g)                     && !isNaN(color.b)                     && !isNaN(opacity))                     fills.push(                     {                         type:      fill[0],                          color:     color,                         opacity:   opacity,                         blendMode: fill[5]                     });                   break;             }              case 'GRADIENT_LINEAR':             case 'GRADIENT_RADIAL':             case 'GRADIENT_ANGULAR':             case 'GRADIENT_DIAMOND':             {                 const c4185 = fill[1];                   const stops = [];                  for (const stop of fill[2])                 {                     stops.push({                         color:                          {                             r: Math.min(Math.max(0, stop[0]), 1),                             g: Math.min(Math.max(0, stop[1]), 1),                             b: Math.min(Math.max(0, stop[2]), 1),                             a: Math.min(Math.max(0, stop[3]), 1)                         },                         position: stop[4]                     });                   }                   fills.push(                 {                     type:              fill[0],                     gradientTransform: c4185,                     gradientStops:     stops,                     blendMode:         fill[3]                 });                   break;             }         }     }       return fills; }    function w951(type) {     return s1084.includes(type); }


function i952(type, active) {     return s953(type, active, h3981); }    function s953(type, active, h3981) {     if (k1161.includes(type))         return active              ? (h3981 ? t2380 : u2370)             : (h3981 ? a2381       : t2371      );      else if (x1162.includes(type))         return active              ? (h3981 ? a2386   : y2376)             : (h3981 ? t2387         : w2377      );      else if (o1280.includes(type)          || l1206.includes(type))         return active              ? (h3981 ? r2384  : m2374)             : (h3981 ? c2385        : v2375      );      else if (u1284.includes(type))         return active              ? (h3981 ? t2382  : n2372)             : (h3981 ? q2383        : v2373      );      else if (f1085.includes(type)           || type == w1082)         return active              ? (h3981 ? i2378   : g2368)             : (h3981 ? k2379         : u2369      );      else if (type == v1208)         return active              ? (h3981 ? i2378   : g2368)             : (h3981 ? k2379         : u2369      );       switch (type)     {         case u1163:               case k1173:         case x1176:         case q1179:         case f1182:          case g1164:                    case k1170:         case o1166:         case w1168:         case b1169:         case w1171:          case t1180:         case m1183:              return h3981                   ? k2379                           : u2369;                                             }                return h3981           ? k2379                   : u2369; }    function u954(color) {     return isNaN(color[1])         || isNaN(color[2])         || isNaN(color[3]); }


function s992(x, replace) {     return !isNaN(x) ? x : replace; }    function q993(c) {     return c >= 'a' && c <= 'z'         || c >= 'A' && c <= 'Z'; }   function c994(i) {     let l = Math.floor(Math.log10(Math.abs(i)));      return l + 1; }    function x995(dec) {     return Math.pow(10, -dec); }    function z996(c) {     return c >= '0'          && c <= '9'; }    function p997(c) {     return c.length == 1         && (   c >= 'A' && c <= 'F'             || c >= 'a' && c <= 'f'); }    function r998(num)  {     if (typeof num !== 'number')         u947('Input must be a number');          const strNum = num.toFixed(10);     const iDec   = strNum.indexOf('.');          if (iDec === -1)         return 0;          let count        = strNum.length - iDec - 1;     let nonZeroFound = false;          for (let i = strNum.length-1; i > iDec; i--)     {         if (strNum[i] === '0')             count--;         else             break;     }          return count; }    function l999(code) {     return code == 'ArrowLeft'         || code == 'ArrowRight'         || code == 'ArrowUp'         || code == 'ArrowDown'; }    function n1000(num, dec = 0, y3975 = false, k1001 = '.', o1002 = '') {     return y3975          ? a1004(num, dec, k1001, o1002)          : o1003(num, dec, k1001, o1002); }    function o1003(num, dec, k1001 = '.', o1002 = '') {     const k4071 = Math.abs(dec);     let    str = Number(num).toFixed(k4071).toString(10);                     let i = str.length-1;          while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return i1005(str, o1002, 3);           let whole = str.slice(0, i);     let frac  = str.slice(i+1);             i = frac.length-1;      if (dec < 0)     {         while (i >= 0 && frac[i] === '0')             frac = frac.substring(0, i--);     }           return i1005(whole, o1002, 3) + (frac != '' ? k1001 : '') + frac; }    function a1004(num, dec, k1001 = '.', o1002 = '') {     const z4070 = Number(num);     const k4071 = Math.abs(dec);      let   s4068 = Number(num).toFixed(k4071).toString(10);     let    str = Math.abs(z4070).toString(16);                 let i = str.length-1;      while (i >= 0         && str[i] !== '.'          && str[i] !== ',')         i--;      if (i < 0)          return i1005(str, o1002, 2);           let whole = str.slice(0, i);     let frac  = s4068.slice(i+1);                 i = frac.length-1;      let f4072 = parseFloat(frac);     frac = '';      while (f4072 != 0)     {         f4072 *= 16;          const b4073 = Math.floor(f4072);          frac += b4073.toString(16);         f4072 -= b4073;     }           if (whole.length % 2 > 0) whole = '0' + whole;     if (frac .length % 2 > 0) frac  = frac + '0';       const neg = num < 0 ? '-' : '';      return neg + i1005(whole, o1002, 2) + k1001 + c1006(frac, o1002, 2); }    function i1005(s4068, sep, w1007) {     let str = '';      for (let i = s4068.length-1, t = 0; i >= 0; i--, t++)     {         if (t == w1007)         {             str = sep + str;             t = 0;         }          str = s4068[i] + str;     }      return str; }    function c1006(s4068, sep, w1007) {     let str = '';      for (let i = 0, t = 0; i < s4068.length; i++, t++)     {         if (t == w1007)         {             str += sep;             t = 0;         }          str += s4068[i];     }      return str; }                                 function capitalize(str) {     let cap = "";      if (str.length > 0)         cap += str[0].toUpperCase();      if (str.length > 1)         cap += str.substring(1).toLowerCase();      return cap; }    function i1008(y4074) {     const query = window.location.search.substring(1);     const vars  = query.split('&');      for (let i = 0; i < vars.length; i++)      {         let pair = vars[i].split('=');          if (pair[0] == y4074)             return pair[1];     }      return false; }


const phi = (Math.sqrt(5) - 1) / 2;  const Phi = (Math.sqrt(5) + 1) / 2;     function m1009(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.floor((x + Number.EPSILON) * div) / div;     }    function f1010(x, dec) {     const div = Math.round(Math.pow(10, dec));     return Math.round((x + Number.EPSILON) * div) / div;     }    function g1011(x, dec) {     const div = Math.ceil(Math.pow(10, dec));     return Math.ceil((x + Number.EPSILON) * div) / div;     }    function i1012(x1, y1, x2, y2) {     const dx = x2 - x1;     const dy = y2 - y1;      return Math.sqrt(dx*dx + dy*dy); }    function vector(angle, dist) {     return point(          dist * Math.cos(angle),          dist * Math.sin(angle)); }    function y1013(v1, v2) {     return v1.x == v2.x         && v1.y == v2.y; }    function i1014(v, salt = 0.0000000001) {     return y889(v, point(         -salt + Math.random() * salt*2,          -salt + Math.random() * salt*2)); }    function r1015(v) {     return point(-v.x, -v.y); }    function b1016(v) {           return point(v.y, -v.x); }    function angle(v) {     let angle = Math.atan2(v.y, v.x);     if (angle < 0) angle += Tau;      return angle; }    function w1017(x, y) {     let angle = Math.atan2(y, x);     if (angle < 0) angle += Tau;      return angle; }    function y3982(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         let r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         let r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function g3983(x1, y1, x2, y2, left, top, right, bottom) {     let t0 = 0;     let t1 = 1;      let dx = x2 - x1;     let dy = y2 - y1;      let cl = y3982(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     let cr = y3982( dx, right - x1,   t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     let ct = y3982(-dy, -(top - y1),  t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     let cb = y3982( dy, bottom - y1,  t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function intersect(p1, p2, q1, q2, segment) {     if (   y1013(p1, p2)          || y1013(q1, q2))          return s978;       let v1 = u894(p2, p1);     let v2 = u894(q2, q1);      if (a888(v1, v2) == 0)          return s978;       let t1 = a888(u894(q1, p1), v2) / a888(v1, v2);     let t2 = a888(u894(q1, p1), v1) / a888(v1, v2);      if ((  0 <= t1 && t1 <= 1         && 0 <= t2 && t2 <= 1)         || !segment)         return y889(p1, r891(v1, t1));              return s978; }    function s3984(l0, l1, p, segment) {     if (y1013(p, l0))         return l0;              let d = r891(         z876(b1016(u894(l1, l0))),          distance(p, l0));                  return intersect(l0, l1, p, u894(p, d), segment); }    function h3985(p0, p1, p) {     let cp = s3984(p0, p1, p, false);      let c4185 = f879(         t3986(r1015(p0)),         n3987(-l873(p0, p1)));              p0 = transform(p0, c4185);     p1 = transform(p1, c4185);     cp = transform(cp, c4185);      return (cp.x - p0.x) / nozero(p1.x - p0.x); }    function transform(p, c4185) {     return f878(p, c4185); }    function t3986(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function n3987(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }                          const MaxDigits = 100000;   function i1018(x, res, resSize) {     let carry = 0n;               for (let i = 0; i < resSize; i++)      {         const prod = res[i] * x + carry;              res[i] = prod % 10n;          carry  = prod / 10n;      }                    while (carry)     {         res[resSize] = carry % 10n;         carry        = carry / 10n;         resSize++;     }      return resSize; }    function a1019(max = Number.MAX_SAFE_INTEGER/2) {     const num = Math.floor(Math.random() * max);     return r1020(num); }    function r1020(x)  {     while (!s1021(++x));     return x; }    function s1021(n, k = j1022)  {     if (n <= 1) return false;      if (n <= 3) return true;           if (n % 2 == 0)          return false;                let d = n - 1;          while (d % 2 == 0)          d /= 2;                       for (let i = 0; i < k; i++)             if (!o1023(d, n))             return false;                return true;  }        function o1023(d, n) {     return bigMillerTest(         BigInt(d),         BigInt(n)); }            function m1024(buffer, size) {     return i1025(buffer, 0, size); }    function i1025(buffer, start, size) {     let val = 0;     let mul = 1;      for (let i = start+size-1; i >= start; i--)      {         val += mul * buffer[i];         mul <<= 8;     }      return val; }    function z1026(val, buffer, d1027) {     k1028(val, buffer, 0, d1027); }    function k1028(val, buffer, start, d1027) {     let size = Math.ceil(bigBitCount(val) / 8);          size = Math.min(size, buffer.length - start);      start += d1027 - size;      for (let i = start+size-1; i >= start; i--)      {         buffer[i] = val & 0xFF;          val >>= 8;     } }    function n1029(a, b, t) {     return a + (b - a) * t; }    function i1030(f0, f1, f2, t) {     const c0 = n1029(f0, f1, t);     const c1 = n1029(f1, f2, t);      return n1029(c0, c1, t); }    function n1031(f0, f1, f2, f3, t) {     const c0  = n1029(f0, f1, t);     const c1  = n1029(f1, f2, t);     const c2  = n1029(f2, f3, t);      const c01 = n1029(c0, c1, t);     const c12 = n1029(c1, c2, t);      return n1029(c01, c12, t); }    function g1032(angle) {     while (angle <  0  ) angle += Tau;     while (angle >= Tau) angle -= Tau;      return angle;  }    function g1033(m, v)  {     const result = [];      for (let i = 0; i < m.length; i++)      {         let sum = 0;          for (let j = 0; j < v.length; j++)              sum += m[i][j] * v[j];          result.push(sum);     }         return result; }


const s978 = point(Number.NaN, Number.NaN);    function f979(p) { return isNaN(p.x) || isNaN(p.y); }    function unit(v) {     return v.X != 0          || v.Y != 0         ? r891(v, 1 / z875(v))         : point(0, 0); }    function b980(p0, p1, t) {     return point(         n1029(p0.x, p1.x, t),         n1029(p0.y, p1.y, t)); }    function d981(p0, p1, p2, t) {     return point(         i1030(p0.x, p1.x, p2.x, t),         i1030(p0.y, p1.y, p2.y, t)); }    function u982(p0, p1, p2, p3, t) {     return point(         n1031(p0.x, p1.x, p2.x, p3.x, t),         n1031(p0.y, p1.y, p2.y, p3.y, t)); }    function y3982(p, q, t0, t1) {     if (p == 0 && q < 0)     {         return null;     }     else if (p < 0)     {         const r = q/p;               if (r > t1) return null;         else if (r > t0) t0 = r;     }     else if (p > 0)     {         const r = q/p;               if (r < t0) return null;         else if (r < t1) t1 = r;     }      return [t0, t1]; }    function g3983(x1, y1, x2, y2, left, top, right, bottom) {     const t0 = 0;     const t1 = 1;      const dx = x2 - x1;     const dy = y2 - y1;      const cl = y3982(-dx, -(left - x1), t0, t1); if (cl != null) { t0 = cl[0]; t1 = cl[1]; } else return null;     const cr = y3982( dx,  right - x1,  t0, t1); if (cr != null) { t0 = cr[0]; t1 = cr[1]; } else return null;     const ct = y3982(-dy,  -(top - y1), t0, t1); if (ct != null) { t0 = ct[0]; t1 = ct[1]; } else return null;     const cb = y3982( dy,  bottom - y1, t0, t1); if (cb != null) { t0 = cb[0]; t1 = cb[1]; } else return null;      if (t1 < 1)     {         x2 = x1 + t1*dx;         y2 = y1 + t1*dy;     }      if (t0 > 0)     {         x1 = x1 + t0*dx;         y1 = y1 + t0*dy;     }      return [         point(x1, y1),          point(x2, y2) ]; }    function p983(p1, p2, q1, q2, segment) {     if (   y1013(p1, p2)          || y1013(q1, q2))          return s978;       const v1 = u894(p2, p1);     const v2 = u894(q2, q1);      if (a888(v1, v2) == 0)          return s978;       const t1 = a888(u894(q1, p1), v2) / a888(v1, v2);     const t2 = a888(u894(q1, p1), v1) / a888(v1, v2);      if (   (   0 <= t1 && t1 <= 1             && 0 <= t2 && t2 <= 1)         || !segment)         return y889(p1, r891(v1, t1));              return s978; }    function s3984(l0, l1, p, segment) {     if (y1013(p, l0))         return l0;              const d = r891(         z876(b1016(u894(l1, l0))),          distance(p, l0));                  return p983(l0, l1, p, u894(p, d), segment); }    function h3985(p0, p1, p) {     let cp = s3984(p0, p1, p, false);      const c4185 = f879(         t3986(-p0),         n3987(-l873(p0, p1)));      p0 = transform(p0, c4185);     p1 = transform(p1, c4185);     cp = transform(cp, c4185);      return (cp.X - p0.X) / nozero(p1.X - p0.X); }    function x984(rect1, rect2) {     return rect1.l >= rect2.l         && rect1.r <= rect2.r         && rect1.t >= rect2.t         && rect1.b <= rect2.b;  }    function m985(rect1, rect2) {     return !(            rect1.l >= rect2.r         || rect1.r <= rect2.l         || rect1.t >= rect2.b         || rect1.b <= rect2.t);  }    function y986(rect, clip) {     if (!m985(rect, clip))         return v1042.NaN;      return new AbsRect(         Math.max(rect.l, clip.l),         Math.max(rect.t, clip.t),         Math.min(rect.r, clip.r),         Math.min(rect.b, clip.b)); }    function e987(rect) {     return new v1042(         rect.x + Math.min(rect.w, 0),         rect.y + Math.min(rect.h, 0),         Math.abs(rect.w),         Math.abs(rect.h)); }    function y988(x, y, w, h) {     return [         x + Math.min(w, 0),         y + Math.min(h, 0),         Math.abs(w),         Math.abs(h) ]; }    function transform(p, c4185) {     return f878(p, c4185); }    function t3986(v) {     return [[1, 0, v.x],             [0, 1, v.y],             [0, 0, 1  ]]; }    function n3987(angle) {     return [[ Math.cos(angle), Math.sin(angle), 0],             [-Math.sin(angle), Math.cos(angle), 0],             [ 0,               0,               1]]; }    function offsetRect(elem) {     return new v1042(         elem.offsetLeft,         elem.offsetTop,         elem.offsetWidth,         elem.offsetHeight); }    function r989(elem) {     const bounds = elem.getBoundingClientRect();      return new v1042(         bounds.x,         bounds.y,         bounds.width,         bounds.height); }    function o990(p0, p1, p2) {     const v0  = u894(p1, p0);     const v1  = u894(p2, p1);          const pm0 = j893(y889(p0, p1), 2);     const pm1 = j893(y889(p1, p2), 2);          return p983(         pm0, y889(pm0, b1016(v0)),          pm1, u894(pm1, b1016(v1)),          false); }    function s991(p1, p2, p3) {           const pc = o990(p1, p2, p3);      let a = t877(         angle(u894(p1, pc)),         angle(u894(p2, pc)));                           return a; }


function n848(x0, y0, x1, y1, x2, y2, x3, y3, t) {     const p0 = point(x0, y0);     const p1 = point(x1, y1);     const p2 = point(x2, y2);     const p3 = point(x3, y3);      return unit(y889(y889(         r891(u894(p1, p0), 3*sqr(1-t)),         r891(u894(p2, p1), 6*(1-t)*t)),         r891(u894(p3, p2), 3*sqr(t)))); }    function p849(p0, p1, p2, p3, p850, error = 0.001) {     const hullLength =            distance(p0, p1)          + distance(p1, p2)         + distance(p2, p3);      if (hullLength == 0)         return Number.NAN;       let t = p850 / hullLength;      if (t < 0 || t > 1)         return Number.NAN;               let halves = z851(p0, p1, p2, p3, t);     let l      = halves[0];      let length = n852(l[0], l[1], l[2], l[3], error);       let q3833 = 1000;      while (Math.abs(p850 - length) > error         && q3833-- > 0)     {         t += (p850 - length) / hullLength;          halves = z851(p0, p1, p2, p3, t);         l      = halves[0];          length = n852(l[0], l[1], l[2], l[3], error);     }      if (q3833 == 0)         u947('endless loop in p849()');       return t; }    function z851(p0, p1, p2, p3, t) {     const c0   = b980(p0, p1, t);     const c1   = b980(p1, p2, t);     const c2   = b980(p2, p3, t);                      const c01  = b980(c0, c1, t);     const c12  = b980(c1, c2, t);      const c012 = b980(c01, c12, t);      return [         [p0, c0, c01, c012],         [c012, c12, c2, p3] ]; }                                           function n852(p0, p1, p2, p3, error = 0.0000001) {     const p850 =            distance(p0, p1)         + distance(p1, p2)         + distance(p2, p3);      const chord = distance(p0, p3);      if ((p850 - chord) > error)     {         const halves = z851(p0, p1, p2, p3, 0.5);         const l      = halves[0];         const r      = halves[1];                      return n852(l[0], l[1], l[2], l[3], error)              + n852(r[0], r[1], r[2], r[3], error);     }      return p850; }    function u853(p0, p1, p2) {     let rect = v1042.NaN;       rect = z3720(rect, p0);     rect = z3720(rect, p2);            if (   (   p0.x <= p1.x && p1.x <= p2.x             || p2.x <= p1.x && p1.x <= p0.x)         && (   p0.y <= p1.y && p1.y <= p2.y             || p2.y <= p1.y && p1.y <= p0.y))         return rect;       const ax = p0.x - 2*p1.x + p2.x;     const bx = 2 * (p1.x - p0.x);          const ay = p0.y - 2*p1.y + p2.y;     const by = 2 * (p1.y - p0.y);       const tx = -bx / nozero(2*ax);     const ty = -by / nozero(2*ay);       if (tx >= 0 && tx <= 1) rect = z3720(rect, d981(p0, p1, p2, tx));     if (ty >= 0 && ty <= 1) rect = z3720(rect, d981(p0, p1, p2, ty));           return rect; }    function u854(p0, p1, p2, p3) {     let rect = v1042.NaN;       rect = z3720(rect, p0);     rect = z3720(rect, p3);       const ax =   -p0.x + 3*p1.x - 3*p2.x + p3.x;     const bx =  3*p0.x - 6*p1.x + 3*p2.x;     const cx = -3*p0.x + 3*p1.x;      const ay =   -p0.y + 3*p1.y - 3*p2.y + p3.y;     const by =  3*p0.y - 6*p1.y + 3*p2.y;     const cy = -3*p0.y + 3*p1.y;       const roots = [];       v855(ax, bx, cx, roots);     v855(ay, by, cy, roots);       for (const root of roots)     {         rect = z3720(             rect,              u982(p0, p1, p2, p3, root));     }       return rect; }    function v855(a, b, c, roots) {     let a_ = a * 3;     let b_ = b * 2;       let D = b_*b_ - 4*a_*c;     let r;      if (a_ == 0)     {         r = -c/b_;  if (r >= 0 && r <= 1) roots.push(r);     }     else     {         const _2a = 1/(2*a_);         b_ *= _2a;              if (D == 0)         {             if (b_ >= 0 && b_ <= 1) roots.push(-b_);         }         else if (D > 0)         {             D = Math.sqrt(D) * _2a;              r = -b_ + D;  if (r >= 0 && r <= 1) roots.push(r);             r = -b_ - D;  if (r >= 0 && r <= 1) roots.push(r);         }     } }


class j1040 {     x;     y;      constructor(x, y)     {         this.x = x;         this.y = y;     } }


class v1042 {     x;     y;     w;     h;       get l()            { return this.x;            }     get c()            { return this.x + this.w/2; }     get r()            { return this.x + this.w;   }                 get t()            { return this.y;            }     get m()            { return this.y + this.h/2  }     get b()            { return this.y + this.h;   }                get tl()           { return point(this.l, this.t); }     get tc()           { return point(this.c, this.t); }     get tr()           { return point(this.r, this.t); }     get ml()           { return point(this.l, this.m); }     get mc()           { return point(this.c, this.m); }     get cm()           { return point(this.c, this.m); }     get mr()           { return point(this.r, this.m); }     get bl()           { return point(this.l, this.b); }     get bc()           { return point(this.c, this.b); }     get br()           { return point(this.r, this.b); }                   get width()        { return this.w; }     get height()       { return this.h; }            get left()         { return this.l; }     get center()       { return this.c; }     get right()        { return this.r; }                get top()          { return this.t; }     get middle()       { return this.m; }     get bottom()       { return this.b; }      get topLeft()      { return this.tl; }     get topCenter()    { return this.tc; }     get topRight()     { return this.tr; }     get middleLeft()   { return this.ml; }     get middleCenter() { return this.mc; }     get centerMiddle() { return this.cm; }     get middleRight()  { return this.mr; }     get bottomLeft()   { return this.bl; }     get bottomCenter() { return this.bc; }     get bottomRight()  { return this.br; }        constructor(x, y, w, h)     {         this.x = x;         this.y = y;         this.w = w;         this.h = h;     }        static g3563(rect)     {         return new v1042(rect.x, rect.y, rect.width, rect.height);      }             static get NaN() { return new v1042(Number.NaN, Number.NaN, 0, 0) };     static get Zero() { return new v1042(0, 0, 0, 0); }        get isNaN()     {         return isNaN(this.x)             || isNaN(this.y)             || isNaN(this.w)             || isNaN(this.h);     }    	get isEmpty() 	{ 		return (this.w == 0 			 || this.h == 0); 	}        assign(rect)     {         this.x = rect.x;         this.y = rect.y;         this.w = rect.w;         this.h = rect.h;     } }   class   AbsRect extends v1042 {     constructor(l, t, r, b)     {         super(l, t, r-l, b-t);     } }    function u3719(rect1, rect2) {     if (rect1.isNaN  ) return rect2;     if (rect1.isEmpty) return rect2;      if (rect2.isNaN  ) return rect1;     if (rect2.isEmpty) return rect1;          return new AbsRect(         Math.min(rect2.l, rect1.l),         Math.min(rect2.t, rect1.t),         Math.max(rect2.r, rect1.r),         Math.max(rect2.b, rect1.b)); }    function z3720(rect, p) {     if (rect.isNaN) return new v1042(p.x, p.y, 0, 0);      return new AbsRect(         Math.min(p.x, rect.l),         Math.min(p.y, rect.t),         Math.max(p.x, rect.r),         Math.max(p.y, rect.b)); } 


class Random {     seed;     index;       cache;        constructor(seed = 0)     {          this.seed  = seed;          this.index = 0;                  this.c1041(256);     }        copy()     {         return new Random(this.seed, this.last);     }        c1041(size)     {         this.cache = new Int32Array(size);          let seed = this.seed;         let last = seed;          for (let i = 0; i < size; i++)             this.cache[i] = seed = this.generate(seed, last);     }        next()     {         if (this.index >= this.cache.length)             this.c1041(t872(this.index));          return this.cache[this.index++] / -0x7fffffff;     }        get(index)     {         if (index >= this.cache.length)             this.c1041(t872(index+1));          return this.cache[index] / -0x7fffffff;     }        generate(seed, last)     {         last = seed;                  seed = (seed + 0x7ed55d16) + (seed << 12);         seed = (seed ^ 0xc761c23c) ^ (seed >> 19);         seed = (seed + 0x165667b1) + (seed <<  5);         seed = (seed + 0xd3a2646c) ^ (seed <<  9);         seed = (seed + 0xfd7046c5) + (seed <<  3);         seed = (seed ^ 0xb55a4f09) ^ (seed >> 16);          return seed;     } }


const h1425 = navigator.platform.toLowerCase().indexOf('mac') >= 0;    var w3988; var r3989;        function k1426() {     w3988  = document.createElement('canvas');     r3989 = w3988.getContext('2d');      r3989.willReadFrequently = true; }    function u1427(parent, child) {     return Array.prototype.indexOf.call(parent.children, child); }    function c3990(count, singular, plural = singular) {     if (singular == plural)     {         const c3844   = singular.at(-1);         const c3845 = c3844 == c3844.toUpperCase() ? 'S' : 's';          return singular + (count == 1 ? '' : c3845);     }     else     {         const c3844 = plural.at(-1);          if (c3844 == c3844.toUpperCase())             plural = plural.toUpperCase();          return count == 1             ? singular             : plural;     } }    function j1428(o1429) {     const v3846   = o1429.indexOf('.');     const y3847 = o1429.indexOf(',');      return v3846 >= 0          ? o1429.length-1 - v3846          : (y3847 >= 0             ? o1429.length-1 - y3847             : 0); }    function d1430() {     const num = 1.1;      return num         .toLocaleString(navigator.language)         .substring(1, 2); }    function e1431(c111) {     if (c111 == null)         return false;              return (            Object.keys(c111).length === 0          && c111.constructor === Object); }    function t1432(c111) {     return Object.assign(Object.create(Object.getPrototypeOf(c111)), c111); }    function f1433(c111) {     return JSON.parse(JSON.stringify(c111)); }    function w1434(array) {     return array.filter((value, index) =>          array.indexOf(value) === index); }    function m1435(element) {     const svg = document.createElementNS("http://www.w3.org/2000/svg", element);
    svg.style.pointerEvents = 'none';     return svg; }    function y3991(element) {      return element.style.visibility == 'visible';  }    function y1436(array, item) {     return array.indexOf(item) == array.length-1; }    function t1437(parent)  {     while (parent.firstChild)         parent.removeChild(parent.firstChild); }             function g1438(data) {     let str = '';      for (let i = 0; i < data.length; i++)         str += String.fromCharCode(data[si]);      return str; }           function log(...params) {     setTimeout(console.log.bind(console, ...params));  }    function s1439() {     setTimeout(console.trace.bind(console)); }    function y1440(num) {     return !isNaN(num) ? num : e958; }    function l1441(str) {     return str == e958          ? Number.NaN           : parseFloat(str); }    function r1442(strBool) {     return strBool == 'true'; }    function g1443(str)  {     if (typeof str != 'string')          return false;       if (str == 'NaN')          return true;      return !isNaN(str)          && !isNaN(parseFloat(str));  }    function u1444(elem) {     void(elem.offsetHeight); }   function readonly(target, name, descriptor) {     descriptor.writable = false;     return descriptor; }    function q1445     (plus = true) { return h1425 ? ('⌘' + (plus ? ' ' : '')) : ('Ctrl'  + (plus ? '+' : '')); } function g1446      (plus = true) { return h1425 ? ('⌥' + (plus ? ' ' : '')) : ('Alt'   + (plus ? '+' : '')); } function q1447    (plus = true) { return h1425 ? ('⇧' + (plus ? ' ' : '')) : ('Shift' + (plus ? '+' : '')); } function a1448(plus = true) { return h1425 ? q1447(plus) + q1445(plus) : q1445(plus) + q1447(plus); }    function n1449(type, i4212, options) {     return  options.insert != undefined         &&  options.insert         && (    options.u3387 == undefined             || !options.u3387)         ? new k3(type, i4212, options)         : new s4      (type, i4212, options, options.u3387 != undefined && options.u3387); }    function u1450(x) {     return (x * 2654435761 % Math.pow(2, 32)) / Math.pow(2, 32); }    function r1451(g1452, y1453, id = g1452, join = '') {     if (!y1453(id))         return id;           let numLength = f1454(id);      if (numLength > 0)     {         const len = id.length - numLength;         let   num = parseInt(id.substring(len));          let u4216 = '';         while (u4216 == '' || y1453(u4216))             u4216 = id.substring(0, len + join.length) + join + (++num);          return u4216;     }      else if (numLength == 0)     {         let num   = 2;         let u4216 = id + join + num;          while (y1453(u4216))             u4216 = id + join + (++num);          return u4216;     }      else         return id; }    function f1454(name) {     let numLength = 0;      for (let i = name.length - 1; i >= 0; i--)     {         if (z996(name[i])) numLength++;         else break;     }      return numLength; }    function c1455(str)  {     return /^-?\d*\.?\d*(e-?\d+)?$/.test(str); }    function g1456(control, family, size, align = 'left') {     control.style.fontFamily = family;     control.style.fontSize   = size + 'px';     control.style.textAlign  = align; }    function u1457(month, year) {     if (month == 2)     {         return year % 4 != 0              ? 28              : 29;     }     else if (month == 4           || month == 7           || month == 9           || month == 11)         return 30;     else         return 31; }    function getFontStyles(fontName) {     let fonts = c4015.filter(f => f.fontName.family == fontName);       fonts.sort((a, b) =>     {         if (a.fontName.style != b.fontName.style)             return e1366.findIndex(w => w[0] == a.fontName.style.toLowerCase())                  - e1366.findIndex(w => w[0] == b.fontName.style.toLowerCase());          return 0;     });           return fonts.map(f => f.fontName.style); }    function q1458(str) {     return str.replaceAll(/\\(.)/g, (match, char) =>      {         const replacements =          {             'n':  '\n',             'r':  '\r',             't':  '\t',             '\\': '\\',             '\'': '\'',             '\"': '\"',             '\`': '\`'         };                return replacements[char] || match;     }); }    function unescapeRegexPattern(str) {     return str.replace(/\\([\\.*+?^${}()|\[\]])/g, '$1'); }    function unescapeRegexReplacement(str) {     return str.replace(/\\([\\$&`'])/g, '$1'); }    function v1459(str1, str2) {          // implementation taken from http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html
           if (str1.length == 0) return str2.length;     if (str2.length == 0) return str1.length;            if (str1.length > str2.length)     {         const s4068 = str1;         str1 = str2;         str2 = s4068;     }       let len1 = str1.length;      let len2 = str2.length;            while (len1 > 0          && str1[len1 - 1] == str2[len2 - 1])     {         len1--;          len2--;      }      let start = 0;            if (str1[0] == str2[0])     {         while (start < len1              && str1[start] == str2[start])              start++;          len1 -= start;          len2 -= start;                             if (len1 == 0) return len2;          str2 = str2.substring(start, len2);      }            let v0 = [];          for (let j = 0; j < len2; j++)          v0.push(j + 1);            let current = 0;      for (let i = 0; i < len1; i++)     {         const c = str1[start + i];          let left = current = i;          for (let j = 0; j < len2; j++)         {             const above = current;                         current = left;              left = v0[j];              if (c != str2[j])             {                 current++;                   let insDel = above + 1;                   if (insDel < current)                      current = insDel;                  insDel = left + 1;                   if (insDel < current)                      current = insDel;             }              v0[j] = current;         }     }          return current; }    function r1460(count) {     for (let i = 0; i < count; i++)          Math.random(); }    function k1461(str, sub, levenshteinDistance) {     if (sub.length > str.length)         return false;          if (str.includes(sub))         return true;          for (let i = 0; i <= str.length - sub.length; i++)      {         const s = str.substring(i, i + sub.length);                  if (v1459(sub, s) <= levenshteinDistance)             return true;     } }    function degamma(rgb, cs = o36) {     return [ cs.degamma(rgb[0]),              cs.degamma(rgb[1]),              cs.degamma(rgb[2]) ]; }    function regamma(rgb, cs = o36) {     return [ cs.regamma(rgb[0]),              cs.regamma(rgb[1]),              cs.regamma(rgb[2]) ]; }    String.prototype.replaceAt = function(index, replacement)  {     return this.substring(0, index)           + replacement           + this.substring(index+1); };    function e1462(array, condition) {     const items   = array.filter(condition);     const indices = [];          for (const item of items)         indices.push(items.indexOf(item));      return indices; }    function j1463(length) {     const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split('');      let str = '';      for (let i = 0; i < length; i++)         str += letters[Math.floor(Math.random() * letters.length)];      return str; }    function i1464(rect) {     return '{'               + rect.width         + ', '   + rect.height         + '}'; }    function y1465(str, _what, _with) {     var lastIndex = str.lastIndexOf(_what);      if (lastIndex === -1)          return str;      return str.substring(0, lastIndex) + _with + str.substring(lastIndex + _what.length); }    function a1466(x, y) {     const unders = document.elementsFromPoint(x, y)         .filter(el =>                 el.node             && el.className == 'nodeLabelWrapper');      unders.reverse();      return unders.length > 0           ? unders[0]          : null; }    function measureHtmlText(text, font, fontSize) {     divTextMeasure.style.font = fontSize + 'px \'' + font + '\'';     divTextMeasure.innerHTML = text;              return r989(divTextMeasure); }


"use strict";   // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
    function s842(c)  {     return    c > 64             && c < 91             ? c - 65             :    c > 96               && c < 123               ? c - 71              :    c > 47                 && c < 58                 ? c + 4                : c === 43                   ? 62                  : c === 47 ? 63 : 0; }    function b843(str, blocksSize)  {     const base64 = str.replace(/[^A-Za-z0-9\+\/]/g, "");     const inLen  = base64.length;      const outLen =          blocksSize          ? Math.ceil((inLen * 3 + 1 >> 2) / blocksSize) * blocksSize          : inLen * 3 + 1 >> 2;              const bytes = new Uint8Array(outLen);      for (let mod3,               mod4,               uint24 = 0,               out    = 0,          i = 0;          i < inLen;          i++)      {         mod4 = i & 3;         uint24 |= s842(base64.charCodeAt(i)) << 6 * (3 - mod4);          if (   mod4 === 3              || inLen - i === 1)          {             for (mod3 = 0; mod3 < 3 && out < outLen; mod3++, out++)                  bytes[out] = uint24 >>> (16 >>> mod3 & 24) & 255;              uint24 = 0;         }     }      return bytes; }      function s844(i)  {     return i < 26             ? i + 65            : i < 52               ? i + 71              : i < 62                 ? i - 4                : i === 62                   ? 43                  : i === 63 ? 47 : 65; }    function e845(bytes) {     let mod3   = 2,          base64 = "";      const length = bytes.length;      for (let i = 0, uint24 = 0; i < length; i++)      {         mod3 = i % 3;          if (i > 0 && (i * 4 / 3) % 76 === 0)              base64 += "\r\n";          uint24 |= bytes[i] << (16 >>> mod3 & 24);          if (   mod3 === 2              || bytes.length - i === 1)          {             base64 += String.fromCharCode(                 s844(uint24 >>> 18 & 0x3F),                  s844(uint24 >>> 12 & 0x3F),                  s844(uint24 >>>  6 & 0x3F),                  s844(uint24        & 0x3F));                              uint24 = 0;         }     }      return base64.substring(0, base64.length - 2 + mod3) + (mod3 === 2 ? '' : mod3 === 1 ? '=' : '=='); }      function utf8ArrToStr(bytes)  {     let   str    = "";      const length = bytes.length;      for (let i = 0; i < length; i++)      {         const byte = bytes[i];          str += String.fromCharCode(                byte > 251              && byte < 254              && i + 5 < length              ? (byte - 252) * 1073741824 + (bytes[++i] - 128 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128             :    byte > 247                && byte < 252                && i + 4 < length                ? (byte - 248 << 24) + (bytes[++i] - 128 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128               :    byte > 239                  && byte < 248                  && i + 3 < length                  ? (byte - 240 << 18) + (bytes[++i] - 128 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                 :    byte > 223                    && byte < 240                    && i + 2 < length                    ? (byte - 224 << 12) + (bytes[++i] - 128 << 6) + bytes[++i] - 128                   :    byte > 191                      && byte < 224                      && i + 1 < length                      ? (byte - 192 << 6) + bytes[++i] - 128                       : byte);     }      return str; }    function strToUtf8Arr(str)  {     let strLen = str.length,          arrLen = 0;             for (let i = 0; i < strLen; i++)      {         const chr = str.charCodeAt(i);         arrLen += chr < 0x80 ? 1 : chr < 0x800 ? 2 : chr < 0x10000 ? 3 : chr < 0x200000 ? 4 : chr < 0x4000000 ? 5 : 6;     }      const bytes = new Uint8Array(arrLen);             for (let i = 0, iChr = 0; i < arrLen; iChr++)      {         const chr = str.charCodeAt(iChr);               if (chr < 0x80)          {             bytes[i++] = chr;         }          else if (chr < 0x800)          {             bytes[i++] = 192 + (chr >>> 6);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x10000)          {             bytes[i++] = 224 + (chr >>> 12);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }         else if (chr < 0x200000)          {             bytes[i++] = 240 + (chr >>> 18);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else if (chr < 0x4000000)          {             bytes[i++] = 248 + (chr >>> 24);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }          else          {             bytes[i++] = 252 + (chr >>> 30);             bytes[i++] = 128 + (chr >>> 24 & 0x3F);             bytes[i++] = 128 + (chr >>> 18 & 0x3F);             bytes[i++] = 128 + (chr >>> 12 & 0x3F);             bytes[i++] = 128 + (chr >>>  6 & 0x3F);             bytes[i++] = 128 + (chr        & 0x3F);         }     }       return bytes; }


function position(e) {     return point(e.clientX, e.clientY); }    function m1468(c111, style) {     return window.getComputedStyle(c111).getPropertyValue(style); }    function p1469(e) {     return h1425 ? e.metaKey : e.ctrlKey;           }    function k1470(target, proto) {     target.dispatchEvent(new proto.constructor(proto.type, proto)); }    function l1471(className = '', id = '') {     const div = document.createElement('div');          if (className != '')         div.className = className;          if (id != '')         div.id = id;      return div; }    function q1472(div, to) {     if (!to.contains(div))         to.appendChild(div); }    function m1473(div, from) {     if (from.contains(div))         from.removeChild(div); }    function i1474(className = '') {     const textbox = document.createElement('INPUT');     textbox.setAttribute('type', 'text');       if (className.trim() != '')         textbox.className = className;          return textbox; }    function r1475(className = '') {     const textarea = document.createElement('textarea');      if (className.trim() != '')         textarea.className = className;          textarea.spellcheck = false;          return textarea; }    function x1476(elem, enable, bold = true) {     elem.style.fontStyle  = enable ? 'normal' : 'italic';       if (bold)         elem.style.fontWeight = enable ? 'normal' : 'bold'; }    function hasFocus(elem) {     return elem == document.activeElement; }    function p1477(id, properties) {     const elem = document.getElementById(id);      for (const property of properties)         elem.style[property] = properties[property]; }    function n1478(parent, child) {     return child.parentNode == parent; }    function c1479(event, element) {     const e = new event.constructor(event.type, event);     element.dispatchEvent(e); }    function offsetRect(element) {     return new v1042(         element.offsetLeft,         element.offsetTop,         element.offsetWidth,         element.offsetHeight); }    function clientRect(element) {     return new v1042(         element.clientLeft,         element.clientTop,         element.clientWidth,         element.clientHeight); }                  function a1480(elementId) {     if (document.selection)      {         var range = document.body.createTextRange();         range.moveToElementText(document.getElementById(elementId));         range.select();     }     else if (window.getSelection)      {         var range = document.createRange();         range.selectNode(document.getElementById(elementId));         window.getSelection().removeAllRanges();         window.getSelection().addRange(range);     } }    function u1481(e) {     return Math.abs(e.deltaX) < 100         && Math.abs(e.deltaY) < 100; }    function t1482(element, show = true)  {     const showStyle = 'block';     const hideStyle = 'none';      if (  !show         && element.style.display != hideStyle)         element.oldDisplay = element.style.display;      element.style.display =          show          ? (   element.style.oldDisplay             && element.style.oldDisplay != hideStyle            ? element.style.oldDsplay            : showStyle)         : hideStyle;  }   function v1483(element)               {      t1482(element, false);  }    function y3991(element) {     return element.offsetParent !== null; }    function u1484(element)  {      if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         return element.value.substring(             element.selectionStart,             element.selectionEnd);     } }    function l1485(element) {     if (   element.tagName === 'TEXTAREA'          || (   element.tagName === 'INPUT'              && element.type === 'text'))      {         const str = element.value;          element.value =                str.slice(0, element.selectionStart)              + str.slice(element.selectionEnd)     } }    function scrollbarVisible(element)  {     return element.i3101 > element.clientHeight; }    function x1486(e) {     return point(e.clientX, e.clientY); }    function v1487(div) {     const selection = window.getSelection();      if (selection.rangeCount > 0)      {         const range = selection.getRangeAt(0);                  if (   range.commonAncestorContainer === div             || div.contains(range.commonAncestorContainer))         {             const selectedText = range.toString().trim();              if (selectedText.length > 0)                 return true;         }     }      return false;  }    function a1488(div) {     var range = document.createRange();     range.selectNode(div);      window.getSelection().removeAllRanges();     window.getSelection().addRange(range);     }    function t1489(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '.gen';          input.onchange = e =>      {          const file = e.target.files[0];           const reader = new FileReader();         reader.readAsText(file,'UTF-8');          reader.onload = e => callback(e.target.result);     };       input.click(); }    function g1490(callback) {     const input = document.createElement('input');      input.type   = 'file';     input.accept = '*.*';          input.onchange = e =>      {          callback(e.target.files[0]);      };       input.click(); }    async function d1491(content, filename, contentType) {     const a    = document.createElement('a');     const file = new Blob([content], {type: contentType});      a.download = filename;     a.href     = URL.createObjectURL(file);      a.click();      await new Promise(resolve => setTimeout(resolve, 500));          URL.revokeObjectURL(a.href); }


const b1467 = [     {name: 'AliceBlue',            color: 'f0f8ff'},     {name: 'AntiqueWhite',         color: 'faebd7'},     {name: 'Aqua',                 color: '00ffff'},     {name: 'Aquamarine',           color: '7fffd4'},     {name: 'Azure',                color: 'f0ffff'},     {name: 'Beige',                color: 'f5f5dc'},     {name: 'Bisque',               color: 'ffe4c4'},     {name: 'Black',                color: '000000'},     {name: 'BlanchedAlmond',       color: 'ffebcd'},     {name: 'Blue',                 color: '0000ff'},     {name: 'BlueViolet',           color: '8a2be2'},     {name: 'Brown',                color: 'a52a2a'},     {name: 'BurlyWood',            color: 'deb887'},     {name: 'CadetBlue',            color: '5f9ea0'},     {name: 'Chartreuse',           color: '7fff00'},     {name: 'Chocolate',            color: 'd2691e'},     {name: 'Coral',                color: 'ff7f50'},     {name: 'CornflowerBlue',       color: '6495ed'},     {name: 'Cornsilk',             color: 'fff8dc'},     {name: 'Crimson',              color: 'dc143c'},     {name: 'Cyan',                 color: '00ffff'},     {name: 'DarkBlue',             color: '00008b'},     {name: 'DarkCyan',             color: '008b8b'},     {name: 'DarkGoldenRod',        color: 'b8860b'},     {name: 'DarkGray',             color: 'a9a9a9'},     {name: 'DarkGrey',             color: 'a9a9a9'},     {name: 'DarkGreen',            color: '006400'},     {name: 'DarkKhaki',            color: 'bdb76b'},     {name: 'DarkMagenta',          color: '8b008b'},     {name: 'DarkOliveGreen',       color: '556b2f'},     {name: 'DarkOrange',           color: 'ff8c00'},     {name: 'DarkOrchid',           color: '9932cc'},     {name: 'DarkRed',              color: '8b0000'},     {name: 'DarkSalmon',           color: 'e9967a'},     {name: 'DarkSeaGreen',         color: '8fbc8f'},     {name: 'DarkSlateBlue',        color: '483d8b'},     {name: 'DarkSlateGray',        color: '2f4f4f'},     {name: 'DarkSlateGrey',        color: '2f4f4f'},     {name: 'DarkTurquoise',        color: '00ced1'},     {name: 'DarkViolet',           color: '9400d3'},     {name: 'DeepPink',             color: 'ff1493'},     {name: 'DeepSkyBlue',          color: '00bfff'},     {name: 'DimGray',              color: '696969'},     {name: 'DimGrey',              color: '696969'},     {name: 'DodgerBlue',           color: '1e90ff'},     {name: 'FireBrick',            color: 'b22222'},     {name: 'FloralWhite',          color: 'fffaf0'},     {name: 'ForestGreen',          color: '228b22'},     {name: 'Fuchsia',              color: 'ff00ff'},     {name: 'Gainsboro',            color: 'dcdcdc'},     {name: 'GhostWhite',           color: 'f8f8ff'},     {name: 'Gold',                 color: 'ffd700'},     {name: 'GoldenRod',            color: 'daa520'},     {name: 'Gray',                 color: '808080'},     {name: 'Grey',                 color: '808080'},     {name: 'Green',                color: '008000'},     {name: 'GreenYellow',          color: 'adff2f'},     {name: 'HoneyDew',             color: 'f0fff0'},     {name: 'HotPink',              color: 'ff69b4'},     {name: 'IndianRed',            color: 'cd5c5c'},     {name: 'Indigo',               color: '4b0082'},     {name: 'Ivory',                color: 'fffff0'},     {name: 'Khaki',                color: 'f0e68c'},     {name: 'Lavender',             color: 'e6e6fa'},     {name: 'LavenderBlush',        color: 'fff0f5'},     {name: 'LawnGreen',            color: '7cfc00'},     {name: 'LemonChiffon',         color: 'fffacd'},     {name: 'LightBlue',            color: 'add8e6'},     {name: 'LightCoral',           color: 'f08080'},     {name: 'LightCyan',            color: 'e0ffff'},     {name: 'LightGoldenRodYellow', color: 'fafad2'},     {name: 'LightGray',            color: 'd3d3d3'},     {name: 'LightGrey',            color: 'd3d3d3'},     {name: 'LightGreen',           color: '90ee90'},     {name: 'LightPink',            color: 'ffb6c1'},     {name: 'LightSalmon',          color: 'ffa07a'},     {name: 'LightSeaGreen',        color: '20b2aa'},     {name: 'LightSkyBlue',         color: '87cefa'},     {name: 'LightSlateGray',       color: '778899'},     {name: 'LightSlateGrey',       color: '778899'},     {name: 'LightSteelBlue',       color: 'b0c4de'},     {name: 'LightYellow',          color: 'ffffe0'},     {name: 'Lime',                 color: '00ff00'},     {name: 'LimeGreen',            color: '32cd32'},     {name: 'Linen',                color: 'faf0e6'},     {name: 'Magenta',              color: 'ff00ff'},     {name: 'Maroon',               color: '800000'},     {name: 'MediumAquaMarine',     color: '66cdaa'},     {name: 'MediumBlue',           color: '0000cd'},     {name: 'MediumOrchid',         color: 'ba55d3'},     {name: 'MediumPurple',         color: '9370db'},     {name: 'MediumSeaGreen',       color: '3cb371'},     {name: 'MediumSlateBlue',      color: '7b68ee'},     {name: 'MediumSpringGreen',    color: '00fa9a'},     {name: 'MediumTurquoise',      color: '48d1cc'},     {name: 'MediumVioletRed',      color: 'c71585'},     {name: 'MidnightBlue',         color: '191970'},     {name: 'MintCream',            color: 'f5fffa'},     {name: 'MistyRose',            color: 'ffe4e1'},     {name: 'Moccasin',             color: 'ffe4b5'},     {name: 'NavajoWhite',          color: 'ffdead'},     {name: 'Navy',                 color: '000080'},     {name: 'OldLace',              color: 'fdf5e6'},     {name: 'Olive',                color: '808000'},     {name: 'OliveDrab',            color: '6b8e23'},     {name: 'Orange',               color: 'ffa500'},     {name: 'OrangeRed',            color: 'ff4500'},     {name: 'Orchid',               color: 'da70d6'},     {name: 'PaleGoldenRod',        color: 'eee8aa'},     {name: 'PaleGreen',            color: '98fb98'},     {name: 'PaleTurquoise',        color: 'afeeee'},     {name: 'PaleVioletRed',        color: 'db7093'},     {name: 'PapayaWhip',           color: 'ffefd5'},     {name: 'PeachPuff',            color: 'ffdab9'},     {name: 'Peru',                 color: 'cd853f'},     {name: 'Pink',                 color: 'ffc0cb'},     {name: 'Plum',                 color: 'dda0dd'},     {name: 'PowderBlue',           color: 'b0e0e6'},     {name: 'Purple',               color: '800080'},     {name: 'RebeccaPurple',        color: '663399'},     {name: 'Red',                  color: 'ff0000'},     {name: 'RosyBrown',            color: 'bc8f8f'},     {name: 'RoyalBlue',            color: '4169e1'},     {name: 'SaddleBrown',          color: '8b4513'},     {name: 'Salmon',               color: 'fa8072'},     {name: 'SandyBrown',           color: 'f4a460'},     {name: 'SeaGreen',             color: '2e8b57'},     {name: 'SeaShell',             color: 'fff5ee'},     {name: 'Sienna',               color: 'a0522d'},     {name: 'Silver',               color: 'c0c0c0'},     {name: 'SkyBlue',              color: '87ceeb'},     {name: 'SlateBlue',            color: '6a5acd'},     {name: 'SlateGray',            color: '708090'},     {name: 'SlateGrey',            color: '708090'},     {name: 'Snow',                 color: 'fffafa'},     {name: 'SpringGreen',          color: '00ff7f'},     {name: 'SteelBlue',            color: '4682b4'},     {name: 'Tan',                  color: 'd2b48c'},     {name: 'Teal',                 color: '008080'},     {name: 'Thistle',              color: 'd8bfd8'},     {name: 'Tomato',               color: 'ff6347'},     {name: 'Turquoise',            color: '40e0d0'},     {name: 'Violet',               color: 'ee82ee'},     {name: 'Wheat',                color: 'f5deb3'},     {name: 'White',                color: 'ffffff'},     {name: 'WhiteSmoke',           color: 'f5f5f5'},     {name: 'Yellow',               color: 'ffff00'},     {name: 'YellowGreen',          color: '9acd32'} ];


var _clipboard = '';    function n856(str)  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.writeText(str);          else          {             const prevActive = document.activeElement;             const textArea   = document.createElement('textarea');              textArea.value = str;              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus();             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('copy') ? res() : rej();                 textArea.remove();                  prevActive.focus();             });         }     }     else         _clipboard = str; }    function f857()  {     if (subscribed())     {         if (   navigator.clipboard              && window.isSecureContext)              return navigator.clipboard.readText();          else          {             let textArea = document.createElement('textarea');              textArea.style.position = 'fixed';             textArea.style.left     = '-999999px';             textArea.style.top      = '-999999px';                          document.body.appendChild(textArea);                          textArea.focus({preventScroll: true});             textArea.select();                          return new Promise((res, rej) =>              {                 document.execCommand('paste') ? res(textArea.value) : rej();                 textArea.remove();             });         }     }     else         return new Promise((res, rej) => res(_clipboard)); }


function l1043(key, tag)  {     return key.substring(0, tag.length+1) == tag + ' '; }    function m1044(key, tag) {     return key.substring(tag.length+1); }    function h1045(key) { return l1043(key, c867); } function j1046(key) { return l1043(key, f865); } function u1047(key) { return l1043(key, y866); }    function h1048(key) { return m1044(key, c867); } function k1049(key) { return m1044(key, f865); } function v1050(key) { return m1044(key, y866); }


const a957               = '\uFFFD'; const e958            = '?';      const k959           = '?'; const v960        = k959;  const NAME_SEPARATOR         = ' '; const w961       = ' > '; const   l962       = ' / '; const  g963       = ':';  const n964          = ' •'; const  p965          = ' ◇';       const  w966    = '<svg width="13" height="11" viewBox="0 1 13 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3645 1.82058L10.2676 0.599976L5.1191 8.58091L2.44314 6.06144L0.800003 7.67327L5.54161 12.1958L12.3645 1.82058Z" fill="#2AD400"/></svg>';
const h967    = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#F43D3D"/></svg>';    
 const  f968     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41674 0L4.20109 8.01592L1.50123 5.4381L0.1 6.77599L4.52397 11L11.1 0.998457Z" fill="#3FF911"/></svg>';
const b969     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="#FF3E3E"/></svg>';
 const  b970 = '<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.7157 0.893364L9.55198 0.139526L4.15187 8.47598L1.20316 5.59262L0.248535 6.5928L4.41886 10.5815L5.04702 9.60025L10.7157 0.893364Z" fill="black"/></svg>';
const s971 = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.13479 0.1521L0.1521 1.13479L3.51727 4.49997L0.152106 7.86514L1.1348 8.84783L4.49997 5.48266L7.86511 8.8478L8.8478 7.86511L5.48266 4.49997L8.84781 1.13482L7.86511 0.152129L4.49997 3.51727L1.13479 0.1521Z" fill="black"/></svg>';
 const  t972  = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41672 0L4.20107 8.01592L1.50121 5.4381L0.0999756 6.77599L4.52395 11L11.1 0.998457Z" fill="white"/></svg>';
const m973  = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
 const  k974     = '<svg width="12" height="11" viewBox="0 0 12 11" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M11.1 0.998457L9.41675 0L4.2011 8.01592L1.50124 5.4381L0.100006 6.77599L4.52398 11L11.1 0.998457Z" fill="white"/></svg>';
const h975     = '<svg width="9" height="9" viewBox="0 0 9 9" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.27273L7.72727 0L4.5 3.22728L1.27273 5.21088e-06L0 1.27273L3.22727 4.5L6.50594e-06 7.72727L1.27273 9L4.5 5.77273L7.72727 9L8.99999 7.72727L5.77272 4.5L9 1.27273Z" fill="white"/></svg>';
   function c976(color = true) {     return h3981          ? (color ? f968  : t972 )          : (color ? w966 : b970); }    function x977(color = true) {     return h3981          ? (color ? b969  : m973 )          : (color ? h967 : s971); }


function h955(nodeIds) {     let str = '';      for (let i = 0; i < nodeIds.length; i++)     {         if (i > 0) str += ', ';         str += nodeIds[i];     }      return str; }    function e956(nodes) {     let str = '';      nodes.map(n => n ? n.id : 'undefined').join(', ');                                return str; }


const r1034   = 0,       q1035 = 1,       p1036 = 2,       g1037  = 3;    class o1038 {     initial;     current;            constructor()     {         this.reset();     }            set(seed)     {         this.initial = seed;         this.current = seed;     }                rotate()     {         this.current = (this.current + 0x7ed55d16) + (this.current << 12);         this.current = (this.current ^ 0xc761c23c) ^ (this.current >> 19);         this.current = (this.current + 0x165667b1) + (this.current <<  5);         this.current = (this.current + 0xd3a2646c) ^ (this.current <<  9);         this.current = (this.current + 0xfd7046c5) + (this.current <<  3);         this.current = (this.current ^ 0xb55a4f09) ^ (this.current >> 16);     }                next()     {         const seed = this.current;         this.rotate();         return seed;     }        reset()     {         this.current = this.initial;     } };    class Noise { 	interpolation = g1037; 	clip = false;  	seed = new o1038();  	v0; 	v1; 	v2; 	v3;  	step = 0;       constructor(seed = 0)     {         this.seed.set(seed);         this.reset();     }       next(scale = 1)     {                  scale = Math.max(1, scale);          let next = this.v1;          if (this.step >= 1)         {                                   this.seed.rotate();              this.v0 = this.v1;                      this.v1 = this.v2;             this.v2 = this.v3;                      this.v3 = o1039(this.seed.current);              this.step -= 1;         }                    switch (this.interpolation)         {             case r1034:             {                 next = this.v1;                 break;             }             case q1035:             {                 next = this.v1 + this.step * (this.v2 - this.v1);                 break;             }             case p1036:             {                 const ft = this.step * Math.PI;                 const f  = (1 - Math.cos(ft)) * 0.5;                                  next = this.v1 + f * (this.v2 - this.v1);                 break;             }             case g1037:             {                 const p = (this.v3 - this.v2) - (this.v0 - this.v1);                 const q = (this.v0 - this.v1) - p;                 const r =  this.v2 - this.v0;                 const s =  this.v1;                  const val =                        p * cube(this.step)                      + q * sqr(this.step)                      + r * this.step                      + s;                  next = this.clip                      ? Math.max(0, Math.min(val, 1))                      : val;                  break;             }         }          this.step += 1 / scale;          return next;     }          reset()     {         this.seed.reset();          this.v0 = o1039(this.seed.current); this.seed.rotate();         this.v1 = o1039(this.seed.current); this.seed.rotate();         this.v2 = o1039(this.seed.current); this.seed.rotate();         this.v3 = o1039(this.seed.current); this.seed.rotate();          this.step = 0;     } }   function o1039(x) {     return x / -0x7fffffff; }


const settings = {     debugMode:                     false,              x2503:         false,     u2504:              0.35,     m3995:               500,     y2505:                     false,     m3634:            false,     v2506:                 true,     q2507:                true,     b2508:             true,     k2509:    true,     y2510:        false,     p2511:          true,     w2512:             true,     r2513:               true,     showDebugMenu:                 false,              m2514:                    false,      p2515:           false,     z2516:                 false,      l2517:           false,     d2518:              false,     y2519: true,     x2520:     true,     d2521:      true,                        g2522:             false,     f2523:               false,     k2524:                   false,      f2525:                    false,                   j2526:                    false,      j2527:                   false,      e3998:               false,      b3999:              false,     m4000:               false,                  i2528:               false,      d2529:               false,      b2530:         false,               y2531:               false,      t2532:               false,      j2533:         false,               a2534:                false,      u2535:                  false,      sessionId:                     '' };    function g3565(o3635, value) {     switch (o3635)     {         case 'debugMode':                     settings.debugMode                     = value;  break;                          case 'enableZoomedOutParams':         settings.x2503         = value;  break;         case 'minZoomForParams':              settings.u2504              = value;  break;         case 'objectBatchSize':               settings.m3995               = value;  break;         case 'showPages':                     settings.y2505                     = value;  break;         case 'showAllColorSpaces':            settings.m3634            = value;  break;         case 'showNodeIcons':                 settings.v2506                 = value;  break;         case 'showBoolValues':                settings.q2507                = value;  break;         case 'separateThousands':             settings.b2508             = value;  break;         case 'invertSimpleMathParamOrder':    settings.k2509    = value;  break;         case 'showColorLegendInMenus':        settings.y2510        = value;  break;         case 'showClearUndoWarning':          settings.p2511          = value;  break;         case 'shareUsageMetrics':             settings.w2512             = value;  break;         case 'showObjectCount':               settings.r2513               = value;  break;         case 'showDebugMenu':                 settings.showDebugMenu                 = value;  break;                                  case 'showNodeId':                    settings.m2514                    = value;  break;         case 'showTransformPoints':           settings.p2515           = value;  break;         case 'enableAsserts':                 settings.z2516                 = value;  break;          case 'showTooltipLists':              settings.d2518              = value;  break;         case 'showTooltipLongText':           settings.l2517           = value;  break;         case 'showTooltipColorInterpolation': settings.y2519 = value;  break;         case 'showTooltipColorBlindness':     settings.x2520     = value;  break;         case 'showTooltipColorContrast':      settings.d2521      = value;  break;                                       case 'logThreadMessages':             settings.g2522             = value;  break;         case 'logDataMessages':               settings.f2523               = value;  break;         case 'logMessages':                   settings.k2524                   = value;  break;          case 'logActions':                    settings.f2525                    = value;  break;         case 'logLoading':                    settings.j2526                    = value;  break;         case 'logRequests':                   settings.j2527                   = value;  break;         case 'logValueUpdates':               settings.e3998               = value;  break;         case 'logObjectUpdates':              settings.b3999              = value;  break;         case 'logStyleUpdates':               settings.m4000               = value;  break;                             case 'logRawLoadPages':               settings.i2528               = value;  break;         case 'logRawLoadNodes':               settings.d2529               = value;  break;         case 'logRawLoadConnections':         settings.b2530         = value;  break;                          case 'logRawSavePages':               settings.y2531               = value;  break;         case 'logRawSaveNodes':               settings.t2532               = value;  break;         case 'logRawSaveConnections':         settings.j2533         = value;  break;                          case 'logRawRequests':                settings.a2534                = value;  break;         case 'logRawValues':                  settings.u2535                  = value;  break;          case 'sessionId':                     settings.sessionId                     = value;  break;     }  }    function p3489(o3635, valid, value, save = true) {     switch (o3635)     {         case 'debugMode':                     z3633(valid, o3635, value, b714                    ); break;                        case 'enableZoomedOutParams':         z3633(valid, o3635, value, c640        ); break;         case 'showPages':                     z3633(valid, o3635, value, k643                    ); break;         case 'showAllColorSpaces':            z3633(valid, o3635, value, b645           ); break;         case 'showNodeIcons':                 z3633(valid, o3635, value, m646                ); break;         case 'showBoolValues':                z3633(valid, o3635, value, x648               ); break;         case 'separateThousands':             z3633(valid, o3635, value, m649            ); break;         case 'invertSimpleMathParamOrder':    z3633(valid, o3635, value, q650   ); break;         case 'showColorLegendInMenus':        z3633(valid, o3635, value, j647       ); break;         case 'showClearUndoWarning':          z3633(valid, o3635, value, j651         ); break;         case 'shareUsageMetrics':             z3633(valid, o3635, value, a652            ); break;         case 'showObjectCount':               z3633(valid, o3635, value, f654              ); break;         case 'showDebugMenu':                 z3633(valid, o3635, value, l655                ); break;                                case 'showNodeId':                    z3633(valid, o3635, value, a658                   ); break;         case 'showTransformPoints':           z3633(valid, o3635, value, r659          ); break;         case 'enableAsserts':                 z3633(valid, o3635, value, e660                ); z2516 = value; break;                  case 'showTooltipLists':              z3633(valid, o3635, value, q636             ); break;         case 'showTooltipLongText':           z3633(valid, o3635, value, j635          ); break;         case 'showTooltipColorContrast':      z3633(valid, o3635, value, x638     ); break;         case 'showTooltipColorInterpolation': z3633(valid, o3635, value, c637); break;         case 'showTooltipColorBlindness':     z3633(valid, o3635, value, g639    ); break;                                          case 'logThreadMessages':             z3633(valid, o3635, value, d715            ); break;         case 'logDataMessages':               z3633(valid, o3635, value, o716              ); break;         case 'logMessages':                   z3633(valid, o3635, value, l717                  ); break;          case 'logActions':                    z3633(valid, o3635, value, c718                   ); break;         case 'logLoading':                    z3633(valid, o3635, value, l719                   ); break;         case 'logRequests':                   z3633(valid, o3635, value, z720                  ); break;         case 'logValueUpdates':               z3633(valid, o3635, value, q721              ); break;         case 'logObjectUpdates':              z3633(valid, o3635, value, b722             ); break;         case 'logStyleUpdates':               z3633(valid, o3635, value, n723              ); break;                                case 'logRawLoadPages':               z3633(valid, o3635, value, m724              ); break;         case 'logRawLoadNodes':               z3633(valid, o3635, value, i725              ); break;         case 'logRawLoadConnections':         z3633(valid, o3635, value, c726        ); break;                                case 'logRawSavePages':               z3633(valid, o3635, value, i727              ); break;         case 'logRawSaveNodes':               z3633(valid, o3635, value, i728              ); break;         case 'logRawSaveConnections':         z3633(valid, o3635, value, h729        ); break;                                case 'logRawRequests':                z3633(valid, o3635, value, t730               ); break;         case 'logRawValues':                  z3633(valid, o3635, value, y731                 ); break;     }        if (   save         && o3635 != 'showAllColorSpaces')         n2537(o3635, g931(value)); }    function z3633(valid, setting, value, menu) {     if (valid)          settings[setting] = value;         if (setting == 'showNodeId')     {         n2448(         {             cmd:    'figUpdateShowIds',             l2772: settings.m2514         });     }       if (menu)         menu.s2843(settings[setting]); }    function updateSettingsMenus() {     b714                    .z326(settings.debugMode                    );                      c640        .s2843(settings.x2503        );     k643                    .s2843(settings.y2505                    );     b645           .s2843(settings.m3634           );     m646                .s2843(settings.v2506                );     x648               .s2843(settings.q2507               );     m649            .s2843(settings.b2508            );     q650   .s2843(settings.k2509   );     j647       .s2843(settings.y2510       );     j651         .s2843(settings.p2511         );     a652            .s2843(settings.w2512            );     f654              .s2843(settings.r2513              );     l655                .s2843(settings.showDebugMenu                );                      a658                   .s2843(settings.m2514                   );     r659          .s2843(settings.p2515          );     e660                .s2843(settings.z2516                );      q636             .s2843(settings.d2518             );     j635          .s2843(settings.l2517          );     c637.s2843(settings.y2519);     g639    .s2843(settings.x2520    );     x638     .s2843(settings.d2521     );                            d715            .s2843(settings.g2522            );     o716              .s2843(settings.f2523              );     l717                  .s2843(settings.k2524                  );      c718                   .s2843(settings.f2525                   );                        l719                   .s2843(settings.j2526                   );     z720                  .s2843(settings.j2527                  );     q721              .s2843(settings.e3998              );     b722             .s2843(settings.b3999             );     n723              .s2843(settings.m4000              );                        i725              .s2843(settings.i2528              );     i725              .s2843(settings.d2529              );     c726        .s2843(settings.b2530        );                          i727              .s2843(settings.t2532              );     i728              .s2843(settings.t2532              );     h729        .s2843(settings.j2533        );                      t730               .s2843(settings.a2534               );     y731                 .s2843(settings.u2535                 ); }    function updateMenuItemShowPages() {     k2541('showPages', g931(settings.y2505));     graph.l2049();     k186.update(); }    function updateMenuItemShowAllColorSpaces() {     k2541('showAllColorSpaces', g931(settings.m3634));      graph.nodes         .filter(n => t1172.includes(n.type))         .forEach(n => n.i3002()); }    function updateMenuItemShowNodeIcons() {     graph.nodes.forEach(n => n.i3002()); }    function updateMenuItemShowBoolValues() {     graph.nodes         .filter(n => n.params.find(p => p.type == g1086) != null)         .forEach(n => n.i3002()); }    function updateMenuItemSeparateThousands() {     graph.nodes         .filter(n => n.params.find(p => p.type == g1086) != null)         .forEach(n => n.i3002()); }    function updateMenuItemInvertSimpleMathParamOrder() {     graph.nodes         .filter(n => n.type == a1108)         .forEach(n => n.i3002()); }    function updateMenuItemShowColorLegendInMenus() {     for (const menu of t572)         menu.items.forEach(i => i.w3427()); }    function enableFeatures(sub, beta = false) {     enableMenuItem(menuItemValueName,    true, sub);     enableMenuItem(menuItemObjectName,   true, sub);     enableMenuItem(c683,        true, sub);     enableMenuItem(d685,      true, sub);     enableMenuItem(o662,   true, sub);     enableMenuItem(menuItemSaveSelected, true, sub);     enableMenuItem(t686,        true, sub);     enableMenuItem(q687,     true, sub);     enableMenuItem(f693,  true, sub);     enableMenuItem(c692,     true, sub);     enableMenuItem(q695,        true, sub);     enableMenuItem(o3448,     true, sub);     enableMenuItem(y696,   true, sub);     enableMenuItem(p697, true, sub);     enableMenuItem(v698,  true, sub);     enableMenuItem(v700,   true, sub);     enableMenuItem(d712,  true, sub);      graph.nodes.forEach(n => n.h3467(sub)); }    function enableMenuItem(menuItem, enable, sub) {     if (!menuItem) return;      menuItem.enabled = enable;     menuItem.sub     = sub;      menuItem.update(); }    function updateMenuItemShowDebugMenu() {     updateElementDisplay(w663.div, settings.showDebugMenu);      m573.update(         r989(m573.div).x + 6,         r989(m573.div).y - 4,         true); }     function updateElementDisplay(menuItem, enable) {     menuItem.style.display = enable ? 'block' : 'none'; }    function loadLocalSettings() {     d2536('debugMode'                    );              d2536('enableZoomedOutParams'        );     d2536('minZoomForParams'             );     d2536('objectBatchSize'              );     d2536('showNodeIcons'                );     d2536('showBoolValues'               );     d2536('separateThousands'            );     d2536('invertSimpleMathParamOrder'   );     d2536('showColorLegendInMenus'       );     d2536('showPages'                    );     d2536('showClearUndoWarning'         );     d2536('shareUsageMetrics'            );     d2536('showObjectCount'              );     d2536('showDebugMenu'                );              d2536('showNodeId'                   );     d2536('showTransformPoints'          );     d2536('enableAsserts'                );      d2536('showTooltipLists'             );     d2536('showTooltipLongText'          );     d2536('showTooltipColorInterpolation');     d2536('showTooltipColorBlindness'    );     d2536('showTooltipColorContrast'     );                      d2536('logThreadMessages'            );     d2536('logDataMessages'              );     d2536('logMessages'                  );      d2536('logActions'                   );                  d2536('logLoading'                   );     d2536('logRequests'                  );     d2536('logValueUpdates'              );     d2536('logObjectUpdates'             );     d2536('logStyleUpdates'              );                  d2536('logRawLoadPages'              );     d2536('logRawLoadNodes'              );     d2536('logRawLoadConnections'        );              d2536('logRawSavePages'              );     d2536('logRawSaveNodes'              );     d2536('logRawSaveConnections'        );              d2536('logRawRequests'               );     d2536('logRawValues'                 ); }


const c1051              = 'LIST#';  const g1052       = 'NLIST#'; const   r1053       = 'TLIST#'; const  u1054       = 'SLIST#';   const v1055               = 'NULL'; const b1056                = 'VAR'; const z1057          = 'VARGRP'; const b1058                   = 'START'; const r1059                  = 'REPT'; const j1060                   = 'CACHE'; const z1061                  = 'FRZ'; const l1062                   = 'TIMER'; const u1063              = 'VNAME'; const OBJECT_NAME             = 'ONAME';  const e1064                 = 'CMB'; const s1065                = 'CDENSE'; const a1066                 = 'EXTR'; const c1067               = 'SETP'; const h1068           = 'EXTRP'; const r1069                 = 'SUBLST'; const c1070                  = 'UNIQ'; const v1071            = 'REVLST'; const h1072                    = 'SORT'; const u1073                  = 'CLMN'; const q1074                    = 'CELL'; const p1075                    = 'LIST'; const w1076              = 'COUNT'; const x1077                = 'LCONT'; const c1078                  = 'SEL'; const f1079                 = 'IF'; const y1080                  = 'LSTFLT'; const f1081                  = 'DEFINE';     const w1082               = 'ANY#';   const a1083 = [     c1051,     g1052,     r1053,     u1054,     e1064,     a1066,     c1067,     h1068,     r1069,     p1075,     w1076,     x1077,     r1059 ];   const s1084 = [            c1051,     g1052,       r1053,      u1054 ];   const f1085 = [     v1055,     b1056,     z1057,     ...a1083,     s1065,     a1066,     c1067,     h1068,     r1069,     c1070,     v1071,     u1073,     h1072,     q1074,     p1075,     c1078,     f1079,     y1080,     b1058,     r1059,          f1081,     j1060,     z1061,     l1062,     u1063,     OBJECT_NAME ];   const g1086            = 'NUM#';   const o1087                  = 'NUM';    const l1088             = 'NSIGN';    const w1089         = 'ABS';    const p1090            = 'ROUND';    const p1091    = 'SMINMAX';    const f1092           = 'MINMAX';    const x1093           = 'LIM';    const f1094            = 'NCURVE';    const k1095              = 'NANISNUM'; const q1096         = 'CONST';   const b1097         = 'DATE';   const h1098         = 'SEQ';   const u1099            = 'RANGE';   const g1100             = 'WAVE';   const h1101           = 'RAND';   const m1102            = 'NOISE';   const p1103      = 'PROB';   const i1104       = 'ACCUM';   const z1105      = 'LERP';  const v1106            = 'SOLVE'; const m1107          = 'NANIM';  const a1108      = 'SMATH';   const f1109             = 'MATH';   const y1110              = 'ADD';    const d1111         = 'SUB';    const x1112         = 'MUL';    const v1113           = 'DIV';    const s1114           = 'MOD';    const d1115         = 'EXP';  const c1116          = 'NBOOL';   const l1117              = 'NOT'; const c1118              = 'AND'; const y1119               = 'OR'; const l1120              = 'XOR';  const m1121        = 'COND'; const q1122            = 'EQ'; const l1123        = 'NE'; const c1124             = 'LT'; const m1125    = 'LE'; const q1126          = 'GT'; const k1127 = 'GE';  const o1128             = 'TRIG';   const f1129              = 'SIN';    const y1130              = 'COS';    const v1131              = 'TAN'; const p1132            = 'ATAN2';  const i1133           = 'CNVANG';  const y1134 = [     f1109,     a1108,     y1110,     d1111,     x1112,     v1113,     s1114,     d1115 ];   const r1135 = [     c1116,     l1117,     c1118,     y1119,     l1120 ];   const s1136 = [     m1121,     q1122,     l1123,     c1124,     m1125,     q1126,     k1127 ];   const g1137 = [     o1128,     f1129,     y1130,     v1131,     p1132 ];   const r1138     = 'TEXT#'; const s1139           = 'TEXT'; const k1140    = 'TLEN'; const u1141      = 'TTRIM'; const o1142 = 'TSUB'; const g1143  = 'TCONT'; const x1144      = 'TCASE'; const l1145   = 'TREPL'; const s1146      = 'TJOIN'; const j1147       = 'TPAD'; const f1148   = 'TCMP'; const b1149      = 'TCHAR'; const h1150   = 'TUNI'; const f1151  = 'INDEX'; const y1152 = 'N2T'; const j1153  = 'C2T'; const i1154 = 'T2N'; const u1155  = 'T2C'; const r1156     = 'TSPLT'; const z3477      = 'TJSON'; const m1158       = 'TCSV'; const w1159     = 'FETCH'; const j1160      = 'TFILE';   const k1161 = [     g1086,     g1052,     o1087,     l1088,     w1089,     p1090,     p1091,     f1092,     x1093,     f1094,     k1095,     q1096,     b1097,     h1098,     u1099,     g1100,     h1101,     m1102,     p1103,     i1104,     z1105,     v1106,     m1107,     y1152,     b1149,     j1153,      ...y1134,     ...r1135,     ...s1136,     ...g1137,      i1133 ];   const x1162 = [     r1138,     r1053,     s1139,     k1140,     u1141,     o1142,     g1143,     x1144,     s1146,     j1147,     l1145,     f1148,     h1150,     f1151,     i1154,     u1155,     r1156,     z3477,     m1158,     w1159,     j1160 ];   const u1163        = 'COL#';   const g1164              = 'COL';    const d1165        = 'CVAL';   const o1166      = 'CCOR';   const o1167   = 'COLP3'; const w1168     = 'CCNT';   const b1169         = 'BLND';   const k1170  = 'CLERP';  const w1171        = 'CBLND';   const t1172 = [     u1163,     g1164,     o1166,     o1167,     b1169,     k1170,     w1171 ];   const k1173          = 'FILL#'; const o1174                = 'FILL'; const q1175          = [k1173, o1174];    const x1176        = 'STRK#'; const j1177              = 'STRK'; const n1178        = [x1176, j1177];    const q1179    = 'CSTOP#'; const t1180          = 'CSTOP'; const h1181    = [q1179, t1180];    const f1182      = 'GRAD#'; const m1183            = 'GRAD'; const y1184      = [f1182, m1183];    const t1185 = 'RCRN#'; const w1186       = 'RCRN'; const g1187 = [t1185, w1186];  const z1188   = 'DRSH#'; const e1189         = 'DRSH'; const z1190   = [z1188, e1189];   const r1191  = 'INSH#'; const t1192        = 'INSH'; const v1193  = [r1191, t1192];   const i1194    = 'LBLR#'; const z1195          = 'LBLR'; const x1196    = [i1194, z1195];   const t1197     = 'BBLR#'; const a1198           = 'BBLR'; const u1199     = [t1197, a1198];   const x1200    = 'MASK#'; const d1201          = 'MASK'; const m1202    = [x1200, d1201];   const d1203   = 'BLEND#'; const r1204         = 'BLEND'; const l1205   = [d1203, r1204];   const l1206 = [     ...g1187,     ...z1190,     ...v1193,     ...x1196,     ...u1199,     ...l1205,     ...m1202 ];   const o1207 = [            u1163,              k1173,          f1182,            x1176,      z1188,     r1191,       i1194,        t1197,      d1203,       x1200 ];   const v1208          = 'CSTL';     const s1209          = 'SHP#';    const w1210      = 'RECT#'; const h1211            = 'RECT';  const n1212      = [w1210, h1211];   const w1213           = 'LINE#'; const c1214                 = 'LINE';  const c1215           = [w1213, c1214];     const f1216        = 'ELPS#'; const k1217              = 'ELPS';  const w1218        = [f1216, k1217];   const m1219        = 'TRPZ#'; const g1220              = 'TRPZ'; const h1221        = [m1219, g1220];   const p1222        = 'POLY#'; const s1223              = 'POLY';  const b1224        = [p1222, s1223];     const s1225           = 'STAR#'; const c1226                 = 'STAR';  const y1227           = [s1225, c1226];     const b1228     = 'TXTS#'; const o1229           = 'TXTS';  const s1230     = [b1228, o1229];    const e1231          = 'PT#'; const j1232                = 'PT'; const s1233          = [e1231, j1232];  const t1234         = 'PCORN';  const q1235    = 'VPATH#'; const u1236          = 'VPATH';  const b1237    = [q1235, u1236];   const v1238  = 'VPT#'; const m1239        = 'VPT';  const i1240  = [v1238, m1239];   const h1241    = 'VEDGE#'; const l1242          = 'VEDGE';  const g1243    = [h1241, l1242];   const h1244  = 'VREG#'; const s1245        = 'VREG';  const e1246  = [h1244, s1245];   const x1247 = 'VNET#'; const t1248       = 'VNET';  const g1249 = [x1247, t1248];   const t1250    = 'SGRP#'; const n1251          = 'SGRP'; const x1252    = [t1250, n1251];   const n1253          = 'FRM#'; const n1254                = 'FRM'; const p1255          = [n1253, n1254];    const o1256                 = 'MOVE'; const u1257               = 'ROT'; const c1258                = 'SCALE'; const y1259                 = 'SKEW';  const j1260               = 'CENTR'; const m1261          = 'RSTX';  const n1262                = 'PLACE'; const g1263          = 'APPLY';    const a1264       = 'MESPT'; const s1265        = 'VECLEN'; const x1266        = 'CIRCEN'; const u1267      = 'INTLIN'; const c1268    = 'PTLERP'; const l1269        = 'PONPT';   const h1270              = 'BOOL'; const e1271        = 'BOOL#';  const o1272           = 'BOOLU'; const k1273        = 'BOOLS'; const e1274       = 'BOOLI'; const z1275         = 'BOOLE';   const w1276 = [     h1270,     e1271,     o1272,     k1273,     e1274,     z1275 ];   const i1277             = 'RENDER';   const k1278 = [     s1209,     u1054,     w1210,     w1213,     f1216,     m1219,     p1222,     s1225,     b1228,     e1231,     q1235,     v1238,     h1241,     h1244,     x1247,     t1250,     n1253,     e1271,     z1188,     r1191,     i1194,     t1197,     d1203,     x1200 ];   const j1279 = [     u1257,     c1258,     y1259 ];   const o1280 = [     ...k1278,      ...n1212,     ...c1215,     ...w1218,     ...h1221,     ...b1224,     ...y1227,     ...s1230,     ...s1233,        t1234,     ...b1237,     ...i1240,     ...g1243,     ...e1246,     ...g1249,     ...x1252,     ...p1255,     ...w1276,      o1256,     ...j1279,     j1260,     m1261,      n1262,     g1263,      a1264,     s1265,     x1266,     u1267,     c1268,     l1269,      i1277 ];   const e1281 = [             c1051,      g1052,        r1053,       u1054,                 g1086,             r1138,            u1163,               k1173,       q1179,         f1182,           x1176,         q1179,         f1182,              s1209,        w1210,             w1213,          f1216,          m1219,          p1222,             s1225,       b1228,            e1231,      q1235,    v1238,      h1241,    h1244,   x1247,      t1250,            n1253,     t1185,      z1188,     r1191,       i1194,        t1197,       d1203,       x1200 ];   const e1282    = 'GROUP'; const u1283   = 'GPARAM';   const u1284 = [     e1282,     u1283 ];   const f1285       = 'CMNT'; const h1286 = 'CMNTARR'; const v1287         = 'PANEL';   const f1288        = 'ACT'; const d1289 = 'BEF'; const b1290      = 'DIS'; const a1291       = 'NOC';   const y1292         = 'PARAM';     const x1293           = 'LOG';   const d1294         = 'GRAPH';   const v1295 =  [        [d1111, '−' ],     [y1110,      '+' ],     [s1114,   '%' ],     [v1113,   '/' ],      [x1112, '×' ],     [d1115, 'e<sup>x']  ];   const u1296 =  [        [d1111, '−' ],     [y1110,      '+'],     [v1113,   '/' ],      [x1112, '×'] ];    const e1297 = 0; const g1298 = 1; const p1299  = 2; const u1300 = 3;   const j1301 =  [        [e1297, 'not'],     [g1298, 'xor'],      [p1299,  'or' ],     [u1300, 'and'] ];    const u1302             = 0; const h1303    = 1; const z1304        = 2; const o1305            = 3; const y1306 = 4; const m1307          = 5;   const j1308 =  [        [u1302,             '<'],     [h1303,    '≤'],     [z1304,        '≠'],     [o1305,            '='],     [y1306, '≥'],     [m1307,          '>'] ];    const o1309  = 0; const t1310  = 1; const f1311  = 2; const j1312 = 3; const s1313 = 4; const j1314 = 5;   const e1315 =  [        [o1309,  'sin' ],     [t1310,  'cos' ],     [f1311,  'tan' ],     [j1312, 'asin'],     [s1313, 'acos'],     [j1314, 'atan'] ];    const i1316               = 'EMPTY'; const s1317             = 'CONNECT'; const l1318              = 'CREATE'; const u1319       = 'CREATE_INSERT'; const l1320              = 'DELETE'; const c1321          = 'DISCONNECT'; const p1322          = 'LINK_STYLE'; const z1323       = 'LINK_VARIABLE'; const k1324 = 'LINK_VARIABLE_GROUP'; const g1325         = 'MAKE_ACTIVE'; const f1326        = 'MAKE_PASSIVE'; const q1327               = 'PASTE'; const h1328           = 'RECONNECT'; const i1329              = 'REMOVE'; const e1330              = 'RENAME'; const r1331      = 'REORDER_INPUTS'; const b1332 = 'REORDER_CONNECTIONS'; const v1333              = 'SELECT'; const o1334         = 'SELECT_MOVE'; const f1335          = 'MOVE_NODES'; const j1336     = 'SET_PARAM_VALUE'; const x1337   = 'SET_PARAM_SETTING'; const v1338       = 'SET_NODE_RECT'; const f1339      = 'TOGGLE_DISABLE'; const g1340 = 'TOGGLE_PARAM_HEADER'; const u1341   = 'SET_CURRENT_GRAPH'; const m1342         = 'CREATE_PAGE'; const q1343         = 'DELETE_PAGE'; const k1344         = 'GROUP_NODES'; const v1345       = 'UNGROUP_NODES'; const r1346     = 'HIGHLIGHT_NODES';   const f1347               = 'BNORM'; const n1348               = 'BDARK'; const y1349             = 'BMULT'; const n1350          = 'BPDRK'; const b1351           = 'BBURN'; const t1352              = 'BLITE'; const m1353               = 'BSCRN'; const d1354         = 'BPLGT'; const s1355          = 'BDODG'; const t1356              = 'BOVER'; const v1357           = 'BSOFT'; const x1358           = 'BHARD'; const s1359           = 'BDIFF'; const j1360            = 'BEXCL'; const h1361                  = 'BHUE'; const f1362           = 'BSAT'; const a1363                = 'BCOL'; const k1364           = 'BLUM';   const b1365 = [     [f1347,       'normal',       'NORMAL'      ],     [n1348,       'darken',       'DARKEN'      ],     [y1349,     'multiply',     'MULTIPLY'    ],     [n1350,  'plus darker',  'LINEAR_BURN' ],     [b1351,   'color burn',   'COLOR_BURN'  ],     [t1352,      'lighten',      'LIGHTEN'     ],     [m1353,       'screen',       'SCREEN'      ],     [d1354, 'plus lighter', 'LINEAR_DODGE'],     [s1355,  'color dodge',  'COLOR_DODGE' ],     [t1356,      'overlay',      'OVERLAY'     ],     [v1357,   'soft light',   'SOFT_LIGHT'  ],     [x1358,   'hard light',   'HARD_LIGHT'  ],     [s1359,   'difference',   'DIFFERENCE'  ],     [j1360,    'exclusion',    'EXCLUSION'   ],     [h1361,          'hue',          'HUE'         ],     [f1362,   'saturation',   'SATURATION'  ],     [a1363,        'color',        'COLOR'       ],     [k1364,   'luminosity',   'LUMINOSITY'  ] ];    const e1366 = [     ['thin',        100],     ['extra light', 200],     ['light',       300],     ['regular',     400],     ['medium',      500],     ['semi bold',   600],     ['bold',        700],     ['extra bold',  800],     ['black',       900] ];    const o1367           =  0; const e1368        =  1;  const e1369      =  2;   const v1370     = 2; const k1371    =  3;   const x1372   = 3;  const f1373       =  4;   const n1374 = 4; const r1375         =  5;   const p1376            =  6; const z1377            =  7; const o1378            =  8;  const o1379          =  9;  const p1380          = 10; const a1381        = 11;   const c1382  = 12; const j1383   = 13; const v1384    = 14;                                     const c1385   = 15; const y1386     = 16; const p1387  = 17;  const s1388        = 18;  const w1389           = 19; const l1390      = 20;     const n1391        = 21; const z1392          = 22; const d1393           = 23;  const w1394              = 24;                                                                                                                                                                                                         const y1395 = 24; const o1396              = 25;                                     const l1397          = 26;    const f1398         = 27;                                      const i1399     = 28;   const r1400   = 28;   const c1401 = 28;   const b1402    = 28;   const j1403   = 28;   const c1404  = 28;   const c1405      = 28;   const e1406    = 28;                                 const n1407    = 29;                                        const y1408 = 29;   const l1409 = 29;   const c1410 = 29;   const u1411     = 29;   const h1412 = 29;                                 const j1413      = 30;                                        const c1414   = 30;                                 const j1415 = 30;   const e1416           = 30;                                                                                                                                                                    const w1417   = 31;                                                                                                                                        const f1418           = 31;                                                                                                                                                                                                       const h1419      = 32;                                                                                                                                                                                                       const d1420     = 33;                                                                                                                                                                                                                                                                                                                                                                                                                                            const o1421        = 34;                                                                                                                                                                                                       const w1422        = 35;                                                                                                                                                                                                                                                                                                                                                                                                                                            const h1423    = 36;                                                                                                                                                                                                       const t1424 = 37;


class k1808 {     type;          nodeId     = '';       objectId   = NULL;     objectName = NULL;      u3795  = -1;       retain     = 0;     feedback   = false;       c4185;      xp0 = null;      xp1 = null;      xp2 = null;       sp0 = null;      sp1 = null;      sp2 = null;        n3715;     scaleStyle;        constructor(type, nodeId, objectId, objectName)     {         this.type         = type;         this.nodeId       = nodeId;         this.objectId     = objectId;         this.objectName   = objectName;          this.c4185        = clone(identity);          this.n3715 = 1;         this.scaleStyle   = 1;     }        u3332(base)     {         this.u3795    = base.u3795;                  this.feedback     = base.feedback;         this.retain       = base.retain;                  this.c4185        = clone(base.c4185);          this.xp0          = clone(base.xp0);         this.xp1          = clone(base.xp1);         this.xp2          = clone(base.xp2);          this.sp0          = clone(base.sp0);         this.sp1          = clone(base.sp1);         this.sp2          = clone(base.sp2);          this.n3715 = base.n3715;         this.scaleStyle   = base.scaleStyle;     }        copy()     {         u947('invalid use of abstract method k1808.copy()');         return null;     }        getCount()     {         return 1;     }        w3717(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         let _cx;          let _cy;           if (units == 0)         {             _cx = bounds.x + cx * bounds.width;             _cy = bounds.y + cy * bounds.height;                     }         else if (units == 1)         {             _cx = bounds.x + cx;             _cy = bounds.y + cy;         }         else          {             _cx = this.x + cx;             _cy = this.y + cy;                     }           const ds1 = u894(this.sp1, this.sp0);         const ds2 = u894(this.sp2, this.sp0);          this.sp0  = point(_cx, _cy);          this.sp1  = y889(this.sp0, ds1);         this.sp2  = y889(this.sp0, ds2);     }        i4075(x, y, a = 0)     {         this.c4185 =             [[Math.cos(a), -Math.sin(a), x],              [Math.sin(a),  Math.cos(a), y],              [0,            0,           1]];     }        h3704(x, y, w, h)     {         this.xp0 = point(x,     y    );         this.xp1 = point(x + w, y    );         this.xp2 = point(x,     y + h);     }        p3706()     {         let vr = point(this.sp1.x - this.sp0.x, this.sp1.y - this.sp0.y);         let vb = point(this.sp2.x - this.sp0.x, this.sp2.y - this.sp0.y);                   let sx = vr.x;         let sy = vb.y;              let kx = vr.y;         let ky = vb.x;                  let dx = this.sp0.x;         let dy = this.sp0.y;                   let c4185 = f879(             f883(dx, dy),             [[sx, ky, 0],              [kx, sy, 0],              [0,  0,  1]]);               return c4185;     }                getBounds()     {         let bounds = v1042.NaN;          const dp = u894(this.xp1, this.xp0);          bounds = z3720(bounds, this.xp0);         bounds = z3720(bounds, this.xp1);         bounds = z3720(bounds, this.xp2);         bounds = z3720(bounds, y889(this.xp2, dp));          return bounds;     }        o4076(c4185, affectSpace)     {         const space = this.p3706();           if (this.type == j1232)         {             const p = j3705(point(this.x, this.y), c4185, space);              this.x = p.x;             this.y = p.y;              if (affectSpace)                 this.applySpaceTransform(c4185, space);         }         else if (this.type == u1236               || this.type == g1220)         {             this.applyObjectTransform(c4185, space);              this.updatePoints(c4185, space);             this.h3718();             this.w3724();              if (affectSpace)                 this.applySpaceTransform(c4185, space);         }         else if (this.type == n1251)         {             for (const c111 of this.children)             {                 c111.applyObjectTransform(c4185, space);                  if (c111.type == u1236)                     c111.updatePoints(c4185, space);                  if (affectSpace)                     c111.applySpaceTransform(c4185, space);             }                         }         else         {             this.applyObjectTransform(c4185, space);              if (affectSpace)                 this.applySpaceTransform(c4185, space);         }     }        applyObjectTransform(c4185, space)     {         if (   this.xp0.x == this.xp1.x             && this.xp0.y == this.xp1.y)             this.xp1.x += 0.000000001;          if (   this.xp0.x == this.xp2.x             && this.xp0.y == this.xp2.y)             this.xp2.y += 0.000000001;          this.xp0 = j3705(this.xp0, c4185, space);         this.xp1 = j3705(this.xp1, c4185, space);         this.xp2 = j3705(this.xp2, c4185, space);     }        applySpaceTransform(c4185, space)     {         this.sp0 = j3705(this.sp0, c4185, space);         this.sp1 = j3705(this.sp1, c4185, space);         this.sp2 = j3705(this.sp2, c4185, space);     }        g3731()     {         return {             type:       this.type,             nodeId:     this.nodeId,              objectId:   this.objectId,             objectName: this.objectName,                          feedback:   this.feedback,              xp0:        this.xp0 ? this.xp0 : null,             xp1:        this.xp1 ? this.xp1 : null,             xp2:        this.xp2 ? this.xp2 : null         };     }        o3716()     {         return [          this.type,          this.nodeId,           this.objectId,          this.objectName,                       this.feedback,          this.retain,                   this.xp0 ? this.xp0 : null,          this.xp1 ? this.xp1 : null,          this.xp2 ? this.xp2 : null,           0          ];     } }    function j3705(p, c4185, space) {     p = f878(p, m881(space));     p = f878(p, c4185);     p = f878(p, space);      return p; }    function d3712(c111) {     switch (c111.type)     {         case h1211:   return k1811 .prototype.copy.call(c111);         case c1214:        return s1807      .prototype.copy.call(c111);         case k1217:     return j1805   .prototype.copy.call(c111);         case g1220:     return h1816   .prototype.copy.call(c111);         case s1223:     return e1810   .prototype.copy.call(c111);         case c1226:        return a1814      .prototype.copy.call(c111);         case o1229:  return t1815      .prototype.copy.call(c111);         case j1232:       return f1809     .prototype.copy.call(c111);         case u1236: return a1818.prototype.copy.call(c111);         case h1270:     return q1803   .prototype.copy.call(c111);         case n1251: return q1813.prototype.copy.call(c111);         case n1254:       return m1806     .prototype.copy.call(c111);     }      u947('invalid Figma object type \'' + c111.type + '\'');     return null; }    function getPointBounds(points) {     let minX = Number.MAX_SAFE_INTEGER;     let minY = Number.MAX_SAFE_INTEGER;     let maxX = Number.MIN_SAFE_INTEGER;     let maxY = Number.MIN_SAFE_INTEGER;      for (const p of points)     {         minX = Math.min(minX, p.x.value);         minY = Math.min(minY, p.y.value);         maxX = Math.max(maxX, p.x.value);         maxY = Math.max(maxY, p.y.value);     }      return new AbsRect(minX, minY, maxX, maxY); }    function getObjBounds(objects) {     let bounds = v1042.NaN;      for (const c111 of objects)         bounds = u3719(bounds, c111.getBounds());      return bounds; }    function n2567(node, c111, zoom) {     const length = 10;          const sp0 = point(         c111.sp0.x ,          c111.sp0.y );      const sp1 = y889(sp0, r891(      u894(c111.sp1, c111.sp0),      length));     const sp2 = y889(sp0, r891(r891(u894(c111.sp2, c111.sp0), -1), length));          node.value.objects.push(         createDecoPoly(             node,              sp0,              [sp2, sp0, sp1],             false,             '',             [242, 72, 34],              n964,             true)); }    function createDecoPoly(node, center, points, closed, dashes, color, suffix, q3714) {     const path = new a1818(         node.nodeId,         node.nodeId   + suffix,         node.nodeName + suffix,         points.map(p => t1984.fromPoint(node.nodeId, p)),         closed ? 1 : 0,          0,          0,          0);       path.strokes.push([         'SOLID',          color[0],          color[1],          color[2],          100,          'NORMAL']);      path.strokeWeight =  1;     path.strokeAlign  = 'CENTER';     path.strokeJoin   = 'MITER';     path.strokeCap    = 'NONE';     path.strokeDashes =  dashes;     path.b3713       =  true;     path.q3714     =  q3714;       path.i4075(center.x, center.y);       return path; }    function u3600(value) {     return value         && value.objects         ? value.objects               .filter(o =>                       o.b3713  === false                   || o.isXform === true)               .map(o => o.copy())          : []; }


function m1788(c111, prop) {          if (prop.type ==         u1163)  t1789       (c111, prop);     else if (prop.type ==          k1173)  b1790        (c111, prop);     else if (prop.type ==      f1182)  w1791    (c111, prop);     else if (prop.type ==        x1176)  l1795      (c111, prop);     else if (prop.type == t1185)  w1796(c111, prop);     else if (prop.type ==   z1188)  u1797  (c111, prop);     else if (prop.type ==  r1191)  n1798 (c111, prop);     else if (prop.type ==    i1194)  o1799   (c111, prop);     else if (prop.type ==     t1197)  m1800    (c111, prop);     else if (prop.type ==   d1203)  w1801  (c111, prop);     else if (prop.type ==    x1200)  z1802        (c111, prop); }    function t1789(c111, prop) {     const rgb = g4119(prop.y3213());      if (c111.type == n1251)     {         for (const _obj of c111.children)             m1788(_obj, prop);     }     else     {         c111.fills.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              255   ]);     } }    function b1790(c111, prop, target = c111.fills) {     const rgb = g4119(prop.color.y3213());      if (c111.type == n1251)     {         for (const _obj of c111.children)             m1788(_obj, prop);     }     else     {         target.push([             'SOLID',              rgb[0],              rgb[1],              rgb[2],              prop.opacity.f3605().o3677(),             b1365[Math.min(Math.max(0, Math.round(prop.blend.value)), b1365.length-1)][2]]);     } }    function w1791(c111, prop, target = c111.fills)                 {     const gradient =      [         '',          [],          []       ];       switch(prop.s3661.value)     {         case 0: gradient[0] = 'GRADIENT_LINEAR';  break;         case 1: gradient[0] = 'GRADIENT_RADIAL';  break;         case 2: gradient[0] = 'GRADIENT_ANGULAR'; break;         case 3: gradient[0] = 'GRADIENT_DIAMOND'; break;     }       const isLinear   = prop.s3661.value == 0;      let   x   =        prop.x     .o3677() / 100;     let   y   =        prop.y     .o3677() / 100;     const a   =        prop.angle .o3677()/360*Tau;     let   s   = nozero(prop.size  .o3677() / 100);     let   asp = nozero(prop.aspect.o3677() / 100);     let   sk  =        prop.skew  .o3677() / 100;       if (!isLinear)     {         x -= s/2 * Math.cos(a);         y -= s/2 * Math.sin(a);          asp /= 2;     }           const p0 = point(x, y);     const p1 = y889(p0, vector(a, s));          const p2 = y889(         y889(p0, vector(a + Tau/4, s * asp)),         r891(z876(u894(p1, p0)), distance(p0, p1) * sk));       const l4184 =          [[0,   1,   0],          [0.5, 0.5, 1],          [1,   1,   1]];       let c4185 = [         [p0.x, p1.x, p2.x],         [p0.y, p1.y, p2.y],         [1,    1,    1   ]];       c4185 = f879(l4184, m881(c4185));       gradient[1] = [         c4185[0],         c4185[1] ];               const stops = w1792(prop.stops.items);          x1794(stops);       for (let j = 0; j < stops.length; j++)     {         const stop = stops[j];         const rgba = stop.fill.c99();          gradient[2].push([             rgba[0],              rgba[1],              rgba[2],              rgba[3],             Math.min(Math.max(0, stop.position.o3677() / 100), 1)]);     }       gradient[3] = b1365[prop.blend.value][2];           target.push(gradient); }    function w1792(o1793) {     const stops = [];       for (let i = 0; i < o1793.length; i++)     {         const stop = o1793[i];          if (stop.type == u1163)         {             stops.push(new g1970(                 g1974.w3748(g4119(stop.y3213()), 100),                 p1983.NaN));         }          else if (stop.type == k1173)             stops.push(new g1970(                 stop,                 p1983.NaN));          else if (stop.type == c1051)             stops.push(...w1792(stop.items));          else             stops.push(stop);     }       return stops; }    function x1794(stops) {     if (    stops.length > 0         && !stops[0].position.isValid())          stops[0].position = new p1983(0);      if (    stops.length > 1         && !stops.at(-1).position.isValid())          stops.at(-1).position = new p1983(100);           if (stops.length > 2)     {         for (let i = 1; i < stops.length-1; i++)         {             const stop = stops[i];              if (!stop.position.isValid())             {                 let prevValid = i-1;                 let nextValid = i+1;                  while ( prevValid > 0                     && !stops[prevValid].position.isValid())                      prevValid--;                  while ( nextValid < stops.length-1                     && !stops[nextValid].position.isValid())                      nextValid++;                                          const pv = stops[prevValid].position.o3677();                 const nv = stops[nextValid].position.o3677();                 stop.position = new p1983((pv + (nv - pv) * ((i - prevValid) / (nextValid - prevValid))));              }         }     } }    function l1795(c111, prop) {     for (const fill of prop.fills.items)     {         if (fill.type ==     k1173) b1790    (c111, fill, c111.strokes);         if (fill.type == f1182) w1791(c111, fill, c111.strokes);     }       if (c111.type == n1251)     {         for (const _obj of c111.children)             m1788(_obj, prop);     }     else     {         c111.strokeWeight = prop.weight.f3605().o3677();          switch (prop.fit.f3605().value)         {             case 0: c111.strokeAlign = 'INSIDE';  break;             case 1: c111.strokeAlign = 'CENTER';  break;             case 2: c111.strokeAlign = 'OUTSIDE'; break;         }          switch (prop.join.f3605().value)         {             case 0: c111.strokeJoin = 'MITER'; break;             case 1: c111.strokeJoin = 'BEVEL'; break;             case 2: c111.strokeJoin = 'ROUND'; break;         }          switch (prop.cap.f3605().value)         {             case 0: c111.strokeCap = 'NONE';   break;             case 1: c111.strokeCap = 'SQUARE'; break;             case 2: c111.strokeCap = 'ROUND';  break;         }          c111.strokeDashes     = prop.dashes.f3605().value.trim();                  c111.strokeMiterLimit = prop.miter .f3605().value;     } }    function w1796(c111, prop) {     if (c111.type == n1251)     {         for (const _obj of c111.children)             m1788(_obj, prop);     }     else     {         c111.effects.push([             'ROUND_CORNERS',              prop.tl.o3677(),             prop.tr.o3677(),             prop.bl.o3677(),             prop.br.o3677(),             prop.visible ]);     } }    function u1797(c111, prop) {     const rgba = prop.fill.c99();      c111.effects.push([         'DROP_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .o3677(),         prop.y     .o3677(),         prop.blur  .o3677(),         prop.spread.o3677(),         b1365[prop.blend.value][2],         prop.behind.value > 0,         prop.visible ]); }    function n1798(c111, prop) {     const rgba = prop.fill.c99();      c111.effects.push([         'INNER_SHADOW',          rgba[0],         rgba[1],         rgba[2],         rgba[3],         prop.x     .o3677(),         prop.y     .o3677(),         prop.blur  .o3677(),         prop.spread.o3677(),         b1365[prop.blend.value][2],         prop.visible ]); }    function o1799(c111, prop) {     c111.effects.push([         'LAYER_BLUR',          prop.radius.o3677(),         prop.visible ]); }    function m1800(c111, prop) {     c111.effects.push([         'BACKGROUND_BLUR',          prop.radius.o3677(),         prop.visible ]); }    function w1801(c111, prop) {     c111.opacity = Math.min(Math.max(0, prop.opacity.o3677() / 100), 1);     c111.blend   = b1365[prop.blend.value][2]; }    function z1802(c111, mask) {     c111.maskType = mask.maskType.value + 1; } 


class w1812 extends k1808 {     m886;     a887;      fills   = [];     strokes = [];      strokeWeight;     strokeAlign;     strokeJoin;     strokeMiterLimit;     strokeCap;     strokeDashes;      effects = [];      b3713;     q3714;     isXform;      opacity;     blend;      maskType = 0;        constructor(type, nodeId, objectId, objectName, b3713 = false, isXform = false)     {         super(type, nodeId, objectId, objectName);          this.m886    = 0;         this.a887    = 0;          this.b3713   = b3713;         this.q3714 = false;         this.isXform  = isXform;          this.opacity  = 1;         this.blend    = 'PASS_THROUGH';     }        u3332(base)     {         super.u3332(base);          this.m886            = base.m886;         this.a887            = base.a887;          this.fills            = clone(base.fills);         this.strokes          = clone(base.strokes);          this.strokeWeight     = base.strokeWeight;         this.strokeAlign      = base.strokeAlign;         this.strokeJoin       = base.strokeJoin;         this.strokeMiterLimit = base.strokeMiterLimit;         this.strokeCap        = base.strokeCap;         this.strokeDashes     = base.strokeDashes;          this.effects          = clone(base.effects);          this.b3713           = base.b3713;         this.q3714         = base.q3714;         this.isXform          = base.isXform;          this.opacity          = base.opacity;         this.blend            = base.blend;         this.maskType         = base.maskType;     }        o3716()     {         const weight = this.strokeWeight * Math.abs(this.scaleStyle);          const dashes =              this.strokeDashes             ? this.strokeDashes                 .split(',')                 .map(d => parseFloat(d.trim()) * Math.abs(this.scaleStyle))                 .join(',')             : '';                   return [             ...super.o3716(),                  this.fills,              this.strokes,               weight,              this.strokeAlign,              this.strokeJoin,              this.strokeMiterLimit,              this.strokeCap,              dashes,               this.effects,               this.b3713,              this.q3714,               this.opacity,              this.blend,              this.maskType         ];     } } 


class k1811 extends w1812 {     x;     y;     width;     height;      round;            constructor(nodeId, objectId, objectName, x, y, width, height, round)     {         super(h1211, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;          this.w3717(             x + width /2,              y + height/2);     }        copy()     {         const copy = new k1811(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round);           copy.u3332(this);           return copy;     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.n3715)         ];     } } 


class s1807 extends w1812 {     x;     y;     width;        constructor(nodeId, objectId, objectName, x, y, width)     {         super(c1214, nodeId, objectId, objectName);                  this.x     = x;         this.y     = y;         this.width = width;                   this.w3717(             x + width/2,              y);     }        copy()     {         const copy = new s1807(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width);           copy.u3332(this);           return copy;     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width         ];     } }


class j1805 extends w1812 {     x;     y;     width;     height;     round;      from;     to;     inner;            constructor(nodeId, objectId, objectName, x, y, width, height, round, from, to, inner)     {         super(k1217, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;          this.from   = from;         this.to     = to;         this.inner  = inner;                   this.w3717(             x + width /2,              y + height/2);     }        copy()     {         const copy = new j1805(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,             this.round,                          this.from,             this.to,             this.inner);           copy.u3332(this);           return copy;     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,              this.round,               this.from,              this.to,              this.inner         ];     } }


class a1818 extends w1812 {     x;     y;     width;     height;          points;     closed;     degree;      l3721;      b4009;     winding;     round;        constructor(nodeId, objectId, objectName, points, closed, degree, winding, round)     {         super(u1236, nodeId, objectId, objectName);                  this.points  = points.map(p => p.copy());          this.closed  = closed;         this.degree  = degree;         this.winding = winding;          this.round   = round;                   this.h3718();           let bounds = this.getBounds();          this.w3717(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new a1818(             this.nodeId,             this.objectId,             this.objectName,              this.points,               this.closed,              this.degree,             this.winding,              this.round);           copy.x        = this.x;         copy.y        = this.y;         copy.width    = this.width;         copy.height   = this.height;           copy.u3332(this);           return copy;     }        u3332(base)     {         super.u3332(base);          if (base.points) this.points = base.points.map(p => p.copy());     }        getBounds()     {         let bounds = v1042.NaN;                   switch (this.degree)         {             case 0:                 for (const p of this.l3721)                     bounds = z3720(bounds, p);                  break;              case 1:                 for (let i = 0; i < this.l3721.length-2; i += 2)                 {                     bounds = u3719(                         bounds,                          u853(                             this.l3721[i  ],                              this.l3721[i+1],                             this.l3721[i+2]));                 }                 break;              case 2:             case 3:             case 4:             case 5:                 for (let i = 0; i < this.l3721.length-3; i += 3)                 {                     bounds = u3719(                         bounds,                          u854(                             this.l3721[i  ],                              this.l3721[i+1],                             this.l3721[i+2],                             this.l3721[i+3]));                 }                 break;              default:                 console.error('invalid curve degree');         }           return bounds;     }        updatePoints(c4185, space)     {         for (let i = 0; i < this.points.length; i++)         {             let p      = this.points[i].q3722();             let smooth = this.points[i].smooth;              p = j3705(p, c4185, space);              this.points[i]        = t1984.fromPoint(this.nodeId, p);             this.points[i].smooth = smooth;         }     }        h3718()     {         switch (this.degree)         {         case 0: this.l3721 = this.points.map(p => p.q3722());                           break;         case 1: this.l3721 = this.points.map(p => p.q3722());                           break;         case 2: this.l3721 = this.points.map(p => p.q3722());                           break;         case 3: this.l3721 = u3728(this.points, this.closed, g4221); break;         case 4: this.l3721 = u3728(this.points, this.closed, s4222 ); break;         case 5: this.l3721 = u3728(this.points, this.closed, e4223 ); break;         }     }        w3724()     {         const bounds = this.getBounds();          this.x      = bounds.x;         this.y      = bounds.y;         this.width  = bounds.width;         this.height = bounds.height;          this.h3704(this.x, this.y, this.width, this.height);          this.b4009 = v3723(this.l3721, this.closed, this.degree);     }        o3716()     {         this.h3718();         this.w3724();           return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,               this.b4009,              this.winding,              this.round * Math.abs(this.n3715)         ];     } }    function v3723(points, closed, degree) {     for (const p of points)         if (   isNaN(p.x)             || isNaN(p.y))             return '';                   let b4009 = '';       switch (degree)     {     case 0: b4009 = l941   (points);         break;      case 1: b4009 = g3725(points, closed); break;      case 2:                                                              case 3:                                                              case 4:                                                              case 5: b4009 = x3726    (points, closed); break;      }       const w3727 =            degree == 0 && points.length > 2         || degree == 1 && points.length > 2         || degree == 2 && points.length > 3         || degree == 3 && points.length > 2         || degree == 4 && points.length > 2         || degree == 5 && points.length > 2;       if (   w3727         && (   closed             || y1013(points[0], points.at(-1))))         b4009 += ' Z';       return b4009; }    function g3725(points, closed) {     let b4009 = '';       if (points.length < 3)         return b4009;       b4009 += 'M';     b4009 += ' ' + t869(points[0].x);     b4009 += ' ' + t869(points[0].y);      let i;     for (i = 1; i < points.length-1; i += 2)     {         b4009 +=                ' Q'             + ' ' + t869(points[i  ].x)             + ' ' + t869(points[i  ].y)             + ' ' + t869(points[i+1].x)             + ' ' + t869(points[i+1].y);     }       if (   points.length - i == 1         && closed)     {         b4009 +=                ' Q'             + ' ' + t869(points.at(-1).x)             + ' ' + t869(points.at(-1).y)             + ' ' + t869(points.at( 0).x)             + ' ' + t869(points.at( 0).y);     }       return b4009; }    function x3726(points, closed) {     let b4009 = '';       if (points.length < 4)         return b4009;       b4009 += 'M';     b4009 += ' ' + t869(points[0].x);     b4009 += ' ' + t869(points[0].y);      let i;     for (i = 1; i < points.length-2; i += 3)     {         b4009 +=                ' C'             + ' ' + t869(points[i  ].x)             + ' ' + t869(points[i  ].y)             + ' ' + t869(points[i+1].x)             + ' ' + t869(points[i+1].y)             + ' ' + t869(points[i+2].x)             + ' ' + t869(points[i+2].y);     }       if (points.length - i == 2)     {         b4009 +=                ' C'             + ' ' + t869(points.at(-2).x)             + ' ' + t869(points.at(-2).y)             + ' ' + t869(points.at(-1).x)             + ' ' + t869(points.at(-1).y)             + ' ' + t869(points.at( 0).x)             + ' ' + t869(points.at( 0).y);     }       return b4009; }    function u3728(points, closed, o3729) {     if (points.length < 2)         return '';       const bp = [];            let [pp, p, pn] = o3729(         closed ? points.at(-1) : points[0],          points[0],         points[1]);      bp.push(p);       let _pp = pn;            for (let i = 1; i < points.length; i++)     {         [pp, p, pn] = o3729(             points[i-1],              points[i],             i == points.length-1              ? (closed ? points[0] : points[i])             : points[i+1]);          if (points[i].smooth)             [pp, pn] = w3730(points[i], pp, p, pn);                      bp.push(_pp, pp, p);             _pp = pn;     }       if (bp.length > 3)     {         if (closed)         {             if (   equal(bp[0].x, bp.at(-1).x, 0.01)                 && equal(bp[0].y, bp.at(-1).y, 0.01))             {                                  [pp, p, pn] = o3729(                     points.at(-2),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = w3730(points[0], pp, p, pn);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }             else             {                                  [pp, p, pn] = o3729(                     points.at(-1),                      points.at( 0),                     points.at( 1));                  if (points[0].smooth)                     [pp, pn] = w3730(points[0], pp, p, pn);                  bp.push(_pp, pp, p);                  bp[1]           = pn;                 bp[bp.length-2] = pp;             }         }         else          {             bp[1]           = y889(bp[0],     r891(z876(u894(bp[2],     bp[0]    )), distance(bp[3],     bp[0]    )/3));             bp[bp.length-2] = y889(bp.at(-1), r891(z876(u894(bp.at(-3), bp.at(-1))), distance(bp.at(-4), bp.at(-1))/3));         }     }       return bp; }    function w3730(point, pp, p, pn) {     if (point.smooth)     {         const smooth = point.smooth.value;                  pp = y889(p, r891(u894(pp, p), smooth));         pn = y889(p, r891(u894(pn, p), smooth));     }      return [pp, pn]; }    function g4221(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     let   _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);       const v = u894(_pn, _pp);               let a = t877(         angle(u894(_p, _pp)),          angle(u894(_pn, _p)));      a = Math.abs(a);     while (a >= Tau/2) a -= Tau;       const k     = 4 * (Math.sqrt(2) - 1) / 3;        // or use the value 0.55191502449 from http://spencermortensen.com/articles/bezier-circle/
	const kCorr = 0.9993391093366649465402826439248;       let f =         a > Tau/4         ? 1/3 + (k*kCorr - 1/3) * Math.sin(a)         : 1/3 + (k*kCorr - 1/3) * (1 - Math.cos(a));           let pp = y889(_p, r891(z876(v), -z875(v)/2 * f));     let pn = y889(_p, r891(z876(v),  z875(v)/2 * f));      pp = i1014(pp);      _p = i1014(_p);      pn = i1014(pn);       return [pp, _p, pn]; }    function s4222(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x - (_p.x - _pp.x) * 0.3615, _p.y);     const  pn = point(_p.x + (_pn.x - _p.x) * 0.3615, _p.y);      return [pp, _p, pn]; }    function e4223(_pointP, _point, _pointN) {     const _pp = point(_pointP.x.value, _pointP.y.value);     const _p  = point(_point .x.value, _point .y.value);     const _pn = point(_pointN.x.value, _pointN.y.value);      const  pp = point(_p.x, _p.y - (_p.y - _pp.y) * 0.3615);     const  pn = point(_p.x, _p.y + (_pn.y - _p.y) * 0.3615);      return [pp, _p, pn]; }


class l1817 extends w1812 {     x;     y;     width;     height;          points;     edges;     regions;      networkData;        constructor(nodeId, objectId, objectName, points, edges, regions)     {         super(t1248, nodeId, objectId, objectName);                  this.points  = points .map(p => p.copy());         this.edges   = edges  .map(e => e.copy());         this.regions = regions.map(r => r.copy());           this.updateNetworkData();           let bounds = v1042.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = u3719(                 bounds,                  u854(                     this.edges[i].start.q3722(),                      this.edges[i].start.q3722(),                     this.edges[i].end  .q3722(),                     this.edges[i].end  .q3722()));         }          this.w3717(             bounds.x + bounds.width /2,                         bounds.y + bounds.height/2                     );     }        copy()     {         const copy = new l1817(             this.nodeId,             this.objectId,             this.objectName,              this.points,              this.edges,              this.regions);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.u3332(this);           return copy;     }        updateNetworkData()     {         let minX = Number.MAX_SAFE_INTEGER;         let minY = Number.MAX_SAFE_INTEGER;         let maxX = Number.MIN_SAFE_INTEGER;         let maxY = Number.MIN_SAFE_INTEGER;          for (const p of this.points)         {             minX = Math.min(minX, p.x.value);             minY = Math.min(minY, p.y.value);             maxX = Math.max(maxX, p.x.value);             maxY = Math.max(maxY, p.y.value);         }           this.x      = minX;         this.y      = minY;         this.width  = maxX - minX;         this.height = maxY - minY;          this.h3704(this.x, this.y, this.width, this.height);           this.networkData = getNetworkData(this.points, this.edges, this.regions);     }        getBounds()     {         let bounds = v1042.NaN;          for (let i = 0; i < this.edges.length; i++)         {             bounds = u3719(                 bounds,                  u854(                     this.edges[i].start.q3722(),                      this.edges[i].start.q3722(),                     this.edges[i].end  .q3722(),                     this.edges[i].end  .q3722()));         }          return bounds;     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,               this.networkData         ];     } }    function getNetworkData(points, edges, _regions) {     const vertices = [];     const segments = [];     const regions  = [];       for (const point of points)     {         let join;         let cap;          switch (point.join.value)         {             case 0: join = 'MITER'; break;             case 1: join = 'BEVEL'; break;             case 2: join = 'ROUND'; break;         }              switch (point.cap.value)         {             case 0: cap = 'NONE';   break;             case 1: cap = 'SQUARE'; break;             case 2: cap = 'ROUND';  break;         }              vertices.push(         {             x:            point.x.value,             y:            point.y.value,             strokeJoin:   join,             strokeCap:    cap,             cornerRadius: point.round.value         });     }       for (const edge of edges)     {         segments.push(         {             start: points.findIndex(p => p.r3710 == edge.start.r3710),             end:   points.findIndex(p => p.r3710 == edge.end  .r3710)         });     }       for (const region of _regions)     {         const loops = [];          for (const _loop of region.loops.items)         {             const loop = [];              for (const _edge of _loop.items)                 loop.push(edges.findIndex(e => e.r3710 == _edge.r3710));              loops.push(loop);         }           regions.push(         {             windingRule: region.winding.value == 1 ? 'NONZERO' : 'EVENODD',             loops:       loops,             fills:       b950(region.fills)         });     }       let networkData =      {         vertices: vertices,         segments: segments,         regions:  regions     };       return networkData; }


class h1816 extends a1818 {     width;     height;      round;     bias;        constructor(nodeId, objectId, objectName, x, y, width, height, round, bias)     {         const tw = width * (1 + Math.min(0,  bias/100));         const bw = width * (1 + Math.min(0, -bias/100));                  const tx = x + (width - tw) / 2;         const bx = x + (width - bw) / 2;          const points =         [             t1984.create(nodeId, tx,      y         ),             t1984.create(nodeId, bx,      y + height),             t1984.create(nodeId, bx + bw, y + height),             t1984.create(nodeId, tx + tw, y         )         ];               super(             nodeId,              objectId,             objectName,              points,             1,              0,              0,              round);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.bias   = bias;                   this.w3717(             x + width /2,              y + height/2);                                                    }        copy()     {         const copy = new h1816(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.bias);           copy.x      = this.x;         copy.y      = this.y;         copy.width  = this.width;         copy.height = this.height;           copy.u3332(this);                   return copy;     } } 


class e1810 extends w1812 {     x;     y;     width;     height;     round;     corners;        constructor(nodeId, objectId, objectName, x, y, width, height, round, corners)     {         super(s1223, nodeId, objectId, objectName);                  this.x       = x;         this.y       = y;         this.width   = width;         this.height  = height;          this.round   = round;         this.corners = corners;                   this.w3717(             x + width /2,              y + height/2);     }        copy()     {         const copy = new e1810(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,                          this.round,             this.corners);           copy.u3332(this);           return copy;     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.n3715),              this.corners         ];     } } 


class a1814 extends w1812 {     x;     y;     width;     height;      round;     points;     convex;        constructor(nodeId, objectId, objectName, x, y, width, height, round, points, convex)     {         super(c1226, nodeId, objectId, objectName);                  this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;          this.round  = round;         this.points = points;         this.convex = convex;                   this.w3717(             x + width /2,              y + height/2);     }        copy()     {         const copy = new a1814(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.width,             this.height,              this.round,             this.points,             this.convex);          copy.u3332(this);          return copy;     }       o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,               this.round * Math.abs(this.n3715),              this.points,              this.convex         ];     } } 


class t1815 extends w1812 {     text;          x;     y;     width;     height;          t3732;     t3733;          font;     size;     style;          alignH;     alignV;          lineHeight;     letterSpacing;        constructor(nodeId, objectId, objectName, text, x, y, width, height, font, size, style, alignH, alignV, lineHeight, letterSpacing)     {         super(o1229, nodeId, objectId, objectName);                  this.text          = text;              this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;              this.t3732      = width;         this.t3733     = height;              this.font          = font;         this.size          = size;         this.style         = style;              this.alignH        = alignH;         this.alignV        = alignV;              this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;                   this.w3717(             x + width /2,              y + height/2);     }        copy()     {         const copy = new t1815(             this.nodeId,             this.objectId,             this.objectName,                  this.text,                  this.x,             this.y,             this.width,             this.height,                  this.font,             this.size,             this.style,                  this.alignH,             this.alignV,                  this.lineHeight,             this.letterSpacing);           copy.t3732  = this.t3732;         copy.t3733 = this.t3733;           copy.u3332(this);           return copy;     }        g3731()     {         return {             ...super.g3731(),                 x:             this.x,             y:             this.y,             width:         this.width,             height:        this.height,              t3732:      this.t3732,             t3733:     this.t3733,              text:          this.text,              font:          this.font,             size:          this.size,             style:         this.style,              alignH:        this.alignH,             alignV:        this.alignV,                          lineHeight:    this.lineHeight,             letterSpacing: this.letterSpacing         };     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,                           this.t3732,              this.t3733,                           this.text,               this.font,              this.size,              this.style,                           this.alignH,              this.alignV,                           this.lineHeight,              this.letterSpacing         ];     } } 


class f1809 extends w1812 {     x;     y;     smooth;        constructor(nodeId, objectId, objectName, x, y, smooth = 1, b3713 = false, q3714 = false, isXform = false)     {         super(j1232, nodeId, objectId, objectName, b3713, isXform);                  this.x        = x;         this.y        = y;         this.smooth   = smooth;         this.q3714 = q3714;                   this.w3717(x, y);          this.i4075(x, y);     }        copy()     {         const copy = new f1809(             this.nodeId,             this.objectId,             this.objectName,              this.x,             this.y,             this.smooth,             this.b3713,             this.q3714);          copy.u3332(this);          return copy;     }        getBounds()     {         return new v1042(             this.x - 0.005,              this.y - 0.005,              0.01,              0.01);     }        q3722()     {         return point(this.x, this.y);     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y         ];     } } 


class q1803 extends w1812 {     operation;     children;        constructor(nodeId, objectId, objectName, operation, children = [])     {         super(h1270, nodeId, objectId, objectName);                  this.operation = operation;         this.children  = children.map(c => c.copy());     }        copy()     {         const copy = new q1803(             this.nodeId,             this.objectId,             this.objectName,             this.operation,             this.children);          copy.u3332(this);          return copy;     }        g3731()     {         return {             ...super.g3731(),                 operation: this.operation,             children:  this.children         };     } }


class q1813 extends w1812 {     children;        constructor(nodeId, objectId, objectName, children = [])     {         super(n1251, nodeId, objectId, objectName);                  this.children = children.map(c => c.copy());     }        copy()     {         const copy = new q1813(             this.nodeId,             this.objectId,             this.objectName,              this.children);          copy.u3332(this);          return copy;     }        getCount()     {         let i3307 =             this.children.length > 0             ? super.getCount()             : 0;          for (const c111 of this.children)             i3307 += c111.getCount();          return i3307;     }        w3717(cx = 0, cy = 0)     {         super.w3717(cx, cy);          for (const c111 of this.children)             c111.w3717(cx, cy);     }        resetSpace(bounds, singlePoint = false, cx = 0.5, cy = 0.5, units = 0)     {         super.resetSpace(bounds, singlePoint, cx, cy, units);          for (const c111 of this.children)             c111.resetSpace(bounds, singlePoint, cx, cy, units);     }        getBounds()     {         return getObjBounds(this.children);     }        o4076(c4185, affectSpace)     {         for (const c111 of this.children)             c111.o4076(c4185, affectSpace);     }        g3731()     {         return {             ...super.g3731(),                 children: this.children         };     }        o3716()     {         return [             ...super.o3716(),                  this.children.map(o => o.o3716())         ];     } }


class m1806 extends w1812 {     x;     y;     width;     height;      round;          children;        constructor(nodeId, objectId, objectName, x, y, width, height, round, children = [])     {         super(n1254, nodeId, objectId, objectName);                  this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;              this.round    = round;              this.children = children.map(c => c.copy());          this.w3717(             x + width /2,              y + height/2);     }        copy()     {         const copy = new m1806(             this.nodeId,             this.objectId,             this.objectName,                  this.x,             this.y,             this.width,             this.height,                  this.round,                  this.children);           copy.u3332(this);           return copy;     }        getCount()     {         let i3307 = super.getCount();          for (const c111 of this.children)             i3307 += c111.getCount();          return i3307;     }            g3731()     {         return {             ...super.g3731(),                 x:        this.x,             y:        this.y,             width:    this.width,             height:   this.height,                      round:    this.round,                      children: this.children         };     }        o3716()     {         return [             ...super.o3716(),                  this.x,              this.y,              this.width,              this.height,               this.round,               this.children.map(o => o.o3716())         ];     } }    


class s1804 {     type;          nodeId = '';      styleId;     styleName;      paints = [];          constructor(nodeId, styleId, styleName)     {         this.type      = v1208;         this.nodeId    = nodeId;          this.styleId   = styleId;         this.styleName = styleName;     }        copy()     {         const copy = new s1804(this.nodeId, this.styleId, this.styleName);            return copy;     }        o3716()     {         return [          this.type,          this.nodeId,           this.styleId,          this.styleName,                   this.paints         ];     } }


class b2003 {     static nextUniqueId = 0;      type;       valid;       listId        = -1;     r3710;      cached        = true;     unknown       = false;      u3796        = NULL;      iteration     = 0;     iterated      = false;       z3067  = null;        constructor(type, options)      {         this.type    = type;          if (options && options.cached ) this.cached  = options.cached;         if (options && options.unknown) this.unknown = options.unknown;               this.r3710 = b2003.nextUniqueId++;     }        reset()     {                                                                                   this.z3067 = null;     }        copy()     {         u947('abstract type b2003 cannot be copied');         return null;     }        u3332(base)     {                  this.r3710 = base.r3710;     }        o3743()     {         if (   this.input             && this.input.o3743)             return this.input.o3743();                  return this;     }            f3605()     {         return null;     }        toString()      {          return this.type;      }        o2080()     {         return this.toString();     }        isValid()      {         return false;     }            validate()     {         this.valid = true;     }        x4065(parse)     {      }        v4066(parse, from, force = false)     {         if (   this.unknown             || force)             this.valid = false;          return true;     }        n3601(parse, nodeId)     {      }        o3602(parse, nodeId)     {      }        m4064(parse)     {      }        w3604(parse, nodeId)     {      }     } 


class j2011  {     type;     valueId;      customParams = [];       objects = null;        constructor(type)      {                   this.type = type;          this.valueId = '';     }        reset() {}        copy()     {         u947('abstract class j2011 cannot be copied');         return null;     }        u3332(base)     {                           this.valueId = base.valueId;          this.e3598(base);          if (base.objects)             this.p3599(base.objects);     }        e3598(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        p3599(objects)     {         this.objects = objects.map(o => o.copy());     }                               b3686()     {         return false;     }        f3605()     {         return this.copy();     }        o2080()      {          return this.toString();      }        toString()      {          return this.type;      }        h3680()     {         return this.toString();     }        j2819(gen)     {         u947('invalid abstract method');         return '';     }        w3331()     {         u947('invalid abstract method');         return null;     }        isCached()     {         return true;     }        x4065(parse)              {}     v4066(parse, from, force) {}     m4064     (parse)              {} }    function l3812(type, value) {     switch (type)     {         case            w1082: return parseNullValue         (value)[0];          case           c1051:          case    g1052:          case      r1053:          case     u1054: return i3455         (value)[0];          case         g1086: return d2822       (value)[0];         case           r1138: return n2837         (value)[0];         case          u1163: return r2838        (value)[0];          case           k1173: return z3651         (value)[0];         case     q1179: return m2839    (value)[0];         case       f1182: return z3650     (value)[0];         case         x1176: return e3807       (value)[0];         case    z1188: return t3808   (value)[0];         case   r1191: return j3809  (value)[0];         case     i1194: return q3810    (value)[0];         case      t1197: return a3681     (value)[0];         case    d1203: return e3682   (value)[0];         case     x1200: return p3683    (value)[0];          case      w1210: return d3685    (value)[0];         case           w1213: return i3797         (value)[0];         case        f1216: return j3798      (value)[0];         case        m1219: return j3799      (value)[0];         case        p1222: return s3800      (value)[0];         case           s1225: return b3801         (value)[0];         case     b1228: return j3802    (value)[0];         case          e1231: return a3803        (value)[0];         case    q1235: return i3644   (value)[0];         case  v1238: return s3643 (value)[0];         case    h1241: return x3641   (value)[0];         case  h1244: return j3638 (value)[0];         case x1247: return b3637(value)[0];         case        e1271: return k3804 (value)[0];         case    t1250: return s3805   (value)[0];         case          n1253: return z3806        (value)[0];                  default:              console.error('unknown type \'' + type + '\'');             return null;     } }    function m4187(type, value) {     if (   type == g1086         && value.indexOf(',') < 0)         return value;       switch (type)     {         case            w1082: return parseNullValue         (value)[0].h3680();         case           c1051: return i3455         (value)[0].h3680();          case         g1086: return d2822       (value)[0].h3680();         case           r1138: const val = n2837    (value)[0]; return val == '' ? '\'\'' : val.h3680();         case          u1163: return r2838        (value)[0].h3680();         case           k1173: return z3651         (value)[0].h3680();         case     q1179: return m2839    (value)[0].h3680();         case       f1182: return z3650     (value)[0].h3680();         case         x1176: return e3807       (value)[0].h3680();         case    z1188: return t3808   (value)[0].h3680();         case   r1191: return j3809  (value)[0].h3680();         case     i1194: return q3810    (value)[0].h3680();         case      t1197: return a3681     (value)[0].h3680();         case    d1203: return e3682   (value)[0].h3680();         case     x1200: return p3683    (value)[0].h3680();          case      w1210: return d3685    (value)[0].h3680();         case           w1213: return i3797         (value)[0].h3680();         case        f1216: return j3798      (value)[0].h3680();         case        m1219: return j3799      (value)[0].h3680();         case        p1222: return s3800      (value)[0].h3680();         case           s1225: return b3801         (value)[0].h3680();         case     b1228: return j3802    (value)[0].h3680();         case          e1231: return a3803        (value)[0].h3680();         case    q1235: return i3644   (value)[0].h3680();         case  v1238: return s3643 (value)[0].h3680();         case    h1241: return x3641   (value)[0].h3680();         case  h1244: return j3638 (value)[0].h3680();         case x1247: return b3637(value)[0].h3680();         case        e1271: return k3804 (value)[0].h3680();         case    t1250: return s3805   (value)[0].h3680();         case          n1253: return z3806        (value)[0].h3680();     }       u947('cannot display value of type \'' + type + '\''); }    function nanFromType(type) {     switch (type)     {         case            c1051: return          p1982.NaN;          case          g1086: return        p1983.NaN;         case            r1138: return        new c1994();         case           u1163: return         c1971.NaN;         case            k1173: return          g1974.NaN;         case      q1179: return     g1970.NaN;         case        f1182: return      k1976.NaN;         case          x1176: return        c1992.NaN;         case     z1188: return    t1972.NaN;         case    r1191: return   r1977.NaN;         case      i1194: return     k1979.NaN;         case       t1197: return      b1969.NaN;         case     d1203: return    i1978.NaN;         case      x1200: return     m1980.NaN;          case       w1210: return     e1986.NaN;         case            w1213: return          v1981.NaN;         case         f1216: return       g1973.NaN;         case         p1222: return       q1985.NaN;         case            s1225: return          m1991.NaN;         case      b1228: return     m1993.NaN;         case           e1231: return         t1984.NaN;         case     q1235: return    k1998.NaN;         case   v1238: return  r2000.NaN;         case     h1241: return    r1996.NaN;         case   h1244: return  w1999.NaN;         case  x1247: return j1997.NaN;         case         e1271: return  v1988.NaN;         case     t1250: return    u1989.NaN;         case           n1253: return         x1975.NaN;     }      u947('cannot determine null value from type \'' + type + '\''); }


class h2004 extends b2003 {     nodeId;     nodeName;      topLevel;      value;          customParams = [];      options      = {};     z3067 = [];               constructor(type, nodeId, options)     {         super(type, options);          this.nodeId   = nodeId;         this.nodeName = options.nodeName;          this.options  = clone(options);          this.valid    = false;         this.topLevel = false;          this.value    = null;     }        reset()     {         this.customParams = [];         this.options      = {};         this.z3067 = [];     }        u3332(base)     {         super.u3332(base);                  this.nodeId       = base.nodeId;         this.nodeName     = base.nodeName;          this.e3598(base);          this.options      = clone(base.options);          this.valid        = base.valid;         this.topLevel     = base.topLevel;          if (base.value)              this.value = base.value.copy();     }        e3598(base)     {         for (const param of base.customParams)             this.customParams.push([param[0], param[1].copy()]);     }        v4219(e2963)     {         return e2963 == 'value'             ?  this.value             :  this[e2963];     }        isCached()     {         return this.options.cached             && this.valid;     }        async eval(parse)     {                   return this;     }        async x4077(parse)     {      }        p3599(value, listId = -1)     {         const objects = u3600(value);         const copies  = [];                                  for (let i = 0; i < objects.length; i++)         {             const c111 = d3712(objects[i]);                  c111.nodeId   = this.nodeId;             c111.listId   = listId;                          c111.objectId = c111.objectId + w961 + this.nodeId;                  copies.push(c111);         }          return copies;     }                outputType()     {                  return this.value             ? new c1994(                 w951(this.value.type)                 ? q3452(this.value.items)                 : this.value.type)             : new c1994(w1082);     }        outputListType()     {         return this.outputType();                                }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.unknown)             this.valid = false;          this.iterated = false;     }        n3601(parse, nodeId)     {         this.u3796    = nodeId;         this.iteration = 0;     }        o3602(parse, nodeId)     {         this.valid = false;     }        m4064(parse)     {         const v3603 = parse.repeats.findIndex(r => r.repeatId == this.u3796);                                                                if (   (   v3603 < 0                 || v3603 == parse.repeats.length-1)             && !this.iterated)         {                          this.iteration++;             this.iterated = true;         }     }        iterateCache(parse, from)     {      }        w3604(parse, nodeId)     {         this.valid     = false;         this.iteration = 0;     }            n4078(parse, values, add = false)     {         if (    parse.repeats.length == 0             ||  this.unknown && parse.repeats[0].total == 0             || !this.unknown             ||  parse.repeats.at(-1).iteration == 0             ||  parse.repeats.at(-1).iteration == parse.repeats.at(-1).total-1)         {             if (add) this.z3067.push(...values);             else     this.z3067 = [...values];         }         else if (!add)             this.z3067 = [];     }        x4065(parse)     {         if (!this.z3067)             return;          for (const value of this.z3067)             j2023(parse, this.nodeId, value[0], value[1]);                       this.z3067 = [];     }        i4193()     {         if (   !this.value             || !this.value.objects)             return;           for (let i = 0; i < this.value.objects.length; i++)         {             const c111    = this.value.objects[i];              c111.nodeId   = this.nodeId;             c111.objectId = c111.objectId + w961 + this.nodeId;             c111.listId   = -1;         }     }                                                                      }


class r2005 extends h2004 {     input = null;        reset()     {         super.reset();          this.input = null;     }        u3332(base)     {         super.u3332(base);          if (base.input) this.input = base.input.copy();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        isValid()     {         return this.input && this.input.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.input) this.input.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.input) this.input.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.input) this.input.m4064(parse);     } }


class p2006 extends h2004 {     p4060 = null;     f4061 = null;        reset()     {         super.reset();          this.p4060 = null;         this.f4061 = null;     }        u3332(base)     {         super.u3332(base);          if (base.p4060) this.p4060 = base.p4060.copy();         if (base.f4061) this.f4061 = base.f4061.copy();     }        isCached()     {         return super.isCached()             && (!this.p4060 || this.p4060.isCached())             && (!this.f4061 || this.f4061.isCached());     }        z4067(node)     {         return this.p4060 && this.p4060.nodeId == node.nodeId             || this.f4061 && this.f4061.nodeId == node.nodeId;     }        isValid()     {         return this.p4060 && this.p4060.isValid()             && this.f4061 && this.f4061.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.p4060) this.p4060.x4065(parse);         if (this.f4061) this.f4061.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.p4060) this.p4060.v4066(parse, from, force);         if (this.f4061) this.f4061.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.p4060) this.p4060.m4064(parse);         if (this.f4061) this.f4061.m4064(parse);     } }


class l2007 extends h2004 {     p4060 = null;     f4061 = null;     d4062 = null;        reset()     {         super.reset();          this.p4060 = null;         this.f4061 = null;         this.d4062 = null;     }        u3332(base)     {         super.u3332(base);          if (base.p4060) this.p4060 = base.p4060.copy();         if (base.f4061) this.f4061 = base.f4061.copy();         if (base.d4062) this.d4062 = base.d4062.copy();     }        isCached()     {         return super.isCached()             && (!this.p4060 || this.p4060.isCached())             && (!this.f4061 || this.f4061.isCached())             && (!this.d4062 || this.d4062.isCached());     }        z4067(node)     {         return this.p4060 && this.p4060.nodeId == node.nodeId             || this.f4061 && this.f4061.nodeId == node.nodeId             || this.d4062 && this.d4062.nodeId == node.nodeId;     }        isValid()     {         return this.p4060 && this.p4060.isValid()             && this.f4061 && this.f4061.isValid()             && this.d4062 && this.d4062.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.p4060) this.p4060.x4065(parse);         if (this.f4061) this.f4061.x4065(parse);         if (this.d4062) this.d4062.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.p4060) this.p4060.v4066(parse, from, force);         if (this.f4061) this.f4061.v4066(parse, from, force);         if (this.d4062) this.d4062.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.p4060) this.p4060.m4064(parse);         if (this.f4061) this.f4061.m4064(parse);         if (this.d4062) this.d4062.m4064(parse);     } }


class w2008 extends h2004 {     p4060 = null;     f4061 = null;     d4062 = null;     a4063 = null;        reset()     {         super.reset();          this.p4060 = null;         this.f4061 = null;         this.d4062 = null;         this.a4063 = null;     }        u3332(base)     {         super.u3332(base);          if (base.p4060) this.p4060 = base.p4060.copy();         if (base.f4061) this.f4061 = base.f4061.copy();         if (base.d4062) this.d4062 = base.d4062.copy();         if (base.a4063) this.a4063 = base.a4063.copy();     }        isCached()     {         return super.isCached()             && (!this.p4060 || this.p4060.isCached())             && (!this.f4061 || this.f4061.isCached())             && (!this.d4062 || this.d4062.isCached())             && (!this.a4063 || this.a4063.isCached());     }        z4067(node)     {         return this.p4060 && this.p4060.nodeId == node.nodeId             || this.f4061 && this.f4061.nodeId == node.nodeId             || this.d4062 && this.d4062.nodeId == node.nodeId             || this.a4063 && this.a4063.nodeId == node.nodeId;     }        isValid()     {         return this.p4060 && this.p4060.isValid()             && this.f4061 && this.f4061.isValid()             && this.d4062 && this.d4062.isValid()             && this.a4063 && this.a4063.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.p4060) this.p4060.x4065(parse);         if (this.f4061) this.f4061.x4065(parse);         if (this.d4062) this.d4062.x4065(parse);         if (this.a4063) this.a4063.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.p4060) this.p4060.v4066(parse, from, force);         if (this.f4061) this.f4061.v4066(parse, from, force);         if (this.d4062) this.d4062.v4066(parse, from, force);         if (this.a4063) this.a4063.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.p4060) this.p4060.m4064(parse);         if (this.f4061) this.f4061.m4064(parse);         if (this.d4062) this.d4062.m4064(parse);         if (this.a4063) this.a4063.m4064(parse);     } }


class w2010 extends h2004 {     e2963;          node;     param;            constructor(nodeId, e2963)     {         super(y1292, nodeId, false);          this.e2963 = e2963;     }        reset()     {         if (this.node)             this.node.reset();     }        copy()     {         const copy = new w2010(this.nodeId, this.e2963);          copy.u3332(this);          copy.node = this.node;              return copy;     }        o3743()     {         return this.node              ? this.node.o3743()              : null;     }        async eval(parse)     {         this.node = parse.x4220.find(v => v.nodeId == this.nodeId);         s946(this.node, 'can\'t find parameter node \'' + this.nodeId + '\'');           if (    this.node.type != p1075             || !this.node.q4189)             await this.node.eval(parse);           this.param = this.node.v4219(this.e2963);          if (this.node.type == p1075)             this.param = this.node[this.e2963];                   if (isValid(this.param))         {             const value = (await this.param.eval(parse)).f3605();             this.value = value;                          return this.value;         }         else             return this.value = new i4194();                                                                                                                                                                  }        isCached()     {         return super.isCached();      }        f3605()     {         return this.value.copy();     }        x4065(parse)     {         super.x4065(parse);          if (this.node) this.node.x4065(parse);     }            v4066(parse, from, force)     {         super.v4066(parse, from, force);                  if (this.node) this.node.v4066(parse, from, force);     }        n3601(parse, nodeId)     {         const node = parse.x4220.find(n => n.nodeId == this.nodeId);                  node.n3601(parse, nodeId);     }        iterateCache(parse, from)     {         const node = parse.x4220.find(n => n.nodeId == from.nodeId);                  node.iterateCache(parse, from);     }        o3602(parse, nodeId)     {         const node = parse.x4220.find(n => n.nodeId == this.nodeId);                  node.o3602(parse, nodeId);     }        m4064(parse)     {         const node = parse.x4220.find(n => n.nodeId == this.nodeId);                  node.m4064(parse);     }        w3604(parse, nodeId)     {         const node = parse.x4220.find(n => n.nodeId == this.nodeId);                  node.w3604(parse, nodeId);     }                                                                                                                                                                                                 }


class i4194 extends j2011 {     value;        constructor()     {         super(w1082);          this.value = null;     }        copy()     {         const copy = new i4194();          copy.u3332(this);          return copy;     }        equals(_null)     {         return _null             && this.type  == _null.type             && this.value == _null.value;     }        async eval(parse)     {         return this;     }        b3686()     {         return true;     }        isValid()     {         return false;     }        f3605()     {         return this.copy();     }        o2080()      {          return this.toString();      }        toString()     {         return '';     }        h3679()     {         return 'NULL';     }        h3680()     {         return 'NULL';     }        j2819(gen)     {         return this.h3679();     }        w3331()     {         return this;     } }    function parseNullValue(str) {     const _null = new i4194();      return [_null, 1]; } 


class p1982 extends j2011 {     items;      condensed = false;        constructor(items = [])     {         super(c1051);          if (items)         {             this.items = [];              for (const item of items)             {                 this.items.push(item.copy());                  if (   this.objects                     && item.objects)                     this.objects.push(...item.objects.map(o => o.copy()));             }         }     }        copy()     {         const copy = new p1982(this.items);          copy.u3332(this);          copy.condensed = this.condensed;          return copy;     }        equals(list)     {         if (!list)                                  return false;         if (!(list instanceof p1982))           return false;         if (this.items.length != list.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(list.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        f3605()     {         return this.copy();     }        b3686()     {         if (!this.items)             return false;                      for (const item of this.items)             if (!item.b3686())                 return false;          return true;     }        isValid()     {                  return  this.items;              }        o2080()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.o2080();         }           return str;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        h3679()     {         if (!this.items)             return '';           const nItems = Math.min(this.items.length, 10);           let str = '';          for (let i = 0; i < nItems; i++)         {             if (i > 0)                  str += '<br/>';               const item = this.items[i];              if (w951(item.type))                              {                 for (let j = 0; j < item.items.length; j++)                 {                     if (j > 0)                          str += ', ';                                          str += item.items[j].h3679();                 }             }             else                 str += item.h3679();         }          if (this.items.length > 10)              str += '<br/>. . .';                  return str;     }        h3680()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.h3680();         }           return str;     }        w3331()     {         return p1982.NaN;     }        static NaN = Object.freeze(new p1982(null)); }    function i3455(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }                   const u3744  = i;     const w4186 = parseInt(str[i++]);               const list = new p1982();       for (let j = 0; j < w4186; j++)     {         const type = str[i++];          switch (type)         {             case         c1051:               case  g1052:               case    r1053:               case   u1054: { const _list   = i3455        (str, i);  i += _list  [1];  list.items.push(_list  [0]);  break; }               case       g1086: { const num     = d2822      (str[i]);  i += num    [1];  list.items.push(num    [0]);  break; }             case         r1138: { const text    = n2837        (str[i]);  i += text   [1];  list.items.push(text   [0]);  break; }             case        u1163: { const color   = r2838       (str, i);  i += color  [1];  list.items.push(color  [0]);  break; }              case         k1173: { const fill    = z3651        (str, i);  i += fill   [1];  list.items.push(fill   [0]);  break; }             case   q1179: { const stop    = m2839   (str, i);  i += stop   [1];  list.items.push(stop   [0]);  break; }             case     f1182: { const grad    = z3650    (str, i);  i += grad   [1];  list.items.push(grad   [0]);  break; }             case       x1176: { const stroke  = e3807      (str, i);  i += stroke [1];  list.items.push(stroke [0]);  break; }             case  z1188: { const shadow  = t3808  (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case r1191: { const shadow  = j3809 (str, i);  i += shadow [1];  list.items.push(shadow [0]);  break; }             case   i1194: { const blur    = q3810   (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case    t1197: { const blur    = a3681    (str, i);  i += blur   [1];  list.items.push(blur   [0]);  break; }             case  d1203: { const layer   = e3682  (str, i);  i += layer  [1];  list.items.push(layer  [0]);  break; }             case   x1200: { const mask    = p3683   (str[i]);  i += mask   [1];  list.items.push(mask   [0]);  break; }              case    w1210: { const rect    = d3685   (str, i);  i += rect   [1];  list.items.push(rect   [0]);  break; }             case         w1213: { const line    = i3797        (str, i);  i += line   [1];  list.items.push(line   [0]);  break; }             case      f1216: { const ellipse = j3798     (str, i);  i += ellipse[1];  list.items.push(ellipse[0]);  break; }             case      m1219: { const trapeze = j3799     (str, i);  i += trapeze[1];  list.items.push(trapeze[0]);  break; }             case      p1222: { const poly    = s3800     (str, i);  i += poly   [1];  list.items.push(poly   [0]);  break; }             case         s1225: { const star    = b3801        (str, i);  i += star   [1];  list.items.push(star   [0]);  break; }             case   b1228: { const text    = j3802   (str, i);  i += text   [1];  list.items.push(text   [0]);  break; }             case        e1231: { const point   = a3803       (str, i);  i += point  [1];  list.items.push(point  [0]);  break; }             case  q1235: { const path    = i3644  (str, i);  i += path   [1];  list.items.push(path   [0]);  break; }             case      e1271: { const bool    = k3804(str, i);  i += bool   [1];  list.items.push(bool   [0]);  break; }             case  t1250: { const group   = s3805  (str, i);  i += group  [1];  list.items.push(group  [0]);  break; }             case        n1253: { const frame   = z3806       (str, i);  i += frame  [1];  list.items.push(frame  [0]);  break; }         }     }           return [         list,          i - u3744]; }    function getItemTypes(items, debug) {     const types = [];      for (const item of items)     {         if (   item.type ==        c1051             || item.type == g1052             || item.type ==   r1053             || item.type ==  u1054)             e943(types, q3452(item.items, debug));          else             e943(types, item.type);     }      return types; }    function finalTypeFromItems(items) {     return finalTypeFromTypes(getItemTypes(items)); }    function q3452(items) {     return p3007(getItemTypes(items)); }    function finalTypeFromTypes(types) {     let _type = NULL;      for (const type of types)     {         if (_type == NULL)             _type = type;          else if (    k1278.includes(_type)                   && !k1278.includes( type))         {             _type = w1082;             break;          }     else if (   !k1278.includes(_type)                   && _type != type)         {             _type = w1082;             break;          }     }      return _type; }    function p3007(types) {     let _type = finalTypeFromTypes(types);               if (  _type == g1086 || _type == g1052)  return g1052;     else if (  _type ==   r1138 || _type ==   r1053)  return   r1053;     else if (k1278.includes(_type))                           return  u1054;     else                                                             return        c1051; }


class p1983 extends j2011 {     value;     e3764;     decimals;        constructor(val = Number.NaN, dec = -1)     {         super(g1086);          if (typeof val !== 'number')             u947('NumberValue(value) is ' + typeof val + ', must be a number');           this.value     = val;         this.e3764 = val;                  this.decimals =                !isNaN(this.value)              && dec == -1              ? r998(this.value)              : dec;     }        static fromString(str)     {         return new p1983(             parseFloat(str),             j1428(str));     }        copy()     {         const copy = new p1983(             this.value,              this.decimals);          copy.e3764 = this.e3764;          copy.u3332(this);          return copy;     }        equals(num)     {         return num             && this.value    == num.value             && this.decimals == num.decimals;     }        async eval(parse)     {         return this;     }        b3686()     {         return this.value == this.e3764;     }        isValid()     {         return !isNaN(this.value)             && !isNaN(this.decimals);     }        b3703()     {         return new p1983(Math.round(this.value));     }        o3677()     {         return f1010(this.value, this.decimals);     }        toString()     {         return y1440(this.value) + ',' + y1440(this.decimals);     }        h3679()     {         return this.isValid()              ? n1000(this.value, this.decimals)              : e958;     }        h3680()     {         return y1440(this.value)               + (!isNaN(this.decimals)                 ? '_' + this.decimals                  : '');     }        j2819(gen)     {         return this.h3679();     }        w3331()     {         return p1983.NaN;     }        static NaN = Object.freeze(new p1983(         Number.NaN,          Number.NaN)); }    function d2822(str) {     if (str.indexOf(',') < 0)     {         console.trace();         u947('number value \'' + str + '\' missing \',\'');     }           const parts = str.split(',');      const num = new p1983(         l1441(parts[0]),         l1441(parts[1]));      return [num, 1]; }    function u3811(str) {     const num =          str == e958         ? p1983.NaN         : p1983.fromString(str);      return [num, 1]; }


class c1994 extends j2011 {     value;     e3764;        constructor(val = '')     {         super(r1138);           if (   val !== null             && typeof val !== 'string')         {             console.trace();             u947('TextValue('+val+') is ' + typeof val + ', must be a string');         }                   this.value        = val;         this.e3764    = val;               }        copy()     {         const copy = new c1994(this.value);          copy.e3764 = this.e3764;                  copy.u3332(this);          return copy;     }        equals(text)     {         return text             && this.value == text.value;     }        async eval(parse)     {         return this;     }        b3686()     {         this.value == this.e3764;     }        isValid()     {         return this.value !== null;     }        o2080()     {         return encodeURIComponent(this.value);     }        toString()     {         return this.value;     }        h3679()     {         const lines = this.value.split('\n');          let str = '';          for (let i = 0; i < Math.min(lines.length, 10); i++)         {             if (i > 0)                 str += '\n';              str += lines[i];         }          if (lines.length > 10)             str += '\n. . .';                  return str;     }        h3680()     {         return '\''               + this.value.replaceAll('\n', '↵')              + '\'';     }        w3331()     {         return c1994.NaN;     }        static NaN = Object.freeze(new c1994()); }    function n2837(str) {     const text = new c1994(decodeURIComponent(str));      return [text, 1]; }


class c1971 extends j2011 {     space;     c1;     c2;     c3;        constructor(space = p1983.NaN,                  c1    = p1983.NaN,                  c2    = p1983.NaN,                  c3    = p1983.NaN)     {         super(u1163);          this.space  = space.copy();         this.c1     = c1   .copy();         this.c2     = c2   .copy();         this.c3     = c3   .copy();          this.valid  = true;     }        static create(space, c1, c2, c3)     {         s946(typeof space == 'number', 'ColorValue.create() space must be a number');         s946(typeof c1    == 'number', 'ColorValue.create() c1 must be a number');         s946(typeof c2    == 'number', 'ColorValue.create() c2 must be a number');         s946(typeof c3    == 'number', 'ColorValue.create() c3 must be a number');          return new c1971(             new p1983(space),             new p1983(c1   ),             new p1983(c2   ),             new p1983(c3   ));     }        static w3748(rgb)     {         return c1971.create(1, rgb[0], rgb[1], rgb[2]);     }        static a2778(m3170, spaceIndex = -1)     {         if (spaceIndex < 0)             spaceIndex = r4102 (m3170[0]);          const space  = a133(spaceIndex);         const factor = a4169(space);          return c1971.create(             spaceIndex,             m3170[1] * factor[0],             m3170[2] * factor[1],             m3170[3] * factor[2]);     }        copy()     {         const copy = new c1971(             this.space.copy(),              this.c1   .copy(),              this.c2   .copy(),              this.c3   .copy());          copy.u3332(this);          return copy;     }        b3686()     {         return this.space.b3686()             && this.c1   .b3686()             && this.c2   .b3686()             && this.c3   .b3686();     }        isValid()     {         return this.space.isValid()             && this.c1   .isValid()             && this.c2   .isValid()             && this.c3   .isValid();     }        equals(col)     {         return col             && this.space.equals(col.space)             && this.c1   .equals(col.c1   )             && this.c2   .equals(col.c2   )             && this.c3   .equals(col.c3   );     }        async eval(parse)     {         return this;     }        w3212()     {         if (!this.isValid())             return t3789;          const space = this.space.copy();          space.value = Math.round(Math.min(Math.max(0, space.value), l131.length-1));          return s147(             space,             this.c1,             this.c2,             this.c3);     }        y3213()     {         return c4172(this.w3212());     }        toRgbObject(limit = false)     {         const rgb = c4172(this.w3212());          if (limit && p73(rgb))             return {r: 0.5, g: 0.5, b: 0.5};                  return limit             ? { r: Math.min(Math.max(0, rgb[0]), 1),                 g: Math.min(Math.max(0, rgb[1]), 1),                 b: Math.min(Math.max(0, rgb[2]), 1) }             : { r: rgb[0],                 g: rgb[1],                 b: rgb[2] };     }        toString()     {         return      this.space.toString()             + ' ' + this.c1   .toString()             + ' ' + this.c2   .toString()             + ' ' + this.c3   .toString();     }        h3679()     {         return      this.space.h3679()             + ' ' + this.c1   .h3679()             + ' ' + this.c2   .h3679()             + ' ' + this.c3   .h3679();     }        h3680()     {         return      this.space.h3680()             + ' ' + this.c1   .h3680()             + ' ' + this.c2   .h3680()             + ' ' + this.c3   .h3680();     }        h3679()     {         if (!this.isValid())             return v960;          const rgb = this.y3213();          return '#' + m151(rgb);     }        toRgbString()     {         if (!this.isValid())             return v960;          const rgb = this.y3213();          return      rgb[0].toString()             + ' ' + rgb[1].toString()             + ' ' + rgb[2].toString();     }        w3331()     {         return c1971.NaN;     }        static NaN = Object.freeze(new c1971(         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN)); }    function r2838(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const u3744 = i;      const space = d2822(str[i]); i += space[1];     const c1    = d2822(str[i]); i += c1   [1];     const c2    = d2822(str[i]); i += c2   [1];     const c3    = d2822(str[i]); i += c3   [1];       return [         new c1971(space[0], c1[0], c2[0], c3[0]),          i - u3744 ]; }


class g1974 extends j2011 {     color;     opacity;     blend;        constructor(color   = c1971.NaN,                  opacity = new p1983(100),                 blend   = new p1983(0))     {         super(k1173);          this.color   = color  .copy();         this.opacity = opacity.copy();         this.blend   = blend  .copy();          this.valid   = true;     }            static create(r, g, b, opacity, blend = 0)     {         s946(             typeof opacity == 'number',             'opacity must be a number');          return new g1974(             c1971.create(1, r, g, b),             new p1983(opacity),             new p1983(blend));     }        static w3748(rgb, opacity, blend = 0)     {         s946(             typeof opacity == 'number',             'opacity must be a number');          return new g1974(             c1971.w3748(rgb),             new p1983(opacity),             new p1983(blend));     }        copy()     {         const copy = new g1974(             this.color  .copy(),             this.opacity.copy(),             this.blend  .copy());          copy.u3332(this);          return copy;     }        equals(fill)     {         return this.color  .equals(fill.color  )             && this.opacity.equals(fill.opacity)             && this.blend  .equals(fill.blend  );     }        async eval(parse)     {         return this;     }        c99()     {         return [             ...this.color.y3213(),             this.opacity.value / 100 ];     }                               toString()     {         const rgb = g4119(this.color.y3213());          return        new p1983(rgb[0]).toString()               + ' ' + new p1983(rgb[1]).toString()               + ' ' + new p1983(rgb[2]).toString()               + ' ' + this.opacity           .toString()               + ' ' + this.blend             .toString();     }        h3679()     {         const rgb = g4119(this.color.y3213());          return        new p1983(rgb[0]).h3679()               + ' ' + new p1983(rgb[1]).h3679()               + ' ' + new p1983(rgb[2]).h3679()               + ' ' + this.opacity           .h3679()               + ' ' + this.blend             .h3679();     }        h3680()     {         const rgb = g4119(this.color.y3213());          return        new p1983(rgb[0]).h3680()               + ' ' + new p1983(rgb[1]).h3680()               + ' ' + new p1983(rgb[2]).h3680()               + ' ' + this.opacity           .h3680()               + ' ' + this.blend             .h3680();     }        b3686()     {         return this.color  .b3686()             && this.opacity.b3686()             && this.blend  .b3686();     }        isValid()     {         return this.color  .isValid()             && this.opacity.isValid()             && this.blend  .isValid();     }        w3331()     {         return g1974.NaN;     }        static NaN = Object.freeze(new g1974(         c1971 .NaN,         p1983.NaN,         p1983.NaN));        static default = Object.freeze(g1974.create(217, 217, 217, 100)); }    function z3651(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const r  = d2822(str[i]); i += r [1];     const g  = d2822(str[i]); i += g [1];     const b  = d2822(str[i]); i += b [1];     const a  = d2822(str[i]); i += a [1];     const bl = d2822(str[i]); i += bl[1];      const color = new c1971(new p1983(1), r[0], g[0], b[0]);           return [         new g1974(color, a[0], bl[0]),         i - u3744 ]; }               


class g1970 extends j2011 {     fill;     position;        constructor(fill     = g1974.NaN,                  position = new p1983(1))     {         if (fill.type != k1173)             u947('fill.type is ' + fill.type + ', must be FILL_VALUE');           super(q1179);          this.fill     = fill    .copy();         this.position = position.copy();          this.valid    = true;     }            copy()     {         const copy = new g1970(             this.fill    .copy(),             this.position.copy());          copy.u3332(this);          return copy;     }        isValid()     {         return this.fill    .isValid()             && this.position.isValid();     }        equals(stop)     {         return stop             && this.fill    .equals(stop.fill    )             && this.position.equals(stop.position);     }        async eval(parse)     {         return this;     }        f3605()     {         return this.copy();     }        toString()     {         return      this.fill    .toString()             + ' ' + this.position.toString();     }        h3679()     {         return      this.fill    .h3679()             + ' ' + this.position.h3679();     }        h3680()     {         return      this.fill    .h3680()             + ' ' + this.position.h3680();     }        w3331()     {         return g1970.NaN;     }        static NaN = Object.freeze(new g1970(         g1974  .NaN,         p1983.NaN)); }    function m2839(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [g1970.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const fill     = z3651  (str, i); i += fill    [1];     const position = d2822(str[i]); i += position[1];       return [         new g1970(fill[0], position[0]),         i - u3744 ]; }


class k1976 extends j2011 {     stops;     s3661;     x;     y;     size;     angle;     aspect;     skew;     blend;        constructor(stops    = new p1982(),                 s3661 = new p1983(0),                 x        = new p1983(0),                 y        = new p1983(0),                 size     = new p1983(0),                 angle    = new p1983(0),                 aspect   = new p1983(0),                 skew     = new p1983(0),                 blend    = new p1983(0))     {         super(f1182);          this.stops    = stops   .copy();         this.s3661 = s3661.copy();         this.x        = x       .copy();         this.y        = y       .copy();         this.size     = size    .copy();         this.angle    = angle   .copy();         this.aspect   = aspect  .copy();         this.skew     = skew    .copy();         this.blend    = blend   .copy();          this.valid = true;     }            copy()     {         const copy = new k1976(             this.stops,             this.s3661,             this.x,             this.y,             this.size,             this.angle,             this.aspect,             this.skew,             this.blend);          copy.u3332(this);          return copy;     }        isValid()     {         return this.stops   .isValid()             && this.s3661.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.size    .isValid()             && this.angle   .isValid()             && this.aspect  .isValid()             && this.skew    .isValid()             && this.blend   .isValid();     }        equals(grad)     {         return grad             && this.stops   .equals(grad.stops   )             && this.s3661.equals(grad.s3661)             && this.x       .equals(grad.x       )             && this.y       .equals(grad.y       )             && this.size    .equals(grad.size    )             && this.angle   .equals(grad.angle   )             && this.aspect  .equals(grad.aspect  )             && this.skew    .equals(grad.skew    )             && this.blend   .equals(grad.blend   );     }        async eval(parse)     {         return this;     }        f3605()     {         return this.copy();     }        toString()     {         return      this.stops   .toString()             + ' ' + this.s3661.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.size    .toString()             + ' ' + this.angle   .toString()             + ' ' + this.aspect  .toString()             + ' ' + this.skew    .toString()             + ' ' + this.blend   .toString();     }        c99()     {         return this.stops.length > 0              ? this.stops[0].fill.c99()              : rgba_NaN;     }            h3679()     {         return      this.stops   .h3679()             + ' ' + this.s3661.h3679()             + ' ' + this.x       .h3679()             + ' ' + this.y       .h3679()             + ' ' + this.size    .h3679()             + ' ' + this.angle   .h3679()             + ' ' + this.aspect  .h3679()             + ' ' + this.skew    .h3679()             + ' ' + this.blend   .h3679();     }        h3680()     {         return      this.stops   .h3680()             + ' ' + this.s3661.h3680()             + ' ' + this.x       .h3680()             + ' ' + this.y       .h3680()             + ' ' + this.size    .h3680()             + ' ' + this.angle   .h3680()             + ' ' + this.aspect  .h3680()             + ' ' + this.skew    .h3680()             + ' ' + this.blend   .h3680();     }        w3331()     {         return k1976.NaN;     }        static NaN = Object.freeze(new k1976(         p1982  .NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN));                                  }    function z3650(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [k1976.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const stops    = i3455  (str, i); i += stops   [1];     const s3661 = d2822(str[i]); i += s3661[1];     const x        = d2822(str[i]); i += x       [1];     const y        = d2822(str[i]); i += y       [1];     const size     = d2822(str[i]); i += size    [1];     const angle    = d2822(str[i]); i += angle   [1];     const aspect   = d2822(str[i]); i += aspect  [1];     const skew     = d2822(str[i]); i += skew    [1];     const blend    = d2822(str[i]); i += blend   [1];       return [         new k1976(stops[0], s3661[0], x[0], y[0], size[0], angle[0], aspect[0], skew[0], blend[0]),         i - u3744 ]; }


class c1992 extends j2011 {     fills;     weight;     fit;     join;     miter;     cap;     dashes;        constructor(fills  = new p1982(),                  weight = new p1983(1),                 fit    = new p1983(0),                 join   = new p1983(0),                 miter  = new p1983(28.96, 2),                 cap    = new p1983(0),                 dashes = new c1994())     {         if (fills.type != c1051)             u947('fill.type is ' + fills.type + ', must be LIST_VALUE');           super(x1176);          this.fills  = fills .copy();         this.weight = weight.copy();         this.fit    = fit   .copy();         this.join   = join  .copy();         this.miter  = miter .copy();         this.cap    = cap   .copy();         this.dashes = dashes.copy();          this.valid  = true;     }            copy()     {         const copy = new c1992(             this.fills .copy(),             this.weight.copy(),             this.fit   .copy(),             this.join  .copy(),             this.miter .copy(),             this.cap   .copy(),             this.dashes.copy());          copy.u3332(this);          return copy;     }        b3686()     {         return this.fills .b3686()             && this.weight.b3686()             && this.fit   .b3686()             && this.join  .b3686()             && this.miter .b3686()             && this.cap   .b3686()             && this.dashes.b3686();     }        isValid()     {         return this.fills .isValid()             && this.weight.isValid()             && this.fit   .isValid()             && this.join  .isValid()             && this.miter .isValid()             && this.cap   .isValid()             && this.dashes.isValid();     }        equals(stroke)     {         return stroke             && this.fills .equals(stroke.fill  )             && this.weight.equals(stroke.weight)             && this.fit   .equals(stroke.fit   )             && this.join  .equals(stroke.join  )             && this.miter .equals(stroke.miter )             && this.cap   .equals(stroke.cap   )             && this.dashes.equals(stroke.dashes);     }        async eval(parse)     {         return this;     }        f3605()     {         return this.copy();     }        toString()     {         return      this.fills .toString()             + ' ' + this.weight.toString()             + ' ' + this.fit   .toString()             + ' ' + this.join  .toString()             + ' ' + this.miter .toString()             + ' ' + this.cap   .toString()             + ' ' + this.dashes.toString();     }        h3679()     {         return      this.fills .h3679()             + ' ' + this.weight.h3679()             + ' ' + this.fit   .h3679()             + ' ' + this.join  .h3679()             + ' ' + this.miter .h3679()             + ' ' + this.cap   .h3679()             + ' ' + this.dashes.h3679();     }        h3680()     {         return      this.fills .h3680()             + ' ' + this.weight.h3680()             + ' ' + this.fit   .h3680()             + ' ' + this.join  .h3680()             + ' ' + this.miter .h3680()             + ' ' + this.cap   .h3680()             + ' ' + this.dashes.h3680();     }        w3331()     {         return c1992.NaN;     }        static NaN = Object.freeze(new c1992(         new p1982(),         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         new c1994()));        static default = Object.freeze(new c1992(         new p1982(),         new p1983(1),         new p1983(0),         new p1983(0),         new p1983(28.96),         new p1983(0),         new c1994())); }    function e3807(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [c1992.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const fills  = i3455  (str, i); i += fills [1];     const weight = d2822(str[i]); i += weight[1];     const fit    = d2822(str[i]); i += fit   [1];     const join   = d2822(str[i]); i += join  [1];     const miter  = d2822(str[i]); i += miter [1];     const cap    = d2822(str[i]); i += cap   [1];     const dashes = n2837  (str[i]); i += dashes[1];      return [          new c1992(             fills [0],              weight[0],              fit   [0],              join  [0],              miter [0],              cap   [0],              dashes[0]),                  i - u3744 ]; } 


class w1987 extends j2011 {     tl;     tr;     bl;     br;     visible;        constructor(tl = new p1983(0),                  tr = new p1983(0),                  bl = new p1983(0),                  br = new p1983(0),                  visible = true)     {         super(t1185);          this.tl      = tl;         this.tr      = tr;         this.bl      = bl;         this.br      = br;         this.visible = visible;     }            copy()     {         const copy = new w1987(             this.tl.copy(),             this.tr.copy(),             this.bl.copy(),             this.br.copy(),             this.visible);          copy.u3332(this);          return copy;     }        equals(corners)     {         return this.tl.equals(corners.tl)             && this.tr.equals(corners.tr)             && this.bl.equals(corners.bl)             && this.br.equals(corners.br)             && this.visible === corners.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.tl.toString()             + ' ' + this.tr.toString()             + ' ' + this.bl.toString()             + ' ' + this.br.toString();     }        h3679()     {         return      this.tl.h3679()             + ' ' + this.tr.h3679()             + ' ' + this.bl.h3679()             + ' ' + this.br.h3679();     }        h3680()     {         return      this.tl.h3680()             + ' ' + this.tr.h3680()             + ' ' + this.bl.h3680()             + ' ' + this.br.h3680();     }        isValid()     {         return this.tl.isValid()             && this.tr.isValid()             && this.bl.isValid()             && this.br.isValid();     }        w3331()     {         return w1987.NaN;     }        static NaN = Object.freeze(new w1987(         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         false)); }    function y3813(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [w1987.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const tl = d2822(str[i]); i += tl[1];     const tr = d2822(str[i]); i += tr[1];     const bl = d2822(str[i]); i += bl[1];     const br = d2822(str[i]); i += br[1];       const corners = new w1987(         tl[0],         tr[0],         bl[0],         br[0]);       return [corners, i - u3744]; } 


class t1972 extends j2011 {     x;     y;     blur;     spread;     fill;     blend;     behind;     visible;        constructor(x       = new p1983(0),                  y       = new p1983(0),                  blur    = new p1983(0),                  spread  = new p1983(0),                  fill    = g1974.NaN,                 blend   = new p1983(0),                 behind  = new p1983(0),                 visible = true)     {         super(z1188);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.behind  = behind;         this.visible = visible;                  s946(fill.type == k1173, 'fill.type must be FILL_VALUE');     }                                             copy()     {         const copy = new t1972(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.behind.copy(),             this.visible);          copy.u3332(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.behind.equals(shadow.behind)             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString()             + ' ' + this.behind.toString();     }        h3679()     {         return      this.x     .h3679()             + ' ' + this.y     .h3679()             + ' ' + this.blur  .h3679()             + ' ' + this.spread.h3679()             + ' ' + this.fill  .h3679()             + ' ' + this.blend .h3679()             + ' ' + this.behind.h3679();     }        h3680()     {         return      this.x     .h3680()             + ' ' + this.y     .h3680()             + ' ' + this.blur  .h3680()             + ' ' + this.spread.h3680()             + ' ' + this.fill  .h3680()             + ' ' + this.blend .h3680()             + ' ' + this.behind.h3680();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid()             && this.behind.isValid();     }        w3331()     {         return t1972.NaN;     }        static NaN = Object.freeze(new t1972(         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         g1974 .NaN,         p1983.NaN,         p1983.NaN,         false));        }    function t3808(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [t1972.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x      = d2822(str[i]); i += x     [1];     const y      = d2822(str[i]); i += y     [1];     const blur   = d2822(str[i]); i += blur  [1];     const spread = d2822(str[i]); i += spread[1];     const fill   = z3651  (str, i); i += fill  [1];     const blend  = d2822(str[i]); i += blend [1];     const behind = d2822(str[i]); i += behind[1];       const shadow = new t1972(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0],         behind[0]);       return [shadow, i - u3744]; } 


class r1977 extends j2011 {     x;     y;     blur;     spread;     fill;     blend;     visible;        constructor(x       = new p1983(0),                  y       = new p1983(0),                  blur    = new p1983(0),                  spread  = new p1983(0),                  fill    = g1974.NaN,                 blend   = new p1983(0),                 visible = true)     {         super(r1191);          this.x       = x;         this.y       = y;         this.blur    = blur;         this.spread  = spread;         this.fill    = fill;         this.blend   = blend;         this.visible = visible;     }                                             copy()     {         const copy = new r1977(             this.x     .copy(),             this.y     .copy(),             this.blur  .copy(),             this.spread.copy(),             this.fill  .copy(),             this.blend .copy(),             this.visible);          copy.u3332(this);          return copy;     }        equals(shadow)     {         return this.x     .equals(shadow.x     )             && this.y     .equals(shadow.y     )             && this.blur  .equals(shadow.blur  )             && this.spread.equals(shadow.spread)             && this.fill  .equals(shadow.fill  )             && this.blend .equals(shadow.blend )             && this.visible === shadow.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.blur  .toString()             + ' ' + this.spread.toString()             + ' ' + this.fill  .toString()             + ' ' + this.blend .toString();     }        h3679()     {         return      this.x     .h3679()             + ' ' + this.y     .h3679()             + ' ' + this.blur  .h3679()             + ' ' + this.spread.h3679()             + ' ' + this.fill  .h3679()             + ' ' + this.blend .h3679();     }        h3680()     {         return      this.x     .h3680()             + ' ' + this.y     .h3680()             + ' ' + this.blur  .h3680()             + ' ' + this.spread.h3680()             + ' ' + this.fill  .h3680()             + ' ' + this.blend .h3680();     }        isValid()     {         return this.x     .isValid()             && this.y     .isValid()             && this.blur  .isValid()             && this.spread.isValid()             && this.fill  .isValid()             && this.blend .isValid();     }        w3331()     {         return r1977.NaN;     }        static NaN = Object.freeze(new r1977(         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         g1974 .NaN,         p1983.NaN,         false));         }    function j3809(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [r1977.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x      = d2822(str[i]); i += x     [1];     const y      = d2822(str[i]); i += y     [1];     const blur   = d2822(str[i]); i += blur  [1];     const spread = d2822(str[i]); i += spread[1];     const fill   = z3651  (str, i); i += fill  [1];     const blend  = d2822(str[i]); i += blend [1];       const shadow = new r1977(         x     [0],         y     [0],         blur  [0],         spread[0],         fill  [0],         blend [0]);       return [shadow, i - u3744]; } 


class k1979 extends j2011 {     radius;     visible;        constructor(radius  = new p1983(0),                  visible = true)     {         super(i1194);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new k1979(             this.radius.copy(),             this.visible);          copy.u3332(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        h3679()     {         return this.radius.h3679();     }        h3680()     {         return this.radius.h3680();     }        isValid()     {         return this.radius.isValid();     }        w3331()     {         return k1979.NaN;     }        static NaN = Object.freeze(new k1979(         p1983.NaN,         false));         }    function q3810(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [k1979.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const radius = d2822(str[i]); i += radius[1];       const shadow = new k1979(         radius[0]);       return [shadow, i - u3744]; } 


class b1969 extends j2011 {     radius;     visible;        constructor(radius  = new p1983(0),                 visible = true)     {         super(t1197);          this.radius  = radius;         this.visible = visible;     }                                             copy()     {         const copy = new b1969(             this.radius.copy(),             this.visible);          copy.u3332(this);          return copy;     }        equals(blur)     {         return this.radius.equals(blur.radius)             && this.visible === blur.visible;     }        async eval(parse)     {         return this;     }                                                                toString()     {         return this.radius.toString();     }        h3679()     {         return this.radius.h3679();     }        h3680()     {         return this.radius.h3680();     }        isValid()     {         return this.radius.isValid();     }        w3331()     {         return b1969.NaN;     }        static NaN = Object.freeze(new b1969(         p1983.NaN,         false));         }    function a3681(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [b1969.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const radius = d2822(str[i]); i += radius[1];       const shadow = new b1969(         radius[0]);       return [shadow, i - u3744]; } 


class i1978 extends j2011 {     opacity;     blend;        constructor(opacity, blend)     {         super(d1203);          this.opacity = opacity.copy();         this.blend   = blend  .copy();     }            copy()     {         const copy = new i1978(this.opacity, this.blend);          copy.u3332(this);          return copy;     }        equals(layer)     {         return this.opacity.equals(layer.opacity)             && this.blend  .equals(layer.blend  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.opacity.toString()             + ' ' + this.blend  .toString();     }        h3679()     {         return      this.opacity.h3679()             + ' ' + this.blend  .h3679();     }        h3680()     {         return      this.opacity.h3680()             + ' ' + this.blend  .h3680();     }        b3686()     {         return this.opacity.b3686()             && this.blend  .b3686();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        w3331()     {         return i1978.NaN;     }        static NaN = Object.freeze(new i1978(p1983.NaN, p1983.NaN)); }    function e3682(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [i1978.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const opacity = d2822(str[i]); i += opacity[1];     const blend   = d2822(str[i]); i += blend  [1];       const layer = new i1978(         opacity[0],         blend  [0]);               return [layer, i - u3744]; } 


class m1980 extends j2011 {     visible;     maskType;        constructor(maskType, visible = true)     {         super(x1200);          this.visible  = visible;         this.maskType = maskType.copy();     }            copy()     {         const copy = new m1980(this.maskType, this.visible);          copy.u3332(this);          return copy;     }        equals(mask)     {         return this.visible === mask.visible             && this.maskType.equals(mask.maskType);     }        async eval(parse)     {         return this;     }        toString()     {         return 'mask';     }        h3679()     {         return 'mask';     }        h3680()     {         return 'mask';     }        isValid()     {         return this.maskType.isValid();     }        w3331()     {         return m1980.NaN;     }        static NaN = Object.freeze(new m1980(p1983.NaN, false)); }    function p3683(str) {     const mask =          str == e958         ? m1980.NaN         : new m1980(new p1983(parseInt(str)), true);      return [mask, 1]; } 


  class o1990 extends j2011 {     nodeId;      props = null;        constructor(type, nodeId)     {         super(type);          this.nodeId = nodeId;           this.objects = [];     }        u3332(base)     {         super.u3332(base);                  this.nodeId  = base.nodeId;          this.objects = base.objects.map(o => o.copy());          if (base.props) this.props = base.props.copy();     }        b3686()     {         return !this.props             ||  this.props.b3686();     }        isValid()     {         return !this.props             ||  this.props.isValid();     } }    function b3684(str, i, c111) {     const props = i3455(str, i); i += props[1];      c111.props = props[0];      return i; }


class e1986 extends o1990 {     x;     y;     width;     height;     round;        constructor(nodeId,                 x      = new p1983(0),                  y      = new p1983(0),                  width  = new p1983(0),                  height = new p1983(0),                  round  = new p1983(0))     {         super(w1210, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;     }        copy()     {         const copy = new e1986(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy());          copy.u3332(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + super.toString();     }        h3679()     {         return 'rectangle';                                                                      }        h3680()     {         return      this.x     .h3680()             + ' ' + this.y     .h3680()             + ' ' + this.width .h3680()             + ' ' + this.height.h3680()             + ' ' + this.round .h3680();     }        f3605()     {         return this.copy();     }        b3686()     {         return super.b3686()             && this.x     .b3686()             && this.y     .b3686()             && this.width .b3686()             && this.height.b3686()             && this.round .b3686();     }        isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid();     }            static NaN = new e1986(         '',         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function d3685(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [e1986.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x      = d2822(str[i]); i += x     [1];     const y      = d2822(str[i]); i += y     [1];     const width  = d2822(str[i]); i += width [1];     const height = d2822(str[i]); i += height[1];     const round  = d2822(str[i]); i += round [1];       const rect = new e1986(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0]);       i = b3684(str, i, rect);           return [rect, i - u3744]; } 


class v1981 extends o1990 {     x;     y;     width;        constructor(nodeId,                 x      = new p1983(0),                  y      = new p1983(0),                  width  = new p1983(0))     {         super(w1213, nodeId);          this.x     = x;         this.y     = y;         this.width = width;     }        copy()     {         const copy = new v1981(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.width.copy());          copy.u3332(this);          return copy;     }        equals(line)     {         return line             && this.x    .equals(line.x    )             && this.y    .equals(line.y    )             && this.width.equals(line.width);     }        async eval(parse)     {         return this;     }        b3686()     {         return super.b3686()             && this.x     .b3686()             && this.y     .b3686()             && this.width .b3686();     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.width.isValid();     }        f3605()     {         return this.copy();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.width.toString()             + ' ' + super.toString();     }        h3679()     {         return      this.x    .h3679()             + ' ' + this.y    .h3679()             + ' ' + this.width.h3679();     }        h3680()     {         return      this.x    .h3680()             + ' ' + this.y    .h3680()             + ' ' + this.width.h3680();     }        static NaN = new v1981(         '',         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function i3797(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [v1981.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x     = d2822(str[i]); i += x    [1];     const y     = d2822(str[i]); i += y    [1];     const width = d2822(str[i]); i += width[1];       const line = new v1981(         '',          x    [0],         y    [0],         width[0]);       i = b3684(str, i, line);           return [line, i - u3744]; } 


class g1973 extends o1990 {     position;     x;     y;     width;     height;     round;     from;     to;     inner;        constructor(nodeId,                 position = new p1983(0),                 x        = new p1983(0),                  y        = new p1983(0),                  width    = new p1983(0),                  height   = new p1983(0),                  round    = new p1983(0),                  from     = new p1983(0),                 to       = new p1983(0),                 inner    = new p1983(0))     {         super(f1216, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.from     = from;         this.to       = to;         this.inner    = inner;     }        copy()     {         const copy = new g1973(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.from    .copy(),             this.to      .copy(),             this.inner   .copy());          copy.u3332(this);          return copy;     }        equals(ellipse)     {         return ellipse             && this.position.equals(ellipse.position)             && this.x       .equals(ellipse.x       )             && this.y       .equals(ellipse.y       )             && this.width   .equals(ellipse.width   )             && this.height  .equals(ellipse.height  )             && this.round   .equals(ellipse.round   )             && this.from    .equals(ellipse.from    )             && this.to      .equals(ellipse.to      )             && this.inner   .equals(ellipse.inner   );     }        async eval(parse)     {         return this;     }                    b3686()     {         return super.b3686()             && this.position.b3686()             && this.x       .b3686()             && this.y       .b3686()             && this.width   .b3686()             && this.height  .b3686()             && this.round   .b3686()             && this.from    .b3686()             && this.to      .b3686()             && this.inner   .b3686();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.from    .isValid()             && this.to      .isValid()             && this.inner   .isValid();     }        f3605()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.from    .toString()             + ' ' + this.to      .toString()             + ' ' + this.inner   .toString()             + ' ' + super.toString();     }        h3679()     {         return 'ellipse';                                                                                                                          }        h3680()     {         return      this.position.h3680()             + ' ' + this.x       .h3680()             + ' ' + this.y       .h3680()             + ' ' + this.width   .h3680()             + ' ' + this.height  .h3680()             + ' ' + this.round   .h3680()             + ' ' + this.from    .h3680()             + ' ' + this.to      .h3680()             + ' ' + this.inner   .h3680();     }        static NaN = new g1973(         '',         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function j3798(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [g1973.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const pos    = d2822(str[i]); i += pos   [1];     const x      = d2822(str[i]); i += x     [1];     const y      = d2822(str[i]); i += y     [1];     const width  = d2822(str[i]); i += width [1];     const height = d2822(str[i]); i += height[1];     const round  = d2822(str[i]); i += round [1];     const from   = d2822(str[i]); i += from  [1];     const to     = d2822(str[i]); i += to    [1];     const inner  = d2822(str[i]); i += inner [1];       const ellipse = new g1973(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         from  [0],         to    [0],         inner [0]);       i = b3684(str, i, ellipse);           return [ellipse, i - u3744]; } 


class j1995 extends o1990 {     x;     y;     width;     height;     round;     bias;        constructor(nodeId,                 x      = new p1983(0),                  y      = new p1983(0),                  width  = new p1983(0),                  height = new p1983(0),                  round  = new p1983(0),                 bias   = new p1983(0))     {         super(m1219, nodeId);          this.x      = x;         this.y      = y;         this.width  = width;         this.height = height;         this.round  = round;         this.bias   = bias;     }        copy()     {         const copy = new j1995(             this.nodeId,             this.x     .copy(),              this.y     .copy(),              this.width .copy(),              this.height.copy(),              this.round .copy(),             this.bias  .copy());          copy.u3332(this);          return copy;     }        equals(rect)     {         return rect             && this.x     .equals(rect.x     )             && this.y     .equals(rect.y     )             && this.width .equals(rect.width )             && this.height.equals(rect.height)             && this.round .equals(rect.round )             && this.bias  .equals(rect.bias  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x     .toString()             + ' ' + this.y     .toString()             + ' ' + this.width .toString()             + ' ' + this.height.toString()             + ' ' + this.round .toString()             + ' ' + this.bias  .toString()             + ' ' + super.toString();     }        h3679()     {         return 'trapeze';                                                                                   }        h3680()     {         return      this.x     .h3680()             + ' ' + this.y     .h3680()             + ' ' + this.width .h3680()             + ' ' + this.height.h3680()             + ' ' + this.round .h3680()             + ' ' + this.bias  .h3680();     }        f3605()     {         return this.copy();     }        b3686()     {         return super.b3686()             && this.x     .b3686()             && this.y     .b3686()             && this.width .b3686()             && this.height.b3686()             && this.round .b3686()             && this.bias  .b3686();     }            isValid()     {         return super.isValid()             && this.x     .isValid()             && this.y     .isValid()             && this.width .isValid()             && this.height.isValid()             && this.round .isValid()             && this.bias  .isValid();     }            static NaN = new j1995(         '',         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function j3799(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [j1995.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x      = d2822(str[i]); i += x     [1];     const y      = d2822(str[i]); i += y     [1];     const width  = d2822(str[i]); i += width [1];     const height = d2822(str[i]); i += height[1];     const round  = d2822(str[i]); i += round [1];     const bias   = d2822(str[i]); i += bias  [1];       const rect = new j1995(         '',          x     [0],         y     [0],         width [0],         height[0],         round [0],         bias  [0]);       i = b3684(str, i, rect);           return [rect, i - u3744]; } 


class q1985 extends o1990 {     position;     x;     y;     width;     height;     round;     corners;        constructor(nodeId,                 position = new p1983(0),                 x        = new p1983(0),                  y        = new p1983(0),                  width    = new p1983(0),                  height   = new p1983(0),                  round    = new p1983(0),                  corners  = new p1983(0))     {         super(p1222, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.corners  = corners;     }        copy()     {         const copy = new q1985(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.corners .copy());              copy.u3332(this);          return copy;     }        equals(poly)     {         return poly             && this.position.equals(poly.position)             && this.x       .equals(poly.x       )             && this.y       .equals(poly.y       )             && this.width   .equals(poly.width   )             && this.height  .equals(poly.height  )             && this.round   .equals(poly.round   )             && this.corners .equals(poly.corners );     }        async eval(parse)     {         return this;     }        b3686()     {         return super.b3686()             && this.position.b3686()             && this.x       .b3686()             && this.y       .b3686()             && this.width   .b3686()             && this.height  .b3686()             && this.round   .b3686()             && this.corners .b3686();     }        isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.corners .isValid();     }        f3605()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.corners .toString()             + ' ' + super.toString();     }        h3679()     {         return      this.position.h3679()             + ' ' + this.x       .h3679()             + ' ' + this.y       .h3679()             + ' ' + this.width   .h3679()             + ' ' + this.height  .h3679()             + ' ' + this.round   .h3679()             + ' ' + this.corners .h3679();     }        h3680()     {         return      this.position.h3680()             + ' ' + this.x       .h3680()             + ' ' + this.y       .h3680()             + ' ' + this.width   .h3680()             + ' ' + this.height  .h3680()             + ' ' + this.round   .h3680()             + ' ' + this.corners .h3680();     }        static NaN = new q1985(         '',         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function s3800(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [q1985.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const pos     = d2822(str[i]); i += pos    [1];     const x       = d2822(str[i]); i += x      [1];     const y       = d2822(str[i]); i += y      [1];     const width   = d2822(str[i]); i += width  [1];     const height  = d2822(str[i]); i += height [1];     const round   = d2822(str[i]); i += round  [1];     const corners = d2822(str[i]); i += corners[1];       const poly = new q1985(         '',          pos    [0],         x      [0],         y      [0],         width  [0],         height [0],         round  [0],         corners[0]);       i = b3684(str, i, poly);           return [poly, i - u3744]; } 


class m1991 extends o1990 {     position;     x;     y;     width;     height;     round;     points;     convex;        constructor(nodeId,                 position = new p1983(0),                  x        = new p1983(0),                  y        = new p1983(0),                  width    = new p1983(0),                  height   = new p1983(0),                  round    = new p1983(0),                  points   = new p1983(0),                 convex   = new p1983(0))     {         super(s1225, nodeId);          this.position = position;         this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.points   = points;         this.convex   = convex;     }        copy()     {         const copy = new m1991(             this.nodeId,             this.position.copy(),              this.x       .copy(),              this.y       .copy(),              this.width   .copy(),              this.height  .copy(),              this.round   .copy(),              this.points  .copy(),             this.convex  .copy());          copy.u3332(this);          return copy;     }        equals(star)     {         return star             && this.position.equals(star.position)             && this.x       .equals(star.x       )             && this.y       .equals(star.y       )             && this.width   .equals(star.width   )             && this.height  .equals(star.height  )             && this.round   .equals(star.round   )             && this.points  .equals(star.points  )             && this.convex  .equals(star.convex  );     }        async eval(parse)     {         return this;     }        b3686()     {         return super.b3686()             && this.position.b3686()             && this.x       .b3686()             && this.y       .b3686()             && this.width   .b3686()             && this.height  .b3686()             && this.round   .b3686()             && this.points  .b3686()             && this.convex  .b3686();     }            isValid()     {         return super.isValid()             && this.position.isValid()             && this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.points  .isValid()             && this.convex  .isValid();     }            f3605()     {         return this.copy();     }        toString()     {         return      this.position.toString()             + ' ' + this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.points  .toString()             + ' ' + this.convex  .toString()             + ' ' + super.toString();     }        h3679()     {         return      this.position.h3679()             + ' ' + this.x       .h3679()             + ' ' + this.y       .h3679()             + ' ' + this.width   .h3679()             + ' ' + this.height  .h3679()             + ' ' + this.round   .h3679()             + ' ' + this.points  .h3679()             + ' ' + this.convex  .h3679();     }        h3680()     {         return      this.position.h3680()             + ' ' + this.x       .h3680()             + ' ' + this.y       .h3680()             + ' ' + this.width   .h3680()             + ' ' + this.height  .h3680()             + ' ' + this.round   .h3680()             + ' ' + this.points  .h3680()             + ' ' + this.convex  .h3680();     }        static NaN = new m1991(         '',         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function b3801(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [m1991.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const pos    = d2822(str[i]); i += pos   [1];     const x      = d2822(str[i]); i += x     [1];     const y      = d2822(str[i]); i += y     [1];     const width  = d2822(str[i]); i += width [1];     const height = d2822(str[i]); i += height[1];     const round  = d2822(str[i]); i += round [1];     const points = d2822(str[i]); i += points[1];     const convex = d2822(str[i]); i += convex[1];       const star = new m1991(         '',          pos   [0],         x     [0],         y     [0],         width [0],         height[0],         round [0],         points[0],         convex[0]);       i = b3684(str, i, star);           return [star, i - u3744]; } 


class m1993 extends o1990 {     text;     x;     y;     width;     height;     font;     style;     size;     alignH;     alignV;     lineHeight;     letterSpacing;            constructor(nodeId,                 text          = new c1994(),                 x             = new p1983(0),                  y             = new p1983(0),                  width         = new p1983(0),                  height        = new p1983(0),                  font          = new p1983(0),                 style         = new p1983(0),                 size          = new p1983(0),                 alignH        = new p1983(0),                 alignV        = new p1983(0),                 lineHeight    = new p1983(0),                 letterSpacing = new p1983(0))     {         super(b1228, nodeId);          this.text          = text;         this.x             = x;         this.y             = y;         this.width         = width;         this.height        = height;         this.font          = font;         this.style         = style;         this.size          = size;         this.alignH        = alignH;         this.alignV        = alignV;         this.lineHeight    = lineHeight;         this.letterSpacing = letterSpacing;          this.objects       = [];     }        copy()     {         const copy = new m1993(             this.nodeId,             this.text         .copy(),             this.x            .copy(),              this.y            .copy(),              this.width        .copy(),              this.height       .copy(),              this.font         .copy(),             this.style        .copy(),             this.size         .copy(),             this.alignH       .copy(),             this.alignV       .copy(),             this.lineHeight   .copy(),             this.letterSpacing.copy());           copy.u3332(this);          return copy;     }        equals(text)     {         return text             && this.text         .equals(text.text         )             && this.x            .equals(text.x            )             && this.y            .equals(text.y            )             && this.width        .equals(text.width        )             && this.height       .equals(text.height       )             && this.font         .equals(text.font         )             && this.style        .equals(text.style        )             && this.size         .equals(text.size         )             && this.alignH       .equals(text.alignH       )             && this.alignV       .equals(text.alignV       )             && this.lineHeight   .equals(text.lineHeight   )             && this.letterSpacing.equals(text.letterSpacing);     }        async eval(parse)     {         return this;     }        b3686()     {         return super.b3686()             && this.text         .b3686()             && this.x            .b3686()             && this.y            .b3686()             && this.width        .b3686()             && this.height       .b3686()             && this.font         .b3686()             && this.style        .b3686()             && this.size         .b3686()             && this.alignH       .b3686()             && this.alignV       .b3686()             && this.lineHeight   .b3686()             && this.letterSpacing.b3686();     }            isValid()     {         return super.isValid()             && this.text         .isValid()             && this.x            .isValid()             && this.y            .isValid()             && this.width        .isValid()             && this.height       .isValid()             && this.font         .isValid()             && this.style        .isValid()             && this.size         .isValid()             && this.alignH       .isValid()             && this.alignV       .isValid()             && this.lineHeight   .isValid()             && this.letterSpacing.isValid();     }            f3605()     {         return this.copy();     }        toString()     {         return      this.text         .o2080()              + ' ' + this.x            .toString()             + ' ' + this.y            .toString()             + ' ' + this.width        .toString()             + ' ' + this.height       .toString()             + ' ' + this.font         .toString()             + ' ' + this.style        .toString()             + ' ' + this.size         .toString()             + ' ' + this.alignH       .toString()             + ' ' + this.alignV       .toString()             + ' ' + this.lineHeight   .toString()             + ' ' + this.letterSpacing.toString()             + ' ' + super.toString();         }        h3679()     {         return      this.text         .o2080()              + ' ' + this.x            .h3679()             + ' ' + this.y            .h3679()             + ' ' + this.width        .h3679()             + ' ' + this.height       .h3679()             + ' ' + this.font         .h3679()             + ' ' + this.style        .h3679()             + ' ' + this.size         .h3679()             + ' ' + this.alignH       .h3679()             + ' ' + this.alignV       .h3679()             + ' ' + this.lineHeight   .h3679()             + ' ' + this.letterSpacing.h3679();     }        h3680()     {         return      this.text         .h3680()             + ' ' + this.x            .h3680()             + ' ' + this.y            .h3680()             + ' ' + this.width        .h3680()             + ' ' + this.height       .h3680()             + ' ' + this.font         .h3680()             + ' ' + this.style        .h3680()             + ' ' + this.size         .h3680()             + ' ' + this.alignH       .h3680()             + ' ' + this.alignV       .h3680()             + ' ' + this.lineHeight   .h3680()             + ' ' + this.letterSpacing.h3680();     }        o2080()     {         return      this.text         .o2080()             + ' ' + this.x            .o2080()             + ' ' + this.y            .o2080()             + ' ' + this.width        .o2080()             + ' ' + this.height       .o2080()             + ' ' + this.font         .o2080()             + ' ' + this.style        .o2080()             + ' ' + this.size         .o2080()             + ' ' + this.alignH       .o2080()             + ' ' + this.alignV       .o2080()             + ' ' + this.lineHeight   .o2080()             + ' ' + this.letterSpacing.o2080();     }        static NaN = new m1993(         '',         c1994.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function j3802(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [m1993.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const text          = n2837  (str[i]); i += text         [1];     const x             = d2822(str[i]); i += x            [1];     const y             = d2822(str[i]); i += y            [1];     const width         = d2822(str[i]); i += width        [1];     const height        = d2822(str[i]); i += height       [1];     const font          = d2822(str[i]); i += font         [1];     const style         = d2822(str[i]); i += style        [1];     const size          = d2822(str[i]); i += size         [1];     const alignH        = d2822(str[i]); i += alignH       [1];     const alignV        = d2822(str[i]); i += alignV       [1];     const lineHeight    = d2822(str[i]); i += lineHeight   [1];     const letterSpacing = d2822(str[i]); i += letterSpacing[1];       const txts = new m1993(         '',          text         [0],         x            [0],         y            [0],         width        [0],         height       [0],         font         [0],         style        [0],         size         [0],         alignH       [0],         alignV       [0],         lineHeight   [0],         letterSpacing[0]);       i = b3684(str, i, txts);           return [txts, i - u3744]; } 


class t1984 extends j2011 {     nodeId;      x;     y;     smooth;       sp0 = null;      sp1 = null;      sp2 = null;         constructor(nodeId,                 x = new p1983(0),                  y = new p1983(0),                 smooth = null)     {         super(e1231);          this.nodeId  = nodeId;          this.x       = x;         this.y       = y;         this.smooth  = smooth;           this.w3717();     }        copy()     {         const copy = new t1984(             this.nodeId,             this.x.copy(),              this.y.copy());          if (this.smooth) copy.smooth = this.smooth.copy();          copy.u3332(this);          copy.sp0 = clone(this.sp0);         copy.sp1 = clone(this.sp1);         copy.sp2 = clone(this.sp2);          return copy;     }        equals(p)     {         return p             && this.x.equals(p.x)             && this.y.equals(p.y);     }        w3717(cx = 0, cy = 0)     {         this.sp0 = point(cx,   cy  );         this.sp1 = point(cx+1, cy  );         this.sp2 = point(cx,   cy+1);     }        applySpaceTransform(c4185, space)     {         this.sp0 = j3705(this.sp0, c4185, space);         this.sp1 = j3705(this.sp1, c4185, space);         this.sp2 = j3705(this.sp2, c4185, space);     }        static create(nodeId, x, y)     {         return new t1984(             nodeId,             new p1983(x),             new p1983(y));     }        static fromPoint(nodeId, p)     {         return new t1984(             nodeId,             new p1983(p.x),             new p1983(p.y));     }        async eval(parse)     {         return this;     }        b3686()     {         return this.x.b3686()             && this.y.b3686()             && (  !this.smooth                 || this.smooth.b3686());     }        isValid()     {         return this.x.isValid()             && this.y.isValid()             && (  !this.smooth                 || this.smooth.isValid());     }        toString()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.toString()               + ' ' + this.y.toString()             : e958;     }        h3679()     {         return this.x.isValid()             && this.y.isValid()             ?   '(' + this.x.h3679()               + ', ' + this.y.h3679()               + ')'             : e958;     }        h3680()     {         return this.x.isValid()             && this.y.isValid()             ?         this.x.h3680()               + ' ' + this.y.h3680()             : e958;     }        f3605()     {         return this.copy();     }        q3722()     {         return point(             this.x.value,             this.y.value);     }        j2819(gen)     {         return '';     }        w3331()     {         return t1984.NaN;     }        static NaN = Object.freeze(new t1984(         '',         p1983.NaN,          p1983.NaN)); }    function a3803(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [t1984.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x = d2822(str[i]); i += x[1];     const y = d2822(str[i]); i += y[1];       const point = new t1984(         '',          x[0],         y[0]);       return [point, i - u3744]; } 


class k1998 extends o1990 {     points;     closed;     degree;     winding;     round;        constructor(nodeId,                 points  = new p1982(),                  closed  = new p1983(0),                  degree  = new p1983(0),                  winding = new p1983(0),                  round   = new p1983(0))     {         super(q1235, nodeId);          this.points  = points ?? new p1982();         this.closed  = closed;         this.degree  = degree;         this.winding = winding;         this.round   = round;     }        copy()     {         const copy = new k1998(             this.nodeId,             this.points .copy(),              this.closed .copy(),              this.degree .copy(),              this.winding.copy(),              this.round  .copy());          copy.u3332(this);          return copy;     }        equals(rect)     {         return rect             && this.points .equals(rect.points )             && this.closed .equals(rect.closed )             && this.degree .equals(rect.degree )             && this.winding.equals(rect.winding)             && this.round  .equals(rect.round  );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.points .toString()             + ' ' + this.closed .toString()             + ' ' + this.degree .toString()             + ' ' + this.winding.toString()             + ' ' + this.round  .toString()             + ' ' + super.toString();     }        h3679()     {         return      this.points .h3679()             + ' ' + this.closed .h3679()             + ' ' + this.degree .h3679()             + ' ' + this.winding.h3679()             + ' ' + this.round  .h3679();     }        h3680()     {         return      this.points .h3680()             + ' ' + this.closed .h3680()             + ' ' + this.degree .h3680()             + ' ' + this.winding.h3680()             + ' ' + this.round  .h3680();     }        f3605()     {         return this;     }        b3686()     {         return super.b3686()             && this.points .b3686()             && this.closed .b3686()             && this.degree .b3686()             && this.winding.b3686()             && this.round  .b3686();     }            isValid()     {         return super.isValid()             && this.points .isValid()             && this.closed .isValid()             && this.degree .isValid()             && this.winding.isValid()             && this.round  .isValid();     }            static NaN = new k1998(         '',         p1982  .NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN); }    function i3644(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [k1998.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const points  = i3455  (str, i); i += points [1];     const closed  = d2822(str[i]); i += closed [1];     const degree  = d2822(str[i]); i += degree [1];     const winding = d2822(str[i]); i += winding[1];     const round   = d2822(str[i]); i += round  [1];      const path = new k1998(         '',          points [0],         closed [0],         degree [0],         winding[0],         round  [0]);       i = b3684(str, i, path);           return [path, i - u3744]; } 


class r2000 extends j2011 {     nodeId;      x;     y;     join;     cap;     round;        constructor(nodeId,                 x     = new p1983(0),                  y     = new p1983(0),                 join  = new p1983(0),                 cap   = new p1983(0),                 round = new p1983(0))     {         super(v1238);          this.nodeId = nodeId;          this.x      = x    .copy();         this.y      = y    .copy();         this.join   = join .copy();         this.cap    = cap  .copy();         this.round  = round.copy();     }        copy()     {         const copy = new r2000(             this.nodeId,             this.x    .copy(),              this.y    .copy(),              this.join .copy(),              this.cap  .copy(),              this.round.copy());          copy.u3332(this);          return copy;     }        equals(p)     {         return p             && this.x    .equals(p.x    )             && this.y    .equals(p.y    )             && this.join .equals(p.join )             && this.cap  .equals(p.cap  )             && this.round.equals(p.round);     }        static create(nodeId, x, y)     {         return new r2000(             nodeId,             new p1983(x    ),             new p1983(y    ),             new p1983(join ),             new p1983(cap  ),             new p1983(round));     }        static fromPoint(nodeId, p)     {         return new r2000(             nodeId,             new p1983(p.x),             new p1983(p.y),             new p1983(0),             new p1983(0),             new p1983(0));     }        async eval(parse)     {         return this;     }        b3686()     {         return this.x    .b3686()             && this.y    .b3686()             && this.join .b3686()             && this.cap  .b3686()             && this.round.b3686();     }        isValid()     {         return this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        toString()     {         return      this.x    .toString()             + ' ' + this.y    .toString()             + ' ' + this.join .toString()             + ' ' + this.cap  .toString()             + ' ' + this.round.toString();     }        h3679()     {         return      this.x    .h3679()             + ' ' + this.y    .h3679()             + ' ' + this.join .h3679()             + ' ' + this.cap  .h3679()             + ' ' + this.round.h3679();     }        h3680()     {         return      this.x    .h3680()             + ' ' + this.y    .h3680()             + ' ' + this.join .h3680()             + ' ' + this.cap  .h3680()             + ' ' + this.round.h3680();     }        f3605()     {         return this.copy();     }        q3722()     {         return point(             this.x.value,             this.y.value);     }        j2819(gen)     {         return '';     }        w3331()     {         return r2000.NaN;     }        static NaN = Object.freeze(new r2000(         '',         p1983.NaN,          p1983.NaN,          p1983.NaN,          p1983.NaN,          p1983.NaN)); }    function s3643(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [r2000.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x     = d2822(str[i]); i += x    [1];     const y     = d2822(str[i]); i += y    [1];     const join  = d2822(str[i]); i += join [1];     const cap   = d2822(str[i]); i += cap  [1];     const round = d2822(str[i]); i += round[1];       const point = new r2000(         '',          x    [0],         y    [0],         join [0],         cap  [0],         round[0]);       return [point, i - u3744]; } 


class r1996 extends j2011 {     nodeId;      start;     end;     h3639;     l3640;        constructor(nodeId,                 start,                  end,                 h3639 = t1984.create(nodeId, 0, 0),                 l3640   = t1984.create(nodeId, 0, 0))     {         super(h1241);          this.nodeId = nodeId;          this.start        = start       .copy();                this.end          = end         .copy();                  this.h3639 = h3639.copy();         this.l3640   = l3640  .copy();       }        copy()     {         const copy = new r1996(             this.nodeId,             this.start       .copy(),              this.end         .copy(),              this.h3639.copy(),              this.l3640  .copy());          copy.u3332(this);          return copy;     }        equals(edge)     {         return edge             && this.start       .equals(edge.start       )             && this.end         .equals(edge.end         )             && this.h3639.equals(edge.h3639)             && this.  l3640.equals(edge.  l3640);     }        static create(nodeId, start, end, h3639, l3640)     {         return new r1996(             nodeId,             start,             end,             t1984.create(nodeId, h3639.x, h3639.y),             t1984.create(nodeId,   l3640.x,   l3640.y));     }        async eval(parse)     {         return this;     }        b3686()     {         return this.start       .b3686()             && this.end         .b3686()             && this.h3639.b3686()             && this.l3640  .b3686();     }        isValid()     {         return this.start       .isValid()             && this.end         .isValid();                               }        toString()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.h3639.toString()             + ' ' + this.l3640  .toString();     }        h3679()     {         return      this.start       .toString()             + ' ' + this.end         .toString()             + ' ' + this.h3639.toString()             + ' ' + this.l3640  .toString();     }        h3680()     {         return      this.start       .h3680()             + ' ' + this.end         .h3680()             + ' ' + this.h3639.h3680()             + ' ' + this.l3640  .h3680();     }        f3605()     {         return this.copy();     }        j2819(gen)     {         return '';     }        w3331()     {         return r1996.NaN;     }        static NaN = Object.freeze(new r1996(         '',         r2000.NaN,          r2000.NaN,          t1984.NaN,          t1984.NaN)); }    function x3641(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [r1996.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const start        = s3643(str, i); i += start       [1];     const end          = s3643(str, i); i += end         [1];     const h3639 = a3803       (str, i); i += h3639[1];     const l3640   = a3803       (str, i); i +=   l3640[1];       const edge = new r1996(         '',          start       [0],         end         [0],         h3639[0],           l3640[0]);       return [edge, i - u3744]; } 


class w1999 extends o1990 {     loops;       winding;      fills = [];        constructor(nodeId,                 loops   = new p1982(),                  winding = new p1983(0))     {         super(h1244, nodeId);          this.loops   = loops;           this.winding = winding;     }        copy()     {         const copy = new w1999(             this.nodeId,             this.loops  .copy(),              this.winding.copy());          copy.fills = clone(this.fills);                  copy.u3332(this);          return copy;     }        equals(region)     {         return region             && this.loops  .equals(region.loops  )             && this.winding.equals(region.winding);     }                                              async eval(parse)     {         return this;     }        b3686()     {         return this.loops  .b3686()             && this.winding.b3686();     }        isValid()     {         return this.loops  .isValid()             && this.winding.isValid();     }        toString()     {         return      this.loops  .toString()             + ' ' + this.winding.toString();     }        h3679()     {         return      this.loops  .h3679()             + ' ' + this.winding.h3679();     }        h3680()     {         return      this.loops  .h3680()             + ' ' + this.winding.h3680();     }        f3605()     {         return this.copy();     }        j2819(gen)     {         return '';     }        w3331()     {         return r1996.NaN;     }        static NaN = Object.freeze(new w1999(         '',         p1982  .NaN,          p1983.NaN)); }    function j3638(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [w1999.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const loops   = i3455  (str, i); i += loops  [1];     const winding = d2822(str[i]); i += winding[1];       const region = new w1999(         '',          loops  [0],         winding[0]);       i = b3684(str, i, region);       return [region, i - u3744]; } 


class j1997 extends j2011 {     nodeId;      regions;        constructor(nodeId,                 regions = new p1982())     {         super(x1247);          this.nodeId  = nodeId;          this.regions = regions;      }        copy()     {         const copy = new j1997(             this.nodeId,             this.regions.copy());          copy.u3332(this);          return copy;     }        equals(region)     {         return region             && this.regions.equals(region.regions);     }        static create(nodeId, regions)     {         return new j1997(             nodeId,             regions);     }        async eval(parse)     {         return this;     }        b3686()     {         return this.regions.b3686();     }        isValid()     {         return this.regions.isValid();     }        toString()     {         return this.regions.toString();     }        h3679()     {         return this.regions.h3679();     }        h3680()     {         return this.regions.h3680();     }        f3605()     {         return this.copy();     }        j2819(gen)     {         return '';     }        w3331()     {         return j1997.NaN;     }        static NaN = Object.freeze(new j1997(         '',         p1982.NaN)); }    function b3637(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [j1997.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const regions = i3455(str, i); i += regions[1];       const net = new j1997(         '',          regions[0]);       return [net, i - u3744]; } 


class v1988 extends o1990 {     operation;     children;        constructor(nodeId, operation, children)     {         super(e1271, nodeId);          this.operation = operation;         this.children  = children;          this.objects =              children.objects             ? children.objects.map(o => o.copy())             : null;     }        copy()     {         const copy = new u1989(             this.nodeId,             this.operation.copy(),             this.children .copy());          copy.u3332(this);          return copy;     }        equals(bool)     {         return bool             && this.operation.equals(bool.operation)             && this.children .equals(bool.children );     }        async eval(parse)     {         return this;     }        toString()     {         return      this.operation.toString()             + ' ' + this.children .toString();     }        h3679()     {         return      this.operation.h3679()             + ' ' + this.children .h3679();     }        h3680()     {         return      this.operation.h3680()             + ' ' + this.children .h3680();     }        f3605()     {         return this.copy();     }        isValid()     {         return super.isValid()             && this.operation.isValid()             && this.children .isValid();     }            static NaN = new v1988(         '',         p1983.NaN,         p1982  .NaN); }    function k3804(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [v1988.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const operation = d2822(str[i]); i += operation[1];     const children  = i3455  (str, i); i += children [1];      const bool = new v1988(         '',          operation[0],         children [0]);       i = b3684(str, i, bool);           return [bool, i - u3744]; } 


class u1989 extends j2011 {     items = [];        constructor(nodeId, items = [])     {         super(t1250, nodeId);          this.items = items;               }        copy()     {         const copy = new u1989(             this.nodeId,             this.items.map(i => i.copy()));          copy.u3332(this);          return copy;     }        equals(group)     {         if (!group)                                  return false;         if (!(group instanceof u1989))     return false;         if (this.items.length != group.items.length) return false;                      for (let i = 0; i < this.items.length; i++)             if (!this.items[i].equals(group.items[i]))                 return false;          return true;     }        async eval(parse)     {         return this;     }        toString()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.toString();         }           return str;     }        h3679()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.h3679();         }           return str;     }        h3680()     {         if (!this.items)             return '';           let str = '';                           str += this.items.length;          for (let i = 0; i < this.items.length; i++)         {             const item = this.items[i];              str += ' ' + item.type + ' ';             str += item.h3680();         }           return str;     }        f3605()     {         return this.copy();     }        isValid()     {         return  this.items             && !this.items.find(i => !i.isValid());     }            static NaN = new u1989(         '',         p1982.NaN); }    function s3805(str, i = -1) {     if (i < 0)     {         str = str.split(' ');         i   = 0;     }               const u3744 = i;      const group = new u1989();           const w4186 = parseInt(str[i++]);       for (let j = 0; j < w4186; j++)     {         const type = str[i++];                  switch (type)         {             case         c1051:               case   u1054: { const _list   = i3455        (str, i);  i += _list  [1];  group.items.push(_list  [0]);  break; }               case    w1210: { const rect    = d3685   (str, i);  i += rect   [1];  group.items.push(rect   [0]);  break; }             case         w1213: { const line    = i3797        (str, i);  i += line   [1];  group.items.push(line   [0]);  break; }             case      f1216: { const ellipse = j3798     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case      m1219: { const ellipse = j3799     (str, i);  i += ellipse[1];  group.items.push(ellipse[0]);  break; }             case      p1222: { const poly    = s3800     (str, i);  i += poly   [1];  group.items.push(poly   [0]);  break; }             case         s1225: { const star    = b3801        (str, i);  i += star   [1];  group.items.push(star   [0]);  break; }             case   b1228: { const text    = j3802   (str, i);  i += text   [1];  group.items.push(text   [0]);  break; }             case        e1231: { const point   = a3803       (str, i);  i += point  [1];  group.items.push(point  [0]);  break; }             case  q1235: { const path    = i3644  (str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case      e1271: { const path    = k3804(str, i);  i += path   [1];  group.items.push(path   [0]);  break; }             case  t1250: { const _group  = s3805  (str, i);  i += _group [1];  group.items.push(_group [0]);  break; }             case        n1253: { const frame   = z3806       (str, i);  i += frame  [1];  group.items.push(frame  [0]);  break; }         }     }           return [         group,          i - u3744]; } 


class x1975 extends o1990 {     x;     y;     width;     height;     round;     children;        constructor(nodeId, x, y, width, height, round, children)     {         super(n1253, nodeId);          this.x        = x;         this.y        = y;         this.width    = width;         this.height   = height;         this.round    = round;         this.children = children;          this.objects =                 children             && children.objects              ? children.objects.map(o => o.copy())              : [];     }        copy()     {         const copy = new x1975(             this.nodeId,             this.x       .copy(),             this.y       .copy(),             this.width   .copy(),             this.height  .copy(),             this.round   .copy(),             this.children.copy());          copy.u3332(this);          return copy;     }        equals(frame)     {         return frame             && this.x       .equals(frame.x       )             && this.y       .equals(frame.y       )             && this.width   .equals(frame.width   )             && this.height  .equals(frame.height  )             && this.round   .equals(frame.round   )             && this.children.equals(frame.children);     }        async eval(parse)     {         return this;     }        toString()     {         return      this.x       .toString()             + ' ' + this.y       .toString()             + ' ' + this.width   .toString()             + ' ' + this.height  .toString()             + ' ' + this.round   .toString()             + ' ' + this.children.toString();     }        h3679()     {         return      this.x       .h3679()             + ' ' + this.y       .h3679()             + ' ' + this.width   .h3679()             + ' ' + this.height  .h3679()             + ' ' + this.round   .h3679()             + ' ' + this.children.h3679();     }        h3680()     {         return      this.x       .h3680()             + ' ' + this.y       .h3680()             + ' ' + this.width   .h3680()             + ' ' + this.height  .h3680()             + ' ' + this.round   .h3680()             + ' ' + this.children.h3680();     }        f3605()     {         return this.copy();     }        isValid()     {         return this.x       .isValid()             && this.y       .isValid()             && this.width   .isValid()             && this.height  .isValid()             && this.round   .isValid()             && this.children.isValid()             && super.isValid();     }            static NaN = new x1975(         '',         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1983.NaN,         p1982  .NaN); }    function z3806(str, i = -1) {     if (   i <  0 && str    == e958         || i >= 0 && str[i] == e958)         return [x1975.NaN, 1];       if (i < 0)     {         str = str.split(' ');         i   = 0;     }       const u3744 = i;      const x        = d2822(str[i]); i += x      [1];     const y        = d2822(str[i]); i += y      [1];     const width    = d2822(str[i]); i += width  [1];     const height   = d2822(str[i]); i += height [1];     const round    = d2822(str[i]); i += round  [1];     const children = i3455  (str, i); i += children[1];      const frame = new x1975(         '',          x       [0],         y       [0],         width   [0],         height  [0],         round   [0],         children[0]);       i = b3684(str, i, frame);           return [frame, i - u3744]; } 


class z1838 extends r2005 {     feedback = null;     from     = null;      u3796   = NULL;            constructor(nodeId, options)     {         super(b1058, nodeId, options);     }            reset()     {         super.reset();          this.feedback = null;         this.from     = null;     }        copy()     {         const copy = new z1838(this.nodeId, this.options);          copy.u3332(this);          if (this.value   ) copy.value    = this.value   .copy();         if (this.feedback) copy.feedback = this.feedback.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const feedback = this.feedback ? (await this.feedback.eval(parse)).f3605() : null;           this.value =              this.input              ? (await this.input.eval(parse)).f3605()              : new i4194();           this.n4078(parse,          [             ['feedback', feedback]         ]);           await this.x4077(parse, {feedback: feedback.value > 0});                   this.validate();          return this;     }        async x4077(parse, options = {})     {         const repeat = parse.repeats.find(r => r.repeatId == this.u3796);           this.o3615(                this.from             && repeat             && repeat.iteration > 0             && options.feedback             ? this.from.f3794              : (   this.input                 && this.input.value.objects                 ? this.input.value.objects                 : []),             repeat              ? repeat.iteration.toString()             : '');          this.from = null;                   await super.x4077(parse);     }        o3615(objects, iteration)     {         if (!this.value.isValid())             return;                      this.value.objects = objects.map(o => o.copy());          for (const c111 of this.value.objects)         {             c111.nodeId   = this.nodeId;             c111.objectId = c111.objectId + w961 + this.nodeId;         }     }                f3605()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.feedback && this.feedback.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.feedback) this.feedback.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.from = from;          if (this.feedback) this.feedback.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.feedback) this.feedback.m4064(parse);     } } 


class v1833 extends r2005 {     count   = null;    j3654   = null;          loop    = null;      f3794 = [];        constructor(nodeId, options)     {         super(r1059, nodeId, options);     }            reset()     {         super.reset();          this. count   = null;         this.j3654   = null;                  this. loop    = null;          this.f3794 = [];     }        copy()     {         const copy = new v1833(this.nodeId, this.options);          copy.u3332(this);          if (this. value  ) copy. value   = this. value  .copy();         if (this. count  ) copy. count   = this. count  .copy();         if (this.j3654  ) copy.j3654   = this.j3654  .copy();                  if (this. loop   ) copy. loop    = this. loop   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let   count   = (await this.count  .eval(parse)).f3605();         let  j3654   = new p1983(1);                  const loop    = (await this.loop   .eval(parse)).f3605();           count =              count             ? new p1983(Math.floor(count.value))             : new p1983(0);                    if (this.loop   .type != g1086) m3330(this.loop,    this);           this.value = new p1982();         this.value.objects = [];           if (count.value > 0)         {             if (this.input)                              {                 const w3151    = Date.now();                 let   h3793 = false;                   const nRepeats =                      this.options.enabled                      ? count.value                      : 0;                                   let repeat =                 {                     repeatId:  this.nodeId,                     iteration: 0,                     total:     nRepeats                 };                                       parse.repeats.push(repeat);                  if (parse.repeats.length == 1)                     parse.f3612 += nRepeats;                   if (this.loop.type != g1086)                      this.loop.n3601(parse, this.nodeId);                   for (let i = 0, o = 0; i < Math.max(1, nRepeats); i++)                 {                     j3654 = (await this.j3654.eval(parse)).f3605();                                          if (j3654.value == 0)                         break;                                       if (  !h3793                         && Date.now() - w3151 > 50)                     {                         i2038(this.nodeId);                         h3793 = true;                     }                       repeat.iteration = i;                       this.input.v4066(parse, this, false);                       const input = (await this.input.eval(parse)).f3605();                       if (   input                         && nRepeats > 0)                     {                         this.value.items.push(input);                           if (   this.options.active                             || this.options.u2969)                         {                             this.f3794 = [];                                                      if (this.input.value.objects)                             {                                 for (let j = 0; j < this.input.value.objects.length; j++, o++)                                 {                                     const c111 = d3712(this.input.value.objects[j]);                                      this.f3794.push(c111.copy());                                      c111.nodeId      = this.nodeId;                                     c111.listId      = i;                                      c111.objectId    = c111.objectId + w961 + this.nodeId + ':' + (o+1).toString();                                     c111.objectName += ' ' + (o+1).toString();                                      c111.u3795   = repeat.iteration;                                      if (this.value.objects)                                         this.value.objects.push(c111);                                 }                             }                         }                     }                       this.input.m4064(parse);                                                                                                                                 if (this.loop.type != g1086)                         this.loop.iterateCache(parse, this);                                           if (parse.repeats.length == 1)                     {                         parse.j3611++;                          if (await z3837(parse.e2028))                         {                             a2040(this.nodeId);                             return this;                         }                     }                                           if (h3793)                         b2039(parse, this.nodeId, i / nRepeats);                 }                   if (this.loop.type != g1086)                     this.loop.w3604(parse, this.nodeId, true);                   if (this.startTimer > -1)                 {                     clearTimeout(this.startTimer);                     this.startTimer = -1;                 }                   a2040(this.nodeId);                   s946(parse.repeats.at(-1) == repeat, 'invalid nested repeat \'' + this.nodeId + '\'');                 parse.repeats.pop();             }             else if (this.input)                 await this.input.eval(parse);         }         else         {             if (this.input)                 await this.input.eval(parse);         }           this.n4078(parse,         [             ['type',  this.outputListType()],             ['count', count                ]         ]);           this.validate();          return this;     }        f3605()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this. count && this. count.isValid()             && this.j3654 && this.j3654.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this. count  ) this. count  .x4065(parse);         if (this.j3654  ) this.j3654  .x4065(parse);                  if (this. loop   ) this. loop   .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this. count  ) this. count  .v4066(parse, from, force);         if (this.j3654  ) this.j3654  .v4066(parse, from, force);                  if (this. loop   ) this. loop   .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this. count  ) this. count  .m4064(parse);         if (this.j3654  ) this.j3654  .m4064(parse);                  if (this. loop   ) this. loop   .m4064(parse);     } }    function m3330(loop, node) {     s946(            loop.type == f1081         || loop.type == z1061         || loop.type == u1099         || loop.type == g1100         || loop.type == h1098         || loop.type == h1101         || loop.type == m1102         || loop.type == p1103         || loop.type == e1064         || loop.type == y1292,          'only volatile types can be repeated'); }


class o1832 extends r2005 {     constructor(nodeId, options)     {         super(v1055, nodeId, options);     }            copy()     {         const copy = new o1832(this.nodeId, this.options);          copy.u3332(this);          if (this.value) copy.value = this.value.copy();         if (this.input) copy.input = this.input.copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).f3605()              : new i4194();           this.i4193();           this.n4078(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     } } 


class g1843 extends h2004 {     varValue = null;        constructor(nodeId, options, styleId)     {         super(b1056, nodeId, options);     }        reset()     {         super.reset();          this.varValue = null;     }        copy()     {         const copy = new e1849(this.nodeId, this.options);          if (this.varValue) copy.varValue = this.varValue.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value =              this.varValue             ? (await this.varValue.eval(parse)).f3605()             : new i4194();           this.n4078(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalVariable(options = {})     {         if (!this.options.enabled)             return;     }        isValid()     {         return this.varValue && this.varValue.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.varValue) this.varValue.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.varValue) this.varValue.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.varValue) this.varValue.m4064(parse);     } }


class p1844 extends h2004 {     input = null;        constructor(nodeId, options)     {         super(z1057, nodeId, options);     }        copy()     {         const copy = new x1830(this.nodeId, this.options);                  copy.u3332(this);          if (this.input)              copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof j2011)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = this.input ? (await this.input.eval(parse)).f3605() : p1982.NaN;           this.z3067 = [];                                                                                                                                                                                                                                                  this.n4078(parse, [['', new i4194()]], true);                                        this.validate();          return this;     }                v4219(e2963)     {         return this.value             && this.value.items             && e2963 != 'value'             ? this.value.items.find(i => i.valueId == e2963)              : null;     }        f3605()     {         return this.value.copy();     }        isValid()     {         return this.input && this.input.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.input) this.input.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.input) this.input.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.input) this.input.m4064(parse);     } }


class i1819 extends r2005 {     q4189 = null;        constructor(nodeId, options)     {         super(j1060, nodeId, options);     }            reset()     {         super.reset();          this.q4189 = null;     }        copy()     {         const copy = new i1819(this.nodeId, this.options);          copy.u3332(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (!this.options.enabled)             this.q4189 = null;                      if (   this.isCached()             && this.q4189)             return this;           if (this.q4189)             this.value = this.q4189.copy();          else         {             this.value =                  this.input                  ? (await this.input.eval(parse)).f3605()                  : new i4194();              if (this.options.enabled)                 this.q4189 = this.value.copy();         }           this.i4193();           this.n4078(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          const repeat = parse.repeats.find(r => r.repeatId == this.u3796);          if (   repeat             && repeat.repeatId == from.nodeId)             this.q4189 = null;     }                            } 


class r1828 extends r2005 {     frozen = false;      u3796 = NULL;        constructor(nodeId, options)     {         super(z1061, nodeId, options);     }            reset()     {         super.reset();          this.frozen = false;     }        copy()     {         const copy = new r1828(this.nodeId, this.options);          copy.u3332(this);          if (this.value) copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const repeat = parse.repeats.find(r => r.repeatId == this.u3796);           if (      repeat                && repeat.iteration == 0             || !this.options.enabled)             this.frozen = false;           if (!this.frozen)         {             this.value =                  this.input                  ? (await this.input.eval(parse)).f3605()                 : new i4194();              this.frozen = true;              this.i4193();         }           this.n4078(parse,         [             ['type', this.outputType()]         ]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     } } 


class i1840 extends r2005 {     interval = null;    j3654    = null;     loop     = null;        constructor(nodeId, options)     {         super(l1062, nodeId, options);     }            reset()     {         super.reset();          this. interval = null;         this.j3654    = null;         this. loop     = null;     }        copy()     {         const copy = new i1840(this.nodeId, this.options);          copy.u3332(this);          if (this. interval) copy. interval = this. interval.copy();         if (this.j3654   ) copy.j3654    = this.j3654   .copy();         if (this. loop    ) copy. loop     = this. loop    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const  interval = (await this. interval.eval(parse)).f3605();         const j3654    = (await this.j3654   .eval(parse)).f3605();         const  loop     = (await this. loop    .eval(parse)).f3605();                       if (this.loop.type != g1086) m3330(this.loop, this);          if (j3654.value == 0)             return this;           if (this.input)         {             this.input.v4066(parse, this, true);              const input = (await this.input.eval(parse)).f3605();              this.value = input ? input : new i4194();              if (this.loop.type != g1086)                 this.loop.m4064(parse);         }         else             this.value = new i4194();                       this.n4078(parse,         [             ['value',    this.value],             ['interval', interval  ]         ]);                   this.i4193();           this.validate();          return this;     }        f3605()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.interval && this.interval.isValid()             && this.j3654   && this.j3654  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this. interval) this. interval.x4065(parse);         if (this.j3654   ) this.j3654   .x4065(parse);         if (this. loop    ) this. loop    .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this. interval) this. interval.v4066(parse, from, force);         if (this.j3654   ) this.j3654   .v4066(parse, from, force);         if (this. loop    ) this. loop    .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this. interval) this. interval.m4064(parse);         if (this.j3654   ) this.j3654   .m4064(parse);         if (this. loop    ) this. loop    .m4064(parse);     } } 


class x1842 extends r2005 {     name = null;        constructor(nodeId, options)     {         super(u1063, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new x1842(this.nodeId, this.options);          copy.u3332(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).f3605()              : new i4194();                   const name = (await this.name.eval(parse)).f3605();           if (   this.options.enabled             && this.value.isValid())         {             this.value.valueId = name.value;         }           this.i4193();           this.n4078(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.name) this.name.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.name) this.name.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.name) this.name.m4064(parse);     }        w3604(parse, nodeId)     {         super.w3604(parse, nodeId);          if (this.name) this.name.w3604(parse, nodeId);     } } 


class GObjectName extends r2005 {     name = null;        constructor(nodeId, options)     {         super(OBJECT_NAME, nodeId, options);     }            reset()     {         super.reset();          this.name = null;     }        copy()     {         const copy = new GObjectName(this.nodeId, this.options);          copy.u3332(this);          if (this.value) copy.value = this.value.copy();         if (this.name ) copy.name  = this.name .copy();          return copy;     }        async eval(parse)     {                             this.value =              this.input              ? (await this.input.eval(parse)).f3605()              : new i4194();                   const name = (await this.name.eval(parse)).f3605();                   if (   this.options.enabled             && this.value.isValid()             && this.value.objects)         {             for (const c111 of this.value.objects)             {                 c111.nodeId     = this.nodeId;                 c111.objectName = name.value;             }         }           this.i4193();           this.n4078(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.name) this.name.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.name) this.name.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.name) this.name.m4064(parse);     }        w3604(parse, nodeId)     {         super.w3604(parse, nodeId);          if (this.name) this.name.w3604(parse, nodeId);     } } 


class e1822 extends h2004 {     inputs = [];      value;        constructor(nodeId, options)     {         super(e1064, nodeId, options);     }            reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new e1822(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());         copy.value  = this.value.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p1982();          this.value.objects = [];           for (let i = 0; i < this.inputs.length; i++)         {             const input = (await this.inputs[i].eval(parse)).f3605();               if (   input                 && this.options.enabled)             {                 if (w951(input.type))                 {                     if (input.condensed === true)                         this.value.items.push(input);                     else                     {                         for (const item of input.items)                             this.value.items.push(item);                     }                 }                 else                     this.value.items.push(input);             }               const inputObjects = this.p3599(input, i);                          for (const c111 of inputObjects)             {                 c111.objectId += w961 + i;                 c111.u3795 = i;             }              this.value.objects.push(...inputObjects);         }                     const bounds = getObjBounds(this.value.objects);          const singlePoint =                this.value.objects.length  == 1              && this.value.objects[0].type == j1232;          for (const c111 of this.value.objects)         {             c111.w3717(c111.sp0.x, c111.sp0.y);             c111.resetSpace(bounds, singlePoint);         }                   const preview = new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 10)));         const length  = new p1983(this.value.items.length);         const type    = new c1994(q3452(this.value.items));                   this.n4078(parse,         [             ['length', length],             ['type',   type  ]         ]);           if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        f3605()     {         return this.value.copy();     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));     }        n3601(parse, u3796)     {         this.inputs.forEach(i => i.n3601(parse, u3796));     }        o3602(parse, nodeId)     {         this.inputs.forEach(i => i.o3602(parse, nodeId));     }        m4064(parse)     {         this.inputs.forEach(i => i.m4064(parse));     }        iterateCache(parse, from)     {         for (const input of this.inputs)         {             if (   input.type == p1075                 || input.type == e1064)                 input.iterateCache(parse, from);         }     }        w3604(parse, nodeId)     {         this.inputs.forEach(i => i.w3604(parse, nodeId));     } }


class t1823 extends r2005 {     q4189 = null;        constructor(nodeId, options)     {         super(s1065, nodeId, options);     }            reset()     {         super.reset();          this.q4189 = null;     }        copy()     {         const copy = new t1823(this.nodeId, this.options);          copy.u3332(this);                    return copy;     }        async eval(parse)     {         if (   this.isCached()             && this.q4189)             return this;           this.value = new p1982();         this.value.condensed = true;          let length = 0;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;           if (this.q4189)             this.value = this.q4189.copy();          else         {             if (input)             {                 length = input.items.length;                                                       if (   w951(input.type)                     && this.options.enabled)                 {                     for (const item of input.items)                     {                         const copy = item.copy();                          this.value.items.push(copy);                                              }                 }                 else                 {                     const copy = input.copy();                      this.value.items.push(copy);                     this.value.objects.push(...copy.objects);                 }             }             else                 this.value = new p1982();               this.q4189 = this.value.copy();         }               this.i4193();               this.n4078(parse,         [             ['length', new p1983(length)                              ],             ['type', new c1994(q3452(this.value.items))]         ]);                   this.validate();          return this;     } } 


class n1825 extends r2005 {     indices     = null;      q4189 = null;            constructor(nodeId, options)     {         super(a1066, nodeId, options);     }            reset()     {         super.reset();          this.indices = null;              this.q4189 = null;     }        copy()     {         const copy = new n1825(this.nodeId, this.options);          copy.u3332(this);          if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input   = this.input   ? (await this.input  .eval(parse)).f3605() : null;         const indices = this.indices ? (await this.indices.eval(parse)).f3605() : null;           this.value = new p1982();          let length = 0;                   if (this.q4189)             this.value = this.q4189.copy();          else         {             if (   input                 && indices                 && input.items)             {                 length = input.items.length;                   if (this.options.enabled)                 {                     for (let i = 0; i < indices.items.length; i++)                     {                         const item = input.items[Math.round(indices.items[i].value)];                                                  this.value.items.push(item ? item.copy() : new i4194());                                                  if (   item                             && item.objects                             && this.value.objects)                              this.value.objects.push(...item.objects);                     }                 }             }             else                 this.value = p1982.NaN.copy();               this.q4189 = this.value.copy();         }           this.i4193();           this.n4078(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new p1983(this.value.items.length)],              ['indices', indices                                 ]         ]);                   if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.indices && this.indices.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.indices) this.indices.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.indices) this.indices.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.indices) this.indices.m4064(parse);     } } 


class h1836 extends p2006 {     name = null;            constructor(nodeId, options)     {         super(h1068, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new e1826(this.nodeId, this.options);          copy.u3332(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;         const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;          const name   = this.name  ? (await this.name .eval(parse)).f3605() : null;           if (   p4060             && name)         {             let nameValue = name.value.trim();               if (w951(p4060.type))             {                 this.value = new p1982();                  if (this.options.enabled)                 {                     for (let i = 0; i < p4060.items.length; i++)                     {                         const item = p4060.items[i];                          if (   f4061                             && name.value.trim() != '')                             item.customParams.push([nameValue, f4061]);                                                   if (   item                             && item[nameValue]                             && item[nameValue].objects                              && this.value.objects)                             this.value.objects.push(...item[nameValue].objects);                     }                 }                 else                     this.value = p4060;             }             else             {                 this.value = p4060;                  if (   f4061                     && nameValue != ''                     && this.options.enabled)                     this.value.customParams.push([nameValue, f4061]);             }         }         else         {             this.value = new i4194();         }           this.i4193();           this.n4078(parse,         [             ['type', this.outputType()],             ['name', name             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.name) this.name.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.name) this.name.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.name) this.name.m4064(parse);     } } 


class e1826 extends r2005 {     name = null;            constructor(nodeId, options)     {         super(h1068, nodeId, options);     }            reset()     {         super.reset();          this.name  = null;     }        copy()     {         const copy = new e1826(this.nodeId, this.options);          copy.u3332(this);          if (this.name) copy.name = this.name.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;         const name  = this.name  ? (await this.name .eval(parse)).f3605() : null;           if (   input             && name             && name.value.trim() != '')         {             if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getExtractParamValue(input.items[i], name));                 }                 else                     this.value = getExtractParamValue(input, name);             }             else                 this.value = input;         }         else         {             this.value = new i4194();         }           this.i4193();           const type = this.outputType();                  this.n4078(parse,         [             ['type', type],             ['name', name]         ]);                   if (type.value == r1138 && parse.settings.a3707)         {             this.n4078(parse,             [                 ['preview', this.value]             ],             true);         }         else if (w951(type.value)   && parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.name && this.name.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.name) this.name.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.name) this.name.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.name) this.name.m4064(parse);     } }    function getExtractParamValue(input, name) {     let nameValue = name.value.trim();       if (    input         && !input[nameValue])     {              if (input[name.value.toUpperCase()]) nameValue = name.value.toUpperCase();         else if (input[name.value.toLowerCase()]) nameValue = name.value.toLowerCase();     }       let value = null;      if (   input         && input[nameValue])     {         value = input[nameValue];     }     else     {         const customIndex = input.customParams.findIndex(p => p[0] == nameValue);          value =             customIndex > -1             ? input.customParams[customIndex][1]             : new i4194();     }       if (   input         && input[nameValue]         && input[nameValue].objects          && this.value.objects)         value.objects.push(...input[nameValue].objects);       return value; }


class b1839 extends r2005 {     start       = null;     end         = null;      q4189 = null;            constructor(nodeId, options)     {         super(r1069, nodeId, options);     }            reset()     {         super.reset();          this.start       = null;         this.end         = null;          this.q4189 = null;     }        copy()     {         const copy = new b1839(this.nodeId, this.options);          copy.u3332(this);          if (this.start) copy.start = this.start.copy();         if (this.end  ) copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (   this.isCached()             && this.q4189)             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;         const start = this.start ? (await this.start.eval(parse)).f3605() : null;         const end   = this.end   ? (await this.end  .eval(parse)).f3605() : null;           if (this.q4189)             this.value = this.q4189.copy();          else         {             this.value = new p1982();             this.value.objects = [];              if (   input                 && start                 && end)             {                 if (input.items)                 {                     const _end =                         end.isValid()                         ? end                         : new p1983(input.items.length);                       if (start.value < _end.value)                     {                         if (this.options.enabled)                         {                             for (let i = start.value, j = 0; i < _end.value; i++, j++)                             {                                 const item = input.items[i];                                                                  this.value.items.push(item ? item.copy() : new i4194());                                                                  if (   item                                     && this.value.objects                                     && input.objects)                                 {                                     const objects = input.objects.filter(o => o.u3795 == i);                                     objects.forEach(o => o.u3795 = j);                                      this.value.objects.push(...objects);                                 }                             }                         }                         else                             this.value = input;                     }                 }                 else                     this.value = p1982.NaN.copy();             }               this.q4189 = this.value.copy();         }           this.i4193();           this.n4078(parse,         [             ['type',       this.outputListType()                          ],             ['length',     new p1983(this.value.items.length)       ],              ['fullLength', new p1983(input ? input.items.length : 0)],              ['start',      start                                          ],             ['end',        end                                            ]         ]);                   if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.start) this.start.x4065(parse);         if (this.end  ) this.end  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.start) this.start.v4066(parse, from, force);         if (this.end  ) this.end  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.start) this.start.m4064(parse);         if (this.end  ) this.end  .m4064(parse);     } } 


class y1841 extends r2005 {     counts      = null;     indices     = null;      q4189 = null;            constructor(nodeId, options)     {         super(c1070, nodeId, options);     }            reset()     {         super.reset();          this.counts      = null;         this.indices     = null;                  this.q4189 = null;     }        copy()     {         const copy = new y1841(this.nodeId, this.options);          copy.u3332(this);          if (this.counts ) copy.counts  = this.counts .copy();         if (this.indices) copy.indices = this.indices.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached()             && this.q4189)             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;           if (this.q4189)             this.value = this.q4189.copy();          else         {             this.counts  = new p1982();             this.indices = new p1982();                           if (input)             {                 if (this.options.enabled)                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                     {                         const item       = input.items[i];                         const foundIndex = this.value.items.findIndex(i => i.equals(item));                          if (foundIndex < 0)                         {                             this.value.items.push(item.copy());                              if (   this.value.objects                                 && item.objects)                                 this.value.objects.push(...item.objects);                              this.counts .items.push(new p1983(1));                             this.indices.items.push(new p1982([new p1983(i)]));                         }                         else                         {                             this.counts .items[foundIndex].value++;                             this.indices.items[foundIndex].items.push(new p1983(i));                         }                     }                 }                 else                     this.value = input.copy();             }             else                 this.value = new p1982();               this.q4189 = this.value.copy();         }           this.i4193();           this.n4078(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new p1983(this.value.items.length)],             ['counts',  this.counts                             ],             ['indices', this.indices                            ]         ]);                   if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }                                                                                                                                        } 


class h1834 extends r2005 {     q4189 = null;        constructor(nodeId, options)     {         super(v1071, nodeId, options);     }            reset()     {         super.reset();          this.q4189 = null;     }        copy()     {         const copy = new h1834(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (   this.isCached()             && this.q4189)             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;           this.counts = new p1982();           if (this.q4189)             this.value = this.q4189.copy();          else         {             if (input)             {                 if (this.options.enabled)                 {                     this.value = new p1982();                     this.value.objects = [];                      for (let i = input.items.length-1; i >= 0; i--)                         this.value.items.push(input.items[i]);                      if (input.objects)                     {                         for (let i = input.objects.length-1; i >= 0; i--)                             this.value.objects.push(input.objects[i]);                     }                 }                 else                     this.value = input;             }             else                 this.value = p1982.NaN.copy();               this.q4189 = this.value.copy();         }               this.i4193();           this.n4078(parse,          [             ['type',   this.outputListType()                   ],             ['length', new p1983(this.value.items.length)]         ]);                           if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     } } 


class h1837 extends r2005 {     order         = null;     reverse       = null;      v4190 = null;      q4189   = null;            constructor(nodeId, options)     {         super(h1072, nodeId, options);     }            reset()     {         super.reset();          this.order       = null;         this.reverse     = null;                  this.q4189 = null;     }        copy()     {         const copy = new h1837(this.nodeId, this.options);          copy.u3332(this);          if (this.order  ) copy.order   = this.order  .copy();         if (this.reverse) copy.reverse = this.reverse.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached()             && this.q4189)             return this;           const input   = this.input   ? (await this.input  .eval(parse)).f3605() : null;         const reverse = this.reverse ? (await this.reverse.eval(parse)).f3605() : null;           this.value = new p1982();         this.value.objects = [];          let maxColumns = 0;                   if (this.q4189)             this.value = this.q4189.copy();          else         {             if (   input                 && reverse)             {                 const order = this.order ? (await this.order.eval(parse)).f3605() : null;                                       if (this.options.enabled)                 {                     if (   this.order                         && this.order.o3743)                     {                         const orderNode = this.order.o3743(parse);                           if (orderNode)                         {                             const z4191 = reverse.value > 0 ? -1 : 1;                             const n4192          = [...input.items];                               input.items = await asyncSort(                                 parse,                                  n4192,                                  orderNode,                                  this,                                 this.order,                                  z4191);                                                           input.items.forEach(i => maxColumns = Math.max(maxColumns, w951(i.type) ? i.items.length : 1));                                                           for (let i = 0; i < input.items.length; i++)                             {                                 const row       = input   .items[i];                                 const u3795 = n4192.indexOf(row);                                  this.value.items.push(row.copy());                                  if (   row.objects                                     && this.value.objects)                                 {                                     const objects = input.objects.filter(o => o.u3795 == u3795).map(o => o.copy());                                     objects.forEach(o => o.u3795 = i);                                      this.value.objects.push(...objects);                                 }                             }                         }                     }                     else                         this.value = input;                 }                 else                     this.value = input;             }             else                 this.value = new p1982();               this.q4189 = this.value.copy();         }           this.i4193();           const preview = new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)));           this.n4078(parse,         [             ['type',    this.outputListType()],             ['reverse', reverse              ]         ]);                   if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order   && this.order  .isValid()             && this.reverse && this.reverse.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.order  ) this.order  .x4065(parse);         if (this.reverse) this.reverse.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.order  ) this.order  .v4066(parse, from, force);         if (this.reverse) this.reverse.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.order  ) this.order  .m4064(parse);         if (this.reverse) this.reverse.m4064(parse);     } }    async function asyncSort(parse, array, orderNode, node, order, z4191) {     const sorted = [];      for (const item of array)     {         const criterion = await getSortCriterion(parse, orderNode, node, order, item);         sorted.push({item, criterion});     }       sorted.sort((a, b) =>     {         if (a.criterion < b.criterion) return -1 * z4191;         if (a.criterion > b.criterion) return  1 * z4191;          return 0;     });       return sorted.map(_item => _item.item); }    async function getSortCriterion(parse, orderNode, node, order, item) {     orderNode.reset();      orderNode.input = item.copy();     order.v4066(parse, node, true);            return (await order.eval(parse)).f3605().value; } 


class q1827 extends r2005 {     condition = null;                  constructor(nodeId, options)     {         super(y1080, nodeId, options);     }            reset()     {         super.reset();          this.condition = null;     }        copy()     {         const copy = new q1827(this.nodeId, this.options);          copy.u3332(this);          if (this.condition) copy.condition = this.condition.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;           this.value = new p1982();         this.value.objects = [];          let maxColumns = 0;                   if (   input             && this.condition)         {             const condition = this.condition ? (await this.condition.eval(parse)).f3605() : null;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    this.value = input;         }         else             this.value = new p1982();           this.i4193();           const preview = new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)));           this.n4078(parse,         [             ['type',    this.outputListType()                   ],             ['length',  new p1983(this.value.items.length)]         ]);                   if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.condition && this.condition.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.condition) this.condition.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.condition) this.condition.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.condition) this.condition.m4064(parse);     } }


class f1821 extends r2005 {     index       = null;      q4189 = null;            constructor(nodeId, options)     {         super(u1073, nodeId, options);     }            reset()     {         super.reset();          this.index       = null;          this.q4189 = null;     }        copy()     {         const copy = new f1821(this.nodeId, this.options);          copy.u3332(this);          if (this.index) copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (   this.isCached()             && this.q4189)             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;         const index = this.index ? (await this.index.eval(parse)).f3605() : null;                   this.value = new p1982();          let maxColumns = 0;           if (this.q4189)             this.value = this.q4189.copy();          else         {             if (   input                 && index)             {                 if (isTable(input))                 {                     input.items.forEach(i => maxColumns = Math.max(maxColumns, i.items.length));                      if (index.value < maxColumns)                     {                         for (let i = 0; i < input.items.length; i++)                         {                             const row = input.items[i];                              if (index.value < row.items.length)                             {                                 this.value.items.push(row.items[index.value].copy());                                  if (   this.value.objects                                      && row.items[index.value].objects)                                     this.value.objects.push(...row.items[index.value].objects);                             }                         }                     }                 }                 else if (w951(input.type))                 {                     this.value = input.copy();                     maxColumns = 1;                 }             }               this.q4189 = this.value.copy();         }           this.i4193();           this.n4078(parse,         [             ['type',    this.outputListType()                                                          ],             ['length',  new p1983(this.value.items.length)                                       ],             ['columns', new p1983(maxColumns, 0)                                                 ],             ['index',   index                                                                          ]         ]);               if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.index) this.index.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.index) this.index.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.index) this.index.m4064(parse);     } }    function isTable(value) {     if (!w951(value.type))         return false;      for (const item of value.items)     {         if (!w951(item.type))             return false;     }      return true; }


class v1820 extends r2005 {     column;     row;            constructor(nodeId, options)     {         super(q1074, nodeId, options);     }            reset()     {         super.reset();          this.column = null;         this.row    = null;     }        copy()     {         const copy = new v1820(this.nodeId, this.options);          copy.u3332(this);          if (this.column) copy.column = this.column.copy();         if (this.row   ) copy.row    = this.row   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const column = this.column ? (await this.column.eval(parse)).f3605() : null;         const row    = this.row    ? (await this.row   .eval(parse)).f3605() : null;           let columns = 0;         let rows    = 0;          if (   this.input             && column             && row)         {             const input = this.input ? (await this.input.eval(parse)).f3605() : null;                           if (   input                 && isTable(input))             {                 rows = input.items.length;                  input.items.forEach(i => columns = Math.max(columns, i.items ? i.items.length : null));                  if (row.value < rows)                 {                     const _row = input.items[row.value];                      if (column.value < columns)                         this.value = _row.items[column.value].copy();                     else                         this.value = new i4194();                 }                 else                     this.value = new i4194();             }             else                 this.value = new i4194();         }         else             this.value = new i4194();           this.n4078(parse,         [                          ['type',    this.outputType()          ],             ['columns', new p1983(columns, 0)],             ['rows',    new p1983(rows   , 0)]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.column && this.column.isValid()             && this.row    && this.row   .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.column) this.column.x4065(parse);         if (this.row   ) this.row   .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.column) this.column.v4066(parse, from, force);         if (this.row   ) this.row   .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.column) this.column.m4064(parse);         if (this.row   ) this.row   .m4064(parse);     } }


class x1830 extends r2005 {     q4189 = null;        constructor(nodeId, options)     {         super(p1075, nodeId, options);     }        reset()     {         super.reset();          this.q4189 = null;     }        copy()     {         const copy = new x1830(this.nodeId, this.options);                  copy.u3332(this);          if (this.input)              copy.input = this.input.copy();                  for (const key of this.keys())         {             if (this[key] instanceof j2011)                 Object.assign(copy, {[key]: this[key]});         }          return copy;     }        async eval(parse)     {         if (   this.isCached()             && this.q4189)             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;            if (this.q4189)            this.value = this.q4189.copy();          else         {             this.value = input ?? new i4194();             this.q4189 = this.value.copy();         }           this.z3067 = [];                   if (    this.value.isValid()             &&  this.value.items             && !isEmpty(this.value.items))         {             for (let i = 0; i < this.value.items.length; i++)             {                 const item = this.value.items[i];                                  let valueId =                      item.valueId.trim() != ''                     ? item.valueId                     : i.toString();                  valueId = r1451(                     valueId,                     id => this.value.items.find(i =>                            i != item                          && i.valueId == id));                  Object.assign(this, {[valueId]: item});                 this.n4078(parse, [[valueId, item]], true);                  item.sortId = i;             }              this.z3067.sort((a, b) => a.sortId - b.sortId);              this.n4078(parse, [['-type-', this.outputType()]], true);         }         else             this.n4078(parse, [['-type-', new c1994(c1051)]], true);                                        this.i4193();           this.validate();          return this;     }                v4219(e2963)     {         return this.value             && this.value.items             && e2963 != 'value'             ? this.value.items.find(i => i.valueId == e2963)              : null;     }        f3605()     {         return this.value.copy();     }        iterateCache(parse, from)     {         this.q4189 = null;     } }


class x1835 extends r2005 {     index = null;        constructor(nodeId, options)     {         super(c1078, nodeId, options);     }        reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new x1835(this.nodeId, this.options);                  copy.u3332(this);          if (this.input) copy.input = this.input.copy();         if (this.index) copy.index = this.index.copy();         if (this.value) copy.value = this.value.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           let index = this.index ? (await this.index.eval(parse)).f3605() : null;           let length = 0;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;                      if (   index             && input             && input.items             && input.items.length > 0)         {             length = input.items.length;               index =                      index.isValid()                 && index.value > -input.items.length                 && index.value <  input.items.length                 ? new p1983(Math.round(index.value))                 : new p1983(0);                           if (   index.isValid()                 && index.value > -input.items.length                 && index.value <  input.items.length)             {                 this.value = input.items.at(index.value);                  if (this.value.objects)                 {                     for (let i = 0; i < this.value.objects.length; i++)                     {                         const c111 = this.value.objects[i];                          c111.nodeId = this.nodeId;                         c111.listId = -1;                          c111.objectId = this.nodeId;                                                  if (c111.objectId != NULL)                              c111.objectId += '/';                          c111.objectId += index.value.toString();                     }                 }             }             else             {                 this.value = new i4194();                 index      = p1983.NaN;             }         }         else         {             this.value = new i4194();             index      = p1983.NaN;         }           const type = this.outputType();          this.n4078(parse,         [             ['type',    type                   ],             ['length',  new p1983(length)],             ['index',   index                  ]         ]);           if (type.value == r1138 && parse.settings.a3707)         {             this.n4078(parse,             [                 ['preview', this.value]             ],             true);         }         else if (w951(type.value)   && parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.index) this.index.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.index) this.index.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.index) this.index.m4064(parse);     } }


class w1831 extends r2005 {     start = null;              constructor(nodeId, options)     {         super(w1076, nodeId, options);     }        reset()     {         super.reset();          this.start = null;     }        copy()     {         const copy = new w1831(this.nodeId, this.options);                  copy.u3332(this);          if (this.input) copy.input = this.input.copy();         if (this.start) copy.start = this.start.copy();                  if (this.count) copy.count = this.count.copy();          return copy;     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;           const start = (await this.start.eval(parse)).f3605();                   if (this.input)         {             const input = (await this.input.eval(parse)).f3605();             this.value = new p1983(input.items.length - (start.value == 0 ? 1 : 0));         }         else             this.value = p1983.NaN.copy();           this.n4078(parse,         [             ['value', this.value],             ['start', start     ]         ]);           this.validate();          return this;     }                               isValid()     {         return super.isValid()             && this.start && this.start.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.start) this.start.x4065(parse);     }            v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.start) this.start.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.start) this.start.m4064(parse);     }     }


class n1824 extends p2006 {     first;     last;     all;        constructor(nodeId, options)     {         super(x1077, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new n1824(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;         const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;               if (   p4060 && p4060.isValid()              && f4061 && f4061.isValid())         {             const indices = [];                           if (   f4061                 && f4061.isValid())             {                 for (let i = 0; i < p4060.items.length; i++)                 {                     if (p4060.items[i].equals(f4061))                         indices.push(i);                 }                     this.value = new p1983(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new p1983(indices.at( 0)) : p1983.NaN;                 this.last  = indices.length > 0 ? new p1983(indices.at(-1)) : p1983.NaN;                  this.all   = new p1982();                  for (const index of indices)                     this.all.items.push(new p1983(index));             }             else             {                 this.value = new p1983(1);                  this.first = p1983.NaN;                 this.last  = p1983.NaN;                 this.all   =   p1982.NaN;             }         }         else                           {             this.value = p1983.NaN;             this.first = p1983.NaN;             this.last  = p1983.NaN;             this.all   =   p1982.NaN;         }               this.n4078(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class x1829 extends h2004 {     p4060    = null;     f4061    = null;      condition = null;        constructor(nodeId, options)     {         super(f1079, nodeId, options);     }            reset()     {         super.reset();          this.p4060    = null;         this.f4061    = null;          this.condition = null;     }        copy()     {         const copy = new x1829(this.nodeId, this.options);          copy.u3332(this);          if (this.p4060   ) copy.p4060    = this.p4060   .copy();         if (this.f4061   ) copy.f4061    = this.f4061   .copy();          if (this.condition) copy.condition = this.condition.copy();          if (this.value    ) copy.value     = this.value    .copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.p4060 || this.p4060.isCached())             && (!this.f4061 || this.f4061.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                   const p4060 = this.p4060    ? (await this.p4060   .eval(parse)).f3605() : null;         const f4061 = this.f4061    ? (await this.f4061   .eval(parse)).f3605() : null;                  const cond   = this.condition ? (await this.condition.eval(parse)).f3605() : null;             if (   p4060                && f4061) this.value = cond.value != 0 ? p4060 : f4061;         else if (p4060) this.value = cond.value != 0 ? p4060 : new i4194();         else if (f4061) this.value = cond.value == 0 ? f4061 : new i4194();         else             this.value = new i4194();           this.i4193();           this.n4078(parse,         [             ['type',      this.outputType()],             ['condition', cond             ]         ]);                           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()               : null;     }        isValid()     {         return this.p4060    && this.p4060   .isValid()             && this.f4061    && this.f4061   .isValid()             && this.condition && this.condition.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.p4060   ) this.p4060   .x4065(parse);         if (this.f4061   ) this.f4061   .x4065(parse);         if (this.condition) this.condition.x4065(parse);     }            v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.p4060   ) this.p4060   .v4066(parse, from, force);         if (this.f4061   ) this.f4061   .v4066(parse, from, force);         if (this.condition) this.condition.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.p4060   ) this.p4060   .m4064(parse);         if (this.f4061   ) this.f4061   .m4064(parse);         if (this.condition) this.condition.m4064(parse);     }     } 


class v1861 extends h2004 {     inputs = [];        reset()     {         super.reset();          this.inputs = [];     }        o3743()     {         const orderNodes = [];          for (const input of this.inputs)         {             const orderNode = input.o3743();             if (orderNode) orderNodes.push(orderNode);                     }          console.assert(orderNodes.length < 2, 'Error: sort order requires not more than one order node');          return orderNodes.length == 1              ? orderNodes[0]              : null;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        isValid()     {         return  this.inputs.length > 0             && !this.inputs.find(i => !i.isValid());     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));     } } 


class y1898 extends r2005 {     constructor(nodeId, options)     {         super(o1087, nodeId, options);     }        copy()     {         const copy = new y1898(this.nodeId, this.options);                  copy.u3332(this);          copy.value = this.value;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();         }         else if (this.value)             await this.value.eval(parse);         else             this.value = p1983.NaN;           this.n4078(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        isValid()     {         return !this.input || this.input.isValid();     } }


class f1905 extends r2005 {     constructor(nodeId, options)     {         super(l1088, nodeId, options);     }            copy()     {         const copy = new f1905(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              s946(                 this.value.type == g1086,                  'this.value.type must be NUMBER_VALUE');              if (this.options.enabled)                 this.value.value = Math.sign(this.value.value);         }         else             this.value = p1983.NaN;           this.n4078(parse,          [                          ['', new i4194()]         ]);           this.validate();          return this;     } }


class c1886 extends r2005 {     constructor(nodeId, options)     {         super(w1089, nodeId, options);     }            copy()     {         const copy = new c1886(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              s946(                 this.value.type == g1086,                  'this.value.type must be NUMBER_VALUE');              if (this.options.enabled)                 this.value.value = Math.abs(this.value.value);         }         else             this.value = p1983.NaN;           this.n4078(parse, [['value', this.value]]);           this.validate();          return this;     } } 


class l1903 extends r2005 {     type;     decimals;        constructor(nodeId, options)     {         super(p1090, nodeId, options);     }            reset()     {         super.reset();          this.type     = null;         this.decimals = null;     }        copy()     {         const copy = new l1903(this.nodeId, this.options);          copy.u3332(this);          copy.type     = this.type    .copy();         copy.decimals = this.decimals.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p1983(0);                   const type = (await this.type    .eval(parse)).f3605();         const dec  = (await this.decimals.eval(parse)).f3605();           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              s946(                 this.value.type == g1086,                  'this.value.type must be NUMBER_VALUE');                           if (this.options.enabled)             {                 switch (type.value)                 {                     case 0: this.value.value = m1009(this.value.value, dec.value); break;                     case 1: this.value.value = f1010(this.value.value, dec.value); break;                     case 2: this.value.value =  g1011(this.value.value, dec.value); break;                 }                  this.value.decimals = dec.value;             }         }         else             this.value = p1983.NaN;           this.n4078(parse,         [                          ['type',     type      ],             ['decimals', dec       ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.type     && this.type    .isValid()             && this.decimals && this.decimals.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.type    ) this.type    .x4065(parse);         if (this.decimals) this.decimals.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.type    ) this.type    .v4066(parse, from, force);         if (this.decimals) this.decimals.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.type    ) this.type    .m4064(parse);         if (this.decimals) this.decimals.m4064(parse);     } } 


class y1906 extends r2005 {     operand;     operation;        constructor(nodeId, options)     {         super(p1091, nodeId, options);     }            reset()     {         super.reset();          this.operand   = null;         this.operation = null;     }        copy()     {         const copy = new l1903(this.nodeId, this.options);          copy.u3332(this);          copy.operand   = this.operand  .copy();         copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p1983(0);                   const input   = this.input     ? (await this.input    .eval(parse)).f3605() : null;         const operand = this.operand   ? (await this.operand  .eval(parse)).f3605() : null;         const op      = this.operation ? (await this.operation.eval(parse)).f3605() : null;           if (input)         {             if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == g1086                             ? getSimpleMinMaxValue(item, operand, op, this.options.enabled)                             : p1983.NaN.copy());                        }                 }                 else                 {                     this.value = getSimpleMinMaxValue(input, operand, op, this.options.enabled);                 }             }             else                 this.value = input;         }         else             this.value = p1983.NaN.copy();           this.n4078(parse,         [                          ['type',      this.outputType()],             ['operand',   operand          ],             ['operation', op               ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operand   && this.operation.isValid()             && this.operation && this.operand  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.operand  ) this.operand  .x4065(parse);         if (this.operation) this.operation.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.operand  ) this.operand  .v4066(parse, from, force);         if (this.operation) this.operation.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.operand  ) this.operand  .m4064(parse);         if (this.operation) this.operation.m4064(parse);     } }    function getSimpleMinMaxValue(input, operand, op, enabled) {     s946(         input.type == g1086,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), 1);          return new p1983(op.value == 0             ? Math.min(input.value, operand.o3677())             : Math.max(input.value, operand.o3677()));     }     else         return input; }


class m1895 extends v1861 {     operation;        constructor(nodeId, options)     {         super(f1092, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new m1895(this.nodeId, this.options);          copy.u3332(this);          copy.inputs    = this.inputs.map(i => i.copy());         copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op = (await this.operation.eval(parse)).f3605().b3703();          if (this.options.enabled)             op.value = Math.min(Math.max(0, op.value), v1295.length-1);                   this.value = await evalMinMaxInputs(this.inputs, op.value, parse);                   this.n4078(parse,         [             ['operation', op        ]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.operation) this.operation.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.operation) this.operation.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.operation) this.operation.m4064(parse);     } }    async function evalMinMaxInputs(inputs, op, parse) {     if (isEmpty(inputs))         return p1983.NaN;       let value = new p1983(0);       const x3664 = (await inputs[0].eval(parse)).f3605();       if (   inputs.length == 1         && x3664.type == g1086)     {         value = new p1983(-x3664.value);     }     else if (w951(x3664.type)             && !isEmpty(x3664.items))     {         value = x3664.items[0].copy();                  for (let i = 1; i < x3664.items.length; i++)         {             const item = x3664.items[i];              if (item.type == g1086)             {                 value = new p1983(                      op == 0                     ? Math.min(value.value, item.value)                     : Math.max(value.value, item.value));             }                             }     }     else     {         if (x3664.type != g1086)             return p1983.NaN;          value = x3664;     }       for (let i = 1; i < inputs.length; i++)     {         const val = (await inputs[i].eval(parse)).f3605();           if (w951(val.type))         {             for (const item of val.items)             {                 if (item.type == g1086)                 {                     value = new p1983(                         op == 0                         ? Math.min(value.value, item.value)                         : Math.max(value.value, item.value));                                       }                                 }         }         else         {             s946(                 val.type == g1086,                  'val.type must be NUMBER_VALUE');                              value = new p1983(                 op == 0                 ? Math.min(value.value, val.value)                 : Math.max(value.value, val.value));                       }     }       return value; }


class v1894 extends r2005 {     min = null;     max = null;            constructor(nodeId, options)     {         super(x1093, nodeId, options);     }            reset()     {         super.reset();          this.min = null;         this.max = null;     }        copy()     {         const copy = new v1894(this.nodeId, this.options);          copy.u3332(this);          copy.min = this.min.copy();         copy.max = this.max.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min || this.min.isCached())             && (!this.max || this.max.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const min = (await this.min.eval(parse)).f3605();         const max = (await this.max.eval(parse)).f3605();           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              s946(                 this.value.type == g1086,                  'this.value.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 this.value.value = Math.min(Math.max(                     min.value,                     this.value.value),                     max.value);             }         }         else             this.value = p1983.NaN;           this.n4078(parse,         [             ['value', this.value],             ['min',   min       ],             ['max',   max       ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min && this.min.isValid()             && this.max && this.max.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.input) this.input.x4065(parse);         if (this.min  ) this.min  .x4065(parse);         if (this.max  ) this.max  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.input) this.input.v4066(parse, from, force);         if (this.min  ) this.min  .v4066(parse, from, force);         if (this.max  ) this.max  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.input) this.input.m4064(parse);         if (this.min  ) this.min  .m4064(parse);         if (this.max  ) this.max  .m4064(parse);     } } 


class h1899 extends r2005 {     min    = null;     max    = null;     power  = null;     bias   = null;     spread = null;            constructor(nodeId, options)     {         super(f1094, nodeId, options);     }            reset()     {         super.reset();          this.min    = null;         this.max    = null;         this.power  = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new v1894(this.nodeId, this.options);          copy.u3332(this);          copy.min    = this.min   .copy();         copy.max    = this.max   .copy();         copy.power  = this.power .copy();         copy.bias   = this.bias  .copy();         copy.spread = this.spread.copy();          return copy;     }        isCached()     {         return super.isCached()             && (!this.min    || this.min   .isCached())             && (!this.max    || this.max   .isCached())             && (!this.power  || this.power .isCached())             && (!this.bias   || this.bias  .isCached())             && (!this.spread || this.spread.isCached());     }        async eval(parse)     {         if (this.isCached())             return this;                       const min    = (await this.min   .eval(parse)).f3605();         const max    = (await this.max   .eval(parse)).f3605();         const power  = (await this.power .eval(parse)).f3605();         const bias   = (await this.bias  .eval(parse)).f3605();         const spread = (await this.spread.eval(parse)).f3605();           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              if (this.options.enabled)             {                 let f = (input.value - min.value) / (max.value - min.value);                  f = Math.pow(f, power.value);                 f = b3709(f, bias.value, spread.value);                                  f = min.value + f * (max.value - min.value);                                  this.value = new p1983(f);             }             else                 this.value = input;         }         else             this.value = p1983.NaN;           this.n4078(parse,         [                          ['min',    min       ],             ['max',    max       ],             ['power',  power     ],             ['bias',   bias      ],             ['spread', spread    ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.power  && this.power .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.input ) this.input .x4065(parse);         if (this.min   ) this.min   .x4065(parse);         if (this.max   ) this.max   .x4065(parse);         if (this.power ) this.power .x4065(parse);         if (this.bias  ) this.bias  .x4065(parse);         if (this.spread) this.spread.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.input ) this.input .v4066(parse, from, force);         if (this.min   ) this.min   .v4066(parse, from, force);         if (this.max   ) this.max   .v4066(parse, from, force);         if (this.power ) this.power .v4066(parse, from, force);         if (this.bias  ) this.bias  .v4066(parse, from, force);         if (this.spread) this.spread.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.input ) this.input .m4064(parse);         if (this.min   ) this.min   .m4064(parse);         if (this.max   ) this.max   .m4064(parse);         if (this.power ) this.power .m4064(parse);         if (this.bias  ) this.bias  .m4064(parse);         if (this.spread) this.spread.m4064(parse);     } } 


class x1896 extends r2005 {     _value = null;        constructor(nodeId, options)     {         super(k1095, nodeId, options);     }            reset()     {         super.reset();          this._value = null;     }        copy()     {         const copy = new x1896(this.nodeId, this.options);          copy.u3332(this);          copy._value = this._value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _value = (await this._value.eval(parse)).f3605();           if (this.input)         {             const input = (await this. input.eval(parse)).f3605();              if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1086                         ? getNaNisNumberValue(item, _value, this.options.enabled)                         : c1994.NaN.copy());                    }             }             else             {                 this.value = getNaNisNumberValue(input, _value, this.options.enabled);             }         }          else             this.value = p1983.NaN.copy();           this.n4078(parse,         [             ['type',   this.outputType()]                      ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.value && this.value.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.value) this.value.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.value) this.value.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.value) this.value.m4064(parse);     } }    function getNaNisNumberValue(input, value, enabled) {     if (    enabled         && !input.isValid())         return value;     else         return input; }


class a1889 extends h2004 {     constant;        constructor(nodeId, options)     {         super(q1096, nodeId, options);     }            reset()     {         super.reset();          this.constant = null;     }        copy()     {         const copy = new a1889(this.nodeId, this.options);          copy.u3332(this);          if (this.constant) copy.constant = this.constant.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                                  const constant = (await this.constant.eval(parse)).f3605();              let value;          switch (Math.min(Math.max(0, constant.o3677()), 5))         {             case 0: value = 1.4142135623; break;              case 1: value = 2.7182818284; break;              case 2: value = 0.6180339887; break;              case 3: value = 1.6180339887; break;              case 4: value = 3.1415926536; break;              case 5: value = 6.2831853072; break;          }           this.value = new p1983(value);                   this.n4078(parse,         [             ['value',   this.value],             ['constant', constant ]         ]);           this.validate();          return this;     }        isValid()     {         return this.constant && this.constant.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.constant) this.constant.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.constant) this.constant.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.constant) this.constant.m4064(parse);     } } 


class b1891 extends h2004 {     seconds   = null;     minutes   = null;     hours     = null;     dayOfWeek = null;     date      = null;     month     = null;     year      = null;                    constructor(nodeId, options)     {         super(x1093, nodeId, options);     }            reset()     {         super.reset();                  this.seconds   = null;         this.minutes   = null;         this.hours     = null;         this.dayOfWeek = null;         this.date      = null;         this.month     = null;         this.year      = null;     }        copy()     {         const copy = new v1894(this.nodeId, this.options);                  copy.u3332(this);                  copy.seconds   = this.seconds  .copy();         copy.minutes   = this.minutes  .copy();         copy.hours     = this.hours    .copy();         copy.dayOfWeek = this.dayOfWeek.copy();         copy.date      = this.date     .copy();         copy.month     = this.month    .copy();         copy.year      = this.year     .copy();          return copy;     }                        isCached()     {         return super.isCached()             && (!this.year      || this.year     .isCached())             && (!this.month     || this.month    .isCached())             && (!this.date      || this.date     .isCached())             && (!this.dayOfWeek || this.dayOfWeek.isCached())             && (!this.hours     || this.hours    .isCached())             && (!this.minutes   || this.minutes  .isCached())             && (!this.seconds   || this.seconds  .isCached())     }        async eval(parse)     {         if (this.isCached())             return this;           this.z3067 = [];                   if (this.options.enabled)         {             const dateTime = new Date();              const seconds   = new p1983(dateTime.getSeconds() );             const minutes   = new p1983(dateTime.getMinutes() );             const hours     = new p1983(dateTime.getHours()   );             const dayOfWeek = new p1983(dateTime.getDay()     );             const date      = new p1983(dateTime.getDate()    );             const month     = new p1983(dateTime.getMonth()   );             const year      = new p1983(dateTime.getFullYear());               this.n4078(parse,             [                 ['seconds',   seconds  ],                 ['minutes',   minutes  ],                 ['hours',     hours    ],                 ['dayOfWeek', dayOfWeek],                 ['date',      date     ],                 ['month',     month    ],                 ['year',      year     ]             ]);             }                       this.validate();          return this;     }            isValid()     {         return this.year      && this.year     .isValid()             && this.month     && this.month    .isValid()             && this.date      && this.date     .isValid()             && this.dayOfWeek && this.dayOfWeek.isValid()             && this.hours     && this.hours    .isValid()             && this.minutes   && this.minutes  .isValid()             && this.seconds   && this.seconds  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.year     ) this.year     .x4065(parse);         if (this.month    ) this.month    .x4065(parse);         if (this.date     ) this.date     .x4065(parse);         if (this.dayOfWeek) this.dayOfWeek.x4065(parse);         if (this.hours    ) this.hours    .x4065(parse);         if (this.minutes  ) this.minutes  .x4065(parse);         if (this.seconds  ) this.seconds  .x4065(parse);     }            v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.year     ) this.year     .v4066(parse, from, force);         if (this.month    ) this.month    .v4066(parse, from, force);         if (this.date     ) this.date     .v4066(parse, from, force);         if (this.dayOfWeek) this.dayOfWeek.v4066(parse, from, force);         if (this.hours    ) this.hours    .v4066(parse, from, force);         if (this.minutes  ) this.minutes  .v4066(parse, from, force);         if (this.seconds  ) this.seconds  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.year     ) this.year     .m4064(parse);         if (this.month    ) this.month    .m4064(parse);         if (this.date     ) this.date     .m4064(parse);         if (this.dayOfWeek) this.dayOfWeek.m4064(parse);         if (this.hours    ) this.hours    .m4064(parse);         if (this.minutes  ) this.minutes  .m4064(parse);         if (this.seconds  ) this.seconds  .m4064(parse);     }     } 


class f1892 extends h2004 {     inputs = [];        constructor(nodeId, options)     {         super(f1081, nodeId, options);     }            reset()     {         super.reset();          this.input = [];     }        copy()     {         const copy = new f1892(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const _values = [];          for (let i = 0; i < this.inputs.length; i++)         {             const input = (await this.inputs[i].eval(parse)).f3605();              if (   input                 && this.options.enabled)                         {                 if (w951(input.type))                 {                     for (const item of input.items)                         _values.push(item.copy());                    }                 else                     _values.push(input.copy());             }         }                       this.value = _values[this.iteration % _values.length];           this.n4078(parse,         [             ['type', new c1994(finalTypeFromItems(_values))]         ]);                   this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return !this.inputs.find(i => !i.isValid());     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));     } } 


class s1904 extends h2004 {     start    = null;     multiply = null;     add      = null;     end      = null;      current  = null;                    constructor(nodeId, options)     {         super(h1098, nodeId, options);     }        reset()     {         super.reset();                  this.start    = null;         this.multiply = null;         this.add      = null;         this.end      = null;              this.current  = null;     }           copy()     {         const copy = new s1904(this.nodeId, this.options);          copy.u3332(this);          if (this.start   ) copy.start    = this.start   .copy();         if (this.multiply) copy.multiply = this.multiply.copy();         if (this.add     ) copy.add      = this.add     .copy();         if (this.end     ) copy.end      = this.end     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const start = (await this.start   .eval(parse)).f3605();         const mult  = (await this.multiply.eval(parse)).f3605();         const add   = (await this.add     .eval(parse)).f3605();         const end   = (await this.end     .eval(parse)).f3605();               if (   start             && mult             && add             && end)         {             const value = start.value + (this.options.enabled ? add.value * this.iteration : 0);              if (!end.isValid())                 this.value = getSequenceValue(start, mult, add, this.iteration, this.options.enabled);              else if (   end.isValid()                         && (   add.value == 0                          || add.value >  0 && start.value < end.value                                            &&       value < end.value                          || add.value <  0 && start.value > end.value                                            &&       value > end.value))                 this.value = getSequenceValue(start, mult, add, this.iteration, this.options.enabled);              else                 this.value = p1983.NaN.copy();         }         else             this.value = p1983.NaN.copy();           this.n4078(parse,         [             ['start',    start],             ['multiply', mult ],             ['add',      add  ],             ['end',      end  ]         ]);                   this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.start    && this.start   .isValid()             && this.multiply && this.multiply.isValid()             && this.add      && this.add     .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.start   ) this.start   .x4065(parse);         if (this.multiply) this.multiply.x4065(parse);         if (this.add     ) this.add     .x4065(parse);         if (this.end     ) this.end     .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.start   ) this.start   .v4066(parse, from, force);         if (this.multiply) this.multiply.v4066(parse, from, force);         if (this.add     ) this.add     .v4066(parse, from, force);         if (this.end     ) this.end     .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.start   ) this.start   .m4064(parse);         if (this.multiply) this.multiply.m4064(parse);         if (this.add     ) this.add     .m4064(parse);         if (this.end     ) this.end     .m4064(parse);     } }    function getSequenceValue(start, mult, add, iteration, enabled) {     let value = start.value;      if (enabled)     {         const _mult = Math.pow(mult.value, iteration);         const _add  = add.value * iteration;          value = start.value * _mult + _add;     }      return new p1983(value); }


class x1902 extends h2004 {     from   = null;     start  = null;     end    = null;     bias   = null;     spread = null;                constructor(nodeId, options)     {         super(u1099, nodeId, options);     }            reset()     {         super.reset();          this.from   = null;         this.start  = null;         this.end    = null;         this.bias   = null;         this.spread = null;     }        copy()     {         const copy = new x1902(this.nodeId, this.options);          copy.u3332(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.start ) copy.start  = this.start .copy();         if (this.end   ) copy.end    = this.end   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const from   = (await this.from  .eval(parse)).f3605();         const start  = (await this.start .eval(parse)).f3605();         const end    = (await this.end   .eval(parse)).f3605();         const bias   = (await this.bias  .eval(parse)).f3605();         const spread = (await this.spread.eval(parse)).f3605();               const repeat    = parse.repeats.find(r => r.repeatId == this.u3796);         const iteration = repeat ? repeat.iteration : 0;           let delta = end.value - start.value;          let step =                 repeat             && this.options.enabled             ? delta / Math.max(1, repeat.total - (from.value == 1 ? 1 : 0))             : 0;                       let startOffset;               if (from  .value == 2) startOffset = step;         else if (from  .value == 1               && repeat               && repeat.total == 1) startOffset = delta/2;         else                        startOffset = 0;           let f;                  if (repeat)         {                  if (from.value == 2) f = iteration/repeat.total;             else if (from.value == 1) f = (repeat.total > 1 ? iteration/(repeat.total-1) : 0);             else if (from.value == 0) f = iteration/repeat.total;         }         else             f = 0;           f = b3709(f, bias.value, spread.value);           this.value = new p1983(             start.value + startOffset + delta * f,             Math.max(start.decimals, end.decimals));           this.n4078(parse,         [             ['from',   from  ],             ['start',  start ],             ['end',    end   ],             ['bias',   bias  ],             ['spread', spread]         ]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.start  && this.start .isValid()             && this.end    && this.end   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.from  ) this.from  .x4065(parse);         if (this.start ) this.start .x4065(parse);         if (this.end   ) this.end   .x4065(parse);         if (this.bias  ) this.bias  .x4065(parse);         if (this.spread) this.spread.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.from  ) this.from  .v4066(parse, from, force);         if (this.start ) this.start .v4066(parse, from, force);         if (this.end   ) this.end   .v4066(parse, from, force);         if (this.bias  ) this.bias  .v4066(parse, from, force);         if (this.spread) this.spread.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.from  ) this.from  .m4064(parse);         if (this.start ) this.start .m4064(parse);         if (this.end   ) this.end   .m4064(parse);         if (this.bias  ) this.bias  .m4064(parse);         if (this.spread) this.spread.m4064(parse);     } }    function b3709(f, bias, spread) {     const b = bias   / 50;     const s = spread / 50;       f =          b >= 0         ? 1 - Math.pow(1-f, 1+b)         :     Math.pow(  f, 1-b);            if (s >= 0 && f >= 0.5) f = 1 - Math.pow((1-f)*2, 1+s) / 2;     else if (s >= 0 && f <  0.5) f = Math.pow(f*2, 1+s) / 2;     else if (s < 0)              f = n1031(0, (1-s)/3, (2+s)/3, 1, f);       return f; }


class g1908 extends h2004 {     shape     = null;     base      = null;     amplitude = null;     frequency = null;     offset    = null;     bias      = null;                constructor(nodeId, options)     {         super(g1100, nodeId, options);     }            reset()     {         super.reset();          this.shape     = null;         this.base      = null;         this.amplitude = null;         this.frequency = null;         this.offset    = null;         this.bias      = null;     }        copy()     {         const copy = new g1908(this.nodeId, this.options);          copy.u3332(this);          if (this.shape    ) copy.shape     = this.shape    .copy();         if (this.base     ) copy.base      = this.base     .copy();         if (this.amplitude) copy.amplitude = this.amplitude.copy();         if (this.frequency) copy.frequency = this.frequency.copy();         if (this.offset   ) copy.offset    = this.offset   .copy();         if (this.bias     ) copy.bias      = this.bias     .copy();          if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const shape  = this.shape     ? (await this.shape    .eval(parse)).f3605() : null;         const base   = this.base      ? (await this.base     .eval(parse)).f3605() : null;         const amp    = this.amplitude ? (await this.amplitude.eval(parse)).f3605() : null;         const freq   = this.frequency ? (await this.frequency.eval(parse)).f3605() : null;         const offset = this.offset    ? (await this.offset   .eval(parse)).f3605() : null;         const bias   = this.bias      ? (await this.bias     .eval(parse)).f3605() : null;               const repeat    = parse.repeats.find(r => r.repeatId == this.u3796);         const iteration = repeat ? repeat.iteration : 0;            if (this.options.enabled)         {             let t;                                       if (   repeat                 && shape                 && freq                 && offset)             {                 t = (iteration/repeat.total) * freq.value - offset.value/freq.value*2;                  switch (shape.value)                 {                     case 0: t = (t%1) < 0.5 ? 1 : -1;      break;                      case 1: t = (1 - (t%1)*2);             break;                      case 2: t = ((t%1)*2 - 1);             break;                      case 3: t = 1 - 2*Math.abs(2*(t%1)-1); break;                      case 4: t = Math.sin(t * Tau);         break;                  }             }             else                  t = 0;                           if (bias)             {                 const b = bias.value / 100;                  if (b >= 0) t = t / (1+b) + b/2;                 else        t = t / (1-b) + b/2;             }               if (amp ) t = t * amp .value;             if (base) t = t + base.value;               this.value = new p1983(t);         }         else             this.value = base;                   this.n4078(parse,         [             ['shape',     shape ],             ['base',      base  ],             ['amplitude', amp   ],             ['frequency', freq  ],             ['offset',    offset],             ['bias',      bias  ]         ]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.shape     && this.shape    .isValid()             && this.base      && this.base     .isValid()             && this.amplitude && this.amplitude.isValid()             && this.frequency && this.frequency.isValid()             && this.offset    && this.offset   .isValid()             && this.bias      && this.bias     .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.shape    ) this.shape    .x4065(parse);         if (this.base     ) this.base     .x4065(parse);         if (this.amplitude) this.amplitude.x4065(parse);         if (this.frequency) this.frequency.x4065(parse);         if (this.offset   ) this.offset   .x4065(parse);         if (this.bias     ) this.bias     .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.shape    ) this.shape    .v4066(parse, from, force);         if (this.base     ) this.base     .v4066(parse, from, force);         if (this.amplitude) this.amplitude.v4066(parse, from, force);         if (this.frequency) this.frequency.v4066(parse, from, force);         if (this.offset   ) this.offset   .v4066(parse, from, force);         if (this.bias     ) this.bias     .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.shape    ) this.shape    .m4064(parse);         if (this.base     ) this.base     .m4064(parse);         if (this.amplitude) this.amplitude.m4064(parse);         if (this.frequency) this.frequency.m4064(parse);         if (this.offset   ) this.offset   .m4064(parse);         if (this.bias     ) this.bias     .m4064(parse);     } } 


class y1901 extends h2004 {     seed   = null;     min    = null;     max    = null;     bias   = null;     spread = null;     unique = null;      random       = null;     randomUnique = null;      lastValue1   = -1;     lastValue2   = -1;     uniqueOffset =  0;        constructor(nodeId, options)     {         super(h1101, nodeId, options);     }            reset()     {         super.reset();          this.seed   = null;         this.min    = null;         this.max    = null;         this.bias   = null;         this.spread = null;         this.unique = null;     }        copy()     {         const copy = new y1901(this.nodeId, this.options);          copy.u3332(this);          if (this.seed  ) copy.seed   = this.seed  .copy();         if (this.min   ) copy.min    = this.min   .copy();         if (this.max   ) copy.max    = this.max   .copy();         if (this.bias  ) copy.bias   = this.bias  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.unique) copy.unique = this.unique.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const seed   = (await this.seed  .eval(parse)).f3605();         const min    = (await this.min   .eval(parse)).f3605();         const max    = (await this.max   .eval(parse)).f3605();         const bias   = (await this.bias  .eval(parse)).f3605();         const spread = (await this.spread.eval(parse)).f3605();         const unique = (await this.unique.eval(parse)).f3605();               if (  !this.random             || this.random.seed != seed.value)         {             this.random       = new Random(seed.value);             this.randomUnique = new Random(seed.value+1);         }           if (this.options.enabled)         {             let f = this.random.get(this.iteration + this.uniqueOffset);             f = b3709(f, bias.value, spread.value);                          f = min.value + f * (max.value - min.value);                          this.value = new p1983(f, Math.max(min.decimals, max.decimals));                               const _unique = unique.value/100;                           if (max.value - min.value >= 1)             {                 while (this.value.o3677() == this.lastValue1                     && this.randomUnique.get(this.iteration) < _unique)                     this.value = new p1983(                         min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),                         Math.max(min.decimals, max.decimals));             }              if (max.value - min.value >= 2)             {                 while ((   this.value.o3677() == this.lastValue1                         || this.value.o3677() == this.lastValue2)                     && this.randomUnique.get(this.iteration) < Math.max(_unique - 1))                     this.value = new p1983(                         min.value + this.random.get(this.iteration + ++this.uniqueOffset) * (max.value - min.value),                         Math.max(min.decimals, max.decimals));             }                 }         else             this.value = min;           if (this.value.isValid())             this.value.value = this.value.o3677();          this.lastValue2 = this.lastValue1;         this.lastValue1 = this.value.value;           this.n4078(parse,         [             ['seed',   seed  ],             ['min',    min   ],             ['max',    max   ],             ['bias',   bias  ],             ['spread', spread],             ['unique', unique]         ]);                   this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed   && this.seed  .isValid()             && this.min    && this.min   .isValid()             && this.max    && this.max   .isValid()             && this.bias   && this.bias  .isValid()             && this.spread && this.spread.isValid()             && this.unique && this.unique.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.seed  ) this.seed  .x4065(parse);         if (this.min   ) this.min   .x4065(parse);         if (this.max   ) this.max   .x4065(parse);         if (this.bias  ) this.bias  .x4065(parse);         if (this.spread) this.spread.x4065(parse);         if (this.unique) this.unique.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.seed  ) this.seed  .v4066(parse, from, force);         if (this.min   ) this.min   .v4066(parse, from, force);         if (this.max   ) this.max   .v4066(parse, from, force);         if (this.bias  ) this.bias  .v4066(parse, from, force);         if (this.spread) this.spread.v4066(parse, from, force);         if (this.unique) this.unique.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.seed  ) this.seed  .m4064(parse);         if (this.min   ) this.min   .m4064(parse);         if (this.max   ) this.max   .m4064(parse);         if (this.bias  ) this.bias  .m4064(parse);         if (this.spread) this.spread.m4064(parse);         if (this.unique) this.unique.m4064(parse);     }        n3601(parse, nodeId)     {         super.n3601(parse, nodeId);          this.uniqueOffset = 0;     }        w3604(parse, nodeId)     {         super.w3604(parse, nodeId);          this.uniqueOffset = 0;     } } 


class l1897 extends h2004 {     seed        = null;     min         = null;     max         = null;     scale       = null;     interpolate = null;     offset      = null;     detail      = null;          random = null;                    constructor(nodeId, options)     {         super(m1102, nodeId, options);     }                    reset()     {         super.reset();                  this.seed        = null;         this.min         = null;         this.max         = null;         this.scale       = null;         this.interpolate = null;         this.offset      = null;         this.detail      = null;     }        copy()     {         const copy = new l1897(this.nodeId, this.options);          copy.u3332(this);          if (this.seed       ) copy.seed        = this.seed       .copy();         if (this.min        ) copy.min         = this.min        .copy();         if (this.max        ) copy.max         = this.max        .copy();         if (this.scale      ) copy.scale       = this.scale      .copy();         if (this.offset     ) copy.offset      = this.offset     .copy();         if (this.interpolate) copy.interpolate = this.interpolate.copy();         if (this.detail     ) copy.detail      = this.detail     .copy();          if (this.random     ) copy.random      = this.random     .copy();          return copy;     }        async eval(parse)     {         const repeat    = parse.repeats.find(r => r.repeatId == this.u3796);         const iteration = repeat ? repeat.iteration : 0;           if (this.isCached())             return this;           const seed        = (await this.seed       .eval(parse)).f3605();         const min         = (await this.min        .eval(parse)).f3605();         const max         = (await this.max        .eval(parse)).f3605();         const scale       = (await this.scale      .eval(parse)).f3605();         const offset      = (await this.offset     .eval(parse)).f3605();         const interpolate = (await this.interpolate.eval(parse)).f3605();         const detail      = (await this.detail     .eval(parse)).f3605();               if (  !this.random             || this.random.seed != seed.value)             this.random = new Random(seed.value);                   let size  = 1;         let power = 1;                  const avg = (min.value + max.value) / 2;         let   r;                   if (   this.options.enabled             && scale             && offset)         {             r = avg;                          for (let c = 0; c < detail.value; c++)             {                 const i = this.iteration / (Math.max(0.000001, scale.value) * size) + offset.value;                                  const i0 = Math.floor(i);                 const i1 = Math.ceil (i);                  const r0 = this.random.get(i0);                 const r1 = this.random.get(i1);                   let _r;                                  switch (interpolate.value)                 {                     case 0: _r = power * r0;                                                 break;                     case 1: _r = power * n1029(r0, r1, i-i0);                                 break;                     case 2: _r = power * (r0 + (r1 - r0) * (-Math.cos((i-i0)*Tau/2) + 1)/2); break;                 }                  r +=                      - power * (avg       - min.value)                     + _r    * (max.value - min.value);                   size  /= 2;                 power /= 2;             }         }         else         {             r = min.value;         }           this.value = new p1983(r, Math.max(min.decimals, max.decimals));           this.n4078(parse,         [             ['seed',        seed       ],             ['min',         min        ],             ['max',         max        ],             ['scale',       scale      ],             ['offset',      offset     ],             ['interpolate', interpolate],             ['detail',      detail     ]         ]);                   this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed        && this.seed       .isValid()             && this.min         && this.min        .isValid()             && this.max         && this.max        .isValid()             && this.scale       && this.scale      .isValid()             && this.offset      && this.offset     .isValid()             && this.interpolate && this.interpolate.isValid()             && this.detail      && this.detail     .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.seed       ) this.seed       .x4065(parse);         if (this.min        ) this.min        .x4065(parse);         if (this.max        ) this.max        .x4065(parse);         if (this.scale      ) this.scale      .x4065(parse);         if (this.offset     ) this.offset     .x4065(parse);         if (this.interpolate) this.interpolate.x4065(parse);         if (this.detail     ) this.detail     .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.seed       ) this.seed       .v4066(parse, from, force);         if (this.min        ) this.min        .v4066(parse, from, force);         if (this.max        ) this.max        .v4066(parse, from, force);         if (this.scale      ) this.scale      .v4066(parse, from, force);         if (this.offset     ) this.offset     .v4066(parse, from, force);         if (this.interpolate) this.interpolate.v4066(parse, from, force);         if (this.detail     ) this.detail     .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.seed       ) this.seed       .m4064(parse);         if (this.min        ) this.min        .m4064(parse);         if (this.max        ) this.max        .m4064(parse);         if (this.scale      ) this.scale      .m4064(parse);         if (this.offset     ) this.offset     .m4064(parse);         if (this.interpolate) this.interpolate.m4064(parse);         if (this.detail     ) this.detail     .m4064(parse);     } } 


class u1900 extends h2004 {     seed   = null;     chance = null;      random = null;        constructor(nodeId, options)     {         super(p1103, nodeId, options);     }            reset()     {         super.reset();          this.seed   = null;         this.chance = null;     }        copy()     {         const copy = new y1901(this.nodeId, this.options);          copy.u3332(this);          if (this.seed  ) copy.seed   = this.seed  .copy();         if (this.chance) copy.chance = this.chance.copy();          if (this.random) copy.random = this.random.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const seed   = (await this.seed  .eval(parse)).f3605();         const chance = (await this.chance.eval(parse)).f3605();               if (  !this.random             || this.random.seed != seed.value)             this.random = new Random(seed.value);           const r =              this.options.enabled             ? (this.random.get(this.iteration) > 1 - chance.value/100 ? 1 : 0)             : 0;           this.value = new p1983(Math.round(r));           this.n4078(parse,         [             ['seed', seed  ],             ['min',  chance],         ]);                   this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return this.seed   && this.seed  .isValid()             && this.chance && this.chance.isValid()             && this.max    && this.max   .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.seed  ) this.seed  .x4065(parse);         if (this.chance) this.chance.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.seed  ) this.seed  .v4066(parse, from, force);         if (this.chance) this.chance.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.seed  ) this.seed  .m4064(parse);         if (this.chance) this.chance.m4064(parse);     } } 


class i1887 extends r2005 {     current;     when;        constructor(nodeId, options)     {         super(i1104, nodeId, options);          this.current = new p1983(0);     }            reset()     {         super.reset();          this.current = null;         this.when    = null;     }        copy()     {         const copy = new i1887(this.nodeId, this.options);          copy.u3332(this);          if (this.when   ) copy.when    = this.when   .copy();         if (this.current) copy.current = this.current.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;         const when  = this.when  ? (await this.when .eval(parse)).f3605() : null;                       if (   input             && when)         {             if (this.options.enabled)             {                 if (when.value == 0)                     this.value = this.current.copy();                  if (input)                 {                     this.current.value += input.value;                     this.current.decimals = Math.max(this.current.decimals, input.decimals);                 }                  if (when.value > 0)                     this.value = this.current.copy();             }             else                 this.value = input;         }         else             this.value = p1983.NaN.copy();           this.n4078(parse,          [             ['when', when]         ]);                   this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.when && this.when.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.when) this.when.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.when) this.when.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.when) this.when.m4064(parse);     }        w3604(parse, nodeId)     {         super.w3604(parse, nodeId);          this.current = new p1983(0);     } } 


class u1893 extends p2006 {     amount;       constructor(nodeId, options)     {         super(z1105, nodeId, options);     }            reset()     {         super.reset();          this.amount = null;     }        copy()     {         const copy = new u1893(this.nodeId, this.options);          copy.u3332(this);          copy.amount = this.amount.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount = (await this.amount.eval(parse)).f3605();           if (   this.p4060              && this.f4061)         {             const x3664 = (await this.p4060.eval(parse)).f3605();             const val1 = (await this.f4061.eval(parse)).f3605();              const maxDec = Math.max(x3664.decimals, val1.decimals);              this.value = new p1983(                 x3664.value + amount.value * (val1.value - x3664.value) / 100,                 maxDec);         }         else if (this.p4060)             this.value = (await this.p4060.eval(parse)).f3605();          else if (this.f4061)              this.value = (await this.f4061.eval(parse)).f3605();          else                               this.value = p1983.NaN;           this.n4078(parse,         [             ['amount', amount    ],             ['value',  this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.amount && this.amount.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.amount) this.amount.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.amount) this.amount.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.amount) this.amount.m4064(parse);     } } 


class u1907 extends r2005 {     current = null;     target  = null;      temp    = null;            constructor(nodeId, options)     {         super(x1093, nodeId, options);     }            reset()     {         super.reset();          this.current = null;         this.target  = null;         this.temp    = null;     }        copy()     {         const copy = new u1907(this.nodeId, this.options);          copy.u3332(this);          copy.current = this.current.copy();         copy.target  = this.target .copy();          return copy;     }        isCached()     {         return super.isCached()             && this.current.isCached()             && this.target .isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           let   current = (await this.current.eval(parse)).f3605();         const target  = (await this.target .eval(parse)).f3605();           if (   this.input             && current.isValid()             && target .isValid())         {             let input = (await this.input.eval(parse)).f3605();              s946(                 input.type == g1086,                  'input.type must be NUMBER_VALUE');               if (this.options.enabled)             {                 let   diff      = target.value - current.value;                 let   prevDiff  = 0;                   let   temp      = 0;                 let   step      = Number.MAX_SAFE_INTEGER/65536;                   let   iter      = 0;                 const maxIter   = 1000;                                   i2038(this.nodeId);                   parse.f3612 += maxIter;                   while (iter++ < maxIter)                 {                     temp += step;                       if (this.input.type == y1292)                     {                         this.input.node[this.input.e2963].value    = temp;                         this.input.node[this.input.e2963].decimals = r998(temp);                     }                                               this.current.v4066(parse, this);                     current = (await this.current.eval(parse)).f3605();                                                                                      if (current.isValid())                     {                         diff = target.value - current.value;                                                   if (Math.abs(diff) < 0.0000001)                             break;                                                       if (   Math.abs (diff) >  Math.abs (prevDiff)                             || Math.sign(diff) != Math.sign(prevDiff))                             step /= -2;                                                                             prevDiff = diff;                     }                                               parse.j3611++;                     b2039(parse, this.nodeId, iter / maxIter);                 }                   if (iter < maxIter)                 {                     parse.j3611 += maxIter - iter;                      input = (await this.input.eval(parse)).f3605();                     this.value = input;                 }                 else                 {                     this.value = p1983.NaN;                     console.warn('max solve iterations');                 }             }             else                 this.value = input;         }         else         {             if (this.input)                  await this.input.eval(parse);              this.value = p1983.NaN;         }                             this.n4078(parse,         [                          ['current', current   ],             ['target',  target    ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.current && this.current.isValid()             && this.target  && this.target .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.current) this.current.x4065(parse);         if (this.target ) this.target .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.current) this.current.v4066(parse, from, force);         if (this.target ) this.target .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.current) this.current.m4064(parse);         if (this.target ) this.target .m4064(parse);     } } 


class c1888 extends h2004 {     from   = null;     to     = null;     curve  = null;     repeat = null;     length = null;     time   = null;                    constructor(nodeId, options)     {         super(m1107, nodeId, options);     }                    reset()     {         super.reset();                  this.from   = null;         this.to     = null;         this.curve  = null;         this.repeat = null;         this.length = null;         this.time   = null;     }        copy()     {         const copy = new c1888(this.nodeId, this.options);          copy.u3332(this);          if (this.from  ) copy.from   = this.from  .copy();         if (this.to    ) copy.to     = this.to    .copy();         if (this.curve ) copy.curve  = this.curve .copy();         if (this.repeat) copy.repeat = this.repeat.copy();         if (this.length) copy.length = this.length.copy();         if (this.time  ) copy.time   = this.time  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from   = (await this.from  .eval(parse)).f3605();         const to     = (await this.to    .eval(parse)).f3605();         const curve  = (await this.curve .eval(parse)).f3605();         const repeat = (await this.repeat.eval(parse)).f3605();         const length = (await this.length.eval(parse)).f3605();         const time   = (await this.time  .eval(parse)).f3605();               const maxDec = Math.max(from.decimals, to.decimals);          switch (curve.value)         {             case 0:              {                 this.value = new p1983(                     time.value < length.value ? from.value : to.value,                      maxDec);                      break;             }             case 1:              {                 this.value = new p1983(                     from.value + (to.value - from.value) * time.value / length.value,                     maxDec);                  break;             }             case 2:              {                 let f = time.value / length.value;                  f = 1 - sqr(1 - f);                  this.value = new p1983(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 3:              {                 let f = time.value / length.value;                  f = sqr(f);                  this.value = new p1983(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }             case 4:              {                 let f = time.value / length.value;                  f = 6*Math.pow(f, 5) - 15*Math.pow(f, 4) + 10*Math.pow(f, 3);                  this.value = new p1983(                     from.value + (to.value - from.value) * f,                     maxDec);                      break;             }         }                   this.n4078(parse,         [             ['from',   from  ],             ['to',     to    ],             ['curve',  curve ],             ['repeat', repeat],             ['length', length],             ['time',   time  ]         ]);                   this.validate();          return this;     }        isValid()     {         return this.from   && this.from  .isValid()             && this.to     && this.to    .isValid()             && this.curve  && this.curve .isValid()             && this.repeat && this.repeat.isValid()             && this.length && this.length.isValid()             && this.time   && this.time  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.from  ) this.from  .x4065(parse);         if (this.to    ) this.to    .x4065(parse);         if (this.curve ) this.curve .x4065(parse);         if (this.repeat) this.repeat.x4065(parse);         if (this.length) this.length.x4065(parse);         if (this.time  ) this.time  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.from  ) this.from  .v4066(parse, from, force);         if (this.to    ) this.to    .v4066(parse, from, force);         if (this.curve ) this.curve .v4066(parse, from, force);         if (this.repeat) this.repeat.v4066(parse, from, force);         if (this.length) this.length.v4066(parse, from, force);         if (this.time  ) this.time  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.from  ) this.from  .m4064(parse);         if (this.to    ) this.to    .m4064(parse);         if (this.curve ) this.curve .m4064(parse);         if (this.repeat) this.repeat.m4064(parse);         if (this.length) this.length.m4064(parse);         if (this.time  ) this.time  .m4064(parse);     } } 


class i1864 extends v1861 {     operation;        constructor(nodeId, options)     {         super(f1109, nodeId, options);     }       reset()     {         super.reset();          this.operation = null;     }            copy()     {         const copy = new i1864(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.operation) copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op = (await this.operation.eval(parse)).f3605().b3703();          op.value    = Math.min(Math.max(0, Math.round(op.value)), v1295.length-1);         op.decimals = 0;           switch (op.value)         {             case 0: this.value = await j3672(this.inputs, parse); break;             case 1: this.value = await p3671     (this.inputs, parse); break;             case 2: this.value = await i3675  (this.inputs, parse); break;             case 3: this.value = await g3674  (this.inputs, parse); break;             case 4: this.value = await m3673(this.inputs, parse); break;             case 5: this.value = await i3676(this.inputs, parse); break;         }           this.n4078(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.operation) this.operation.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.operation) this.operation.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.operation) this.operation.m4064(parse);     } } 


class b1867 extends r2005 {     operation;     operand;     invert;        constructor(nodeId, options)     {         super(a1108, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;         this.invert    = null;     }        copy()     {         const copy = new l1903(this.nodeId, this.options);          copy.u3332(this);          copy.operation = this.operation.copy();         copy.operand   = this.operand  .copy();         copy.invert    = this.invert   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p1983(0);           const input   = this.input     ? (await this.input    .eval(parse)).f3605() : null;         const op      = this.operation ? (await this.operation.eval(parse)).f3605() : null;         const operand = this.operand   ? (await this.operand  .eval(parse)).f3605() : null;         const invert  = this.invert    ? (await this.invert   .eval(parse)).f3605() : null;           op.value    = Math.min(Math.max(0, Math.round(op.value)), v1295.length-1);         op.decimals = 0;           if (input)         {             if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == g1086                             ? u3670(item, operand, op, invert, this.options.enabled)                             : p1983.NaN.copy());                        }                 }                 else                 {                     this.value = u3670(input, operand, op, invert, this.options.enabled);                 }             }             else                 this.value = input;         }         else             this.value = p1983.NaN.copy();           this.n4078(parse,         [                          ['type',      this.outputType()],             ['operation', op               ],             ['operand',   operand          ],             ['invert',    invert           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid()             && this.invert    && this.invert   .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.operation) this.operation.x4065(parse);         if (this.operand  ) this.operand  .x4065(parse);         if (this.invert   ) this.invert   .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.operation) this.operation.v4066(parse, from, force);         if (this.operand  ) this.operand  .v4066(parse, from, force);         if (this.invert   ) this.invert   .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.operation) this.operation.m4064(parse);         if (this.operand  ) this.operand  .m4064(parse);         if (this.invert   ) this.invert   .m4064(parse);     } }    function u3670(input, operand, op, invert, enabled) {     s946(         input.type == g1086,          'input.type is ' + input.type + ', must be NUMBER_VALUE');       if (enabled)     {         op.value = Math.min(Math.max(0, Math.floor(op.value)), v1295.length-1);          const f3669 = Math.max(input.decimals, operand.decimals);          switch (op.value)         {             case 0:                  return invert.value == 0                     ? new p1983(input.value - operand.value, f3669)                     : new p1983(operand.value - input.value, f3669);              case 1:                  return invert.value == 0                     ? new p1983(input.value + operand.value, f3669)                     : new p1983(operand.value + input.value, f3669);              case 2:                  return invert.value == 0                     ? new p1983(input.value % operand.value, f3669)                     : new p1983(operand.value % input.value, f3669);              case 3:                  if (      operand.value == 0                        && invert .value == 0                     ||    input  .value == 0                        && invert .value == 1)                     return p1983.NaN.copy();                 else                     return invert.value == 0                         ? new p1983(input.value / operand.value, f3669)                         : new p1983(operand.value / input.value, f3669);              case 4:                  return invert.value == 0                     ? new p1983(input.value * operand.value, f3669)                     : new p1983(operand.value * input.value, f3669);              case 5:                  return invert.value == 0                     ? new p1983(Math.pow(input.value, operand.value), f3669)                     : new p1983(Math.pow(operand.value, input.value), f3669);         }           u947('invalid math operation');         return input;     }     else         return input; }


class f1860 extends v1861 {     constructor(nodeId, options)     {         super(y1110, nodeId, options);     }            copy()     {         const copy = new f1860(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          this.value = await p3671(this.inputs, parse);                  this.n4078(parse,          [             ['', new i4194()]                      ]);          this.validate();          return this;     } }    async function p3671(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       const value = new p1983(0);       for (let i = 0; i < inputs.length; i++)     {         const val = (await inputs[i].eval(parse)).f3605();                  if (   !val             || !val.isValid())             return p1983.NaN;          if (w951(val.type))         {             if (   isEmpty(val.items)                 || val.items[0].type != g1086)                 return p1983.NaN;              for (const item of val.items)             {                 if (item.type == g1086)                 {                     value.value   += item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }         }         else         {             s946(                 val.type == g1086,                  'val.type must be NUMBER_VALUE');              value.value   += val.value;             value.decimals = Math.max(value.decimals, val.decimals);         }     }       return value; }


class i1868 extends v1861 {     constructor(nodeId, options)     {         super(d1111, nodeId, options);     }            copy()     {         const copy = new i1868(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await j3672(this.inputs, parse);           this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function j3672(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       let value = new p1983(0);       if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();          if (   !x3664             || !x3664.isValid())             return p1983.NaN;           if (   inputs.length == 1             && x3664.type == g1086)         {             value = new p1983(-x3664.value, x3664.decimals);         }         else if (w951(x3664.type)              && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              if (   !j3663                 || !j3663.isValid())                 return p1983.NaN;               value.value    = j3663.value;             value.decimals = j3663.decimals;              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                  if (   !item                     || !item.isValid())                     return p1983.NaN;                  if (item.type == g1086)                 {                     value.value   -= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              value.value    = x3664.value;             value.decimals = x3664.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();              if (   !val                 || !val.isValid())                 return p1983.NaN;               if (w951(val.type))             {                 for (const item of val.items)                 {                     if (item.type == g1086)                     {                         value.value   -= item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                                      value.value   -= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class w1866 extends v1861 {     constructor(nodeId, options)     {         super(x1112, nodeId, options);     }        copy()     {         const copy = new w1866(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }            async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3673(this.inputs, parse);           this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function m3673(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       const value = new p1983(0);       if (!isEmpty(inputs))     {         value.value = 1;          for (let i = 0; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();              if (   !val                 || !val.isValid())                 return p1983.NaN;               if (w951(val.type))             {                 if (   isEmpty(val.items)                     || val.items[0].type != g1086)                     return p1983.NaN;                  for (const item of val.items)                 {                     value.value   *= item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                  value.value   *= val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class b1862 extends v1861 {     constructor(nodeId, options)     {         super(v1113, nodeId, options);     }            copy()     {         const copy = new b1862(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       this.value = await g3674(this.inputs, parse);                       this.n4078(parse,          [             ['', new i4194()]         ]);           this.validate();          return this;     } }    async function g3674(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;               let value = new p1983(0);               if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();          if (   !x3664             || !x3664.isValid())             return p1983.NaN;           if (    w951(x3664.type)             && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              if (   !j3663                 || !j3663.isValid())                 return p1983.NaN;               value.value    = j3663.value;             value.decimals = j3663.decimals;              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                  if (   !item                     || !item.isValid())                     return p1983.NaN;                                       if (item.type == g1086)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.value    = value.value / item.value;                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              value.value    = x3664.value;             value.decimals = x3664.decimals;         }                   for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();              if (   !val                 || !val.isValid())                 return p1983.NaN;               if (w951(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return p1983.NaN;                       if (item.type == g1086)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                                                   value.value    = value.value / item.value;                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                                                        value.value    = value.value / val.value;                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class i1865 extends v1861 {     constructor(nodeId, options)     {         super(s1114, nodeId, options);     }            copy()     {         const copy = new i1865(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3675(this.inputs, parse);           this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function i3675(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;               const value = new p1983(0);               if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();          if (   !x3664             || !x3664.isValid())             return p1983.NaN;           if (    w951(x3664.type)             && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              if (   !j3663                 || !j3663.isValid())                 return p1983.NaN;               value.value    = j3663.value;             value.decimals = j3663.decimals;              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                                  if (   !item                     || !item.isValid())                     return p1983.NaN;                   if (item.type == g1086)                 {                     if (item.value == 0)                      {                          value.value    = Number.NaN;                          value.decimals = 0;                         break;                      }                      value.decimals = Math.max(value.decimals, item.decimals);                     value.value    = value.value % item.value;                 }                                 }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              value.value    = x3664.value;             value.decimals = x3664.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();              if (   !val                 || !val.isValid())                 return p1983.NaN;               if (w951(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return p1983.NaN;                       if (item.type == g1086)                     {                         if (item.value == 0)                          {                              value.value    = Number.NaN;                              value.decimals = 0;                             break;                          }                          value.decimals = Math.max(value.decimals, item.decimals);                         value.value    = m1009(value.value % item.value, value.decimals);                     }                                     }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                  if (val.value == 0)                  {                      value.value    = Number.NaN;                      value.decimals = 0;                     break;                  }                  value.decimals = Math.max(value.decimals, val.decimals);                 value.value    = m1009(value.value % val.value, value.decimals);             }         }     }       return value; }


class m1863 extends v1861 {     constructor(nodeId, options)     {         super(d1115, nodeId, options);     }            copy()     {         const copy = new m1863(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await i3676(this.inputs, parse);           this.n4078(parse, [['value', this.value]]);           this.validate();          return this;     } }    async function i3676(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       const value = new p1983(0);       if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();          if (   !x3664             || !x3664.isValid())             return p1983.NaN;           if (    w951(x3664.type)             && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              if (   !j3663                 || !j3663.isValid())                 return p1983.NaN;               value.value    = j3663.value;             value.decimals = j3663.decimals;              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                                  if (   !item                     || !item.isValid())                     return p1983.NaN;                   if (item.type == g1086)                 {                     value.value    = Math.pow(value.value,    item.value);                     value.decimals = Math.max(value.decimals, item.decimals);                 }                                 }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              value.value    = x3664.value;             value.decimals = x3664.decimals;         }           for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();              if (   !val                 || !val.isValid())                 return p1983.NaN;               if (w951(val.type))             {                 for (const item of val.items)                 {                     if (   !item                         || !item.isValid())                         return p1983.NaN;                      if (item.type == g1086)                     {                         value.value    = Math.pow(value.value,    item.value);                         value.decimals = Math.max(value.decimals, item.decimals);                     }                                     }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                  value.value    = Math.pow(value.value,    val.value);                 value.decimals = Math.max(value.decimals, val.decimals);             }         }     }       return value; }


class l1870 extends v1861 {     operation;        constructor(nodeId, options)     {         super(c1116, nodeId, options);     }        reset()     {         super.reset();          this.operation = null;     }           copy()     {         const copy = new l1870(this.nodeId, this.options);          copy.u3332(this);          copy.inputs    = this.inputs.map(i => i.copy());         copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op = (await this.operation.eval(parse)).f3605().b3703();          op.value = op.e3764 = Math.min(Math.max(0, op.value), j1301.length-1);                   switch (op.value)         {             case e1297: this.value = await h3668(this.inputs, parse); break;             case g1298: this.value = await a3665 (this.inputs, parse); break;             case p1299:  this.value = await q3666  (this.inputs, parse); break;             case u1300: this.value = await f3667 (this.inputs, parse); break;         }                   this.n4078(parse,         [                          ['operation', op        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.operation) this.operation.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.operation) this.operation.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.operation) this.operation.m4064(parse);     } }


class z1871 extends v1861 {     constructor(nodeId, options)     {         super(l1117, nodeId, options);     }            copy()     {         const copy = new z1871(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await h3668(this.inputs, parse);                   this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function h3668(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       const value = new p1983();       if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();         if (!x3664.isValid()) return p1983.NaN;          if (    w951(x3664.type)             && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              value.value = j3663.o3677() != 0 ? 0 : 1;              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                                  if (   item.type == g1086                     && item.o3677() == 0)                     value.value = 1;             }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              value.value = x3664.o3677() != 0 ? 0 : 1;         }           for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();             if (!val.isValid()) return p1983.NaN;              if (w951(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == g1086                         && item.o3677() == 0)                         value.value = 1;                 }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                  if (val.o3677() == 0)                     value.value = 1;             }         }     }       return value; } 


class c1869 extends v1861 {     constructor(nodeId, options)     {         super(c1118, nodeId, options);     }            copy()     {         const copy = new c1869(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await f3667(this.inputs, parse);                   this.n4078(parse,          [             ['', new i4194()]                      ]);                   this.validate();          return this;     } }    async function f3667(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       const value = new p1983();       if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();         if (!x3664.isValid()) return p1983.NaN;          if (    w951(x3664.type)             && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              value.value = j3663.o3677();              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                                  if (item.type == g1086)                     value.value = Math.min(value.value, item.o3677());             }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              value.value = x3664.o3677();         }           for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();             if (!val.isValid()) return p1983.NaN;              if (w951(val.type))             {                 for (const item of val.items)                 {                     if (item.type == g1086)                         value.value = Math.min(value.value, item.o3677());                 }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                  value.value = Math.min(value.value, val.o3677());             }         }                   if (value.value != 0)             value.value = 1;     }       return value; }


class m1872 extends v1861 {     constructor(nodeId, options)     {         super(y1119, nodeId, options);     }            copy()     {         const copy = new m1872(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await q3666(this.inputs, parse);                   this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function q3666(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       const value = new p1983();       if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();         if (!x3664.isValid()) return p1983.NaN;          if (    w951(x3664.type)             && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              value.value = j3663.o3677();              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                                  if (item.type == g1086)                     value.value = Math.max(value.value, item.o3677());             }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              value.value = x3664.o3677();         }           for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();             if (!val.isValid()) return p1983.NaN;              if (w951(val.type))             {                 for (const item of val.items)                 {                     if (item.type == g1086)                         value.value = Math.max(value.value, item.o3677());                 }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                                      value.value = Math.max(value.value, val.o3677());             }         }           if (value.value != 0)             value.value = 1;     }       return value; }


class z1873 extends v1861 {     constructor(nodeId, options)     {         super(l1120, nodeId, options);     }            copy()     {         const copy = new z1873(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await a3665(this.inputs, parse);                   this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function a3665(inputs, parse) {     if (isEmpty(inputs))         return p1983.NaN;       const value = new p1983(0);       let flipped;      if (!isEmpty(inputs))     {         const x3664 = (await inputs[0].eval(parse)).f3605();         if (!x3664.isValid()) return p1983.NaN;          if (    w951(x3664.type)             && !isEmpty(x3664.items))         {             const j3663 = x3664.items[0];              flipped = j3663.o3677() != 0;              for (let i = 1; i < x3664.items.length; i++)             {                 const item = x3664.items[i];                                  if (   item.type == g1086                     && item.o3677() != 0)                     flipped++;             }         }         else         {             if (x3664.type != g1086)                 return p1983.NaN;              flipped = x3664.o3677() != 0;         }           for (let i = 1; i < inputs.length; i++)         {             const val = (await inputs[i].eval(parse)).f3605();             if (!val.isValid()) return p1983.NaN;              if (w951(val.type))             {                 for (const item of val.items)                 {                     if (   item.type == g1086                         && item.o3677() != 0)                         flipped++;                     }             }             else             {                 s946(                     val.type == g1086,                      'val.type must be NUMBER_VALUE');                                      if (val.o3677() != 0)                     flipped++;             }         }           value.value = flipped == 1 ? 1 : 0;     }       return value; }


class z1874 extends r2005 {     operation;     operand;        constructor(nodeId, options)     {         super(m1121, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;         this.operand   = null;     }        copy()     {         const copy = new z1874(this.nodeId, this.options);          copy.u3332(this);          copy.operation = this.operation.copy();         copy.operand   = this.operand  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op      = (await this.operation.eval(parse)).f3605();         const operand = (await this.operand  .eval(parse)).f3605();          op.value = Math.min(Math.max(0, op.value), j1308.length-1);                   switch (op.value)         {             case u1302:              this.value = await m3662(this.input, operand, ((a, b) => a <  b), parse);  break;             case h1303:     this.value = await m3662(this.input, operand, ((a, b) => a <= b), parse);  break;             case z1304:         this.value = await m3662(this.input, operand, ((a, b) => a != b), parse);  break;             case o1305:             this.value = await m3662(this.input, operand, ((a, b) => a == b), parse);  break;             case y1306:  this.value = await m3662(this.input, operand, ((a, b) => a >= b), parse);  break;             case m1307:           this.value = await m3662(this.input, operand, ((a, b) => a >  b), parse);  break;         }           this.n4078(parse,         [                          ['operation', op        ],             ['operand',   operand   ]         ]);           this.validate();      return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid()             && this.operand   && this.operand  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.operation) this.operation.x4065(parse);         if (this.operand  ) this.operand  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.operation) this.operation.v4066(parse, from, force);         if (this.operand  ) this.operand  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.operation) this.operation.m4064(parse);         if (this.operand  ) this.operand  .m4064(parse);     } }    async function m3662(p4060, f4061, op, parse)  {     const x3664 = p4060 ? (await p4060.eval(parse)).f3605() : p1983.NaN;     const val1 = f4061 ? (await f4061.eval(parse)).f3605() : p1983.NaN;      if (   x3664.isValid()          && val1.isValid())         return new p1983(op(x3664.o3677(), val1.o3677()) ? 1 : 0);     else                           return p1983.NaN; }


class x1875 extends p2006 {     constructor(nodeId, options)     {         super(q1122, nodeId, options);     }            copy()     {         const copy = new x1875(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3662(             this.p4060,              this.f4061,              (a, b) => a == b,              parse);                       this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } } 


class o1880 extends p2006 {     constructor(nodeId, options)     {         super(l1123, nodeId, options);     }            copy()     {         const copy = new o1880(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3662(             this.p4060,              this.f4061,              (a, b) => a != b,              parse);                   this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }


class d1878 extends p2006 {     constructor(nodeId, options)     {         super(c1124, nodeId, options);     }            copy()     {         const copy = new d1878(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3662(             this.p4060,              this.f4061,              (a, b) => a < b,              parse);                       this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }


class w1879 extends p2006 {     constructor(nodeId, options)     {         super(m1125, nodeId, options);     }            copy()     {         const copy = new w1879(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3662(             this.p4060,              this.f4061,              (a, b) => a <= b,              parse);                       this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } } 


class h1876 extends p2006 {     constructor(nodeId, options)     {         super(q1126, nodeId, options);     }            copy()     {         const copy = new h1876(this.nodeId, this.options);         copy.u3332(this);         copy.inputs = this.inputs.map(i => i.copy());         return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3662(             this.p4060,              this.f4061,              (a, b) => a > b,              parse);                   this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }


class x1877 extends p2006 {     constructor(nodeId, options)     {         super(k1127, nodeId, options);     }            copy()     {         const copy = new x1877(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await m3662(             this.p4060,              this.f4061,              (a, b) => a >= b,              parse);                       this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } } 


class m1885 extends r2005 {     function;        constructor(nodeId, options)     {         super(o1128, nodeId, options);     }            reset()     {         super.reset();          this.function = null;     }        copy()     {         const copy = new m1885(this.nodeId, this.options);          copy.u3332(this);          copy.function = this.function.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input    ? (await this.input   .eval(parse)).f3605() : null;         const func  = this.function ? (await this.function.eval(parse)).f3605().b3703() : null;          func.value = Math.min(Math.max(0, func.value), e1315.length-1);                   if (this.options.enabled)         {             switch (func.value)             {                 case o1309:  this.value = await x4213   (input, false);  break;                 case t1310:  this.value = await x4214 (input, false);  break;                 case f1311:  this.value = await s4215(input, false);  break;                 case j1312: this.value = await x4213   (input, true );  break;                 case s1313: this.value = await x4214 (input, true );  break;                 case j1314: this.value = await s4215(input, true );  break;             }         }         else             this.value = input;           this.n4078(parse,         [                          ['function', func      ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.function && this.function.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.function) this.function.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.function) this.function.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.function) this.function.m4064(parse);     } }


class n1883 extends r2005 {     constructor(nodeId, options)     {         super(f1129, nodeId, options);     }            copy()     {         const copy = new n1883(this.nodeId, this.options);                  copy.u3332(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await x4213(this.input, parse);           this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     }        f3605()     {         return this.value.copy();     } }    async function x4213(input, arc) {     if (!input)         return p1983.NaN;      const val =          !arc          ? Math.sin (input.value)          : Math.asin(input.value);      return new p1983(val, r998(val)); }


class c1882 extends r2005 {     constructor(nodeId, options)     {         super(y1130, nodeId, options);     }            copy()     {         const copy = new c1882(this.nodeId, this.options);                  copy.u3332(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await x4214(this.input, parse);           this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function x4214(input, arc) {     if (!input)         return p1983.NaN;      const val =          !arc          ? Math.cos (input.value)          : Math.acos(input.value);     return new p1983(val, r998(val)); }


class t1884 extends r2005 {     constructor(nodeId, options)     {         super(v1131, nodeId, options);     }            copy()     {         const copy = new t1884(this.nodeId, this.options);                  copy.u3332(this);          if (this.input) copy.input = this.input.copy();                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = await s4215(this.input, parse);           this.n4078(parse,          [             ['', new i4194()]                      ]);           this.validate();          return this;     } }    async function s4215(input, arc) {     if (!input)         return p1983.NaN;      const val =          !arc          ? Math.tan (input.value)          : Math.atan(input.value);          return new p1983(val, r998(val)); }


class y1881 extends h2004 {     x;     y;            constructor(nodeId, options)     {         super(p1132, nodeId, options);     }            reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new y1881(this.nodeId, this.options);          copy.u3332(this);          copy.x = this.x.copy();         copy.y = this.x.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x = this.x ? (await this.x.eval(parse)).f3605() : null;         const y = this.y ? (await this.y.eval(parse)).f3605() : null;           this.value = new p1983(Math.atan2(y.value, x.value));           this.n4078(parse,         [                          ['x',     x         ],             ['y',     y         ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.x) this.x.x4065(parse);         if (this.y) this.y.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.x) this.x.v4066(parse, from, force);         if (this.y) this.y.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.x) this.x.m4064(parse);         if (this.y) this.y.m4064(parse);     } } 


class g1890 extends r2005 {     from;        constructor(nodeId, options)     {         super(i1133, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new g1890(this.nodeId, this.options);          copy.u3332(this);          copy.from = this.from.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p1983(0);                   const from = (await this.from.eval(parse)).f3605();           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              s946(                 this.value.type == g1086,                  'this.value.type must be NUMBER_VALUE');                           if (this.options.enabled)             {                 switch (from.value)                 {                     case 0: this.value.value = this.value.value/360 * Tau; break;                     case 1: this.value.value = this.value.value/Tau * 360; break;                 }             }              this.value.decimals = r998(this.value.value);         }         else             this.value = p1983.NaN;           this.n4078(parse,         [             ['value', this.value],             ['from',  from      ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.from) this.from.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.from) this.from.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.from) this.from.m4064(parse);     } } 


class d1953 extends r2005 {     constructor(nodeId, options)     {         super(s1139, nodeId, options);     }        copy()     {         const copy = new d1953(this.nodeId, this.options);                  copy.u3332(this);          copy.value = this.value;                  return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)             this.value = (await this.input.eval(parse)).f3605();         else if (this.value)             await this.value.eval(parse);         else             this.value = new c1994();           this.n4078(parse,         [             ['value', this.value]         ]);                   this.validate();          return this;     }        isValid()     {         return   !this.input                && this.value != a957              || this.input.isValid();     }        isValid()     {         return ;     } }


class f1961 extends r2005 {     constructor(nodeId, options)     {         super(k1140, nodeId, options);     }            copy()     {         const copy = new f1961(this.nodeId, this.options);          copy.u3332(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let length;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();             s946(input.type == r1138, 'input must be TEXT_VALUE');              length = new p1983(input.value.length);         }         else             length = p1983.NaN;               this.n4078(parse,         [             ['length', length]         ]);           this.validate();          return this;     } } 


class e1968 extends r2005 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(u1141, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new e1968(this.nodeId, this.options);          copy.u3332(this);          copy.start = this.start.copy();         copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = (await this.start.eval(parse)).f3605();         const end   = (await this.end  .eval(parse)).f3605();           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();                          if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == r1138                         ? t3403(item, start, end, this.options.enabled)                         : new c1994());                    }             }             else             {                 this.value = t3403(input, start, end, this.options.enabled);             }         }         else             this.value = new c1994();           this.n4078(parse,         [                          ['type',  this.outputType()],             ['start', start            ],             ['end',   end              ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.start) this.start.x4065(parse);         if (this.end  ) this.end  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.start) this.start.v4066(parse, from, force);         if (this.end  ) this.end  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.start) this.start.m4064(parse);         if (this.end  ) this.end  .m4064(parse);     } }    function t3403(input, start, end, enabled) {     s946(input.type == r1138, 'input.type must be TEXT_VALUE');                     const value = input.copy();      if (enabled)     {         if (start.value.length > 0) value.value = p948(value.value, q1458(start.value));         if (end  .value.length > 0) value.value = b949  (value.value, q1458(end  .value));     }      return value; }


class d1965 extends r2005 {     start = null;     end   = null;            constructor(nodeId, options)     {         super(o1142, nodeId, options);     }            reset()     {         super.reset();          this.start = null;         this.end   = null;     }        copy()     {         const copy = new d1965(this.nodeId, this.options);          copy.u3332(this);          copy.start = this.start.copy();         copy.end   = this.end  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const start = (await this.start.eval(parse)).f3605();         const end   = (await this.end  .eval(parse)).f3605();          let   length = 0;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();                          length = input.value.length;                          this.value = input.copy();                          s946(this.value.type == r1138, 'this.value.type must be TEXT_VALUE');                                               const _end =                 end.isValid()                 ? end                 : new p1983(input.value.length);               if (start.value <= _end.value)             {                 if (this.options.enabled)                     this.value.value = this.value.value.substring(start.value, _end.value);             }             else                 this.value = new c1994();         }         else             this.value = new c1994();           this.n4078(parse,         [                          ['length', new p1983(length)],              ['start',  start                  ],             ['end',    end                    ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.start && this.start.isValid()             && this.end   && this.end  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.start) this.start.x4065(parse);         if (this.end  ) this.end  .x4065(parse);     }        x4065(parse)     {         super.x4065(parse);          if (this.start) this.start.x4065(parse);         if (this.end  ) this.end  .x4065(parse);     }        m4064(parse, from)     {         super.m4064(parse, from);          if (this.start) this.start.m4064(parse, from);         if (this.end  ) this.end  .m4064(parse, from);     } } 


class a1956 extends p2006 {     first;     last;     all;        constructor(nodeId, options)     {         super(g1143, nodeId, options);     }            reset()     {         super.reset();          this.first = null;         this.last  = null;         this.all   = null;     }        copy()     {         const copy = new a1956(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;         const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;               if (   p4060 && p4060.isValid()              && f4061 && f4061.isValid())         {             const indices = [];             let   index   = 0;              if (f4061.value != '')             {                 while (index != -1)                  {                     index = p4060.value.indexOf(f4061.value, index);                      if (index != -1)                      {                         indices.push(index);                         index += 1;                     }                 }                                   this.value = new p1983(indices.length > 0 ? 1 : 0);                  this.first = indices.length > 0 ? new p1983(indices.at( 0)) : p1983.NaN;                 this.last  = indices.length > 0 ? new p1983(indices.at(-1)) : p1983.NaN;                  this.all   = new p1982();                  for (const index of indices)                     this.all.items.push(new p1983(index));             }             else             {                 this.value = new p1983(1);                  this.first = p1983.NaN;                 this.last  = p1983.NaN;                 this.all   =   p1982.NaN;             }         }         else                           {             this.value = p1983.NaN;             this.first = p1983.NaN;             this.last  = p1983.NaN;             this.all   =   p1982.NaN;         }               this.n4078(parse,         [             ['value', this.value],             ['first', this.first],             ['last',  this.last ],             ['all',   this.all  ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.first && this.first.isValid()             && this.last  && this.last .isValid()             && this.all   && this.all  .isValid();     } }


class b1954 extends r2005 {     case;            constructor(nodeId, options)     {         super(x1144, nodeId, options);     }            reset()     {         super.reset();          this.case = null;     }        copy()     {         const copy = new b1954(this.nodeId, this.options);          copy.u3332(this);          copy.case = this.case.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;         const o3631 = this.case  ? (await this.case .eval(parse)).f3605() : null;           if (input)         {             if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == r1138                             ? getTextCaseValue(item, o3631)                             : new c1994());                        }                 }                 else                 {                     this.value = getTextCaseValue(input, o3631);                 }             }             else                 this.value = input;         }         else             this.value = new c1994();           this.n4078(parse,         [                          ['type',   this.outputType()],             ['case',  o3631             ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.case && this.case.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.case) this.case.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.case) this.case.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.case) this.case.m4064(parse);     } }    function getTextCaseValue(input, o3631) {     s946(input.type == r1138, 'input.type must be TEXT_VALUE');      const val   = input.value;     const value = new c1994();           if (o3631.value == 0)           value.value = val.toLowerCase();      else if (o3631.value == 1)     {         if (val.length > 0) value.value += val.substring(0, 1).toUpperCase();         if (val.length > 1) value.value += val.substring(1)   .toLowerCase();     }      else if (o3631.value == 2)     {         let i = 0;         while (i < val.length)         {             while (i < val.length                 && /\s/.test(val.charAt(i)))                 value.value += val.charAt(i++);              if (i < val.length)                 value.value += val.charAt(i++).toUpperCase();              while (i < val.length                 && !/\s/.test(val.charAt(i)))                 value.value += val.charAt(i++).toLowerCase();         }     }      else if (o3631.value == 3)          value.value = val.toUpperCase();       return value; }


class r1952 extends r2005 {     base;     decimals;     thousands;            constructor(nodeId, options)     {         super(y1152, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new r1952(this.nodeId, this.options);          copy.u3332(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = this.input     ? (await this.input    .eval(parse)).f3605() : null;         const base      = this.base      ? (await this.base     .eval(parse)).f3605() : null;         const decimals  = this.decimals  ? (await this.decimals .eval(parse)).f3605() : null;         const thousands = this.thousands ? (await this.thousands.eval(parse)).f3605() : null;           if (input)         {             if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1086                         ? f3404(item, base, decimals, thousands)                         : c1994.NaN.copy());                    }             }             else             {                 this.value = f3404(input, base, decimals, thousands);             }         }         else             this.value = c1994.NaN.copy();           this.n4078(parse,         [                          ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.base     ) this.base     .x4065(parse);         if (this.decimals ) this.decimals .x4065(parse);         if (this.thousands) this.thousands.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.base     ) this.base     .v4066(parse, from, force);         if (this.decimals ) this.decimals .v4066(parse, from, force);         if (this.thousands) this.thousands.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.base     ) this.base     .m4064(parse);         if (this.decimals ) this.decimals .m4064(parse);         if (this.thousands) this.thousands.m4064(parse);     } }    function f3404(input, base, decimals, thousands) {     return new c1994(n1000(          input.value,          -input.decimals,           base.value == 1,           decimals.value,           thousands.value)); }


class t1950 extends r2005 {     format;            constructor(nodeId, options)     {         super(j1153, nodeId, options);     }       reset()     {         super.reset();          this.format = null;     }            copy()     {         const copy = new t1950(this.nodeId, this.options);          copy.u3332(this);          if (this.format) copy.format = this.format.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const format = (await this.format.eval(parse)).f3605();           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();               if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1086                         ? getColorToTextValue(item, format)                         : c1994.NaN.copy());                    }             }             else             {                 this.value = getColorToTextValue(input, format);             }         }          else             this.value = c1994.NaN;           this.n4078(parse,         [             ['type',   this.outputType()],             ['format', format           ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.format && this.format.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.format) this.format.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.format) this.format.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.format) this.format.m4064(parse);     } }    function getColorToTextValue(input, format) {     let str = a957;      const rgb = input.y3213();      switch (format.value)     {         case 0:              str = m151(rgb);             break;          case 1:              str =                    n1000(rgb[0], -3) + ', '                 + n1000(rgb[1], -3) + ', '                 + n1000(rgb[2], -3);             break;          case 2:              str =                    Math.round(rgb[0] * 255) + ', '                 + Math.round(rgb[1] * 255) + ', '                 + Math.round(rgb[2] * 255);             break;     }      return new c1994(str); }


class g1967 extends r2005 {     base      = null;     decimals  = null;     thousands = null;            constructor(nodeId, options)     {         super(i1154, nodeId, options);     }            reset()     {         super.reset();          this.base      = null;         this.decimals  = null;         this.thousands = null;     }        copy()     {         const copy = new g1967(this.nodeId, this.options);          copy.u3332(this);          if (this.base     ) copy.base      = this.base     .copy();         if (this.decimals ) copy.decimals  = this.decimals .copy();         if (this.thousands) copy.thousands = this.thousands.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input     = this.input     ? (await this.input    .eval(parse)).f3605() : null;         const base      = this.base      ? (await this.base     .eval(parse)).f3605() : null;         const decimals  = this.decimals  ? (await this.decimals .eval(parse)).f3605() : null;         const thousands = this.thousands ? (await this.thousands.eval(parse)).f3605() : null;           if (   input             && input.isValid())         {             if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == r1138                         ? getTextToNumberValue(item, base, decimals, thousands)                         : p1983.NaN.copy());                    }             }             else             {                 this.value = getTextToNumberValue(input, base, decimals, thousands);             }         }          else             this.value = p1983.NaN;           this.n4078(parse,         [             ['type',      this.outputType()],             ['base',      base             ],             ['decimals',  decimals         ],             ['thousands', thousands        ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.base      && this.base     .isValid()             && this.decimals  && this.decimals .isValid()             && this.thousands && this.thousands.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.base     ) this.base     .x4065(parse);         if (this.decimals ) this.decimals .x4065(parse);         if (this.thousands) this.thousands.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.base     ) this.base     .v4066(parse, from, force);         if (this.decimals ) this.decimals .v4066(parse, from, force);         if (this.thousands) this.thousands.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.base     ) this.base     .m4064(parse);         if (this.decimals ) this.decimals .m4064(parse);         if (this.thousands) this.thousands.m4064(parse);     } }    function getTextToNumberValue(input, base, decimals, thousands) {     let num   = Number.NaN;     let value = input.value;      value = value.replaceAll(thousands.value, '');           switch (base.value)     {         case 0:          {             if (value.lastIndexOf(decimals.value) < 0)                 num = parseInt(value.replace(/\D/g, ''), 10);             else             {                 value = y1465(value, decimals.value, '.');                 num   = parseFloat(value);             }                   break;         }         case 1:          {             const decIndex = value.lastIndexOf(decimals.value);              if (decIndex < -1)                 num = parseInt(value, 16);             else             {                 const whole = value.slice(0, decIndex);                 const frac  = value.slice(decIndex + decimals.value.length);                  num =                        parseInt(whole, 16)                     + frac.split('')                           .reduce((sum, digit, index) => sum + parseInt(digit, 16) / Math.pow(16, index + 1), 0);             }              break;         }     }      return new p1983(num, r998(num)); }


class u1966 extends r2005 {     constructor(nodeId, options)     {         super(u1155, nodeId, options);     }            copy()     {         const copy = new u1966(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == r1138                         ? getTextToColorValue(item)                         : p1983.NaN.copy());                    }             }             else             {                 this.value = getTextToColorValue(input);             }         }         else             this.value = c1971.NaN;           this.n4078(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getTextToColorValue(input) {     const str = input.value.trim();      let rgb =          str != ''         ? g153(str)         : rgb_NaN;              return c1971.w3748(g4119(rgb)); }


class n1949 extends r2005 {     constructor(nodeId, options)     {         super(b1149, nodeId, options);     }            copy()     {         const copy = new n1949(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;           if (input)         {             if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == g1086                         ? getCodeToCharacterValue(item)                         : c1994.NaN.copy());                    }             }             else             {                 this.value = getCodeToCharacterValue(input);             }         }         else             this.value = c1994.NaN.copy();           this.n4078(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCodeToCharacterValue(input) {     return new c1994(String.fromCharCode(Math.min(Math.max(0, input.value), 0xffff))); }


class d1948 extends r2005 {     constructor(nodeId, options)     {         super(h1150, nodeId, options);     }            copy()     {         const copy = new d1948(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;           if (input)         {             if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == r1138                         ? getCharacterToCodeValue(item)                         : p1983.NaN.copy());                    }             }             else             {                 this.value = getCharacterToCodeValue(input);             }         }         else             this.value = p1983.NaN.copy();           this.n4078(parse,         [                          ['type',  this.outputType()]         ]);           this.validate();          return this;     } }    function getCharacterToCodeValue(input) {     return input.value.length > 0          ? new p1983(input.value.charCodeAt(0))          : p1983.NaN.copy(); }


class j1951 extends h2004 {     name;     index;            constructor(nodeId, options)     {         super(f1151, nodeId, options);     }            reset()     {         super.reset();          this.index = null;     }        copy()     {         const copy = new j1951(this.nodeId, this.options);          copy.u3332(this);          copy.name  = this.name .copy();         copy.index = this.index.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const name  = (await this.name .eval(parse)).f3605();         const index = (await this.index.eval(parse)).f3605();           switch (name.value)         {             case 0: this.value = new c1994(                 [                     'monday',                      'tuesday',                      'wednesday',                      'thursday',                      'friday',                      'saturday',                      'sunday'                 ]                  [index.value-1]);                  break;              case 1: this.value = new c1994(                 [                     'january',                      'february',                      'march',                      'april',                      'may',                      'june',                      'july',                     'august',                     'september',                     'october',                     'november',                     'december'                 ]                  [index.value-1]);                  break;              case 2:                 this.value = new c1994(v4016[index.value]);                 break;          }           this.n4078(parse,         [                          ['name',  name      ],             ['index', index     ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.index && this.index.isValid()             && this.name  && this.name .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.index) this.index.x4065(parse);         if (this.name ) this.name .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.index) this.index.v4066(parse, from, force);         if (this.name ) this.name .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.index) this.index.m4064(parse);         if (this.name ) this.name .m4064(parse);     } } 


class t1963 extends r2005 {     what  = null;     with  = null;     regex = null;        constructor(nodeId, options)     {         super(l1145, nodeId, options);     }            reset()     {         super.reset();          this.what  = null;         this.with  = null;         this.regex = null;     }        copy()     {         const copy = new t1963(this.nodeId, this.options);          copy.u3332(this);          copy.what  = this.what .copy();         copy.with  = this.with .copy();         copy.regex = this.regex.copy();          copy.value = this.value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const  input = this.input ? (await this.input.eval(parse)).f3605() : null;         const _what  = this.what  ? (await this.what .eval(parse)).f3605() : null;         const _with  = this.with  ? (await this.with .eval(parse)).f3605() : null;         const _regex = this.regex ? (await this.regex.eval(parse)).f3605() : null;           if (input)         {             if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                     {                         const item = input.items[i];                          this.value.items.push(                             item.type == r1138                             ? getReplaceValue(item, _what, _with, _regex)                             : new c1994());                        }                 }                 else                 {                     this.value = getReplaceValue(input, _what, _with, _regex);                 }             }             else                 this.value = input;         }         else             this.value = new c1994();           this.n4078(parse,         [                          ['type',   this.outputType()],             ['what',  _what             ],             ['with',  _with             ],             ['regex', _regex            ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.what  && this.what .isValid()             && this.with  && this.with .isValid()             && this.regex && this.regex.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.what ) this.what .x4065(parse);         if (this.with ) this.with .x4065(parse);         if (this.regex) this.regex.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.what ) this.what .v4066(parse, from, force);         if (this.with ) this.with .v4066(parse, from, force);         if (this.regex) this.regex.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.what ) this.what .m4064(parse);         if (this.with ) this.with .m4064(parse);         if (this.regex) this.regex.m4064(parse);     } }    function getReplaceValue(input, _what, _with, _regex) {     s946(input.type == r1138, 'input.type must be TEXT_VALUE');      const value = new c1994();           if (_regex.value > 0)     {         try         {             value.value = input.value.replace(                 new RegExp(unescapeRegexPattern(_what.value), 'gu'),                 unescapeRegexReplacement(_with.value));                                                                                                                                                                                                }         catch (e)         {                  }     }     else     {         value.value = input.value.replaceAll(             q1458(_what.value),             q1458(_with.value));     }       return value; }


class l1960 extends h2004 {     inputs = [];      with = null;            constructor(nodeId, options)     {         super(s1146, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];                  this.with = null;     }           copy()     {         const copy = new l1960(this.nodeId, this.options);         copy.u3332(this);                  copy.inputs = this.inputs.map(i => i.copy());         copy.with   = this.with;          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;           const _with = (await this.with.eval(parse)).f3605();          this.value = await evalJoinInputs(this.inputs, _with, parse);                   this.n4078(parse,         [                          ['with',  _with     ]         ]);           this.validate();          return this;     }        isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.with && this.with.isValid();     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));     } }    async function evalJoinInputs(inputs, _with, parse) {     if (isEmpty(inputs))         return new c1994();       const value = new c1994();     const w     = q1458(_with.value);      for (let i = 0; i < inputs.length; i++)     {         const val = (await inputs[i].eval(parse)).f3605();         if (!val) continue;           if (i > 0)             value.value += w;           if (w951(val.type))         {             for (let j = 0; j < val.items.length; j++)             {                 if (j > 0)                     value.value += w;                   const item = val.items[j];                  if (item.type == r1138)                     value.value += item.value;             }         }         else         {             s946(val.type == r1138, 'val.type must be TEXT_VALUE');              value.value += val.value;         }     }       return value; }


class q1962 extends r2005 {     l3627   = null;     r3628 = null;     b3629     = null;     d3630   = null;                    constructor(nodeId, options)     {         super(j1147, nodeId, options);     }            reset()     {         super.reset();                  this.l3627   = null;         this.r3628 = null;         this.b3629     = null;         this.d3630   = null;     }        copy()     {         const copy = new q1962(this.nodeId, this.options);          copy.u3332(this);          copy.l3627   = this.l3627  .copy();         copy.r3628 = this.r3628.copy();         copy.b3629     = this.b3629    .copy();         copy.d3630   = this.d3630  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l3627   = (await this.l3627  .eval(parse)).f3605();         const r3628 = (await this.r3628.eval(parse)).f3605();         const b3629     = (await this.b3629    .eval(parse)).f3605();         const d3630   = (await this.d3630  .eval(parse)).f3605();           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();                          if (w951(input.type))             {                 this.value = new p1982();                  for (let i = 0; i < input.items.length; i++)                 {                     const item = input.items[i];                      this.value.items.push(                         item.type == r1138                         ? getPadValue(                             item,                              l3627,                              r3628,                              b3629,                              d3630,                              this.options.enabled)                         : new c1994());                    }             }             else             {                 this.value = getPadValue(                     input,                      l3627,                      r3628,                      b3629,                      d3630,                      this.options.enabled);             }         }         else             this.value = new c1994();           this.n4078(parse,         [                          ['type',       this.outputType()],             ['startPad',   l3627         ],             ['startCount', r3628       ],             ['endPad',     b3629           ],             ['endCount',   d3630         ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l3627   && this.l3627  .isValid()             && this.r3628 && this.r3628.isValid()             && this.b3629     && this.b3629    .isValid()             && this.d3630   && this.d3630  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.l3627  ) this.l3627  .x4065(parse);         if (this.r3628) this.r3628.x4065(parse);         if (this.b3629    ) this.b3629    .x4065(parse);         if (this.d3630  ) this.d3630  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.l3627  ) this.l3627  .v4066(parse, from, force);         if (this.r3628) this.r3628.v4066(parse, from, force);         if (this.b3629    ) this.b3629    .v4066(parse, from, force);         if (this.d3630  ) this.d3630  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.l3627  ) this.l3627  .m4064(parse);         if (this.r3628) this.r3628.m4064(parse);         if (this.b3629    ) this.b3629    .m4064(parse);         if (this.d3630  ) this.d3630  .m4064(parse);     } }    function getPadValue(input, l3627, r3628, b3629, d3630, enabled) {     s946(input.type == r1138, 'input.type must be TEXT_VALUE');      const value = input.copy();          if (enabled)         value.value = input.value             .padStart(r3628.value, q1458(l3627.value))             .padEnd  (  d3630.value, b3629.value != '' ? q1458(b3629.value) : q1458(l3627.value));      return value; }


class w1964 extends r2005 {     value;     separator;        constructor(nodeId, options)     {         super(r1156, nodeId, options);     }        reset()     {         super.reset();          this.value     = null;         this.separator = null;     }           copy()     {         const copy = new w1964(this.nodeId, this.options);          copy.u3332(this);          if (this.value    ) copy.value     = this.value    .copy();         if (this.separator) copy.separator = this.separator.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const separator = this.separator ? (await this.separator.eval(parse)).f3605() : null;           this.value = new p1982();           if (   this.input             && separator)         {             const input = (await this.input.eval(parse)).f3605();                          if (   input                 && input.value)             {                 s946(input.type == r1138, 'input must be TEXT_VALUE');                 const items = input.value.split(q1458(separator.value));                  for (const item of items)                     this.value.items.push(new c1994(item));             }         }               this.n4078(parse,         [                          ['separator', separator ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.separator && this.separator.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.separator) this.separator.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.separator) this.separator.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.separator) this.separator.m4064(parse);     } } 


class h1955 extends p2006 {     operation;        constructor(nodeId, options)     {         super(f1148, nodeId, options);     }            reset()     {         super.reset();          this.operation = null;     }        copy()     {         const copy = new h1955(this.nodeId, this.options);          copy.u3332(this);          copy.operation = this.operation.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const op = (await this.operation.eval(parse)).f3605().b3703();          op.value = Math.min(Math.max(0, op.value), j1308.length-1);                   let result;          switch (op.value)         {             case u1302:              result = await evalCompareInputs(this.p4060, this.f4061, ((a, b) => a <  b), parse);  break;             case h1303:     result = await evalCompareInputs(this.p4060, this.f4061, ((a, b) => a <= b), parse);  break;             case z1304:         result = await evalCompareInputs(this.p4060, this.f4061, ((a, b) => a != b), parse);  break;             case o1305:             result = await evalCompareInputs(this.p4060, this.f4061, ((a, b) => a == b), parse);  break;             case y1306:  result = await evalCompareInputs(this.p4060, this.f4061, ((a, b) => a >= b), parse);  break;             case m1307:           result = await evalCompareInputs(this.p4060, this.f4061, ((a, b) => a >  b), parse);  break;         }           this.n4078(parse,         [             ['result',    result],             ['operation', op    ]         ]);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.operation && this.operation.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.operation) this.operation.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.operation) this.operation.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.operation) this.operation.m4064(parse);     } }    async function evalCompareInputs(p4060, f4061, op, parse)  {     const x3664 = p4060 ? (await p4060.eval(parse)).f3605() : c1994.NaN;     const val1 = f4061 ? (await f4061.eval(parse)).f3605() : c1994.NaN;      if (   x3664 && x3664.isValid()          && val1 && val1.isValid())         return new p1983(op(x3664.value, val1.value) ? 1 : 0);     else                           return new i4194(); }


class o1957 extends r2005 {     g3620;     u3621;        constructor(nodeId, options)     {         super(m1158, nodeId, options);     }            reset()     {         super.reset();          this.g3620    = null;         this.u3621 = null;     }        copy()     {         const copy = new o1957(this.nodeId, this.options);          copy.u3332(this);          if (this.g3620   ) copy.g3620    = this.g3620   .copy();         if (this.u3621) copy.u3621 = this.u3621.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const g3620    = this.g3620    ? (await this.g3620   .eval(parse)).f3605() : null;         const u3621 = this.u3621 ? (await this.u3621.eval(parse)).f3605() : null;           this.value = new p1982();           let maxColumns = 0;                   let nRows    = 0;         let nColumns = 0;           if (   this.input             && g3620             && u3621             && g3620.value != '')         {             const input = this.input ? (await this.input.eval(parse)).f3605() : null;                           const rows =                     input                 && input.value                             ? input.value.split(q1458(g3620.value))                 : [];               for (const _row of rows)             {                 const cells =                      _row                     ? _row.split(q1458(u3621.value))                     : [];                   const row = new p1982();                  for (const cell of cells)                     row.items.push(new c1994(cell));                  maxColumns = Math.max(maxColumns, row.items.length);                   this.value.items.push(row);             }               nRows    = this.value.items.length;             nColumns = maxColumns;         }               this.n4078(parse,         [             ['rowSeparator',    g3620             ],             ['columnSeparator', u3621          ],             ['rows',            new p1983(nRows   )],             ['columns',         new p1983(nColumns)]         ]);                   if (parse.settings.f3708)         {             this.n4078(parse,             [                 ['preview', new p1982(this.value.items.slice(0, Math.min(this.value.items.length, 11)))]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.g3620    && this.g3620   .isValid()             && this.u3621 && this.u3621.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.g3620   ) this.g3620   .x4065(parse);         if (this.u3621) this.u3621.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.g3620   ) this.g3620   .v4066(parse, from, force);         if (this.u3621) this.u3621.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.g3620   ) this.g3620   .m4064(parse);         if (this.u3621) this.u3621.m4064(parse);     } } 


class GTextJson extends r2005 {     constructor(nodeId, options)     {         super(z3477, nodeId, options);     }            copy()     {         const copy = new GTextJson(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new p1982();           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();                          try             {                 const json = JSON.parse(input.value);                 this.value = this.evalItems(json);             }             catch (e)             {                 this.value = new p1982();             }         }                        this.n4078(parse,         [             ['length',  new p1983(this.value.items.length)]                      ]);                   if (parse.settings.a3707)         {             this.n4078(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        evalItems(json)     {         let list = new p1982();           for (const key in json)         {             if (   typeof json[key] === 'object'                 && json[key] !== null)             {                 const c111 = this.evalItems(json[key]);                 c111.valueId = key;                 list.items.push(c111);             }             else             {                 let value;                  if (   typeof json[key] === 'number'                     || c1455(json[key]))                     value = p1983.fromString(json[key].toString());                 else if (typeof json[key] === 'boolean')                     value = new p1983(u917(json[key].toString()) ? 1 : 0);                 else                     value = new c1994(json[key]);                                       value.valueId =                      key == 'value'                     ? '(value)'                      : key;                  list.items.push(value);             }         }                   return list;     } } 


class o1958 extends h2004 {     request;     q4189;        constructor(nodeId, options)     {         super(w1159, nodeId, options);     }            reset()     {         super.reset();          this.request     = null;         this.q4189 = null;     }        copy()     {         const copy = new o1958(this.nodeId, this.options);          copy.u3332(this);          copy.request     = this.request    .copy();         copy.q4189 = this.q4189.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const request     = (await this.request    .eval(parse)).f3605();         const q4189 = (await this.q4189.eval(parse)).f3605();                   i2038(this.nodeId);           if (q4189.value == '')         {             try              {                 const response = await fetch(request.value);                 const content  = await response.text();                                  this.value = new c1994(content);             }             catch (e)             {                                                   this.value =                      request.value.trim() == NULL                     ? new c1994()                     : new c1994('invalid request');             }         }         else         {             this.value = this.q4189.copy();         }           this.n4078(parse,         [             ['value',   this.value],             ['request', request   ]         ]);                           if (parse.settings.a3707)         {             this.n4078(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return this.request && this.request.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.request) this.request.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.request) this.request.v4066(parse, from, force);          this.q4189 = new c1994();     }        m4064(parse)     {         super.m4064(parse);          if (this.request) this.request.m4064(parse);     } }


class i1959 extends h2004 {               q4189 = null;        constructor(nodeId, options)     {         super(j1160, nodeId, options);     }            reset()     {         super.reset();          this.q4189 = null;     }        copy()     {         const copy = new i1959(this.nodeId, this.options);          copy.u3332(this);          copy.q4189 = this.q4189.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const q4189 = this.q4189 ? (await this.q4189.eval(parse)).f3605() : null;                            i2038(this.nodeId);           this.value = q4189 ?? new c1994();           this.n4078(parse,         [             ['', new i4194()]                      ]);                           if (parse.settings.a3707)         {             this.n4078(parse,             [                 ['preview', this.value]             ],             true);         }           this.validate();          return this;     }        isValid()     {         return false;     }        x4065(parse)     {         super.x4065(parse);          if (this.path) this.path.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.path) this.path.v4066(parse, from, force);               }        m4064(parse)     {         super.m4064(parse);          if (this.path) this.path.m4064(parse);     } }


class f1761 {     name;      max;     value;          constructor(name = '', max = 0, value = 0)     {         this.name  = name;         this.max   = max;         this.value = value;     } }    async function e1762(parse,                         nodeId,                         color,                         order, j3658, x3659, o3660,                         f3687, p3688, m3689, i3690)  {     const o3691 = q4171(u4177(color));           let a1771 = [...color],         e1772 = null,          p1773 = order ? order.value : -1,         j1774     = -1,         u1775     = -1,         q1776     = -1;       let progress = 0,         total    = 6 * Math.pow(2, Tau);               let d = 1;              parse.f3612 += 1024;       dLoop:     while (d > 1/1024)     {         if (parse.u3613)             break dLoop;          let _closestColor = [...a1771];           for (let e3657 = 0; e3657 < 6; e3657++)         {             if (parse.u3613)                 break dLoop;              a1771 = [..._closestColor];              const [min1, min2, min3] = n1768(color[0], e3657);             const [max1, max2, max3] = p1769(color[0], e3657);              let start1 = n1029(min1, j1774, 1-d),  c1777 = n1029(max1, j1774, 1-d),                 start2 = n1029(min2, u1775, 1-d),  k1778 = n1029(max2, u1775, 1-d),                 start3 = n1029(min3, q1776, 1-d),  t1779 = n1029(max3, q1776, 1-d);                                              if (p3688) { j1774 = j3658.o3677(); start1 = j1774; c1777 = j1774+Epsilon; }             if (m3689) { u1775 = x3659.o3677(); start2 = u1775; k1778 = u1775+Epsilon; }             if (i3690) { q1776 = o3660.o3677(); start3 = q1776; t1779 = q1776+Epsilon; }                         [ a1771,             e1772,             p1773,             j1774,             u1775,             q1776,             progress ] = await findCorrectionInOrder(                 parse,                 nodeId,                 o3691,                 e3657,                  f3687,                  p3688,  m3689,  i3690,                 j1774, u1775, q1776,                 start1,   start2,   start3,                  c1777,     k1778,     t1779,                 [...a1771],                 e1772,                  p1773,                 progress,                 total);         }           if (parse.u3613)             break;                   d /= 2;           parse.j3611++;     }       if (    !parse.u3613)     {                   const s3692 = l1763(color, p1773, j1774, u1775, q1776)[2];          let c1 = j1774;         let c2 = u1775;         let c3 = q1776;          while (c1 >= 0 && i108(l1763(color, p1773, c1-1, u1775, q1776)[2], s3692)) c1--;         while (c2 >= 0 && i108(l1763(color, p1773, j1774, c2-1, q1776)[2], s3692)) c2--;         while (c3 >= 0 && i108(l1763(color, p1773, j1774, u1775, c3-1)[2], s3692)) c3--;          j1774 = Math.max(0, c1);         u1775 = Math.max(0, c2);         q1776 = Math.max(0, c3);     }           return [         p1773,         j1774,         u1775,         q1776 ]; }    async function findCorrectionInOrder(parse,                                      nodeId,                                      o3691,                                      order,                                       f3687,                                       p3688,  m3689,  i3690,                                      j1774, u1775, q1776,                                      start1,   start2,   start3,                                       c1777,     k1778,     t1779,                                      a1771,                                      e1772,                                      p1773,                                      progress,                                      total) {     const color = [...a1771];          let m3693 = p3688 ? 1 : 2;     let s3694 = m3689 ? 1 : 2;     let s3695 = i3690 ? 1 : 2;       cLoop:     for (let m1 = start1; m1 < c1777; m1 += (c1777-start1)/m3693)     {         if (parse.u3613)             break cLoop;          for (let m2 = start2; m2 < k1778; m2 += (k1778-start2)/s3694)         {             if (parse.u3613)                 break cLoop;              for (let m3 = start3; m3 < t1779; m3 += (t1779-start3)/s3695)             {                 if (parse.u3613)                     break cLoop;                  const [m3170, _oklab, o124] = l1763(color, order, m1, m2, m3);                  if (   d78(o124)                     && (  !e1772                         || i102(o3691, _oklab) < i102(o3691, e1772)))                 {                     a1771 = m3170;                     e1772 = _oklab;                                          if (!f3687)                         p1773 = order;                      j1774     = m1;                     u1775     = m2;                     q1776     = m3;                 }                  progress++;             }         }                   if (parse.repeats.length == 1)         {                                                                                                     }           b2039(parse, nodeId, progress / total, false);     }           return [         a1771,         e1772,         p1773,         j1774,         u1775,         q1776,         progress ]; }    function l1763(color, order, m1, m2, m3) {     const m3170 = c1764(color, order, m1, m2, m3);     const oklab  = q4171(u4177(m3170));     const rgb    = o3959(oklab);      return [m3170, oklab, rgb]; }    function c1764(color, order, c1, c2, c3) {     if (order < 0)         return color;       const [i1, i2, i3] = r1767(order);                                 color = n1765(color, i1, c1);     if (!q150(color)) color = n1765(color, i2, c2);     if (!q150(color)) color = n1765(color, i3, c3);                 let rgb = c4172(color);      if (d78(rgb))         rgb = e80(rgb);                   color = n4173(         l146(rgb),         color[0]);               return color; }    function n1765(color, l3696, margin) {     const factor = a4169(color[0]);      margin /= factor[l3696];       const m3701 = [...color];     const n3035 = color[l3696+1];      const d = 0.001;       let h3699  = n3035,          m3700 = n3035;      let c3697  = q150(color);     let  u3698 = c3697;       let h3702 = 1/d;       while (   !c3697            && ! u3698            && h3702-- > 0)     {         h3699  -= d;  c3697  = n1766(h3699 , l3696, m3701);          m3700 += d;   u3698 = n1766( m3700, l3696, m3701);     }       h3702 = 1/d;     color = [...m3701];       if (c3697)      {          c3697 = q150(color);         h3699     = n3035;          while (   !c3697                && margin > 0                && h3702-- > 0)         {             h3699 -= d;              c3697 = n1766(h3699, l3696, m3701);             margin -= d;         }          color[l3696+1] = h3699;     }     else if (u3698)     {          u3698 = q150(color);         m3700     = n3035;          while (   !u3698                && margin > 0                && h3702-- > 0)         {             m3700 += d;              u3698 = n1766(m3700, l3696, m3701);             margin -= d;         }          color[l3696+1] = m3700;     }       return color; }    function n1766(c, l3696, m3701) {     let color = [...m3701];     color[l3696+1] = c;      return q150(color); }    function r1767(order) {     switch (order)     {         case 0: return [0, 1, 2];         case 1: return [1, 0, 2];         case 2: return [1, 2, 0];         case 3: return [0, 2, 1];         case 4: return [2, 0, 1];         case 5: return [2, 1, 0];     }           u947('invalid correction order ' + order);     return [0, 0, 0]; }    function n1768(space, order) {     const [c1, c2, c3] = r1767(order);      let min;      switch (space)     {         case 'hex':         case 'rgb':    min = [0, 0, 0]; break;          case 'hsv':          case 'hsl':    min = [0, 0, 0]; break;          case 'hclok':         case 'hclab':         case 'hcluv': min = [0, 0, 0]; break;          case 'oklab':         case 'lab':         case 'luv':    min = [0, -u4107[1]/2, -u4107[2]/2]; break;                  default:                          u947('invalid validation order ' + order);             return [0, 0, 0];     }      return [min[c1], min[c2], min[c3]]; }    function p1769(space, order) {     const [c1, c2, c3] = r1767(order);      let max;      switch (space)     {         case 'hex':         case 'rgb':    max = [...q4104]; break;          case 'hsv':          case 'hsl':    max = [g4105[0]/2, g4105[1], g4105[2]]; break;          case 'hclok':         case 'hclab':         case 'hcluv': max = [e4106[0]/2, e4106[1], e4106[2]]; break;          case 'oklab':         case 'lab':         case 'luv':    max = [...u4107]; break;                  default:                          u947('invalid validation order ' + order);             return [0, 0, 0];     }      return [max[c1], max[c2], max[c3]]; }    function reorderCorrection(p1773,                            j1774, u1775, q1776,                            p3688,  m3689,  i3690) {     let c1 = { closest: j1774, locked: p3688 };     let c2 = { closest: u1775, locked: m3689 };     let c3 = { closest: q1776, locked: i3690 };      if (   c1.closest <  Epsilon         && c2.closest <  Epsilon         && c3.closest >= Epsilon)     {         switch (p1773)         {             case 0: p1773 = 4; break;             case 1: p1773 = 5; break;             case 2: p1773 = 0; break;             case 3: p1773 = 1; break;             case 4: p1773 = 2; break;             case 5: p1773 = 3; break;         }          const tmp = c2;         c1 = c3;         c2 = c1;         c3 = tmp;     }     else if (c1.closest >= Epsilon           && c2.closest <  Epsilon)     {         switch (p1773)         {             case 0: p1773 = 3; break;             case 1: p1773 = 2; break;             case 2: p1773 = 1; break;             case 3: p1773 = 0; break;             case 4: p1773 = 5; break;             case 5: p1773 = 4; break;         }          const tmp = c2;         c2 = c3;         c3 = tmp;     }     else if (c1.closest < Epsilon)     {         switch (p1773)         {             case 0: p1773 = 2; break;             case 1: p1773 = 3; break;             case 2: p1773 = 4; break;             case 3: p1773 = 5; break;             case 4: p1773 = 0; break;             case 5: p1773 = 1; break;         }          const tmp = c1;         c1 = c2;         c2 = c3;         c3 = tmp;     }       return [         p1773,         c1.closest, c2.closest, c3.closest,         c1.locked,  c2.locked,  c3.locked ]; }    function k1770(a133) {     switch (a133)     {     case 'hex':     case 'rgb':         return [             new f1761('R', q4104[0]),             new f1761('G', q4104[1]),             new f1761('B', q4104[2]) ];      case 'hsv':         return [             new f1761('H', g4105[0]/2),             new f1761('S', g4105[1]),             new f1761('V', g4105[2]) ];      case 'hsl':         return [             new f1761('H', g4105[0]/2),             new f1761('S', g4105[1]),             new f1761('L', g4105[2]) ];      case 'hclok':     case 'hclab':     case 'hcluv':         return [             new f1761('H', e4106[0]/2),             new f1761('C', e4106[1]),             new f1761('L', e4106[2]) ];      case 'oklab':      case 'lab':         return [             new f1761('L', u4107[0]),             new f1761('a', u4107[1]),             new f1761('b', u4107[2]) ];      case 'luv':         return [             new f1761('L', u4107[0]),             new f1761('u', u4107[1]),             new f1761('v', u4107[2]) ];     }       u947('invalid color space ' + a133);     return [         new f1761(),         new f1761(),         new f1761() ]; }


class u1780 extends r2005 {     space   = null;         j3658      = null;    x3659      = null;    o3660      = null;          c1      = null;     c2      = null;     c3      = null;      convert = null;          o3236;        constructor(nodeId, options)     {         super(g1164, nodeId, options);     }                reset()     {         super.reset();                  this.space   = null;                  this.j3658     = null;         this.x3659     = null;         this.o3660     = null;                  this.c1      = null;         this.c2      = null;         this.c3      = null;              this.convert = null;     }        copy()     {         const copy = new u1780(this.nodeId, this.options);          copy.u3332(this);          copy.space = this.space.copy();          if (this.j3658) copy.j3658 = this.j3658.copy();         if (this.x3659) copy.x3659 = this.x3659.copy();         if (this.o3660) copy.o3660 = this.o3660.copy();          if (this. c1) copy. c1 = this. c1.copy();         if (this. c2) copy. c2 = this. c2.copy();         if (this. c3) copy. c3 = this. c3.copy();          if (this.convert)              copy.convert = this.convert.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const space = this.space ? (await this.space.eval(parse)).f3605().b3703() : null;          let   c1    = this.j3658   ? (await this.j3658  .eval(parse)).f3605()             : null;         let   c2    = this.x3659   ? (await this.x3659  .eval(parse)).f3605()             : null;         let   c3    = this.o3660   ? (await this.o3660  .eval(parse)).f3605()             : null;                   if (this.input)         {             const input = (await this.input.eval(parse)).f3605();                           if (   input.isValid())                              {                 if (this.options.enabled)                 {                     this.value = input.copy();                                           const fromSpaceIndex = input.space.value;                      const toSpaceIndex = Math.min(Math.max(                         0,                         Math.round(space.value)),                          y4103(parse)-1);                       if (toSpaceIndex != fromSpaceIndex)                     {                         this.convertColor(                             this.value,                             a133(fromSpaceIndex),                              a133(  toSpaceIndex));                          this.value.space.value = toSpaceIndex;                     }                                           if (!c1) c1 = this.value.c1;                     if (!c2) c2 = this.value.c2;                     if (!c3) c3 = this.value.c3;                       if (c1) { this.value.c1 = c1; this.c1 = c1; }                     if (c2) { this.value.c2 = c2; this.c2 = c2; }                     if (c3) { this.value.c3 = c3; this.c3 = c3; }                 }                 else                     this.value = input;             }             else                 this.value = c1971.NaN.copy();                               if (!this.convert)                 this.convert = p1983.NaN.copy();         }         else         {             this.value = new c1971(space, c1, c2, c3);               const toSpaceIndex = Math.min(Math.max(                 0,                 Math.round(this.value.space.value)),                  y4103(parse)-1);              this.value.space.value = toSpaceIndex;              if (    this.convert                 &&  this.convert.isValid()                 &&  this.convert.value > -1                 &&  this.value.isValid()                 && !this.o3236)             {                 await this.convert.eval(parse);                  this.convertColor(                     this.value,                     a133(this.convert.value),                      a133(toSpaceIndex));             }         }           if (!this.value.space.isValid())             this.value = new c1971(                 this.space.f3605(),                 p1983.NaN,                 p1983.NaN,                 p1983.NaN);           this.n4078(parse,         [             ['convert', this.convert    ],             ['space',   this.value.space],             ['c1',      this.value.c1   ],             ['c2',      this.value.c2   ],             ['c3',      this.value.c3   ]         ]);                                        this.validate();          return this;     }        convertColor(color, fromSpace, x3177)     {         let col = [             fromSpace,              c4153(color.c1.value, fromSpace, 0),             c4153(color.c2.value, fromSpace, 1),             c4153(color.c3.value, fromSpace, 2) ];          col = x4164(n4173(col, x3177));          color.c1.value = col[1];         color.c2.value = col[2];         color.c3.value = col[3];     }        f3605()     {         return this.options.enabled              ? this.value.copy()              : c1971.NaN.copy();     }        isValid()     {         return (!this.input || this.input.isValid())             && this.space && this.space.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.space) this.space.x4065(parse);         if (this.j3658  ) this.j3658  .x4065(parse);         if (this.x3659  ) this.x3659  .x4065(parse);         if (this.o3660  ) this.o3660  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.space) this.space.v4066(parse, from, force);         if (this.j3658  ) this.j3658  .v4066(parse, from, force);         if (this.x3659  ) this.x3659  .v4066(parse, from, force);         if (this.o3660  ) this.o3660  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.space) this.space.m4064(parse);         if (this.j3658  ) this.j3658  .m4064(parse);         if (this.x3659  ) this.x3659  .m4064(parse);         if (this.o3660  ) this.o3660  .m4064(parse);     } }


class i1787 extends r2005 {     quality      = null;      corrections  = [];        constructor(nodeId, options)     {         super(d1165, nodeId, options);     }            reset()     {         super.reset();          this.quality     = null;         this.corrections = [];     }        copy()     {         const copy = new i1787(this.nodeId, this.options);          copy.u3332(this);          if (this.value  ) copy.value   = this.value  .copy();         if (this.quality) copy.quality = this.quality.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const quality = this.quality ? (await this.quality.eval(parse)).f3605().b3703() : null;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await v2777(parse, this, input.items[i], quality));                 }                 else                     this.value = await v2777(parse, this, input, quality);             }             else                 this.value = input;         }         else             this.value = c1971.NaN.copy();                    this.n4078(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', quality          ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.quality && this.quality.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.quality) this.quality.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.quality) this.quality.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.quality) this.quality.m4064(parse);     } }    async function v2777(parse, node, input, quality) {     let rgb = input.y3213();      if (quality.value == 0)      {         rgb[0] = Math.round(Math.min(Math.max(0, rgb[0]), 1) * 0xff);            rgb[1] = Math.round(Math.min(Math.max(0, rgb[1]), 1) * 0xff);            rgb[2] = Math.round(Math.min(Math.max(0, rgb[2]), 1) * 0xff);                   return c1971.w3748(rgb);     }     else if (quality.value == 1)      {         rgb = q129(rgb);          rgb[0] = Math.round(rgb[0] * 0xff);         rgb[1] = Math.round(rgb[1] * 0xff);         rgb[2] = Math.round(rgb[2] * 0xff);          return c1971.w3748(rgb);     }     else      {         if (!d78(rgb))             i2038(node.nodeId);                   const inputColor = input.w3212();           const       [ p1773,         j1774,         u1775,         q1776 ] = await e1762(             parse,             node.nodeId,             inputColor,             quality, null,  null,  null,             false,   false, false, false);                       if (!parse.u3613)         {             if (   p1773 >= 0                 && p1773 <  6)             {                 node.m3170 = c1764(                     inputColor,                     p1773,                     j1774,                     u1775,                     q1776);                  return c1971.a2778(node.m3170);             }             else             {                 return c1971.NaN.copy();             }         }     }           return new i4194(); }


class r1786 extends r2005 {     e3657  = null;     j3658     = null;     x3659     = null;     o3660     = null;          order   = null;     c1      = null;     c2      = null;     c3      = null;      corrections = [];        constructor(nodeId, options)     {         super(o1166, nodeId, options);     }            reset()     {         super.reset();          this.e3657  = null;         this.j3658     = null;         this.x3659     = null;         this.o3660     = null;                  this.order   = null;         this.c1      = null;         this.c2      = null;         this.c3      = null;              this.corrections = [];     }        copy()     {         const copy = new r1786(this.nodeId, this.options);          copy.u3332(this);                  if (this.e3657) copy.e3657 = this.order .copy();         if (this.j3658   ) copy.j3658    = this.j3658   .copy();         if (this.x3659   ) copy.x3659    = this.x3659   .copy();         if (this.o3660   ) copy.o3660    = this.o3660   .copy();                  if (this. order) copy. order = this.order .copy();         if (this. c1   ) copy. c1    = this. c1   .copy();         if (this. c2   ) copy. c2    = this. c2   .copy();         if (this. c3   ) copy. c3    = this. c3   .copy();                  if (this.value ) copy. value = this. value.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const order = this.e3657 ? (await this.e3657.eval(parse)).f3605().b3703() : null;         const c1    = this.j3658    ? (await this.j3658   .eval(parse)).f3605()             : null;         const c2    = this.x3659    ? (await this.x3659   .eval(parse)).f3605()             : null;         const c3    = this.o3660    ? (await this.o3660   .eval(parse)).f3605()             : null;               if (order)             order.value = Math.min(Math.max(0, order.value), 5);           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();               if (this.options.enabled)             {                 const rgb = input.y3213();                                  if (!d78(rgb))                     i2038(this.nodeId);                   const inputColor = input.w3212();                   const               [ p1773,                 j1774,                 u1775,                 q1776 ] = await e1762(                     parse,                     this.nodeId,                     inputColor,                      order, c1, c2, c3,                      this.order != null,                     this.c1    != null,                      this.c2    != null,                      this.c3    != null);                                        if (    !parse.u3613)                 {                     if (   p1773 >= 0                          && p1773 <  6)                     {                         this.m3170 = c1764(                             inputColor,                             p1773,                             j1774,                             u1775,                             q1776);                                                       this.order = new p1983(p1773);                         this.c1    = new p1983(j1774);                         this.c2    = new p1983(u1775);                         this.c3    = new p1983(q1776);                                                   this.value = c1971.a2778(this.m3170);                          this.value.c1.decimals = input.c1.decimals;                         this.value.c2.decimals = input.c2.decimals;                         this.value.c3.decimals = input.c3.decimals;                           this.n4078(parse,                         [                             ['order', new p1983(p1773)],                             ['c1',    new p1983(j1774    )],                             ['c2',    new p1983(u1775    )],                             ['c3',    new p1983(q1776    )],                             ['value', this.value                   ]                         ]);                     }                 }                 else                 {                     this.order = p1983.NaN;                     this.c1    = p1983.NaN;                     this.c2    = p1983.NaN;                     this.c3    = p1983.NaN;                     this.value = input;                          this.n4078(parse,                     [                         ['order', this.order],                         ['c1',    this.c1   ],                         ['c2',    this.c2   ],                         ['c3',    this.c3   ],                         ['value', this.value]                     ]);                 }             }             else             {                 this.order = p1983.NaN;                 this.c1    = p1983.NaN;                 this.c2    = p1983.NaN;                 this.c3    = p1983.NaN;                 this.value = input;                  this.n4078(parse,                 [                     ['order', this.order],                     ['c1',    this.c1   ],                     ['c2',    this.c2   ],                     ['c3',    this.c3   ],                     ['value', this.value]                 ]);             }         }         else         {             this.order = p1983.NaN;             this.c1    = p1983.NaN;             this.c2    = p1983.NaN;             this.c3    = p1983.NaN;             this.value = c1971 .NaN;              this.n4078(parse,             [                 ['order', p1983.NaN],                 ['c1',    p1983.NaN],                 ['c2',    p1983.NaN],                 ['c3',    p1983.NaN],                 ['value', c1971 .NaN]             ]);         }           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.order && this.order.isValid()             && this.c1    && this.c1   .isValid()             && this.c2    && this.c2   .isValid()             && this.c3    && this.c3   .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.e3657) this.e3657.x4065(parse);         if (this.j3658   ) this.j3658   .x4065(parse);         if (this.x3659   ) this.x3659   .x4065(parse);         if (this.o3660   ) this.o3660   .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.e3657) this.e3657.v4066(parse, from, force);         if (this.j3658   ) this.j3658   .v4066(parse, from, force);         if (this.x3659   ) this.x3659   .v4066(parse, from, force);         if (this.o3660   ) this.o3660   .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.e3657) this.e3657.m4064(parse);         if (this.j3658   ) this.j3658   .m4064(parse);         if (this.x3659   ) this.x3659   .m4064(parse);         if (this.o3660   ) this.o3660   .m4064(parse);     } } 


class s1783 extends p2006 {     standard = null;     contrast = null;       constructor(nodeId, options)     {         super(w1168, nodeId, options);     }        reset()     {         super.reset();          this.standard = null;         this.contrast = null;     }        copy()     {         const copy = new s1783(this.nodeId, this.options);          copy.u3332(this);          copy.standard = this.standard.copy();         copy.contrast = this.contrast.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const standard = (await this.standard.eval(parse)).f3605().b3703();                   if (standard.isValid())             standard.value = Math.min(Math.max(0, standard.value), 1);           if (   this.p4060              && this.f4061)         {             const p4060 = (await this.p4060.eval(parse)).f3605();             const f4061 = (await this.f4061.eval(parse)).f3605();               if (   p4060.isValid()                 && f4061.isValid())             {                 if (   w149(p4060.w3212())                     && w149(f4061.w3212()))                 {                     if (standard.value == 0)                     {                         const value = i157(p4060.y3213(), f4061.y3213());                         this.contrast = new p1983(value, 2);                     }                     else                     {                         const value = r161(p4060.y3213(), f4061.y3213());                         this.contrast = new p1983(value, 1);                     }                 }                 else                     this.contrast = p1983.NaN.copy();             }             else                 this.contrast = p1983.NaN.copy();               this.value =                  p4060                  ? p4060                 : c1971.NaN.copy();               this.n4078(parse,             [                 ['text', p4060],                 ['back', f4061]             ]);         }          else if (this.p4060)          {             const p4060 = (await this.p4060.eval(parse)).f3605();              this.n4078(parse,             [                 ['text', p4060.isValid() ? p4060 : c1971.NaN],                 ['back', c1971.NaN                            ]             ]);                          this.value    = p4060;             this.contrast = p1983.NaN.copy();         }          else if (this.f4061)          {             const f4061 = (await this.f4061.eval(parse)).f3605();              this.n4078(parse,             [                 ['text', c1971.NaN                            ],                 ['back', f4061.isValid() ? f4061 : c1971.NaN]             ]);              this.value    = c1971.NaN.copy();             this.contrast = p1983.NaN.copy();         }          else         {             this.value    = c1971.NaN.copy();             this.contrast = p1983.NaN.copy();              this.n4078(parse,             [                 ['text', c1971.NaN],                 ['back', c1971.NaN]             ]);         }                    this.n4078(parse,         [             ['standard', standard     ],             ['contrast', this.contrast]         ],         true);           this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.standard && this.standard.isValid()             && (!this.contrast || this.contrast.isValid());     }        x4065(parse)     {         super.x4065(parse);          if (this.standard) this.standard.x4065(parse);         if (this.contrast) this.contrast.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.standard) this.standard.v4066(parse, from, force);         if (this.contrast) this.contrast.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.standard) this.standard.m4064(parse);         if (this.contrast) this.contrast.m4064(parse);     } } 


class u1785 extends r2005 {     from = null;        constructor(nodeId, options)     {         super(o1167, nodeId, options);     }            reset()     {         super.reset();          this.from = null;     }        copy()     {         const copy = new u1785(this.nodeId, this.options);          copy.u3332(this);          if (this.value) copy.value = this.value.copy();         if (this.from ) copy.from  = this.from .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const from = this.from ? (await this.from.eval(parse)).f3605().b3703() : null;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(await getConvertP3Value(input.items[i], from));                 }                 else                     this.value = await getConvertP3Value(input, from);             }             else                 this.value = input;         }         else             this.value = c1971.NaN.copy();                    this.n4078(parse,         [             ['value',   this.value       ],             ['type',    this.outputType()],             ['quality', from             ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.from && this.from.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.from) this.from.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.from) this.from.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.from) this.from.m4064(parse);     } }    function getConvertP3Value(input, from) {     return c1971.w3748(         from.value == 0         ? g4119(d61(input.y3213()))         : g4119(e62(input.y3213()))); }


class y1782 extends r2005 {     l;     m;     s;       constructor(nodeId, options)     {         super(b1169, nodeId, options);     }            reset()     {         super.reset();          this.l = null;         this.m = null;         this.s = null;     }        copy()     {         const copy = new y1782(this.nodeId, this.options);          copy.u3332(this);          copy.l = this.l.copy();         copy.m = this.m.copy();         copy.s = this.s.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const l = (await this.l.eval(parse)).f3605();                 const m = (await this.m.eval(parse)).f3605();         const s = (await this.s.eval(parse)).f3605();           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();               if (this.options.enabled)             {                 if (w951(input.type))                 {                     this.value = new p1982();                      for (let i = 0; i < input.items.length; i++)                         this.value.items.push(getColorBlindValue(input.items[i], l, m, s));                 }                 else                     this.value = getColorBlindValue(input, l, m, s);             }             else                 this.value = input;         }         else             this.value = c1971.NaN.copy();           this.n4078(parse,         [             ['value',  this.value       ],             ['type',   this.outputType()],             ['l',      l                ],             ['m',      m                ],             ['s',      s                ]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.l && this.l.isValid()             && this.m && this.m.isValid()             && this.s && this.s.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.l) this.l.x4065(parse);         if (this.m) this.m.x4065(parse);         if (this.s) this.s.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.l) this.l.v4066(parse, from, force);         if (this.m) this.m.v4066(parse, from, force);         if (this.s) this.s.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.l) this.l.m4064(parse);         if (this.m) this.m.m4064(parse);         if (this.s) this.s.m4064(parse);     } }    function getColorBlindValue(input, l, m, s) {     const rgb   = input.y3213();      const rgbCb = v134(         rgb,         l.value / 2,         m.value / 2,         s.value / 2);      if (   !p73(rgb  )         && !p73(rgbCb))     {         const validRgbCb = rgbCb;              const validCol = n4173(             l146(validRgbCb),              a133(input.space.value));          return c1971.a2778(validCol);     }     else         return c1971.NaN.copy(); }


class l1784 extends p2006 {     space;     amount;     gamma;       constructor(nodeId, options)     {         super(k1170, nodeId, options);     }            reset()     {         super.reset();          this.space  = null;         this.amount = null;         this.gamma  = null;     }        copy()     {         const copy = new l1784(this.nodeId, this.options);          copy.u3332(this);          copy.space  = this.space .copy();         copy.amount = this.amount.copy();         copy.gamma  = this.gamma .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const space  = (await this.space .eval(parse)).f3605().b3703();         const amount = (await this.amount.eval(parse)).f3605();         const gamma  = (await this.gamma .eval(parse)).f3605();           if (   this.p4060              && this.f4061)         {             const p4060 = (await this.p4060.eval(parse)).f3605();             const f4061 = (await this.f4061.eval(parse)).f3605();              s946(                 amount.type == g1086,                  'this.result.type must be NUMBER_VALUE');              const f = amount.value / 100;               const spaceIndex = Math.min(Math.max(0, space.value), y4103()-1);             const gammaValue = Math.max(0.0001, gamma.value);              const _space = a133(spaceIndex);              const m3170 = this.interpolate(                 spaceIndex,                 n4173(p4060.w3212(), _space),                 n4173(f4061.w3212(), _space),                 f,                 gammaValue);                                          this.value = c1971.a2778(m3170, spaceIndex);         }          else if (this.p4060)              this.value = (await this.p4060.eval(parse)).f3605();          else if (this.f4061)              this.value = (await this.f4061.eval(parse)).f3605();                      else              this.value = c1971.NaN.copy();           this.n4078(parse,         [             ['space',  space     ],             ['amount', amount    ],             ['gamma',  gamma     ],             ['value',  this.value]         ]);                   this.validate();                  return this;     }        interpolate(space, col0, i103, f, gamma)     {         if (   space <= 1             || space >  6)          {             gamma = Math.max(0.01, gamma);              const r0 = Math.sign(col0[1]) * Math.pow(Math.abs(col0[1]), gamma);               const g0 = Math.sign(col0[2]) * Math.pow(Math.abs(col0[2]), gamma);               const b0 = Math.sign(col0[3]) * Math.pow(Math.abs(col0[3]), gamma);                const r1 = Math.sign(i103[1]) * Math.pow(Math.abs(i103[1]), gamma);             const g1 = Math.sign(i103[2]) * Math.pow(Math.abs(i103[2]), gamma);             const b1 = Math.sign(i103[3]) * Math.pow(Math.abs(i103[3]), gamma);              const r = n1029(r0, r1, f);                     const g = n1029(g0, g1, f);                         const b = n1029(b0, b1, f);                      return [                 a133(space),                 Math.sign(r) * Math.pow(Math.abs(r), 1/gamma),                 Math.sign(g) * Math.pow(Math.abs(g), 1/gamma),                 Math.sign(b) * Math.pow(Math.abs(b), 1/gamma) ];         }         else          {             const h0 = col0[1] * Tau;  const h1 = i103[1] * Tau;             const c0 = col0[2];        const c1 = i103[2];             const l0 = col0[3];        const l1 = i103[3];              return [                 a133(space),                 g1032(h0 + t877(h0, h1) * f) / Tau,                 n1029(c0, c1, f),                 n1029(l0, l1, f) ];         }     }        isValid()     {         return super.isValid()             && this.space  && this.space .isValid()             && this.amount && this.amount.isValid()             && this.gamma  && this.gamma .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.space ) this.space .x4065(parse);         if (this.amount) this.amount.x4065(parse);         if (this.gamma ) this.gamma .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.space ) this.space .v4066(parse, from, force);         if (this.amount) this.amount.v4066(parse, from, force);         if (this.gamma ) this.gamma .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.space ) this.space .m4064(parse);         if (this.amount) this.amount.m4064(parse);         if (this.gamma ) this.gamma .m4064(parse);     } } 


class h1781 extends p2006 {     mode    = null;     opacity = null;           constructor(nodeId, options)     {         super(w1171, nodeId, options);     }            reset()     {         super.reset();          this.mode    = null;         this.opacity = null;     }        copy()     {         const copy = new h1781(this.nodeId, this.options);          copy.u3332(this);          copy.mode    = this.mode   .copy();         copy.opacity = this.opacity.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const mode    = (await this.mode   .eval(parse)).f3605().b3703();         const opacity = (await this.opacity.eval(parse)).f3605();           if (   this.p4060              && this.f4061)         {             const p4060 = (await this.p4060.eval(parse)).f3605();             const f4061 = (await this.f4061.eval(parse)).f3605();              s946(                 opacity.type == g1086,                  'this.result.type must be NUMBER_VALUE');              const q3747 = opacity.value / 100;              const l3746 = Math.min(Math.max(0, mode.value), b1365.length-1);               const col = this.blend(                 l3746,                 p4060.y3213(),                 f4061.y3213(),                 q3747);              this.value = c1971.w3748(g4119(col));         }          else if (this.p4060)              this.value = (await this.p4060.eval(parse)).f3605();          else if (this.f4061)              this.value = (await this.f4061.eval(parse)).f3605();                      else              this.value = c1971.NaN.copy();           this.n4078(parse,         [             ['value',   this.value],             ['mode',    mode      ],             ['opacity', opacity   ]         ]);           this.validate();                  return this;     }        blend(mode, col0, i103, opacity)     {         switch (mode)         {             case  0: return k4225    (col0, i103, opacity);              case  1: return d4226    (col0, i103, opacity);             case  2: return t4227  (col0, i103, opacity);             case  3: return e4228 (col0, i103, opacity);              case  4: return a4229   (col0, i103, opacity);             case  5: return v4230    (col0, i103, opacity);             case  6: return z4232(col0, i103, opacity);              case  7: return w4234   (col0, i103, opacity);             case  8: return k4235 (col0, i103, opacity);             case  9: return y4237 (col0, i103, opacity);              case 10: return o4239(col0, i103, opacity);             case 11: return k4240 (col0, i103, opacity);              case 12: return o4242       (col0, i103, opacity);             case 13: return g4243(col0, i103, opacity);             case 14: return o4244     (col0, i103, opacity);             case 15: return r4245(col0, i103, opacity);         }     }        isValid()     {         return super.isValid()             && this.mode    && this.mode   .isValid()             && this.opacity && this.opacity.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.mode   ) this.mode   .x4065(parse);         if (this.opacity) this.opacity.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.mode   ) this.mode   .v4066(parse, from, force);         if (this.opacity) this.opacity.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.mode   ) this.mode   .m4064(parse);         if (this.opacity) this.opacity.m4064(parse);     } } 


function k4225(col, back, opacity) {     return [ col[0] * opacity + back[0] * (1 - opacity),              col[1] * opacity + back[1] * (1 - opacity),              col[2] * opacity + back[2] * (1 - opacity) ]; }    function d4226(col, back, opacity) {     return k4225(         [ Math.min(back[0], col[0]),           Math.min(back[1], col[1]),           Math.min(back[2], col[2]) ],         back,         opacity); }    function chanMultiply(c, b) {     return c * b; }    function t4227(col, back, opacity) {     return k4225(         [ chanMultiply(col[0], back[0]),           chanMultiply(col[1], back[1]),           chanMultiply(col[2], back[2]) ],         back,         opacity); }    function chanColorBurn(c, b) {          if (b == 1) return 1;     else if (c == 0) return 0;     else             return 1 - Math.min((1 - b) / c, 1); }    function e4228(col, back, opacity) {     return k4225(          [ chanColorBurn(col[0], back[0]),            chanColorBurn(col[1], back[1]),            chanColorBurn(col[2], back[2]) ],         back,         opacity); }    function a4229(col, back, opacity) {     return k4225(         [ Math.max(back[0], col[0]),           Math.max(back[1], col[1]),           Math.max(back[2], col[2]) ],         back,         opacity); }    function d4231(c, b) {     return b + c - b*c; }    function v4230(col, back, opacity) {     return k4225(         [ d4231(col[0], back[0]),           d4231(col[1], back[1]),           d4231(col[2], back[2]) ],         back,         opacity); }    function v4233(c, b) {          if (b == 0) return 0;     else if (c == 1) return 1;     else             return Math.min(b / (1 - c), 1); }    function z4232(col, back, opacity) {     return k4225(         [ v4233(col[0], back[0]),           v4233(col[1], back[1]),           v4233(col[2], back[2]) ],         back,         opacity); }    function w4234(col, back, opacity) {     return k4225(         [ u4238(back[0], col[0]),           u4238(back[1], col[1]),           u4238(back[2], col[2]) ],         back,         opacity); }    function d2779(b) {     return b <= 0.25          ? ((16 * b - 12) * b + 4) * b          : Math.sqrt(b); }    function z4236(c, b) {     return c <= 0.5          ? b - (1 - 2*c) * b * (1 - b)          : b + (2*c - 1) * (d2779(b) - b); }    function k4235(col, back, opacity) {     return k4225(         [ z4236(col[0], back[0]),           z4236(col[1], back[1]),           z4236(col[2], back[2]) ],         back,         opacity); }    function u4238(c, b) {     if (c <= 0.5) return chanMultiply(b, 2 * c);     else          return d4231(b, 2 * c - 1); }    function y4237(col, back, opacity) {     return k4225(         [ u4238(col[0], back[0]),           u4238(col[1], back[1]),           u4238(col[2], back[2]) ],         back,         opacity); }    function o4239(col, back, opacity) {     return [ Math.abs(back[0] - col[0]),              Math.abs(back[1] - col[1]),              Math.abs(back[2] - col[2]) ]; }    function q4241(c, b) {     return b + c - 2*b*c; }    function k4240(col, back, opacity) {     return k4225(         [ q4241(col[0], back[0]),           q4241(col[1], back[1]),           q4241(col[2], back[2]) ],         back,         opacity); }    function o2780(col) {     return col[0] * 0.30          + col[1] * 0.59          + col[2] * 0.11; }    function x2781(v127, l) {     const col = [...v127];      const d = l - o2780(col);      col[0] += d;     col[1] += d;     col[2] += d;      return s2789(col); }    function j2782(col) {     return Math.max(col[0], col[1], col[2])           - Math.min(col[0], col[1], col[2]); }    function p2783(col) {          if (col[0] <= col[1]            && col[0] <= col[2]) return 0;     else if (col[1] <= col[1]            && col[1] <= col[2]) return 1;     else                       return 2; }    function q2784(col) {          if (   col[0] >= col[1]               && col[0] <= col[2]           ||    col[0] <= col[1]               && col[0] >= col[2]) return 0;     else if (   col[1] >= col[0]               && col[1] <= col[2]           ||    col[1] <= col[0]               && col[1] >= col[2]) return 1;     else                          return 2; }    function z2785(col) {          if (col[0] >= col[1]            && col[0] >= col[2]) return 0;     else if (col[1] >= col[1]            && col[1] >= col[2]) return 1;     else                       return 2; }    function g2786(col)  {     if (   col[0] == col[1]          && col[0] == col[2])         return [0, 1, 2];      else          return [             p2783(col),              q2784(col),              z2785(col)]; }    function l2787(v127, s) {     const col       = [...v127];     const [n, d, x] = g2786(col);      if (col[x] > col[n])     {         col[d] = (((col[d] - col[n]) * s) / (col[x] - col[n]));         col[x] = s;     }     else         col[d] = col[x] = 0;      col[n] = 0;      return col; }    function k2788(c, l, n, x) {          if (n < 0) return l + (((c - l) * l) / (l - n));     else if (x > 1) return l + (((c - l) * (1 - l)) / (x - l));     else            return c; }    function s2789(col) {     const l   = o2780(col);      const n = Math.min(col[0], col[1], col[2]);     const x = Math.max(col[0], col[1], col[2]);      return [ k2788(col[0], l, n, x),              k2788(col[1], l, n, x),              k2788(col[2], l, n, x) ]; }    function o4242(col, back, opacity) {     return k4225(         x2781(l2787(col, j2782(back)), o2780(back)),         back,         opacity); }    function g4243(col, back, opacity) {     return k4225(         x2781(l2787(back, j2782(col)), o2780(back)),         back,         opacity); }    function o4244(col, back, opacity) {     return k4225(         x2781(col, o2780(back)),         back,         opacity); }    function r4245(col, back, opacity) {     return k4225(         x2781(back, o2780(col)),         back,         opacity); }


class e1849 extends h2004 {     id;      colorStyle;     w2790;           linked;        constructor(nodeId, options, styleId)     {         super(v1208, nodeId, options);          this.id == styleId;     }        copy()     {         const copy = new e1849(this.nodeId, this.options);          copy.id         = this.id;         copy.colorStyle = this.colorStyle.copy();         copy.w2790   = this.w2790  .copy();                           copy.linked     = this.linked;          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   this.value = (await this.w2790.eval(parse)).f3605();           if (   this.value.isValid()             && this.linked)                                   {             if (this.value.type == u1163)                 this.value = g1974.w3748(g4119(this.value.y3213()), 0xff);              const rgba       = this.value.c99();             const b3232 = u100(r120(rgba), rgba[3]);              this.evalStyle({rgba: b3232});         }         else             this.value = g1974.NaN;           this.n4078(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        evalStyle(options = {})     {         if (!this.options.enabled)             return;                       const colorStyle = new s1804(this.nodeId, this.id, this.name);                     colorStyle.paints =          [             [ 'SOLID',                        Math.round(options.rgba[0] * 0xff)               + ' ' + Math.round(options.rgba[1] * 0xff)               + ' ' + Math.round(options.rgba[2] * 0xff)               + ' ' + Math.round(options.rgba[3] * 100 ) ]         ];           this.colorStyle = colorStyle;     }        isValid()     {         return this.w2790 && this.w2790.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.w2790) this.w2790.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.w2790) this.w2790.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.w2790) this.w2790.m4064(parse);     } }


class k1851 extends r2005 {     color   = null;     opacity = null;     blend   = null;        constructor(nodeId, options)     {         super(o1174, nodeId, options);     }        reset()     {         super.reset();          this.color   = null;         this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new k1851(this.nodeId, this.options);          copy.u3332(this);          if (this.color  ) copy.color   = this.color  .copy();         if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let color   = this.color   ? (await this.color  .eval(parse)).f3605() : null;         let opacity = this.opacity ? (await this.opacity.eval(parse)).f3605() : null;         let blend   = this.blend   ? (await this.blend  .eval(parse)).f3605() : null;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new g1974(                 color   ?? input.color,                 opacity ?? input.opacity,                 blend   ?? input.blend);         }         else         {             this.value = new g1974(                 color,                  opacity,                 blend);         }           this.n4078(parse,         [             ['value',   this.value],             ['color',   color     ],             ['opacity', opacity   ],             ['blend',   blend     ]         ]);                   if (!this.color  ) this.color   = this.value.color  .copy();         if (!this.opacity) this.opacity = this.value.opacity.copy();         if (!this.blend  ) this.blend   = this.value.blend  .copy();           this.validate();          return this;     }        f3605()     {         return this.options.enabled             ? new g1974(                 this.color   ? this.color  .f3605() : this.input.value.color  .f3605(),                 this.opacity ? this.opacity.f3605() : this.input.value.opacity.f3605(),                 this.blend   ? this.blend  .f3605() : this.input.value.blend  .f3605())             : g1974.NaN;     }        isValid()     {         return (!this.input || this.input.isValid())             && this.color   && this.color  .isValid()             && this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.color  ) this.color  .x4065(parse);         if (this.opacity) this.opacity.x4065(parse);         if (this.blend  ) this.blend  .x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.color  ) this.color  .v4066(parse, from, force);         if (this.opacity) this.opacity.v4066(parse, from, force);         if (this.blend  ) this.blend  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.color  ) this.color  .m4064(parse);         if (this.opacity) this.opacity.m4064(parse);         if (this.blend  ) this.blend  .m4064(parse);     } }


class n1848 extends r2005 {     fill     = null;     position = null;        constructor(nodeId, options)     {         super(t1180, nodeId, options);     }        reset()     {         super.reset();          this.fill     = null;         this.position = null;     }        copy()     {         const copy = new n1848(this.nodeId, this.options);          copy.u3332(this);          if (this.fill    ) copy.fill     = this.fill    .copy();         if (this.position) copy.position = this.position.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          let fill = this.fill ? (await this.fill.eval(parse)).f3605() : null;          fill = this.validateFill(fill);           const position = this.position ? (await this.position.eval(parse)).f3605() : null;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new g1970(                 fill     ?? input.fill,                 position ?? input.position);         }         else         {             this.value = new g1970(                 fill,                  position);         }           this.n4078(parse,          [             ['value', this.value]         ]);                   if (!this.fill    ) this.fill     = this.value.fill    .copy();         if (!this.position) this.position = this.value.position.copy();           this.validate();          return this;     }        validateFill(fill)     {         if (!fill)             return null;           if (fill.type == u1163)             return g1974.w3748(g4119(fill.y3213()), 100);         else             return fill;     }        f3605()     {         return new g1970(             this.options.enabled             ? this.validateFill(this.fill ? this.fill.f3605() : this.input.fill.f3605())             : g1974.NaN,             this.position ? this.position.f3605() : this.input.position.f3605());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fill     && this.fill    .isValid()             && this.position && this.position.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.fill    ) this.fill    .x4065(parse);         if (this.position) this.position.x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.fill    ) this.fill    .v4066(parse, from, force);         if (this.position) this.position.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.fill    ) this.fill    .m4064(parse);         if (this.position) this.position.m4064(parse);     } }


class t1852 extends h2004 {     inputs = [];      s3661 = null;     x        = null;     y        = null;     size     = null;     angle    = null;     aspect   = null;     skew     = null;     blend    = null;                    constructor(nodeId, options)     {         super(m1183, nodeId, options);     }                    reset()     {         super.reset();                  this.inputs = [];              this.s3661 = null;         this.x        = null;         this.y        = null;         this.size     = null;         this.angle    = null;         this.aspect   = null;         this.skew     = null;         this.blend    = null;     }        copy()     {         const copy = new t1852(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.s3661) copy.s3661 = this.x     .copy();         if (this.x       ) copy.x        = this.x     .copy();         if (this.y       ) copy.y        = this.y     .copy();         if (this.size    ) copy.size     = this.size  .copy();         if (this.angle   ) copy.angle    = this.angle .copy();         if (this.aspect  ) copy.aspect   = this.aspect.copy();         if (this.skew    ) copy.skew     = this.skew  .copy();         if (this.blend   ) copy.blend    = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          const s3661 = this.s3661 ? (await this.s3661.eval(parse)).f3605() : null;         const x        = this.x        ? (await this.x       .eval(parse)).f3605() : null;         const y        = this.y        ? (await this.y       .eval(parse)).f3605() : null;         const size     = this.size     ? (await this.size    .eval(parse)).f3605() : null;         const angle    = this.angle    ? (await this.angle   .eval(parse)).f3605() : null;         const aspect   = this.aspect   ? (await this.aspect  .eval(parse)).f3605() : null;         const skew     = this.skew     ? (await this.skew    .eval(parse)).f3605() : null;         const blend    = this.blend    ? (await this.blend   .eval(parse)).f3605() : null;           const stops = new p1982();          for (let i = 0, o = 0; i < this.inputs.length; i++)         {             const input = (await this.inputs[i].eval(parse)).f3605();               if (   input                 && this.options.enabled)             {                 if (w951(input.type))                 {                     for (const item of input.items)                         stops.items.push(item);                 }                 else                     stops.items.push(input);             }         }           this.value = new k1976(             stops,             s3661,             x,              y,              size,              angle,              aspect,             skew,             blend);                       this.n4078(parse,         [             ['value', this.value]         ]);                   if (!this.s3661) this.s3661 = this.value.s3661.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.size    ) this.size     = this.value.size    .copy();         if (!this.angle   ) this.angle    = this.value.angle   .copy();         if (!this.aspect  ) this.aspect   = this.value.aspect  .copy();         if (!this.skew    ) this.skew     = this.value.skew    .copy();         if (!this.blend   ) this.blend    = this.value.blend   .copy();           this.validate();          return this;     }                f3605()     {         const stops = new p1982();          for (let i = 0, o = 0; i < this.inputs.length; i++)             stops.items.push(this.inputs[i].f3605());           return new k1976(             stops,             this.s3661 ? this.s3661.f3605() : this.input.s3661.f3605(),             this.x        ? this.x       .f3605() : this.input.x       .f3605(),             this.y        ? this.y       .f3605() : this.input.y       .f3605(),             this.size     ? this.size    .f3605() : this.input.size    .f3605(),             this.angle    ? this.angle   .f3605() : this.input.angle   .f3605(),             this.aspect   ? this.aspect  .f3605() : this.input.aspect  .f3605(),             this.skew     ? this.skew    .f3605() : this.input.skew    .f3605(),             this.blend    ? this.blend   .f3605() : this.input.blend   .f3605());     }                         isValid()     {         return !this.inputs.find(i => !i.isValid())             && this.s3661 && this.s3661.isValid()             && this.x        && this.x       .isValid()             && this.y        && this.y       .isValid()             && this.size     && this.size    .isValid()             && this.angle    && this.angle   .isValid()             && this.aspect   && this.aspect  .isValid()             && this.skew     && this.skew    .isValid()             && this.blend    && this.blend   .isValid();     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));          if (this.s3661) this.s3661.x4065(parse);         if (this.x       ) this.x       .x4065(parse);         if (this.y       ) this.y       .x4065(parse);         if (this.size    ) this.size    .x4065(parse);         if (this.angle   ) this.angle   .x4065(parse);         if (this.aspect  ) this.aspect  .x4065(parse);         if (this.skew    ) this.skew    .x4065(parse);         if (this.blend   ) this.blend   .x4065(parse);     }            v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));                  if (this.s3661) this.s3661.v4066(parse, from, force);         if (this.x       ) this.x       .v4066(parse, from, force);         if (this.y       ) this.y       .v4066(parse, from, force);         if (this.size    ) this.size    .v4066(parse, from, force);         if (this.angle   ) this.angle   .v4066(parse, from, force);         if (this.aspect  ) this.aspect  .v4066(parse, from, force);         if (this.skew    ) this.skew    .v4066(parse, from, force);         if (this.blend   ) this.blend   .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));          if (this.s3661) this.s3661.m4064(parse);         if (this.x       ) this.x       .m4064(parse);         if (this.y       ) this.y       .m4064(parse);         if (this.size    ) this.size    .m4064(parse);         if (this.angle   ) this.angle   .m4064(parse);         if (this.aspect  ) this.aspect  .m4064(parse);         if (this.skew    ) this.skew    .m4064(parse);         if (this.blend   ) this.blend   .m4064(parse);     }     }


class c1858 extends r2005 {     fills  = null;    b3649  = null;      weight = null;     fit    = null;     join   = null;     miter  = null;     cap    = null;     dashes = null;                constructor(nodeId, options)     {         super(j1177, nodeId, options);     }                reset()     {         super.reset();                  this. fills  = null;         this.b3649  = null;          this. weight = null;         this. fit    = null;         this. join   = null;         this. miter  = null;         this. cap    = null;         this. dashes = null;     }        copy()     {         const copy = new c1858(this.nodeId, this.options);          copy.u3332(this);          if (this.fills ) copy.fills  = this.fills .copy();         if (this.b3649) copy.b3649 = this.b3649.copy();         if (this.weight) copy.weight = this.weight.copy();         if (this.fit   ) copy.fit    = this.fit   .copy();         if (this.join  ) copy.join   = this.join  .copy();         if (this.miter ) copy.miter  = this.miter .copy();         if (this.cap   ) copy.cap    = this.cap   .copy();         if (this.dashes) copy.dashes = this.dashes.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          let fills = this.b3649 ? (await this.b3649.eval(parse)).f3605() : null;          fills = this.validateFills(fills);          if (!w951(this.b3649.type))             this.fills = fills;           const weight = this.weight ? (await this.weight.eval(parse)).f3605() : null;         const fit    = this.fit    ? (await this.fit   .eval(parse)).f3605() : null;         const join   = this.join   ? (await this.join  .eval(parse)).f3605() : null;         const miter  = this.miter  ? (await this.miter .eval(parse)).f3605() : null;         const cap    = this.cap    ? (await this.cap   .eval(parse)).f3605() : null;         const dashes = this.dashes ? (await this.dashes.eval(parse)).f3605() : null;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new c1992(                 fills  ?? input.fills,                 weight ?? input.weight,                 fit    ?? input.fit,                 join   ?? input.join,                 miter  ?? input.miter,                 cap    ?? input.cap,                 dashes ?? input.dashes);         }         else         {             this.value = new c1992(                 fills,                  weight,                  fit,                  join,                 miter,                 cap,                 dashes);         }           if (!this.fills ) this.fills  = this.value.fills .copy();         if (!this.weight) this.weight = this.value.weight.copy();         if (!this.fit   ) this.fit    = this.value.fit   .copy();         if (!this.join  ) this.join   = this.value.join  .copy();         if (!this.miter ) this.miter  = this.value.miter .copy();         if (!this.cap   ) this.cap    = this.value.cap   .copy();         if (!this.dashes) this.dashes = this.value.dashes.copy();                               this.n4078(parse,         [             ['value',  this.value],             ['fills',  fills     ],             ['weight', weight    ],             ['fit',    fit       ],             ['join',   join      ],             ['miter',  miter     ],             ['cap',    cap       ],             ['dashes', dashes    ]         ]);           this.validate();          return this;     }        validateFills(fills)     {                     if (!fills)             return null;          if (fills.type == u1163)             return new p1982([g1974.w3748(g4119(fills.y3213()), 100)]);          else if (fills.type ==     k1173               || fills.type == f1182)             return new p1982([fills]);         else         {             s946(fills.type == c1051, 'stroke.fills must be a LIST_VALUE');             return fills;         }     }        f3605()     {         return new c1992(             this.options.enabled             ? this.validateFills(this.fills ? this.fills.f3605() : this.input.fills.f3605())             : new p1982(),             this.weight ? this.weight.f3605() : this.input.weight.f3605(),             this.fit    ? this.fit   .f3605() : this.input.fit   .f3605(),             this.join   ? this.join  .f3605() : this.input.join  .f3605(),             this.miter  ? this.miter .f3605() : this.input.miter .f3605(),             this.cap    ? this.cap   .f3605() : this.input.cap   .f3605(),             this.dashes ? this.dashes.f3605() : this.input.dashes.f3605());     }                         isValid()     {         return (!this.input || this.input.isValid())             && this.fills  && this.fills .isValid()             && this.weight && this.weight.isValid()             && this.fit    && this.fit   .isValid()             && this.join   && this.join  .isValid()             && this.miter  && this.miter .isValid()             && this.cap    && this.cap   .isValid()             && this.dashes && this.dashes.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.b3649) this.b3649.x4065(parse);         if (this.weight) this.weight.x4065(parse);         if (this.fit   ) this.fit   .x4065(parse);         if (this.join  ) this.join  .x4065(parse);         if (this.miter ) this.miter .x4065(parse);         if (this.cap   ) this.cap   .x4065(parse);         if (this.dashes) this.dashes.x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.b3649) this.b3649.v4066(parse, from, force);         if (this.weight) this.weight.v4066(parse, from, force);         if (this.fit   ) this.fit   .v4066(parse, from, force);         if (this.join  ) this.join  .v4066(parse, from, force);         if (this.miter ) this.miter .v4066(parse, from, force);         if (this.cap   ) this.cap   .v4066(parse, from, force);         if (this.dashes) this.dashes.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.b3649) this.b3649.m4064(parse);         if (this.weight) this.weight.m4064(parse);         if (this.fit   ) this.fit   .m4064(parse);         if (this.join  ) this.join  .m4064(parse);         if (this.miter ) this.miter .m4064(parse);         if (this.cap   ) this.cap   .m4064(parse);         if (this.dashes) this.dashes.m4064(parse);     }     }


class g1857 extends r2005 {     tl = null;     tr = null;     bl = null;     br = null;                constructor(nodeId, options)     {         super(w1186, nodeId, options);     }                reset()     {         super.reset();                  this.tl = null;         this.tr = null;         this.bl = null;         this.br = null;     }        copy()     {         const copy = new g1857(this.nodeId, this.options);          copy.u3332(this);          if (this.tl) copy.tl = this.tl.copy();         if (this.tr) copy.tr = this.tr.copy();         if (this.bl) copy.bl = this.bl.copy();         if (this.br) copy.br = this.br.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const tl = this.tl ? (await this.tl.eval(parse)).f3605() : null;         const tr = this.tr ? (await this.tr.eval(parse)).f3605() : null;         const bl = this.bl ? (await this.bl.eval(parse)).f3605() : null;         const br = this.br ? (await this.br.eval(parse)).f3605() : null;           if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new w1987(                 tl ?? input.tl,                 tr ?? input.tr,                 bl ?? input.bl,                 br ?? input.br,                 this.options.enabled);         }         else         {             this.value = new w1987(                 tl,                  tr,                  bl,                  br,                 this.options.enabled);         }           this.n4078(parse,         [             ['tl', this.value.tl],             ['tr', this.value.tr],             ['bl', this.value.bl],             ['br', this.value.br]         ]);                   if (!this.tl) this.tl = this.value.tl.copy();         if (!this.tr) this.tr = this.value.tr.copy();         if (!this.bl) this.bl = this.value.bl.copy();         if (!this.br) this.br = this.value.br.copy();           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.tl && this.tl.isValid()             && this.tr && this.tr.isValid()             && this.bl && this.bl.isValid()             && this.br && this.br.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.tl) this.tl.x4065(parse);         if (this.tr) this.tr.x4065(parse);         if (this.bl) this.bl.x4065(parse);         if (this.br) this.br.x4065(parse);     }                   v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.tl) this.tl.v4066(parse, from, force);         if (this.tr) this.tr.v4066(parse, from, force);         if (this.bl) this.bl.v4066(parse, from, force);         if (this.br) this.br.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.tl) this.tl.m4064(parse);         if (this.tr) this.tr.m4064(parse);         if (this.bl) this.bl.m4064(parse);         if (this.br) this.br.m4064(parse);     } }


class e1850 extends r2005 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;     behind = null;                constructor(nodeId, options)     {         super(e1189, nodeId, options);     }                reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;         this.behind = null;     }        copy()     {         const copy = new e1850(this.nodeId, this.options);          copy.u3332(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();         if (this.behind) copy.behind = this.behind.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x      = this.x      ? (await this.x     .eval(parse)).f3605() : null;         const y      = this.y      ? (await this.y     .eval(parse)).f3605() : null;         const blur   = this.blur   ? (await this.blur  .eval(parse)).f3605() : null;         const spread = this.spread ? (await this.spread.eval(parse)).f3605() : null;         let   fill   = this.fill   ? (await this.fill  .eval(parse)).f3605() : null;         const blend  = this.blend  ? (await this.blend .eval(parse)).f3605() : null;         const behind = this.behind ? (await this.behind.eval(parse)).f3605() : null;           if (   fill             && fill.type == u1163)             fill = new g1974(fill);                   if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new t1972(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 behind ?? input.behind,                 this.options.enabled);         }         else         {             this.value = new t1972(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                  behind,                 this.options.enabled);         }           this.n4078(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],             ['behind', this.value.behind]         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();         if (!this.behind) this.behind = this.value.behind.copy();           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid()             && this.behind && this.behind.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.x     ) this.x     .x4065(parse);         if (this.y     ) this.y     .x4065(parse);         if (this.blur  ) this.blur  .x4065(parse);         if (this.spread) this.spread.x4065(parse);         if (this.fill  ) this.fill  .x4065(parse);         if (this.blend ) this.blend .x4065(parse);         if (this.behind) this.behind.x4065(parse);     }                   v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.x     ) this.x     .v4066(parse, from, force);         if (this.y     ) this.y     .v4066(parse, from, force);         if (this.blur  ) this.blur  .v4066(parse, from, force);         if (this.spread) this.spread.v4066(parse, from, force);         if (this.fill  ) this.fill  .v4066(parse, from, force);         if (this.blend ) this.blend .v4066(parse, from, force);         if (this.behind) this.behind.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.x     ) this.x     .m4064(parse);         if (this.y     ) this.y     .m4064(parse);         if (this.blur  ) this.blur  .m4064(parse);         if (this.spread) this.spread.m4064(parse);         if (this.fill  ) this.fill  .m4064(parse);         if (this.blend ) this.blend .m4064(parse);         if (this.behind) this.behind.m4064(parse);     } }


class f1853 extends r2005 {     x      = null;     y      = null;     blur   = null;     spread = null;     fill   = null;     blend  = null;                constructor(nodeId, options)     {         super(t1192, nodeId, options);     }        reset()     {         super.reset();          this.x      = null;         this.y      = null;         this.blur   = null;         this.spread = null;         this.fill   = null;         this.blend  = null;     }        copy()     {         const copy = new f1853(this.nodeId, this.options);          copy.u3332(this);          if (this.x     ) copy.x      = this.x     .copy();         if (this.y     ) copy.y      = this.y     .copy();         if (this.blur  ) copy.blur   = this.blur  .copy();         if (this.spread) copy.spread = this.spread.copy();         if (this.fill  ) copy.fill   = this.fill  .copy();         if (this.blend ) copy.blend  = this.blend .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const x      = this.x      ? (await this.x     .eval(parse)).f3605() : null;         const y      = this.y      ? (await this.y     .eval(parse)).f3605() : null;         const blur   = this.blur   ? (await this.blur  .eval(parse)).f3605() : null;         const spread = this.spread ? (await this.spread.eval(parse)).f3605() : null;         let   fill   = this.fill   ? (await this.fill  .eval(parse)).f3605() : null;         const blend  = this.blend  ? (await this.blend .eval(parse)).f3605() : null;                   if (   fill             && fill.type == u1163)             fill = new g1974(fill);            if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new r1977(                 x      ?? input.x,                 y      ?? input.y,                 blur   ?? input.blur,                 spread ?? input.spread,                 fill   ?? input.fill,                 blend  ?? input.blend,                 this.options.enabled);         }         else         {             this.value = new r1977(                 x,                  y,                  blur,                  spread,                  fill,                  blend,                 this.options.enabled);         }           this.n4078(parse,         [             ['x',      this.value.x     ],             ['y',      this.value.y     ],             ['blur',   this.value.blur  ],             ['spread', this.value.spread],             ['fill',   this.value.fill  ],             ['blend',  this.value.blend ],         ]);                   if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.blur  ) this.blur   = this.value.blur  .copy();         if (!this.spread) this.spread = this.value.spread.copy();         if (!this.fill  ) this.fill   = this.value.fill  .copy();         if (!this.blend ) this.blend  = this.value.blend .copy();           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.blur   && this.blur  .isValid()             && this.spread && this.spread.isValid()             && this.fill   && this.fill  .isValid()             && this.blend  && this.blend .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.x     ) this.x     .x4065(parse);         if (this.y     ) this.y     .x4065(parse);         if (this.blur  ) this.blur  .x4065(parse);         if (this.spread) this.spread.x4065(parse);         if (this.fill  ) this.fill  .x4065(parse);         if (this.blend ) this.blend .x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.x     ) this.x     .v4066(parse, from, force);         if (this.y     ) this.y     .v4066(parse, from, force);         if (this.blur  ) this.blur  .v4066(parse, from, force);         if (this.spread) this.spread.v4066(parse, from, force);         if (this.fill  ) this.fill  .v4066(parse, from, force);         if (this.blend ) this.blend .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.x     ) this.x     .m4064(parse);         if (this.y     ) this.y     .m4064(parse);         if (this.blur  ) this.blur  .m4064(parse);         if (this.spread) this.spread.m4064(parse);         if (this.fill  ) this.fill  .m4064(parse);         if (this.blend ) this.blend .m4064(parse);     } }


class h1855 extends r2005 {     radius = null;        constructor(nodeId, options)     {         super(z1195, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new h1855(this.nodeId, this.options);          copy.u3332(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const radius = this.radius ? (await this.radius.eval(parse)).f3605() : null;                   if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new k1979(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new k1979(                 radius,                 this.options.enabled);         }           this.n4078(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        f3605()     {         return new k1979(             this.radius ? this.radius.f3605() : this.input.radius.f3605(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.radius) this.radius.x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.radius) this.radius.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.radius) this.radius.m4064(parse);     } }


class g1847 extends r2005 {     radius = null;        constructor(nodeId, options)     {         super(a1198, nodeId, options);     }        reset()     {         super.reset();          this.radius = null;     }        copy()     {         const copy = new g1847(this.nodeId, this.options);          copy.u3332(this);          if (this.radius) copy.radius = this.radius.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const radius = this.radius ? (await this.radius.eval(parse)).f3605() : null;                   if (this.input)         {             const input = (await this.input.eval(parse)).f3605();              this.value = new b1969(                 radius ?? input.radius,                 this.options.enabled);         }         else         {             this.value = new b1969(                 radius,                 this.options.enabled);         }           this.n4078(parse,         [             ['radius', this.value.radius]         ]);                   if (!this.radius) this.radius = this.value.radius.copy();           this.validate();          return this;     }        f3605()     {         return new b1969(             this.radius ? this.radius.f3605() : this.input.radius.f3605(),             this.options.enabled);     }        isValid()     {         return super.isValid()             && this.radius && this.radius.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.radius) this.radius.x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.radius) this.radius.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.radius) this.radius.m4064(parse);     } }


class t1854 extends h2004 {     opacity;     blend;        constructor(nodeId, options)     {         super(r1204, nodeId, options);     }        reset()     {         super.reset();          this.opacity = null;         this.blend   = null;     }        copy()     {         const copy = new t1854(this.nodeId, this.options);          copy.u3332(this);          if (this.opacity) copy.opacity = this.opacity.copy();         if (this.blend  ) copy.blend   = this.blend  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const opacity = (await this.opacity.eval(parse)).f3605();         const blend   = (await this.blend  .eval(parse)).f3605();           this.value =              this.options.enabled             ? new i1978(opacity, blend)             : new i1978(new p1983(100), new p1983(0));           this.n4078(parse,          [             ['opacity', opacity],             ['blend',   blend  ]         ]);           this.validate();          return this;     }        f3605()     {         return this.value.copy();     }        isValid()     {         return this.opacity && this.opacity.isValid()             && this.blend   && this.blend  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.opacity) this.opacity.x4065(parse);         if (this.blend  ) this.blend  .x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.opacity) this.opacity.v4066(parse, from, force);         if (this.blend  ) this.blend  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.opacity) this.opacity.m4064(parse);         if (this.blend  ) this.blend  .m4064(parse);     } }


class r1856 extends h2004 {     maskType;        constructor(nodeId, options)     {         super(d1201, nodeId, options);     }        reset()     {         super.reset();          this.maskType = null;     }        copy()     {         const copy = new r1856(this.nodeId, this.options);          copy.u3332(this);          if (this.maskType) copy.maskType = this.maskType.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const maskType = (await this.maskType.eval(parse)).f3605();           this.value = new m1980(maskType, this.options.enabled);           this.n4078(parse,          [             ['maskType', maskType]         ]);           this.validate();          return this;     }        f3605()     {         return this.value.copy();     }        isValid()     {         return this.maskType && this.maskType.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.maskType) this.maskType.x4065(parse);     }                    v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.maskType) this.maskType.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.maskType) this.maskType.m4064(parse);     } }


class a1936 extends h2004 {     x      = null;     y      = null;     width  = null;     height = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();                  this.x      = null;         this.y      = null;         this.width  = null;         this.height = null;     }        u3332(base)     {         super.u3332(base);          if (base.x     ) this.x      = base.x     .copy();         if (base.y     ) this.y      = base.y     .copy();         if (base.width ) this.width  = base.width .copy();         if (base.height) this.height = base.height.copy();     }        async evalBaseParams(parse, evalHeight = true)     {         const x      = this.x      ? (await this.x     .eval(parse)).f3605() : null;         const y      = this.y      ? (await this.y     .eval(parse)).f3605() : null;         const width  = this.width  ? (await this.width .eval(parse)).f3605() : null;          const height = evalHeight                     && this.height ? (await this.height.eval(parse)).f3605() : null;          return [x, y, width, height];     }        evalStyle(options = {})     {                       }        isValid()     {         return this.x      && this.x     .isValid()             && this.y      && this.y     .isValid()             && this.width  && this.width .isValid()             && this.height && this.height.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.x     ) this.x     .x4065(parse);         if (this.y     ) this.y     .x4065(parse);         if (this.width ) this.width .x4065(parse);         if (this.height) this.height.x4065(parse);     }            v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.x     ) this.x     .v4066(parse, from, force);         if (this.y     ) this.y     .v4066(parse, from, force);         if (this.width ) this.width .v4066(parse, from, force);         if (this.height) this.height.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.x     ) this.x     .m4064(parse);         if (this.y     ) this.y     .m4064(parse);         if (this.width ) this.width .m4064(parse);         if (this.height) this.height.m4064(parse);     } }    function validateObjectRect(x, y, w, h, a = 0, _a = 0) {     if (w < 0)     {         x += w * Math.cos(_a);         y += w * Math.sin(_a);     }      if (h < 0)     {         y += h * Math.cos(_a);         x -= h * Math.sin(_a);     }             w = Math.abs(w);     h = Math.abs(h);       return [x, y, w, h, a, _a]; }


class p1935 extends a1936 {     input = null;      props = null;           constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.input = null;         this.props = null;     }        u3332(base)     {         super.u3332(base);                  if (base.input) this.input = base.input.copy();         if (base.props) this.props = base.props.copy();     }        d2869()     {         return this.value             && this.value.props             && this.value.props.isValid();     }        isCached()     {         return super.isCached()             && (  !this.input                  || this.input.isCached());     }        async l2868(parse)     {         let props = this.props ? (await this.props.eval(parse)).f3605() : null;          if (   props             && o1207.includes(props.type))             props = new p1982([props]);                   if (this.value)         {             if (this.input)                 this.value.props = props ?? this.input.f3605().props;             else                 this.value.props = props;                                   if (   this.value                 && this.value.isValid()                 && this.value.props != undefined)              {                 this.n4078(parse,                  [                     ['props', props]                 ],                  true);                   if (!this.props) this.props = this.value.props.copy();             }         }     }        async x4077(parse)     {         if (!this.value)             return;           for (const c111 of this.value.objects)         {             s946(c111.fills,   'obj.fills   must not be null');             s946(c111.strokes, 'obj.strokes must not be null');             s946(c111.effects, 'obj.effects must not be null');               if (!this.value.props)                 continue;                               if (w951(this.value.props.type))             {                                for (let i = this.value.props.items.length-1; i >= 0; i--)                     m1788(c111, this.value.props.items[i]);             }             else                 m1788(c111, this.value.props);         }     }        evalStyle(options = {})     {      }        isValid()     {         return super.isValid()             && (!this.input || this.input.isValid())             && this.props && this.props.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.input) this.input.x4065(parse);         if (this.props) this.props.x4065(parse);     }            v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.input) this.input.v4066(parse, from, force);         if (this.props) this.props.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.input) this.input.m4064(parse);         if (this.props) this.props.m4064(parse);     } } 


class z1930 extends p1935 {     round = null;        constructor(nodeId, options)     {         super(h1211, nodeId, options);     }        reset()     {         super.reset();          this.round = null;     }        copy()     {         const copy = new z1930(this.nodeId, this.options);          copy.u3332(this);          if (this.round) copy.round = this.round.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;         let   round = this.round ? (await this.round.eval(parse)).f3605() : null;          let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(input);                          if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;           }         else         {             this.value = new e1986(                 this.nodeId,                  x,                  y,                  width,                  height,                  round);         }                  this.n4078(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.d2869()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const rect = new k1811(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r);                  rect.i4075(x, y);                 rect.h3704(x, y, w, h);                  this.value.objects.push(rect);             }         }                   await super.x4077(parse);     }        f3605()     {         const rect = new e1986(             this.nodeId,             this.x     .f3605(),             this.y     .f3605(),             this.width .f3605(),             this.height.f3605(),             this.round .f3605());          rect.e3598(this.value);          rect.props   = this.props.f3605();         rect.objects = this.value.objects.map(o => o.copy());          return rect;     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.round) this.round.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.round) this.round.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.round) this.round.m4064(parse);     } }


class y1922 extends p1935 {     constructor(nodeId, options)     {         super(c1214, nodeId, options);     }        copy()     {         const copy = new y1922(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           let input = this.input ? (await this.input.eval(parse)).f3605() : null;          let [x, y, width, ] = await this.evalBaseParams(parse, false);                       if (input)         {             this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(input);              if (x    )  this.value.x     = x;      else  x     = this.value.x;                   if (y    )  this.value.y     = y;      else  y     = this.value.y;                   if (width)  this.value.width = width;  else  width = this.value.width;           }         else         {             this.value = new v1981(                 this.nodeId,                  x,                  y,                  width);         }           this.n4078(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.x    ) this.x     = this.value.x    .copy();         if (!this.y    ) this.y     = this.value.y    .copy();         if (!this.width) this.width = this.value.width.copy();           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                       this.value.objects = [];           if (   super.d2869()                && this.value.x    .isValid()             && this.value.y    .isValid()             && this.value.width.isValid())          {             let x = this.value.x    .value;             let y = this.value.y    .value;             let w = this.value.width.value;               [x, y, w, , , ] = validateObjectRect(x, y, w, 0);               if (w != 0)             {                 const line = new s1807(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w);                  line.i4075(x, y);                 line.h3704(x, y, w, 0.01);                                  this.value.objects.push(line);             }         }                   await super.x4077(parse);     }        f3605()     {         const line = new v1981(             this.nodeId,             this.x     .f3605(),             this.y     .f3605(),             this.width .f3605());          line.e3598(this.value);          line.props   = this.props.f3605();         line.objects = this.value.objects.map(o => o.copy());          return line;     } }


class t1918 extends p1935 {     position = null;     round    = null;     from     = null;     to       = null;     inner    = null;        constructor(nodeId, options)     {         super(k1217, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.from     = null;         this.to       = null;         this.inner    = null;     }        copy()     {         const copy = new t1918(this.nodeId, this.options);          copy.u3332(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.from    ) copy.from     = this.from    .copy();         if (this.to      ) copy.to       = this.to      .copy();         if (this.inner   ) copy.inner    = this.inner   .copy();                  return copy;     }       async eval(parse)     {         if (this.isCached())             return this;           let [x, y, width, height] = await this.evalBaseParams(parse);          let input = this.input    ? (await this.input   .eval(parse)).f3605() : null;         let pos   = this.position ? (await this.position.eval(parse)).f3605() : null;         let round = this.round    ? (await this.round   .eval(parse)).f3605() : null;         let from  = this.from     ? (await this.from    .eval(parse)).f3605() : null;         let to    = this.to       ? (await this.to      .eval(parse)).f3605() : null;         let inner = this.inner    ? (await this.inner   .eval(parse)).f3605() : null;           if (input)         {             this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (from  )  this.value.from     = from ;   else  from   = this.value.from;               if (to    )  this.value.to       = to   ;   else  to     = this.value.to;               if (inner )  this.value.inner    = inner;   else  inner  = this.value.inner;           }         else         {             this.value = new g1973(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 from,                 to,                 inner);         }           this.n4078(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['from',     from  ],             ['to',       to    ],             ['inner',    inner ]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.from    ) this.from     = this.value.from    .copy();         if (!this.to      ) this.to       = this.value.to      .copy();         if (!this.inner   ) this.inner    = this.value.inner   .copy();           this.validate();          return this;     }        async x4077(parse, options = {})     {        if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.d2869()             && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid())          {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new p1983(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new p1983(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new p1983(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new p1983(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             let   r = this.value.round .value;             const f = this.value.from  .value;             const t = this.value.to    .value;             const i = this.value.inner .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const ellipse = new j1805(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, f, t, i);                  ellipse.i4075(x, y);                 ellipse.h3704(x, y, w, h);                  this.value.objects.push(ellipse);             }         }           await super.x4077(parse);     }                       f3605()     {         const ellipse = new g1973(             this.nodeId,             this.position.f3605(),             this.x       .f3605(),             this.y       .f3605(),             this.width   .f3605(),             this.height  .f3605(),             this.round   .f3605(),             this.from    .f3605(),             this.to      .f3605(),             this.inner   .f3605());          ellipse.e3598(this.value);          ellipse.props = this.props.f3605();          ellipse.objects =              this.value.objects             ? this.value.objects.map(o => o.copy())             : [];                  return ellipse;     }                isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.from     && this.from    .isValid()             && this.to       && this.to      .isValid()             && this.inner    && this.inner   .isValid();     }        x4065(parse)     {         super.x4065(parse);           if (this.position) this.position.x4065(parse);         if (this.round   ) this.round   .x4065(parse);         if (this.from    ) this.from    .x4065(parse);         if (this.to      ) this.to      .x4065(parse);         if (this.inner   ) this.inner   .x4065(parse);     }                   v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.position) this.position.v4066(parse, from, force);         if (this.round   ) this.round   .v4066(parse, from, force);         if (this.from    ) this.from    .v4066(parse, from, force);         if (this.to      ) this.to      .v4066(parse, from, force);         if (this.inner   ) this.inner   .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);           if (this.position) this.position.m4064(parse);         if (this.round   ) this.round   .m4064(parse);         if (this.from    ) this.from    .m4064(parse);         if (this.to      ) this.to      .m4064(parse);         if (this.inner   ) this.inner   .m4064(parse);     } }


class h1941 extends p1935 {     round = null;     bias  = null;        constructor(nodeId, options)     {         super(g1220, nodeId, options);     }        reset()     {         super.reset();          this.round = null;         this.bias  = null;     }        copy()     {         const copy = new h1941(this.nodeId, this.options);          copy.u3332(this);          if (this.round) copy.round = this.round.copy();         if (this.bias ) copy.bias  = this.bias .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;         let   round = this.round ? (await this.round.eval(parse)).f3605() : null;         let   bias  = this.bias  ? (await this.bias .eval(parse)).f3605() : null;                  let [x, y, width, height] = await this.evalBaseParams(parse);           if (input)         {             this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(input);              if (x     )  this.value.x      = x;       else  x      = this.value.x;                   if (y     )  this.value.y      = y;       else  y      = this.value.y;                   if (width )  this.value.width  = width;   else  width  = this.value.width;               if (height)  this.value.height = height;  else  height = this.value.height;              if (round )  this.value.round  = round;   else  round  = this.value.round;               if (bias  )  this.value.bias   = bias;    else  bias   = this.value.bias;           }         else         {             this.value = new j1995(                 this.nodeId,                  x,                  y,                  width,                  height,                  round,                 bias);         }                  this.n4078(parse,          [             ['x',      x     ],             ['y',      y     ],             ['width',  width ],             ['height', height],             ['round',  round ],             ['bias',   bias  ]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.x     ) this.x      = this.value.x     .copy();         if (!this.y     ) this.y      = this.value.y     .copy();         if (!this.width ) this.width  = this.value.width .copy();         if (!this.height) this.height = this.value.height.copy();         if (!this.round ) this.round  = this.value.round .copy();         if (!this.bias  ) this.bias   = this.value.bias  .copy();           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                        this.value.objects = [];           if (   super.d2869()                && this.value.x     .isValid()                 && this.value.y     .isValid()                 && this.value.width .isValid()             && this.value.height.isValid()             && this.value.round .isValid()             && this.value.bias  .isValid())         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);             let   b = this.value.bias  .value;               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const trapeze = new h1816(                     this.nodeId,                      this.nodeId,                      this.nodeName,                      x, y, w, h, r, b);                  trapeze.i4075(x, y);                 trapeze.h3704(x, y, w, h);                  this.value.objects.push(trapeze);             }         }           await super.x4077(parse);     }        f3605()     {         const trap = new j1995(             this.nodeId,             this.x     .f3605(),             this.y     .f3605(),             this.width .f3605(),             this.height.f3605(),             this.round .f3605(),             this.bias  .f3605());          trap.e3598(this.value);          trap.props   = this.props.f3605();         trap.objects = this.value.objects.map(o => o.copy());          return trap;     }        isValid()     {         return super.isValid()             && this.round && this.round.isValid()             && this.bias  && this.bias .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.round) this.round.x4065(parse);         if (this.bias ) this.bias .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.round) this.round.v4066(parse, from, force);         if (this.bias ) this.bias .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.round) this.round.m4064(parse);         if (this.bias ) this.bias .m4064(parse);     } }


class m1929 extends p1935 {     position = null;     round    = null;     corners  = null;        constructor(nodeId, options)     {         super(s1223, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.corners  = null;     }        copy()     {         const copy = new m1929(this.nodeId, this.options);          copy.u3332(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.corners ) copy.corners  = this.corners .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input   = this.input    ? (await this.input   .eval(parse)).f3605() : null;         let pos     = this.position ? (await this.position.eval(parse)).f3605() : null;         let round   = this.round    ? (await this.round   .eval(parse)).f3605() : null;         let corners = this.corners  ? (await this.corners .eval(parse)).f3605() : null;           if (input)         {             this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(input);              if (pos    )  this.value.position = pos;      else  pos     = this.value.position;             if (x      )  this.value.x        = x;        else  x       = this.value.x;                   if (y      )  this.value.y        = y;        else  y       = this.value.y;                   if (width  )  this.value.width    = width;    else  width   = this.value.width;               if (height )  this.value.height   = height;   else  height  = this.value.height;              if (round  )  this.value.round    = round;    else  round   = this.value.round;               if (corners)  this.value.corners  = corners;  else  corners = this.value.corners;           }         else         {             this.value = new q1985(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 corners);         }           this.n4078(parse,          [             ['position', pos    ],             ['x',        x      ],             ['y',        y      ],             ['width',    width  ],             ['height',   height ],             ['round',    round  ],             ['corners',  corners]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.corners ) this.corners  = this.value.corners .copy();           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   super.d2869()                && this.value.x      .isValid()             && this.value.y      .isValid()             && this.value.width  .isValid()             && this.value.height .isValid()             && this.value.round  .isValid()             && this.value.corners.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new p1983(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new p1983(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new p1983(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new p1983(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const c = Math.max(3, Math.floor(this.value.corners.value));               [x, y, w, h, , ] = validateObjectRect(x, y, w, h);               if (   w != 0                  && h != 0)             {                 const poly = new e1810(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, c);                  poly.i4075(x, y);                 poly.h3704(x, y, w, h);                  this.value.objects.push(poly);             }         }                   await super.x4077(parse);     }        f3605()     {         const poly = new q1985(             this.nodeId,             this.position.f3605(),             this.x       .f3605(),             this.y       .f3605(),             this.width   .f3605(),             this.height  .f3605(),             this.round   .f3605(),             this.corners .f3605());          poly.e3598(this.value);          poly.props   = this.props.f3605();         poly.objects = this.value.objects.map(o => o.copy());          return poly;     }        isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.corners  && this.corners .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.position) this.position.x4065(parse);         if (this.round   ) this.round   .x4065(parse);         if (this.corners ) this.corners .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.position) this.position.v4066(parse, from, force);         if (this.round   ) this.round   .v4066(parse, from, force);         if (this.corners ) this.corners .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.position) this.position.m4064(parse);         if (this.round   ) this.round   .m4064(parse);         if (this.corners ) this.corners .m4064(parse);     } }


 class n1939 extends p1935 {     position = null;     round    = null;     points   = null;     convex   = null;        constructor(nodeId, options)     {         super(c1226, nodeId, options);     }        reset()     {         super.reset();          this.position = null;         this.round    = null;         this.points   = null;         this.convex   = null;     }        copy()     {         const copy = new n1939(this.nodeId, this.options);          copy.u3332(this);          if (this.position) copy.position = this.position.copy();         if (this.round   ) copy.round    = this.round   .copy();         if (this.points  ) copy.points   = this.points  .copy();         if (this.convex  ) copy.convex   = this.convex  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       let [x, y, width, height] = await this.evalBaseParams(parse);          let input  = this.input    ? (await this.input   .eval(parse)).f3605() : null;         let pos    = this.position ? (await this.position.eval(parse)).f3605() : null;         let round  = this.round    ? (await this.round   .eval(parse)).f3605() : null;         let points = this.points   ? (await this.points  .eval(parse)).f3605() : null;         let convex = this.convex   ? (await this.convex  .eval(parse)).f3605() : null;           if (input)         {             this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(input);              if (pos   )  this.value.position = pos;     else  pos    = this.value.position;             if (x     )  this.value.x        = x;       else  x      = this.value.x;                   if (y     )  this.value.y        = y;       else  y      = this.value.y;                   if (width )  this.value.width    = width;   else  width  = this.value.width;               if (height)  this.value.height   = height;  else  height = this.value.height;              if (round )  this.value.round    = round;   else  round  = this.value.round;               if (points)  this.value.points   = points;  else  points = this.value.points;               if (convex)  this.value.convex   = convex;  else  convex = this.value.convex;          }         else         {             this.value = new m1991(                 this.nodeId,                 pos,                 x,                  y,                  width,                  height,                 round,                 points,                 convex);         }           this.n4078(parse,          [             ['position', pos   ],             ['x',        x     ],             ['y',        y     ],             ['width',    width ],             ['height',   height],             ['round',    round ],             ['points',   points],             ['convex',   convex]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.position) this.position = this.value.position.copy();         if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.points  ) this.points   = this.value.points  .copy();         if (!this.convex  ) this.convex   = this.value.convex  .copy();            this.validate();          return this;    }       async x4077(parse, options = {})    {         if (!this.options.enabled)            return;                                 this.value.objects = [];           if (   super.d2869()                && this.value.x     .isValid()             && this.value.y     .isValid()             && this.value.width .isValid()             && this.value.height.isValid()              && this.value.round .isValid()             && this.value.points.isValid()             && this.value.convex.isValid())         {             const vpos = this.value.position;             const vx   = this.value.x;             const vy   = this.value.y;             const vw   = this.value.width;             const vh   = this.value.height;              const _x = vpos.value <= 0 ? vx : new p1983(vx.value - vw.value, Math.max(vx.decimals, vw.decimals));             const _y = vpos.value <= 0 ? vy : new p1983(vy.value - vh.value, Math.max(vy.decimals, vh.decimals));             const _w = vpos.value <= 0 ? vw : new p1983(vw.value*2, Math.max(vx.decimals, vw.decimals));             const _h = vpos.value <= 0 ? vh : new p1983(vh.value*2, Math.max(vy.decimals, vh.decimals));                          let   x = _x.value;             let   y = _y.value;             let   w = _w.value;             let   h = _h.value;             const r = Math.max(0, this.value.round.value);             const p = Math.max(3, Math.floor(this.value.points.value));             const c = this.value.convex.value;               if (   w != 0                 && h != 0)             {                 const star = new a1814(                     this.nodeId,                     this.nodeId,                     this.nodeName,                     x, y, w, h, r, p, c);                  star.i4075(x, y);                 star.h3704(x, y, w, h);                  this.value.objects.push(star);             }         }                  await super.x4077(parse);     }        f3605()     {         const star = new m1991(             this.nodeId,             this.position.f3605(),             this.x       .f3605(),             this.y       .f3605(),             this.width   .f3605(),             this.height  .f3605(),             this.round   .f3605(),             this.points  .f3605(),             this.convex  .f3605());          star.e3598(this.value);          star.props   = this.props.f3605();         star.objects = this.value.objects.map(o => o.copy());           return star;     }        isValid()     {         return super.isValid()             && this.position && this.position.isValid()             && this.round    && this.round   .isValid()             && this.points   && this.points  .isValid()             && this.convex   && this.convex  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.position) this.position.x4065(parse);         if (this.round   ) this.round   .x4065(parse);         if (this.points  ) this.points  .x4065(parse);         if (this.convex  ) this.convex  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.position) this.position.v4066(parse, from, force);         if (this.round   ) this.round   .v4066(parse, from, force);         if (this.points  ) this.points  .v4066(parse, from, force);         if (this.convex  ) this.convex  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.position) this.position.m4064(parse);         if (this.round   ) this.round   .m4064(parse);         if (this.points  ) this.points  .m4064(parse);         if (this.convex  ) this.convex  .m4064(parse);     } }


class o1940 extends p1935 {     text          = null;     x             = null;     y             = null;     width         = null;     height        = null;     font          = null;     size          = null;     style         = null;     alignH        = null;     alignV        = null;     lineHeight    = null;     letterSpacing = null;                constructor(nodeId, options)     {         super(o1229, nodeId, options);     }            reset()     {         super.reset();                  this.text          = null;         this.x             = null;         this.y             = null;         this.width         = null;         this.height        = null;         this.font          = null;         this.size          = null;         this.style         = null;         this.alignH        = null;         this.alignV        = null;         this.lineHeight    = null;         this.letterSpacing = null;     }        copy()     {         const copy = new o1940(this.nodeId, this.options);          copy.u3332(this);          if (this.text         ) copy.text          = this.text         .copy();         if (this.x            ) copy.x             = this.x            .copy();         if (this.y            ) copy.y             = this.y            .copy();         if (this.width        ) copy.width         = this.width        .copy();         if (this.height       ) copy.height        = this.height       .copy();         if (this.font         ) copy.font          = this.font         .copy();         if (this.style        ) copy.style         = this.style        .copy();         if (this.size         ) copy.size          = this.size         .copy();         if (this.alignH       ) copy.alignH        = this.alignH       .copy();         if (this.alignV       ) copy.alignV        = this.alignV       .copy();         if (this.lineHeight   ) copy.lineHeight    = this.lineHeight   .copy();         if (this.letterSpacing) copy.letterSpacing = this.letterSpacing.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input         = this.input         ? (await this.input        .eval(parse)).f3605() : null;         let   text          = this.text          ? (await this.text         .eval(parse)).f3605() : null;         let   x             = this.x             ? (await this.x            .eval(parse)).f3605() : null;         let   y             = this.y             ? (await this.y            .eval(parse)).f3605() : null;         let   width         = this.width         ? (await this.width        .eval(parse)).f3605() : null;         let   height        = this.height        ? (await this.height       .eval(parse)).f3605() : null;         let   font          = this.font          ? (await this.font         .eval(parse)).f3605() : null;         let   style         = this.style         ? (await this.style        .eval(parse)).f3605() : null;         let   size          = this.size          ? (await this.size         .eval(parse)).f3605() : null;         let   alignH        = this.alignH        ? (await this.alignH       .eval(parse)).f3605() : null;         let   alignV        = this.alignV        ? (await this.alignV       .eval(parse)).f3605() : null;         let   lineHeight    = this.lineHeight    ? (await this.lineHeight   .eval(parse)).f3605() : null;         let   letterSpacing = this.letterSpacing ? (await this.letterSpacing.eval(parse)).f3605() : null;           if (input)         {             this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(input);                          if (text         )  this.value.text          = text;           else  text          = this.value.text;             if (x            )  this.value.x             = x;              else  x             = this.value.x;             if (y            )  this.value.y             = y;              else  y             = this.value.y;             if (width        )  this.value.width         = width;          else  width         = this.value.width;             if (height       )  this.value.height        = height;         else  height        = this.value.height;             if (font         )  this.value.font          = font;           else  font          = this.value.font;             if (style        )  this.value.style         = style;          else  style         = this.value.style;             if (size         )  this.value.size          = size;           else  size          = this.value.size;             if (alignH       )  this.value.alignH        = alignH;         else  alignH        = this.value.alignH;             if (alignV       )  this.value.alignV        = alignV;         else  alignV        = this.value.alignV;             if (lineHeight   )  this.value.lineHeight    = lineHeight;     else  lineHeight    = this.value.lineHeight;             if (letterSpacing)  this.value.letterSpacing = letterSpacing;  else  letterSpacing = this.value.letterSpacing;          }         else         {             this.value = new m1993(                 this.nodeId,                  text,                  x,                  y,                  width,                  height,                  font,                  style,                 size,                 alignH,                 alignV,                 lineHeight,                 letterSpacing);         }                  this.n4078(parse,          [             ['text',          text         ],             ['x',             x            ],             ['y',             y            ],             ['width',         width        ],             ['height',        height       ],             ['font',          font         ],             ['style',         style        ],             ['size',          size         ],             ['alignH',        alignH       ],             ['alignV',        alignV       ],             ['lineHeight',    lineHeight   ],             ['letterSpacing', letterSpacing]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.text         ) this.text          = this.value.text         .copy();         if (!this.x            ) this.x             = this.value.x            .copy();         if (!this.y            ) this.y             = this.value.y            .copy();         if (!this.width        ) this.width         = this.value.width        .copy();         if (!this.height       ) this.height        = this.value.height       .copy();         if (!this.font         ) this.font          = this.value.font         .copy();         if (!this.style        ) this.style         = this.value.style        .copy();         if (!this.size         ) this.size          = this.value.size         .copy();         if (!this.alignH       ) this.alignH        = this.value.alignH       .copy();         if (!this.alignV       ) this.alignV        = this.value.alignV       .copy();         if (!this.lineHeight   ) this.lineHeight    = this.value.lineHeight   .copy();         if (!this.letterSpacing) this.letterSpacing = this.value.letterSpacing.copy();                   this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                   this.value.objects = [];           if (   super.d2869()                && this.value.text         .isValid()             && this.value.x            .isValid()             && this.value.y            .isValid()             && this.value.width        .isValid()             && this.value.height       .isValid()             && this.value.font         .isValid()             && this.value.style        .isValid()             && this.value.size         .isValid()             && this.value.alignH       .isValid()             && this.value.alignV       .isValid()             && this.value.lineHeight   .isValid()             && this.value.letterSpacing.isValid())         {             let x = this.value.x     .value;             let y = this.value.y     .value;             let w = this.value.width .value;             let h = this.value.height.value;              const fontName   = v4016[this.value.font.value];             const fontStyles = getFontStyles(fontName);              const text = new t1815(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.value.text.value,                 x, y, w, h,                 fontName,                 this.value.size         .value,                 fontStyles[Math.min(this.value.style.value, fontStyles.length-1)],                 this.value.alignH       .value,                 this.value.alignV       .value,                 this.value.lineHeight   .value,                 this.value.letterSpacing.value);                               text.i4075(x, y);                                                                                                                                                                                                text.h3704(x, y, w, h);                  this.value.objects.push(text);                      }                   await super.x4077(parse);     }        isValid()     {         return super.isValid()             && this.text          && this.text         .isValid()             && this.x             && this.x            .isValid()             && this.y             && this.y            .isValid()             && this.width         && this.width        .isValid()             && this.height        && this.height       .isValid()             && this.font          && this.font         .isValid()             && this.style         && this.style        .isValid()             && this.size          && this.size         .isValid()             && this.alignH        && this.alignH       .isValid()             && this.alignV        && this.alignV       .isValid()             && this.lineHeight    && this.lineHeight   .isValid()             && this.letterSpacing && this.letterSpacing.isValid();     }        f3605()     {         const text = new m1993(             this.nodeId,             this.text         .f3605(),             this.x            .f3605(),             this.y            .f3605(),             this.width        .f3605(),             this.height       .f3605(),             this.font         .f3605(),             this.style        .f3605(),             this.size         .f3605(),             this.alignH       .f3605(),             this.alignV       .f3605(),             this.lineHeight   .f3605(),             this.letterSpacing.f3605());          text.e3598(this.value);                     text.props   = this.props.f3605();         text.objects = this.value.objects.map(o => o.copy());                  return text;     }        x4065(parse)     {         super.x4065(parse);                  if (this.text         ) this.text         .x4065(parse);         if (this.x            ) this.x            .x4065(parse);         if (this.y            ) this.y            .x4065(parse);         if (this.width        ) this.width        .x4065(parse);         if (this.height       ) this.height       .x4065(parse);         if (this.font         ) this.font         .x4065(parse);         if (this.style        ) this.style        .x4065(parse);         if (this.size         ) this.size         .x4065(parse);         if (this.alignH       ) this.alignH       .x4065(parse);         if (this.alignV       ) this.alignV       .x4065(parse);         if (this.lineHeight   ) this.lineHeight   .x4065(parse);         if (this.letterSpacing) this.letterSpacing.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);                  if (this.text         ) this.text         .v4066(parse, from, force);         if (this.x            ) this.x            .v4066(parse, from, force);         if (this.y            ) this.y            .v4066(parse, from, force);         if (this.width        ) this.width        .v4066(parse, from, force);         if (this.height       ) this.height       .v4066(parse, from, force);         if (this.font         ) this.font         .v4066(parse, from, force);         if (this.style        ) this.style        .v4066(parse, from, force);         if (this.size         ) this.size         .v4066(parse, from, force);         if (this.alignH       ) this.alignH       .v4066(parse, from, force);         if (this.alignV       ) this.alignV       .v4066(parse, from, force);         if (this.lineHeight   ) this.lineHeight   .v4066(parse, from, force);         if (this.letterSpacing) this.letterSpacing.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);                  if (this.text         ) this.text         .m4064(parse);         if (this.x            ) this.x            .m4064(parse);         if (this.y            ) this.y            .m4064(parse);         if (this.width        ) this.width        .m4064(parse);         if (this.height       ) this.height       .m4064(parse);         if (this.font         ) this.font         .m4064(parse);         if (this.style        ) this.style        .m4064(parse);         if (this.size         ) this.size         .m4064(parse);         if (this.alignH       ) this.alignH       .m4064(parse);         if (this.alignV       ) this.alignV       .m4064(parse);         if (this.lineHeight   ) this.lineHeight   .m4064(parse);         if (this.letterSpacing) this.letterSpacing.m4064(parse);     } }


class u1926 extends r2005 {     x = null;     y = null;        constructor(nodeId, options)     {         super(j1232, nodeId, options);     }        reset()     {         super.reset();          this.x = null;         this.y = null;     }        copy()     {         const copy = new u1926(this.nodeId, this.options);          copy.u3332(this);          if (this.value) copy.value = this.value.copy();         if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   let input = this.input ? (await this.input.eval(parse)).f3605() : null;         let x     = this.x     ? (await this.x    .eval(parse)).f3605() : null;         let y     = this.y     ? (await this.y    .eval(parse)).f3605() : null;           if (input)         {             const s3787 = input;              if (input.type == v1238)                 input = new t1984(input.nodeId, input.x, input.y);              this.value        = input.f3605();             this.value.nodeId = this.nodeId;             this.value.e3598(s3787);              if (x)  this.value.x = x;  else  x = this.value.x;             if (y)  this.value.y = y;  else  y = this.value.y;         }         else         {             this.value = new t1984(                 this.nodeId,                  x,                  y);         }           await this.x4077(parse);           this.n4078(parse,          [             ['x', x],             ['y', y]         ]);           if (!this.x) this.x = this.value.x.copy();         if (!this.y) this.y = this.value.y.copy();           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new f1809(                 this.nodeId,                  this.nodeId,                  this.nodeName,                  x,                  y,                  this.smooth ? this.smooth.value/100 : 1);              point.i4075(x, y);              this.value.objects = [point];         }           await super.x4077(parse);     }        f3605()     {         const point = new t1984(             this.nodeId,             this.x.f3605(),             this.y.f3605());          point.objects =              this.value.objects             ? this.value.objects.map(o => o.copy())             : [];          return point;     }        isValid()     {         return super.isValid()             && this.x && this.x.isValid()             && this.y && this.y.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.x) this.x.x4065(parse);         if (this.y) this.y.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.x) this.x.v4066(parse, from, force);         if (this.y) this.y.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.x) this.x.m4064(parse);         if (this.y) this.y.m4064(parse);     } }


class s1927 extends r2005 {     smooth = null;        constructor(nodeId, options)     {         super(t1234, nodeId, options);     }        reset()     {         super.reset();          this.smooth = null;     }        copy()     {         const copy = new s1927(this.nodeId, this.options);          copy.u3332(this);          if (this.value ) copy.value  = this.value .copy();         if (this.smooth) copy.smooth = this.smooth.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input  = this.input  ? (await this.input .eval(parse)).f3605() : null;         const smooth = this.smooth ? (await this.smooth.eval(parse)).f3605() : null;                  if (input)         {             this.value        = input;             this.value.smooth = smooth;         }         else         {             this.value = t1984.NaN.copy();         }           await this.x4077(parse);           this.n4078(parse,          [                          ['smooth', smooth    ]         ]);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x      = this.value.x.value;             const y      = this.value.y.value;             const smooth = this.value.smooth ? this.value.smooth.value/100 : 1;              const point = new f1809(this.nodeId, this.nodeId, this.nodeName, x, y, smooth);              point.i4075(x, y);              this.value.objects = [point];         }           await super.x4077(parse);     }        f3605()     {         return this.value.copy();                                                    }        isValid()     {         return super.isValid()             && this.smooth && this.smooth.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.smooth) this.smooth.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.smooth) this.smooth.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.smooth) this.smooth.m4064(parse);     } }


class l1945 extends p1935 {     points  = null;     closed  = null;     degree  = null;     winding = null;     round   = null;        constructor(nodeId, options)     {         super(u1236, nodeId, options);     }        reset()     {         super.reset();          this.points  = null;         this.closed  = null;         this.degree  = null;         this.winding = null;         this.round   = null;     }        copy()     {         const copy = new l1945(this.nodeId, this.options);          copy.u3332(this);          if (this.points ) copy.points  = this.points .copy();         if (this.closed ) copy.closed  = this.closed .copy();         if (this.degree ) copy.degree  = this.degree .copy();         if (this.winding) copy.winding = this.winding.copy();         if (this.round  ) copy.round   = this.round  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const points  = this.points  ? (await this.points .eval(parse)).f3605() : null;         const closed  = this.closed  ? (await this.closed .eval(parse)).f3605() : null;         const degree  = this.degree  ? (await this.degree .eval(parse)).f3605() : null;         const winding = this.winding ? (await this.winding.eval(parse)).f3605() : null;         const round   = this.round   ? (await this.round  .eval(parse)).f3605() : null;           let input = null;          if (this.input)         {             input = (await this.input.eval(parse)).f3605();               if (   input                 && input.points                 && input.points.items                 && input.points.objects)             {                 s946(                     input.points.items.length == input.points.objects.length,                     'Vector path points input item count must match object count');                  for (let i = 0; i < input.points.items.length; i++)                 {                     const item = input.points.items  [i];                     const c111  = input.points.objects[i];                      if (item && c111)                     {                         item.x = new p1983(c111.x);                         item.y = new p1983(c111.y);                     }                 }             }               this.value = new k1998(                 this.nodeId,                 points && points.items.length > 0 ? points : input.points,                 closed  ?? input.closed,                 degree  ?? input.degree,                 winding ?? input.winding,                 round   ?? input.round);              this.value.e3598(input);         }         else         {             this.value = new k1998(                 this.nodeId,                  points,                  closed,                  degree,                  winding,                  round);         }                   this.n4078(parse,          [             ['value', this.value]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (  !this.points              || this.points.items == 0)                             this.points  = this.value.points .copy();         if (!this.closed ) this.closed  = this.value.closed .copy();         if (!this.degree ) this.degree  = this.value.degree .copy();         if (!this.winding) this.winding = this.value.winding.copy();         if (!this.round  ) this.round   = this.value.round  .copy();            this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                       const points = [];          if (this.value.points.objects)         {             const z4079 = this.value.points.objects.filter(o => o.type == j1232);              for (const pt of z4079)             {                 const p = t1984.create(this.nodeId, pt.x, pt.y);                                  if (pt.smooth != null)                     p.smooth = new p1983(pt.smooth);                  points.push(p);             }         }           this.value.objects = [];           if (   super.d2869()                && points.length >= 2             && this.value.closed .isValid()             && this.value.degree .isValid()             && this.value.winding.isValid()             && this.value.round  .isValid())         {             const path = new a1818(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 this.value.closed .value,                 this.value.degree .value,                 this.value.winding.value,                 this.value.round  .value);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;                           path.i4075(x, y);             path.h3704(x, y, w, h);              this.value.objects.push(path);         }           await super.x4077(parse);     }        f3605()     {         const path = new k1998(             this.nodeId,             this.points .f3605(),             this.closed .f3605(),             this.degree .f3605(),             this.winding.f3605(),             this.round  .f3605());          path.e3598(this.value);          path.props   = this.props.f3605();         path.objects = this.value.objects.map(o => o.copy());          return path;     }        isValid()     {         return super.isValid()             && this.points  && this.points .isValid()             && this.closed  && this.closed .isValid()             && this.degree  && this.degree .isValid()             && this.winding && this.winding.isValid()             && this.round   && this.round  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.points ) this.points .x4065(parse);         if (this.closed ) this.closed .x4065(parse);         if (this.degree ) this.degree .x4065(parse);         if (this.winding) this.winding.x4065(parse);         if (this.round  ) this.round  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.points ) this.points .v4066(parse, from, force);         if (this.closed ) this.closed .v4066(parse, from, force);         if (this.degree ) this.degree .v4066(parse, from, force);         if (this.winding) this.winding.v4066(parse, from, force);         if (this.round  ) this.round  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.points ) this.points .m4064(parse);         if (this.closed ) this.closed .m4064(parse);         if (this.degree ) this.degree .m4064(parse);         if (this.winding) this.winding.m4064(parse);         if (this.round  ) this.round  .m4064(parse);     } }


class z1947 extends r2005 {     x     = null;     y     = null;     join  = null;     cap   = null;     round = null;        constructor(nodeId, options)     {         super(m1239, nodeId, options);     }        reset()     {         super.reset();          this.x     = null;         this.y     = null;         this.join  = null;         this.cap   = null;         this.round = null;     }        copy()     {         const copy = new z1947(this.nodeId, this.options);          copy.u3332(this);          if (this.x    ) copy.x     = this.x    .copy();         if (this.y    ) copy.y     = this.y    .copy();         if (this.join ) copy.join  = this.join .copy();         if (this.cap  ) copy.cap   = this.cap  .copy();         if (this.round) copy.round = this.round.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   let   input = this.input ? (await this.input.eval(parse)).f3605() : null;          const x     = this.x     ? (await this.x    .eval(parse)).f3605() : null;         const y     = this.y     ? (await this.y    .eval(parse)).f3605() : null;         const join  = this.join  ? (await this.join .eval(parse)).f3605() : null;         const cap   = this.cap   ? (await this.cap  .eval(parse)).f3605() : null;         const round = this.round ? (await this.round.eval(parse)).f3605() : null;           if (input)         {             if (input.type == e1231)                 input = new r2000(input.nodeId, input.x, input.y);                          this.value = new r2000(                 this.nodeId,                 x     ?? input.x,                 y     ?? input.y,                 join  ?? input.join,                 cap   ?? input.cap,                 round ?? input.round);         }         else         {             this.value = new r2000(                 this.nodeId,                  x,                  y,                  join,                  cap,                  round);         }                  await this.x4077(parse);           this.n4078(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x                 && this.value.y                 && this.value.join              && this.value.cap               && this.value.round)         {             const x     = this.value.x    .value;             const y     = this.value.y    .value;                                                     const point = new f1809(this.nodeId, this.nodeId, this.nodeName, x, y);              point.i4075(x, y);              this.value.objects = [point];         }           await super.x4077(parse);     }        f3605()     {         const point = new r2000(             this.nodeId,             this.x    .f3605(),             this.y    .f3605(),             this.join .f3605(),             this.cap  .f3605(),             this.round.f3605());          point.e3598(this.value);          point.objects  = this.value.objects.map(o => o.copy());         point.r3710 = this.value.r3710;          return point;     }        isValid()     {         return super.isValid()             && this.x    .isValid()             && this.y    .isValid()             && this.join .isValid()             && this.cap  .isValid()             && this.round.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.x    ) this.x    .x4065(parse);         if (this.y    ) this.y    .x4065(parse);         if (this.join ) this.join .x4065(parse);         if (this.cap  ) this.cap  .x4065(parse);         if (this.round) this.round.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.x    ) this.x    .v4066(parse, from, force);         if (this.y    ) this.y    .v4066(parse, from, force);         if (this.join ) this.join .v4066(parse, from, force);         if (this.cap  ) this.cap  .v4066(parse, from, force);         if (this.round) this.round.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.x    ) this.x    .m4064(parse);         if (this.y    ) this.y    .m4064(parse);         if (this.join ) this.join .m4064(parse);         if (this.cap  ) this.cap  .m4064(parse);         if (this.round) this.round.m4064(parse);     } }


class c1942 extends p2006 {     h3639 = null;     l3640   = null;                    constructor(nodeId, options)     {         super(l1242, nodeId, options);     }        reset()     {         super.reset();                  this.h3639 = null;         this.l3640   = null;     }        copy()     {         const copy = new c1942(this.nodeId, this.options);          copy.u3332(this);          if (this.h3639) copy.h3639 = this.h3639.copy();         if (this.l3640  ) copy.l3640   = this.l3640  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   let p4060       = this.p4060       ? (await this.p4060      .eval(parse)).f3605() : r2000.NaN;         let f4061       = this.f4061       ? (await this.f4061      .eval(parse)).f3605() : r2000.NaN;         let h3639 = this.h3639 ? (await this.h3639.eval(parse)).f3605() : t1984.NaN;         let   l3640 = this.  l3640 ? (await this.  l3640.eval(parse)).f3605() : t1984.NaN;           if (p4060.type == e1231) p4060 = new r2000(p4060.nodeId, p4060.x, p4060.y);         if (f4061.type == e1231) f4061 = new r2000(f4061.nodeId, f4061.x, f4061.y);          if (h3639.type == v1238) h3639 = new t1984(h3639.nodeId, h3639.x, h3639.y);         if (  l3640.type == v1238)   l3640 = new t1984(  l3640.nodeId,   l3640.x,   l3640.y);           this.value = new r1996(             this.nodeId,             p4060,             f4061,             h3639,               l3640);           await this.x4077(parse);           this.n4078(parse,          [             ['value', this.value]         ]);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (   !this.options.enabled             || !this.value.start.isValid()             || !this.value.end  .isValid())             return;                                   this.value.objects = [];           if (   this.value.start.isValid()             && this.value.end  .isValid())         {             const path = new a1818(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 [ this.value.start,                   this.value.h3639.isValid() ? this.value.h3639 : this.value.start,                   this.value.l3640  .isValid() ? this.value.  l3640 : this.value.end,                   this.value.end ],                 0,                 2,                  0,                 0);                           const bounds = getObjBounds([path]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               path.i4075(x, y);             path.h3704(x, y, w, h);              this.value.objects.push(path);         }           await super.x4077(parse);     }        f3605()     {         const edge = new r1996(             this.nodeId,             this.p4060 ? this.p4060.f3605() : r2000.NaN,             this.f4061 ? this.f4061.f3605() : r2000.NaN,             this.h3639.f3605(),             this.l3640  .f3605());          edge.e3598(this.value);          edge.r3710 = this.value.r3710;         edge.objects  = this.value.objects.map(o => o.copy());          return edge;     }        isValid()     {         return super.isValid()             && this.h3639.isValid()             && this.l3640  .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.h3639) this.h3639.x4065(parse);         if (this.l3640  ) this.l3640  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.h3639) this.h3639.v4066(parse, from, force);         if (this.l3640  ) this.l3640  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.h3639) this.h3639.m4064(parse);         if (this.l3640  ) this.l3640  .m4064(parse);     } }


class y1946 extends p1935 {     inputs  = [];      loops   = null;     winding = null;        constructor(nodeId, options)     {         super(s1245, nodeId, options);     }        reset()     {         super.reset();          this.inputs  = [];          this.loops   = null;         this.winding = null;     }        copy()     {         const copy = new y1946(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          if (this.winding) copy.winding = this.winding.copy();          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached()             && this.winding.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const winding = this.winding ? (await this.winding.eval(parse)).f3605() : null;           this.loops = new p1982();           const loop = new p1982();          for (let i = 0; i < this.inputs.length; i++)         {             const input = (await this.inputs[i].eval(parse)).f3605();              if (w951(input.type))             {                 const _loop = new p1982();                  for (const item of input.items)                 {                     if (item.type == h1241)                         _loop.items.push(item);                 }                  if (!isEmpty(_loop.items))                     loops.items.push(_loop);             }             else             {                 s946(                      input.type == h1241,                      'input.type must be VECTOR_EDGE_VALUE');                  loop.items.push(input);             }         }           if (!isEmpty(loop.items))             this.loops.items.push(loop);           this.value = new w1999(             this.nodeId,             this.loops,              winding);           this.n4078(parse,         [             ['value',   this.value],             ['winding', winding   ]         ]);           await this.l2868(parse);           await this.x4077(parse);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];                   if (   this.loops  .isValid()             && this.winding.isValid())         {             const regions = [];               for (let i = 0; i < this.loops.items.length; i++)             {                 const loop = this.loops.items[i];                  console.log('loop.items =', loop.items);                 const points = [];                      for (let j = 0; j < loop.items.length; j++)                 {                     const edge = loop.items[j];                     const next = loop.items[j == loop.items.length-1 ? 0 : j+1];                      points.push(                            edge.start.r3710 == next.start.r3710                         || edge.start.r3710 == next.end  .r3710                         ? edge.end                           : edge.start);                 }                   regions.push(new a1818(                     this.nodeId,                     this.nodeId + '/' + i,                     this.nodeName,                     points,                     1,                     0,                      this.winding.value,                     0));             }                           let bounds = getObjBounds(regions);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               for (const region of regions)             {                 region.i4075(x, y);                 region.h3704(x, y, w, h);                  this.value.objects.push(region);             }         }           await super.x4077(parse);     }        f3605()     {         const region = new w1999(             this.nodeId,             this.loops  .f3605(),             this.winding.f3605(),             this.props  .f3605());          region.e3598(this.value);          region.r3710 = this.value.r3710;         region.objects  = this.value.objects.map(o => o.copy());          return region;     }        isValid()     {         if (!super.isValid())             return false;                      for (const input of this.inputs)             if (!input.isCached())                 return false;                  return this.winding.isValid()             && this.props  .isValid();     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));          if (this.winding) this.winding.x4065(parse);         if (this.props  ) this.props  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));          if (this.winding) this.winding.v4066(parse, from, force);         if (this.props  ) this.props  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));          if (this.winding) this.winding.m4064(parse);         if (this.props  ) this.props  .m4064(parse);     } }


class a1944 extends p1935 {     inputs = [];        constructor(nodeId, options)     {         super(t1248, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new a1944(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        isCached()     {         for (const input of this.inputs)             if (!input.isCached())                 return false;          return super.isCached();     }        async eval(parse)     {         if (this.isCached())             return this;                   const regions = new p1982();          for (let i = 0; i < this.inputs.length; i++)         {             const input = (await this.inputs[i].eval(parse)).f3605();              s946(                  input.type == h1244,                  'input.type must be VECTOR_REGION_VALUE');              regions.items.push(input);         }           this.value = new j1997(             this.nodeId,             regions);           this.n4078(parse,          [             ['value', this.value]         ]);           await this.l2868(parse);                   await this.x4077(parse);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (   !this.options.enabled             || !this.value.isValid())             return;                                   this.value.objects = [];           if (!isEmpty(this.value.regions.items))         {             let points  = [];             let edges   = [];             let regions = [];               for (const region of this.value.regions.items)             {                 if (!isEmpty(region.objects))                     region.fills = region.objects[0].fills;                   if (region.loops)                 {                     for (const loop of region.loops.items)                     {                         for (const edge of loop.items)                         {                             b944(points, edge.start, p => p.r3710 == edge.start.r3710);                             b944(points, edge.end,   p => p.r3710 == edge.end  .r3710);                              b944(edges, edge, e => e.r3710 == edge.r3710);                         }                     }                      b944(regions, region, r => r.r3710 == region.r3710);                 }             }                           const network = new l1817(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 points,                 edges,                 regions);                           const bounds = getObjBounds([network]);              let x = bounds.x;             let y = bounds.y;             let w = bounds.w;             let h = bounds.h;               network.i4075(x, y);             network.h3704(x, y, w, h);              this.value.objects.push(network);         }           await super.x4077(parse);     }        f3605()     {         const network = new j1997(             this.nodeId,             this.regions.f3605());          network.e3598(this.value);          network.r3710 = this.value.r3710;         network.objects  = this.value.objects.map(o => o.copy());          return network;     }        isValid()     {         return super.isValid()             && this.regions.isValid();     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.x4065(parse));     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));     } }


class r1937 extends a1936 {     inputs = [];        constructor(nodeId, options)     {         super(n1251, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];     }        copy()     {         const copy = new r1937(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new u1989(this.nodeId);          this.value.objects = [];                  const inputs = [];                  if (this.options.enabled)         {             for (let i = 0; i < this.inputs.length; i++)             {                 const input = (await this.inputs[i].eval(parse)).f3605();                  if (input)                             {                     inputs.push(input);                      if (   input.type == u1054                         || input.type == c1051)                     {                         for (const item of input.items)                         {                             if (!k1278.includes(item.type))                                 continue;                              this.value.items.push(item);                                                      }                     }                     else                     {                         this.value.items.push(input);                                              }                 }             }         }           this.n4078(parse,          [             ['value', this.value]         ]);                      await this.x4077(parse, {inputs: inputs});           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                       if (this.value.items)         {             const group = new q1813(                 this.nodeId,                 this.nodeId,                 this.nodeName);               for (let i = 0; i < options.inputs.length; i++)             {                 const input = options.inputs[i];                  if (input.objects)                 {                     for (let j = 0; j < input.objects.length; j++)                         this.r3711(group.children, input.objects[j], i, j);                 }             }                                 const bounds = getObjBounds(group.children);              const singlePoint =                    group.children.length  == 1                  && group.children[0].type == j1232;              for (const c111 of group.children)             {                 c111.w3717(c111.sp0.x, c111.sp0.y);                 c111.resetSpace(bounds, singlePoint);             }               group.x      = bounds.x;             group.y      = bounds.y;             group.width  = bounds.width;             group.height = bounds.height;                           group.w3717();             group.resetSpace(bounds);              group.i4075(bounds.x, bounds.y);             group.h3704(bounds.x, bounds.y, bounds.width, bounds.height);               this.value.objects = [group];         }         else         {             this.value.objects = [];         }           await super.x4077(parse);     }        r3711(objects, _obj, inputIndex, objIndex)     {         const c111 = d3712(_obj);          c111.nodeId    = this.nodeId;         c111.objectId += w961 + inputIndex;         c111.listId    = -1;          objects.push(c111);     }        f3605()     {         return this.value.copy();     }        isValid()     {         if (!super.isValid())              return false;          for (const input of this.inputs)             if (!input.isValid())                 return false;          return true;     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));     } }


class v1919 extends p1935 {     round    = null;     children = null;        constructor(nodeId, options)     {         super(n1254, nodeId, options);     }        reset()     {         super.reset();          this.round    = null;         this.children = null;     }        copy()     {         const copy = new v1919(this.nodeId, this.options);          copy.u3332(this);          if (this.round   ) copy.round    = this.round   .copy();         if (this.children) copy.children = this.children.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const [x, y, width, height] = await this.evalBaseParams(parse);          const round    = this.round    ? (await this.round   .eval(parse)).f3605() : null;         let   children = this.children ? (await this.children.eval(parse)).f3605() : null;          if (   children             && k1278.includes(children.type)             && children.type != u1054)         {             const objects    = children.objects;             children         = new p1982([children]);             children.objects = objects;         }           let input = null;          if (this.input)         {             input = (await this.input.eval(parse)).f3605();              this.value = new x1975(                 this.nodeId,                 x        ?? input.x,                 y        ?? input.y,                 width    ?? input.width,                 height   ?? input.height,                 round    ?? input.round,                 children ?? input.children);         }         else         {             this.value = new x1975(                 this.nodeId,                  x,                  y,                  width,                 height,                  round,                  children);         }           this.n4078(parse,          [             ['value', this.value]         ]);           await this.l2868(parse);           await this.x4077(parse);           if (!this.x       ) this.x        = this.value.x       .copy();         if (!this.y       ) this.y        = this.value.y       .copy();         if (!this.width   ) this.width    = this.value.width   .copy();         if (!this.height  ) this.height   = this.value.height  .copy();         if (!this.round   ) this.round    = this.value.round   .copy();         if (!this.children) this.children = this.value.children.copy();           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                       if (   this.value.x             && this.value.y             && this.value.width             && this.value.height             && this.value.round)         {             let   x = this.value.x     .value;             let   y = this.value.y     .value;             let   w = this.value.width .value;             let   h = this.value.height.value;             const r = Math.max(0, this.value.round.value);               const frame = new m1806(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 x, y, w, h, r);               for (let i = 0; i < this.value.objects.length; i++)                 this.r3711(frame.children, this.value.objects[i]);               frame.i4075(x, y);             frame.h3704(x, y, w, h);                      this.value.objects = [frame];                           this.n4078(parse,              [                 ['nChildren', new p1983(frame.children.length)]             ],              true);         }           await super.x4077(parse);     }        r3711(objects, _obj)     {         const c111 = d3712(_obj);                              c111.nodeId   = this.nodeId;         c111.objectId = c111.objectId + w961 + this.nodeId;         c111.listId   = -1;                  objects.push(c111);     }        f3605()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.round    && this.round   .isValid()             && this.children && this.children.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.round   ) this.round   .x4065(parse);         if (this.children) this.children.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.round   ) this.round   .v4066(parse, from, force);         if (this.children) this.children.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.round   ) this.round   .m4064(parse);         if (this.children) this.children.m4064(parse);     } }


class h1915 extends r2005 {     props   = null;     replace = null;        constructor(nodeId, options)     {         super(g1263, nodeId, options);     }        reset()     {         super.reset();          this.props   = null;         this.replace = null;     }        copy()     {         const copy = new h1915(this.nodeId, this.options);          copy.u3332(this);          if (this.props  ) copy.props   = this.props  .copy();         if (this.replace) copy.replace = this.replace.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                   const input   = this.input   ? (await this.input  .eval(parse)).f3605() : null;         const props   = this.props   ? (await this.props  .eval(parse)).f3605() : null;         const replace = this.replace ? (await this.replace.eval(parse)).f3605() : null;            if (input)         {             this.value         = input;             this.value.props   = props;             this.value.replace = replace;         }         else         {             this.value = new i4194();         }                  await this.x4077(parse);           this.n4078(parse,          [             ['type',    this.outputType()],                          ['props',   props            ],             ['replace', replace          ]         ]);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (this.value.isValid())         {             this.value.objects =                     this.input                  && this.input.value                 ? this.input.value.objects.map(o => o.copy())                  : [];         }           if (this.value.objects)         {             for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + w961 + this.nodeId;             }              this.applyProps(this.value.objects, this.value.props, this.value.replace.value);         }                   await super.x4077(parse);     }        applyProps(objects, props, replace)     {         for (const c111 of objects)         {             if (this.options.enabled)             {                                                                                                                                          {                     if (replace == 1)                     {                         c111.fills    = [];                         c111.strokes  = [];                         c111.effects  = [];                         c111.maskType = 0;                     }                       if (w951(props.type))                     {                                        for (let i = props.items.length-1; i >= 0; i--)                             m1788(c111, props.items[i]);                     }                     else                         m1788(c111, props);                 }             }         }     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }            isValid()     {         return super.isValid()             && this.props   && this.props  .isValid()             && this.replace && this.replace.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.props  ) this.props  .x4065(parse);         if (this.replace) this.replace.x4065(parse);     }       v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.props  ) this.props  .v4066(parse, from, force);         if (this.replace) this.replace.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.props  ) this.props  .m4064(parse);         if (this.replace) this.replace.m4064(parse);     } }


class v1909 extends a1936 {     input     = null;      operation = null;     children  = null;        constructor(nodeId, options)     {         super(h1270, nodeId, options);     }        reset()     {         super.reset();          this.input     = null;         this.operation = null;         this.children  = null;     }        copy()     {         const copy = new v1909(this.nodeId, this.options);          copy.u3332(this);          if (this.input)              copy.input = this.input.copy();          if (this.operation) copy.operation = this.operation.copy();         if (this.children ) copy.children  = this.children .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           await this.evalBaseParams(parse);          const operation = this.operation ? (await this.operation.eval(parse)).f3605() : null;         let   children  = this.children  ? (await this.children .eval(parse)).f3605() : null;           if (   children             && k1278.includes(children.type)             && children.type != u1054)             children = new p1982([children]);           let input = null;          if (this.input)         {             input = (await this.input.eval(parse)).f3605();              this.value = new v1988(                 this.nodeId,                 operation ?? input.operation,                 children  ?? input.children);         }         else         {             this.value = new v1988(                 this.nodeId,                  operation,                 children);         }           this.n4078(parse,         [                          ['operation', this.value.operation],             ['children',  this.value.children ]         ]);           await this.l2868(parse);          await this.x4077(parse);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                       if (this.value.children)         {             const bool = new q1803(                 this.nodeId,                 this.nodeId,                 this.nodeName,                 this.operation);               if (this.children.objects)             {                 for (let i = 0; i < this.children.objects.length; i++)                 {                     const c111    = this.children.objects[i].copy();                     c111.nodeId   = this.nodeId;                     c111.objectId = c111.objectId + w961 + this.nodeId;                     c111.listId   = -1;                     bool.children.push(c111);                 }             }               this.value.objects = [bool];              this.z3067.push(['nObjects', new p1983(                 this.children.objects                  ? this.children.objects.length                 : 0)]);         }         else         {             this.value.objects = [];             this.z3067.push(['nObjects', new p1983(0)]);         }                   await super.x4077(parse);     }        f3605()     {         return this.value.copy();     }        isValid()     {         return super.isValid()             && this.children.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.input   ) this.input   .x4065(parse);         if (this.children) this.children.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.input   ) this.input   .v4066(parse, from, force);         if (this.children) this.children.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.input   ) this.input   .m4064(parse);         if (this.children) this.children.m4064(parse);     } }














class w1931 extends a1936 {     inputs = [];      retain = null;      finalize;        constructor(nodeId, options)     {         super(i1277, nodeId, options);     }        reset()     {         super.reset();          this.inputs = [];         this.retain = null;     }        copy()     {         const copy = new w1931(this.nodeId, this.options);          copy.u3332(this);          copy.inputs = this.inputs.map(i => i.copy());          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;          const retain   = (await this.retain.eval(parse)).f3605();         const finalize = this.finalize.value > 0;           this.value = new p1982();          this.value.objects = [];           for (let i = 0, o = 0; i < this.inputs.length; i++)         {             await this.inputs[i].eval(parse);              const objects = u3600(this.inputs[i].value);                                   if (   this.options.enabled                 && (   finalize                     || retain.value == 1))             {                 for (let j = 0; j < objects.length; j++, o++)                 {                     let c111 = objects[j];                                            c111.nodeId   = this.nodeId;                     c111.objectId = c111.objectId + w961 + this.nodeId;                     c111.listId   = -1;                      if (  (   !isEmpty(c111.fills  )                            || !isEmpty(c111.strokes))                         && !c111.b3713)                             c111.retain = finalize ? 2 : 1;                                                  this.value.objects.push(c111);                 }             }         }           this.n4078(parse, [['', new i4194()]]);           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        isValid()     {         return super.isValid()             && !this.inputs.find(i => !i.isValid())             && this.retain && this.retain.isValid();     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));          if (this.retain) this.retain.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));          if (this.retain) this.retain.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));          if (this.retain) this.retain.m4064(parse);     } }


class w1924 extends r2005 {     t3636    = null;     x           = null;     y           = null;     affectSpace = null;     s3632  = null;                constructor(nodeId, options)     {         super(o1256, nodeId, options);     }        reset()     {         super.reset();          this.t3636    = null;         this.x           = null;         this.y           = null;         this.affectSpace = null;         this.s3632  = null;     }        copy()     {         const copy = new w1924(this.nodeId, this.options);          copy.u3332(this);          if (this.t3636   ) copy.t3636    = this.t3636   .copy();         if (this.x          ) copy.x           = this.x          .copy();         if (this.y          ) copy.y           = this.y          .copy();         if (this.affectSpace) copy.affectSpace = this.affectSpace.copy();         if (this.s3632 ) copy.s3632  = this.s3632 .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const t3636    = this.t3636    ? (await this.t3636   .eval(parse)).f3605() : null;         const x           = this.x           ? (await this.x          .eval(parse)).f3605() : null;         const y           = this.y           ? (await this.y          .eval(parse)).f3605() : null;         const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).f3605() : null;         const s3632  = this.s3632  ? (await this.s3632 .eval(parse)).f3605() : null;           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new i4194();         }           await this.x4077(             parse,              {                 t3636:    t3636,                 x:           x,                  y:           y,                 s3632:  s3632,                 affectSpace: affectSpace             });           this.n4078(parse,         [             ['type',        this.outputType()],             ['moveType',    t3636         ],             ['x',           x                ],             ['y',           y                ],             ['affectSpace', affectSpace      ],             ['showCenter',  s3632       ]         ]);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (   this.value             && this.value.isValid()             && options.t3636             && options.x             && options.y             && options.affectSpace             && options.s3632)         {             this.value.objects = u3600(this.input.value);               if (w951(this.value.type))             {                 for (let i = 0; i < this.value.items.length; i++)                     this.value.items[i].objects = this.value.objects.filter(o => o.u3795 == i);             }                              const t3636    = options.t3636   .value;             const x           = options.x          .value;             const y           = options.y          .value;             const affectSpace = options.affectSpace.value;             const s3632  = options.s3632 .value;               const _a = y/360*Tau;             const _v = vector(_a, x);                          const _x = t3636 == 0 ? x : _v.x;             const _y = t3636 == 0 ? y : _v.y;               const c4185 =                  t3636 == 0                 ? f883(_x, _y)                 : f879(                     f883(_x, _y),                     q882(-_a));               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + w961 + this.nodeId;                  if (this.options.enabled)                     c111.o4076(c4185, affectSpace > 0);             }               if (   this.value.type == q1235                 && this.value.objects                 && this.value.objects.length > 0)             {                 for (let i = 0; i < this.value.objects[0].points.length; i++)                 {                     const p = this.value.objects[0].points[i].q3722();                          this.value.points.objects[i].x = p.x;                     this.value.points.objects[i].y = p.y;                 }             }               if (s3632 > 0)             {                 const objects = [...this.value.objects];                  objects.forEach(o => n2567(this, o, parse.viewportZoom));             }         }                           await super.x4077(parse);     }        f3605()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.t3636    && this.t3636   .isValid()             && this.x           && this.x          .isValid()             && this.y           && this.y          .isValid()             && this.affectSpace && this.affectSpace.isValid()             && this.s3632  && this.s3632 .isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.t3636   ) this.t3636   .x4065(parse);         if (this.x          ) this.x          .x4065(parse);         if (this.y          ) this.y          .x4065(parse);         if (this.affectSpace) this.affectSpace.x4065(parse);         if (this.s3632 ) this.s3632 .x4065(parse);     }       v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.t3636   ) this.t3636   .v4066(parse, from, force);         if (this.x          ) this.x          .v4066(parse, from, force);         if (this.y          ) this.y          .v4066(parse, from, force);         if (this.affectSpace) this.affectSpace.v4066(parse, from, force);         if (this.s3632 ) this.s3632 .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.t3636   ) this.t3636   .m4064(parse);         if (this.x          ) this.x          .m4064(parse);         if (this.y          ) this.y          .m4064(parse);         if (this.affectSpace) this.affectSpace.m4064(parse);         if (this.s3632 ) this.s3632 .m4064(parse);     } }


class q1914 extends r2005 {     s3632  = null;     affectSpace = null;        constructor(type, nodeId, options)     {         super(type, nodeId, options);     }        reset()     {         super.reset();          this.s3632  = null;         this.affectSpace = null;     }        u3332(base)     {         super.u3332(base);          if (base.s3632 ) this.s3632  = base.s3632 .copy();         if (base.affectSpace) this.affectSpace = base.affectSpace.copy();     }        async evalBaseParams(parse)     {         const s3632  = this.s3632  ? (await this.s3632 .eval(parse)).f3605() : null;         const affectSpace = this.affectSpace ? (await this.affectSpace.eval(parse)).f3605() : null;          return [s3632, affectSpace];     }        async evalAffineObjects(parse, options, n3715, scaleStyle, getXform)     {         if (   !this.value             || !this.value.isValid())             return v1042.NaN;           this.value.objects = u3600(this.input.value);                  if (w951(this.value.type))         {             for (let i = 0; i < this.value.items.length; i++)                 this.value.items[i].objects = this.value.objects.filter(o => o.u3795 == i);         }           const bounds = getObjBounds(this.value.objects);         const c4185  = getXform();           for (const c111 of this.value.objects)         {             c111.nodeId   = this.nodeId;             c111.objectId = c111.objectId + w961 + this.nodeId;               if (this.options.enabled)             {                 c111.o4076(c4185, options.affectSpace.value > 0);                  c111.n3715 *= Math.abs(n3715);                 c111.scaleStyle   *= Math.abs(scaleStyle  );                                   if (c111.type == o1229)                 {                     const sx = Math.sqrt(sqr(c4185[0][0]) + sqr(c4185[0][1]));                     const sy = Math.sqrt(sqr(c4185[1][0]) + sqr(c4185[1][1]));                      c111.size *= Math.min(sx, sy);                 }             }         }           if (   this.value.type == q1235             && this.value.objects             && this.value.objects.length > 0)         {             for (let i = 0; i < this.value.objects[0].points.length; i++)             {                 const p = this.value.objects[0].points[i].q3722();                  this.value.points.objects[i].x = p.x;                 this.value.points.objects[i].y = p.y;             }         }           if (options.s3632.value > 0)         {             const objects = [...this.value.objects];              objects.forEach(o => n2567(this, o, parse.viewportZoom));         }           return bounds;     }        isValid()     {         return super.isValid()             && this.s3632  && this.s3632 .isValid()             && this.affectSpace && this.affectSpace.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.s3632 ) this.s3632 .x4065(parse);         if (this.affectSpace) this.affectSpace.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.s3632 ) this.s3632 .v4066(parse, from, force);         if (this.affectSpace) this.affectSpace.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.s3632 ) this.s3632 .m4064(parse);         if (this.affectSpace) this.affectSpace.m4064(parse);     } }


class w1933 extends q1914 {     angle = null;        constructor(nodeId, options)     {         super(u1257, nodeId, options);     }        reset()     {         super.reset();          this.angle = null;     }        copy()     {         const copy = new w1933(this.nodeId, this.options);          copy.u3332(this);          if (this.angle) copy.angle = this.angle.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const angle = this.angle ? (await this.angle.eval(parse)).f3605() : null;          const [s3632, affectSpace] = await this.evalBaseParams(parse);           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new i4194();         }                  const _bounds = await this.x4077(             parse,              {                 angle:       angle,                  s3632:  s3632,                 affectSpace: affectSpace             });                   const bounds = new e1986(             this.nodeId,             new p1983(_bounds.x     ),              new p1983(_bounds.y     ),              new p1983(_bounds.width ),             new p1983(_bounds.height),             new p1983(0));           this.n4078(parse,         [             ['type',        this.outputType()],             ['angle',       angle            ],             ['showCenter',  s3632       ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async x4077(parse, options)     {         const a     = options.angle.value/360*Tau;         const c4185 = q882(a);          return await this.evalAffineObjects(             parse,             options,              1,              1,             () => c4185);     }        f3605()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.angle && this.angle.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.angle) this.angle.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.angle) this.angle.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.angle) this.angle.m4064(parse);     } }


class b1934 extends q1914 {     q884        = null;     z885        = null;     affectCorners = null;     affectStyle   = null;            constructor(nodeId, options)     {         super(c1258, nodeId, options);     }        reset()     {         super.reset();          this.q884        = null;         this.z885        = null;         this.affectCorners = null;         this.affectStyle   = null;     }        copy()     {         const copy = new b1934(this.nodeId, this.options);          copy.u3332(this);          if (this.q884       ) copy.q884        = this.q884       .copy();         if (this.z885       ) copy.z885        = this.z885       .copy();         if (this.affectCorners) copy.affectCorners = this.affectCorners.copy();         if (this.affectStyle  ) copy.affectStyle   = this.affectStyle  .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const q884        = this.q884        ? (await this.q884       .eval(parse)).f3605() : null;         const z885        = this.z885        ? (await this.z885       .eval(parse)).f3605() : null;         const affectCorners = this.affectCorners ? (await this.affectCorners.eval(parse)).f3605() : null;         const affectStyle   = this.affectStyle   ? (await this.affectStyle  .eval(parse)).f3605() : null;          const [s3632, affectSpace] = await this.evalBaseParams(parse);           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new i4194();         }                  const _bounds = await this.x4077(             parse,              {                 q884:        q884,                  z885:        z885,                  s3632:    s3632,                 affectSpace:   affectSpace,                 affectCorners: affectCorners,                 affectStyle:   affectStyle             });           const bounds = new e1986(             this.nodeId,             new p1983(_bounds.x     ),              new p1983(_bounds.y     ),              new p1983(_bounds.width ),             new p1983(_bounds.height),             new p1983(0));           this.n4078(parse,         [             ['type',          this.outputType()],             ['scaleX',        q884           ],             ['scaleY',        z885           ],             ['showCenter',    s3632       ],             ['affectSpace',   affectSpace      ],             ['affectCorners', affectCorners    ],             ['affectStyle',   affectStyle      ],             ['bounds',        bounds           ]         ]);                   this.validate();          return this;     }        async x4077(parse, options)     {         let sx = t869(options.q884.value / 100);         let sy = t869(options.z885.value / 100);          const scale = Math.min(sx, sy);          return await this.evalAffineObjects(             parse,             options,              this.affectCorners.value > 0 ? scale : 1,             this.affectStyle  .value > 0 ? scale : 1,             () => [[sx, 0,  0],                    [0,  sy, 0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.q884        && this.q884       .isValid()             && this.z885        && this.z885       .isValid()             && this.affectCorners && this.affectCorners.isValid()             && this.affectStyle   && this.affectStyle  .isValid();     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        x4065(parse)     {         super.x4065(parse);          if (this.q884       ) this.q884       .x4065(parse);         if (this.z885       ) this.z885       .x4065(parse);         if (this.affectCorners) this.affectCorners.x4065(parse);         if (this.affectStyle  ) this.affectStyle  .x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.q884       ) this.q884       .v4066(parse, from, force);         if (this.z885       ) this.z885       .v4066(parse, from, force);         if (this.affectCorners) this.affectCorners.v4066(parse, from, force);         if (this.affectStyle  ) this.affectStyle  .v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.q884       ) this.q884       .m4064(parse);         if (this.z885       ) this.z885       .m4064(parse);         if (this.affectCorners) this.affectCorners.m4064(parse);         if (this.affectStyle  ) this.affectStyle  .m4064(parse);     } }


class u1938 extends q1914 {     m886 = null;     a887 = null;        constructor(nodeId, options)     {         super(y1259, nodeId, options);     }        reset()     {         super.reset();          this.m886 = null;         this.a887 = null;     }        copy()     {         const copy = new u1938(this.nodeId, this.options);          copy.u3332(this);          if (this.m886) copy.m886 = this.m886.copy();         if (this.a887) copy.a887 = this.a887.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const m886 = this.m886 ? (await this.m886.eval(parse)).f3605() : null;         const a887 = this.a887 ? (await this.a887.eval(parse)).f3605() : null;          const [s3632, affectSpace] = await this.evalBaseParams(parse);           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new i4194();         }                   const _bounds = await this.x4077(             parse,              {                 m886:       m886,                  a887:       a887,                  s3632:  s3632,                 affectSpace: affectSpace             });           const bounds = new e1986(             this.nodeId,             new p1983(_bounds.x     ),              new p1983(_bounds.y     ),              new p1983(_bounds.width ),             new p1983(_bounds.height),             new p1983(0));           this.n4078(parse,         [             ['type',        this.outputType()],             ['skewX',       m886            ],             ['skewY',       a887            ],             ['showCenter',  s3632       ],             ['affectSpace', affectSpace      ],             ['bounds',      bounds           ]         ]);           this.validate();          return this;     }        async x4077(parse, options)     {         const sx = -options.m886.value / 100;         const sy = -options.a887.value / 100;          return await this.evalAffineObjects(             parse,             options,              1, 1,             () => [[1,  sx, 0],                    [sy, 1,  0],                    [0,  0,  1]]);     }        isValid()     {         return super.isValid()             && this.m886 && this.m886.isValid()             && this.a887 && this.a887.isValid();     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }        x4065(parse)     {         super.x4065(parse);          if (this.m886) this.m886.x4065(parse);         if (this.a887) this.a887.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.m886) this.m886.v4066(parse, from, force);         if (this.a887) this.a887.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.m886) this.m886.m4064(parse);         if (this.a887) this.a887.m4064(parse);     } }


class t1916 extends r2005 {     centerX    = null;     centerY    = null;     units      = null;     s3632 = null;        constructor(nodeId, options)     {         super(j1260, nodeId, options);     }        reset()     {         super.reset();          this.centerX    = null;         this.centerY    = null;         this.units      = null;         this.s3632 = null;     }        copy()     {         const copy = new t1916(this.nodeId, this.options);          copy.u3332(this);          if (this.centerX   ) copy.centerX    = this.centerX   .copy();         if (this.centerY   ) copy.centerY    = this.centerY   .copy();         if (this.units     ) copy.units      = this.units     .copy();         if (this.s3632) copy.s3632 = this.s3632.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const centerX    = this.centerX    ? (await this.centerX   .eval(parse)).f3605() : null;         const centerY    = this.centerY    ? (await this.centerY   .eval(parse)).f3605() : null;         const units      = this.units      ? (await this.units     .eval(parse)).f3605() : null;         const s3632 = this.s3632 ? (await this.s3632.eval(parse)).f3605() : null;           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else         {             this.value = new i4194();         }                   await this.x4077(             parse,              {                 centerX:    centerX,                  centerY:    centerY,                 units:      units,                 s3632: s3632             });           this.n4078(parse,         [             ['centerX',    centerX   ],             ['centerY',    centerY   ],             ['units',      units     ],             ['showCenter', s3632]         ]);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3600(this.input.value);                           const centerX     = options.centerX   .value;             const centerY     = options.centerY   .value;             const units       = options.units     .value;             const s3632  = options.s3632.value;                   const cx          = units == 0 ? centerX/100 : centerX;             const cy          = units == 0 ? centerY/100 : centerY;               const bounds      = getObjBounds(this.value.objects);              const singlePoint =                      this.value.objects.length  == 1                  && this.value.objects[0].type == j1232;               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + w961 + this.nodeId;                  if (this.options.enabled)                     c111.resetSpace(bounds, singlePoint, cx, cy, units);             }               if (s3632 > 0)             {                 const objects = [...this.value.objects];                  objects.forEach(o => n2567(this, o, parse.viewportZoom));             }         }                           await super.x4077(parse);     }        f3605()     {         return this.value             ? this.value.copy()             : null;     }                    isValid()     {         return super.isValid()             && this.centerX    && this.centerX   .isValid()             && this.centerY    && this.centerY   .isValid()             && this.units      && this.units     .isValid()             && this.s3632 && this.s3632.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.centerX   ) this.centerX   .x4065(parse);         if (this.centerY   ) this.centerY   .x4065(parse);         if (this.units     ) this.units     .x4065(parse);         if (this.s3632) this.s3632.x4065(parse);     }       v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.centerX   ) this.centerX   .v4066(parse, from, force);         if (this.centerY   ) this.centerY   .v4066(parse, from, force);         if (this.units     ) this.units     .v4066(parse, from, force);         if (this.s3632) this.s3632.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.centerX   ) this.centerX   .m4064(parse);         if (this.centerY   ) this.centerY   .m4064(parse);         if (this.units     ) this.units     .m4064(parse);         if (this.s3632) this.s3632.m4064(parse);     } }


class z1932 extends r2005 {     s3632 = null;        constructor(nodeId, options)     {         super(m1261, nodeId, options);     }        reset()     {         super.reset();          this.s3632 = null;     }        copy()     {         const copy = new z1932(this.nodeId, this.options);          copy.u3332(this);          if (this.s3632) copy.s3632 = this.s3632.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const s3632 = this.s3632 ? (await this.s3632.eval(parse)).f3605() : null;           if (this.input)         {             this.value = (await this.input.eval(parse)).f3605();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else             this.value = new i4194();                   await this.x4077(parse, {s3632: s3632});           this.n4078(parse,         [             ['showCenter', s3632]         ]);           this.validate();          return this;     }        async x4077(parse, options = {})     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3600(this.input.value);               const s3632 = options.s3632.value;               const bounds = getObjBounds(this.value.objects);              const singlePoint =                    this.value.objects.length  == 1                  && this.value.objects[0].type == j1232;               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + w961 + this.nodeId;                  if (this.options.enabled)                 {                     c111.w3717();                     c111.resetSpace(bounds, singlePoint);                 }             }               if (s3632)             {                 const objects = [...this.value.objects];                  objects.forEach(o => n2567(this, o, parse.viewportZoom));             }         }                           await super.x4077(parse);     }        f3605()     {         return this.value         ? this.value.copy()         : null;     }                    isValid()     {         return super.isValid()             && this.s3632 && this.s3632.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.s3632) this.s3632.x4065(parse);     }       v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.s3632) this.s3632.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.s3632) this.s3632.m4064(parse);     } }


class i1923 extends p2006 {     distance = null;     angle    = null;            constructor(nodeId, options)     {         super(a1264, nodeId, options);     }            reset()     {         super.reset();          this.distance = null;         this.angle    = null;     }        copy()     {         const copy = new i1923(this.nodeId, this.options);          copy.u3332(this);          if (this.distance) copy.distance = this.distance.copy();         if (this.angle   ) copy.angle    = this.angle   .copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;         const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;           if (   p4060             && f4061)         {             const dist = distance(p4060.q3722(), f4061.q3722());              let ang = angle(u894(f4061.q3722(), p4060.q3722()));             if (ang > Tau/2) ang -= Tau;              this.distance = new p1983(dist);             this.angle    = new p1983(ang / Tau * 360);         }         else         {             this.distance = p1983.NaN;             this.angle    = p1983.NaN;         }           this.n4078(parse,         [             ['distance', this.distance],             ['angle',    this.angle   ]         ]);                   this.validate();          return this;     }                                                                                                                                        }


class g1943 extends r2005 {     length = null;            constructor(nodeId, options)     {         super(s1265, nodeId, options);     }            reset()     {         super.reset();          this.length = null;     }        copy()     {         const copy = new g1943(this.nodeId, this.options);          copy.u3332(this);          if (this.length) copy.length = this.length.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const input = this.input ? (await this.input.eval(parse)).f3605() : null;           if (input)             this.length = new p1983(z875(input.q3722()), -2);         else             this.length = p1983.NaN;           this.n4078(parse,         [             ['length', this.length]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.length && this.length.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.length) this.length.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.length) this.length.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.length) this.length.m4064(parse);     } }


class o1917 extends l2007 {     constructor(nodeId, options)     {         super(x1266, nodeId, options);     }                                   copy()     {         const copy = new o1917(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (   this.p4060             && this.f4061             && this.d4062)         {             const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;             const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;             const d4062 = this.d4062 ? (await this.d4062.eval(parse)).f3605() : null;              if (   p4060                 && f4061                 && d4062)             {                 const pc = o990(                     p4060.q3722(),                     f4061.q3722(),                     d4062.q3722());                  this.value = t1984.fromPoint(this.nodeId, pc);             }             else             {                 this.value = t1984.NaN.copy();             }         }         else         {             this.value = t1984.NaN.copy();         }           await this.x4077(parse);           this.n4078(parse,          [             ['', new i4194()]                      ]);                   this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new f1809(this.nodeId, this.nodeId, this.nodeName, x, y);              point.i4075(x, y);              this.value.objects = [point];         }           await super.x4077(parse);     } }


class n1921 extends w2008 {     segment = null;        constructor(nodeId, options)     {         super(u1267, nodeId, options);     }            reset()     {         super.reset();          if (this.segment) this.segment.reset();     }        copy()     {         const copy = new n1921(this.nodeId, this.options);          copy.u3332(this);          if (this.segment) copy.segment = this.segment.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const segment = this.segment ? (await this.segment.eval(parse)).f3605() : null;           if (   this.p4060             && this.f4061             && this.d4062             && this.a4063)         {             const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;             const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;             const d4062 = this.d4062 ? (await this.d4062.eval(parse)).f3605() : null;             const a4063 = this.a4063 ? (await this.a4063.eval(parse)).f3605() : null;              if (   p4060                 && f4061                 && d4062                 && a4063)             {                 const p = p983(                     p4060.q3722(),                     f4061.q3722(),                     d4062.q3722(),                     a4063.q3722(),                     segment.value != 0);                  this.value = t1984.fromPoint(this.nodeId, p);             }             else             {                 this.value = t1984.NaN.copy();             }         }         else         {             this.value = t1984.NaN.copy();         }           await this.x4077(parse);           this.n4078(parse,          [             ['value',   this.value],             ['segment', segment   ]         ]);                   this.validate();          return this;     }        async x4077(parse, options = {})     {         if (!this.options.enabled)             return;                                   this.value.objects = [];           if (   this.value.x.isValid()             && this.value.y.isValid())         {             const x = this.value.x.value;             const y = this.value.y.value;              const point = new f1809(this.nodeId, this.nodeId, this.nodeName, x, y);              point.i4075(x, y);              this.value.objects = [point];         }           await super.x4077(parse);     }        isValid()     {         return super.isValid()             && this.segment && this.segment.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.segment) this.segment.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.segment) this.segment.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.segment) this.segment.m4064(parse);     } }


class f1920 extends p2006 {     amount     = null;     transform  = null;     s3632 = null;            constructor(nodeId, options)     {         super(c1268, nodeId, options);     }            reset()     {         super.reset();          this.amount     = null;         this.transform  = null;         this.s3632 = null;     }        copy()     {         const copy = new f1920(this.nodeId, this.options);          copy.u3332(this);          if (this.amount    ) copy.amount     = this.amount    .copy();         if (this.transform ) copy.transform  = this.transform .copy();         if (this.s3632) copy.s3632 = this.s3632.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const amount     = this.amount     ? (await this.amount    .eval(parse)).f3605() : null;         const transform  = this.transform  ? (await this.transform .eval(parse)).f3605() : null;         const s3632 = this.s3632 ? (await this.s3632.eval(parse)).f3605() : null;           if (   this.p4060             && this.f4061)         {             const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;             const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;              if (   p4060                 && f4061                 && p4060.isValid()                 && f4061.isValid())             {                 const p0  = point(p4060.objects[0].x, p4060.objects[0].y);                 const p1  = point(f4061.objects[0].x, f4061.objects[0].y);                 const amt = amount.value / 100;                  const p   = b980(p0, p1, amt);                                       let sp0 = b980(p4060.objects[0].sp0, f4061.objects[0].sp0, amt);                 let sp1 = b980(p4060.objects[0].sp1, f4061.objects[0].sp1, amt);                 let sp2 = b980(p4060.objects[0].sp2, f4061.objects[0].sp2, amt);                  if (transform.value > 0)                 {                     const l1 = distance(sp0, sp1);                     const l2 = distance(sp0, sp2);                      sp0 = clone(p);                     sp1 = y889(sp0, r891(z876(u894(p1, p0)), l1));                     sp2 = y889(sp0, b1016(r891(z876(u894(p1, p0)), l2)));                 }                   this.value = new t1984(this.nodeId, new p1983(p.x), new p1983(p.y));                  const pt = new f1809(this.nodeId, this.nodeId, this.nodeName, p.x, p.y);                 pt.i4075(p.x, p.y);                 this.value.objects = [pt];                  this.value.objects[0].sp0 = sp0;                 this.value.objects[0].sp1 = sp1;                 this.value.objects[0].sp2 = sp2;                   if (s3632.value > 0)                 {                     const objects = [...this.value.objects];                      objects.forEach(o => n2567(this, o, parse.viewportZoom));                 }             }         }           this.n4078(parse,         [             ['amount',     amount    ],             ['transform',  transform ],             ['showCenter', s3632]         ]);                   this.validate();          return this;     }        isValid()     {         return super.isValid()             && this.amount     && this.amount    .isValid()             && this.transform  && this.transform .isValid()             && this.s3632 && this.s3632.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.amount    ) this.amount    .x4065(parse);         if (this.transform ) this.transform .x4065(parse);         if (this.s3632) this.s3632.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.amount    ) this.amount    .v4066(parse, from, force);         if (this.transform ) this.transform .v4066(parse, from, force);         if (this.s3632) this.s3632.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.amount    ) this.amount    .m4064(parse);         if (this.transform ) this.transform .m4064(parse);         if (this.s3632) this.s3632.m4064(parse);     } }


class d1928 extends p2006 {     measure    = null;     amount     = null;     transform  = null;     s3632 = null;                    constructor(nodeId, options)     {         super(l1269, nodeId, options);     }            reset()     {         super.reset();          this.measure    = null;         this.amount     = null;         this.transform  = null;         this.s3632 = null;     }        copy()     {         const copy = new d1928(this.nodeId, this.options);          copy.u3332(this);          if (this.measure   ) copy.measure    = this.measure   .copy();         if (this.amount    ) copy.amount     = this.amount    .copy();         if (this.transform ) copy.transform  = this.transform .copy();         if (this.s3632) copy.s3632 = this.s3632.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           const measure    = this.measure    ? (await this.measure   .eval(parse)).f3605() : null;         const amount     = this.amount     ? (await this.amount    .eval(parse)).f3605() : null;         const transform  = this.transform  ? (await this.transform .eval(parse)).f3605() : null;         const s3632 = this.s3632 ? (await this.s3632.eval(parse)).f3605() : null;           if (   this.p4060             && this.f4061)         {             const p4060 = this.p4060 ? (await this.p4060.eval(parse)).f3605() : null;             const f4061 = this.f4061 ? (await this.f4061.eval(parse)).f3605() : null;              if (   p4060                 && f4061)             {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       }         }           this.n4078(parse,         [             ['measure',    measure   ],             ['amount',     amount    ],             ['transform',  transform ],             ['showCenter', s3632]         ]);                   this.validate();          return this;     }        x4065(parse)     {         super.x4065(parse);          if (this.measure   ) this.measure   .x4065(parse);         if (this.amount    ) this.amount    .x4065(parse);         if (this.transform ) this.transform .x4065(parse);         if (this.s3632) this.s3632.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.measure   ) this.measure   .v4066(parse, from, force);         if (this.amount    ) this.amount    .v4066(parse, from, force);         if (this.transform ) this.transform .v4066(parse, from, force);         if (this.s3632) this.s3632.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.measure   ) this.measure   .m4064(parse);         if (this.amount    ) this.amount    .m4064(parse);         if (this.transform ) this.transform .m4064(parse);         if (this.s3632) this.s3632.m4064(parse);     } }


class k1925 extends r2005 {     position   = null;     transform  = null;     s3632 = null;                constructor(nodeId, options)     {         super(n1262, nodeId, options);     }        reset()     {         super.reset();                  this.position   = null;         this.transform  = null;         this.s3632 = null;     }        copy()     {         const copy = new k1925(this.nodeId, this.options);          copy.u3332(this);          if (this.position  ) copy.position   = this.position  .copy();         if (this.transform ) copy.transform  = this.transform .copy();         if (this.s3632) copy.s3632 = this.s3632.copy();          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;                       const position   = this.position   ? (await this.position  .eval(parse)).f3605() : null;         const transform  = this.transform  ? (await this.transform .eval(parse)).f3605() : null;         const s3632 = this.s3632 ? (await this.s3632.eval(parse)).f3605() : null;          if (   this.input             && position)         {             this.value = (await this.input.eval(parse)).f3605();              if (this.value)                 this.value.nodeId = this.nodeId;         }         else             this.value = null;            if (   position             && position.isValid())                                   {             const p0 = position.q3722();                                                const p1 = y889(p0, u894(position.sp1, position.sp0));             const p2 = y889(p0, u894(position.sp2, position.sp0));              await this.x4077(                 parse,                  {                     transform:  transform,                     s3632: s3632,                     sp0:        p0,                     sp1:        p1,                     sp2:        p2                 });         }                   this.n4078(parse,         [             ['position',   position  ],             ['transform',  transform ],             ['showCenter', s3632]         ]);           this.validate();          return this;     }        async x4077(parse, options)     {         if (   this.value             && this.value.isValid())         {             this.value.objects = u3600(this.input.value);               const place = f883(                 options.sp0 ? options.sp0.x : 0,                 options.sp0 ? options.sp0.y : 0);               for (const c111 of this.value.objects)             {                 c111.nodeId   = this.nodeId;                 c111.objectId = c111.objectId + w961 + this.nodeId;                   if (this.options.enabled)                 {                     let c4185 = f879(                         f883(                             -c111.sp0.x,                              -c111.sp0.y),                         place);                       if (   options.transform.value > 0                         && options.sp0                         && options.sp1                         && options.sp2)                     {                         const sp = getTransformFromPoints(                             options.sp0,                              options.sp1,                              options.sp2);                          c4185 = f879(c4185, sp);                          c111.sp1 = y889(c111.sp0, point(1, 0));                         c111.sp2 = y889(c111.sp0, point(0, 1));                     }                       c111.o4076(c4185, true);                 }             }               if (options.s3632.value > 0)             {                 const objects = [...this.value.objects];                  objects.forEach(o => n2567(this, o, parse.viewportZoom));             }         }                           await super.x4077(parse);     }        f3605()     {         return this.value              ? this.value.copy()              : null;     }                    isValid()     {         return super.isValid()             && this.position   && this.position  .isValid()             && this.transform  && this.transform .isValid()             && this.s3632 && this.s3632.isValid();     }        x4065(parse)     {         super.x4065(parse);          if (this.position  ) this.position  .x4065(parse);         if (this.transform ) this.transform .x4065(parse);         if (this.s3632) this.s3632.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.position  ) this.position  .v4066(parse, from, force);         if (this.transform ) this.transform .v4066(parse, from, force);         if (this.s3632) this.s3632.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.position  ) this.position  .m4064(parse);         if (this.transform ) this.transform .m4064(parse);         if (this.s3632) this.s3632.m4064(parse);     } }    function getTransformFromPoints(p0, p1, p2)  {     const dx   = p1.x - p0.x;     const dy   = p1.y - p0.y;      const a    = Math.atan2(dy, dx);        const cosa = Math.cos(a);     const sina = Math.sin(a);       const sx   = ((p1.y - p0.y) / nozero(p1.x - p0.x));     const sy   = ((p2.x - p0.x) / nozero(p2.y - p0.y));            return [[ cosa,         -sina , 0 ],              [ sina , cosa,          0 ],              [ 0,             0,             1 ]]; }


class q1845 extends h2004 {     b3063 = [];     params   = [];        constructor(nodeId, options)     {         super(e1282, nodeId, options);     }            copy()     {         const copy = new q1845(this.nodeId, this.options);          copy.u3332(this);          copy.params = this.params.map(p => p.copy());          return copy;     }        v4219(e2963)     {         return this.params[this.b3063.findIndex(id => id == e2963)];     }        async eval(parse)     {         if (this.isCached())             return this;           this.z3067 = [];           if (!isEmpty(this.params))         {             for (let i = 0; i < this.params.length; i++)             {                 const param = await this.params[i].eval(parse);                 this.n4078(parse, [[this.b3063[i], param.f3605()]], true);             }         }         else             this.n4078(parse, [['', new i4194()]], true);                                   this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()               : null;     }        x4065(parse)     {         super.x4065(parse);          this.inputs.forEach(i => i.x4065(parse));         this.params.forEach(p => p.x4065(parse));     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          this.inputs.forEach(i => i.v4066(parse, from, force));         this.params.forEach(p => p.v4066(parse, from, force));     }        m4064(parse)     {         super.m4064(parse);          this.inputs.forEach(i => i.m4064(parse));         this.params.forEach(p => p.m4064(parse));     } } 


class z1846 extends h2004 {     input = null;          dataType = NULL;        constructor(nodeId, options)     {         super(u1283, nodeId, options);     }        reset()     {         super.reset();          this.input    = null;         this.dataType = null;     }        copy()     {         const copy = new z1846(this.nodeId, this.options);                  copy.u3332(this);          if (this.input)              copy.input = this.input.copy();                  copy.dataType = this.dataType;                return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           if (this.input)         {             if (!this.input.value)                 await this.input.eval(parse);              this.value = this.input.f3605();         }          else if (this.dataType != NULL)             this.value = nanFromType(this.dataType);                  else             this.value = new i4194();           this.n4078(parse,         [             ['value', this.value]         ]);           this.validate();          return this;     }        x4065(parse)     {         super.x4065(parse);          if (this.input) this.input.x4065(parse);     }        f3605()     {         return this.value.copy();     }        x4065(parse)     {         super.x4065(parse);          if (this.input) this.input.x4065(parse);     }        v4066(parse, from, force)     {         super.v4066(parse, from, force);          if (this.input) this.input.v4066(parse, from, force);     }        m4064(parse)     {         super.m4064(parse);          if (this.input) this.input.m4064(parse);     } }


class r2001 extends h2004 {     constructor(nodeId, options)     {         super(f1285, nodeId, options);     }            copy()     {         const copy = new r2001(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new i4194();           this.n4078(parse, [['', new i4194()]]);                           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()               : null;     } } 


class v2002 extends h2004 {     constructor(nodeId, options)     {         super(h1286, nodeId, options);     }            copy()     {         const copy = new v2002(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new i4194();           this.n4078(parse, [['', new i4194()]]);                           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()               : null;     } } 


class d2009 extends h2004 {     constructor(nodeId, options)     {         super(v1287, nodeId, options);     }            copy()     {         const copy = new d2009(this.nodeId, this.options);          copy.u3332(this);          return copy;     }        async eval(parse)     {         if (this.isCached())             return this;           this.value = new i4194();           this.n4078(parse, [['', new i4194()]]);                           this.validate();          return this;     }        f3605()     {         return this.value              ? this.value.copy()               : null;     } } 


var q3839 = false;  var i3840          = [];   var c4015            = []; var v4016  = [];       var lastMessage = null;   onmessage = function(e) {     const msg = JSON.parse(e.data);       if (msg.cmd == 'returnUiGetValueForGenerator')          return;           if (msg.cmd == 'genRequest')     {         if (   lastMessage             && lastMessage.cmd == 'genRequest')             return;           x3992(msg.request, msg.save);              }     else     {         switch (msg.cmd)         {             case 'initFonts':        initFonts(msg.fonts, msg.uniqueFontNames); break;                      case 'genEndUiMessage':  q2015 (msg.msgCmd);              break;             case 'genEndFigMessage': q2016();                        break;         }          lastMessage = null;     }       g2012(     {         cmd:   'uiEndGenMessage',         msgCmd: msg.cmd     }); };         function g2012(msg) {     if (msg == undefined)     {         u947('undefined message');         console.trace();     }      postMessage(JSON.stringify(msg)); }    function e2013(msg) {     i3840.push(msg);     w2014(); }    function w2014(msg) {     if (!isEmpty(i3840))          {                  let msg = i3840.shift();                                                                                                                                                                               g2012(msg);     } }    function q2015(msgCmd) {          w2014(); }    function q2016() {     q3839 = false;          if (   !isEmpty(y2020 )         || !isEmpty(y2021)         || !isEmpty(k2022 ))     {         x3836(             a2017,             false,             -1,              Number.MAX_SAFE_INTEGER,              a2018,              g2019,              [],              [],             [],             false);     }      w2014(); }  


var a2017      = -1; var a2018   =  NULL; var g2019  =  NULL; var y2020   =  []; var y2021  =  []; var k2022   =  [];    function initFonts(fonts, uniqueFontNames) {     c4015           = fonts;     v4016 = uniqueFontNames; }    function x3992(request, save) {     const e2028       = parseInt(request[0]);     const actionId        = parseInt(request[1]);     const set             = parseInt(request[2]);     const m3995 = parseInt(request[3]);       const settings =     {         m3634:  ((set >> 0) & 1) != 0,         j2527:         ((set >> 1) & 1) != 0,         p2515: ((set >> 2) & 1) != 0,         c189:        ((set >> 3) & 1) != 0,         a3707:    ((set >> 4) & 1) != 0,         f3708:    ((set >> 5) & 1) != 0     };       const a3993  = request[4];     const t3994 = request[5];      const viewportZoom  = request[6];       const parse = new q1751(         request,          7,         e2028,         a3993,          t3994,          viewportZoom,         settings,         save);       const h3702 = 100;      while (   parse.pos < parse.request.length            && parse.so  < h3702)         u1753(parse);       if (settings.j2527)         p2085(parse);       const x4208 = parse.u3614         .map(id => parse.x4220.find(n => n.nodeId == id));      const g3838 = parse.x4220         .filter(n =>                  n.topLevel              && !x4208.includes(n));       (async () =>     {         for (const node of x4208)         {              if (await z3837(parse.e2028))                 break;              await node.eval(parse);         }            for (const node of g3838)         {              if (await z3837(parse.e2028))                 break;              await node.eval(parse);         }           if (    await z3837(parse.e2028)             && !settings.c189)             return;           e2013({cmd: 'uiEndGlobalProgress'});                  for (const node of g3838)             node.x4065(parse);                           for (const node of parse.x4220)         {             if (node.options.active === true)             {                 if (   node.value                     && node.value.objects)                     node.value.objects.forEach(o => m2024(parse, o));                  if (node.colorStyle)                      u2025(parse, node.colorStyle);             }         }           if (parse.settings.p2515)         {             for (const node of parse.x4220)             {                 if (   node.options.active === true                     && node.value)                 {                     for (const c111 of node.value.objects)                     {                         if (  !c111.b3713                             && c111.xp0                             && c111.xp1                             && c111.xp2)                         {                             const xp0 = clone(c111.xp0);                             const xp1 = clone(c111.xp1);                             const xp2 = clone(c111.xp2);                             const xp3 = y889(xp2, u894(xp1, xp0));                              m2024(                                 parse,                                  createDecoPoly(                                     node,                                      c111.sp0,                                      [xp0, xp2, xp3, xp1],                                      true,                                     '1, 2',                                     [12, 140, 233],                                      p965,                                     false));                         }                     }                 }             }         }           await x3836(             parse.e2028,             settings.c189,             actionId,             m3995,             parse.a3993,             parse.t3994,             parse.z3067,             parse.o3615,             parse.r3616,             save);     })(); }    async function z3837(e2028) {     const uiCurRequestId = await genGetValueFromUi('curRequestId');      if (uiCurRequestId.value > e2028)      {          e2013({cmd: 'uiEndGlobalProgress'});         return true;      }      return false }    function j2023(parse, nodeId, e2963, value) {     if (!value)         return;           x939(parse.z3067, v =>            v.nodeId     == nodeId         && v.e2963    == e2963         && v.value.type == value.type);               parse.z3067.push(     {         nodeId:  nodeId,         e2963: e2963,         type:    value.type,          value:   value.o2080()     }); }    function m2024(parse, object) {     k945(         parse.o3615,         object,         o =>    o.nodeId   == object.nodeId              && o.objectId == object.objectId); }    function u2025(parse, style) {     k945(         parse.r3616,         style,         o => o.nodeId == style.nodeId); }    function z2026() {     a2018  =  NULL;     g2019 =  NULL;      y2020  =  [];     y2021 =  [];     k2022  =  []; }    async function x3836(e2028, c189, actionId, m3995, a3993, t3994, z3067, o3615, r3616, save) {     if (   isEmpty(z3067 )         && isEmpty(o3615)         && isEmpty(r3616 ))     {         a3993  = a2018;         t3994 = g2019;                  z3067  = y2020;         o3615 = y2021;         r3616  = k2022;          z2026();     }     else if (q3839)     {         a2017     = e2028;         a2018  = a3993;         g2019 = t3994;          y2020  = z3067;         y2021 = o3615;         k2022  = r3616;          return;     }       const nodeIds = w1434(z3067.map(v => v.nodeId));     const counts  = nodeIds.map(id => z3067.filter(v => v.nodeId == id).length);             const approxNodeChunkSize = 1000000;     const objChunkSize        = 1000000;     const styleChunkSize      = 1000000;           let n  = 0;      let o  = 0;      let s  = 0;       let nc = 0;      let oc = 0;      let sc = 0;        let b2031   = [],         g2032       = [],         m2033     = [];      let g2030 = 0;      let a2036   = true;               e2013(     {         cmd:      'uiInitGlobalProgress',         e2028: e2028     });       let x2029 = 0;     o3615.forEach(o => x2029 += o.getCount());           while (   n < nodeIds      .length            || o < o3615.length            || s < r3616 .length)     {         if (n < nodeIds.length)         {             b2031.push(nodeIds[n], counts[n]);              const values = z3067.filter(v => v.nodeId == nodeIds[n]);             values.sort((a, b) => a.e2963 - b.e2963);              for (const v of values)                 b2031.push(v.e2963, v.type, v.value);              n++, nc++;         }           if (o < o3615.length)         {             g2032.push(o3615[o].o3716());             o++, oc++;         }           if (s < r3616.length)         {             m2033.push(r3616[s].o3716());             s++, sc++;         }           const chunkNotEmpty =                nc >= approxNodeChunkSize             || oc == objChunkSize             || sc == styleChunkSize;           if (chunkNotEmpty)         {             const n2037 =                        n >= nodeIds      .length                 && o >= o3615.length                 && s >= r3616 .length                 && (   !isEmpty(b2031)                     || !isEmpty(g2032    )                     || !isEmpty(m2033  ));              h2027(                 e2028,                 actionId,                 a3993,                 t3994,                 m3995,                 x2029,                 g2030++,                 b2031,                 g2032,                 m2033,                 n,                 nodeIds.length,                 a2036,                 n2037,                 save);              b2031 = [];  nc = 0;             g2032     = [];  oc = 0;             m2033   = [];  sc = 0;              a2036 = false;         }           if (await z3837(e2028))              break;     }       const lastChunkNotEmpty =            !isEmpty(b2031)         || !isEmpty(g2032    )         || !isEmpty(m2033  );       if (   lastChunkNotEmpty         || c189         ||    isEmpty(z3067)             && isEmpty(o3615)            && isEmpty(r3616))     {         h2027(             e2028,             actionId,             a3993,             t3994,             m3995,             x2029,             g2030++,             b2031,             g2032,             m2033,             nodeIds.length,             nodeIds.length,             false,             true,             save);     }       e2013({         cmd: 'uiForwardToFigma',         msg: {cmd: 'figCommitUndo'}     }) }    function h2027(e2028, actionId, a3993, t3994, m3995, x2029, g2030, b2031, g2032, m2033, t2034, u2035, a2036, n2037, save) {     e2013({         cmd:            'uiUpdateValuesAndObjects',         e2028:       e2028,         actionId:        actionId,         a3993:    a3993,         t3994:   t3994,         m3995: m3995,         x2029:    x2029,         chunkId:         g2030,         values:          [...b2031].map(v => v.toString()),         objects:         [...g2032    ],         styles:          [...m2033  ],         t2034:    t2034,         u2035:      u2035,         a2036:    a2036,         n2037:     n2037,         save:            save     });       if (   !isEmpty(g2032  )         || !isEmpty(m2033))         q3839 = true; }    function i2038(nodeId) {     e2013(     {         cmd:   'uiInitNodeProgress',         nodeId: nodeId     }); }    function b2039(parse, nodeId, progress, updateGlobal = true) {     e2013(     {         cmd:           'uiUpdateNodeProgress',         nodeId:         nodeId,         progress:       progress,         globalProgress: parse.j3611 / parse.f3612,         updateGlobal:   updateGlobal     }); }    function a2040(nodeId, endGlobal) {     e2013(     {         cmd:      'uiEndNodeProgress',         nodeId:    nodeId,         endGlobal: endGlobal     }); }    async function genGetObjectSizeFromFigma(c111)  {     return new Promise((resolve, reject) =>      {         const timeout = 1000;          g2012(         {             cmd: 'uiForwardToFigma',             msg:               {                 cmd:   'figGetObjectSize',                 object: c111             }         });          const f2722 = setTimeout(() =>              reject(new Error('Timeout: Result not received within the specified time')),             timeout);          function o4008(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnFigGetObjectSize')              {                 clearTimeout(f2722);                                  const { objectId, width, height } = msg;                 resolve({ objectId, width, height });                  self.removeEventListener('message', o4008);             }         }          self.addEventListener('message', o4008);     }); }    async function genGetValueFromUi(key)  {     return new Promise((resolve, reject) =>      {         const timeout = 60000;          g2012(         {             cmd: 'uiGetValueForGenerator',             key:  key          });          const f2722 = setTimeout(() =>              reject(new Error('Timeout: Result not received by Generator within the specified time')),             timeout);          function o4008(event)          {             const msg = JSON.parse(event.data);              if (msg.cmd === 'returnUiGetValueForGenerator')              {                 clearTimeout(f2722);                  resolve(                 {                      key:   msg.key,                      value: msg.value                  });                  self.removeEventListener('message', o4008);             }         }          self.addEventListener('message', o4008);     }); }


function h1591(parse) {     parse.pos++;       const col = parse.move();      if (parse.settings.j2527)          w2093(u1163, col, parse);      return r2838(col)[0]; }    function h1592(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const col = new u1780(nodeId, options);      col.o3236 = options.o3236;             let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(col, parse, ignore, w4186);       if (ignore)      {         n1756(parse, col);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;           let b3063;      if (w4186 == 1)     {         col.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['space', 'convert', 'c1', 'c2', 'c3'];       parse.a1754 = false;          for (const id of b3063)     {         switch (id)         {         case 'space':   col.space        = u1753(parse);  break;         case 'convert': col.convert      = u1753(parse);  break;         case 'c1':      col.j3658 = col.c1 = u1753(parse);  break;         case 'c2':      col.x3659 = col.c2 = u1753(parse);  break;         case 'c3':      col.o3660 = col.c3 = u1753(parse);  break;         }     }           parse.r3619--;       n1756(parse, col);     return col; }    function w1593(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const valid = new i1787(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(valid, parse, ignore, w4186);       if (ignore)      {         n1756(parse, valid);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         valid.input = u1753(parse);       valid.quality = u1753(parse);     valid.value   = u1753(parse);       parse.r3619--;       n1756(parse, valid);     return valid; }    function l1594(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const corr = new r1786(nodeId, options);      corr.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(corr, parse, ignore, w4186);       if (ignore)      {         n1756(parse, corr);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)         corr.input = u1753(parse);       b3063 = parse.move().split(',');      parse.a1754 = false;          for (const id of b3063)     {         switch (id)         {         case 'order':  corr.e3657 = corr.order = u1753(parse);  break;         case 'c1':     corr.j3658    = corr.c1    = u1753(parse);  break;         case 'c2':     corr.x3659    = corr.c2    = u1753(parse);  break;         case 'c3':     corr.o3660    = corr.c3    = u1753(parse);  break;         case 'value':  corr.value               = u1753(parse);  break;         }     }                       parse.r3619--;       n1756(parse, corr);     return corr; }    function n1595(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cnt = new s1783(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }       const g3656 =          w4186 == 1         ? parseInt(parse.move())         : -1;           if (parse.settings.j2527)          y2092(cnt, w4186, g3656, parse, ignore);       if (ignore)      {         n1756(parse, cnt);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      if (w4186 == 2)     {         cnt.p4060   = u1753(parse);         cnt.f4061   = u1753(parse);         cnt.standard = u1753(parse);     }     else if (w4186 == 1)     {              if (g3656 == 0) cnt.p4060 = u1753(parse);          else if (g3656 == 1) cnt.f4061 = u1753(parse);           cnt.standard = u1753(parse);     }     else if (w4186 == 0)     {         cnt.standard = u1753(parse);     }      parse.r3619--;       n1756(parse, cnt);     return cnt; }    function x1596(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const convert = new u1785(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(convert, parse, ignore, w4186);       if (ignore)      {         n1756(parse, convert);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         convert.input = u1753(parse);       convert.from = u1753(parse);       parse.r3619--;       n1756(parse, convert);     return convert; }    function l1597(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cb = new y1782(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(cb, parse, ignore, w4186);       if (ignore)      {         n1756(parse, cb);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         cb.input = u1753(parse);      cb.l = u1753(parse);     cb.m = u1753(parse);     cb.s = u1753(parse);           parse.r3619--;       n1756(parse, cb);     return cb; }    function j1598(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const n1029 = new l1784(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(n1029, parse, ignore, w4186);       if (ignore)      {         n1756(parse, n1029);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         n1029.p4060 = u1753(parse);         n1029.f4061 = u1753(parse);     }      else if (w4186 == 1)         n1029.p4060 = u1753(parse);       else if (w4186 != 0)         u947('nInputs must be [0, 2]');       n1029.space  = u1753(parse);     n1029.amount = u1753(parse);     n1029.gamma  = u1753(parse);       parse.r3619--;       n1756(parse, n1029);     return n1029; }    function x1599(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const blend = new h1781(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(blend, parse, ignore, w4186);       if (ignore)      {         n1756(parse, blend);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         blend.p4060 = u1753(parse);         blend.f4061 = u1753(parse);     }      else if (w4186 == 1)         blend.p4060 = u1753(parse);       else if (w4186 != 0)         u947('nInputs must be [0, 2]');       blend.mode    = u1753(parse);     blend.opacity = u1753(parse);       parse.r3619--;       n1756(parse, blend);     return blend; }


function r1600(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const _null = new o1832(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(_null, parse, ignore, w4186);       if (ignore)      {         n1756(parse, _null);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         _null.input = u1753(parse);       parse.r3619--;       n1756(parse, _null);     return _null; }    function h1601(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const variable = new g1843(nodeId, options);      variable.existing = options.existing;       if (parse.settings.j2527)          s2086(variable, parse, ignore);       if (ignore)      {         n1756(parse, variable);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;     parse.a1754 = false;       const m3653 = parseInt(parse.move());      if (m3653 == 1)         variable.varValue = u1753(parse);           parse.r3619--;           variable.linked = variable.id != NULL;       n1756(parse, variable);     return variable; }    function n1602(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const group = new p1844(nodeId, options);           let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(group, parse, ignore, w4186);       if (ignore)      {         n1756(parse, group);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         group.input = u1753(parse);       parse.r3619--;       n1756(parse, group);     return group; }    function r1603(parse) {     parse.pos++;       const list = parse.move();      if (parse.settings.j2527)          w2093(c1051, list, parse);      return i3455(list)[0]; }    function x1604(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const list = new e1822(nodeId, options);           let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(list, parse, ignore, w4186);       if (ignore)      {         n1756(parse, list);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;           for (let i = 0; i < w4186; i++)         list.inputs.push(u1753(parse));       parse.r3619--;               n1756(parse, list);     return list; }    function p1605(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const condense = new t1823(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(condense, parse, ignore, w4186);       if (ignore)      {         n1756(parse, condense);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         condense.input = u1753(parse);           parse.r3619--;       n1756(parse, condense);     return condense; }    function h1606(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const extr = new n1825(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(extr, parse, ignore, w4186);       if (ignore)      {         n1756(parse, extr);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         extr.input = u1753(parse);      extr.indices = u1753(parse);           parse.r3619--;       n1756(parse, extr);     return extr; }    function r1607(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const set = new h1836(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(set, parse, ignore, w4186);       if (ignore)      {         n1756(parse, set);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         set.p4060 = u1753(parse);         set.f4061 = u1753(parse);         set.name   = u1753(parse);     }     else if (w4186 == 1)     {         set.p4060 = u1753(parse);          set.name   = u1753(parse);     }     else if (w4186 == 0)     {         set.name   = u1753(parse);     }           parse.r3619--;       n1756(parse, set);     return set; }    function l1608(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const extr = new e1826(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(extr, parse, ignore, w4186);       if (ignore)      {         n1756(parse, extr);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         extr.input = u1753(parse);      extr.name = u1753(parse);           parse.r3619--;       n1756(parse, extr);     return extr; }    function z1609(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const sub = new b1839(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(sub, parse, ignore, w4186);       if (ignore)      {         n1756(parse, sub);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         sub.input = u1753(parse);      sub.start = u1753(parse);     sub.end   = u1753(parse);           parse.r3619--;       n1756(parse, sub);     return sub; }    function k1610(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const unique = new y1841(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(unique, parse, ignore, w4186);       if (ignore)      {         n1756(parse, unique);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         unique.input = u1753(parse);             parse.r3619--;       n1756(parse, unique);     return unique; }    function p1611(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const reverse = new h1834(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(reverse, parse, ignore, w4186);       if (ignore)      {         n1756(parse, reverse);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         reverse.input = u1753(parse);             parse.r3619--;       n1756(parse, reverse);     return reverse; }    function e1612(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const sort = new h1837(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(sort, parse, ignore, w4186);       if (ignore)      {         n1756(parse, sort);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         sort.input = u1753(parse);      sort.order   = u1753(parse);     sort.reverse = u1753(parse);           parse.r3619--;       n1756(parse, sort);     return sort; }    function h1613(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const filter = new q1827(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(filter, parse, ignore, w4186);       if (ignore)      {         n1756(parse, filter);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         filter.input = u1753(parse);      filter.condition = u1753(parse);           parse.r3619--;       n1756(parse, filter);     return filter; }    function l1614(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const column = new f1821(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(column, parse, ignore, w4186);       if (ignore)      {         n1756(parse, column);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         column.input = u1753(parse);      column.index = u1753(parse);           parse.r3619--;       n1756(parse, column);     return column; }    function h1615(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cell = new v1820(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(cell, parse, ignore, w4186);       if (ignore)      {         n1756(parse, cell);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         cell.input = u1753(parse);      cell.column = u1753(parse);     cell.row    = u1753(parse);           parse.r3619--;       n1756(parse, cell);     return cell; }    function h1616(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const list = new x1830(nodeId, options);           let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(list, parse, ignore, w4186);       if (ignore)      {         n1756(parse, list);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         list.input = u1753(parse);       parse.r3619--;       n1756(parse, list);     return list; }    function z1617(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const sel = new x1835(nodeId, options);           let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(sel, parse, ignore, w4186);       if (ignore)      {         n1756(parse, sel);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         sel.input = u1753(parse);      sel.index = u1753(parse);           parse.r3619--;       n1756(parse, sel);     return sel; }    function w1618(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const count = new w1831(nodeId, options);           let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(count, parse, ignore, w4186);       if (ignore)      {         n1756(parse, count);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         count.input = u1753(parse);      count.start = u1753(parse);       parse.r3619--;       n1756(parse, count);     return count; }    function q1619(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cont = new n1824(nodeId, options);          let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(cont, parse, ignore, w4186);       if (ignore)      {         n1756(parse, cont);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         cont.p4060 = u1753(parse);         cont.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         cont.p4060 = u1753(parse);      }             parse.r3619--;       n1756(parse, cont);     return cont; }    function u1620(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const a3655 = new x1829(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }       const g3656 =          w4186 == 1         ? parseInt(parse.move())         : -1;       if (parse.settings.j2527)          s2086(a3655, parse, ignore, w4186);       if (ignore)      {         n1756(parse, a3655);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      if (w4186 == 2)     {         a3655.p4060    = u1753(parse);         a3655.f4061    = u1753(parse);         a3655.condition = u1753(parse);     }     else if (w4186 == 1)     {              if (g3656 == 0) a3655.p4060 = u1753(parse);          else if (g3656 == 1) a3655.f4061 = u1753(parse);           a3655.condition = u1753(parse);     }     else if (w4186 == 0)     {         a3655.condition = u1753(parse);     }      parse.r3619--;       n1756(parse, a3655);     return a3655; }    function f1621(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const feedback = new z1838(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(feedback, parse, ignore, w4186);       if (ignore)      {         n1756(parse, feedback);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         feedback.input = u1753(parse);      feedback.feedback = u1753(parse);       parse.r3619--;       n1756(parse, feedback);     return feedback; }    function t1622(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const repeat = new v1833(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(repeat, parse, ignore, w4186);       if (ignore)      {         n1756(parse, repeat);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         repeat.input = u1753(parse);      repeat. count   = u1753(parse);     repeat.j3654   = u1753(parse);          repeat. loop    = u1753(parse);         parse.r3619--;       n1756(parse, repeat);     return repeat; }    function z1623(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cache = new i1819(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(cache, parse, ignore, w4186);       if (ignore)      {         n1756(parse, cache);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         cache.input = u1753(parse);       parse.r3619--;       n1756(parse, cache);     return cache; }    function i1624(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const freeze = new r1828(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(freeze, parse, ignore, w4186);       if (ignore)      {         n1756(parse, freeze);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         freeze.input = u1753(parse);       parse.r3619--;       n1756(parse, freeze);     return freeze; }    function y1625(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const timer = new i1840(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(timer, parse, ignore, w4186);       if (ignore)      {         n1756(parse, timer);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         timer.input = u1753(parse);       timer.interval = u1753(parse);     timer.j3654   = u1753(parse);     timer. loop    = u1753(parse);         parse.r3619--;       n1756(parse, timer);     return timer; }    function a1626(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const name = new x1842(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(name, parse, ignore, w4186);       if (ignore)      {         n1756(parse, name);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         name.input = u1753(parse);      name.name = u1753(parse);       parse.r3619--;       n1756(parse, name);     return name; }    function genParseObjectName(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const name = new GObjectName(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(name, parse, ignore, w4186);       if (ignore)      {         n1756(parse, name);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         name.input = u1753(parse);      name.name = u1753(parse);       parse.r3619--;       n1756(parse, name);     return name; }    function t1627(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cmnt = new r2001(nodeId, options);           if (parse.settings.j2527)          s2086(cmnt, parse, ignore);       if (ignore)      {         n1756(parse, cmnt);         return parse.x4220.find(n => n.nodeId == nodeId);     }       n1756(parse, cmnt);     return cmnt; }    function q1628(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cmnt = new v2002(nodeId, options);           if (parse.settings.j2527)          s2086(cmnt, parse, ignore);       if (ignore)      {         n1756(parse, cmnt);         return parse.x4220.find(n => n.nodeId == nodeId);     }       n1756(parse, cmnt);     return cmnt; }    function b1629(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const panel = new d2009(nodeId, options);           if (parse.settings.j2527)          s2086(panel, parse, ignore);       if (ignore)      {         n1756(parse, panel);         return parse.x4220.find(n => n.nodeId == nodeId);     }       n1756(parse, panel);     return panel; }


function y1630(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const group = new q1845(nodeId, options);       let m3653 = -1;          if (!ignore)     {         m3653 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(group, parse, ignore);       if (ignore)     {         n1756(parse, group);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;             for (let i = 0; i < m3653; i++)     {         group.b3063.push(parse.move());         group.params  .push(u1753(parse));     }       parse.r3619--;       n1756(parse, group);     return group; }    function o1631(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const param = new z1846(nodeId, options);       let w4186  = -1;     let n3652 = -1;          if (!ignore)     {         w4186  = parseInt(parse.move());         n3652 = parseInt(parse.move());          s946(w4186  == 0 || w4186  == 1,  'nInputs must be [0, 1]');         s946(n3652 == 0 || n3652 == 1, 'nOutputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(param, parse, ignore);       if (ignore)      {         n1756(parse, param);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)     {         param.input    = u1753(parse);         param.dataType = parse.move();     }     else if (n3652 == 1)         param.dataType = parse.move();       parse.r3619--;       n1756(parse, param);     return param; } 


function f1632(parse) {     parse.pos++;       const fill = parse.move();      if (parse.settings.j2527)          w2093(k1173, fill, parse);      return z3651(fill)[0]; }    function h1633(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const fill = new k1851(nodeId, options);      fill.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(fill, parse, ignore, w4186);       if (ignore)     {         n1756(parse, fill);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         fill.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['color', 'opacity', 'blend'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'color':   fill.color   = u1753(parse); break;         case 'opacity': fill.opacity = u1753(parse); break;         case 'blend':   fill.blend   = u1753(parse); break;         }     }           parse.r3619--;       n1756(parse, fill);     return fill; }    function c1634(parse) {     const fill = u1753(parse);       if (t1172.includes(fill.type))         fill.options.opacity = u1753(parse);      return fill; }    function c1635(parse) {     parse.pos++;       const grad = parse.move();      if (parse.settings.j2527)          w2093(f1182, grad, parse);      return z3650(grad)[0]; }    function g1636(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const grad = new t1852(nodeId, options);      grad.o3236 = options.o3236;       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(grad, parse, ignore, w4186);       if (ignore)     {         n1756(parse, grad);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       for (let i = 0; i < w4186; i++)         grad.inputs.push(u1753(parse));       grad.s3661 = u1753(parse);      grad.x        = u1753(parse);      grad.y        = u1753(parse);      grad.size     = u1753(parse);      grad.angle    = u1753(parse);      grad.aspect   = u1753(parse);      grad.skew     = u1753(parse);      grad.blend    = u1753(parse);            parse.r3619--;       n1756(parse, grad);     return grad; }                function x1637(parse) {     parse.pos++;       const stop = parse.move();      if (parse.settings.j2527)          w2093(q1179, stop, parse);      return m2839(stop)[0]; }    function k1638(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const stop = new n1848(nodeId, options);      stop.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(stop, parse, ignore, w4186);       if (ignore)     {         n1756(parse, stop);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         stop.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['fill', 'position'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'fill':     stop.fill     = u1753(parse); break;         case 'position': stop.position = u1753(parse); break;         }     }               parse.r3619--;       n1756(parse, stop);     return stop; }    function i1639(parse) {     parse.pos++;       const stroke = parse.move();      if (parse.settings.j2527)          w2093(x1176, stroke, parse);      return e3807(stroke)[0]; }    function e1640(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const stroke = new c1858(nodeId, options);      stroke.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(stroke, parse, ignore, w4186);       if (ignore)     {         n1756(parse, stroke);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         stroke.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['fill', 'weight', 'fit', 'join', 'miter', 'cap', 'dashes'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'fill':   stroke.b3649 = u1753(parse); stroke.fills = stroke.b3649; break;         case 'weight': stroke.weight = u1753(parse); break;         case 'fit':    stroke.fit    = u1753(parse); break;         case 'join':   stroke.join   = u1753(parse); break;         case 'miter':  stroke.miter  = u1753(parse); break;         case 'cap':    stroke.cap    = u1753(parse); break;         case 'dashes': stroke.dashes = u1753(parse); break;         }     }               parse.r3619--;       n1756(parse, stroke);     return stroke; }    function e1641(parse) {     const stroke = u1753(parse);       if (    q1175.includes(stroke.type)         || t1172.includes(stroke.type))         stroke.data.weight = u1753(parse);      return stroke; }    function h1642(parse) {     parse.pos++;       const corners = parse.move();      if (parse.settings.j2527)          w2093(t1185, corners, parse);      return y3813(corners)[0]; }    function w1643(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const corners = new g1857(nodeId, options);      corners.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(corners, parse, ignore, w4186);       if (ignore)     {         n1756(parse, corners);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         corners.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['tl', 'tr', 'bl', 'br'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'tl': corners.tl = u1753(parse); break;         case 'tr': corners.tr = u1753(parse); break;         case 'bl': corners.bl = u1753(parse); break;         case 'br': corners.br = u1753(parse); break;         }     }               parse.r3619--;       n1756(parse, corners);     return corners; }    function r1644(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.j2527)          w2093(z1188, shadow, parse);      return t3808(shadow)[0]; }    function b1645(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const shadow = new e1850(nodeId, options);      shadow.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(shadow, parse, ignore, w4186);       if (ignore)     {         n1756(parse, shadow);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         shadow.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['x', 'y', 'blur', 'spread', 'fill', 'blend', 'behind'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'x':      shadow.x      = u1753(parse); break;         case 'y':      shadow.y      = u1753(parse); break;         case 'blur':   shadow.blur   = u1753(parse); break;         case 'spread': shadow.spread = u1753(parse); break;         case 'fill':   shadow.fill   = u1753(parse); break;         case 'blend':  shadow.blend  = u1753(parse); break;         case 'behind': shadow.behind = u1753(parse); break;         }     }               parse.r3619--;       n1756(parse, shadow);     return shadow; }    function d1646(parse) {     parse.pos++;       const shadow = parse.move();      if (parse.settings.j2527)          w2093(r1191, shadow, parse);      return j3809(shadow)[0]; }    function a1647(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const shadow = new f1853(nodeId, options);      shadow.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(shadow, parse, ignore, w4186);       if (ignore)     {         n1756(parse, shadow);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         shadow.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['x', 'y', 'blur', 'spread', 'fill', 'blend'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'x':      shadow.x      = u1753(parse); break;         case 'y':      shadow.y      = u1753(parse); break;         case 'blur':   shadow.blur   = u1753(parse); break;         case 'spread': shadow.spread = u1753(parse); break;         case 'fill':   shadow.fill   = u1753(parse); break;         case 'blend':  shadow.blend  = u1753(parse); break;         }     }               parse.r3619--;       n1756(parse, shadow);     return shadow; }    function l1648(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.j2527)          w2093(i1194, blur, parse);      return q3810(blur)[0]; }    function e1649(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const blur = new h1855(nodeId, options);      blur.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(blur, parse, ignore, w4186);       if (ignore)     {         n1756(parse, blur);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         blur.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['radius'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'radius': blur.radius = u1753(parse); break;         }     }               parse.r3619--;       n1756(parse, blur);     return blur; }    function f1650(parse) {     parse.pos++;       const blur = parse.move();      if (parse.settings.j2527)          w2093(t1197, blur, parse);      return a3681(blur)[0]; }    function y1651(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const blur = new g1847(nodeId, options);      blur.o3236 = options.o3236;       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(blur, parse, ignore, w4186);       if (ignore)     {         n1756(parse, blur);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       let b3063;      if (w4186 == 1)     {         blur.input = u1753(parse);         b3063 = parse.move().split(',');     }     else         b3063 = ['radius'];       parse.a1754 = false;      for (const id of b3063)     {         switch (id)         {         case 'radius': blur.radius = u1753(parse); break;         }     }               parse.r3619--;       n1756(parse, blur);     return blur; }    function o1652(parse) {     parse.pos++;       const layer = parse.move();      if (parse.settings.j2527)          w2093(d1203, layer, parse);      return e3682(layer)[0]; }    function s1653(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const layer = new t1854(nodeId, options);       if (parse.settings.j2527)          s2086(layer, parse, ignore);       if (ignore)     {         n1756(parse, layer);         return parse.x4220.find(n => n.nodeId == nodeId);     }       layer.opacity = u1753(parse);     layer.blend   = u1753(parse);               n1756(parse, layer);     return layer; }    function d1654(parse) {     parse.pos++;       const mask = parse.move();      if (parse.settings.j2527)          w2093(x1200, mask, parse);      return p3683(mask)[0]; }    function l1655(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const mask = new r1856(nodeId, options);       if (parse.settings.j2527)          s2086(mask, parse, ignore);       if (ignore)     {         n1756(parse, mask);         return parse.x4220.find(n => n.nodeId == nodeId);     }       mask.maskType = u1753(parse);               n1756(parse, mask);     return mask; }


function n1657(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.j2527)          w2093(g1086, val, parse);      return val.indexOf(',') >= 0          ? d2822      (val)[0]          : u3811(val)[0]; }    function i1658(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const num = new y1898(nodeId, options);           if (parse.settings.j2527)          s2086(num, parse, ignore);       if (ignore)      {         n1756(parse, num);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;     parse.a1754 = false;       if (parse.next == g1086) num.value = u1753(parse);     else                            num.input = u1753(parse);       parse.r3619--;       n1756(parse, num);     return num; }    function z1659(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const h3648 = new a1889(nodeId, options);       if (parse.settings.j2527)          s2086(h3648, parse, ignore);       if (ignore)      {         n1756(parse, h3648);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       h3648.constant = u1753(parse);       parse.r3619--;       n1756(parse, h3648);     return h3648; }    function p1660(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const dateTime = new b1891(nodeId, options);       if (parse.settings.j2527)          s2086(dateTime, parse, ignore);       if (ignore)      {         n1756(parse, dateTime);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       dateTime.seconds   = u1753(parse);     dateTime.minutes   = u1753(parse);     dateTime.hours     = u1753(parse);     dateTime.dayOfWeek = u1753(parse);     dateTime.date      = u1753(parse);     dateTime.month     = u1753(parse);     dateTime.year      = u1753(parse);       parse.r3619--;       n1756(parse, dateTime);     return dateTime; }    function o1661(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const sign = new f1905(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(sign, parse, ignore);       if (ignore)      {         n1756(parse, sign);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         sign.input = u1753(parse);           parse.r3619--;       n1756(parse, sign);     return sign; }    function a1662(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const abs = new c1886(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(abs, parse, ignore);       if (ignore)      {         n1756(parse, abs);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         abs.input = u1753(parse);           parse.r3619--;       n1756(parse, abs);     return abs; }    function k1663(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const round = new l1903(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(round, parse, ignore, w4186);       if (ignore)      {         n1756(parse, round);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         round.input = u1753(parse);      round.type     = u1753(parse);     round.decimals = u1753(parse);           parse.r3619--;       n1756(parse, round);     return round; }    function b1664(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const p3647 = new y1906(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(p3647, parse, ignore, w4186);       if (ignore)      {         n1756(parse, p3647);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         p3647.input = u1753(parse);      p3647.operand   = u1753(parse);     p3647.operation = u1753(parse);           parse.r3619--;       n1756(parse, p3647);     return p3647; }    function v1665(parse) {     const [type, nodeId, options, ignore] = v1755(parse);       const s3646 = new m1895(nodeId, options);           let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(s3646, parse, ignore, w4186);       if (ignore)      {         n1756(parse, s3646);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      for (let i = 0; i < w4186; i++)         s3646.inputs.push(u1753(parse));       s3646.operation = u1753(parse);       parse.r3619--;               n1756(parse, s3646);     return s3646; }    function j1666(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const limits = new v1894(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(limits, parse, ignore, w4186);       if (ignore)      {         n1756(parse, limits);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         limits.input = u1753(parse);      limits.min = u1753(parse);     limits.max = u1753(parse);           parse.r3619--;       n1756(parse, limits);     return limits; }    function w1667(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const curve = new h1899(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(curve, parse, ignore, w4186);       if (ignore)      {         n1756(parse, curve);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         curve.input = u1753(parse);      curve.min    = u1753(parse);     curve.max    = u1753(parse);     curve.power  = u1753(parse);     curve.bias   = u1753(parse);     curve.spread = u1753(parse);           parse.r3619--;       n1756(parse, curve);     return curve; }    function e1668(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const d3645 = new x1896(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(d3645, parse, ignore, w4186);       if (ignore)      {         n1756(parse, d3645);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         d3645.input = u1753(parse);      d3645._value = u1753(parse);      parse.r3619--;       n1756(parse, d3645);     return d3645; }    function i1669(parse, n1656) {     const [type, nodeId, options, ignore] = v1755(parse);       const math = n1656(nodeId, options);           let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(math, parse, ignore, w4186);       if (ignore)      {         n1756(parse, math);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      for (let i = 0; i < w4186; i++)         math.inputs.push(u1753(parse));       math.operation = u1753(parse);       parse.r3619--;               n1756(parse, math);     return math; }    function b1670(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const smath = new b1867(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(smath, parse, ignore, w4186);       if (ignore)      {         n1756(parse, smath);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         smath.input = u1753(parse);      smath.operation = u1753(parse);     smath.operand   = u1753(parse);     smath.invert    = u1753(parse);           parse.r3619--;       n1756(parse, smath);     return smath; }    function j1671(parse, n1656) {     const [type, nodeId, options, ignore] = v1755(parse);       const arith = n1656(nodeId, options);       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(arith, parse, ignore, w4186);       if (ignore)      {         n1756(parse, arith);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      for (let i = 0; i < w4186; i++)         arith.inputs.push(u1753(parse));      parse.r3619--;               n1756(parse, arith);     return arith; }    function o1672(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const convert = new g1890(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(convert, parse, ignore, w4186);       if (ignore)      {         n1756(parse, convert);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         convert.input = u1753(parse);      convert.from = u1753(parse);           parse.r3619--;       n1756(parse, convert);     return convert; }    function o1673(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const define = new f1892(nodeId, options);       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(define, parse, ignore, w4186);       if (ignore)      {         n1756(parse, define);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;           for (let i = 0; i < w4186; i++)         define.inputs.push(u1753(parse));       parse.r3619--;       n1756(parse, define);     return define; }    function l1674(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const dist = new x1902(nodeId, options);       if (parse.settings.j2527)          s2086(dist, parse, ignore);       if (ignore)      {         n1756(parse, dist);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       dist.from   = u1753(parse);     dist.start  = u1753(parse);     dist.end    = u1753(parse);     dist.bias   = u1753(parse);     dist.spread = u1753(parse);       parse.r3619--;       n1756(parse, dist);     return dist; }    function p1675(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const wave = new g1908(nodeId, options);       if (parse.settings.j2527)          s2086(wave, parse, ignore);       if (ignore)      {         n1756(parse, wave);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       wave.shape     = u1753(parse);     wave.base      = u1753(parse);     wave.amplitude = u1753(parse);     wave.frequency = u1753(parse);     wave.offset    = u1753(parse);     wave.bias      = u1753(parse);       parse.r3619--;       n1756(parse, wave);     return wave; }    function x1676(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const seq = new s1904(nodeId, options);       if (parse.settings.j2527)          s2086(seq, parse, ignore);       if (ignore)      {         n1756(parse, seq);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       seq.start    = u1753(parse);     seq.multiply = u1753(parse);     seq.add      = u1753(parse);     seq.end      = u1753(parse);       parse.r3619--;       n1756(parse, seq);     return seq; }    function x1677(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const rnd = new y1901(nodeId, options);       if (parse.settings.j2527)          s2086(rnd, parse, ignore);       if (ignore)      {         n1756(parse, rnd);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       rnd.seed        = u1753(parse);     rnd.min         = u1753(parse);     rnd.max         = u1753(parse);     rnd.bias        = u1753(parse);     rnd.spread      = u1753(parse);     rnd.unique      = u1753(parse);       parse.r3619--;       n1756(parse, rnd);     return rnd; }    function i1678(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const noise = new l1897(nodeId, options);       if (parse.settings.j2527)          s2086(noise, parse, ignore);       if (ignore)      {         n1756(parse, noise);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       noise.seed        = u1753(parse);     noise.min         = u1753(parse);     noise.max         = u1753(parse);     noise.scale       = u1753(parse);     noise.offset      = u1753(parse);     noise.interpolate = u1753(parse);     noise.detail      = u1753(parse);       parse.r3619--;       n1756(parse, noise);     return noise; }    function g1679(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const prob = new u1900(nodeId, options);       if (parse.settings.j2527)          s2086(prob, parse, ignore);       if (ignore)      {         n1756(parse, prob);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       prob.seed   = u1753(parse);     prob.chance = u1753(parse);       parse.r3619--;       n1756(parse, prob);     return prob; }    function v1680(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const accum = new i1887(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(accum, parse, ignore, w4186);       if (ignore)      {         n1756(parse, accum);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         accum.input = u1753(parse);      accum.when = u1753(parse);               parse.r3619--;       n1756(parse, accum);     return accum; }    function a1681(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const n1029 = new u1893(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(n1029, parse, ignore, w4186);       if (ignore)      {         n1756(parse, n1029);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      if (w4186 == 2)     {         n1029.p4060 = u1753(parse);         n1029.f4061 = u1753(parse);         n1029.amount = u1753(parse);     }     else if (w4186 == 1)     {         n1029.p4060 = u1753(parse);          n1029.amount = u1753(parse);     }     else if (w4186 == 0)     {         n1029.amount = u1753(parse);     }      parse.r3619--;       n1756(parse, n1029);     return n1029; }    function i1682(parse) {     const [type, nodeId, options, ignore] = v1755(parse);       const bool = new l1870(nodeId, options);           let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(bool, parse, ignore, w4186);       if (ignore)      {         n1756(parse, bool);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      for (let i = 0; i < w4186; i++)         bool.inputs.push(u1753(parse));       bool.operation = u1753(parse);       parse.r3619--;               n1756(parse, bool);     return bool; }    function m1683(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cond = new z1874(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(cond, parse, ignore, w4186);       if (ignore)      {         n1756(parse, cond);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         cond.input = u1753(parse);             cond.operation = u1753(parse);     cond.operand   = u1753(parse);       parse.r3619--;       n1756(parse, cond);     return cond; }    function v1684(parse, n1656) {     const [type, nodeId, options, ignore] = v1755(parse);       const cond = n1656(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)         s2086(cond, parse, ignore, w4186);        if (ignore)      {         n1756(parse, cond);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;      if (w4186 == 2)     {         cond.p4060 = u1753(parse);         cond.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         cond.p4060 = u1753(parse);      }      parse.r3619--;       n1756(parse, cond);     return cond; }    function a1685(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const trig = new m1885(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(trig, parse, ignore, w4186);       if (ignore)      {         n1756(parse, trig);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         trig.input = u1753(parse);      trig.function = u1753(parse);      parse.r3619--;       n1756(parse, trig);     return trig; }    function a1686(parse, n1656) {     const [type, nodeId, options, ignore] = v1755(parse);       const trig = n1656(nodeId, options);       let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)         s2086(trig, parse, ignore, w4186);        if (ignore)      {         n1756(parse, trig);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         trig.input = u1753(parse);       parse.r3619--;       n1756(parse, trig);     return trig; }    function n1687(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const atan2 = new y1881(nodeId, options);              if (parse.settings.j2527)          s2086(atan2, parse, ignore);       if (ignore)      {         n1756(parse, atan2);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       atan2.x = u1753(parse);     atan2.y = u1753(parse);           parse.r3619--;       n1756(parse, atan2);     return atan2; }    function e1688(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const solve = new u1907(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(solve, parse, ignore, w4186);       if (ignore)      {         n1756(parse, solve);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         solve.input = u1753(parse);      solve.current = u1753(parse);     solve.target  = u1753(parse);           parse.r3619--;       n1756(parse, solve);     return solve; }    function q1689(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const anim = new c1888(nodeId, options);       if (parse.settings.j2527)          s2086(anim, parse);       if (ignore)      {         n1756(parse, anim);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       anim.from   = u1753(parse);     anim.to     = u1753(parse);     anim.curve  = u1753(parse);     anim.repeat = u1753(parse);     anim.length = u1753(parse);     anim.time   = u1753(parse);       parse.r3619--;       n1756(parse, anim);     return anim; } 


function p1690(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const rect = new z1930(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(rect, parse, ignore);       if (ignore)      {         n1756(parse, rect);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         rect.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'x':      rect.x      = u1753(parse); break;         case 'y':      rect.y      = u1753(parse); break;         case 'width':  rect.width  = u1753(parse); break;         case 'height': rect.height = u1753(parse); break;         case 'round':  rect.round  = u1753(parse); break;         case 'props':  rect.props  = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, rect);     return rect; }    function s1691(parse) {     const [, nodeId, options, ignore] = v1755(parse);         const line = new y1922(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(line, parse, ignore);       if (ignore)      {         n1756(parse, line);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         line.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'x':     line.x     = u1753(parse); break;         case 'y':     line.y     = u1753(parse); break;         case 'width': line.width = u1753(parse); break;         case 'props': line.props = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, line);     return line; }    function o1692(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const ellipse = new t1918(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(ellipse, parse, ignore);       if (ignore)      {         n1756(parse, ellipse);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         ellipse.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'position': ellipse.position = u1753(parse); break;         case 'x':        ellipse.x        = u1753(parse); break;         case 'y':        ellipse.y        = u1753(parse); break;         case 'width':    ellipse.width    = u1753(parse); break;         case 'height':   ellipse.height   = u1753(parse); break;         case 'round':    ellipse.round    = u1753(parse); break;         case 'from':     ellipse.from     = u1753(parse); break;         case 'to':       ellipse.to       = u1753(parse); break;         case 'inner':    ellipse.inner    = u1753(parse); break;         case 'props':    ellipse.props    = u1753(parse); break;         }     }               parse.a1754 = false;     parse.r3619--;       n1756(parse, ellipse);     return ellipse; }    function k1693(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const trapeze = new h1941(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(trapeze, parse, ignore);       if (ignore)      {         n1756(parse, trapeze);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         trapeze.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'x':      trapeze.x      = u1753(parse); break;         case 'y':      trapeze.y      = u1753(parse); break;         case 'width':  trapeze.width  = u1753(parse); break;         case 'height': trapeze.height = u1753(parse); break;         case 'round':  trapeze.round  = u1753(parse); break;         case 'bias':   trapeze.bias   = u1753(parse); break;         case 'props':  trapeze.props  = u1753(parse); break;         }     }               parse.a1754 = false;     parse.r3619--;       n1756(parse, trapeze);     return trapeze; }    function s1694(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const poly = new m1929(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(poly, parse, ignore);       if (ignore)      {         n1756(parse, poly);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         poly.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'position': poly.position = u1753(parse); break;         case 'x':        poly.x        = u1753(parse); break;         case 'y':        poly.y        = u1753(parse); break;         case 'width':    poly.width    = u1753(parse); break;         case 'height':   poly.height   = u1753(parse); break;         case 'round':    poly.round    = u1753(parse); break;         case 'corners':  poly.corners  = u1753(parse); break;         case 'props':    poly.props    = u1753(parse); break;         }     }               parse.a1754 = false;     parse.r3619--;       n1756(parse, poly);     return poly; }    function q1695(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const star = new n1939(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(star, parse, ignore);       if (ignore)      {         n1756(parse, star);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         star.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'position': star.position = u1753(parse); break;         case 'x':        star.x        = u1753(parse); break;         case 'y':        star.y        = u1753(parse); break;         case 'width':    star.width    = u1753(parse); break;         case 'height':   star.height   = u1753(parse); break;         case 'round':    star.round    = u1753(parse); break;         case 'points':   star.points   = u1753(parse); break;         case 'convex':   star.convex   = u1753(parse); break;         case 'props':    star.props    = u1753(parse); break;         }     }               parse.a1754 = false;     parse.r3619--;       n1756(parse, star);     return star; }    function e1696(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const text = new o1940(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(text, parse, ignore);       if (ignore)      {         n1756(parse, text);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         text.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {                case 'text':          text.text          = u1753(parse); break;         case 'x':             text.x             = u1753(parse); break;         case 'y':             text.y             = u1753(parse); break;         case 'width':         text.width         = u1753(parse); break;         case 'height':        text.height        = u1753(parse); break;         case 'font':          text.font          = u1753(parse); break;         case 'size':          text.size          = u1753(parse); break;         case 'style':         text.style         = u1753(parse); break;         case 'props':         text.props         = u1753(parse); break;         case 'alignH':        text.alignH        = u1753(parse); break;         case 'alignV':        text.alignV        = u1753(parse); break;         case 'lineHeight':    text.lineHeight    = u1753(parse); break;         case 'letterSpacing': text.letterSpacing = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, text);     return text; }    function x1697(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.j2527)          w2093(e1231, point, parse);      return a3803(point)[0]; }    function u1698(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const point = new u1926(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(point, parse, ignore);       if (ignore)      {         n1756(parse, point);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         point.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'x': point.x = u1753(parse); break;         case 'y': point.y = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, point);     return point; }    function v1699(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const corner = new s1927(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(corner, parse, ignore);       if (ignore)      {         n1756(parse, corner);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         corner.input = u1753(parse);      corner.smooth = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, corner);     return corner; }    function r1700(parse) {     parse.pos++;       const path = parse.move();      if (parse.settings.j2527)          w2093(q1235, path, parse);      return i3644(path)[0]; }    function g1701(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const path = new l1945(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(path, parse, ignore);       if (ignore)      {         n1756(parse, path);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         path.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {                case 'points':  path.points  = u1753(parse); break;         case 'closed':  path.closed  = u1753(parse); break;         case 'degree':  path.degree  = u1753(parse); break;         case 'winding': path.winding = u1753(parse); break;         case 'round':   path.round   = u1753(parse); break;         case 'props':   path.props   = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, path);     return path; }    function v1702(parse) {     parse.pos++;       const point = parse.move();      if (parse.settings.j2527)          w2093(v1238, point, parse);      return s3643(point)[0]; }    function c1703(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const point = new z1947(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(point, parse, ignore);       if (ignore)      {         n1756(parse, point);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         point.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'x':     point.x     = u1753(parse); break;         case 'y':     point.y     = u1753(parse); break;         case 'join':  point.join  = u1753(parse); break;         case 'cap':   point.cap   = u1753(parse); break;         case 'round': point.round = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, point);     return point; }    function d1704(parse) {     parse.pos++;       const edge = parse.move();      if (parse.settings.j2527)          w2093(h1241, edge, parse);      return x3641(edge)[0]; }    function w1705(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const edge = new c1942(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(edge, parse, ignore, w4186);       if (ignore)      {         n1756(parse, edge);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         edge.p4060 = u1753(parse);         edge.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         edge.p4060 = u1753(parse);      }       edge.h3639 = u1753(parse);     edge.  l3640 = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, edge);     return edge; }    function j1706(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.j2527)          w2093(h1244, region, parse);      return j3638(region)[0]; }    function z1707(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const region = new y1946(nodeId, options);       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(region, parse, ignore, w4186);       if (ignore)      {         n1756(parse, region);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       for (let i = 0; i < w4186; i++)         region.inputs.push(u1753(parse));       region.winding = u1753(parse);     region.props   = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, region);     return region; }    function g1708(parse) {     parse.pos++;       const region = parse.move();      if (parse.settings.j2527)          w2093(x1247, region, parse);      return b3637(region)[0]; }    function n1709(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const network = new a1944(nodeId, options);       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(network, parse, ignore, w4186);       if (ignore)      {         n1756(parse, network);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       for (let i = 0; i < w4186; i++)         network.inputs.push(u1753(parse));      network.props = u1753(parse);       parse.r3619--;        n1756(parse, network);     return network; }    function o1710(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const bool = new v1909(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(bool, parse, ignore);       if (ignore)      {         n1756(parse, bool);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         bool.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'children':  bool.children  = u1753(parse); break;         case 'operation': bool.operation = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, bool);     return bool; }    function p1711(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const group = new r1937(nodeId, options);       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(group, parse, ignore, w4186);       if (ignore)      {         n1756(parse, group);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       for (let i = 0; i < w4186; i++)         group.inputs.push(u1753(parse));       parse.r3619--;       n1756(parse, group);     return group; }    function e1712(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const frame = new v1919(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(frame, parse, ignore);       if (ignore)      {         n1756(parse, frame);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         frame.input = u1753(parse);       const l3642 = j1758(parse);      for (let i = 0; i < l3642; i++)     {         const e2963 = b1760(parse);          parse.a1754 = true;          switch (e2963)         {         case 'x':        frame.x        = u1753(parse); break;         case 'y':        frame.y        = u1753(parse); break;         case 'width':    frame.width    = u1753(parse); break;         case 'height':   frame.height   = u1753(parse); break;                  case 'round':    frame.round    = u1753(parse); break;         case 'children': frame.children = u1753(parse); break;         case 'props':    frame.props    = u1753(parse); break;         }     }       parse.a1754 = false;     parse.r3619--;       n1756(parse, frame);     return frame; }    function c1713(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const move = new w1924(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(move, parse, ignore);       if (ignore)      {         n1756(parse, move);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         move.input = u1753(parse);      move.t3636    = u1753(parse);     move.x           = u1753(parse);     move.y           = u1753(parse);     move.affectSpace = u1753(parse);     move.s3632  = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, move);     return move; }    function e1714(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const rotate = new w1933(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(rotate, parse, ignore);       if (ignore)      {         n1756(parse, rotate);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         rotate.input = u1753(parse);      rotate.angle       = u1753(parse);     rotate.s3632  = u1753(parse);     rotate.affectSpace = u1753(parse);           parse.a1754 = false;     parse.r3619--;       n1756(parse, rotate);     return rotate; }    function p1715(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const scale = new b1934(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(scale, parse, ignore);       if (ignore)      {         n1756(parse, scale);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         scale.input = u1753(parse);      scale.q884        = u1753(parse);     scale.z885        = u1753(parse);     scale.affectCorners = u1753(parse);     scale.affectStyle   = u1753(parse);     scale.s3632    = u1753(parse);     scale.affectSpace   = u1753(parse);           parse.a1754 = false;     parse.r3619--;       n1756(parse, scale);     return scale; }    function g1716(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const skew = new u1938(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(skew, parse, ignore);       if (ignore)      {         n1756(parse, skew);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         skew.input = u1753(parse);      skew.m886       = u1753(parse);     skew.a887       = u1753(parse);     skew.s3632  = u1753(parse);     skew.affectSpace = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, skew);     return skew; }    function n1717(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const center = new t1916(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(center, parse, ignore);       if (ignore)      {         n1756(parse, center);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         center.input = u1753(parse);      center.centerX    = u1753(parse);     center.centerY    = u1753(parse);     center.units      = u1753(parse);     center.s3632 = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, center);     return center; }    function o1718(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const reset = new z1932(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(reset, parse, ignore);       if (ignore)      {         n1756(parse, reset);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         reset.input = u1753(parse);      reset.s3632 = u1753(parse);       parse.r3619--;       n1756(parse, reset);     return reset; }    function a1719(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const measure = new i1923(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(measure, parse, ignore, w4186);       if (ignore)      {         n1756(parse, measure);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;           if (w4186 == 2)     {         measure.p4060 = u1753(parse);         measure.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         measure.p4060 = u1753(parse);      }       parse.r3619--;       n1756(parse, measure);     return measure; }    function v1720(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const len = new g1943(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(len, parse, ignore, w4186);       if (ignore)      {         n1756(parse, len);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;           if (w4186 == 1)         len.input = u1753(parse);      len.length = u1753(parse);       parse.r3619--;       n1756(parse, len);     return len; }    function w1721(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const center = new o1917(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 3, 'nInputs must be [0, 3]');     }           if (parse.settings.j2527)          s2086(center, parse, ignore, w4186);       if (ignore)      {         n1756(parse, center);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;           if (w4186 == 3)     {         center.p4060 = u1753(parse);         center.f4061 = u1753(parse);         center.d4062 = u1753(parse);     }     else if (w4186 == 2)     {         center.p4060 = u1753(parse);         center.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         center.p4060 = u1753(parse);     }       parse.r3619--;       n1756(parse, center);     return center; }    function s1722(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const inter = new n1921(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 4, 'nInputs must be [0, 4]');     }           if (parse.settings.j2527)          s2086(inter, parse, ignore, w4186);       if (ignore)      {         n1756(parse, inter);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;           if (w4186 == 4)     {         inter.p4060 = u1753(parse);         inter.f4061 = u1753(parse);         inter.d4062 = u1753(parse);         inter.a4063 = u1753(parse);     }     else if (w4186 == 3)     {         inter.p4060 = u1753(parse);         inter.f4061 = u1753(parse);         inter.d4062 = u1753(parse);     }     else if (w4186 == 2)     {         inter.p4060 = u1753(parse);         inter.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         inter.p4060 = u1753(parse);     }       inter.segment = u1753(parse);       parse.r3619--;       n1756(parse, inter);     return inter; }    function n1723(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const n1029 = new f1920(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(n1029, parse, ignore, w4186);       if (ignore)      {         n1756(parse, n1029);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         n1029.p4060 = u1753(parse);         n1029.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         n1029.p4060 = u1753(parse);      }       n1029.amount     = u1753(parse);     n1029.transform  = u1753(parse);     n1029.s3632 = u1753(parse);       parse.r3619--;       n1756(parse, n1029);     return n1029; }    function t1724(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const pop = new d1928(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(pop, parse, ignore, w4186);       if (ignore)      {         n1756(parse, pop);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         pop.p4060 = u1753(parse);         pop.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         pop.p4060 = u1753(parse);      }       pop.measure    = u1753(parse);     pop.amount     = u1753(parse);     pop.transform  = u1753(parse);     pop.s3632 = u1753(parse);       parse.r3619--;       n1756(parse, pop);     return pop; }    function i1725(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const place = new k1925(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(place, parse, ignore);       if (ignore)      {         n1756(parse, place);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         place.input = u1753(parse);      place.position   = u1753(parse);     place.transform  = u1753(parse);     place.s3632 = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, place);     return place; }    function u1726(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const apply = new h1915(nodeId, options);       let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(apply, parse, ignore);       if (ignore)      {         n1756(parse, apply);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         apply.input = u1753(parse);      apply.props   = u1753(parse);     apply.replace = u1753(parse);       parse.a1754 = false;     parse.r3619--;       n1756(parse, apply);     return apply; }    function e1727(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const render = new w1931(nodeId, options);       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(render, parse, ignore, w4186);       if (ignore)      {         n1756(parse, render);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       for (let i = 0; i < w4186; i++)         render.inputs.push(u1753(parse));      render.retain   = u1753(parse);     render.finalize = u1753(parse);       parse.r3619--;       n1756(parse, render);     return render; }


              function v1728(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const style = new e1849(nodeId, options);      style.existing = options.existing;       if (parse.settings.j2527)          s2086(style, parse, ignore);       if (ignore)      {         n1756(parse, style);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;     parse.a1754 = false;       style.id       = parse.move();     style.name     = options.nodeName;          style.w2790 = u1753(parse);           parse.r3619--;           style.linked = style.id != NULL;       n1756(parse, style);     return style; }                             


 function v1729(parse) {     parse.pos++;       const val = parse.move();      if (parse.settings.j2527)          w2093(r1138, val, parse);      return n2837(val)[0]; }    function l1730(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const text = new d1953(nodeId, options);           if (parse.settings.j2527)          s2086(text, parse, ignore);       if (ignore)      {         n1756(parse, text);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;     parse.a1754 = false;       if (parse.next == r1138) text.value = u1753(parse);     else                          text.input = u1753(parse);       parse.r3619--;       n1756(parse, text);     return text; }    function a1731(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const len = new f1961(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(len, parse, ignore, w4186);       if (ignore)      {         n1756(parse, len);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         len.input = u1753(parse);           parse.r3619--;       n1756(parse, len);     return len; }    function c1732(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const trim = new e1968(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(trim, parse, ignore, w4186);       if (ignore)      {         n1756(parse, trim);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         trim.input = u1753(parse);      trim.start = u1753(parse);     trim.end   = u1753(parse);           parse.r3619--;       n1756(parse, trim);     return trim; }    function n1733(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const sub = new d1965(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(sub, parse, ignore, w4186);       if (ignore)      {         n1756(parse, sub);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         sub.input = u1753(parse);      sub.start = u1753(parse);     sub.end   = u1753(parse);           parse.r3619--;       n1756(parse, sub);     return sub; }    function p1734(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cont = new a1956(nodeId, options);          let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(cont, parse, ignore, w4186);       if (ignore)      {         n1756(parse, cont);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         cont.p4060 = u1753(parse);         cont.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         cont.p4060 = u1753(parse);      }             parse.r3619--;       n1756(parse, cont);     return cont; }    function p1735(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const o3631 = new b1954(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(o3631, parse, ignore, w4186);       if (ignore)      {         n1756(parse, o3631);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         o3631.input = u1753(parse);      o3631.case = u1753(parse);           parse.r3619--;       n1756(parse, o3631);     return o3631; }    function e1736(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const replace = new t1963(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(replace, parse, ignore, w4186);       if (ignore)      {         n1756(parse, replace);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         replace.input = u1753(parse);      replace.what  = u1753(parse);     replace.with  = u1753(parse);     replace.regex = u1753(parse);           parse.r3619--;       n1756(parse, replace);     return replace; }                                                                     function f1737(parse, n1656) {     const [type, nodeId, options, ignore] = v1755(parse);       const join = new l1960(nodeId, options);       let w4186 = 0;          if (!ignore)         w4186 = parseInt(parse.move());       if (parse.settings.j2527)          s2086(join, parse, ignore, w4186);       if (ignore)      {         n1756(parse, join);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       for (let i = 0; i < w4186; i++)         join.inputs.push(u1753(parse));       join.with = u1753(parse);           parse.r3619--;               n1756(parse, join);     return join; }    function j1738(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const pad = new q1962(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(pad, parse, ignore, w4186);       if (ignore)      {         n1756(parse, pad);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         pad.input = u1753(parse);      pad.l3627   = u1753(parse);     pad.r3628 = u1753(parse);     pad.b3629     = u1753(parse);     pad.d3630   = u1753(parse);           parse.r3619--;       n1756(parse, pad);     return pad; }    function z1739(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const cmp = new h1955(nodeId, options);          let w4186 = -1;      if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 => 0 && w4186 <= 2, 'nInputs must be [0, 2]');     }           if (parse.settings.j2527)          s2086(cmp, parse, ignore, w4186);       if (ignore)      {         n1756(parse, cmp);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 2)     {         cmp.p4060 = u1753(parse);         cmp.f4061 = u1753(parse);     }     else if (w4186 == 1)     {         cmp.p4060 = u1753(parse);      }             cmp.operation = u1753(parse);           parse.r3619--;       n1756(parse, cmp);     return cmp; }    function r1740(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const q3626 = new n1949(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(q3626, parse, ignore, w4186);       if (ignore)      {         n1756(parse, q3626);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         q3626.input = u1753(parse);           parse.r3619--;       n1756(parse, q3626);     return q3626; }    function a1741(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const z3625 = new d1948(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(z3625, parse, ignore, w4186);       if (ignore)      {         n1756(parse, z3625);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         z3625.input = u1753(parse);           parse.r3619--;       n1756(parse, z3625);     return z3625; }    function g1742(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const index = new j1951(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(index, parse, ignore, w4186);       if (ignore)      {         n1756(parse, index);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       index.name  = u1753(parse);     index.index = u1753(parse);           parse.r3619--;       n1756(parse, index);     return index; }    function q1743(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const l3624 = new r1952(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(l3624, parse, ignore, w4186);       if (ignore)      {         n1756(parse, l3624);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         l3624.input = u1753(parse);      l3624.base      = u1753(parse);     l3624.decimals  = u1753(parse);     l3624.thousands = u1753(parse);           parse.r3619--;       n1756(parse, l3624);     return l3624; }    function c1744(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const j3623 = new t1950(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(j3623, parse, ignore, w4186);       if (ignore)      {         n1756(parse, j3623);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         j3623.input = u1753(parse);      j3623.format = u1753(parse);           parse.r3619--;       n1756(parse, j3623);     return j3623; }    function z1745(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const g3622 = new g1967(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(g3622, parse, ignore);       if (ignore)      {         n1756(parse, g3622);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         g3622.input = u1753(parse);      g3622.base      = u1753(parse);     g3622.decimals  = u1753(parse);     g3622.thousands = u1753(parse);           parse.r3619--;       n1756(parse, g3622);     return g3622; }    function o1746(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const text2col = new u1966(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }       if (parse.settings.j2527)          s2086(text2col, parse, ignore);       if (ignore)      {         n1756(parse, text2col);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         text2col.input = u1753(parse);           parse.r3619--;       n1756(parse, text2col);     return text2col; }    function m1747(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const split = new w1964(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(split, parse, ignore, w4186);       if (ignore)      {         n1756(parse, split);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         split.input = u1753(parse);      split.separator = u1753(parse);           parse.r3619--;       n1756(parse, split);     return split; }    function f1748(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const csv = new o1957(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(csv, parse, ignore, w4186);       if (ignore)      {         n1756(parse, csv);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         csv.input = u1753(parse);      csv.g3620    = u1753(parse);     csv.u3621 = u1753(parse);           parse.r3619--;       n1756(parse, csv);     return csv; }    function b3678(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const json = new GTextJson(nodeId, options);          let w4186 = -1;          if (!ignore)     {         w4186 = parseInt(parse.move());         s946(w4186 == 0 || w4186 == 1, 'nInputs must be [0, 1]');     }           if (parse.settings.j2527)          s2086(json, parse, ignore, w4186);       if (ignore)      {         n1756(parse, json);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       if (w4186 == 1)         json.input = u1753(parse);           parse.r3619--;       n1756(parse, json);     return json; }    function d1749(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const fetch = new o1958(nodeId, options);          if (parse.settings.j2527)          s2086(fetch, parse, ignore);       if (ignore)      {         n1756(parse, fetch);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       fetch.request     = u1753(parse);     fetch.q4189 = u1753(parse);           parse.r3619--;       n1756(parse, fetch);     return fetch; }    function k1750(parse) {     const [, nodeId, options, ignore] = v1755(parse);       const file = new i1959(nodeId, options);          if (parse.settings.j2527)          s2086(file, parse, ignore);       if (ignore)      {         n1756(parse, file);         return parse.x4220.find(n => n.nodeId == nodeId);     }       parse.r3619++;       file.q4189 = u1753(parse);                parse.r3619--;       n1756(parse, file);     return file; }


class q1751 {     request;     e2028;          pos;      so;      settings = {};      save;       log  = '';          r3619 = 0;      get tab() { return this.a1754 ? ' ' : (z862 + g860.repeat(Math.max(0, this.r3619))); }           a1754 = false;           a3993;     t3994;      viewportZoom;      j3611 = 0;     f3612   = 0;      scope         = [];      x4220   = [];        repeats       = [];      u3613  = false;       u3614  = [];      j2848  = [];     z3067  = [];     o3615 = [];     r3616  = [];            get next() { return this.request[this.pos]; }      get u3618()      {          return this.pos+1 < this.request.length               ? this.request[this.pos+1]              : null;     }        constructor(request, t3617, e2028, a3993, t3994, viewportZoom, settings, save)     {         this.request       = request;         this.e2028     = e2028;                    this.pos           = t3617;          this.so            = 0;                  this.a3993  = a3993;          this.t3994 = t3994;             this.viewportZoom  = viewportZoom;          this.settings      = settings;          this.save          = save;     }        move()     {                   const token = this.request[this.pos++];                  return token;     }        i1752()      {         return isEmpty(this.repeats)             ||    this.repeats.length == 1                && this.repeats[0].iteration == this.repeats[0].total-1;     }                                                        }    function u1753(parse, a1754 = true) {           if (!a1754)         parse.a1754 = false;       let result = null;            if (parse.next == y1292                  ) result = u1759             (parse);              else if (parse.next ==        c1051                        || parse.next == g1052                        || parse.next ==   r1053                        || parse.next ==  u1054      ) result = r1603         (parse);       else if (parse.next == v1055              ) result = r1600              (parse);     else if (parse.next == b1056               ) result = h1601          (parse);     else if (parse.next == z1057         ) result = n1602     (parse);     else if (parse.next == f1079                ) result = u1620            (parse);     else if (parse.next == b1058                  ) result = f1621             (parse);     else if (parse.next == r1059                 ) result = t1622            (parse);     else if (parse.next == j1060                  ) result = z1623             (parse);     else if (parse.next == f1081                 ) result = o1673            (parse);     else if (parse.next == z1061                 ) result = i1624            (parse);     else if (parse.next == l1062                  ) result = y1625             (parse);     else if (parse.next == u1063             ) result = a1626         (parse);     else if (parse.next == OBJECT_NAME            ) result = genParseObjectName        (parse);      else if (parse.next == e1064                ) result = x1604              (parse);     else if (parse.next == s1065               ) result = p1605          (parse);     else if (parse.next == a1066                ) result = h1606           (parse);     else if (parse.next == c1067              ) result = r1607          (parse);     else if (parse.next == h1068          ) result = l1608      (parse);     else if (parse.next == r1069                ) result = z1609           (parse);     else if (parse.next == c1070                 ) result = k1610            (parse);     else if (parse.next == v1071           ) result = p1611       (parse);     else if (parse.next == h1072                   ) result = e1612              (parse);     else if (parse.next == y1080                 ) result = h1613            (parse);     else if (parse.next == u1073                 ) result = l1614            (parse);     else if (parse.next == q1074                   ) result = h1615              (parse);     else if (parse.next == p1075                   ) result = h1616              (parse);     else if (parse.next == c1078                 ) result = z1617            (parse);     else if (parse.next == w1076             ) result = w1618         (parse);     else if (parse.next == x1077               ) result = q1619      (parse);           else if (parse.next == g1086           ) result = n1657          (parse);     else if (parse.next == o1087                 ) result = i1658            (parse);           else if (parse.next == l1088            ) result = o1661              (parse);     else if (parse.next == w1089        ) result = a1662          (parse);     else if (parse.next == p1090           ) result = k1663             (parse);     else if (parse.next == f1092          ) result = v1665            (parse);     else if (parse.next == p1091   ) result = b1664      (parse);     else if (parse.next == x1093          ) result = j1666            (parse);     else if (parse.next == f1094           ) result = w1667       (parse);     else if (parse.next == k1095             ) result = e1668       (parse);     else if (parse.next == q1096        ) result = z1659          (parse);     else if (parse.next == b1097        ) result = p1660          (parse);     else if (parse.next == h1098        ) result = x1676          (parse);     else if (parse.next == u1099           ) result = l1674             (parse);     else if (parse.next == g1100            ) result = p1675              (parse);     else if (parse.next == h1101          ) result = x1677            (parse);     else if (parse.next == m1102           ) result = i1678             (parse);     else if (parse.next == p1103     ) result = g1679       (parse);     else if (parse.next == i1104      ) result = v1680        (parse);     else if (parse.next == z1105     ) result = a1681       (parse);     else if (parse.next == v1106           ) result = e1688             (parse);     else if (parse.next == m1107         ) result = q1689           (parse);          else if (parse.next == f1109            ) result = i1669              (parse, (nodeId, options) => new i1864          (nodeId, options));     else if (parse.next == a1108     ) result = b1670        (parse, (nodeId, options) => new i1864          (nodeId, options));     else if (parse.next == y1110             ) result = j1671        (parse, (nodeId, options) => new f1860           (nodeId, options));     else if (parse.next == d1111        ) result = j1671        (parse, (nodeId, options) => new i1868      (nodeId, options));     else if (parse.next == x1112        ) result = j1671        (parse, (nodeId, options) => new w1866      (nodeId, options));     else if (parse.next == v1113          ) result = j1671        (parse, (nodeId, options) => new b1862        (nodeId, options));     else if (parse.next == s1114          ) result = j1671        (parse, (nodeId, options) => new i1865        (nodeId, options));     else if (parse.next == d1115        ) result = j1671        (parse, (nodeId, options) => new m1863      (nodeId, options));           else if (parse.next == c1116         ) result = i1682           (parse);     else if (parse.next == l1117             ) result = j1671        (parse, (nodeId, options) => new z1871           (nodeId, options));     else if (parse.next == c1118             ) result = j1671        (parse, (nodeId, options) => new c1869           (nodeId, options));     else if (parse.next == y1119              ) result = j1671        (parse, (nodeId, options) => new m1872            (nodeId, options));     else if (parse.next == l1120             ) result = j1671        (parse, (nodeId, options) => new z1873           (nodeId, options));           else if (parse.next == m1121       ) result = m1683         (parse);     else if (parse.next == q1122           ) result = v1684     (parse, (nodeId, options) => new x1875         (nodeId, options));     else if (parse.next == l1123       ) result = v1684     (parse, (nodeId, options) => new o1880      (nodeId, options));     else if (parse.next == c1124            ) result = v1684     (parse, (nodeId, options) => new d1878          (nodeId, options));     else if (parse.next == m1125   ) result = v1684     (parse, (nodeId, options) => new w1879   (nodeId, options));     else if (parse.next == q1126         ) result = v1684     (parse, (nodeId, options) => new h1876       (nodeId, options));     else if (parse.next == k1127) result = v1684     (parse, (nodeId, options) => new x1877(nodeId, options));       else if (parse.next == o1128            ) result = a1685     (parse);     else if (parse.next == f1129             ) result = a1686          (parse, (nodeId, options) => new n1883          (nodeId, options));     else if (parse.next == y1130             ) result = a1686          (parse, (nodeId, options) => new c1882        (nodeId, options));     else if (parse.next == v1131             ) result = a1686          (parse, (nodeId, options) => new t1884       (nodeId, options));     else if (parse.next == p1132           ) result = n1687             (parse, (nodeId, options) => new t1884       (nodeId, options));      else if (parse.next == i1133          ) result = o1672      (parse);       else if (parse.next == r1138             ) result = v1729         (parse);     else if (parse.next == s1139                   ) result = l1730              (parse);     else if (parse.next == k1140            ) result = a1731        (parse);     else if (parse.next == u1141              ) result = c1732          (parse);     else if (parse.next == o1142         ) result = n1733     (parse);     else if (parse.next == g1143          ) result = p1734      (parse);     else if (parse.next == x1144              ) result = p1735          (parse);     else if (parse.next == b1149              ) result = r1740   (parse);     else if (parse.next == h1150           ) result = a1741   (parse);     else if (parse.next == f1151          ) result = g1742       (parse);     else if (parse.next == y1152         ) result = q1743      (parse);     else if (parse.next == j1153          ) result = c1744       (parse);     else if (parse.next == i1154         ) result = z1745      (parse);     else if (parse.next == u1155          ) result = o1746       (parse);     else if (parse.next == l1145           ) result = e1736       (parse);     else if (parse.next == s1146              ) result = f1737          (parse);     else if (parse.next == j1147               ) result = j1738           (parse);     else if (parse.next == f1148           ) result = z1739       (parse);     else if (parse.next == r1156             ) result = m1747         (parse);     else if (parse.next == m1158               ) result = f1748           (parse);     else if (parse.next == z3477              ) result = b3678          (parse);     else if (parse.next == w1159             ) result = d1749         (parse);     else if (parse.next == j1160              ) result = k1750          (parse);       else if (parse.next == u1163            ) result = h1591        (parse);     else if (parse.next == g1164                  ) result = h1592             (parse);     else if (parse.next == d1165            ) result = w1593        (parse);     else if (parse.next == o1166          ) result = l1594      (parse);     else if (parse.next == w1168         ) result = n1595     (parse);     else if (parse.next == o1167       ) result = x1596    (parse);     else if (parse.next == b1169             ) result = l1597        (parse);     else if (parse.next == k1170      ) result = j1598  (parse);     else if (parse.next == w1171            ) result = x1599        (parse);            else if (parse.next == k1173             ) result = f1632         (parse);     else if (parse.next == o1174                   ) result = h1633              (parse);            else if (parse.next == q1179       ) result = x1637    (parse);     else if (parse.next == t1180             ) result = k1638         (parse);            else if (parse.next == f1182         ) result = c1635     (parse);     else if (parse.next == m1183               ) result = g1636          (parse);            else if (parse.next == x1176           ) result = i1639       (parse);     else if (parse.next == j1177                 ) result = e1640            (parse);            else if (parse.next == t1185    ) result = h1642 (parse);     else if (parse.next == w1186          ) result = w1643      (parse);            else if (parse.next == z1188      ) result = r1644   (parse);     else if (parse.next == e1189            ) result = b1645        (parse);            else if (parse.next == r1191     ) result = d1646  (parse);     else if (parse.next == t1192           ) result = a1647       (parse);            else if (parse.next == i1194       ) result = l1648    (parse);     else if (parse.next == z1195             ) result = e1649         (parse);            else if (parse.next == t1197        ) result = f1650     (parse);     else if (parse.next == a1198              ) result = y1651          (parse);      else if (parse.next == d1203      ) result = o1652   (parse);     else if (parse.next == r1204            ) result = s1653        (parse);            else if (parse.next == x1200       ) result = d1654    (parse);     else if (parse.next == d1201             ) result = l1655         (parse);            else if (parse.next == v1208            ) result = v1728        (parse);            else if (parse.next == h1211              ) result = p1690         (parse);     else if (parse.next == c1214                   ) result = s1691              (parse);     else if (parse.next == k1217                ) result = o1692           (parse);     else if (parse.next == g1220                ) result = k1693           (parse);     else if (parse.next == s1223                ) result = s1694           (parse);     else if (parse.next == c1226                   ) result = q1695              (parse);     else if (parse.next == o1229             ) result = e1696         (parse);       else if (parse.next == e1231            ) result = x1697        (parse);     else if (parse.next == j1232                  ) result = u1698             (parse);     else if (parse.next == t1234           ) result = v1699       (parse);     else if (parse.next == q1235      ) result = r1700   (parse);     else if (parse.next == u1236            ) result = g1701        (parse);          else if (parse.next == v1238    ) result = v1702 (parse);     else if (parse.next == m1239          ) result = c1703      (parse);     else if (parse.next == h1241      ) result = d1704   (parse);     else if (parse.next == l1242            ) result = w1705        (parse);     else if (parse.next == h1244    ) result = j1706 (parse);     else if (parse.next == s1245          ) result = z1707      (parse);     else if (parse.next == x1247   ) result = g1708(parse);     else if (parse.next == t1248         ) result = n1709     (parse);      else if (parse.next == e1271          ) result = f3814 (parse);     else if (parse.next == h1270                ) result = o1710      (parse);      else if (parse.next == t1250      ) result = e3815   (parse);     else if (parse.next == n1251            ) result = p1711        (parse);       else if (parse.next == n1253            ) result = s3816        (parse);     else if (parse.next == n1254                  ) result = e1712             (parse);       else if (parse.next == o1256                   ) result = c1713              (parse);     else if (parse.next == u1257                 ) result = e1714            (parse);     else if (parse.next == c1258                  ) result = p1715             (parse);     else if (parse.next == y1259                   ) result = g1716              (parse);      else if (parse.next == j1260                 ) result = n1717            (parse);     else if (parse.next == m1261            ) result = o1718    (parse);      else if (parse.next == a1264         ) result = a1719     (parse);     else if (parse.next == s1265          ) result = v1720      (parse);     else if (parse.next == x1266          ) result = w1721      (parse);     else if (parse.next == u1267        ) result = s1722    (parse);     else if (parse.next == c1268      ) result = n1723  (parse);     else if (parse.next == l1269          ) result = t1724       (parse);      else if (parse.next == n1262                  ) result = i1725             (parse);     else if (parse.next == g1263            ) result = u1726        (parse);          else if (parse.next == i1277                 ) result = e1727            (parse);       else if (parse.next == e1282             ) result = y1630         (parse);     else if (parse.next == u1283            ) result = o1631        (parse);       else if (parse.next == f1285                ) result = t1627           (parse);     else if (parse.next == h1286          ) result = q1628      (parse);     else if (parse.next == v1287                  ) result = b1629             (parse);      else u947('unknown parse token \'' + parse.next + '\' @ ' + parse.pos);       parse.a1754 = false;       if (result)         return result;     else     {         parse.so++;         return null;     } }    function v1755(parse) {     const type     = parse.move();     const nodeId   = parse.move();     const nodeName = parse.move();           parse.scope.push(nodeId);       if (parse.x4220.find(n => n.nodeId == nodeId))         return [type, nodeId, {nodeName: nodeName}, true];       const options = h1757(parse);      options.nodeName = nodeName;       return [type, nodeId, options, false]; }    function n1756(parse, node = null) {     parse.scope.pop();      if (node)     {         if (isEmpty(parse.scope))             node.topLevel = true;          e943(parse.x4220, node);     } }    function h1757(parse) {     const opt = parseInt(parse.move());      const options =      {         active:       ((opt >>  0) & 1) != 0,         u2969: ((opt >>  1) & 1) != 0,         enabled:      ((opt >>  2) & 1) != 0,         cached:       ((opt >>  3) & 1) != 0,         unknown:      ((opt >>  4) & 1) != 0,         o3236:    ((opt >> 20) & 1) != 0,         existing:     ((opt >> 21) & 1) != 0     };      return options; }    function j1758(parse) {     const l3642 = parseInt(parse.move());      if (parse.settings.j2527)          parse.log += parse.tab + l3642;      return l3642; }    function u1759(parse) {     if (parse.next != y1292)          return null;              parse.move();      const type = parse.move();            const nodeId  = parse.move();     const e2963 = parse.move();          const param   = new w2010(nodeId, e2963);            e943(parse.u3614, nodeId);       if (parse.settings.j2527)          n2090(param, type, parse);       return param; }    function b1760(parse) {     const e2963 = parse.move();      if (parse.settings.j2527)         parse.log += parse.tab + e2963;      return e2963; }


class k2094 {     request;     pos;      so            = 0;     r3619          = 0;        skipNewLine   = false;      loggedNodeIds = [];            constructor(request, pos)     {         this.request = request;         this.pos     = pos;     }       get tab()      {          if (this.skipNewLine)         {             this.skipNewLine = false;             return '';         }         else              return z862 + g860.repeat(Math.max(0, this.r3619));      } }    function log(str) {     w3857.innerHTML = str; }    function s2095(m2096, c111 = null) {     let str = m2096;      if (c111)         str = c111.id + '.' + str;      console.log(         '%c ' + str + ' ',          'background: #fc0; color: #632;'); }    function b2097(str, color = 'white', background = 'red') {     console.log(         '%c ' + str + ' ',          'background: ' + background + '; color: ' + color + ';'); }    function e3998(a3993, t3994, values) {           let log     = '';     let newLine = true;      if (   a3993  != ''          || t3994 != '')         log = '↓ ' + o2088(a3993) + '.' + o2088(t3994);     else         newLine = false;                 let i    = 0;     let r3619 = 0;      while (i < values.length)     {         const nodeId  = values[i++];         const w4186 = parseInt(values[i++]);          log +=                (newLine ? z862 : '') + g860.repeat(Math.max(0, r3619))             + nodeId;          newLine = true;          r3619++;          for (let j = 0; j < w4186; j++)         {             const index = values[i++];             const type  = values[i++];             const value = values[i++];              log +=                    z862 + g860.repeat(Math.max(0, r3619))                 + index + ' ' + m4187(type, value);         }          r3619--;     }       console.log(         '%c%s',          'background: #e70; color: white;',          log); }    function b3999(objects) {     console.log(         '%cobjects',          'background: #07e; color: white;',          objects); }    function m4000(styles) {     console.log(         '%cstyles',          'background: #b4d; color: white;',          styles); }    function v2098(pageJson) {     console.log('%cSAVING PAGES\n' + pageJson, 'color: black; background: #ddeeee;'); }    function b2099(nodeJson) {     console.log('%cSAVING NODES\n' + nodeJson, 'color: black; background: #ddeeff;'); }    function d2100(l2101) {     let log = 'SAVING ' + l2101.length + ' ' + c3990(l2101.length, 'CONNECTION');      for (const k243 of l2101)         log += '\n' + k243.o2080();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function m2102(l2101) {     let log = 'UPDATING ' + l2101.length + ' ' + c3990(l2101.length, 'SAVED CONNECTION');      for (const k243 of l2101)         log += '\n' + k243.o2080();      console.log(         '%c' + log,          'color: black; background: #ddeeff;'); }    function o2103() {     let log =          'UNDO STACK:\n'         + w2858.actions.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #ffd; color: #b80;', log); }    function v2104() {     let log =           'REDO STACK:\n'         + w2858.j2860.map(a => '    ' + a.name).join('\n');      console.log('%c%s', 'background: #fff4e8; color: #c64;', log); }


function p2085(parse) {     let log = '';      if (   parse.a3993  != ''          || parse.t3994 != '')         log = '↓ ' + o2088(parse.a3993) + '.' + o2088(parse.t3994);      log += parse.log;      console.log(         '%c%s',          'background: #60aa60; color: #fff',           log); }    function s2086(node, parse, ignore, w4186 = -1) {     parse.log += parse.tab + node.type;     parse.log += b2087(node, ignore);      if (    w4186 > -1         && !ignore)         parse.log += ' ' + w4186; }    function b2087(node, ignore = false) {     return ' '           + o2088(node.nodeId)           + ' ' + o2088(node.nodeName)          + (!ignore             ? a2089(node)             : ''); }    function o2088(nodeId) {     return nodeId == '' ? '\'\'' : nodeId; }    function a2089(node) {     let log = '';      if ( node.options.active      ) log += ' ' + f1288;     if ( node.options.u2969) log += ' ' + d1289;     if (!node.options.enabled     ) log += ' ' + b1290;      if (!node.cached              ) log += ' ' + a1291;      return log; }    function n2090(param, type, parse) {     parse.log +=                  parse.tab + y1292         + ' ' + type          + ' ' + o2088(param.nodeId)          + '.' + o2088(param.e2963); }    function o2091(node, parse) {     parse.log += parse.tab + node.type;     parse.log += b2087(node); }    function y2092(n1029, w4186, g3656, parse, ignore) {     parse.log += parse.tab + w1168;     parse.log += b2087(n1029, ignore);      if (!ignore)     {         parse.log += ' ' + w4186;          if (w4186 == 1)             parse.log += ' ' + g3656;     } }    function w2093(type, val, parse) {     parse.log += parse.tab + type + ' ' + m4187(type, val); }                                           


function b2081(nodeKey, h3981) {     const log  = r2082(s1532(nodeKey, false));      if (h3981)     {         console.log(             '%c%s\n%c%s',              'background: #fa24; color: white;',              k1049(nodeKey),              'background: #fa44; color: #edc;',             log);     }     else     {         console.log(             '%c%s\n%c%s',              'background: #fdb; color: black;',              k1049(nodeKey),              'background: #fed; color: black;',             log);     } }    function r2082(json) {     let l4010 = json         .replace('{\n', '')         .replace('\n}', '')          .replace('[\n' + g860, '')         .replace('\n' + g860 + ']', '')          .split(g860 + '"params":\n').join('')           .split('": "').join(': ')         .split('", "').join(': ')          .split(g860 + '"').join(g860)         .split(g860 + g860 + '["').join(g860 + g860)                  .split('",\n').join('\n')         .split('"\n').join('\n')                  .split('"],\n').join('\n');       if (l4010[l4010.length-1] == '"')         l4010 = l4010.substring(0, l4010.length - 1);      if (l4010.substring(l4010.length-2) == '"]')             l4010 = l4010.substring(0, l4010.length - 2);      return l4010; }    function s2083(json) {     let l4010 = json         .replace('{\n', '')         .replace('\n}', '')         .replace('[\n' + g860, '')         .replace('\n' + g860 + ']', '');      return l4010; }    function e2084(k243, h3981) {     const b4188 = j918(k243, true);      if (h3981)     {         console.log(             '%c%s',              'background: #4f44; color: #ded',              b4188);      }     else     {         console.log(             '%c%s',              'background: #cfc; color: black;',              b4188);      } }


  const D65 = [0.95047, 1, 1.08883];    function n31(R, G, B, Y, W, gamma, degamma, regamma, luminance) {     return {             R:         R,         G:         G,         B:         B,          Y:         Y,          W:         W,          x3949:   y32(R, G, B, W),         xyz2lin:   m881(y32(R, G, B, W)),          gamma:     gamma,                  degamma:   degamma,         regamma:   regamma,                  luminance: luminance     }; }   function y32(R, G, B, W) {     const C0 = s33(R);     const C1 = s33(G);     const C2 = s33(B);      const M = [ [ C0[0], C1[0], C2[0] ],                  [ C0[1], C1[1], C2[1] ],                  [ C0[2], C1[2], C2[2] ] ];      const S = v942(W, m881(M));      return [ [ S[0]*C0[0], S[1]*C1[0], S[2]*C2[0] ],              [ S[0]*C0[1], S[1]*C1[1], S[2]*C2[1] ],              [ S[0]*C0[2], S[1]*C1[2], S[2]*C2[2] ] ]; }   function s33(c) {     const x = c[0],           y = c[1];      return [x/y, 1, (1-x-y)/y]; } 


const o36 = n31 (     [0.64, 0.33],      [0.3,  0.6 ],      [0.15, 0.06],       [0.212656,      0.715158,      0.072186],       D65,              2.4,                function(v)      {         return v >= 0.04045                ? Math.pow((v + 0.055) / 1.055, this.gamma)                : v / 12.92;     },            function(v)      {         return v > 0.0031308                ? 1.055 * Math.pow(v, 1/this.gamma) - 0.055                : v * 12.92;     },                function(rgb)      {         return  this.Y[0] * this.degamma(rgb[0])                + this.Y[1] * this.degamma(rgb[1])                + this.Y[2] * this.degamma(rgb[2]);     } ); 


function d66(rgb, amount) {     const hsv = w52(rgb);     hsv[2] *= amount;     return r54(hsv); }    function a67(rgb, amount) {     const hsv = w52(rgb);     hsv[1] *= amount;     return r54(hsv); }    function n68(rgb, amount) {     const hsl = d48(rgb);     hsl[1] *= amount;     return q50(hsl); }


function u51(r, g, b) {     let h, s, v;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      v = max;     s = max == 0 ? 0 : delta / max; 	     if      (max == r) h = 1/6 * (g - b) / delta + 1;        else if (max == g) h = 1/6 * (b - r) / delta + 1/3;      else if (max == b) h = 1/6 * (r - g) / delta + 2/3;   	if (h > 1) h -= 1; 	      return [h, s, v]; }    function w52(rgb) {     return u51(rgb[0], rgb[1], rgb[2]); }    function x53(h, s, v) {     while (h < 0) h++;     h %= 1;      if (s == 0)         return [v, v, v];       h *= 6 - 0.0000001;      let i = Math.floor(h);     let f = h - i; 	     let p = v * (1 - s);     let q = v * (1 - s * f);     let t = v * (1 - s * (1 - f));      switch (i)     {         case 0:  return [v, t, p];         case 1:  return [q, v, p];         case 2:  return [p, v, t];         case 3:  return [p, q, v];         case 4:  return [t, p, v];         default: return [v, p, q];     } }    function r54(hsv) { 	return x53(hsv[0], hsv[1], hsv[2]); }


function v47(r, g, b) {     let h, s, l;      let min = Math.min(Math.min(r, g), b),         max = Math.max(Math.max(r, g), b);      let delta = max - min;      l = (max + min) / 2;           if (max == min) h = 0;     else if (max == r  ) h = 1/6 * (g - b) / delta + 1;     else if (max == g  ) h = 1/6 * (b - r) / delta + 1/3;     else if (max == b  ) h = 1/6 * (r - g) / delta + 2/3;           if (max == min) s = 0;     else if (l <= 0.5)   s = delta / (2 * l);     else if (l >  0.5)   s = delta / (2 - 2 * l);      return [h, s, l]; }    function d48(rgb) {     return v47(rgb[0], rgb[1], rgb[2]); }    function d49(h, s, l) {     while (h < 0) h++;     h %= 1;      let q =         l < 0.5         ? l * (1 + s)         : l + s - l * s;      let p = 2 * l - q;      let tr = h + 1/3;     let tg = h;     let tb = h - 1/3;      if (tr < 0) tr += 1; if (tr > 1) tr -= 1;     if (tg < 0) tg += 1; if (tg > 1) tg -= 1;     if (tb < 0) tb += 1; if (tb > 1) tb -= 1;      let r, g, b;      let qp6 = (q - p) * 6;            if (tr <  1/6)				r = p + qp6 * tr;     else if (tr >= 1/6 && tr < 0.5)	r = q;     else if (tr >= 0.5 && tr < 2/3)	r = p + qp6 * (2/3 - tr);     else							r = p; 	          if (tg <  1/6)				g = p + qp6 * tg;     else if (tg >= 1/6 && tg < 0.5)	g = q;     else if (tg >= 0.5 && tg < 2/3) g = p + qp6 * (2/3 - tg);     else							g = p;           if (tb <  1/6)				b = p + qp6 * tb;     else if (tb >= 1/6 && tb < 0.5) b = q;     else if (tb >= 0.5 && tb < 2/3) b = p + qp6 * (2/3 - tb);     else							b = p;      return [r, g, b]; }    function q50(hsl) {     return d49(hsl[0], hsl[1], hsl[2]); }


function d59(xyz) {     return v942(xyz, CAT); }    function t60(lms) {     return v942(lms, invCAT); } 


function u69(rgb, cs = o36) {      return r70(degamma(rgb, cs), cs); }        function r70(rgb, cs = o36) {     return v942(rgb, cs.x3949); }            function t71(xyz, cs = o36) {     return regamma(i72(xyz, cs), cs); }    function i72(xyz, cs = o36) {     return v942(xyz, cs.xyz2lin); }


function z3951(rgb, cs = o36) {     return p3953(u69(rgb, cs), cs.W); }    function v3952(luv, cs = o36) {     return t71(z3954(luv, cs.W), cs); }    function p3953(xyz, W = o36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = cube(6/29);     const k = cube(29/3);      const yw = y / W[1];      let l =          yw > e         ? 116 * Math.cbrt(yw) - 16         : k * yw;      const u_ = 4*x / (x + 15*y + 3*z);     const v_ = 9*y / (x + 15*y + 3*z);          const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const u = 13*l * (u_ - uw);     const v = 13*l * (v_ - vw);      return [         l / 100,          u / 100,          v / 100]; }    function z3954(luv, W = o36.W) {     let l = luv[0] * 100,          u = luv[1] * 100,          v = luv[2] * 100;      const e = cube(6/29);         const k = cube(29/3);      const uw = 4*W[0] / (W[0] + 15*W[1] + 3*W[2]);     const vw = 9*W[1] / (W[0] + 15*W[1] + 3*W[2]);          const y =          l > e*k         ? cube((l + 16) / 116)         : l / k;          const a = (52*l / nozero(u + 13*l*uw) - 1) / 3;     const b = -5 * y;     const c = -1/3;     const d =  y * (39*l / nozero(v + 13*l*vw) - 5);      const x = (d - b) / nozero(a - c);      const z = x*a + b;      return [x, y, z]; }


function l55(rgb, cs = o36) {     return q57(u69(rgb, cs), cs.W); }    function b56(lab, cs = o36) {     return t71(v58(lab, cs.W), cs); }    function q57(xyz, W = o36.W) {     const x = xyz[0],            y = xyz[1],            z = xyz[2];      const e = 0.008856;      const k = 903.3;          let xw = x / W[0];     let yw = y / W[1];     let zw = z / W[2];      xw = xw > e ? Math.cbrt(xw) : (k / 100 * xw + 0.16) / 1.16;     yw = yw > e ? Math.cbrt(yw) : (k / 100 * yw + 0.16) / 1.16;     zw = zw > e ? Math.cbrt(zw) : (k / 100 * zw + 0.16) / 1.16;       const l = (1.16 * yw) - 0.16;     const a = 5 * (xw - yw);     const b = 2 * (yw - zw);      return [l, a, b]; }    function v58(lab, W = o36.W) {     const l = lab[0],            a = lab[1],            b = lab[2];      const e = 0.008856 / 100;      const k = 903.3    / 100;       const yw = (l + 0.16)/1.16;     const xw = a/5 + yw;     const zw = yw - b/2;      let x = cube(xw) > e ? cube(xw) : (1.16*xw - 0.16) / k;     let y = cube(yw) > e ? cube(yw) : (1.16*yw - 0.16) / k;     let z = cube(zw) > e ? cube(zw) : (1.16*zw - 0.16) / k;      x *= W[0];     y *= W[1];     z *= W[2];       return [x, y, z]; }


function d3955(rgb, cs = o36) {     return n3956(rgb[0], rgb[1], rgb[2], cs); }    function n3956(r, g, b, cs = o36)  {     return u3958(d3957(r, g, b, cs)); }    function d3957(r, g, b, cs = o36)  {     r = cs.degamma(r);     g = cs.degamma(g);     b = cs.degamma(b);      return [         0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b, 	    0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b, 	    0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b ]; }            function u3958(lms)  {     const l = Math.cbrt(lms[0]);     const m = Math.cbrt(lms[1]);     const s = Math.cbrt(lms[2]);      const l_ = 0.2104542553 * l + 0.7936177850 * m - 0.0040720468 * s;     const a_ = 1.9779984951 * l - 2.4285922050 * m + 0.4505937099 * s;     const b_ = 0.0259040371 * l + 0.7827717662 * m - 0.8086757660 * s;      return [         l_,         a_,          b_ ]; }            function o3959(lab, cs = o36) {     return b3963(t3961(lab), cs); }    function k3960(l, a, b, cs = o36)  {     return o3959([l, a, b], cs); }    function t3961(lab) {     return g3962(lab[0], lab[1], lab[2]); }    function g3962(l, a, b)  {     return [         l + 0.3963377774 * a + 0.2158037573 * b,         l - 0.1055613458 * a - 0.0638541728 * b,         l - 0.0894841775 * a - 1.2914855480 * b ]; }    function b3963(lms, cs = o36)  {     const l = cube(lms[0]);     const m = cube(lms[1]);     const s = cube(lms[2]);  	const r =  4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s; 	const g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s; 	const b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;      return [         cs.regamma(r),         cs.regamma(g),         cs.regamma(b) ]; }


const i65 = 0.89;   function u63(opp)  {                const l = opp[0],            a = opp[1],            b = opp[2];      const h = Math.atan2(b, a);     const c = Math.sqrt(a*a + b*b);      return [h, c, l]; }    function h64(pol)  {                const h = pol[0],            c = pol[1],            l = pol[2];      const a = c * Math.cos(h);     const b = c * Math.sin(h);      return [l, a, b]; }


function z34(hcl, cs = o36) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];       return o3959(h64(hcl), cs); }        function h35(h, c, l, cs = o36) {     return h35([h, c, l], cs); }                    function t37(rgb, cs = o36) {     const hcl = u63(d3955(rgb, cs));      hcl[0] /= Tau;     hcl[1] /= nozero(hcl[2]);      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function q38(r, g, b, cs = o36) {     return t37([r, g, b], cs); }    function r39(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return h64(hcl); }    function b40(hcl, cs = o36) {     return b56(r39(hcl), cs); }    function n41(lab) {     let hcl = u63(lab);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function b42(rgb, cs = o36) {     return n41(l55(rgb, cs)); }    function l43(hcl) {     hcl = [...hcl];      hcl[0] *= Tau;     hcl[1] *= hcl[2];      return h64(hcl); }    function l44(hcl, cs = o36) {     return v3952(l43(hcl), cs); }    function y45(luv) {     let hcl = u63(luv);      hcl[0] /= Tau;     hcl[1] /= hcl[2];      while (hcl[0] < 0) hcl[0] += 1;     while (hcl[0] > 1) hcl[0] -= 1;      return hcl; }    function k46(rgb, cs = o36) {     return y45(z3951(rgb, cs)); }


function d61(rgb) {     const p3 =          [ [ 0.8225, 0.1774, 0      ],           [ 0.0332, 0.9669, 0      ],           [ 0.0171, 0.0724, 0.9108 ] ];      rgb = degamma(rgb);      return regamma(g1033(p3, rgb)); }    function e62(rgb)  {     const invp3 =          [ [ 1.2249, -0.2247, 0      ],           [-0.0420,  1.0419, 0      ],           [-0.0197, -0.0786, 1.0979 ] ];        rgb = g1033(invp3, degamma(rgb));        return regamma(rgb); }


const l131 =  [     ['hex',   'Hex'   ],     ['rgb',   'RGB'   ],      ['hsv',   'HSV'   ],      ['hsl',   'HSL'   ],      ['hclok', 'HCL/ok'],     ['hclab', 'HCL/ab'],     ['hcluv', 'HCL/uv'],     ['oklab', 'okLab' ],     ['lab',   'Lab'   ],     ['luv',   'Luv'   ] ];    class v132 {     hex   = Object.freeze(0);     rgb   = Object.freeze(1);     hsv   = Object.freeze(2);     hsl   = Object.freeze(3);     hclok = Object.freeze(4);     hclab = Object.freeze(5);     hcluv = Object.freeze(6);     oklab = Object.freeze(7);     lab   = Object.freeze(8);     luv   = Object.freeze(9); }    class Color extends Float32Array {     get r() { return this[0]; }     get g() { return this[1]; }     get b() { return this[2]; }     get a() { return this[3]; }     get s() { return this[4]; }      set r(r) { this[0] = r; }     set g(g) { this[1] = g; }     set b(b) { this[2] = b; }     set a(a) { this[3] = a; }     set s(s) { this[4] = s; }        constructor(c = null)     {         super(5);           if (c)         {             this.r = c.r;             this.g = c.g;             this.b = c.b;             this.a = c.a;             this.s = c.s;         }         else         {             this.r = 0;             this.g = 0;             this.b = 0;             this.a = 0;             this.s = v132.rgb;         }     } }


const s76 = 0.001;    function l146(rgb) {     const _space = 'rgb';      return [         _space,          c4153(rgb[0], _space, 0),          c4153(rgb[1], _space, 1),          c4153(rgb[2], _space, 2) ];  }    function s147(space, c1, c2, c3) {     const _space = a133(space.value);      return [         _space,          c4153(c1.value, _space, 0),          c4153(c2.value, _space, 1),          c4153(c3.value, _space, 2) ];  }    function n148(c) {     return isNaN(c[1])         || isNaN(c[2])         || isNaN(c[3]); }    function w149(col, lim = s76) {     return e75(c4172(col), lim); }    function q150(col, lim = s76) {     return d78(c4172(col), lim); }


const rgb_NaN = [     Number.NaN,     Number.NaN,     Number.NaN ];  const rgba_NaN = [     Number.NaN,     Number.NaN,     Number.NaN,     Number.NaN ];   const rgbInvalid  = [0xff, 0, 0xff]; const rgbaInvalid = [0xff, 0, 0xff, 0xff];   const t3789 = Object.freeze([     'rgb',     Number.NaN,     Number.NaN,     Number.NaN ]);            const CAT = [[ 0.7328, 0.4296, -0.1624],              [-0.7036, 1.6975,  0.0061],              [ 0.0030, 0.0136,  0.9834]];  const invCAT = m881(CAT);   const M1 = [[ 0.8189330101, 0.3618667424, -0.1288597137 ],             [ 0.0329845436, 0.9293118715,  0.0361456387 ],             [ 0.0482003018, 0.2643662691,  0.6338517070 ]];  const invM1 = m881(M1);    function p73(rgb)  {     return isNaN(rgb[0])         || isNaN(rgb[1])         || isNaN(rgb[2]); }    function o74(rgba)  {     return isNaN(rgba[0])         || isNaN(rgba[1])         || isNaN(rgba[2])         || isNaN(rgba[3]); }    function e75(rgb, lim = s76) {     return rgb[0] > -lim && rgb[0] < 1 + lim          && rgb[1] > -lim && rgb[1] < 1 + lim          && rgb[2] > -lim && rgb[2] < 1 + lim; }    function z77(rgba, lim = s76) {     return rgba[0] > -lim && rgba[0] < 1 + lim          && rgba[1] > -lim && rgba[1] < 1 + lim          && rgba[2] > -lim && rgba[2] < 1 + lim         && rgba[3] > -lim && rgba[3] < 1 + lim; }    function d78(rgb, lim = s76) {     return !p73  (rgb)         &&  e75(rgb, lim); }    function q79(rgba, lim = s76) {     return !o74  (rgba)         &&  z77(rgba, lim); }    function e80(rgb) {     return [         Math.min(Math.max(0, rgb[0]), 1),         Math.min(Math.max(0, rgb[1]), 1),         Math.min(Math.max(0, rgb[2]), 1) ]; }    function r81(v82, i83, t) {     return [ n1029(v82[0], i83[0], t),              n1029(v82[1], i83[1], t),              n1029(v82[2], i83[2], t) ]; }    function o84(c3777, rgba2, t) {     return [ n1029(c3777[0], rgba2[0], t),              n1029(c3777[1], rgba2[1], t),              n1029(c3777[2], rgba2[2], t),              n1029(c3777[3], rgba2[3], t) ]; }    function k85(v82, i83) {     return [ v82[0] + i83[0],              v82[1] + i83[1],              v82[2] + i83[2] ]; }    function q86(v82, i83) {     return [ v82[0] - i83[0],              v82[1] - i83[1],              v82[2] - i83[2] ]; }    function b87(rgb, s) {     return [ rgb[0] * s,              rgb[1] * s,              rgb[2] * s ]; }    function a88(v82, i83) {     return [ (v82[0] + i83[0]) / 2,              (v82[1] + i83[1]) / 2,              (v82[2] + i83[2]) / 2 ]; }    function n89(v82, i83) {     return [ Math.max(v82[0], i83[0]),              Math.max(v82[1], i83[1]),              Math.max(v82[2], i83[2]) ]; }    function g90(col, p) {     return [         Math.pow(col[0], p),          Math.pow(col[1], p),          Math.pow(col[2], p) ] }    function x91(cones) {     return cones.l == 1          && cones.m == 1          && cones.s == 1; }    function x92(rgb) {     return '{' + Math.round(rgb[0] * 255) + ', '                + Math.round(rgb[1] * 255) + ', '                + Math.round(rgb[2] * 255) + '}'; }    function n93(r, g, b, a) {     if (a !== undefined)     {         return 'rgba('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ', '             + a + ')';     }     else     {         return 'rgb('             + Math.round(r * 0xff) + ', '             + Math.round(g * 0xff) + ', '             + Math.round(b * 0xff) + ')';     } }    function y94(r, g, b) {     return n93(r, g, b, 1); }    function y95(rgb) {     return n93(rgb[0], rgb[1], rgb[2], 1); }    function i96(r, g, b, a) {     return n93(r, g, b, a); }    function g97(rgba) {     return n93(rgba[0], rgba[1], rgba[2], rgba[3]); }    function d98(rgb, a = 1) {     return n93(rgb[0], rgb[1], rgb[2], a); }    function c99(rgb_) {     return rgb_.length == 3          ? [...rgb_, 1]          : rgb_; }    function u100(rgb, a = 1) {     return [rgb[0], rgb[1], rgb[2], a]; }    function j101(rgb, threshold = 0.71) {     return t37(rgb)[2] < threshold; }    function i102(i103, m104) {     const d0 = m104[0] - i103[0];     const d1 = m104[1] - i103[1];     const d2 = m104[2] - i103[2];      return Math.sqrt(d0*d0 + d1*d1 + d2*d2); }    function x105(rgba, v) {     return [         rgba[0] * v,         rgba[1] * v,         rgba[2] * v,         rgba[3] * v ]; }    function m106(rgba, v) {     return [         rgba[0] / v,         rgba[1] / v,         rgba[2] / v,         rgba[3] / v ]; }    function g107(i103, m104) {     return Math.max(Math.max(Math.max(         Math.abs(m104[0] - i103[0]),         Math.abs(m104[1] - i103[1])),         Math.abs(m104[2] - i103[2]))); }    function i108(v82, i83) {     return Math.abs(v82[0] - i83[0]) < s76         && Math.abs(v82[1] - i83[1]) < s76         && Math.abs(v82[2] - i83[2]) < s76;         }    function n109(style)  {     r3989.fillStyle = style;     r3989.fillRect(0, 0, 1, 1);      return m106(r3989.getImageData(0, 0, 1, 1).data, 0xFF); }    function s110(c111, style)  {     r3989.fillStyle = m1468(c111, style);     r3989.fillRect(0, 0, 1, 1);      return m106(r3989.getImageData(0, 0, 1, 1).data, 0xFF); }    function m112(rgb, opacity = 1) {     return !p73(rgb)            ? (opacity >= 0.5                ? (j101(rgb) ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75])                : (h3981 ? [1, 1, 1, 0.75] : [0, 0, 0, 0.75]))            : (h3981 ? p2393 : v2392); }    function f113(rgb) {     return !p73(rgb)          ? (j101(rgb)  ? [1, 1, 1, 0.133] : [0, 0, 0, 0.161])            : (h3981 ? [1, 1, 1, 0.031] : [0, 0, 0, 0.031]);   }    function z114(b115) {     let y3824,          m3825;                   const o3826 = f113(b115);            if (!p73(b115))     {         const h3827 = t37(b115);          const k3828 = [...h3827];         const m3829 = [...h3827];          k3828[0] += 1/12;  if (k3828[0] > 1) k3828[0] -= 1;         m3829[0] -= 1/12;  if (m3829[0] < 0) m3829[0] += 1;           const e3830 = u100(z123(z34(k3828)), 0.35);         const b3831 = u100(z123(z34(m3829)), 0.35);          const factor   = x119(b115);          const colWarn1 = o84(o3826, e3830, factor);         const colWarn2 = o84(o3826, b3831, factor);                  y3824     = g97(colWarn1);         m3825     = g97(colWarn2);     }     else     {         y3824 = g97(o3826);         m3825 = g97(o3826);     }       return [y3824,              m3825]; }    function i116(i, w117, g118) {     return 'repeating-linear-gradient('             + '-45deg, '             + 'transparent 0 ' + i   + 'px,'              +  w117 + ' '    + i   + 'px ' + i*2 +'px,'             + 'transparent '   + i*2 + 'px ' + i*3 +'px,'             +  g118 + ' '    + i*3 + 'px ' + i*4 +'px)'; }    function x119(b115) {     let dr, dg, db;      if (b115[0] < 0) dr = -b115[0]; else if (b115[0] > 1) dr = b115[0] - 1; else dr = 0;     if (b115[1] < 0) dg = -b115[1]; else if (b115[1] > 1) dg = b115[1] - 1; else dg = 0;     if (b115[2] < 0) db = -b115[2]; else if (b115[2] > 1) db = b115[2] - 1; else db = 0;          const d   = [dr, dg, db].sort()[1];     const avg = (dr + dg + db) / 3;      const factor = Math.min((d + avg) / 2, 1);                                                              return factor; }    function r120(c121) {     let s3832 = [...c121];              const factor = x119(c121);      if (factor > 0)     {         const hcl = t37(z123(c121));         hcl[1] /= 2;                   s3832 = r81(c121, q129(z34(hcl)), factor);     }      return s3832; }    function z122(rgba) {     return !o74(rgba)          ? (j101(rgba)  ? '#ffffff29' : '#00000022')          : (h3981 ? '#ffffff08' : '#00000006');  }    function z123(o124) {     const rgb = [...o124];      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function t125(val) {     return Math.min(Math.max(0, val), 1); }    function v126(v127, r128, val) {     const col = [...v127];     col[r128] = val;     return col; }    function q129(rgb) {     let hcl = t37(rgb);      let q3833 = 10000;      while (!e75(z34(hcl))          && hcl[1] > 0.001          && q3833-- > 0)         hcl[1] -= 0.001;      rgb = z34(hcl);      rgb[0] = Math.min(Math.max(0, rgb[0]), 1);        rgb[1] = Math.min(Math.max(0, rgb[1]), 1);        rgb[2] = Math.min(Math.max(0, rgb[2]), 1);       return rgb; }    function v130(rgba) {     if (!o74(rgba))         return 'transparent';     else     {         return h3981             ? 'rgba(56, 56, 56, 0.95)'             : 'rgba(255, 255, 255, 0.95)';     } }


// https://ixora.io/projects/colorblindness/color-blindness-simulation-research/
  const u135 = d59(r70([1, 1, 1])); const j136 = d59(r70([0, 0, 1])); const m137 = d59(r70([1, 0, 0]));  const w138 = (u135[2]*j136[0] - j136[2]*u135[0]) / (u135[2]*j136[1] - j136[2]*u135[1]); const r139 = (u135[1]*j136[0] - j136[1]*u135[0]) / (u135[1]*j136[2] - j136[1]*u135[2]);  const x140 = (u135[2]*j136[1] - j136[2]*u135[1]) / (u135[2]*j136[0] - j136[2]*u135[0]); const j141 = (u135[0]*j136[1] - j136[0]*u135[1]) / (u135[0]*j136[2] - j136[0]*u135[2]);  const s142 = (u135[1]*m137[2] - m137[1]*u135[2]) / (u135[1]*m137[0] - m137[1]*u135[0]); const n143 = (u135[0]*m137[2] - m137[0]*u135[2]) / (u135[0]*m137[1] - m137[0]*u135[1]);  const v144 = u135[0] / u135[2]; const d145 = u135[1] / u135[2];   // this is a number I made up following the information here: https://www.color-blindness.com/2007/07/20/monochromacy-complete-color-blindness/
    const n3834 = 0.88;   function v134(rgb, l, m, s, cs = o36) {     if (   l == 0         && m == 0         && s == 0)     {                   const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          rgb = [a, a, a];     }     else     {         const xyz = u69(rgb, cs);         const lms = d59(xyz);          const a =                cs.Y[0] * rgb[0]             + cs.Y[1] * rgb[1]             + cs.Y[2] * rgb[2];          const lm = Math.min(l + m, 1);           const lms_ = [             lms[0] + n1029(n3834 * (v144*lms[2] - lms[0]), (1 - l) * ((w138*lms[1] + r139*lms[2]) - lms[0]), lm),             lms[1] + n1029(n3834 * (d145*lms[2] - lms[1]), (1 - m) * ((x140*lms[0] + j141*lms[2]) - lms[1]), lm),             lms[2] + n1029(0,                     n1029(s, 1 - s, lm) * ((s142*lms[0] + n143*lms[1]) - lms[2]), lm) ];          const xyz_ = t60(lms_);               rgb  = t71(xyz_, cs);           let bm_ = l55(rgb, cs);         bm_[0] = n1029(a, bm_[0], lm);         rgb = b56(bm_, cs);                   rgb = r81(             [a, a, a],              rgb,              Math.min(s + lm, 1));     }           return rgb; }


function m151(rgb) {     let hex =           Math.round(rgb[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgb[2] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function a152(rgba) {     let hex =           Math.round(rgba[0] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[1] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[2] * 0xff).toString(16).padStart(2, '0').toUpperCase()         + Math.round(rgba[3] * 0xff).toString(16).padStart(2, '0').toUpperCase();      return hex; }    function g153(hex)  {     return hex.indexOf(e958) > -1             ? rgb_NaN             : s155(hex); }    function l154(hex)  {     return hex.indexOf(e958) > -1             ? rgba_NaN             : j156(hex); }    function s155(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgb = [];      if (hex.length >= 6)     {         rgb[0] = parseInt(hex.slice(0, 2), 16);          rgb[1] = parseInt(hex.slice(2, 4), 16);          rgb[2] = parseInt(hex.slice(4, 6), 16);      }     else if (hex.length >= 3)     {         rgb[0] = parseInt(hex[0], 16) * 0x11;          rgb[1] = parseInt(hex[1], 16) * 0x11;          rgb[2] = parseInt(hex[2], 16) * 0x11;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgb[0] = v;          rgb[1] = v;          rgb[2] = v;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgb[0] = v * 0x11;          rgb[1] = v * 0x11;          rgb[2] = v * 0x11;      }     else if (hex.length == 0)     {         rgb[0] = 0;          rgb[1] = 0;          rgb[2] = 0;              }       rgb[0] /= 0xff;     rgb[1] /= 0xff;     rgb[2] /= 0xff;           return rgb; }    function j156(hex) {     if (hex[0] == '#')         hex = hex.substring(1);               let rgba = [];      if (hex.length >= 8)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = parseInt(hex.slice(6, 8), 16);      }     else if (hex.length >= 6)     {         rgba[0] = parseInt(hex.slice(0, 2), 16);          rgba[1] = parseInt(hex.slice(2, 4), 16);          rgba[2] = parseInt(hex.slice(4, 6), 16);          rgba[3] = 0xff;      }     else if (hex.length >= 4)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = parseInt(hex[3], 16) * 0x11;      }     else if (hex.length == 3)     {         rgba[0] = parseInt(hex[0], 16) * 0x11;          rgba[1] = parseInt(hex[1], 16) * 0x11;          rgba[2] = parseInt(hex[2], 16) * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 2)     {         let v = parseInt(hex, 16);                  rgba[0] = v;          rgba[1] = v;          rgba[2] = v;          rgba[3] = 0xff;      }     else if (hex.length == 1)     {         let v = parseInt(hex, 16);                  rgba[0] = v * 0x11;          rgba[1] = v * 0x11;          rgba[2] = v * 0x11;          rgba[3] = 0xff;      }     else if (hex.length == 0)     {         rgba[0] = 0;          rgba[1] = 0;          rgba[2] = 0;                  rgba[3] = 0;      }       rgba[0] /= 0xff;     rgba[1] /= 0xff;     rgba[2] /= 0xff;     rgba[3] /= 0xff;       return rgba; }


function i157(t158, s159) {     if (    p73  (t158)         || !e75(t158))         return Number.NaN;      const s164 = o36.luminance(t158);     const  h165 = o36.luminance(s159);      return (         h165 > s164         ? ( h165 + 0.05) / (s164 + 0.05)         : (s164 + 0.05) / ( h165 + 0.05)); }    function b160(ratio) {          if (ratio >= 7  ) return 'AAA';     else if (ratio >= 4.5) return 'AA';     else if (ratio >= 3  ) return 'AA<sub>L</sub>';     else                   return ''; }    function r161(t158, s159) {     if (!d78(t158))         return Number.NaN;      return r163(         p162(t158),         p162(s159)); }    // I copied the code below from https://github.com/Myndex/t4100-APCA/blob/master/WEBTOOLS/APCA/JS/DEV.0.1.2.G_SAPCsRGB.js
  const d4080     = 2.4;          const l4081        = 0.2126729,        t4082        = 0.7151522,        i4083        = 0.0721750;      const x4084      = 0.56,        f4085     = 0.57,       r4086      = 0.62,       r4087       = 0.65;      const m4088     = 0.022,       v4089     = 1.414,        n4090    = 1.14,       s4091    = 1.14,       l4092 = 0.035991,       x4093 = 0.035991,       r4094 = 27.7847239587675,       z4095 = 27.7847239587675,       n4096 = 0.027,       x4097 = 0.027,       j4098      = 0.001,       i4099   = 0.0005;    function p162(rgb)  {                     return l4081 * Math.pow(rgb[0], d4080)           + t4082 * Math.pow(rgb[1], d4080)          + i4083 * Math.pow(rgb[2], d4080); }    function r163(s164, h165) {     let t4100           = 0;      let k4101 = 0;       s164 =          s164 > m4088          ? s164          : s164 + Math.pow(m4088 - s164, v4089);              h165 =          h165 > m4088          ? h165          : h165 + Math.pow(m4088 - h165, v4089);      if (Math.abs(h165 - s164) < i4099)           return 0;        if (h165 > s164)      {           t4100 = (Math.pow(h165, x4084) - Math.pow(s164, f4085)) * n4090;          k4101 =              t4100 < j4098              ? 0              : t4100 < l4092               ? t4100 - t4100 * r4094 * n4096                : t4100 - n4096;     }      else      {           t4100 = (Math.pow(h165, r4087) - Math.pow(s164, r4086)) * s4091;          k4101 =              t4100 > -j4098              ? 0              : t4100 > -x4093                ? t4100 - t4100 * z4095 * x4097                : t4100 + x4097;     }       return k4101 * 100; }


function a133     (index) { return l131[index][0]; } function r4102(space) { return l131.findIndex(s => s[0] == space); }  function y4103(parse = null) {      const set = parse ? parse.settings : settings;      return set.m3634             ? l131.length         : l131.length - 5;  }    const q4104  = [255, 255, 255]; const g4105  = [360, 100, 100]; const e4106  = [360, 100, 100]; const u4107  = [100, 100, 100];      const d4108   = [255, 255, 255];    const t4109   = [360, 100, 100];   const k4110 = [360, 50,  100]; const h4111 = [360, 400, 100]; const x4112 = [360, 330, 100];     const a4113 = [100,  30,  30]; const t4114   = [100, 100, 100]; const e4115   = [100, 150, 150];     function l4116(space) {     switch (space)     {         case 'hex':         case 'rgb':   return q4104;          case 'hsv':         case 'hsl':   return g4105;          case 'hclok':         case 'hclab':         case 'hcluv': return e4106;          case 'oklab':           case 'lab':               case 'luv':   return u4107;                     default:      u947('invalid color factor from space \''+space+'\''); break;     } }    function u4117(col, space) {     let scale;      switch (space)     {         case 'hex':             case 'rgb':   scale = d4108;   break;          case 'hsv':             case 'hsl':   scale = t4109;   break;          case 'hclok': scale = k4110; break;         case 'hclab': scale = h4111; break;         case 'hcluv': scale = x4112; break;          case 'oklab': scale = a4113; break;         case 'lab':   scale = t4114;   break;         case 'luv':   scale = e4115;   break;     }      return [         col[0] * scale[0],         col[1] * scale[1],         col[2] * scale[2] ]; }    function d4118(rgb) {     return [ rgb[0] / 255,              rgb[1] / 255,              rgb[2] / 255 ]; }    function g4119(rgb) {     return [ Math.round(rgb[0] * 255),              Math.round(rgb[1] * 255),              Math.round(rgb[2] * 255) ]; }    function f4120(node, space) {     switch (space)     {         case 'hex':   n4122   (node); break;         case 'rgb':   x4123   (node); break;          case 'hsv':   q4124   (node); break;         case 'hsl':   h4125   (node); break;          case 'hclok': z4126 (node); break;         case 'hclab': h4127 (node); break;         case 'hcluv': k4128 (node); break;          case 'oklab': z4129 (node); break;         case 'lab':   v4130   (node); break;         case 'luv':   q4131   (node); break;     }      node.d4121(); }    function n4122  (node) { o4132   (node); o4142(node); } function x4123  (node) { o4132   (node);                        }  function q4124  (node) { e4133   (node, 'V');                   } function h4125  (node) { e4133   (node, 'L');                   }               function z4126(node) { g4134(node);                        } function h4127(node) { s4135(node);                        } function k4128(node) { t4136(node);                        }               function z4129(node) { v4137 (node, 'a', 'b');              } function v4130  (node) { s4138   (node, 'a', 'b');              } function q4131  (node) { q4139   (node, 'u', 'v');              }       function o4132(node) {     x4141(node,          'R', 0, d4108[0], '', false,          'G', 0, d4108[1],          'B', 0, d4108[2]);        node.v4146.k4248[0].min =      node.k4147.k4248[0].min =      node.e4148.k4248[0].min = Number.MIN_SAFE_INTEGER;       node.v4146.k4248[0].max =      node.k4147.k4248[0].max =      node.e4148.k4248[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);     }    function e4133(node, v_or_l)  {      x4141(node,          'H',    0, t4109[0], '°', true,           'S',    0, t4109[1],          v_or_l, 0, t4109[2]);        node.v4146.k4248[0].v803 = -4;      node.k4147.k4248[0].min =      node.e4148.k4248[0].min = Number.MIN_SAFE_INTEGER;       node.k4147.k4248[0].max =      node.e4148.k4248[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function switchToHclControls(node, scale)  {      x4141(node,          'H', 0, scale[0], '°', true,           'C', 0, scale[1],          'L', 0, scale[2]);        node.v4146.k4248[0].v803 = -4;      node.k4147.k4248[0].min =      node.e4148.k4248[0].min = Number.MIN_SAFE_INTEGER;       node.k4147.k4248[0].max =      node.e4148.k4248[0].max = Number.MAX_SAFE_INTEGER;       showRgbControlHex(node, false);  }    function g4134(node) { switchToHclControls(node, k4110); } function s4135(node) { switchToHclControls(node, h4111); } function t4136(node) { switchToHclControls(node, x4112); }    function b4140(node, c2, c3, scale) {      x4141(node,          'L', 0,        scale[0], '', false,           c2, -scale[1], scale[1],          c3, -scale[2], scale[2]);        showRgbControlHex(node, false);  }    function v4137(node) { b4140(node, 'a', 'b', a4113); } function s4138  (node) { b4140(node, 'a', 'b', t4114  ); } function q4139  (node) { b4140(node, 'u', 'v', e4115  ); }    function showRgbControlHex(node, show) {     node.v4146.k4248[0].y3975 = show;     node.k4147.k4248[0].y3975 = show;     node.e4148.k4248[0].y3975 = show; }    function x4141(node, c1, c1min, c1max, c1suffix, c1wrap, c2, c2min, c2max, c3, c3min, c3max) {     s4143(node);      node.v4146.x2927(c1, false);      node.k4147.x2927(c2, false);      node.e4148.x2927(c3, false);      node.v4146.k4248[0].i801 = c1wrap;     node.v4146.k4248[0].setSuffix(c1suffix, c1suffix != '');      node.v4146.k4248[0].q3093(c1min);      node.k4147.k4248[0].q3093(c2min);     node.e4148.k4248[0].q3093(c3min);          node.v4146.k4248[0].h3094(c1max);      node.k4147.k4248[0].h3094(c2max);      node.e4148.k4248[0].h3094(c3max);           node.v4146.f2806();     node.k4147.f2806();     node.e4148.f2806();      node.v4146.k4248[0].v803 = 0; }    function o4142(node) {     g4145(node);      m1473(node.v4146.div, node.m4149);     m1473(node.k4147.div, node.m4149);     m1473(node.e4148.div, node.m4149);              q1472(node.n4150.div, node.m4149); }    function k4144(node) {     g4145(node);      m1473(node.v4146.div,     node.m4149);     m1473(node.k4147.div,     node.m4149);     m1473(node.e4148.div,     node.m4149);          m1473(node.n4150.div, node.m4149); }    function g4145(node) {     for (let i = node.inputs.length-1; i >= 2; i--)         if (node.inputs[i].connected)             i2581(node.inputs[i]);      for (let i = node.outputs.length-1; i >= 2; i--)         for (const input of node.outputs[i].t4151)             i2581(input); }    function s4143(node) {     m1473(node.n4150.div, node.m4149);      q1472(node.v4146.div, node.m4149);     q1472(node.k4147.div, node.m4149);     q1472(node.e4148.div, node.m4149); }    function l146(rgb) {     return [        'rgb',         rgb[0],         rgb[1],         rgb[2] ]; }    function c4153(value, space, r128) {     switch (space)     {         case 'hex':         case 'rgb':   return d4154(value, r128);          case 'hsv':            case 'hsl':   return p4155 (value, r128);          case 'hclok':          case 'hclab':          case 'hcluv': return u4157 (value, r128);          case 'oklab':           case 'lab':             case 'luv':   return x4156 (value, r128);     } }    function d4154(value, r128) {     switch (r128)     {         case 0: return value / q4104[0];         case 1: return value / q4104[1];          case 2: return value / q4104[2];     } }    function p4155(value, r128) {     switch (r128)     {         case 0: return value / g4105[0];         case 1: return value / g4105[1];          case 2: return value / g4105[2];     } }    function x4156(value, r128) {     switch (r128)     {         case 0: return value / u4107[0];         case 1: return value / u4107[1];          case 2: return value / u4107[2];     } }    function u4157(value, r128) {     switch (r128)     {         case 0: return value / e4106[0];         case 1: return value / e4106[1];          case 2: return value / e4106[2];     } }    function h4158(color) {     return j4159(         color[0],          color[1],          color[2],          color[3]) }    function j4159(space, c1, c2, c3) {     switch (space)     {         case 'hex':         case 'rgb':   return h4160(c1, c2, c3);          case 'hsv':            case 'hsl':   return x4161(c1, c2, c3);          case 'hclok':          case 'hclab':          case 'hcluv': return k4162(c1, c2, c3);          case 'oklab':          case 'lab':          case 'luv':   return d4163(c1, c2, c3);     } }    function h4160(c1, c2, c3) {     return [         c1 / q4104[0],          c2 / q4104[1],          c3 / q4104[2]]; }    function x4161(c1, c2, c3) {     return [         c1 / g4105[0],          c2 / g4105[1],          c3 / g4105[2]]; }    function k4162(c1, c2, c3) {     return [         c1 / e4106[0],          c2 / e4106[1],          c3 / e4106[2]]; }    function d4163(c1, c2, c3) {     return [         c1 / u4107[0],          c2 / u4107[1],          c3 / u4107[2]]; }    function x4164(color) {     switch (color[0])     {         case 'hex':         case 'rgb':   return t4165(         color[1], color[2], color[3]);          case 'hsv':   return s4166('hsv',   color[1], color[2], color[3]);         case 'hsl':   return s4166('hsl',   color[1], color[2], color[3]);          case 'hclok': return t4167('hclok', color[1], color[2], color[3]);         case 'hclab': return t4167('hclab', color[1], color[2], color[3]);         case 'hcluv': return t4167('hcluv', color[1], color[2], color[3]);          case 'oklab': return u4168('oklab', color[1], color[2], color[3]);         case 'lab':   return u4168('lab',   color[1], color[2], color[3]);         case 'luv':   return u4168('luv',   color[1], color[2], color[3]);     } }    function t4165(c1, c2, c3) {     return [        'rgb',         c1 * q4104[0],          c2 * q4104[1],          c3 * q4104[2] ]; }    function s4166(space, c1, c2, c3) {     return [         space,         c1 * g4105[0],          c2 * g4105[1],          c3 * g4105[2] ]; }    function t4167(space, c1, c2, c3) {     return [         space,         c1 * e4106[0],          c2 * e4106[1],          c3 * e4106[2] ]; }    function u4168(space, c1, c2, c3) {     return [         space,         c1 * u4107[0],          c2 * u4107[1],          c3 * u4107[2] ]; }    function e3176(node, color) {     const x3177 = a133(node.v3172.value);     node.m3170   = n4173(color, x3177);      node.v3458(node.m3170); }    function a4169(space) {     switch (space)     {         case 'hex':         case 'rgb':   return q4104;          case 'hsv':            case 'hsl':   return g4105;          case 'hclok':          case 'hclab':          case 'hcluv': return e4106;          case 'oklab':          case 'lab':          case 'luv':   return u4107;     }     }    function k4170(space) {     switch (space)     {         case 'hex':         case 'rgb':   return d4108;          case 'hsv':            case 'hsl':   return t4109;          case 'hclok': return k4110;         case 'hclab': return h4111;         case 'hcluv': return x4112;          case 'oklab': return a4113;         case 'lab':   return t4114;         case 'luv':   return e4115;     }     }


function q4171(color) {     return [         color[1],          color[2],          color[3]]; }    function c4172(color) {     const col = q4171(color);      switch (color[0])     {         case 'hex':         case 'rgb':   return           col;          case 'hsv':   return r54  (col);         case 'hsl':   return q50  (col);          case 'hclok': return z34(col);         case 'hclab': return b40(col);         case 'hcluv': return l44(col);          case 'oklab': return o3959(col);         case 'lab':   return b56  (col);         case 'luv':   return v3952  (col);     } }    function n4173(color, x3177) {     switch (x3177)     {         case 'hex':             case 'rgb':   return f4174    (color);          case 'hsv':   return i4175    (color);         case 'hsl':   return o4176    (color);          case 'hclok': return l4180  (color);         case 'hclab': return o4181  (color);         case 'hcluv': return c4182  (color);          case 'oklab': return u4177(color);         case 'lab':   return m4178    (color);         case 'luv':   return k4179    (color);     } }    function f4174(x4183) {     const col = q4171(x4183);      let rgb;      switch (x4183[0])     {         case 'hex':         case 'rgb':   rgb =           col;  break;          case 'hsv':   rgb = r54  (col); break;         case 'hsl':   rgb = q50  (col); break;          case 'hclok': rgb = z34(col); break;         case 'hclab': rgb = b40(col); break;         case 'hcluv': rgb = l44(col); break;          case 'oklab': rgb = o3959(col); break;         case 'lab':   rgb = b56  (col); break;         case 'luv':   rgb = v3952  (col); break;     }      return l146(rgb); }    function i4175(x4183) {     const col = q4171(x4183);          let hsv;          switch (x4183[0])     {         case 'hex':         case 'rgb':   hsv = w52(          col ); break;          case 'hsv':   hsv =                   col;   break;         case 'hsl':   hsv = w52(q50  (col)); break;          case 'hclok': hsv = w52(z34(col)); break;         case 'hclab': hsv = w52(b40(col)); break;         case 'hcluv': hsv = w52(l44(col)); break;          case 'oklab': hsv = w52(o3959(col)); break;         case 'lab':   hsv = w52(b56  (col)); break;         case 'luv':   hsv = w52(v3952  (col)); break;     }          if (isNaN(hsv[0]))         hsv[0] = 5/6;          return [        'hsv',         hsv[0],         hsv[1],         hsv[2] ]; }    function o4176(x4183) {     const col = q4171(x4183);      let hsl;      switch (x4183[0])     {         case 'hex':         case 'rgb':   hsl = d48(          col ); break;          case 'hsv':   hsl = d48(r54  (col)); break;         case 'hsl':   hsl =                   col;   break;          case 'hclok': hsl = d48(z34(col)); break;         case 'hclab': hsl = d48(b40(col)); break;         case 'hcluv': hsl = d48(l44(col)); break;          case 'oklab': hsl = d48(o3959(col)); break;         case 'lab':   hsl = d48(b56  (col)); break;         case 'luv':   hsl = d48(v3952  (col)); break;     }      return [        'hsl',         hsl[0],         hsl[1],         hsl[2] ]; }    function u4177(x4183) {     const col = q4171(x4183);      let lab;      switch (x4183[0])     {         case 'hex':         case 'rgb':   lab = d3955(          col ); break;          case 'hsv':   lab = d3955(r54  (col)); break;         case 'hsl':   lab = d3955(q50  (col)); break;          case 'hclok': lab = d3955(z34(col)); break;         case 'hclab': lab = d3955(b40(col)); break;         case 'hcluv': lab = d3955(l44(col)); break;          case 'oklab': lab =                     col;   break;         case 'lab':   lab = d3955(b56  (col)); break;         case 'luv':   lab = d3955(v3952  (col)); break;     }      return [        'oklab',         lab[0],         lab[1],         lab[2] ]; }    function m4178(x4183) {     const col = q4171(x4183);      let lab;      switch (x4183[0])     {         case 'hex':         case 'rgb':   lab = l55(          col ); break;          case 'hsv':   lab = l55(r54  (col)); break;         case 'hsl':   lab = l55(q50  (col)); break;          case 'hclok': lab = l55(z34(col)); break;         case 'hclab': lab =         r39(col);  break;         case 'hcluv': lab = l55(l44(col)); break;          case 'oklab': lab = l55(o3959(col)); break;         case 'lab':   lab =                   col;   break;         case 'luv':   lab = l55(v3952  (col)); break;     }      return [        'lab',         lab[0],         lab[1],         lab[2] ]; }    function k4179(x4183) {     const col = q4171(x4183);      let luv;      switch (x4183[0])     {         case 'hex':         case 'rgb':   luv = z3951(          col ); break;          case 'hsv':   luv = z3951(r54  (col)); break;         case 'hsl':   luv = z3951(q50  (col)); break;          case 'hclok': luv = z3951(z34(col)); break;         case 'hclab': luv = z3951(b40(col)); break;         case 'hcluv': luv =         l43(col);  break;          case 'oklab': luv = z3951(o3959(col)); break;         case 'lab':   luv = z3951(b56  (col)); break;         case 'luv':   luv =                   col;   break;     }      return [        'luv',         luv[0],         luv[1],         luv[2] ]; }    function l4180(x4183) {     const col = q4171(x4183);      let hcl;      switch (x4183[0])     {         case 'hex':         case 'rgb':   hcl = t37(          col);  break;          case 'hsv':   hcl = t37(r54  (col)); break;         case 'hsl':   hcl = t37(q50  (col)); break;          case 'hclok': hcl =                     col;   break;         case 'hclab': hcl = t37(b40(col)); break;         case 'hcluv': hcl = t37(l44(col)); break;          case 'oklab': hcl = t37(o3959(col)); break;         case 'lab':   hcl = t37(b56  (col)); break;         case 'luv':   hcl = t37(v3952  (col)); break;     }      return [        'hclok',         hcl[0],         hcl[1],         hcl[2] ]; }    function o4181(x4183) {     const col = q4171(x4183);      let lab;      switch (x4183[0])     {         case 'hex':         case 'rgb':   lab = b42(          col) ; break;                  case 'hsv':   lab = b42(r54  (col)); break;         case 'hsl':   lab = b42(q50  (col)); break;                  case 'hclok': lab = b42(z34(col)); break;         case 'hclab': lab =                     col;   break;         case 'hcluv': lab = b42(l44(col)); break;                  case 'oklab': lab = b42(o3959(col)); break;         case 'lab':   lab = n41(          col ); break;         case 'luv':   lab = b42(v3952  (col)); break;     }      return [        'hclab',         lab[0],         lab[1],         lab[2] ]; }    function c4182(x4183) {     const col = q4171(x4183);      let hcl;      switch (x4183[0])     {         case 'hex':         case 'rgb':   hcl = k46(          col ); break;          case 'hsv':   hcl = k46(r54  (col)); break;         case 'hsl':   hcl = k46(q50  (col)); break;          case 'hclab': hcl = k46(b40(col)); break;         case 'hcluv': hcl =                     col;   break;         case 'hclok': hcl = k46(z34(col)); break;          case 'oklab': hcl = k46(o3959(col)); break;         case 'lab':   hcl = k46(b56  (col)); break;         case 'luv':   hcl = y45(          col ); break;     }      return [        'hcluv',         hcl[0],         hcl[1],         hcl[2] ]; }


</script>